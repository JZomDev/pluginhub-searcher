/*
 * Copyright (c) 2025, LordStrange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.runemessages;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;

@ConfigGroup("runemessages")
public interface RuneMessagesConfig extends Config
{
	@ConfigSection(
		name = "Display Settings",
		description = "Configure how messages are displayed",
		position = 0
	)
	String displaySection = "displaySection";

	@ConfigItem(
		keyName = "showOwnMessages",
		name = "Show Own Messages",
		description = "Display your own messages as markers",
		position = 1,
		section = displaySection
	)
	default boolean showOwnMessages()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showOtherMessages",
		name = "Show Other Players' Messages",
		description = "Display messages left by other players",
		position = 2,
		section = displaySection
	)
	default boolean showOtherMessages()
	{
		return true;
	}

	@ConfigItem(
		keyName = "displayRadius",
		name = "Message Display Radius",
		description = "How close you need to be to see the message text (in tiles)",
		position = 3,
		section = displaySection
	)
	@Range(min = 1, max = 20)
	default int displayRadius()
	{
		return 5;
	}

	@ConfigSection(
		name = "Sync Settings",
		description = "Configure message synchronization",
		position = 10
	)
	String syncSection = "syncSection";

	@ConfigItem(
		keyName = "syncMessages",
		name = "Sync Messages",
		description = "Share your messages with other players online",
		position = 11,
		section = syncSection
	)
	default boolean syncMessages()
	{
		return true;
	}

	@ConfigItem(
		keyName = "apiKey",
		name = "API Key",
		description = "Your unique API key",
		hidden = true
	)
	default String apiKey()
	{
		return "";
	}

	@ConfigItem(
		keyName = "registeredUsername",
		name = "Registered Username",
		description = "The username this API key is registered to",
		hidden = true
	)
	default String registeredUsername()
	{
		return "";
	}
}

/*
 * Copyright (c) 2025, LordStrange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.runemessages;

import com.google.inject.Provides;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;
import javax.inject.Inject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.Model;
import net.runelite.api.Player;
import net.runelite.api.RuneLiteObject;
import net.runelite.api.Tile;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.ChatMessageType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;

@Slf4j
@PluginDescriptor(
	name = "RuneMessages",
	description = "Leave messages for other players around the world",
	tags = {"rune", "message", "note", "sign", "communication"}
)
public class RuneMessagesPlugin extends Plugin
{
	private static final String VOTE_UP_OPTION = "Vote Up";
	private static final String VOTE_DOWN_OPTION = "Vote Down";
	private static final String EXAMINE_OPTION = "Examine";
	private static final String REPORT_OPTION = "Report";

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private RuneMessagesConfig config;

	@Inject
	private RuneMessagesService messageService;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private RuneMessagesOverlay overlay;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private ConfigManager configManager;

	private static final String CONFIG_GROUP = "runemessages";
	private static final int MAX_MESSAGES_PER_REGION = 30;
	private static final int TOP_VOTED_COUNT = 10;
	private static final int MAX_AUTHOR_MESSAGES_PER_REGION = 1;
	private static final int MAX_AUTHOR_MESSAGES_PER_WORLD = 5;

	@Getter
	private final Map<String, RuneLiteObject> spawnedGraves = new ConcurrentHashMap<>();

	@Getter
	private final Map<String, MessageData> messageDataMap = new ConcurrentHashMap<>();

	private final Set<Integer> loadedRegions = new HashSet<>();
	private final Set<String> votedMessages = new HashSet<>();
	private final Set<String> reportedMessages = new HashSet<>();

	// Cache of all messages per world+region (persists until logout)
	// Key format: "worldId:regionId"
	private final Map<String, List<MessageData>> regionMessageCache = new ConcurrentHashMap<>();

	// Track occupied tile locations to prevent duplicate messages at same spot
	private final Set<String> occupiedLocations = new HashSet<>();

	private RuneMessagesPanel messagePanel;
	private NavigationButton navButton;
	private boolean panelVisible = false;
	private boolean registrationAttempted = false;

	@Override
	protected void startUp() throws Exception
	{
		overlayManager.add(overlay);

		// Load API key from config
		String savedApiKey = config.apiKey();
		if (savedApiKey != null && !savedApiKey.isEmpty())
		{
			messageService.setApiKey(savedApiKey);
			log.debug("Loaded API key from config");
		}

		messagePanel = new RuneMessagesPanel(this);

		// Use a simple placeholder icon (16x16 gray square with darker border)
		BufferedImage icon = new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB);
		java.awt.Graphics2D g = icon.createGraphics();
		g.setColor(new java.awt.Color(80, 80, 80));
		g.fillRect(0, 0, 16, 16);
		g.setColor(new java.awt.Color(60, 60, 60));
		g.drawRect(0, 0, 15, 15);
		g.setColor(new java.awt.Color(200, 180, 100)); // Gold-ish cross
		g.drawLine(8, 3, 8, 12);
		g.drawLine(5, 6, 11, 6);
		g.dispose();

		navButton = NavigationButton.builder()
			.tooltip("RuneMessages")
			.icon(icon)
			.priority(10)
			.panel(messagePanel)
			.build();

		// Always show the navigation button
		clientToolbar.addNavigation(navButton);

		log.info("RuneMessages plugin started");
	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove(overlay);

		if (navButton != null)
		{
			clientToolbar.removeNavigation(navButton);
		}

		clearAllGraves();
		loadedRegions.clear();
		messageDataMap.clear();
		votedMessages.clear();
		reportedMessages.clear();
		regionMessageCache.clear();
		occupiedLocations.clear();

		log.info("RuneMessages plugin stopped");
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		if (event.getGameState() == GameState.LOGIN_SCREEN ||
			event.getGameState() == GameState.HOPPING)
		{
			clearAllGraves();
			loadedRegions.clear();
			messageDataMap.clear();
			regionMessageCache.clear();
			occupiedLocations.clear();
			registrationAttempted = false; // Allow re-registration on next login
			// Keep votedMessages and reportedMessages across hops to prevent abuse
		}
	}

	@Subscribe
	public void onGameTick(GameTick event)
	{
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		// Try to register if we haven't already
		if (!registrationAttempted)
		{
			// Check if we need to register: no API key OR username mismatch
			boolean needsRegistration = messageService.getApiKey() == null || messageService.getApiKey().isEmpty();

			if (!needsRegistration)
			{
				// Have API key, but check if username matches current player
				Player localPlayer = client.getLocalPlayer();
				if (localPlayer != null && localPlayer.getName() != null)
				{
					String savedUsername = config.registeredUsername();
					if (!savedUsername.isEmpty() && !savedUsername.equalsIgnoreCase(localPlayer.getName()))
					{
						// Different player logged in - need to re-register
						needsRegistration = true;
						log.info("Different player detected (saved: {}, current: {}), re-registering",
							savedUsername, localPlayer.getName());
					}
				}
			}

			if (needsRegistration)
			{
				registrationAttempted = true;
				tryRegister();
			}
			else
			{
				// API key valid and username matches - no need to register
				registrationAttempted = true;
			}
		}

		// Check for new regions and load messages
		int[] regions = client.getMapRegions();
		if (regions == null)
		{
			return;
		}

		int worldId = client.getWorld();

		// Convert to set for easy lookup
		Set<Integer> currentRegions = new HashSet<>();
		for (int r : regions)
		{
			currentRegions.add(r);
		}

		// Clear regions that are no longer visible - this allows fresh loading when returning
		Set<Integer> regionsToRemove = new HashSet<>();
		for (Integer loadedRegion : loadedRegions)
		{
			if (!currentRegions.contains(loadedRegion))
			{
				regionsToRemove.add(loadedRegion);
			}
		}
		for (Integer regionToRemove : regionsToRemove)
		{
			loadedRegions.remove(regionToRemove);
			// Also clear the cache for this region
			String cacheKey = worldId + ":" + regionToRemove;
			regionMessageCache.remove(cacheKey);
		}

		// Clean up messages from regions no longer in view
		cleanupDistantMessages(currentRegions);

		// Load new regions
		for (int region : regions)
		{
			if (!loadedRegions.contains(region))
			{
				loadedRegions.add(region);
				loadMessagesForRegion(worldId, region);
			}
		}

		// Re-spawn graves that went out of view and came back
		refreshGraves();
	}

	/**
	 * Remove messages from regions that are no longer in view
	 */
	private void cleanupDistantMessages(Set<Integer> currentRegions)
	{
		List<String> messagesToRemove = new ArrayList<>();

		for (Map.Entry<String, MessageData> entry : messageDataMap.entrySet())
		{
			MessageData message = entry.getValue();
			if (!currentRegions.contains(message.getRegionId()))
			{
				messagesToRemove.add(entry.getKey());
			}
		}

		for (String messageId : messagesToRemove)
		{
			// Deactivate and remove the grave
			RuneLiteObject grave = spawnedGraves.remove(messageId);
			if (grave != null)
			{
				grave.setActive(false);
			}

			// Remove from message data and occupied locations
			MessageData data = messageDataMap.remove(messageId);
			if (data != null)
			{
				String locationKey = data.getX() + "," + data.getY() + "," + data.getPlane();
				occupiedLocations.remove(locationKey);
			}
		}

		if (!messagesToRemove.isEmpty())
		{
			log.debug("Cleaned up {} messages from distant regions", messagesToRemove.size());
		}
	}

	private void refreshGraves()
	{
		for (Map.Entry<String, MessageData> entry : messageDataMap.entrySet())
		{
			String messageId = entry.getKey();
			MessageData message = entry.getValue();

			RuneLiteObject existingGrave = spawnedGraves.get(messageId);

			// Check if grave needs to be re-spawned
			WorldPoint worldPoint = new WorldPoint(message.getX(), message.getY(), message.getPlane());
			LocalPoint localPoint = LocalPoint.fromWorld(client, worldPoint);

			if (localPoint == null)
			{
				// Location not in view - deactivate if active
				if (existingGrave != null && existingGrave.isActive())
				{
					existingGrave.setActive(false);
				}
			}
			else
			{
				// Location is in view
				if (existingGrave == null || !existingGrave.isActive())
				{
					// Need to re-spawn
					if (existingGrave != null)
					{
						existingGrave.setActive(false);
						spawnedGraves.remove(messageId);
					}
					spawnGrave(message);
				}
				else
				{
					// Grave exists and is active - update location in case it shifted
					existingGrave.setLocation(localPoint, message.getPlane());
				}
			}
		}
	}

	private void tryRegister()
	{
		Player localPlayer = client.getLocalPlayer();
		if (localPlayer == null || localPlayer.getName() == null)
		{
			registrationAttempted = false; // Retry later
			return;
		}

		String username = localPlayer.getName();
		String savedUsername = config.registeredUsername();

		// Check if already registered with a different username
		if (!savedUsername.isEmpty() && !savedUsername.equalsIgnoreCase(username))
		{
			// Different user - need to re-register
			log.info("Different user detected, re-registering for RuneMessages");
		}

		log.info("Registering for RuneMessages as: {}", username);

		messageService.register(username)
			.thenAccept(apiKey -> {
				// Save to config
				configManager.setConfiguration(CONFIG_GROUP, "apiKey", apiKey);
				configManager.setConfiguration(CONFIG_GROUP, "registeredUsername", username);
				log.info("Successfully registered for RuneMessages");

				clientThread.invokeLater(() -> {
					sendChatMessage("RuneMessages: Registered successfully!");
				});
			})
			.exceptionally(ex -> {
				log.warn("Failed to register for RuneMessages: {}", ex.getMessage());
				clientThread.invokeLater(() -> {
					sendChatMessage("RuneMessages: Registration failed. Messages will be local only.");
				});
				return null;
			});
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event)
	{
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		// Add menu options for spawned messages (right-click on ground near message)
		addMessageMenuOptions(event);
	}

	private void addMessageMenuOptions(MenuEntryAdded event)
	{
		// Check for WALK menu action (like ground markers plugin does)
		MenuAction menuAction = event.getMenuEntry().getType();
		if (menuAction != MenuAction.WALK)
		{
			return;
		}

		// Get the world view
		int worldViewId = event.getMenuEntry().getWorldViewId();
		WorldView wv = client.getWorldView(worldViewId);
		if (wv == null)
		{
			return;
		}

		// Get the selected/hovered tile
		Tile selectedTile = wv.getSelectedSceneTile();
		if (selectedTile == null)
		{
			return;
		}

		// Get the world point of the selected tile
		WorldPoint selectedWorldPoint = selectedTile.getWorldLocation();
		if (selectedWorldPoint == null)
		{
			return;
		}

		// Check if we already added message options
		MenuEntry[] entries = client.getMenuEntries();
		for (MenuEntry entry : entries)
		{
			if (EXAMINE_OPTION.equals(entry.getOption()) && entry.getTarget().contains("'s Message"))
			{
				return; // Already added
			}
		}

		// Find message at this tile using world coordinates
		MessageData nearbyMessage = findMessageAtWorldPoint(selectedWorldPoint);
		if (nearbyMessage == null)
		{
			return;
		}

		String messageTarget = "<col=ffff00>" + nearbyMessage.getAuthor() + "'s Message</col>";

		// Add Examine option
		client.createMenuEntry(-1)
			.setOption(EXAMINE_OPTION)
			.setTarget(messageTarget)
			.setType(MenuAction.RUNELITE)
			.onClick(e -> examineMessage(nearbyMessage));

		// Add Vote Up option
		client.createMenuEntry(-1)
			.setOption(VOTE_UP_OPTION)
			.setTarget(messageTarget)
			.setType(MenuAction.RUNELITE)
			.onClick(e -> voteMessage(nearbyMessage, true));

		// Add Vote Down option
		client.createMenuEntry(-1)
			.setOption(VOTE_DOWN_OPTION)
			.setTarget(messageTarget)
			.setType(MenuAction.RUNELITE)
			.onClick(e -> voteMessage(nearbyMessage, false));

		// Add Report option
		client.createMenuEntry(-1)
			.setOption(REPORT_OPTION)
			.setTarget(messageTarget)
			.setType(MenuAction.RUNELITE)
			.onClick(e -> reportMessage(nearbyMessage));
	}

	private MessageData findMessageAtWorldPoint(WorldPoint worldPoint)
	{
		// Check each message to see if it's at this world point
		for (Map.Entry<String, MessageData> entry : messageDataMap.entrySet())
		{
			MessageData message = entry.getValue();
			if (message == null)
			{
				continue;
			}

			// Compare world coordinates directly
			if (message.getX() == worldPoint.getX() &&
				message.getY() == worldPoint.getY() &&
				message.getPlane() == worldPoint.getPlane())
			{
				return message;
			}
		}

		return null;
	}

	private void examineMessage(MessageData message)
	{
		if (message == null)
		{
			return;
		}

		java.text.SimpleDateFormat dateFormat = new java.text.SimpleDateFormat("dd/MMM/yyyy");
		String dateStr = dateFormat.format(new java.util.Date(message.getTimestamp()));

		String chatMessage = new ChatMessageBuilder()
			.append("Message from ")
			.append(ColorScheme.PROGRESS_COMPLETE_COLOR, message.getAuthor())
			.append(" on " + dateStr)
			.append(": \"")
			.append(ColorScheme.GRAND_EXCHANGE_ALCH, message.getMessage())
			.append("\"")
			.build();

		chatMessageManager.queue(QueuedMessage.builder()
			.type(ChatMessageType.CONSOLE)
			.runeLiteFormattedMessage(chatMessage)
			.build());
	}

	private void voteMessage(MessageData message, boolean thumbsUp)
	{
		if (message == null)
		{
			return;
		}

		// Check if already voted on this message
		if (votedMessages.contains(message.getId()))
		{
			String chatMsg = new ChatMessageBuilder()
				.append(ColorScheme.PROGRESS_ERROR_COLOR, "You have already voted on this message.")
				.build();

			chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.CONSOLE)
				.runeLiteFormattedMessage(chatMsg)
				.build());
			return;
		}

		messageService.rateMessage(message, thumbsUp)
			.thenRun(() ->
			{
				votedMessages.add(message.getId());
				String voteType = thumbsUp ? "up" : "down";
				log.info("Voted {} on message: {}", voteType, message.getId());

				String chatMsg = new ChatMessageBuilder()
					.append(ColorScheme.PROGRESS_COMPLETE_COLOR, "Vote recorded!")
					.build();

				chatMessageManager.queue(QueuedMessage.builder()
					.type(ChatMessageType.CONSOLE)
					.runeLiteFormattedMessage(chatMsg)
					.build());
			})
			.exceptionally(ex ->
			{
				log.warn("Failed to vote on message: {}", ex.getMessage());
				return null;
			});
	}

	private void reportMessage(MessageData message)
	{
		if (message == null)
		{
			return;
		}

		// Check if already reported this message
		if (reportedMessages.contains(message.getId()))
		{
			String chatMsg = new ChatMessageBuilder()
				.append(ColorScheme.PROGRESS_ERROR_COLOR, "You have already reported this message.")
				.build();

			chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.CONSOLE)
				.runeLiteFormattedMessage(chatMsg)
				.build());
			return;
		}

		// Get reporter's name
		Player localPlayer = client.getLocalPlayer();
		String reporterName = localPlayer != null ? localPlayer.getName() : "Unknown";

		messageService.reportMessage(message, reporterName)
			.thenRun(() ->
			{
				reportedMessages.add(message.getId());

				String chatMsg = new ChatMessageBuilder()
					.append(ColorScheme.PROGRESS_ERROR_COLOR, "Message has been reported.")
					.build();

				chatMessageManager.queue(QueuedMessage.builder()
					.type(ChatMessageType.CONSOLE)
					.runeLiteFormattedMessage(chatMsg)
					.build());
			})
			.exceptionally(ex ->
			{
				log.warn("Failed to report message: {}", ex.getMessage());
				return null;
			});
	}

	/**
	 * Called from the message panel when user submits a message
	 */
	public void submitMessage(String message, MarkerType markerType)
	{
		if (message == null || message.trim().isEmpty())
		{
			return;
		}

		final String trimmedMessage = message.trim();
		final MarkerType selectedMarker = markerType != null ? markerType : MarkerType.NOTE;

		// Must run on client thread to access game state
		clientThread.invokeLater(() ->
		{
			Player localPlayer = client.getLocalPlayer();
			if (localPlayer == null)
			{
				sendChatMessage("You must be logged in to write a message!");
				return;
			}

			WorldPoint location = localPlayer.getWorldLocation();
			String author = localPlayer.getName();
			int worldId = client.getWorld();

			saveAndSpawnMessage(trimmedMessage, location, author, worldId, selectedMarker);
		});
	}

	/**
	 * Get current world ID (for panel to fetch messages)
	 */
	public int getCurrentWorldId()
	{
		return client.getWorld();
	}

	/**
	 * Get current player name
	 */
	public String getCurrentPlayerName()
	{
		Player localPlayer = client.getLocalPlayer();
		return localPlayer != null ? localPlayer.getName() : null;
	}

	/**
	 * Get the message service for fetching player's messages
	 */
	public RuneMessagesService getMessageService()
	{
		return messageService;
	}

	/**
	 * Close/hide the message panel (called from cancel button)
	 */
	public void closeMessagePanel()
	{
		// Panel stays in navigation, just clears the input via cancel()
		// No additional action needed as the navButton keeps panel accessible
	}

	/**
	 * Remove a message from the world (called after successful API delete)
	 */
	public void removeMessage(String messageId)
	{
		clientThread.invokeLater(() -> {
			// Remove the grave object
			RuneLiteObject grave = spawnedGraves.remove(messageId);
			if (grave != null)
			{
				grave.setActive(false);
			}

			// Remove from message data
			MessageData data = messageDataMap.remove(messageId);

			// Remove from occupied locations
			if (data != null)
			{
				String locationKey = data.getX() + "," + data.getY() + "," + data.getPlane();
				occupiedLocations.remove(locationKey);
			}

			// Remove from region cache
			for (List<MessageData> messages : regionMessageCache.values())
			{
				messages.removeIf(m -> m.getId().equals(messageId));
			}

			sendChatMessage("Message deleted successfully!");
		});
	}

	private void saveAndSpawnMessage(String message, WorldPoint location, String author, int worldId, MarkerType markerType)
	{
		int modelId = markerType.getModelId();
		String locationKey = location.getX() + "," + location.getY() + "," + location.getPlane();

		// Check if there's already a message at this location locally
		if (occupiedLocations.contains(locationKey))
		{
			sendChatMessage("You cannot place a message here - this spot is already taken!");
			return;
		}

		if (config.syncMessages())
		{
			// Check if we have an API key
			if (messageService.getApiKey() == null || messageService.getApiKey().isEmpty())
			{
				sendChatMessage("Not registered yet. Please wait for registration to complete.");
				return;
			}

			// Save via API - it handles rate limiting and returns errors
			messageService.saveMessage(location, message.trim(), author, worldId, modelId)
				.thenAccept(data ->
				{
					clientThread.invokeLater(() ->
					{
						if (spawnGrave(data))
						{
							messageDataMap.put(data.getId(), data);
							occupiedLocations.add(locationKey);
							sendChatMessage("Message placed successfully!");
						}
					});
				})
				.exceptionally(ex ->
				{
					String errorMsg = ex.getCause() != null ? ex.getCause().getMessage() : ex.getMessage();
					log.warn("Failed to save message: {}", errorMsg);
					clientThread.invokeLater(() ->
						sendChatMessage(errorMsg)
					);
					return null;
				});
		}
		else
		{
			// Local only - no limits
			MessageData localData = MessageData.builder()
				.id("local-" + System.currentTimeMillis())
				.author(author)
				.message(message.trim())
				.x(location.getX())
				.y(location.getY())
				.plane(location.getPlane())
				.worldId(worldId)
				.regionId(location.getRegionID())
				.timestamp(System.currentTimeMillis())
				.modelId(modelId)
				.build();
			if (spawnGrave(localData))
			{
				messageDataMap.put(localData.getId(), localData);
				occupiedLocations.add(locationKey);
				sendChatMessage("Message placed locally (sync disabled).");
			}
		}
	}

	private void sendChatMessage(String message)
	{
		String chatMessage = new ChatMessageBuilder()
			.append(ColorScheme.PROGRESS_COMPLETE_COLOR, "[RuneMessages] ")
			.append(message)
			.build();

		chatMessageManager.queue(QueuedMessage.builder()
			.type(ChatMessageType.CONSOLE)
			.runeLiteFormattedMessage(chatMessage)
			.build());
	}

	private void loadMessagesForRegion(int worldId, int regionId)
	{
		if (!config.showOtherMessages())
		{
			return;
		}

		// Always fetch fresh from API - this ensures random selection each visit
		messageService.getMessagesForRegion(worldId, regionId)
			.thenAccept(messages ->
			{
				// Store temporarily for spawning
				String cacheKey = worldId + ":" + regionId;
				regionMessageCache.put(cacheKey, new ArrayList<>(messages));

				clientThread.invokeLater(() -> spawnMessagesFromCache(worldId, regionId));
			})
			.exceptionally(ex ->
			{
				log.warn("Failed to load messages for region {}: {}", regionId, ex.getMessage());
				return null;
			});
	}

	private void spawnMessagesFromCache(int worldId, int regionId)
	{
		String cacheKey = worldId + ":" + regionId;
		List<MessageData> allMessages = regionMessageCache.get(cacheKey);
		if (allMessages == null || allMessages.isEmpty())
		{
			return;
		}

		Player localPlayer = client.getLocalPlayer();
		String localPlayerName = localPlayer != null ? localPlayer.getName() : "";

		// Separate own messages from others - own messages ALWAYS load first
		List<MessageData> ownMessages = new ArrayList<>();
		List<MessageData> otherMessages = new ArrayList<>();

		for (MessageData msg : allMessages)
		{
			// CRITICAL: Verify message belongs to this world
			if (msg.getWorldId() != worldId)
			{
				log.warn("Message {} has worldId {} but expected {}",
					msg.getId(), msg.getWorldId(), worldId);
				continue;
			}
			// CRITICAL: Verify message belongs to this region
			if (msg.getRegionId() != regionId)
			{
				log.warn("Message {} has regionId {} but expected {}",
					msg.getId(), msg.getRegionId(), regionId);
				continue;
			}
			// Skip already spawned
			if (spawnedGraves.containsKey(msg.getId()))
			{
				continue;
			}

			// Separate own vs other messages
			if (msg.getAuthor().equalsIgnoreCase(localPlayerName))
			{
				if (config.showOwnMessages())
				{
					ownMessages.add(msg);
				}
			}
			else
			{
				otherMessages.add(msg);
			}
		}

		// ALWAYS spawn player's own messages first (no limit)
		int ownSpawned = 0;
		for (MessageData msg : ownMessages)
		{
			String locationKey = msg.getX() + "," + msg.getY() + "," + msg.getPlane();
			if (occupiedLocations.contains(locationKey))
			{
				continue;
			}
			if (spawnGrave(msg))
			{
				messageDataMap.put(msg.getId(), msg);
				occupiedLocations.add(locationKey);
				ownSpawned++;
			}
		}

		// Now handle other players' messages with the voting algorithm
		if (otherMessages.isEmpty() || !config.showOtherMessages())
		{
			if (ownSpawned > 0)
			{
				log.debug("Loaded {} own messages for region {}", ownSpawned, regionId);
			}
			return;
		}

		// Sort by vote score (thumbsUp - thumbsDown) descending
		otherMessages.sort(Comparator.comparingInt(
			(MessageData m) -> m.getThumbsUp() - m.getThumbsDown()
		).reversed());

		// Take top 10 voted
		List<MessageData> topVoted = otherMessages.stream()
			.limit(TOP_VOTED_COUNT)
			.collect(Collectors.toList());

		// Get remaining messages (after top 10)
		List<MessageData> remaining = otherMessages.stream()
			.skip(TOP_VOTED_COUNT)
			.collect(Collectors.toList());

		// Shuffle the remaining and take up to (MAX - top10) random ones
		Collections.shuffle(remaining);
		int randomCount = Math.min(remaining.size(), MAX_MESSAGES_PER_REGION - topVoted.size());
		List<MessageData> randomPicks = remaining.stream()
			.limit(randomCount)
			.collect(Collectors.toList());

		// Combine: top voted + random picks
		List<MessageData> messagesToSpawn = new ArrayList<>();
		messagesToSpawn.addAll(topVoted);
		messagesToSpawn.addAll(randomPicks);

		// Spawn messages, avoiding duplicate locations
		int othersSpawned = 0;
		for (MessageData msg : messagesToSpawn)
		{
			String locationKey = msg.getX() + "," + msg.getY() + "," + msg.getPlane();

			// Skip if location already has a message
			if (occupiedLocations.contains(locationKey))
			{
				continue;
			}

			// Spawn the grave
			if (spawnGrave(msg))
			{
				messageDataMap.put(msg.getId(), msg);
				occupiedLocations.add(locationKey);
				othersSpawned++;
			}
		}

		if (ownSpawned > 0 || othersSpawned > 0)
		{
			log.debug("Loaded {} own + {} others for region {} (top {} voted + {} random)",
				ownSpawned, othersSpawned, regionId,
				Math.min(topVoted.size(), othersSpawned),
				Math.max(0, othersSpawned - topVoted.size()));
		}
	}

	private boolean spawnGrave(MessageData message)
	{
		WorldPoint worldPoint = new WorldPoint(message.getX(), message.getY(), message.getPlane());

		// Validate that the world point's region matches the stored region
		int computedRegion = worldPoint.getRegionID();
		if (computedRegion != message.getRegionId())
		{
			log.warn("Message {} coordinates ({},{}) compute to region {} but stored regionId is {}",
				message.getId(), message.getX(), message.getY(), computedRegion, message.getRegionId());
			return false;
		}

		LocalPoint localPoint = LocalPoint.fromWorld(client, worldPoint);

		if (localPoint == null)
		{
			log.debug("Cannot spawn grave - location not in view: {}", worldPoint);
			return false;
		}

		RuneLiteObject grave = client.createRuneLiteObject();
		Model model = client.loadModel(message.getModelId());

		if (model == null)
		{
			log.warn("Failed to load grave model {}", message.getModelId());
			return false;
		}

		grave.setModel(model);
		grave.setLocation(localPoint, message.getPlane());
		grave.setActive(true);

		spawnedGraves.put(message.getId(), grave);
		log.debug("Spawned grave for message {} at {}", message.getId(), worldPoint);
		return true;
	}

	private void despawnGrave(String messageId)
	{
		RuneLiteObject grave = spawnedGraves.remove(messageId);
		if (grave != null)
		{
			grave.setActive(false);
		}
		messageDataMap.remove(messageId);
	}

	private void clearAllGraves()
	{
		for (RuneLiteObject grave : spawnedGraves.values())
		{
			grave.setActive(false);
		}
		spawnedGraves.clear();
	}

	@Provides
	RuneMessagesConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(RuneMessagesConfig.class);
	}
}

/*
 * Copyright (c) 2025, LordStrange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.runemessages;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;

public class RuneMessagesPanel extends PluginPanel
{
	private static final int MAX_MESSAGE_LENGTH = 100;
	private static final Map<String, String[]> WORD_CATEGORIES = new LinkedHashMap<>();

	static
	{
		WORD_CATEGORIES.put("Actions", new String[] {
			"Try", "Beware of", "Watch out for", "Be wary of", "Seek", "Find", "Avoid",
			"Attack", "Don't attack", "Jump", "Roll", "Run", "Walk", "Sneak", "Hide",
			"Look", "Listen", "Wait", "Stop", "Go", "Turn", "Climb", "Fall", "Die",
			"Kill", "Slay", "Defeat", "Flee", "Escape", "Enter", "Exit", "Open", "Close",
			"Pull", "Push", "Grab", "Drop", "Use", "Equip", "Unequip", "Eat", "Drink",
			"Pray", "Teleport", "Bank", "Trade", "Buy", "Sell", "Steal", "Pickpocket",
			"Mine", "Chop", "Fish", "Cook", "Craft", "Smith", "Fletch", "Alch", "Splash",
			"Hop", "Log out", "Touch grass", "Git gud", "Panic buy", "Panic sell",
			"Trim armour", "Double money", "Trust trade", "Skull trick", "Lure",
			"Try thrusting", "Try holding with both hands", "Try finger", "Offer seed",
			"Offer pickle", "Try tongue", "Try rear", "Plunging attack", "Be wary of tight spot",
			"Try two-handing", "Thrust from behind", "Time for rolling", "Praise", "Beg"
		});
		WORD_CATEGORIES.put("Directions", new String[] {
			"ahead", "behind", "left", "right", "up", "down", "above", "below",
			"north", "south", "east", "west", "nearby", "far away", "around the corner",
			"through the door", "past the gate", "over there", "here", "somewhere",
			"in the corner", "at the edge", "in the middle", "on the path", "off the path",
			"underground", "upstairs", "downstairs", "inside", "outside", "beyond",
			"at Lumbridge", "at Varrock", "at Falador", "at Camelot", "at Ardougne",
			"in the Wilderness", "at the G.E.", "at the Grand Exchange", "Grand Exchange",
			"at the bank", "in the dungeon", "at the altar", "by the fountain",
			"near the tree", "by the rocks"
		});
		WORD_CATEGORIES.put("Things", new String[] {
			"enemy", "enemies", "boss", "monster", "creature", "NPC", "player",
			"treasure", "loot", "gold", "coins", "GP", "item", "drop", "rare drop",
			"weapon", "armour", "shield", "helmet", "sword", "bow", "staff", "wand",
			"rune", "runes", "bones", "ashes", "food", "potion", "prayer pot",
			"teleport", "portal", "door", "gate", "lever", "ladder", "stairs",
			"chest", "crate", "barrel", "rock", "tree", "bush", "flower",
			"trap", "pit", "spikes", "poison", "fire", "water", "lava",
			"dragon", "demon", "goblin", "guard", "wizard", "knight", "king", "queen",
			"cow", "chicken", "rat", "spider", "snake", "wolf", "bear", "unicorn",
			"slayer task", "clue scroll", "pet", "skilling pet", "boss pet",
			"ironman", "HCIM", "UIM", "GIM", "pure", "main", "alt", "bot",
			"noob", "pro", "chad", "legend", "king", "absolute unit",
			"hole", "but hole", "finger", "head", "rear", "chest", "rump",
			"fatty", "plump sort", "giant", "horse", "dog", "pickle", "seed",
			"lever", "key", "ring", "pole", "balls", "grass", "bush", "snake"
		});
		WORD_CATEGORIES.put("Food", new String[] {
			"lobster", "shark", "manta ray", "anglerfish", "dark crab", "tuna", "swordfish",
			"monkfish", "karambwan", "cooked karambwan", "sea turtle", "bass",
			"pizza", "anchovy pizza", "pineapple pizza", "wine", "jug of wine",
			"cake", "chocolate cake", "bread", "meat pie", "apple pie", "summer pie",
			"potato", "baked potato", "potato with cheese", "tuna potato", "sweetcorn",
			"cabbage", "onion", "tomato", "banana", "orange", "pineapple", "papaya",
			"strawberry", "watermelon", "grapes", "lemon", "lime", "coconut",
			"beer", "ale", "dwarven stout", "asgarnian ale", "wizards mind bomb",
			"kebab", "ugthanki kebab", "super kebab", "gnome food", "gnome cocktail",
			"purple sweets", "candy", "chocolate", "cheese", "egg", "flour", "milk"
		});
		WORD_CATEGORIES.put("Items", new String[] {
			// Weapons
			"bronze sword", "iron sword", "steel sword", "mithril sword", "adamant sword", "rune sword",
			"dragon sword", "dragon scimitar", "dragon longsword", "dragon dagger", "dragon claws",
			"abyssal whip", "abyssal dagger", "abyssal bludgeon", "abyssal tentacle",
			"crossbow", "rune crossbow", "dragon crossbow", "armadyl crossbow", "zaryte crossbow",
			"magic shortbow", "dark bow", "twisted bow", "bow of faerdhinen", "crystal bow",
			"trident", "trident of the swamp", "sanguinesti staff", "tumeken's shadow",
			"elder maul", "ghrazi rapier", "inquisitor's mace", "osmumten's fang",
			"scythe of vitur", "blade of saeldor", "saradomin sword", "zamorakian spear",
			// Armour
			"bronze armour", "iron armour", "steel armour", "mithril armour", "adamant armour", "rune armour",
			"dragon armour", "barrows armour", "bandos armour", "armadyl armour",
			"torva armour", "ancestral robes", "masori armour", "virtus robes", "justiciar armour",
			"fighter torso", "void knight", "graceful", "rogue outfit", "pyromancer",
			// Shields
			"dragon defender", "avernic defender", "dragonfire shield", "spectral shield", "arcane shield", "elysian shield",
			// Accessories
			"amulet of glory", "amulet of fury", "blood fury", "torture", "anguish", "tormented bracelet",
			"berserker ring", "archers ring", "seers ring", "warrior ring", "ring of suffering",
			"barrows gloves", "ferocious gloves", "zaryte vambraces",
			// Other items
			"spade", "rope", "lockpick", "knife", "tinderbox", "hammer", "chisel", "needle",
			"coins", "gold bar", "diamond", "dragonstone", "onyx", "zenyte",
			"bones", "dragon bones", "superior dragon bones", "wyvern bones",
			"herb", "ranarr", "snapdragon", "torstol", "dwarf weed",
			"potion", "super combat", "divine super combat", "overload", "antifire", "antivenom",
			"rune pouch", "looting bag", "seed box", "herb sack", "gem bag", "coal bag"
		});
		WORD_CATEGORIES.put("OSRS", new String[] {
			"RNG", "RNGesus", "XP", "XP waste", "efficiency", "tick perfect",
			"one tick", "two tick", "three tick", "prayer flick", "lazy flick",
			"spec", "DPS", "max hit", "accuracy", "defence", "prayer",
			"Bandos", "Armadyl", "Zamorak", "Saradomin", "Guthix", "Zaros",
			"AGS", "BGS", "SGS", "ZGS", "Godsword", "Scythe", "Tbow", "Bowfa",
			"Blowpipe", "Whip", "Tentacle", "Rapier", "Mace", "Fang",
			"Torva", "Ancestral", "Masori", "Virtus", "Justiciar",
			"Fire cape", "Infernal cape", "Assembler", "Imbued heart",
			"Zenyte", "Onyx", "Dragonstone", "Diamond", "Ruby", "Sapphire",
			"Zulrah", "Vorkath", "Hydra", "Cerberus", "Sire", "Kraken",
			"TOB", "COX", "TOA", "Inferno", "Fight caves", "Gauntlet",
			"Slayer", "Konar", "Duradel", "Nieve", "Turael", "Krystilia",
			"Runecrafting", "Agility", "Mining", "Farming", "Hunter",
			"Bird house", "Herb run", "Tree run", "Birdhouse run",
			"Bond", "Membership", "F2P", "P2P", "Ironman btw", "BTW",
			"spooned", "bricked", "dry", "dry streak", "go next", "on drop rate",
			"over drop rate", "1 kc", "pet luck", "log slot", "collection log",
			"max cape", "quest cape", "music cape", "achievement diary",
			"chompy hat", "golden tench", "tangleroot", "vorki", "jad pet",
			"zuk pet", "olmlet", "lil zik", "tumeken's guardian", "smolcano",
			"wildy", "rev caves", "corp", "nightmare", "nex", "phantom muspah",
			"tempoross", "wintertodt", "zalcano", "puro puro", "pyramid plunder",
			"barrows", "brothers", "blood runes", "wrath runes", "nature runes",
			"sand casino", "duel arena RIP", "staking", "cleaned", "bank made",
			"bank standing", "fashionscape", "drip", "BIS", "pre-BIS", "budget gear"
		});
		WORD_CATEGORIES.put("Feelings", new String[] {
			"danger", "safety", "victory", "defeat", "death", "life",
			"happiness", "sadness", "fear", "courage", "despair", "hope",
			"anger", "peace", "chaos", "order", "pain", "pleasure",
			"boredom", "excitement", "surprise", "shock", "awe", "disgust",
			"love", "hate", "friendship", "betrayal", "trust", "suspicion",
			"greed", "generosity", "envy", "pride", "shame", "glory",
			"madness", "sanity", "confusion", "clarity", "exhaustion", "energy",
			"tilt", "rage", "zen", "vibes", "mood", "feels"
		});
		WORD_CATEGORIES.put("Descriptors", new String[] {
			"amazing", "terrible", "good", "bad", "great", "awful", "best", "worst",
			"hidden", "secret", "obvious", "mysterious", "strange", "normal",
			"hard", "easy", "impossible", "simple", "complex", "tricky",
			"dangerous", "safe", "deadly", "harmless", "toxic", "blessed",
			"strong", "weak", "powerful", "pathetic", "mighty", "feeble",
			"fast", "slow", "quick", "sluggish", "instant", "eternal",
			"big", "small", "huge", "tiny", "massive", "minuscule",
			"hot", "cold", "warm", "freezing", "burning", "frozen",
			"dark", "light", "bright", "dim", "shadowy", "radiant",
			"old", "new", "ancient", "modern", "legendary", "common",
			"rare", "epic", "godly", "blessed", "cursed", "haunted",
			"sweaty", "casual", "tryhard", "chill", "intense", "relaxed",
			"based", "cringe", "poggers", "sadge", "pepega", "5head",
			"absolute", "utter", "pure", "complete", "total", "partial"
		});
		WORD_CATEGORIES.put("British", new String[] {
			"mate", "lad", "lass", "bloke", "chap", "geezer", "bruv", "fam",
			"bollocks", "bloody", "bugger", "blimey", "crikey", "cor",
			"brilliant", "rubbish", "naff", "dodgy", "cheeky", "proper",
			"knackered", "gobsmacked", "gutted", "chuffed", "miffed", "narked",
			"mental", "daft", "barmy", "bonkers", "crackers", "mental",
			"quid", "tenner", "fiver", "bob", "nicker", "brass",
			"cuppa", "brekkie", "sarnie", "butty", "chippy", "pub",
			"loo", "bog", "khazi", "toilet", "lavatory", "WC",
			"bum", "arse", "backside", "bottom", "rear", "behind",
			"innit", "init", "right", "yeah", "nah", "dunno",
			"wanker", "tosser", "muppet", "numpty", "plonker", "pillock",
			"sod off", "bugger off", "jog on", "do one", "get stuffed",
			"having a laugh", "taking the piss", "absolute legend", "top bloke",
			"cheers", "ta", "thanks", "lovely", "smashing", "cracking"
		});
		WORD_CATEGORIES.put("Memes", new String[] {
			"finger", "but hole", "dog", "try tongue", "offer seed",
			"visions of", "no", "yes", "why", "how", "when", "where",
			"praise the sun", "don't give up skeleton", "time for crab",
			"horse", "but hole", "try thrust", "offer pickle",
			"liar ahead", "try jumping", "hidden path", "illusory wall",
			"seek head", "behold", "O you don't have the right",
			"could this be a", "if only I had a", "didn't expect",
			"is this", "I can't take this", "let me solo her",
			"we go jim", "gains", "no XP waste", "efficiency scape",
			"buying GF", "trimming armour free", "doubling money",
			"sit", "get rekt", "EZ", "GG", "L", "W", "F", "Pog",
			"Kappa", "Keepo", "MonkaS", "PepeHands", "Copium", "Hopium",
			"sus", "amogus", "imposter", "sussy", "baka",
			"bruh", "oof", "yeet", "vibe check", "no cap", "bussin",
			"sheesh", "respectfully", "down bad", "touch grass",
			"least insane", "most sane", "average", "enjoyer", "fan",
			"73", "69", "420", "nice", "gamer moment", "skill issue",
			"KEKW", "OMEGALUL", "Sadge", "PogChamp", "Pepega", "5Head",
			"Jebaited", "LULW", "ICANT", "Clueless", "Aware", "modCheck",
			"Wicked", "actually", "real", "fr fr", "on god", "lowkey",
			"highkey", "deadass", "ngl", "tbh", "idk", "idc", "smh",
			"ratio", "L + ratio", "cope", "seethe", "mald", "touch grace",
			"maidenless", "no maidens", "tarnished", "git gud casul",
			"try fingers", "likely pickle", "gorgeous chest", "amazing rear",
			"be wary of fatty", "offer rump", "ahh head", "try head",
			"weakness: thrusting", "weakness: rear", "O you don't have the right",
			"first off you don't have the right", "seek god", "find grace"
		});
		WORD_CATEGORIES.put("Connectors", new String[] {
			"and", "or", "but", "so", "then", "therefore", "however",
			"the", "a", "an", "this", "that", "these", "those",
			"is", "are", "was", "were", "be", "been", "being",
			"I", "you", "he", "she", "it", "we", "they", "one",
			"my", "your", "his", "her", "its", "our", "their",
			"in", "on", "at", "to", "from", "with", "without",
			"for", "of", "by", "about", "between", "through",
			"before", "after", "during", "while", "until", "since",
			"if", "unless", "although", "because", "when", "where",
			"not", "no", "never", "always", "sometimes", "maybe",
			"very", "really", "quite", "rather", "somewhat", "extremely",
			"!", "?", "...", ",", ":", ";"
		});
		WORD_CATEGORIES.put("Messages", new String[] {
			"Good luck", "You can do it", "Don't give up", "Keep going",
			"Almost there", "So close", "One more try", "Believe",
			"You died", "Game over", "Try again", "Respawn",
			"Welcome", "Hello", "Goodbye", "See you", "Nice to meet you",
			"Thank you", "Sorry", "Excuse me", "Please", "Help",
			"Well done", "Congratulations", "GG", "Nice one", "Well played",
			"Be careful", "Watch your step", "Stay alert", "Stay safe",
			"Go back", "Wrong way", "Dead end", "No entry",
			"Follow me", "Wait here", "Come with me", "Stay close",
			"I was here", "Remember this", "Never forget", "Witness me",
			"First", "Last", "Only one", "The chosen one",
			"Praise be", "Blessed be", "May RNG be with you", "GL HF",
			"No pain no gain", "Risk it for the biscuit", "Send it",
			"LEROY JENKINS", "At least I have chicken"
		});
		WORD_CATEGORIES.put("Insults", new String[] {
			"noob", "scrub", "casual", "trash", "garbage", "bot",
			"gold buyer", "RWT", "account sharer", "boosted", "carried",
			"1 def pure brain", "smooth brain", "small brain", "no brain",
			"skill issue", "get good", "uninstall", "go back to Lumbridge",
			"deserved", "outplayed", "outclassed", "destroyed", "demolished",
			"sit", "sit down", "sit kid", "stay down", "L bozo", "ratio'd",
			"clapped", "slapped", "smacked", "deleted", "removed", "erased",
			"embarrassing", "shameful", "pathetic", "sad", "cringe",
			"maidenless behavior", "grass is outside", "touch grass",
			"least skilled", "weakest", "most mid", "below average",
			"no mechanics", "no hands", "keyboard player", "mobile gamer",
			"cope harder", "seethe more", "mald", "rent free", "living in your head",
			"free", "freebie", "thanks for the loot", "my loot now",
			"log out", "hop worlds", "wrong neighborhood", "my world"
		});
		WORD_CATEGORIES.put("Encouragement", new String[] {
			"You got this", "Believe in yourself", "You're doing great",
			"Keep grinding", "Stay focused", "Almost there", "So close",
			"One more try", "Never give up", "You can do it", "I believe",
			"Respect", "Well played", "Nice try", "Good effort", "Good attempt",
			"You'll get it", "Next time", "Go again", "Run it back",
			"Stay strong", "Keep going", "Don't stop", "Push through",
			"Worth it", "Grind pays off", "Patience", "Trust the process",
			"Future you will thank you", "For the log", "For the pet",
			"For the cape", "For the glory", "For the gains", "We go jim",
			"Strong", "Powerful", "Mighty", "Legendary", "Based", "Gigachad",
			"King behavior", "Queen behavior", "Main character", "Built different",
			"Different breed", "Not like the others", "One of a kind"
		});
		WORD_CATEGORIES.put("Cheeky", new String[] {
			// Classic Dark Souls double meanings
			"amazing chest ahead", "try chest", "praise the chest", "behold chest",
			"gorgeous view ahead", "nice view", "what a view", "stunning view",
			"try putting it in", "it won't fit", "tight fit ahead", "be wary of tight spot",
			"seek larger one", "smaller one ahead", "long one required", "short one ahead",
			"try licking", "licking required", "offer tongue", "use tongue",
			"try stroking", "stroking required", "be gentle", "go slow",
			"up and down", "in and out", "back and forth", "round and round",
			"try pulling out", "don't pull out", "push it in", "all the way in",
			"didn't expect hole", "likely hole", "behold hole", "seek hole",
			"weak to rear", "try rear entry", "attacking from behind", "behind is weak",
			"plump sort ahead", "fatty ahead", "be wary of fatty", "seek fatty",
			"time for mount", "mounting required", "try mounting", "be wary of mounting",
			"try using both hands", "both hands required", "two hands ahead",
			"time to get wet", "getting wet ahead", "moisture ahead", "slippery ahead",
			"praise the rump", "behold rump", "gorgeous rump", "seek rump",
			"time for seed", "offer seed", "seed required", "plant seed",
			"time for bone", "bone required", "big bone ahead", "seek bone",
			"time for eating out", "eating out ahead", "devouring ahead",
			"be wary of snake", "long snake ahead", "big snake", "one-eyed snake",
			"try head", "head required", "seek head", "offer head",
			"be wary of balls", "two balls ahead", "blue balls", "seek balls",
			"pole ahead", "grab pole", "long pole", "try pole",
			"time for wood", "wood required", "morning wood", "hard wood",
			// OSRS specific innuendos
			"examine my dragon", "wanna see my whip", "nice tentacle", "show me your staff",
			"check out my d long", "nice d scim", "grab my d pick", "examine my maul",
			"come to my POH", "visit my house", "use my altar", "enter my dungeon",
			"explore my cave", "I've got a big sack", "empty my sack", "fill my bag",
			"grinding bones all day", "give me your bone", "need bone service",
			"handling my tool", "polish my armor", "trim my armor for free",
			"show me your spec", "nice 2h you got there", "that's a big one",
			"let's see your shaft", "give me your essence", "seeking essence",
			"come use my pool", "restore at my house", "touch my dragonfire shield",
			"feel my barrows", "nice torso", "show me your void",
			"looking for head", "dragon head required", "KBD head wanted",
			"that's some nice wood", "chopping wood all night", "hard oak",
			"magic logs ahead", "seeking redwood", "got wood?",
			"come to my bank", "show me what you got", "nice drops",
			"thicc loot", "juicy drop", "fat stack", "show me your stack"
		});
		WORD_CATEGORIES.put("Famous People", new String[] {
			// Jagex Staff
			"Mod Ash", "God Ash", "The Ash", "Mod Archie", "Mod Arcane", "Mod Ayiza",
			"Mod Boko", "Mod Bruno", "Mod Curse", "Mod Ed", "Mod Elena", "Mod Goblin",
			"Mod Husky", "Mod Kieren", "Mod Light", "Mod Lottie", "Mod Mack",
			"Mod Oasis", "Mod Sarnie", "Mod Squid", "Mod Sween", "Mod Tide", "Mod West",
			"Mod Roq", "Mod Flippy", "Mod Abyss", "Mod Crystal", "Mod Daizong",
			// Legendary Players
			"Zezima", "Woox", "Lynx Titan", "Hey Jase", "Suomi",
			// Content Creators
			"B0aty", "Settled", "Swampletics", "C Engineer", "Mudkip", "Torvesta",
			"Framed", "Skill Specs", "A Friend", "Dovydas", "J1mmy", "9Rain",
			"SoloMission", "EVscape", "Tanzoo", "Virtoso", "Faux", "Sick Nerd",
			"Rendi", "Dino", "FlippingOldschool", "Alfie", "Odablock", "Purespam",
			"Mmorpg", "Theoatrix", "Slayermusiq1", "Soup", "Spookdog", "Jakeyosaurus",
			"KempQ", "Ricecup", "Vannaka", "Westham", "Gunschilli", "25 Buttholes",
			"Lower the Better", "Verf", "UIM Lenny", "xRakine", "WildMudkip",
			// Meme References
			"Durial321", "the Falador Massacre", "a Jmod", "a famous player",
			"a streamer", "a YouTuber", "a content creator", "a legend"
		});
	}

	private final RuneMessagesPlugin plugin;
	private final JTextArea messageInput;
	private final JLabel charCountLabel;
	private final JPanel wordButtonsPanel;
	private final JTextField searchField;
	private final JComboBox<String> categoryComboBox;
	private final JComboBox<MarkerType> markerTypeComboBox;
	private final JPanel myMessagesPanel;
	private final JLabel myMessagesStatusLabel;

	public RuneMessagesPanel(RuneMessagesPlugin plugin)
	{
		super(false);
		this.plugin = plugin;
		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARK_GRAY_COLOR);
		setBorder(new EmptyBorder(10, 10, 10, 10));

		JLabel titleLabel = new JLabel("<html><center>RuneMessages<br><font size='2' color='#AAAAAA'>by LordStrange</font></center></html>");
		titleLabel.setForeground(new Color(255, 215, 0));
		titleLabel.setHorizontalAlignment(SwingConstants.CENTER);
		titleLabel.setBorder(new EmptyBorder(0, 0, 10, 0));

		messageInput = new JTextArea(3, 20);
		messageInput.setLineWrap(true);
		messageInput.setWrapStyleWord(true);
		messageInput.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		messageInput.setForeground(new Color(255, 215, 0));
		messageInput.setEditable(false);
		messageInput.setFocusable(false);
		messageInput.setBorder(BorderFactory.createCompoundBorder(
			BorderFactory.createLineBorder(new Color(255, 215, 0, 100)),
			BorderFactory.createEmptyBorder(5, 5, 5, 5)
		));

		JScrollPane messageScrollPane = new JScrollPane(messageInput);
		messageScrollPane.setBorder(null);
		messageScrollPane.setPreferredSize(new Dimension(0, 60));

		charCountLabel = new JLabel("0 / " + MAX_MESSAGE_LENGTH);
		charCountLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);

		JButton deleteLastButton = new JButton("Undo");
		deleteLastButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		deleteLastButton.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		deleteLastButton.setFocusPainted(false);
		deleteLastButton.addActionListener(e -> deleteLastWord());

		JButton clearButton = new JButton("Clear");
		clearButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		clearButton.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		clearButton.setFocusPainted(false);
		clearButton.addActionListener(e -> { messageInput.setText(""); updateCharCount(); });

		JPanel buttonRow = new JPanel(new GridLayout(1, 2, 3, 0));
		buttonRow.setBackground(ColorScheme.DARK_GRAY_COLOR);
		buttonRow.add(deleteLastButton);
		buttonRow.add(clearButton);

		JPanel charCountPanel = new JPanel(new BorderLayout());
		charCountPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		charCountPanel.add(buttonRow, BorderLayout.WEST);
		charCountPanel.add(charCountLabel, BorderLayout.EAST);

		JPanel inputPanel = new JPanel(new BorderLayout(0, 5));
		inputPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		inputPanel.add(messageScrollPane, BorderLayout.CENTER);
		inputPanel.add(charCountPanel, BorderLayout.SOUTH);

		JPanel filterPanel = new JPanel(new BorderLayout(5, 0));
		filterPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		filterPanel.setBorder(new EmptyBorder(10, 0, 5, 0));

		searchField = new JTextField();
		searchField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		searchField.setForeground(Color.WHITE);
		searchField.setCaretColor(Color.WHITE);
		searchField.setBorder(BorderFactory.createCompoundBorder(
			BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR),
			BorderFactory.createEmptyBorder(3, 5, 3, 5)
		));
		searchField.setText("Search...");
		searchField.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		searchField.addFocusListener(new java.awt.event.FocusAdapter() {
			public void focusGained(java.awt.event.FocusEvent e) {
				if (searchField.getText().equals("Search...")) { searchField.setText(""); searchField.setForeground(Color.WHITE); }
			}
			public void focusLost(java.awt.event.FocusEvent e) {
				if (searchField.getText().isEmpty()) { searchField.setText("Search..."); searchField.setForeground(ColorScheme.LIGHT_GRAY_COLOR); }
			}
		});
		searchField.addKeyListener(new KeyAdapter() { public void keyReleased(KeyEvent e) { filterWords(); } });

		String[] categories = new String[WORD_CATEGORIES.size() + 1];
		categories[0] = "All Categories";
		int i = 1;
		for (String cat : WORD_CATEGORIES.keySet()) { categories[i++] = cat; }

		categoryComboBox = new JComboBox<>(categories);
		categoryComboBox.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		categoryComboBox.setForeground(Color.WHITE);
		categoryComboBox.setPreferredSize(new Dimension(120, 25));
		categoryComboBox.addActionListener(e -> filterWords());

		filterPanel.add(searchField, BorderLayout.CENTER);
		filterPanel.add(categoryComboBox, BorderLayout.EAST);

		wordButtonsPanel = new JPanel();
		wordButtonsPanel.setLayout(new BoxLayout(wordButtonsPanel, BoxLayout.Y_AXIS));
		wordButtonsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		JScrollPane wordsScrollPane = new JScrollPane(wordButtonsPanel);
		wordsScrollPane.setBorder(BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR));
		wordsScrollPane.getVerticalScrollBar().setUnitIncrement(16);
		wordsScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
		filterWords();

		JPanel wordsSection = new JPanel(new BorderLayout());
		wordsSection.setBackground(ColorScheme.DARK_GRAY_COLOR);
		wordsSection.add(filterPanel, BorderLayout.NORTH);
		wordsSection.add(wordsScrollPane, BorderLayout.CENTER);

		JPanel markerPanel = new JPanel(new BorderLayout(5, 0));
		markerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		markerPanel.setBorder(new EmptyBorder(10, 0, 5, 0));
		JLabel markerLabel = new JLabel("Marker:");
		markerLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		markerTypeComboBox = new JComboBox<>(MarkerType.values());
		markerTypeComboBox.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		markerTypeComboBox.setForeground(Color.WHITE);
		markerTypeComboBox.setSelectedItem(MarkerType.NOTE);
		markerPanel.add(markerLabel, BorderLayout.WEST);
		markerPanel.add(markerTypeComboBox, BorderLayout.CENTER);

		JPanel buttonPanel = new JPanel(new GridLayout(1, 2, 5, 0));
		buttonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		buttonPanel.setBorder(new EmptyBorder(5, 0, 0, 0));
		JButton submitButton = new JButton("Write");
		submitButton.setBackground(new Color(60, 90, 60));
		submitButton.setForeground(Color.WHITE);
		submitButton.setFocusPainted(false);
		submitButton.addActionListener(e -> submitMessage());
		JButton cancelButton = new JButton("Cancel");
		cancelButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		cancelButton.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		cancelButton.setFocusPainted(false);
		cancelButton.addActionListener(e -> cancel());
		buttonPanel.add(cancelButton);
		buttonPanel.add(submitButton);

		JPanel bottomPanel = new JPanel(new BorderLayout());
		bottomPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		bottomPanel.add(markerPanel, BorderLayout.NORTH);
		bottomPanel.add(buttonPanel, BorderLayout.SOUTH);

		JPanel contentPanel = new JPanel(new BorderLayout(0, 5));
		contentPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		contentPanel.add(inputPanel, BorderLayout.NORTH);
		contentPanel.add(wordsSection, BorderLayout.CENTER);
		contentPanel.add(bottomPanel, BorderLayout.SOUTH);

		JPanel myMessagesSection = new JPanel(new BorderLayout(0, 5));
		myMessagesSection.setBackground(ColorScheme.DARK_GRAY_COLOR);
		myMessagesSection.setBorder(new EmptyBorder(10, 0, 0, 0));
		JSeparator separator = new JSeparator();
		separator.setForeground(ColorScheme.MEDIUM_GRAY_COLOR);
		JPanel myMessagesHeader = new JPanel(new BorderLayout());
		myMessagesHeader.setBackground(ColorScheme.DARK_GRAY_COLOR);
		myMessagesHeader.setBorder(new EmptyBorder(5, 0, 5, 0));
		JLabel myMessagesTitleLabel = new JLabel("My Messages");
		myMessagesTitleLabel.setForeground(new Color(255, 215, 0));
		JButton refreshButton = new JButton("Refresh");
		refreshButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		refreshButton.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		refreshButton.setFocusPainted(false);
		refreshButton.setPreferredSize(new Dimension(70, 22));
		refreshButton.addActionListener(e -> refreshMyMessages());
		myMessagesHeader.add(myMessagesTitleLabel, BorderLayout.WEST);
		myMessagesHeader.add(refreshButton, BorderLayout.EAST);

		myMessagesPanel = new JPanel();
		myMessagesPanel.setLayout(new BoxLayout(myMessagesPanel, BoxLayout.Y_AXIS));
		myMessagesPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		myMessagesStatusLabel = new JLabel("Click Refresh to load your messages");
		myMessagesStatusLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		myMessagesStatusLabel.setAlignmentX(JLabel.LEFT_ALIGNMENT);
		myMessagesPanel.add(myMessagesStatusLabel);

		JScrollPane myMessagesScrollPane = new JScrollPane(myMessagesPanel);
		myMessagesScrollPane.setBorder(BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR));
		myMessagesScrollPane.getVerticalScrollBar().setUnitIncrement(16);
		myMessagesScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
		myMessagesScrollPane.setPreferredSize(new Dimension(0, 120));
		myMessagesSection.add(separator, BorderLayout.NORTH);
		myMessagesSection.add(myMessagesHeader, BorderLayout.CENTER);
		myMessagesSection.add(myMessagesScrollPane, BorderLayout.SOUTH);

		JPanel mainWrapper = new JPanel(new BorderLayout());
		mainWrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);
		mainWrapper.add(contentPanel, BorderLayout.CENTER);
		mainWrapper.add(myMessagesSection, BorderLayout.SOUTH);

		add(titleLabel, BorderLayout.NORTH);
		add(mainWrapper, BorderLayout.CENTER);
	}

	private void filterWords() {
		wordButtonsPanel.removeAll();
		String searchText = searchField.getText().toLowerCase();
		if (searchText.equals("search...")) searchText = "";
		String selectedCategory = (String) categoryComboBox.getSelectedItem();
		boolean allCategories = "All Categories".equals(selectedCategory);
		List<String> wordsToShow = new ArrayList<>();
		for (Map.Entry<String, String[]> entry : WORD_CATEGORIES.entrySet()) {
			if (!allCategories && !entry.getKey().equals(selectedCategory)) continue;
			for (String word : entry.getValue()) {
				if (searchText.isEmpty() || word.toLowerCase().contains(searchText)) {
					if (!wordsToShow.contains(word)) wordsToShow.add(word);
				}
			}
		}
		for (String word : wordsToShow) wordButtonsPanel.add(createWordButton(word));
		wordButtonsPanel.revalidate();
		wordButtonsPanel.repaint();
	}

	private JButton createWordButton(String word) {
		JButton btn = new JButton(word);
		btn.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		btn.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		btn.setFocusPainted(false);
		btn.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR), BorderFactory.createEmptyBorder(4, 10, 4, 10)));
		btn.setAlignmentX(JButton.LEFT_ALIGNMENT);
		btn.setMaximumSize(new Dimension(Integer.MAX_VALUE, 28));
		btn.setHorizontalAlignment(SwingConstants.LEFT);
		btn.addMouseListener(new java.awt.event.MouseAdapter() {
			public void mouseEntered(java.awt.event.MouseEvent e) { btn.setBackground(new Color(80, 80, 80)); btn.setForeground(new Color(255, 215, 0)); }
			public void mouseExited(java.awt.event.MouseEvent e) { btn.setBackground(ColorScheme.DARKER_GRAY_COLOR); btn.setForeground(ColorScheme.LIGHT_GRAY_COLOR); }
		});
		btn.addActionListener(e -> appendWord(word));
		return btn;
	}

	private void appendWord(String word) {
		String currentText = messageInput.getText();
		String newText;
		if (currentText.isEmpty()) newText = word;
		else if (currentText.endsWith(" ") || word.equals(",") || word.equals(".") || word.equals("!") || word.equals("?") || word.equals(":") || word.equals(";") || word.equals("...")) newText = currentText + word;
		else newText = currentText + " " + word;
		if (newText.length() <= MAX_MESSAGE_LENGTH) { messageInput.setText(newText); updateCharCount(); }
	}

	private void deleteLastWord() {
		String text = messageInput.getText().trim();
		if (text.isEmpty()) return;
		int lastSpace = text.lastIndexOf(' ');
		messageInput.setText(lastSpace >= 0 ? text.substring(0, lastSpace) : "");
		updateCharCount();
	}

	private void updateCharCount() {
		int length = messageInput.getText().length();
		charCountLabel.setText(length + " / " + MAX_MESSAGE_LENGTH);
		charCountLabel.setForeground(length > MAX_MESSAGE_LENGTH * 0.8 ? new Color(255, 150, 150) : ColorScheme.LIGHT_GRAY_COLOR);
	}

	private void submitMessage() {
		String message = messageInput.getText().trim();
		if (!message.isEmpty()) {
			plugin.submitMessage(message, (MarkerType) markerTypeComboBox.getSelectedItem());
			messageInput.setText("");
			updateCharCount();
		}
	}

	public MarkerType getSelectedMarkerType() { return (MarkerType) markerTypeComboBox.getSelectedItem(); }
	private void cancel() { messageInput.setText(""); updateCharCount(); plugin.closeMessagePanel(); }

	private void refreshMyMessages() {
		String playerName = plugin.getCurrentPlayerName();
		if (playerName == null || playerName.isEmpty()) {
			myMessagesPanel.removeAll(); myMessagesStatusLabel.setText("Not logged in"); myMessagesPanel.add(myMessagesStatusLabel); myMessagesPanel.revalidate(); myMessagesPanel.repaint(); return;
		}
		myMessagesPanel.removeAll(); myMessagesStatusLabel.setText("Loading..."); myMessagesPanel.add(myMessagesStatusLabel); myMessagesPanel.revalidate(); myMessagesPanel.repaint();
		plugin.getMessageService().getAllAuthorMessages()
			.thenAccept(messages -> SwingUtilities.invokeLater(() -> {
				myMessagesPanel.removeAll();
				if (messages.isEmpty()) { myMessagesStatusLabel.setText("No messages found"); myMessagesPanel.add(myMessagesStatusLabel); }
				else { for (MessageData msg : messages) myMessagesPanel.add(createMessageEntry(msg)); }
				myMessagesPanel.revalidate(); myMessagesPanel.repaint();
			}))
			.exceptionally(ex -> { SwingUtilities.invokeLater(() -> { myMessagesPanel.removeAll(); myMessagesStatusLabel.setText("Failed to load messages"); myMessagesPanel.add(myMessagesStatusLabel); myMessagesPanel.revalidate(); myMessagesPanel.repaint(); }); return null; });
	}

	private JPanel createMessageEntry(MessageData message) {
		JPanel entry = new JPanel(new BorderLayout(3, 2));
		entry.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		entry.setBorder(BorderFactory.createCompoundBorder(
			BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR),
			BorderFactory.createEmptyBorder(5, 5, 5, 5)
		));
		entry.setAlignmentX(JPanel.LEFT_ALIGNMENT);
		entry.setMaximumSize(new Dimension(Integer.MAX_VALUE, 75));

		// Message text
		String msgText = message.getMessage();
		if (msgText.length() > 25) msgText = msgText.substring(0, 22) + "...";
		JLabel messageLabel = new JLabel("\"" + msgText + "\"");
		messageLabel.setForeground(new Color(255, 215, 0));
		messageLabel.setAlignmentX(JLabel.LEFT_ALIGNMENT);

		// Location info
		JLabel locationLabel = new JLabel("World " + message.getWorldId() + " | Region " + message.getRegionId());
		locationLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		locationLabel.setAlignmentX(JLabel.LEFT_ALIGNMENT);

		// Votes display
		JLabel thumbsUpLabel = new JLabel("\u25B2" + message.getThumbsUp());
		thumbsUpLabel.setForeground(new Color(50, 205, 50));
		JLabel thumbsDownLabel = new JLabel("\u25BC" + message.getThumbsDown());
		thumbsDownLabel.setForeground(new Color(220, 20, 60));

		JPanel votesPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 3, 0));
		votesPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		votesPanel.setAlignmentX(JPanel.LEFT_ALIGNMENT);
		votesPanel.add(thumbsUpLabel);
		votesPanel.add(thumbsDownLabel);

		// Left panel - message, location, votes stacked vertically
		JPanel leftPanel = new JPanel();
		leftPanel.setLayout(new BoxLayout(leftPanel, BoxLayout.Y_AXIS));
		leftPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		leftPanel.add(messageLabel);
		leftPanel.add(locationLabel);
		leftPanel.add(votesPanel);

		// Delete button
		JButton deleteButton = new JButton("X");
		deleteButton.setBackground(new Color(120, 40, 40));
		deleteButton.setForeground(Color.WHITE);
		deleteButton.setFocusPainted(false);
		deleteButton.setFont(deleteButton.getFont().deriveFont(12f).deriveFont(java.awt.Font.BOLD));
		deleteButton.setPreferredSize(new Dimension(32, 32));
		deleteButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
		deleteButton.setToolTipText("Delete message");
		deleteButton.addActionListener(e -> deleteMessage(message));

		// Right panel - delete button centered vertically
		JPanel rightPanel = new JPanel(new GridBagLayout());
		rightPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		rightPanel.setPreferredSize(new Dimension(40, 60));
		rightPanel.add(deleteButton);

		entry.add(leftPanel, BorderLayout.CENTER);
		entry.add(rightPanel, BorderLayout.EAST);
		return entry;
	}

	private void deleteMessage(MessageData message) {
		plugin.getMessageService().deleteMessage(message.getWorldId(), message.getRegionId(), message.getId())
			.thenAccept(v -> SwingUtilities.invokeLater(() -> { plugin.removeMessage(message.getId()); refreshMyMessages(); }))
			.exceptionally(ex -> { SwingUtilities.invokeLater(() -> { myMessagesPanel.removeAll(); myMessagesStatusLabel.setText("Failed to delete message"); myMessagesPanel.add(myMessagesStatusLabel); myMessagesPanel.revalidate(); myMessagesPanel.repaint(); }); return null; });
	}
}

/*
 * Copyright (c) 2025, LordStrange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.runemessages;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.util.Map;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Player;
import net.runelite.api.Point;
import net.runelite.api.RuneLiteObject;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;

public class RuneMessagesOverlay extends Overlay
{
	private static final Color MESSAGE_COLOR = new Color(255, 215, 0);
	private static final Color AUTHOR_COLOR = new Color(180, 180, 180);
	private static final Color SHADOW_COLOR = new Color(0, 0, 0, 180);
	private static final Color THUMBS_UP_COLOR = new Color(50, 205, 50);
	private static final Color THUMBS_DOWN_COLOR = new Color(220, 20, 60);

	private final Client client;
	private final RuneMessagesPlugin plugin;
	private final RuneMessagesConfig config;

	@Inject
	public RuneMessagesOverlay(Client client, RuneMessagesPlugin plugin, RuneMessagesConfig config)
	{
		this.client = client;
		this.plugin = plugin;
		this.config = config;

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
		setPriority(OverlayPriority.HIGH);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		Player localPlayer = client.getLocalPlayer();
		if (localPlayer == null)
		{
			return null;
		}

		WorldPoint playerLocation = localPlayer.getWorldLocation();
		int displayRadius = config.displayRadius();

		for (Map.Entry<String, RuneLiteObject> entry : plugin.getSpawnedGraves().entrySet())
		{
			RuneLiteObject grave = entry.getValue();
			if (grave == null || !grave.isActive())
			{
				continue;
			}

			MessageData message = plugin.getMessageDataMap().get(entry.getKey());
			if (message == null)
			{
				continue;
			}

			WorldPoint messageWorldPoint = new WorldPoint(message.getX(), message.getY(), message.getPlane());

			LocalPoint expectedLocal = LocalPoint.fromWorld(client, messageWorldPoint);
			if (expectedLocal == null)
			{
				continue;
			}

			int distance = playerLocation.distanceTo(messageWorldPoint);
			if (distance > displayRadius)
			{
				continue;
			}

			renderMessage(graphics, expectedLocal, message, message.getPlane());
		}

		return null;
	}

	private void renderMessage(Graphics2D graphics, LocalPoint location, MessageData message, int plane)
	{
		Point point = Perspective.localToCanvas(client, location, plane, 150);
		if (point == null)
		{
			return;
		}

		String messageText = "\"" + message.getMessage() + "\"";
		String authorText = "- " + message.getAuthor();

		FontMetrics metrics = graphics.getFontMetrics();
		int messageWidth = metrics.stringWidth(messageText);
		int authorWidth = metrics.stringWidth(authorText);
		int maxWidth = Math.max(messageWidth, authorWidth);

		int x = point.getX() - maxWidth / 2;
		int y = point.getY();

		graphics.setColor(SHADOW_COLOR);
		graphics.drawString(messageText, x + 1, y + 1);
		graphics.drawString(messageText, x - 1, y - 1);
		graphics.drawString(messageText, x + 1, y - 1);
		graphics.drawString(messageText, x - 1, y + 1);

		graphics.setColor(MESSAGE_COLOR);
		graphics.drawString(messageText, x, y);

		int authorX = point.getX() - authorWidth / 2;
		int authorY = y + metrics.getHeight() + 2;

		graphics.setColor(SHADOW_COLOR);
		graphics.drawString(authorText, authorX + 1, authorY + 1);

		graphics.setColor(AUTHOR_COLOR);
		graphics.drawString(authorText, authorX, authorY);

		int ratingsY = authorY + metrics.getHeight() + 2;
		String thumbsUpText = "\u25B2 " + message.getThumbsUp();
		String thumbsDownText = "\u25BC " + message.getThumbsDown();

		int thumbsUpWidth = metrics.stringWidth(thumbsUpText);
		int thumbsDownWidth = metrics.stringWidth(thumbsDownText);
		int totalRatingsWidth = thumbsUpWidth + 15 + thumbsDownWidth;
		int ratingsX = point.getX() - totalRatingsWidth / 2;

		graphics.setColor(SHADOW_COLOR);
		graphics.drawString(thumbsUpText, ratingsX + 1, ratingsY + 1);
		graphics.setColor(THUMBS_UP_COLOR);
		graphics.drawString(thumbsUpText, ratingsX, ratingsY);

		int thumbsDownX = ratingsX + thumbsUpWidth + 15;
		graphics.setColor(SHADOW_COLOR);
		graphics.drawString(thumbsDownText, thumbsDownX + 1, ratingsY + 1);
		graphics.setColor(THUMBS_DOWN_COLOR);
		graphics.drawString(thumbsDownText, thumbsDownX, ratingsY);
	}
}

/*
 * Copyright (c) 2025, LordStrange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.runemessages;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum MarkerType
{
	NOTE("Note", 10137),
	WOODEN_SIGNPOST("Wooden Signpost", 1402),
	STONE_SIGNPOST("Stone Signpost", 11560),
	SCRIBBLED_NOTE("Scribbled Note", 2838),
	CLUE_BOTTLE("Clue Bottle", 31044);

	private final String displayName;
	private final int modelId;

	@Override
	public String toString()
	{
		return displayName;
	}

	public static MarkerType fromModelId(int modelId)
	{
		for (MarkerType type : values())
		{
			if (type.getModelId() == modelId)
			{
				return type;
			}
		}
		return NOTE; // Default
	}
}

/*
 * Copyright (c) 2025, LordStrange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.runemessages;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class MessageData
{
	private String id;
	private String author;
	private String message;
	private int x;
	private int y;
	private int plane;
	private int worldId;
	private int regionId;
	private long timestamp;
	private int modelId;
	private int thumbsUp;
	private int thumbsDown;
	private boolean reported;

	public int getModelId()
	{
		// Default to NOTE if not set (for backwards compatibility)
		return modelId > 0 ? modelId : MarkerType.NOTE.getModelId();
	}
}

/*
 * Copyright (c) 2025, LordStrange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.runemessages;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.coords.WorldPoint;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;

@Slf4j
@Singleton
public class RuneMessagesService
{
	private static final String API_URL = "https://runemessages-api-production.up.railway.app";
	private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");

	private final OkHttpClient httpClient;
	private final Gson gson;

	@Getter
	@Setter
	private String apiKey;

	@Inject
	public RuneMessagesService(OkHttpClient httpClient, Gson gson)
	{
		this.httpClient = httpClient;
		this.gson = gson;
	}

	public CompletableFuture<String> register(String username)
	{
		CompletableFuture<String> future = new CompletableFuture<>();

		JsonObject body = new JsonObject();
		body.addProperty("username", username);

		Request request = new Request.Builder()
			.url(API_URL + "/register")
			.post(RequestBody.create(JSON, gson.toJson(body)))
			.build();

		httpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				log.warn("Failed to register: {}", e.getMessage());
				future.completeExceptionally(e);
			}

			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				try
				{
					if (!response.isSuccessful())
					{
						future.completeExceptionally(new IOException("Registration failed: HTTP " + response.code()));
						return;
					}

					String responseBody = response.body().string();
					JsonObject json = gson.fromJson(responseBody, JsonObject.class);

					if (json.has("apiKey"))
					{
						String key = json.get("apiKey").getAsString();
						apiKey = key;
						future.complete(key);
					}
					else
					{
						future.completeExceptionally(new IOException("No API key in response"));
					}
				}
				finally
				{
					response.close();
				}
			}
		});

		return future;
	}

	public CompletableFuture<Boolean> verifyApiKey(String key)
	{
		CompletableFuture<Boolean> future = new CompletableFuture<>();

		Request request = new Request.Builder()
			.url(API_URL + "/verify")
			.header("X-API-Key", key)
			.get()
			.build();

		httpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				log.warn("Failed to verify API key: {}", e.getMessage());
				future.complete(false);
			}

			@Override
			public void onResponse(Call call, Response response)
			{
				response.close();
				future.complete(response.isSuccessful());
			}
		});

		return future;
	}

	public CompletableFuture<List<MessageData>> getMessagesForRegion(int worldId, int regionId)
	{
		CompletableFuture<List<MessageData>> future = new CompletableFuture<>();

		String url = API_URL + "/messages?worldId=" + worldId + "&regionId=" + regionId;

		Request request = new Request.Builder()
			.url(url)
			.get()
			.build();

		httpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				log.warn("Failed to fetch messages for region {}: {}", regionId, e.getMessage());
				future.completeExceptionally(e);
			}

			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				try
				{
					if (!response.isSuccessful())
					{
						log.warn("Failed to fetch messages: HTTP {}", response.code());
						future.complete(new ArrayList<>());
						return;
					}

					String responseBody = response.body().string();
					List<MessageData> messages = parseMessageArray(responseBody);
					log.debug("Fetched {} messages for region {}", messages.size(), regionId);
					future.complete(messages);
				}
				finally
				{
					response.close();
				}
			}
		});

		return future;
	}

	public CompletableFuture<List<MessageData>> getAllAuthorMessages()
	{
		CompletableFuture<List<MessageData>> future = new CompletableFuture<>();

		if (apiKey == null || apiKey.isEmpty())
		{
			log.warn("getAllAuthorMessages: No API key set");
			future.complete(new ArrayList<>());
			return future;
		}

		String url = API_URL + "/messages/mine";
		log.debug("Fetching all author messages from: {}", url);

		Request request = new Request.Builder()
			.url(url)
			.header("X-API-Key", apiKey)
			.get()
			.build();

		httpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				log.warn("Failed to fetch author messages: {}", e.getMessage());
				future.complete(new ArrayList<>());
			}

			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				try
				{
					if (!response.isSuccessful())
					{
						log.warn("getAllAuthorMessages failed: HTTP {}", response.code());
						future.complete(new ArrayList<>());
						return;
					}

					String responseBody = response.body().string();
					log.debug("getAllAuthorMessages response: {}", responseBody);
					List<MessageData> messages = parseMessageArray(responseBody);
					log.debug("Parsed {} messages from /messages/mine", messages.size());
					future.complete(messages);
				}
				finally
				{
					response.close();
				}
			}
		});

		return future;
	}

	public CompletableFuture<MessageData> saveMessage(WorldPoint location, String message, String author, int worldId, int modelId)
	{
		CompletableFuture<MessageData> future = new CompletableFuture<>();

		if (apiKey == null || apiKey.isEmpty())
		{
			future.completeExceptionally(new IOException("Not authenticated"));
			return future;
		}

		int regionId = location.getRegionID();

		JsonObject body = new JsonObject();
		body.addProperty("worldId", worldId);
		body.addProperty("regionId", regionId);
		body.addProperty("message", message);
		body.addProperty("x", location.getX());
		body.addProperty("y", location.getY());
		body.addProperty("plane", location.getPlane());
		body.addProperty("modelId", modelId);

		Request request = new Request.Builder()
			.url(API_URL + "/messages")
			.header("X-API-Key", apiKey)
			.post(RequestBody.create(JSON, gson.toJson(body)))
			.build();

		httpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				log.warn("Failed to save message: {}", e.getMessage());
				future.completeExceptionally(e);
			}

			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				try
				{
					String responseBody = response.body().string();

					if (!response.isSuccessful())
					{
						try
						{
							JsonObject errorJson = gson.fromJson(responseBody, JsonObject.class);
							String errorMsg = errorJson.has("error") ? errorJson.get("error").getAsString() : "Unknown error";
							future.completeExceptionally(new IOException(errorMsg));
						}
						catch (Exception e)
						{
							future.completeExceptionally(new IOException("HTTP " + response.code()));
						}
						return;
					}

					MessageData data = gson.fromJson(responseBody, MessageData.class);
					log.debug("Saved message '{}' by {} at region {}", message, author, regionId);
					future.complete(data);
				}
				finally
				{
					response.close();
				}
			}
		});

		return future;
	}

	public CompletableFuture<Void> deleteMessage(int worldId, int regionId, String messageId)
	{
		CompletableFuture<Void> future = new CompletableFuture<>();

		if (apiKey == null || apiKey.isEmpty())
		{
			future.completeExceptionally(new IOException("Not authenticated"));
			return future;
		}

		String url = API_URL + "/messages/" + worldId + "/" + regionId + "/" + messageId;

		Request request = new Request.Builder()
			.url(url)
			.header("X-API-Key", apiKey)
			.delete()
			.build();

		httpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				log.warn("Failed to delete message: {}", e.getMessage());
				future.completeExceptionally(e);
			}

			@Override
			public void onResponse(Call call, Response response)
			{
				response.close();
				if (response.isSuccessful())
				{
					log.debug("Deleted message {}", messageId);
					future.complete(null);
				}
				else
				{
					future.completeExceptionally(new IOException("HTTP " + response.code()));
				}
			}
		});

		return future;
	}

	public CompletableFuture<Void> rateMessage(MessageData message, boolean thumbsUp)
	{
		CompletableFuture<Void> future = new CompletableFuture<>();

		if (apiKey == null || apiKey.isEmpty())
		{
			future.completeExceptionally(new IOException("Not authenticated"));
			return future;
		}

		String url = API_URL + "/messages/" + message.getWorldId() + "/" + message.getRegionId() + "/" + message.getId() + "/vote";

		JsonObject body = new JsonObject();
		body.addProperty("vote", thumbsUp ? "up" : "down");

		Request request = new Request.Builder()
			.url(url)
			.header("X-API-Key", apiKey)
			.post(RequestBody.create(JSON, gson.toJson(body)))
			.build();

		httpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				log.warn("Failed to vote on message: {}", e.getMessage());
				future.completeExceptionally(e);
			}

			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				try
				{
					if (response.isSuccessful())
					{
						if (thumbsUp)
						{
							message.setThumbsUp(message.getThumbsUp() + 1);
						}
						else
						{
							message.setThumbsDown(message.getThumbsDown() + 1);
						}
						log.debug("Voted {} on message {}", thumbsUp ? "up" : "down", message.getId());
						future.complete(null);
					}
					else
					{
						String responseBody = response.body().string();
						try
						{
							JsonObject errorJson = gson.fromJson(responseBody, JsonObject.class);
							String errorMsg = errorJson.has("error") ? errorJson.get("error").getAsString() : "Vote failed";
							future.completeExceptionally(new IOException(errorMsg));
						}
						catch (Exception e)
						{
							future.completeExceptionally(new IOException("HTTP " + response.code()));
						}
					}
				}
				finally
				{
					response.close();
				}
			}
		});

		return future;
	}

	public CompletableFuture<Void> reportMessage(MessageData message, String reporterName)
	{
		CompletableFuture<Void> future = new CompletableFuture<>();

		if (apiKey == null || apiKey.isEmpty())
		{
			future.completeExceptionally(new IOException("Not authenticated"));
			return future;
		}

		String url = API_URL + "/messages/" + message.getWorldId() + "/" + message.getRegionId() + "/" + message.getId() + "/report";

		JsonObject body = new JsonObject();
		body.addProperty("reason", "Reported by " + reporterName);

		Request request = new Request.Builder()
			.url(url)
			.header("X-API-Key", apiKey)
			.post(RequestBody.create(JSON, gson.toJson(body)))
			.build();

		httpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				log.warn("Failed to report message: {}", e.getMessage());
				future.completeExceptionally(e);
			}

			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				try
				{
					if (response.isSuccessful())
					{
						message.setReported(true);
						log.debug("Reported message {}", message.getId());
						future.complete(null);
					}
					else
					{
						String responseBody = response.body().string();
						try
						{
							JsonObject errorJson = gson.fromJson(responseBody, JsonObject.class);
							String errorMsg = errorJson.has("error") ? errorJson.get("error").getAsString() : "Report failed";
							future.completeExceptionally(new IOException(errorMsg));
						}
						catch (Exception e)
						{
							future.completeExceptionally(new IOException("HTTP " + response.code()));
						}
					}
				}
				finally
				{
					response.close();
				}
			}
		});

		return future;
	}

	private List<MessageData> parseMessageArray(String json)
	{
		List<MessageData> messages = new ArrayList<>();

		if (json == null || json.isEmpty() || json.equals("null"))
		{
			return messages;
		}

		try
		{
			JsonArray array = gson.fromJson(json, JsonArray.class);
			for (JsonElement element : array)
			{
				try
				{
					MessageData msg = gson.fromJson(element, MessageData.class);
					if (msg != null)
					{
						messages.add(msg);
					}
				}
				catch (Exception e)
				{
					log.warn("Failed to parse message: {}", e.getMessage());
				}
			}
		}
		catch (Exception e)
		{
			log.warn("Failed to parse message array: {}", e.getMessage());
		}

		return messages;
	}
}

