package com.betterbingo;

import com.google.inject.Provides;
import com.google.inject.Injector;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.swing.SwingUtilities;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.Tile;
import net.runelite.api.TileItem;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.DrawManager;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import okhttp3.*;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import java.lang.reflect.Type;
import java.util.Map;
import net.runelite.api.ItemComposition;
import net.runelite.http.api.item.ItemPrice;
import net.runelite.api.NPC;
import java.util.Collection;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.Actor;
import net.runelite.api.events.ItemSpawned;
import java.util.HashSet;
import java.util.Set;
import net.runelite.client.util.ImageCapture;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.HashMap;


/**
 * Bingo Plugin for RuneLite
 * Tracks items for bingo events and sends notifications to Discord
 * Supports loading items from Pastebin for easy sharing
 */
@Slf4j
@PluginDescriptor(
        name = "Bingo",
        description = "Track items for bingo events. Supports Pastebin for easy sharing.",
        tags = {"bingo", "items", "collection", "pastebin"}
)
public class BingoPlugin extends Plugin {

    private static final String CONFIG_GROUP = "bingo";
    private static final String CONFIG_KEY_OBTAINED_ITEMS = "obtainedItems";
    private static final int GRID_SIZE = 5;

    @Inject
    private Client client;
    @Inject
    private ClientThread clientThread;
    @Inject
    private BingoConfig config;
    @Inject
    private ClientToolbar clientToolbar;
    @Inject
    private ItemManager itemManager;
    @Inject
    private ConfigManager configManager;
    @Inject
    private ScheduledExecutorService executor;
    @Inject
    private OkHttpClient okHttpClient;
    @Inject
    private Injector injector;
    @Inject
    private DrawManager drawManager;
    @Inject
    private ImageCapture imageCapture;
    @Inject
    private Gson gson;
    @Inject
    private BingoAntiCheat antiCheat;
    @Inject
    private BingoDiscordNotifier discordNotifier;
    @Inject
    private BingoProfileManager profileManager;

    @Getter
    private final List<BingoItem> items = new ArrayList<>();

    private final Map<String, BingoItem> itemsByName = new HashMap<>();
    private final Set<Integer> recentlyKilledNpcs = new HashSet<>();
    private BingoPanel panel;
    private NavigationButton navButton;

    /**
     * Represents an item that has been obtained
     */
    @Getter
    private static class ObtainedItem {
        private final BingoItem bingoItem;
        private final int index;

        public ObtainedItem(BingoItem bingoItem, int index) {
            this.bingoItem = bingoItem;
            this.index = index;
        }

        public BingoItem getBingoItem() {
            return bingoItem;
        }

        public int getIndex() {
            return index;
        }

        public String getName() {
            return bingoItem.getName();
        }
    }

    /**
     * Represents the type of bingo completion
     */
    private enum CompletionType {
        ROW,
        COLUMN,
        DIAGONAL1,
        DIAGONAL2,
        FULL
    }

    /**
     * Gets a human-readable message for a completion type
     *
     * @param completionType  The type of completion
     * @param completionIndex The index of the completed row or column
     * @return A human-readable message
     */
    private String getCompletionMessage(CompletionType completionType, int completionIndex) {
        switch (completionType) {
            case ROW:
                return "Row " + (completionIndex + 1) + " complete!";
            case COLUMN:
                return "Column " + (completionIndex + 1) + " complete!";
            case DIAGONAL1:
                return "Diagonal (top-left to bottom-right) complete!";
            case DIAGONAL2:
                return "Diagonal (top-right to bottom-left) complete!";
            case FULL:
                return "BINGO! Full board complete!";
            default:
                return "Bingo completion!";
        }
    }

    /**
     * Represents a pattern for matching chat messages related to item drops
     */
    private static class ChatMessagePattern {
        private final String pattern;
        private final Function<String, String> itemExtractor;
        @Getter
        private final boolean multiItem;

        public ChatMessagePattern(String pattern, Function<String, String> itemExtractor, boolean multiItem) {
            this.pattern = pattern;
            this.itemExtractor = itemExtractor;
            this.multiItem = multiItem;
        }

        public boolean matches(String message) {
            return message.contains(pattern);
        }

        public String extractItem(String message) {
            return itemExtractor.apply(message);
        }
    }

    private final List<ChatMessagePattern> chatPatterns = Arrays.asList(
            // Regular drops
            new ChatMessagePattern("Valuable drop:",
                    message -> message.substring(message.indexOf(":") + 2), false),
            new ChatMessagePattern("You receive a drop:",
                    message -> message.substring(message.indexOf(":") + 2), false),

            // Pet drops
            new ChatMessagePattern("You have a funny feeling like",
                    message -> message.substring(0, message.indexOf("like you") - 1)
                            .replace("You have a funny feeling ", ""), false),

            // Collection log
            new ChatMessagePattern("New item added to your collection log:",
                    message -> message.substring(message.indexOf(":") + 2), false),

            // Raids drops with specific format
            new ChatMessagePattern("- ",
                    message -> {
                        if (message.contains("Chambers of Xeric") ||
                                message.contains("Theatre of Blood") ||
                                message.contains("Tombs of Amascut")) {
                            return message.substring(message.indexOf("- ") + 2);
                        }
                        return null;
                    }, false),

            // Special raid loot messages
            new ChatMessagePattern("Special loot:",
                    message -> message.substring(message.indexOf(":") + 2), true),

            // Chest opening messages
            new ChatMessagePattern("You open the chest and find:",
                    message -> message.substring(message.indexOf("find:") + 6), true),
            new ChatMessagePattern("You find some loot:",
                    message -> message.substring(message.indexOf("loot:") + 6), true),
            new ChatMessagePattern("Your loot is:",
                    message -> message.substring(message.indexOf("is:") + 4), true),

            // Special drop notifications
            new ChatMessagePattern("received a special drop:",
                    message -> message.substring(message.indexOf("drop:") + 6), false),
            new ChatMessagePattern("received unique loot:",
                    message -> message.substring(message.indexOf("loot:") + 6), false)
    );

    /**
     * Extracts an item name from a string, handling quantity indicators and special cases
     *
     * @param rawItemName The raw item name to clean
     * @return The cleaned item name or null if invalid
     */
    private String cleanItemName(String rawItemName) {
        if (rawItemName == null || rawItemName.trim().isEmpty()) {
            return null;
        }

        String itemName = rawItemName.trim();

        // Handle "x quantity" format (e.g., "5 x Bones")
        if (itemName.contains(" x ")) {
            if (itemName.indexOf("x ") > 0) {
                itemName = itemName.substring(itemName.indexOf("x ") + 2).trim();
            }
        }

        // Handle "quantity x" format (e.g., "5x Bones")
        if (itemName.matches(".*\\d+x .*")) {
            itemName = itemName.replaceAll("\\d+x ", "").trim();
        }

        // Handle "Item (quantity)" format (e.g., "Bones (5)")
        if (itemName.matches(".*\\(\\d+\\)$")) {
            itemName = itemName.replaceAll("\\s*\\(\\d+\\)$", "").trim();
        }

        return itemName;
    }

    @Override
    protected void startUp() throws Exception {
        panel = injector.getInstance(BingoPanel.class);

        final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/icon.png");

        navButton = NavigationButton.builder()
                .tooltip("Bingo")
                .icon(icon)
                .priority(5)
                .panel(panel)
                .build();

        clientToolbar.addNavigation(navButton);

        // Initialize with the current profile
        log.info("Starting with bingo profile: {}", config.currentProfile());
        loadItems();

        if (config.itemSourceType() == BingoConfig.ItemSourceType.REMOTE) {
            scheduleRemoteUpdate();
        }

        if (config.discordWebhookUrl() == null || config.discordWebhookUrl().isEmpty()) {
            log.warn("Discord webhook URL is not configured. Discord notifications will not be sent.");
        } else {
            log.info("Discord webhook URL is configured: {}", config.discordWebhookUrl().substring(0, Math.min(20, config.discordWebhookUrl().length())) + "...");
        }
        if (config.completionNotifications()) {
            log.info("Completion notifications are enabled");
        } else {
            log.warn("Completion notifications are disabled");
        }
    }

    @Override
    protected void shutDown() {
        clientToolbar.removeNavigation(navButton);
        items.clear();
        itemsByName.clear();
        recentlyKilledNpcs.clear();
    }

    @Provides
    BingoConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(BingoConfig.class);
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        if (!event.getGroup().equals(CONFIG_GROUP)) {
            return;
        }

        // Handle profile-specific settings
        String key = event.getKey();
        String currentProfileKey = profileManager.getCurrentProfileKey("");

        if (key.startsWith(currentProfileKey)) {
            String actualKey = key.substring(currentProfileKey.length());
            if (actualKey.equals("itemSourceType") || actualKey.equals("itemList") || actualKey.equals("remoteUrl")) {
                loadItems();

                if (profileManager.getProfileItemSourceType() == BingoConfig.ItemSourceType.REMOTE) {
                    scheduleRemoteUpdate();
                }
            } else if (actualKey.equals("refreshInterval") && profileManager.getProfileItemSourceType() == BingoConfig.ItemSourceType.REMOTE) {
                scheduleRemoteUpdate();
            }
        }
        // Handle global settings
        else if (key.equals("itemSourceType") || key.equals("itemList") || key.equals("remoteUrl")) {
            loadItems();

            if (config.itemSourceType() == BingoConfig.ItemSourceType.REMOTE) {
                scheduleRemoteUpdate();
            }
        } else if (key.equals("refreshInterval") && config.itemSourceType() == BingoConfig.ItemSourceType.REMOTE) {
            scheduleRemoteUpdate();
        }
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event) {
        if (event.getGameState() == GameState.LOGGING_IN) {
            loadItems();
            loadSavedItems();
        }
    }

    @Subscribe
    public void onNpcLootReceived(NpcLootReceived event) {
        NPC npc = event.getNpc();
        Collection<ItemStack> items = event.getItems();
        String npcName = npc.getName();
        String location = antiCheat.getPlayerLocationName();

        for (ItemStack item : items) {
            final ItemComposition itemComp = itemManager.getItemComposition(item.getId());
            String itemName = itemComp.getName();

            antiCheat.recordItemAcquisition(
                    cleanItemName(itemName),
                    BingoAntiCheat.AcquisitionMethod.NPC_DROP,
                    npcName,
                    location
            );
            checkForItem(itemName);
        }
    }

    @Subscribe
    public void onChatMessage(net.runelite.api.events.ChatMessage event) {
        if (event.getType() != ChatMessageType.GAMEMESSAGE && event.getType() != ChatMessageType.SPAM) {
            return;
        }

        String message = event.getMessage();
        String location = antiCheat.getPlayerLocationName();

        for (ChatMessagePattern pattern : chatPatterns) {
            if (pattern.matches(message)) {
                String extractedText = pattern.extractItem(message);

                if (extractedText == null) {
                    continue;
                }
                BingoAntiCheat.AcquisitionMethod method = BingoAntiCheat.AcquisitionMethod.CHAT_MESSAGE;
                String sourceDetails = "Chat message: " + message;

                if (message.contains("collection log")) {
                    method = BingoAntiCheat.AcquisitionMethod.COLLECTION_LOG;
                    sourceDetails = "Collection log";
                } else if (message.contains("chest") || message.contains("loot")) {
                    method = BingoAntiCheat.AcquisitionMethod.CHEST_LOOT;
                    sourceDetails = "Chest/Loot container";
                }

                if (pattern.isMultiItem()) {
                    String[] parts = extractedText.split(",|\\sand\\s");
                    for (String part : parts) {
                        String itemName = cleanItemName(part);
                        if (itemName != null && !itemName.isEmpty()) {
                            antiCheat.recordItemAcquisition(itemName, method, sourceDetails, location);
                            checkForItem(itemName);
                        }
                    }
                } else {
                    String itemName = cleanItemName(extractedText);
                    if (itemName != null && !itemName.isEmpty()) {
                        antiCheat.recordItemAcquisition(itemName, method, sourceDetails, location);
                        checkForItem(itemName);
                    }
                }

                return;
            }
        }
    }

    @Subscribe
    public void onActorDeath(ActorDeath event) {
        Actor actor = event.getActor();
        if (actor instanceof NPC) {
            recentlyKilledNpcs.add(((NPC) actor).getIndex());
            clientThread.invokeLater(() -> {
                recentlyKilledNpcs.remove(((NPC) actor).getIndex());
            });
        }
    }

    @Subscribe
    public void onItemSpawned(ItemSpawned event) {
        final TileItem item = event.getItem();
        final Tile tile = event.getTile();

        if (item == null || tile == null || client.getLocalPlayer() == null) {
            return;
        }

        boolean isNearKilledNpc = false;
        String npcName = "Unknown";

        for (NPC npc : client.getNpcs()) {
            if (npc != null && recentlyKilledNpcs.contains(npc.getIndex()) &&
                    tile.getWorldLocation().distanceTo(npc.getWorldLocation()) <= 1) {
                isNearKilledNpc = true;
                npcName = npc.getName();
                break;
            }
        }

        if (!isNearKilledNpc) {
            return;
        }

        final String finalNpcName = npcName;
        clientThread.invoke(() -> {
            final ItemComposition itemComp = itemManager.getItemComposition(item.getId());
            String itemName = itemComp.getName();
            String location = antiCheat.getPlayerLocationName();

            antiCheat.recordItemAcquisition(
                    cleanItemName(itemName),
                    BingoAntiCheat.AcquisitionMethod.GROUND_SPAWN,
                    finalNpcName,
                    location
            );

            checkForItem(itemName);
        });
    }

    /**
     * Checks if an item is on the bingo board and processes it if found
     *
     * @param itemName The name of the item to check
     */
    private void checkForItem(String itemName) {
        String cleanedItemName = cleanItemName(itemName);
        if (cleanedItemName == null) {
            return;
        }

        ObtainedItem obtainedItem = findAndMarkItem(cleanedItemName);

        if (obtainedItem != null) {
            notifyItemObtained(obtainedItem);
        }
    }

    /**
     * Finds a bingo item by name and marks it as obtained
     *
     * @param itemName The name of the item to find
     * @return The obtained item, or null if not found or already obtained
     */
    private ObtainedItem findAndMarkItem(String itemName) {
        if (itemName == null || itemName.isEmpty()) {
            return null;
        }

        String normalizedName = cleanItemName(itemName);
        if (normalizedName == null) {
            return null;
        }

        BingoItem bingoItem = itemsByName.get(normalizedName.toLowerCase());

        if (bingoItem != null && !bingoItem.isObtained()) {
            if (!antiCheat.validateItemAcquisition(normalizedName)) {
                if (client.getGameState() == GameState.LOGGED_IN) {
                    client.addChatMessage(
                            ChatMessageType.GAMEMESSAGE,
                            "",
                            "<col=ff0000>Warning:</col> <col=ffffff>Item acquisition validation failed for</col> <col=ffff00>" + itemName + "</col>",
                            null
                    );
                }
                return null;
            }

            bingoItem.setObtained(true);
            int index = items.indexOf(bingoItem);

            saveObtainedItems();
            if (panel != null) {
                SwingUtilities.invokeLater(() -> panel.updateItems(items));
            }

            return new ObtainedItem(bingoItem, index);
        }

        return null;
    }

    /**
     * Notifies the player of an obtained item and sends a Discord notification if configured
     *
     * @param obtainedItem The obtained item
     */
    private void notifyItemObtained(ObtainedItem obtainedItem) {
        if (obtainedItem == null) {
            return;
        }

        BingoItem bingoItem = obtainedItem.getBingoItem();
        int index = obtainedItem.getIndex();

        if (client.getGameState() == GameState.LOGGED_IN) {
            client.addChatMessage(
                    ChatMessageType.GAMEMESSAGE,
                    "",
                    "<col=00ff00>Bingo:</col> <col=ffffff>Obtained item</col> <col=ffff00>" + bingoItem.getName() + "</col>",
                    null
            );
        }

        if (config.discordWebhookUrl() != null && !config.discordWebhookUrl().isEmpty()) {
            executor.execute(() -> captureScreenshotAsync(screenshot -> {
                String playerName = client.getLocalPlayer() != null ? client.getLocalPlayer().getName() : "Unknown";
                int worldNumber = client.getWorld();
                String worldType = client.getWorldType().toString();

                String headerMessage = String.format("**Player: %s | World: %d (%s)**\n\n",
                        playerName, worldNumber, worldType);

                String itemMessage = "Obtained bingo item: **" + bingoItem.getName() + "**";

                Set<String> bingoItemNames = itemsByName.keySet().stream()
                        .map(String::toLowerCase)
                        .collect(Collectors.toSet());

                String logMessage = antiCheat.buildBingoItemsAcquisitionLogMessage(bingoItemNames);

                String combinedMessage = headerMessage + itemMessage + "\n\n" + logMessage;

                discordNotifier.sendNotification(
                        combinedMessage,
                        screenshot,
                        false,
                        config.discordWebhookUrl(),
                        executor
                );
            }));
        }

        checkForCompletions(index);
    }

    /**
     * Captures a screenshot asynchronously and calls the callback with the result
     *
     * @param callback The callback to call with the captured screenshot (or null if disabled/failed)
     */
    private void captureScreenshotAsync(Consumer<BufferedImage> callback) {
        if (!config.sendScreenshot()) {
            log.debug("Screenshot capture disabled by config");
            callback.accept(null);
            return;
        }

        if (client.getGameState() == GameState.LOGIN_SCREEN) {
            log.info("Login screen screenshot prevented");
            callback.accept(null);
            return;
        }

        // Use RuneLite's built-in DrawManager to capture the screenshot
        drawManager.requestNextFrameListener(image -> {
            executor.submit(() -> {
                try {
                    if (image == null) {
                        log.warn("Received null image from drawManager");
                        callback.accept(null);
                        return;
                    }

                    BufferedImage screenshot = new BufferedImage(
                            image.getWidth(null),
                            image.getHeight(null),
                            BufferedImage.TYPE_INT_ARGB);

                    Graphics graphics = screenshot.getGraphics();
                    graphics.drawImage(image, 0, 0, null);
                    graphics.dispose();

                    log.debug("Screenshot captured successfully: {}x{}",
                            screenshot.getWidth(), screenshot.getHeight());

                    callback.accept(screenshot);
                } catch (Exception e) {
                    log.warn("Exception while processing screenshot image", e);
                    callback.accept(null);
                }
            });
        });
    }

    /**
     * Checks for completions in the bingo board based on the last obtained item
     *
     * @param obtainedItemIndex The index of the last obtained item
     */
    private void checkForCompletions(int obtainedItemIndex) {
        int row = obtainedItemIndex / GRID_SIZE;
        int col = obtainedItemIndex % GRID_SIZE;

        if (isRowComplete(row)) {
            notifyCompletion(CompletionType.ROW, row);
        }

        if (isColumnComplete(col)) {
            notifyCompletion(CompletionType.COLUMN, col);
        }

        boolean onDiagonal1 = (row == col);
        if (onDiagonal1 && isDiagonal1Complete()) {
            notifyCompletion(CompletionType.DIAGONAL1, 0);
        }

        boolean onDiagonal2 = (row + col == GRID_SIZE - 1);
        if (onDiagonal2 && isDiagonal2Complete()) {
            notifyCompletion(CompletionType.DIAGONAL2, 0);
        }

        if (isFullBoardComplete()) {
            notifyCompletion(CompletionType.FULL, 0);
        }
    }

    /**
     * Checks if the full board is complete
     *
     * @return True if all items are obtained
     */
    private boolean isFullBoardComplete() {
        for (BingoItem item : items) {
            if (!item.isObtained()) {
                return false;
            }
        }
        return true;
    }

    /**
     * Checks if a row is complete
     *
     * @param row The row to check
     * @return True if the row is complete
     */
    private boolean isRowComplete(int row) {
        for (int c = 0; c < GRID_SIZE; c++) {
            int index = row * GRID_SIZE + c;
            if (index >= items.size() || !items.get(index).isObtained()) {
                return false;
            }
        }
        return true;
    }

    /**
     * Checks if a column is complete
     *
     * @param col The column to check
     * @return True if the column is complete
     */
    private boolean isColumnComplete(int col) {
        for (int r = 0; r < GRID_SIZE; r++) {
            int index = r * GRID_SIZE + col;
            if (index >= items.size() || !items.get(index).isObtained()) {
                return false;
            }
        }
        return true;
    }

    /**
     * Checks if the main diagonal (top-left to bottom-right) is complete
     *
     * @return True if the diagonal is complete
     */
    private boolean isDiagonal1Complete() {
        for (int i = 0; i < GRID_SIZE; i++) {
            int index = i * GRID_SIZE + i;
            if (index >= items.size() || !items.get(index).isObtained()) {
                return false;
            }
        }
        return true;
    }

    /**
     * Checks if the other diagonal (top-right to bottom-left) is complete
     *
     * @return True if the diagonal is complete
     */
    private boolean isDiagonal2Complete() {
        for (int i = 0; i < GRID_SIZE; i++) {
            int index = i * GRID_SIZE + (GRID_SIZE - 1 - i);
            if (index >= items.size() || !items.get(index).isObtained()) {
                return false;
            }
        }
        return true;
    }

    /**
     * Notifies the player of a bingo completion and sends a Discord notification if configured
     *
     * @param completionType  The type of completion (row, column, or full)
     * @param completionIndex The index of the completed row or column
     */
    private void notifyCompletion(CompletionType completionType, int completionIndex) {
        String completionMessage = getCompletionMessage(completionType, completionIndex);

        if (client.getGameState() == GameState.LOGGED_IN) {
            client.addChatMessage(
                    ChatMessageType.GAMEMESSAGE,
                    "",
                    "<col=00ff00>Bingo:</col> <col=ffffff>" + completionMessage + "</col>",
                    null
            );
        }

        if (config.discordWebhookUrl() != null && !config.discordWebhookUrl().isEmpty()) {
            String discordMessage = "**BINGO!** " + completionMessage;

            executor.execute(() -> captureScreenshotAsync(screenshot -> {
                discordNotifier.sendNotification(
                        discordMessage,
                        screenshot,
                        true,
                        config.discordWebhookUrl(),
                        executor
                );
            }));
        }
    }

    /**
     * Loads items from the config based on the selected source type
     */
    private void loadItems() {
        items.clear();
        itemsByName.clear();

        BingoConfig.ItemSourceType itemSourceType = profileManager.getProfileItemSourceType();

        if (itemSourceType == BingoConfig.ItemSourceType.MANUAL) {
            String remoteUrl = profileManager.getProfileRemoteUrl();
            if (!remoteUrl.isEmpty()) {
                clientThread.invoke(() -> {
                    if (client.getLocalPlayer() != null) {
                        client.addChatMessage(ChatMessageType.GAMEMESSAGE, "",
                                "Warning: Remote URL is configured but not being used because you're in Manual mode.", "");
                    }
                });
            }
            loadItemsFromManualList();
        } else if (itemSourceType == BingoConfig.ItemSourceType.REMOTE) {
            String itemList = profileManager.getProfileItemList();
            String defaultItemList = "Dragon Scimitar\nAbyssal Whip\nFire Cape\nBarrows Gloves\nDragon Boots";

            if (!itemList.equals(defaultItemList) && !itemList.isEmpty()) {
                clientThread.invoke(() -> {
                    if (client.getLocalPlayer() != null) {
                        client.addChatMessage(ChatMessageType.GAMEMESSAGE, "",
                                "Warning: Manual Bingo Items are configured but not being used because you're in Remote URL mode.", "");
                    }
                });
            }

            String remoteUrl = profileManager.getProfileRemoteUrl();
            if (!remoteUrl.isEmpty()) {
                updateRemoteItems();
            } else {
                clientThread.invoke(() -> {
                    if (client.getLocalPlayer() != null) {
                        client.addChatMessage(ChatMessageType.GAMEMESSAGE, "",
                                "Remote URL is not configured. Please set a URL in the Bingo plugin settings.", "");
                    } else {
                        log.info("Remote URL is not configured. Please set a URL in the Bingo plugin settings.");
                    }
                });
            }
        }

        SwingUtilities.invokeLater(() -> panel.updateItems(items));
    }

    /**
     * Loads items from the manual list in the config
     */
    private void loadItemsFromManualList() {
        String itemList = profileManager.getProfileItemList();
        if (!itemList.isEmpty()) {
            Arrays.stream(itemList.split("\\n"))
                    .map(String::trim)
                    .filter(s -> !s.isEmpty())
                    .forEach(line -> Arrays.stream(line.split(";"))
                            .map(String::trim)
                            .filter(s -> !s.isEmpty())
                            .forEach(itemName -> {
                                String properName = itemName.replace("_", " ");
                                List<ItemPrice> searchResults = itemManager.search(properName);
                                if (!searchResults.isEmpty()) {
                                    ItemPrice match = searchResults.get(0);
                                    BingoItem item = new BingoItem(match.getName(), match.getId());
                                    items.add(item);
                                    itemsByName.put(item.getName().toLowerCase(), item);
                                } else {
                                    BingoItem item = new BingoItem(properName);
                                    items.add(item);
                                    itemsByName.put(item.getName().toLowerCase(), item);
                                }
                            }));
        }
    }

    /**
     * Loads saved items from the configuration.
     */
    public void loadSavedItems() {
        if (profileManager.getProfilePersistObtained()) {
            return;
        }

        forceLoadSavedItems();
    }

    /**
     * Forces loading of saved items regardless of persistObtained setting.
     * Used during profile switching to ensure items are loaded correctly.
     */
    public void forceLoadSavedItems() {
        String profileKey = profileManager.getCurrentProfileKey(CONFIG_KEY_OBTAINED_ITEMS);
        String savedItems = configManager.getConfiguration(CONFIG_GROUP, profileKey);
        if (savedItems == null || savedItems.isEmpty()) {
            return;
        }

        Arrays.stream(savedItems.split(","))
                .map(String::trim)
                .filter(s -> !s.isEmpty())
                .forEach(name -> {
                    BingoItem item = itemsByName.get(name.toLowerCase());
                    if (item != null) {
                        item.setObtained(true);
                    }
                });
    }

    /**
     * Saves obtained items to the configuration.
     */
    public void saveObtainedItems() {
        if (profileManager.getProfilePersistObtained()) {
            return;
        }

        String obtainedItems = items.stream()
                .filter(BingoItem::isObtained)
                .map(BingoItem::getName)
                .collect(Collectors.joining(","));

        String profileKey = profileManager.getCurrentProfileKey(CONFIG_KEY_OBTAINED_ITEMS);
        configManager.setConfiguration(CONFIG_GROUP, profileKey, obtainedItems);
    }

    /**
     * Clears all obtained items.
     */
    public void clearObtainedItems() {
        for (BingoItem item : items) {
            item.setObtained(false);
        }
    }

    /**
     * Updates the UI to reflect the current state.
     */
    public void updateUI() {
        if (panel != null) {
            SwingUtilities.invokeLater(() -> panel.updateItems(items));
        }
    }

    /**
     * Resets the bingo board.
     *
     * @param showConfirmDialog Whether to show a confirmation dialog
     * @return true if the board was reset, false if the user cancelled
     */
    public boolean resetBingoBoard(boolean showConfirmDialog) {
        if (showConfirmDialog) {
            int result = javax.swing.JOptionPane.showConfirmDialog(
                    panel,
                    "Are you sure you want to reset the bingo board?\nAll progress will be deleted.",
                    "Reset Bingo Board",
                    javax.swing.JOptionPane.YES_NO_OPTION,
                    javax.swing.JOptionPane.WARNING_MESSAGE
            );

            if (result != javax.swing.JOptionPane.YES_OPTION) {
                return false;
            }
        }

        String profileKey = profileManager.getCurrentProfileKey(CONFIG_KEY_OBTAINED_ITEMS);
        configManager.unsetConfiguration(CONFIG_GROUP, profileKey);

        clearObtainedItems();
        updateUI();

        if (client.getLocalPlayer() != null) {
            client.addChatMessage(ChatMessageType.GAMEMESSAGE, "",
                    "Bingo board has been reset.", "");
        }

        log.debug("Bingo board reset for profile: {}", config.currentProfile());
        return true;
    }

    /**
     * Resets the bingo board with confirmation dialog.
     */
    public void resetBingoBoard() {
        resetBingoBoard(true);
    }

    /**
     * Schedules periodic updates from remote URL
     */
    private void scheduleRemoteUpdate() {
        executor.scheduleAtFixedRate(this::updateRemoteItems,
                0, profileManager.getProfileRefreshInterval(), TimeUnit.MINUTES);
    }

    /**
     * Updates items from remote URL
     */
    private void updateRemoteItems() {
        String remoteUrl = profileManager.getProfileRemoteUrl();
        if (remoteUrl.isEmpty()) {
            return;
        }

        try {
            String url = remoteUrl;
            if (url.contains("pastebin.com/") && !url.contains("raw")) {
                String pasteId = url.substring(url.lastIndexOf("/") + 1);
                url = "https://pastebin.com/raw/" + pasteId;
                log.debug("Converted Pastebin URL to raw format: {}", url);
            }

            log.debug("Fetching remote items from URL: {}", url);

            Request request = new Request.Builder()
                    .url(url)
                    .build();

            try (Response response = okHttpClient.newCall(request).execute()) {
                if (!response.isSuccessful()) {
                    log.warn("Failed to fetch remote items: {}", response.code());
                    clientThread.invoke(() -> {
                        if (client.getLocalPlayer() != null) {
                            client.addChatMessage(ChatMessageType.GAMEMESSAGE, "",
                                    "Failed to fetch bingo items: " + response.code(), "");
                        }
                    });
                    return;
                }

                String content = response.body().string();

                if (!content.trim().startsWith("[") && !content.trim().startsWith("{")) {
                    List<String> remoteItems = Arrays.stream(content.split("\\n"))
                            .map(String::trim)
                            .filter(s -> !s.isEmpty())
                            .collect(Collectors.toList());

                    if (remoteItems.isEmpty()) {
                        log.warn("Remote items list is empty");
                        clientThread.invoke(() -> {
                            if (client.getLocalPlayer() != null) {
                                client.addChatMessage(ChatMessageType.GAMEMESSAGE, "",
                                        "Remote items list is empty", "");
                            }
                        });
                        return;
                    }

                    updateItemsFromList(remoteItems);
                    return;
                }

                Type listType = new TypeToken<List<String>>() {
                }.getType();
                List<String> remoteItems = gson.fromJson(content, listType);

                if (remoteItems == null || remoteItems.isEmpty()) {
                    log.warn("Remote items list is empty");
                    clientThread.invoke(() -> {
                        if (client.getLocalPlayer() != null) {
                            client.addChatMessage(ChatMessageType.GAMEMESSAGE, "",
                                    "Remote items list is empty", "");
                        }
                    });
                    return;
                }

                updateItemsFromList(remoteItems);
            }
        } catch (Exception e) {
            log.warn("Error fetching remote items", e);
            clientThread.invoke(() -> {
                if (client.getLocalPlayer() != null) {
                    client.addChatMessage(ChatMessageType.GAMEMESSAGE, "",
                            "Error fetching bingo items: " + e.getMessage(), "");
                }
            });
        }
    }

    /**
     * Updates the items list from a list of item names
     *
     * @param remoteItems List of item names to update from
     */
    private void updateItemsFromList(List<String> remoteItems) {
        items.clear();
        itemsByName.clear();

        for (String itemName : remoteItems) {
            String properName = itemName.trim().replace("_", " ");
            if (properName.isEmpty()) {
                continue;
            }

            List<ItemPrice> searchResults = itemManager.search(properName);
            BingoItem bingoItem;

            if (!searchResults.isEmpty()) {
                ItemPrice match = searchResults.get(0);
                bingoItem = new BingoItem(match.getName(), match.getId());
            } else {
                bingoItem = new BingoItem(properName);
            }

            items.add(bingoItem);
            itemsByName.put(bingoItem.getName().toLowerCase(), bingoItem);
        }

        loadSavedItems();

        SwingUtilities.invokeLater(() -> panel.updateItems(items));

        final int itemCount = items.size();
        clientThread.invoke(() -> {
            if (client.getLocalPlayer() != null) {
                client.addChatMessage(ChatMessageType.GAMEMESSAGE, "",
                        "Bingo items updated (" + itemCount + " items)", "");
            }
        });

        log.debug("Successfully loaded {} items from remote URL", items.size());
    }

    /**
     * Manually triggers an update from the remote URL
     */
    public void updateRemoteItemsManually() {
        updateRemoteItems();
    }

    /**
     * Reloads items from the current source (manual or remote).
     * This is a public method that can be called from other classes.
     */
    public void reloadItems() {
        loadItems();
    }

}
package com.betterbingo;

import lombok.Data;
import lombok.EqualsAndHashCode;

@Data
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class BingoItem
{
    @EqualsAndHashCode.Include
    private final String name;
    private boolean obtained;
    private int itemId;

    public BingoItem(String name)
    {
        this.name = name;
        this.obtained = false;
        this.itemId = -1;
    }

    public BingoItem(String name, int itemId)
    {
        this.name = name;
        this.obtained = false;
        this.itemId = itemId;
    }
} 
package com.betterbingo;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.util.List;
import javax.inject.Inject;
import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.SwingConstants;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.AsyncBufferedImage;
import java.awt.FlowLayout;
import javax.swing.JButton;
import javax.swing.Box;
import javax.swing.JComboBox;
import javax.swing.JOptionPane;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import javax.swing.JCheckBox;

public class BingoPanel extends PluginPanel {
    private static final ImageIcon CHECK_MARK = new ImageIcon(ImageUtil.loadImageResource(BingoPlugin.class, "/check.png"));
    private static final Dimension ITEM_SIZE = new Dimension(32, 32);
    private static final int GRID_SIZE = 5; // 5x5 bingo board
    private static final int GRID_GAP = 2; // Gap between cells
    private static final int MAX_ITEMS = GRID_SIZE * GRID_SIZE; // Maximum 25 items

    private final JPanel itemsContainer = new JPanel();
    private final PluginErrorPanel errorPanel = new PluginErrorPanel();
    private final ItemManager itemManager;
    private final BingoPlugin plugin;
    private final BingoConfig config;
    private final BingoProfileManager profileManager;

    private final JPanel controlPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
    private final JButton resetButton = new JButton("Reset Board");
    private final JButton remoteUpdateButton = new JButton("Update from URL");
    private final JLabel sourceWarningLabel = new JLabel();
    private final JLabel itemLimitWarningLabel = new JLabel();

    // Profile management components
    private final JPanel profilePanel = new JPanel(new GridBagLayout());
    private final JComboBox<String> profileComboBox = new JComboBox<>();
    private final JButton newProfileButton = new JButton("New");
    private final JButton deleteProfileButton = new JButton("Delete");
    private final JButton profileSettingsButton = new JButton("Settings");

    @Inject
    public BingoPanel(ItemManager itemManager, BingoPlugin plugin, BingoConfig config, BingoProfileManager profileManager) {
        super(false);
        this.itemManager = itemManager;
        this.plugin = plugin;
        this.config = config;
        this.profileManager = profileManager;

        setLayout(new BorderLayout(0, 5));
        setBorder(new EmptyBorder(5, 5, 5, 5));

        // Configure grid layout with specific gaps
        itemsContainer.setLayout(new GridLayout(GRID_SIZE, GRID_SIZE, GRID_GAP, GRID_GAP));
        itemsContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);

        // Configure scroll pane
        JScrollPane scrollPane = new JScrollPane(itemsContainer);
        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
        scrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        scrollPane.setBorder(null);

        // Configure reset button
        resetButton.setToolTipText("Reset all bingo progress");
        resetButton.setFocusPainted(false);
        resetButton.addActionListener(e -> plugin.resetBingoBoard());

        // Configure remote update button
        remoteUpdateButton.setToolTipText("Update bingo items from Remote URL (Pastebin)");
        remoteUpdateButton.setFocusPainted(false);
        remoteUpdateButton.addActionListener(e -> plugin.updateRemoteItemsManually());

        // Configure source warning label
        sourceWarningLabel.setForeground(Color.YELLOW);
        sourceWarningLabel.setHorizontalAlignment(SwingConstants.CENTER);
        updateSourceWarningLabel();

        // Configure item limit warning label
        itemLimitWarningLabel.setForeground(Color.ORANGE);
        itemLimitWarningLabel.setHorizontalAlignment(SwingConstants.CENTER);
        itemLimitWarningLabel.setVisible(false);

        // Create a top panel for the warning labels and error panel
        JPanel topPanel = new JPanel(new BorderLayout(0, 5));
        topPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JPanel warningsPanel = new JPanel(new BorderLayout(0, 5));
        warningsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        warningsPanel.add(sourceWarningLabel, BorderLayout.NORTH);
        warningsPanel.add(itemLimitWarningLabel, BorderLayout.CENTER);

        topPanel.add(warningsPanel, BorderLayout.NORTH);
        errorPanel.setContent("Bingo", "No items loaded.");
        topPanel.add(errorPanel, BorderLayout.CENTER);
        errorPanel.setVisible(false);
        controlPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        updateButtonVisibility();
        initProfilePanel();
        topPanel.add(profilePanel, BorderLayout.SOUTH);
        add(topPanel, BorderLayout.NORTH);
        add(scrollPane, BorderLayout.CENTER);
        add(controlPanel, BorderLayout.SOUTH);
    }

    private void initProfilePanel() {
        profilePanel.setBorder(BorderFactory.createTitledBorder("Bingo Profiles"));

        GridBagConstraints c = new GridBagConstraints();
        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(5, 5, 5, 5);

        // Profile selector
        c.gridx = 0;
        c.gridy = 0;
        c.gridwidth = 3;
        c.weightx = 1.0;
        profilePanel.add(profileComboBox, c);

        // New profile button
        c.gridx = 0;
        c.gridy = 1;
        c.gridwidth = 1;
        c.weightx = 0.33;
        profilePanel.add(newProfileButton, c);

        // Delete profile button
        c.gridx = 1;
        c.gridy = 1;
        profilePanel.add(deleteProfileButton, c);

        // Settings button
        c.gridx = 2;
        c.gridy = 1;
        profilePanel.add(profileSettingsButton, c);

        // Add action listeners
        profileComboBox.addActionListener(e -> {
            String selectedProfile = (String) profileComboBox.getSelectedItem();
            if (selectedProfile != null && !selectedProfile.equals(config.currentProfile())) {
                profileManager.switchProfile(selectedProfile);
            }
        });

        newProfileButton.addActionListener(e -> {
            String profileName = JOptionPane.showInputDialog(this,
                    "Enter a name for the new bingo profile:",
                    "New Bingo Profile",
                    JOptionPane.PLAIN_MESSAGE);

            if (profileName != null && !profileName.trim().isEmpty()) {
                if (profileManager.createProfile(profileName)) {
                    updateProfileComboBox();
                    profileComboBox.setSelectedItem(profileName);

                    int configureResult = JOptionPane.showConfirmDialog(this,
                            "Do you want to configure settings for the new profile?",
                            "Configure Profile",
                            JOptionPane.YES_NO_OPTION,
                            JOptionPane.QUESTION_MESSAGE);

                    if (configureResult == JOptionPane.YES_OPTION) {
                        profileManager.switchProfile(profileName);
                        showProfileSettingsDialog();
                    }
                } else {
                    JOptionPane.showMessageDialog(this,
                            "A profile with that name already exists.",
                            "Profile Creation Failed",
                            JOptionPane.ERROR_MESSAGE);
                }
            }
        });

        deleteProfileButton.addActionListener(e -> {
            String selectedProfile = (String) profileComboBox.getSelectedItem();
            if (selectedProfile == null) {
                return;
            }
            int result = JOptionPane.showConfirmDialog(this,
                    "Are you sure you want to delete the profile '" + selectedProfile + "'?",
                    "Delete Profile",
                    JOptionPane.YES_NO_OPTION,
                    JOptionPane.WARNING_MESSAGE);

            if (result != JOptionPane.YES_OPTION) {
                return;
            }
            if (selectedProfile.equals(config.currentProfile())) {
                List<String> profiles = profileManager.getProfiles();
                if (profiles.size() <= 1) {
                    JOptionPane.showMessageDialog(this,
                            "You cannot delete the only profile. Create another profile first.",
                            "Delete Profile Failed",
                            JOptionPane.ERROR_MESSAGE);
                    return;
                }
                String newProfile = profiles.stream()
                        .filter(p -> !p.equals(selectedProfile))
                        .findFirst()
                        .orElse(null);

                if (newProfile == null) {
                    return;
                }
                profileManager.switchProfile(newProfile);
                updateProfileComboBox();
            }
            if (profileManager.deleteProfile(selectedProfile)) {
                updateProfileComboBox();
            } else {
                JOptionPane.showMessageDialog(this,
                        "Failed to delete the profile. It may no longer exist.",
                        "Delete Profile Failed",
                        JOptionPane.ERROR_MESSAGE);
            }
        });

        profileSettingsButton.addActionListener(e -> {
            showProfileSettingsDialog();
        });

        // Initial update
        updateProfileComboBox();
    }

    /**
     * Updates the profile combo box with the current list of profiles.
     */
    public void updateProfileComboBox() {
        profileComboBox.removeAllItems();

        List<String> profiles = profileManager.getProfiles();
        for (String profile : profiles) {
            profileComboBox.addItem(profile);
        }

        profileComboBox.setSelectedItem(config.currentProfile());
    }

    /**
     * Updates the source warning label based on the current item source type
     */
    private void updateSourceWarningLabel() {
        BingoConfig.ItemSourceType itemSourceType = profileManager.getProfileItemSourceType();
        if (itemSourceType == BingoConfig.ItemSourceType.MANUAL) {
            sourceWarningLabel.setText("<html><center>Using MANUAL mode - items from the 'Bingo Items' field will be used.<br>Remote URL will be ignored.</center></html>");
        } else {
            sourceWarningLabel.setText("<html><center>Using REMOTE URL mode - items from the URL will be used.<br>Manual 'Bingo Items' will be ignored.</center></html>");
        }
    }

    /**
     * Updates the visibility of buttons based on the current configuration
     */
    private void updateButtonVisibility() {
        updateSourceWarningLabel();
        controlPanel.removeAll();
        BingoConfig.ItemSourceType itemSourceType = profileManager.getProfileItemSourceType();
        if (itemSourceType == BingoConfig.ItemSourceType.REMOTE) {
            controlPanel.add(remoteUpdateButton);
            controlPanel.add(Box.createHorizontalStrut(10)); // Add spacing
        }
        controlPanel.add(resetButton);
        controlPanel.revalidate();
        controlPanel.repaint();
        revalidate();
        repaint();
    }

    @Override
    public Dimension getPreferredSize() {
        return new Dimension(PluginPanel.PANEL_WIDTH, super.getPreferredSize().height);
    }

    public void updateItems(List<BingoItem> items) {
        updateButtonVisibility();
        itemsContainer.removeAll();
        if (items.isEmpty()) {
            errorPanel.setVisible(true);
            itemLimitWarningLabel.setVisible(false);
            return;
        }

        errorPanel.setVisible(false);

        if (items.size() > MAX_ITEMS) {
            itemLimitWarningLabel.setText("<html><center>Warning: " + items.size() + " items found. Only the first 25 will be displayed.</center></html>");
            itemLimitWarningLabel.setVisible(true);
        } else {
            itemLimitWarningLabel.setVisible(false);
        }

        int availableWidth = PluginPanel.PANEL_WIDTH - 10; // Account for border
        int cellSize = (availableWidth - (GRID_GAP * (GRID_SIZE - 1))) / GRID_SIZE;
        for (int i = 0; i < MAX_ITEMS; i++) {
            JPanel cellPanel = new JPanel();
            cellPanel.setLayout(new BorderLayout(0, 1));
            cellPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            cellPanel.setBorder(BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_COLOR.darker(), 1));
            cellPanel.setPreferredSize(new Dimension(cellSize, cellSize));

            if (i < items.size()) {
                BingoItem item = items.get(i);

                JPanel contentPanel = new JPanel(new BorderLayout(0, 2));
                contentPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

                if (item.getItemId() != -1) {
                    AsyncBufferedImage itemImage = itemManager.getImage(item.getItemId());
                    JLabel iconLabel = new JLabel();
                    iconLabel.setHorizontalAlignment(SwingConstants.CENTER);
                    iconLabel.setPreferredSize(ITEM_SIZE);
                    itemImage.addTo(iconLabel);
                    contentPanel.add(iconLabel, BorderLayout.CENTER);
                }

                JLabel itemLabel = new JLabel("<html><center><small>" + item.getName() + "</small></center></html>");
                itemLabel.setForeground(item.isObtained() ? ColorScheme.PROGRESS_COMPLETE_COLOR : Color.WHITE);
                itemLabel.setHorizontalAlignment(SwingConstants.CENTER);
                contentPanel.add(itemLabel, BorderLayout.SOUTH);

                cellPanel.add(contentPanel, BorderLayout.CENTER);

                if (item.isObtained()) {
                    JLabel checkLabel = new JLabel(CHECK_MARK);
                    checkLabel.setHorizontalAlignment(SwingConstants.CENTER);
                    cellPanel.add(checkLabel, BorderLayout.NORTH);
                }
            } else {
                JLabel emptyLabel = new JLabel("Empty");
                emptyLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
                emptyLabel.setHorizontalAlignment(SwingConstants.CENTER);
                cellPanel.add(emptyLabel, BorderLayout.CENTER);
            }

            itemsContainer.add(cellPanel);
        }

        itemsContainer.revalidate();
        itemsContainer.repaint();
    }

    /**
     * Shows a dialog for editing profile-specific settings.
     */
    private void showProfileSettingsDialog() {
        JPanel settingsPanel = new JPanel(new GridBagLayout());
        GridBagConstraints c = new GridBagConstraints();
        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(5, 5, 5, 5);
        c.gridx = 0;
        c.gridy = 0;
        c.gridwidth = 1;
        c.weightx = 0.3;

        settingsPanel.add(new JLabel("Item Source:"), c);

        c.gridx = 1;
        c.weightx = 0.7;
        JComboBox<BingoConfig.ItemSourceType> itemSourceCombo = new JComboBox<>(BingoConfig.ItemSourceType.values());
        itemSourceCombo.setSelectedItem(profileManager.getProfileItemSourceType());
        settingsPanel.add(itemSourceCombo, c);
        c.gridx = 0;
        c.gridy++;
        c.weightx = 0.3;
        settingsPanel.add(new JLabel("Bingo Items:"), c);

        c.gridx = 1;
        c.weightx = 0.7;
        c.gridheight = 3;
        c.fill = GridBagConstraints.BOTH;
        javax.swing.JTextArea itemListArea = new javax.swing.JTextArea(profileManager.getProfileItemList(), 10, 30);
        itemListArea.setLineWrap(true);
        JScrollPane itemListScroll = new JScrollPane(itemListArea);
        settingsPanel.add(itemListScroll, c);

        c.gridx = 0;
        c.gridy += 3;
        c.gridheight = 1;
        c.weightx = 0.3;
        c.fill = GridBagConstraints.HORIZONTAL;
        settingsPanel.add(new JLabel("Remote URL:"), c);

        c.gridx = 1;
        c.weightx = 0.7;
        javax.swing.JTextField remoteUrlField = new javax.swing.JTextField(profileManager.getProfileRemoteUrl());
        settingsPanel.add(remoteUrlField, c);

        c.gridx = 0;
        c.gridy++;
        c.weightx = 0.3;
        settingsPanel.add(new JLabel("Refresh Interval (min):"), c);

        c.gridx = 1;
        c.weightx = 0.7;
        javax.swing.JSpinner refreshIntervalSpinner = new javax.swing.JSpinner(
                new javax.swing.SpinnerNumberModel(profileManager.getProfileRefreshInterval(), 1, 60, 1));
        settingsPanel.add(refreshIntervalSpinner, c);

        c.gridx = 0;
        c.gridy++;
        c.weightx = 0.3;
        settingsPanel.add(new JLabel("Save Progress:"), c);

        c.gridx = 1;
        c.weightx = 0.7;
        JCheckBox persistObtainedCheckbox = new JCheckBox("Don't save obtained items between sessions",
                profileManager.getProfilePersistObtained());
        settingsPanel.add(persistObtainedCheckbox, c);

        int result = JOptionPane.showConfirmDialog(this,
                settingsPanel,
                "Profile Settings: " + config.currentProfile(),
                JOptionPane.OK_CANCEL_OPTION,
                JOptionPane.PLAIN_MESSAGE);

        if (result == JOptionPane.OK_OPTION) {
            // Save settings
            profileManager.setProfileItemSourceType((BingoConfig.ItemSourceType) itemSourceCombo.getSelectedItem());
            profileManager.setProfileItemList(itemListArea.getText());
            profileManager.setProfileRemoteUrl(remoteUrlField.getText());
            profileManager.setProfileRefreshInterval((Integer) refreshIntervalSpinner.getValue());
            profileManager.setProfilePersistObtained(persistObtainedCheckbox.isSelected());

            // Reload items
            plugin.reloadItems();

            // Update UI
            updateSourceWarningLabel();
        }
    }
} 
package com.betterbingo;

import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.gson.Gson;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import okhttp3.*;

import javax.imageio.ImageIO;
import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.image.BufferedImage;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.concurrent.ScheduledExecutorService;

/**
 * Handles Discord webhook notifications for the Bingo plugin
 */
@Slf4j
@Singleton
public class BingoDiscordNotifier {

    private static final MediaType MEDIA_TYPE_PNG = MediaType.parse("image/png");
    private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");

    private final Client client;
    private final OkHttpClient okHttpClient;
    private final Gson gson;

    /**
     * Represents a notification to be sent to Discord
     */
    public static class DiscordNotification {
        @Getter
        private final String message;
        @Getter
        private final BufferedImage screenshot;
        private final boolean isCompletion;

        public DiscordNotification(String message, BufferedImage screenshot, boolean isCompletion) {
            this.message = message;
            this.screenshot = screenshot;
            this.isCompletion = isCompletion;
        }

        public boolean hasScreenshot() {
            return screenshot != null;
        }

        public boolean isCompletion() {
            return isCompletion;
        }
    }

    @Inject
    public BingoDiscordNotifier(Client client, OkHttpClient okHttpClient, Gson gson) {
        this.client = client;
        this.okHttpClient = okHttpClient;
        this.gson = gson;
    }

    /**
     * Sends a notification to Discord
     *
     * @param message      The message to send
     * @param screenshot   The screenshot to include (can be null)
     * @param isCompletion Whether this is a completion notification
     * @param webhookUrl   The Discord webhook URL
     * @param executor     The executor service to use for async operations
     */
    public void sendNotification(String message, BufferedImage screenshot, boolean isCompletion,
                                 String webhookUrl, ScheduledExecutorService executor) {
        if (webhookUrl == null || webhookUrl.isEmpty()) {
            log.debug("Discord webhook URL not configured, skipping notification");
            return;
        }

        if (!isValidWebhookUrl(webhookUrl)) {
            log.warn("Invalid Discord webhook URL: {}", webhookUrl);
            return;
        }

        DiscordNotification notification = new DiscordNotification(message, screenshot, isCompletion);

        executor.execute(() -> sendDiscordNotificationAsync(notification, webhookUrl));
    }

    /**
     * Sends a notification to Discord asynchronously
     *
     * @param notification The notification to send
     * @param webhookUrl   The Discord webhook URL
     */
    private void sendDiscordNotificationAsync(DiscordNotification notification, String webhookUrl) {
        try {
            if (notification.hasScreenshot()) {
                sendDiscordMessageWithScreenshot(notification, webhookUrl);
            } else {
                sendTextOnlyDiscordMessage(notification, webhookUrl);
            }
        } catch (IOException e) {
            log.warn("Error sending Discord notification", e);
        }
    }

    /**
     * Sends a text-only message to Discord
     *
     * @param notification The notification to send
     * @param webhookUrl   The Discord webhook URL
     */
    private void sendTextOnlyDiscordMessage(DiscordNotification notification, String webhookUrl) throws IOException {
        JsonObject payload = createDiscordPayload(notification);

        RequestBody body = RequestBody.create(
                JSON,
                payload.toString()
        );

        Request request = new Request.Builder()
                .url(webhookUrl)
                .post(body)
                .build();

        try (Response response = okHttpClient.newCall(request).execute()) {
            if (!response.isSuccessful()) {
                log.warn("Error sending Discord notification: {}", extractResponseBody(response));
            }
        }
    }

    /**
     * Sends a message with a screenshot to Discord
     *
     * @param notification The notification to send
     * @param webhookUrl   The Discord webhook URL
     */
    private void sendDiscordMessageWithScreenshot(DiscordNotification notification, String webhookUrl) throws IOException {
        byte[] imageBytes = imageToByteArray(notification.getScreenshot());

        MultipartBody.Builder requestBodyBuilder = new MultipartBody.Builder()
                .setType(MultipartBody.FORM)
                .addFormDataPart("payload_json", createDiscordPayload(notification).toString());
        requestBodyBuilder.addFormDataPart(
                "file",
                "screenshot.png",
                RequestBody.create(
                        MEDIA_TYPE_PNG,
                        imageBytes
                )
        );

        Request request = new Request.Builder()
                .url(webhookUrl)
                .post(requestBodyBuilder.build())
                .build();

        try (Response response = okHttpClient.newCall(request).execute()) {
            if (!response.isSuccessful()) {
                log.warn("Error sending Discord notification with screenshot: {}", extractResponseBody(response));
            }
        }
    }

    /**
     * Creates a Discord payload for the notification
     *
     * @param notification The notification to create a payload for
     * @return The Discord payload as a JsonObject
     */
    private JsonObject createDiscordPayload(DiscordNotification notification) {
        JsonObject payload = new JsonObject();

        payload.addProperty("username", notification.isCompletion() ?
                "Bingo Completion" :
                "Bingo Item Obtained");

        String enhancedMessage = notification.getMessage();
        if (client.getLocalPlayer() != null) {
            String playerName = client.getLocalPlayer().getName();
            int worldNumber = client.getWorld();
            enhancedMessage = String.format("%s (Player: %s, World: %d)",
                    enhancedMessage, playerName, worldNumber);
        }

        payload.addProperty("content", enhancedMessage);
        payload.add("embeds", new JsonArray());
        return payload;
    }

    /**
     * Converts a BufferedImage to a byte array
     *
     * @param screenshot The screenshot to convert
     * @return The image as a byte array
     */
    private byte[] imageToByteArray(BufferedImage screenshot) throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ImageIO.write(screenshot, "png", baos);
        return baos.toByteArray();
    }

    /**
     * Extracts the response body from a Response object
     *
     * @param response The response to extract the body from
     * @return The response body as a string
     */
    private String extractResponseBody(Response response) {
        try {
            return response.body() != null ? response.body().string() : "No response body";
        } catch (IOException e) {
            return "Error reading response body";
        }
    }

    /**
     * Checks if a webhook URL is valid
     *
     * @param webhookUrl The webhook URL to check
     * @return True if the URL is valid
     */
    private boolean isValidWebhookUrl(String webhookUrl) {
        return webhookUrl != null &&
                webhookUrl.startsWith("https://discord.com/api/webhooks/");
    }
} 
package com.betterbingo;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("bingo")
public interface BingoConfig extends Config
{
    enum ItemSourceType
    {
        MANUAL("Manual Input"),
        REMOTE("Remote URL");

        private final String name;

        ItemSourceType(String name)
        {
            this.name = name;
        }

        @Override
        public String toString()
        {
            return name;
        }
    }

    @ConfigItem(
            keyName = "itemSourceType",
            name = "Item Source",
            description = "Choose how to provide bingo items",
            position = 0,
            hidden = true
    )
    default ItemSourceType itemSourceType()
    {
        return ItemSourceType.MANUAL;
    }

    @ConfigItem(
            keyName = "itemList",
            name = "Bingo Items",
            description = "List of items for bingo (one per line)",
            position = 1,
            hidden = true
    )
    default String itemList()
    {
        return "Dragon Scimitar\nAbyssal Whip\nFire Cape\nBarrows Gloves\nDragon Boots";
    }

    @ConfigItem(
            keyName = "remoteUrl",
            name = "Remote URL",
            description = "URL to fetch bingo items from (supports Pastebin links)",
            position = 2,
            hidden = true
    )
    default String remoteUrl()
    {
        return "";
    }

    @ConfigItem(
            keyName = "refreshInterval",
            name = "Refresh Interval",
            description = "How often to refresh remote items (in minutes)",
            position = 3,
            hidden = true
    )
    default int refreshInterval()
    {
        return 5;
    }

    @ConfigItem(
            keyName = "persistObtained",
            name = "Save Progress",
            description = "When disabled, obtained items will be saved between sessions. When enabled, obtained items will NOT be saved between sessions.",
            position = 4,
            hidden = true
    )
    default boolean persistObtained()
    {
        return false;
    }

    @ConfigItem(
            keyName = "sendScreenshot",
            name = "Send Screenshots",
            description = "Send screenshots to Discord when obtaining items",
            position = 5
    )
    default boolean sendScreenshot()
    {
        return true;
    }

    @ConfigItem(
            keyName = "discordWebhookUrl",
            name = "Discord webhook URL",
            description = "Discord webhook integration",
            position = 6
    )
    default String discordWebhookUrl()
    {
        return "";
    }

    @ConfigItem(
            keyName = "completionNotifications",
            name = "Completion Notifications",
            description = "Send special notifications when completing a row, column, or the entire board",
            position = 7
    )
    default boolean completionNotifications()
    {
        return true;
    }

    @ConfigItem(
            keyName = "currentProfile",
            name = "Current Profile",
            description = "The currently active bingo profile",
            position = 8,
            hidden = true
    )
    default String currentProfile()
    {
        return "default";
    }

    @ConfigItem(
            keyName = "currentProfile",
            name = "Current Profile",
            description = "The currently active bingo profile",
            hidden = true
    )
    void setCurrentProfile(String currentProfile);

    @ConfigItem(
            keyName = "profiles",
            name = "Bingo Profiles",
            description = "List of available bingo profiles",
            hidden = true
    )
    default String profiles()
    {
        return "default";
    }

    @ConfigItem(
            keyName = "profiles",
            name = "Bingo Profiles",
            description = "List of available bingo profiles",
            hidden = true
    )
    void setProfiles(String profiles);
} 
package com.betterbingo;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Inject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import javax.inject.Singleton;
import java.lang.reflect.Type;
import java.time.Instant;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.Set;

/**
 * Handles anti-cheat verification for the Bingo plugin
 * Probably not needed, but who knows.
 */
@Slf4j
@Singleton
public class BingoAntiCheat
{
    private final Client client;
    private final BingoConfig config;
    private final ItemManager itemManager;
    
    @Inject
    private ConfigManager configManager;
    
    @Inject
    private Gson gson;

    // Thread-safe log of how items were acquired
    private final Map<String, ItemAcquisitionRecord> acquisitionRecords = new ConcurrentHashMap<>();

    /**
     * Represents how an item was acquired for anti-cheat verification
     */
    public enum AcquisitionMethod
    {
        NPC_DROP,         // From an NPC drop
        GROUND_SPAWN,     // Found on the ground
        CHEST_LOOT,       // From a chest/reward
        COLLECTION_LOG,   // Added to collection log
        CHAT_MESSAGE,     // Detected via chat message
        SIMULATED,        // Test mode simulated drop
        UNKNOWN           // Unknown source
    }

    /**
     * Records information about how an item was acquired for verification
     */
    @Getter
    public static class ItemAcquisitionRecord
    {
        private final String itemName;
        private final AcquisitionMethod method;
        private final Instant timestamp;
        private final String sourceDetails;  // NPC name, chest type, etc.
        private final String playerLocation; // Name or region where acquired

        public ItemAcquisitionRecord(
                String itemName,
                AcquisitionMethod method,
                String sourceDetails,
                String playerLocation
        )
        {
            this.itemName = itemName;
            this.method = method;
            this.timestamp = Instant.now();
            this.sourceDetails = sourceDetails;
            this.playerLocation = playerLocation;
        }
    }

    @Inject
    public BingoAntiCheat(Client client, BingoConfig config, ItemManager itemManager)
    {
        this.client = client;
        this.config = config;
        this.itemManager = itemManager;
    }

    /**
     * Records information about how an item was acquired.
     * Enhanced source details include world number, world type, and player name.
     */
    public void recordItemAcquisition(String itemName, AcquisitionMethod method, String sourceDetails, String location)
    {
        if (itemName == null || itemName.isEmpty())
        {
            log.debug("Attempted to record an acquisition with null or empty item name");
            return;
        }

        String details = String.format(
                "%s | World: %d (%s) | Player: %s",
                sourceDetails,
                getCurrentWorldNumber(),
                getCurrentWorldType(),
                getCurrentPlayerName()
        );

        ItemAcquisitionRecord record = new ItemAcquisitionRecord(itemName, method, details, location);
        acquisitionRecords.put(itemName.toLowerCase(), record);

        log.info("Item acquisition recorded: {} via {} from {} at {}",
                itemName, method, details, location
        );
    }

    /**
     * Validates an item's acquisition. Returns false if no record exists,
     * or if it fails any anti-cheat checks (timing, location, etc.).
     */
    public boolean validateItemAcquisition(String itemName)
    {
        if (itemName == null || itemName.isEmpty())
        {
            log.warn("Cannot validate acquisition for a null or empty item name");
            return false;
        }

        ItemAcquisitionRecord record = acquisitionRecords.get(itemName.toLowerCase());
        if (record == null)
        {
            log.warn("No acquisition record found for item: {}", itemName);
            return false;
        }

        if (!isValidLocationForItem(record.getItemName(), record.getPlayerLocation()))
        {
            log.warn("Rejected {} - invalid location {}", itemName, record.getPlayerLocation());
            return false;
        }

        return true;
    }

    /**
     * Checks if the given location is valid for obtaining the specified item.
     * In a full implementation, this might check a data structure or config.
     * Doubt this will be used ever in the future but w.e
     */
    private boolean isValidLocationForItem(String itemName, String location)
    {
        // Placeholder: assume all locations are valid for now, might never be used though
        return true;
    }

    /**
     * Builds a formatted message containing the acquisition log filtered to only include bingo items.
     * 
     * @param bingoItems Set of item names that are on the bingo board
     * @return Formatted message with acquisition details for bingo items only
     * Makes sure that we are not adding any acquisition items that are needed
     */
    public String buildBingoItemsAcquisitionLogMessage(Set<String> bingoItems)
    {
        if (acquisitionRecords.isEmpty())
        {
            return "No item acquisitions recorded.";
        }

        StringBuilder sb = new StringBuilder("**Bingo Item Acquisition Log**\n\n");
        
        boolean hasRecords = false;
        for (ItemAcquisitionRecord record : acquisitionRecords.values())
        {
            if (bingoItems.contains(record.getItemName().toLowerCase()))
            {
                sb.append(String.format(
                        "- **%s** via %s\n  %s\n  at %s (%s)\n\n",
                        record.getItemName(),
                        record.getMethod(),
                        record.getSourceDetails(),
                        record.getPlayerLocation(),
                        record.getTimestamp()
                ));
                hasRecords = true;
            }
        }

        if (!hasRecords)
        {
            return "No bingo item acquisitions recorded.";
        }

        return sb.toString();
    }

    /**
     * Clears the acquisition log.
     */
    public void clearAcquisitionLog()
    {
        acquisitionRecords.clear();
        log.debug("Acquisition log cleared");
    }

    /**
     * Saves the acquisition log to the configuration.
     * 
     * @param profileKey The profile-specific key to save under
     */
    public void saveAcquisitionLog(String profileKey)
    {
        if (acquisitionRecords.isEmpty())
        {
            return;
        }
        
        try
        {
            List<Map<String, String>> serializedRecords = new ArrayList<>();
            for (ItemAcquisitionRecord record : acquisitionRecords.values())
            {
                Map<String, String> serialized = new HashMap<>();
                serialized.put("itemName", record.getItemName());
                serialized.put("method", record.getMethod().toString());
                serialized.put("timestamp", record.getTimestamp().toString());
                serialized.put("sourceDetails", record.getSourceDetails());
                serialized.put("playerLocation", record.getPlayerLocation());
                serializedRecords.add(serialized);
            }
            
            String json = gson.toJson(serializedRecords);
            configManager.setConfiguration("bingo", profileKey, json);
            
            log.debug("Saved acquisition log with {} records", serializedRecords.size());
        }
        catch (Exception e)
        {
            log.error("Failed to save acquisition log", e);
        }
    }

    /**
     * Loads the acquisition log from the configuration.
     * 
     * @param profileKey The profile-specific key to load from
     */
    public void loadAcquisitionLog(String profileKey)
    {
        acquisitionRecords.clear();
        
        String json = configManager.getConfiguration("bingo", profileKey);
        if (json == null || json.isEmpty())
        {
            return;
        }
        
        try
        {
            Type type = new TypeToken<List<Map<String, String>>>(){}.getType();
            List<Map<String, String>> serializedRecords = gson.fromJson(json, type);
            
            for (Map<String, String> serialized : serializedRecords)
            {
                String itemName = serialized.get("itemName");
                AcquisitionMethod method = AcquisitionMethod.valueOf(serialized.get("method"));
                String sourceDetails = serialized.get("sourceDetails");
                String playerLocation = serialized.get("playerLocation");
                
                ItemAcquisitionRecord record = new ItemAcquisitionRecord(
                    itemName, method, sourceDetails, playerLocation);
                acquisitionRecords.put(itemName.toLowerCase(), record);
            }
            
            log.debug("Loaded acquisition log with {} records", serializedRecords.size());
        }
        catch (Exception e)
        {
            log.error("Failed to load acquisition log", e);
        }
    }

    /**
     * Gets the player's current location name, e.g., a region label.
     */
    public String getPlayerLocationName()
    {
        if (client.getLocalPlayer() == null)
        {
            return "Unknown";
        }

        LocalPoint localPoint = client.getLocalPlayer().getLocalLocation();
        if (localPoint != null)
        {
            WorldPoint worldPoint = WorldPoint.fromLocal(client, localPoint);
            return "Region " + worldPoint.getRegionID();
        }

        return "Region " + client.getLocalPlayer().getWorldLocation().getRegionID();
    }

    private String getCurrentPlayerName()
    {
        return client.getLocalPlayer() != null
                ? client.getLocalPlayer().getName()
                : "Unknown";
    }

    private int getCurrentWorldNumber()
    {
        return client.getWorld();
    }

    private String getCurrentWorldType()
    {
        return client.getWorldType().toString();
    }
}

package com.betterbingo;

import com.google.gson.Gson;
import com.google.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;

import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Manages bingo profiles, allowing players to create, switch between, and delete profiles.
 */
@Slf4j
@Singleton
public class BingoProfileManager {
    private static final String CONFIG_GROUP = "bingo";
    private static final String DEFAULT_PROFILE = "default";
    private static final String CONFIG_KEY_ACQUISITION_LOG = "acquisitionLog";
    private static final String CONFIG_KEY_ITEM_LIST = "itemList";
    private static final String CONFIG_KEY_REMOTE_URL = "remoteUrl";
    private static final String CONFIG_KEY_ITEM_SOURCE_TYPE = "itemSourceType";
    private static final String CONFIG_KEY_REFRESH_INTERVAL = "refreshInterval";
    private static final String CONFIG_KEY_PERSIST_OBTAINED = "persistObtained";

    @Inject
    private ConfigManager configManager;

    @Inject
    private BingoConfig config;

    @Inject
    private BingoPlugin plugin;

    @Inject
    private BingoAntiCheat antiCheat;

    @Inject
    private Gson gson;

    /**
     * Gets the list of available profiles.
     *
     * @return List of profile names
     */
    public List<String> getProfiles() {
        String profilesStr = config.profiles();
        if (profilesStr == null || profilesStr.isEmpty()) {
            return new ArrayList<>(List.of(DEFAULT_PROFILE));
        }

        return Arrays.stream(profilesStr.split(","))
                .map(String::trim)
                .filter(s -> !s.isEmpty())
                .collect(Collectors.toList());
    }

    /**
     * Saves the list of profiles.
     *
     * @param profiles List of profile names
     */
    private void saveProfiles(List<String> profiles) {
        String profilesStr = String.join(",", profiles);
        config.setProfiles(profilesStr);
    }

    /**
     * Creates a new profile.
     *
     * @param profileName Name of the profile to create
     * @return true if the profile was created, false if it already exists
     */
    public boolean createProfile(String profileName) {
        if (profileName == null || profileName.trim().isEmpty()) {
            return false;
        }

        List<String> profiles = getProfiles();
        if (profiles.contains(profileName)) {
            return false;
        }

        profiles.add(profileName);
        saveProfiles(profiles);
        initializeProfileSettings(profileName);
        
        log.debug("Created new bingo profile: {}", profileName);
        return true;
    }

    /**
     * Initializes a profile with default settings.
     * This copies settings from the current profile to ensure consistency.
     *
     * @param profileName Name of the profile to initialize
     */
    private void initializeProfileSettings(String profileName) {
        String sourceTypeKey = getProfileKey(profileName, CONFIG_KEY_ITEM_SOURCE_TYPE);
        configManager.setConfiguration(CONFIG_GROUP, sourceTypeKey, getProfileItemSourceType().name());

        String itemListKey = getProfileKey(profileName, CONFIG_KEY_ITEM_LIST);
        configManager.setConfiguration(CONFIG_GROUP, itemListKey, getProfileItemList());

        String remoteUrlKey = getProfileKey(profileName, CONFIG_KEY_REMOTE_URL);
        configManager.setConfiguration(CONFIG_GROUP, remoteUrlKey, getProfileRemoteUrl());

        String refreshIntervalKey = getProfileKey(profileName, CONFIG_KEY_REFRESH_INTERVAL);
        configManager.setConfiguration(CONFIG_GROUP, refreshIntervalKey, getProfileRefreshInterval());

        String persistObtainedKey = getProfileKey(profileName, CONFIG_KEY_PERSIST_OBTAINED);
        configManager.setConfiguration(CONFIG_GROUP, persistObtainedKey, getProfilePersistObtained());
    }

    /**
     * Deletes a profile.
     *
     * @param profileName Name of the profile to delete
     * @return true if the profile was deleted, false if it doesn't exist
     */
    public boolean deleteProfile(String profileName) {
        if (profileName == null || profileName.trim().isEmpty()) {
            return false;
        }

        List<String> profiles = getProfiles();
        if (!profiles.contains(profileName)) {
            return false;
        }

        profiles.remove(profileName);
        saveProfiles(profiles);
        
        // Delete all configuration for this profile
        configManager.unsetConfiguration(CONFIG_GROUP, getProfileKey(profileName, "obtainedItems"));
        configManager.unsetConfiguration(CONFIG_GROUP, getProfileKey(profileName, CONFIG_KEY_ACQUISITION_LOG));
        configManager.unsetConfiguration(CONFIG_GROUP, getProfileKey(profileName, CONFIG_KEY_ITEM_LIST));
        configManager.unsetConfiguration(CONFIG_GROUP, getProfileKey(profileName, CONFIG_KEY_REMOTE_URL));
        configManager.unsetConfiguration(CONFIG_GROUP, getProfileKey(profileName, CONFIG_KEY_ITEM_SOURCE_TYPE));
        configManager.unsetConfiguration(CONFIG_GROUP, getProfileKey(profileName, CONFIG_KEY_REFRESH_INTERVAL));
        configManager.unsetConfiguration(CONFIG_GROUP, getProfileKey(profileName, CONFIG_KEY_PERSIST_OBTAINED));

        log.debug("Deleted bingo profile: {}", profileName);
        return true;
    }

    /**
     * Switches to a different profile.
     *
     * @param profileName Name of the profile to switch to
     */
    public void switchProfile(String profileName) {
        if (profileName == null || profileName.trim().isEmpty()) {
            return;
        }

        List<String> profiles = getProfiles();
        if (!profiles.contains(profileName)) {
            return;
        }

        // If we're already on this profile, do nothing
        if (profileName.equals(config.currentProfile())) {
            return;
        }
        forceSaveCurrentProfile();
        config.setCurrentProfile(profileName);
        plugin.clearObtainedItems();
        antiCheat.clearAcquisitionLog();
        plugin.reloadItems();
        plugin.forceLoadSavedItems();
        loadAcquisitionLog();
        plugin.updateUI();

        log.debug("Switched to bingo profile: {}", profileName);
    }

    /**
     * Force saves the current profile data regardless of persistObtained setting.
     */
    private void forceSaveCurrentProfile() {
        String obtainedItems = plugin.getItems().stream()
                .filter(BingoItem::isObtained)
                .map(BingoItem::getName)
                .collect(Collectors.joining(","));

        String profileKey = getCurrentProfileKey("obtainedItems");
        configManager.setConfiguration(CONFIG_GROUP, profileKey, obtainedItems);
        saveAcquisitionLog();

        log.debug("Force saved profile data for: {}", config.currentProfile());
    }

    /**
     * Resets the current profile.
     */
    public void resetCurrentProfile() {
        plugin.resetBingoBoard(false);
        antiCheat.clearAcquisitionLog();

        log.debug("Reset current bingo profile: {}", config.currentProfile());
    }

    /**
     * Gets a profile-specific configuration key.
     *
     * @param profileName Name of the profile
     * @param key Base configuration key
     * @return Profile-specific configuration key
     */
    public String getProfileKey(String profileName, String key) {
        return profileName + "_" + key;
    }

    /**
     * Gets a configuration key for the current profile.
     *
     * @param key Base configuration key
     * @return Profile-specific configuration key for the current profile
     */
    public String getCurrentProfileKey(String key) {
        return getProfileKey(config.currentProfile(), key);
    }

    /**
     * Saves the acquisition log for the current profile.
     */
    private void saveAcquisitionLog() {
        String profileKey = getCurrentProfileKey(CONFIG_KEY_ACQUISITION_LOG);
        antiCheat.saveAcquisitionLog(profileKey);
    }

    /**
     * Loads the acquisition log for the current profile.
     */
    private void loadAcquisitionLog() {
        String profileKey = getCurrentProfileKey(CONFIG_KEY_ACQUISITION_LOG);
        antiCheat.loadAcquisitionLog(profileKey);
    }

    /**
     * Gets the profile-specific item list.
     * @return The item list for the current profile
     */
    public String getProfileItemList() {
        String profileKey = getCurrentProfileKey(CONFIG_KEY_ITEM_LIST);
        String itemList = configManager.getConfiguration(CONFIG_GROUP, profileKey);
        if (itemList == null || itemList.isEmpty()) {
            return config.itemList();
        }
        
        return itemList;
    }
    
    /**
     * Sets the profile-specific item list.
     * @param itemList The item list to set for the current profile
     */
    public void setProfileItemList(String itemList) {
        String profileKey = getCurrentProfileKey(CONFIG_KEY_ITEM_LIST);
        configManager.setConfiguration(CONFIG_GROUP, profileKey, itemList);
    }
    
    /**
     * Gets the profile-specific remote URL.
     * @return The remote URL for the current profile
     */
    public String getProfileRemoteUrl() {
        String profileKey = getCurrentProfileKey(CONFIG_KEY_REMOTE_URL);
        String remoteUrl = configManager.getConfiguration(CONFIG_GROUP, profileKey);
        if (remoteUrl == null || remoteUrl.isEmpty()) {
            return config.remoteUrl();
        }
        
        return remoteUrl;
    }
    
    /**
     * Sets the profile-specific remote URL.
     * @param remoteUrl The remote URL to set for the current profile
     */
    public void setProfileRemoteUrl(String remoteUrl) {
        String profileKey = getCurrentProfileKey(CONFIG_KEY_REMOTE_URL);
        configManager.setConfiguration(CONFIG_GROUP, profileKey, remoteUrl);
    }
    
    /**
     * Gets the profile-specific item source type.
     * @return The item source type for the current profile
     */
    public BingoConfig.ItemSourceType getProfileItemSourceType() {
        String profileKey = getCurrentProfileKey(CONFIG_KEY_ITEM_SOURCE_TYPE);
        String itemSourceType = configManager.getConfiguration(CONFIG_GROUP, profileKey);
        if (itemSourceType == null || itemSourceType.isEmpty()) {
            return config.itemSourceType();
        }
        
        try {
            return BingoConfig.ItemSourceType.valueOf(itemSourceType);
        } catch (IllegalArgumentException e) {
            return config.itemSourceType();
        }
    }
    
    /**
     * Sets the profile-specific item source type.
     * @param itemSourceType The item source type to set for the current profile
     */
    public void setProfileItemSourceType(BingoConfig.ItemSourceType itemSourceType) {
        String profileKey = getCurrentProfileKey(CONFIG_KEY_ITEM_SOURCE_TYPE);
        configManager.setConfiguration(CONFIG_GROUP, profileKey, itemSourceType.name());
    }

    /**
     * Gets the profile-specific refresh interval.
     * @return The refresh interval for the current profile
     */
    public int getProfileRefreshInterval() {
        String profileKey = getCurrentProfileKey(CONFIG_KEY_REFRESH_INTERVAL);
        String refreshInterval = configManager.getConfiguration(CONFIG_GROUP, profileKey);
        if (refreshInterval == null || refreshInterval.isEmpty()) {
            return config.refreshInterval();
        }
        
        try {
            return Integer.parseInt(refreshInterval);
        } catch (NumberFormatException e) {
            return config.refreshInterval();
        }
    }
    
    /**
     * Sets the profile-specific refresh interval.
     * @param refreshInterval The refresh interval to set for the current profile
     */
    public void setProfileRefreshInterval(int refreshInterval) {
        String profileKey = getCurrentProfileKey(CONFIG_KEY_REFRESH_INTERVAL);
        configManager.setConfiguration(CONFIG_GROUP, profileKey, refreshInterval);
    }

    /**
     * Gets the profile-specific persistObtained setting.
     * @return Whether obtained items should persist between sessions for the current profile
     */
    public boolean getProfilePersistObtained() {
        String profileKey = getCurrentProfileKey(CONFIG_KEY_PERSIST_OBTAINED);
        String persistObtained = configManager.getConfiguration(CONFIG_GROUP, profileKey);
        if (persistObtained == null || persistObtained.isEmpty()) {
            return config.persistObtained();
        }
        
        return Boolean.parseBoolean(persistObtained);
    }
    
    /**
     * Sets the profile-specific persistObtained setting.
     * @param persistObtained Whether obtained items should persist between sessions for the current profile
     */
    public void setProfilePersistObtained(boolean persistObtained) {
        String profileKey = getCurrentProfileKey(CONFIG_KEY_PERSIST_OBTAINED);
        configManager.setConfiguration(CONFIG_GROUP, profileKey, persistObtained);
    }
} 
package com.betterbingo;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class BetterBingoTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(BingoPlugin.class);
		RuneLite.main(args);
	}
}
