package com.gearswitch;

import lombok.Data;
import net.runelite.client.game.ItemManager;

@Data
class GearTagSettingsWithItemID
{
    GearTagSettings origTag;
    Integer itemID;
    String name;

    GearTagSettingsWithItemID(GearTagSettings tag, String key, ItemManager itemManager) {
        String[] split = key.split("_");
        this.itemID = split.length > 0 ? Integer.parseInt(split[split.length-1]) : null;

        this.origTag = tag;
        if(itemID != null)
            this.name = itemManager.getItemComposition(itemID).getMembersName();
    }

    public int getWeight() {
        return origTag.getWeight();
    }
}
package com.gearswitch;

import lombok.Getter;
import net.runelite.api.Skill;

enum AttackStyle
{
    ACCURATE("Accurate", Skill.ATTACK),
    AGGRESSIVE("Aggressive", Skill.STRENGTH),
    DEFENSIVE("Defensive", Skill.DEFENCE),
    CONTROLLED("Controlled", Skill.ATTACK, Skill.STRENGTH, Skill.DEFENCE),
    RANGING("Ranging", Skill.RANGED),
    LONGRANGE("Longrange", Skill.RANGED, Skill.DEFENCE),
    CASTING("Casting", Skill.MAGIC),
    DEFENSIVE_CASTING("Defensive Casting", Skill.MAGIC, Skill.DEFENCE),
    LONGRANGE_CASTING("Longrange Casting", Skill.MAGIC, Skill.DEFENCE),
    OTHER("Other");

    @Getter
    private final String name;
    @Getter
    private final Skill[] skills;

    AttackStyle(String name, Skill... skills)
    {
        this.name = name;
        this.skills = skills;
    }
}
package com.gearswitch;

import java.util.HashMap;
import java.util.Map;

public class ProfileSerialization {
    String name;
    Map<Integer, GearTagSettings> tags = new HashMap<>();
}

package com.gearswitch;

import com.google.common.base.Strings;
import lombok.Getter;
import lombok.Setter;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;

import javax.swing.*;
import java.awt.*;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.font.TextAttribute;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

import static com.gearswitch.GearSwitchAlertPlugin.profiles;
import static com.gearswitch.ProfilePanel.*;

public class GearSwitchAlertPanel extends PluginPanel {

    private final GearSwitchAlertPlugin plugin;
    private final ItemManager itemManager;

    private final IconTextField searchBar;
    private final JPanel listContainer = new JPanel();
    public final GearSwitchAlertConfig config;
    private final ClientThread clientThread;

    @Setter
    @Getter
    private ProfilePanel enabledProfileTile = null;

    GearSwitchAlertPanel(ClientThread clientThread, GearSwitchAlertPlugin plugin, ItemManager itemManager, GearSwitchAlertConfig config) {
        super();
        this.plugin = plugin;
        this.itemManager = itemManager;
        this.clientThread = clientThread;
        this.config = config;

        add(Box.createRigidArea(new Dimension(PluginPanel.PANEL_WIDTH - 10, 10)));

        Font font = FontManager.getRunescapeFont();
        Map<TextAttribute, Integer> attributes = new HashMap<>();
        attributes.put(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_ON);

        JLabel titleLabel = new JLabel("Dynamic Inventory Tags");
        titleLabel.setFont(font.deriveFont(Font.BOLD, 20).deriveFont(attributes));
        titleLabel.setHorizontalAlignment(SwingConstants.CENTER);
        add(titleLabel);

        add(Box.createRigidArea(new Dimension(PluginPanel.PANEL_WIDTH - 10, 10)));

        this.searchBar = new IconTextField();
        searchBar.setIcon(IconTextField.Icon.SEARCH);
        searchBar.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 30));
        searchBar.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        searchBar.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
        searchBar.setMinimumSize(new Dimension(0, 30));
        searchBar.addKeyListener(new KeyListener() {
            @Override
            public void keyTyped(KeyEvent e) {
            }

            @Override
            public void keyPressed(KeyEvent e) {
            }

            @Override
            public void keyReleased(KeyEvent e) {
                loadProfiles();
            }
        });
        searchBar.addClearListener(this::loadProfiles);
        add(searchBar);

        add(listContainer);
//        listContainer.setLayout(new GridLayout(0, 1, 0, 0));
        listContainer.setLayout(new BoxLayout(listContainer, BoxLayout.Y_AXIS));

        NewProfileManager newProfileManager = new NewProfileManager(plugin, this);

        add(newProfileManager);

        loadProfiles();
    }

    private int sortProfiles(Map.Entry<String, String> profile1, Map.Entry<String, String> profile2) {
        if(profile1.getKey().equals("0"))
            return -1;
        if(profile2.getKey().equals("0"))
            return 1;

        return profile1.getValue().compareTo(profile2.getValue());
    }


    void loadProfiles() {
        listContainer.removeAll();
        String search = searchBar.getText();
        String selectedProfile = plugin.loadSelectedProfile();

        for (Map.Entry<String, String> profile : profiles.entrySet().stream().sorted(this::sortProfiles).collect(Collectors.toList())) {
            if (Strings.isNullOrEmpty(search) || profile.getValue().toLowerCase().contains(search.toLowerCase())) {
                String key = profile.getKey();
                ProfilePanel tile = new ProfilePanel(clientThread, plugin, itemManager, this, key, profile.getValue());
                if(!key.equals(selectedProfile)) {
                    addMouseListener(key, tile);
                }
                else {
                    setEnabledProfileTile(tile);
                    tile.rowContainer.addMouseListener(new MouseAdapter() {
                        @Override
                        public void mouseClicked(MouseEvent e) {
                            if (SwingUtilities.isLeftMouseButton(e)) {
                                tile.toggle();
                            }
                        }
                        @Override
                        public void mouseEntered(MouseEvent e) {
                            tile.applyDimmer(false, tile.rowContainer);
                            if(tile.isCollapsed()) {
                                tile.collapseBtn.setIcon(COLLAPSED_ICON_HOVER);
                            } else {
                                tile.collapseBtn.setIcon(EXPANDED_ICON_HOVER);
                            }
                        }

                        @Override
                        public void mouseExited(MouseEvent e) {
                            tile.applyDimmer(true, tile.rowContainer);
                            if(tile.isCollapsed()) {
                                tile.collapseBtn.setIcon(COLLAPSED_ICON);
                            } else {
                                tile.collapseBtn.setIcon(EXPANDED_ICON);
                            }
                        }
                    });
                }
                listContainer.add(tile);
                listContainer.add(Box.createRigidArea(new Dimension(0, 3)));
            }
        }
        listContainer.revalidate();
        listContainer.repaint();
    }

    private void addMouseListener(String key, ProfilePanel tile) {
        tile.rowContainer.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                if (SwingUtilities.isLeftMouseButton(e)) {
                    plugin.setEnabledProfile(key);
                    tile.removeProfile.setIcon(TICKED_ICON_HOVER);
                    tile.rightPanel.add(tile.removeProfile, BorderLayout.EAST);
                    tile.rightPanel.remove(tile.addProfile);
                    tile.rightPanel.revalidate();
                    tile.rightPanel.repaint();

                    ProfilePanel enabledTile = getEnabledProfileTile();
                    if(enabledTile != null) {
                        enabledTile.rightPanel.add(enabledTile.addProfile, BorderLayout.EAST);
                        enabledTile.rightPanel.remove(enabledTile.removeProfile);
                        enabledTile.rightPanel.revalidate();
                        enabledTile.rightPanel.repaint();
                    }
                    setEnabledProfileTile(tile);

                    loadProfiles();
                    plugin.overlay.invalidateCache();
                }
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                tile.addProfile.setIcon(UNTICKED_ICON_HOVER);
                tile.applyDimmer(false, tile.rowContainer);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                tile.addProfile.setIcon(UNTICKED_ICON);
                tile.applyDimmer(true, tile.rowContainer);
            }
        });
    }

    public void reload() {
        loadProfiles();
        revalidate();
        repaint();
    }
}
package com.gearswitch;

/*
 * Copyright (c) 2018 kulers
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.WidgetItemOverlay;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.awt.*;
import java.awt.image.BufferedImage;

class GearsInventoryTagsOverlay extends WidgetItemOverlay
{
    private final ItemManager itemManager;
    private final GearSwitchAlertPlugin plugin;
    private final GearSwitchAlertConfig config;
    private final Cache<Long, Image> fillCache;
    private final Cache<Integer, GearTagSettings> tagCache;
    private long delayTimerStart;

    @Inject
    private GearsInventoryTagsOverlay(ItemManager itemManager, GearSwitchAlertPlugin plugin, GearSwitchAlertConfig config)
    {
        this.itemManager = itemManager;
        this.plugin = plugin;
        this.config = config;
//        showOnEquipment();
        showOnInventory();
        showOnInterfaces(
                InterfaceID.CHAMBERS_OF_XERIC_INVENTORY,
                InterfaceID.CHAMBERS_OF_XERIC_STORAGE_UNIT_PRIVATE,
                InterfaceID.CHAMBERS_OF_XERIC_STORAGE_UNIT_SHARED,
                InterfaceID.GRAVESTONE
        );
        fillCache = CacheBuilder.newBuilder()
                .concurrencyLevel(1)
                .maximumSize(32)
                .build();
        tagCache = CacheBuilder.newBuilder()
                .concurrencyLevel(1)
                .maximumSize(32)
                .build();
    }

    @Override
    public void renderItemOverlay(Graphics2D graphics, int itemId, WidgetItem widgetItem)
    {
        final GearTagSettings gearTagSettings = getTag(itemId);
        if (gearTagSettings == null)
        {
            return;
        }

        long currentTime = System.currentTimeMillis();
        long delayRequired = config.millisecondsBeforeTagging();
        if(delayTimerStart != 0 && delayRequired > 0 && (currentTime - delayTimerStart) < delayRequired) {
            return;
        }

        AttackType attackType = plugin.getAttackType();
        Color color = null;
        switch (attackType) {
            case RANGE:
                if(!gearTagSettings.isRangeGear)
                    return;

                color = config.defaultColourRanged();
                break;
            case MAGIC:
                if(!gearTagSettings.isMagicGear)
                    return;

                color = config.defaultColourMagic();
                break;
            case MELEE:
                if(!gearTagSettings.isMeleeGear)
                    return;

                color = config.defaultColourMelee();
                break;
            case OTHER:
                return;
        }

        Rectangle bounds = widgetItem.getCanvasBounds();
        if (config.showTagOutline())
        {
            final BufferedImage outline = itemManager.getItemOutline(itemId, widgetItem.getQuantity(), color);
            graphics.drawImage(outline, (int) bounds.getX(), (int) bounds.getY(), null);
        }

        if (config.showTagFill())
        {
            final Image image = getFillImage(color, widgetItem.getId(), widgetItem.getQuantity());
            graphics.drawImage(image, (int) bounds.getX(), (int) bounds.getY(), null);
        }

        if (config.showTagUnderline())
        {
            int heightOffSet = (int) bounds.getY() + (int) bounds.getHeight() + 2;
            graphics.setColor(color);
            graphics.drawLine((int) bounds.getX()-2, heightOffSet, (int) bounds.getX()-2 + (int) bounds.getWidth(), heightOffSet);
        }

        if (config.showBoxAround())
        {
            int heightOffSet = (int) bounds.getY() + (int) bounds.getHeight();
            graphics.setColor(color);
            graphics.drawLine((int) bounds.getX()-2, (int) bounds.getY(), (int) bounds.getX()-2 + (int) bounds.getWidth(), (int) bounds.getY());
            graphics.drawLine((int) bounds.getX()-2, (int) bounds.getY(), (int) bounds.getX()-2, heightOffSet);
            graphics.drawLine((int) bounds.getX()-2 + (int) bounds.getWidth(), (int) bounds.getY(), (int) bounds.getX()-1 + (int) bounds.getWidth(), heightOffSet);
            graphics.drawLine((int) bounds.getX()-2, heightOffSet, (int) bounds.getX()-2 + (int) bounds.getWidth(), heightOffSet);
        }
    }

    private GearTagSettings getTag(int itemId) {
        GearTagSettings gearTagSettings = tagCache.getIfPresent(itemId);
        if (gearTagSettings == null)
        {
            gearTagSettings = plugin.getTag(itemId);
            if (gearTagSettings == null)
            {
                return null;
            }

            tagCache.put(itemId, gearTagSettings);
        }
        return gearTagSettings;
    }

    private Image getFillImage(Color color, int itemId, int qty)
    {
        long key = (((long) itemId) << 32) | qty;
        Image image = fillCache.getIfPresent(key);
        if (image == null)
        {
            final Color fillColor = ColorUtil.colorWithAlpha(color, config.fillOpacity());
            image = ImageUtil.fillImage(itemManager.getImage(itemId, qty, false), fillColor);
            fillCache.put(key, image);
        }
        return image;
    }

    void invalidateCache()
    {
        fillCache.invalidateAll();
        tagCache.invalidateAll();
    }

    void resetDelayTimer() {
        delayTimerStart = System.currentTimeMillis();
    }
}
package com.gearswitch;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.FlatTextField;

import javax.swing.*;
import java.awt.*;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.io.IOException;

@Slf4j
public class NewProfileManager extends PluginPanel {
    private final JLabel inputLabel;
    private final FlatTextField nameInput;

    NewProfileManager(GearSwitchAlertPlugin plugin, GearSwitchAlertPanel panel) {
        super();

        this.inputLabel = new JLabel("Profile Name");
        add(inputLabel);

        this.nameInput = new FlatTextField();
        nameInput.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 30));
        nameInput.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        nameInput.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
        nameInput.setMinimumSize(new Dimension(0, 30));
        add(nameInput);

        JButton addProfileButton = new JButton();
        addProfileButton.setText("Add Profile");
        addProfileButton.setHorizontalAlignment(JLabel.CENTER);
        addProfileButton.setFocusable(false);
        addProfileButton.setPreferredSize((new Dimension(PluginPanel.PANEL_WIDTH - 10, 30)));
        addProfileButton.addActionListener(e ->
        {
            if (nameInput.getText().isEmpty()) {
                JOptionPane.showMessageDialog(inputLabel, "Must add a profile name!", null, JOptionPane.ERROR_MESSAGE);
                return;
            }
            plugin.addProfile(nameInput.getText());
            plugin.loadProfiles();
            panel.loadProfiles();
        });
        add(addProfileButton);

        JButton importProfileButton = new JButton();
        importProfileButton.setText("Import Profile From Clipboard");
        importProfileButton.setHorizontalAlignment(JLabel.CENTER);
        importProfileButton.setFocusable(false);
        importProfileButton.setPreferredSize((new Dimension(PluginPanel.PANEL_WIDTH - 10, 30)));
        importProfileButton.addActionListener(e ->
        {
            final String clipboardText;
            try
            {
                clipboardText = Toolkit.getDefaultToolkit().getSystemClipboard().getData(DataFlavor.stringFlavor).toString();
            }
            catch (IOException | UnsupportedFlavorException ignore)
            {
                JOptionPane.showMessageDialog(importProfileButton, "Nothing in clipboard!", null, JOptionPane.ERROR_MESSAGE);
                return;
            }
            plugin.importProfileFromClipboard(clipboardText, importProfileButton);
        });
        add(importProfileButton);
    }
}
package com.gearswitch;

import lombok.Getter;
import net.runelite.api.Skill;

enum AttackType {
    MELEE("MELEE", Skill.ATTACK),
    MAGIC("MAGIC", Skill.MAGIC),
    RANGE("RANGE", Skill.RANGED),
    OTHER("Other");

    @Getter
    private final String name;
    @Getter
    private final Skill[] skills;

    AttackType(String name, Skill... skills)
    {
        this.name = name;
        this.skills = skills;
    }
}
package com.gearswitch;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.config.*;

import java.awt.*;

@ConfigGroup(GearSwitchAlertConfig.GROUP)
public interface GearSwitchAlertConfig extends Config
{
	String GROUP = "gearswitchalert";
	@ConfigSection(
			name = "Default Tag Colours",
			description = "Colours used to represent each attack style",
			position = 0
	)
	String defaultColourSection = "defaultColourSection";
	@Alpha
	@ConfigItem(
			keyName = "defaultColourMelee",
			name = "Melee Tag",
			description = "Default melee tag colour",
			position = 0,
			section = defaultColourSection
	)
	default Color defaultColourMelee()
	{
		return Color.RED;
	}
	@Alpha
	@ConfigItem(
			keyName = "defaultColourRanged",
			name = "Ranged Tag",
			description = "Default ranged tag colour",
			position = 1,
			section = defaultColourSection
	)
	default Color defaultColourRanged()
	{
		return Color.GREEN;
	}
	@Alpha
	@ConfigItem(
			keyName = "defaultColourMagic",
			name = "Magic Tag",
			description = "Default magic tag colour",
			position = 2,
			section = defaultColourSection
	)
	default Color defaultColourMagic()
	{
		return Color.BLUE;
	}
	@ConfigSection(
			name = "Tag Display Mode",
			description = "How tags are displayed in the inventory",
			position = 3
	)
	String tagStyleSection = "tagStyleSection";

	@ConfigItem(
			position = 3,
			keyName = "showTagOutline",
			name = "Outline",
			description = "Configures whether or not item tags show be outlined",
			section = tagStyleSection
	)
	default boolean showTagOutline()
	{
		return true;
	}

	@ConfigItem(
			position = 4,
			keyName = "tagUnderline",
			name = "Underline",
			description = "Configures whether or not item tags should be underlined",
			section = tagStyleSection
	)
	default boolean showTagUnderline()
	{
		return false;
	}

	@ConfigItem(
			position = 5,
			keyName = "tagBox",
			name = "Box",
			description = "Configures whether or not item tags should have a box around it",
			section = tagStyleSection
	)
	default boolean showBoxAround()
	{
		return false;
	}

	@ConfigItem(
			position = 6,
			keyName = "tagFill",
			name = "Fill",
			description = "Configures whether or not item tags should be filled",
			section = tagStyleSection
	)
	default boolean showTagFill()
	{
		return false;
	}

	@Range(
			max = 255
	)
	@ConfigItem(
			position = 7,
			keyName = "fillOpacity",
			name = "Fill opacity",
			description = "Configures the opacity of the tag \"Fill\"",
			section = tagStyleSection
	)
	default int fillOpacity()
	{
		return 50;
	}


	@ConfigSection(
			name = "Panel Settings",
			description = "Settings specific to the side panel tool.",
			position = 8
	)
	String panelSection = "panelSection";

	@ConfigItem(
			keyName = "hidePlugin",
			name = "Hide on toolbar",
			description = "When checked, the plugin will not appear in the tool bar",
			position = 8,
			section = panelSection
	)
	default boolean hidePlugin() {
		return false;
	}

	@Getter
	@RequiredArgsConstructor
	enum SortMethod
	{
		NONE("None"),
		EMPTY_FIRST("Place non-tagged items first"),
		ALL_FIRST("Place items tagged with more styles first");

		final String name;
	}
	@ConfigItem(
			position = 9,
			keyName = "tagSortMethod",
			name = "Tags Sort Method",
			description = "Sorting method used on tagged item boxes in the panel. <br/>None = no sorting<br/> Empty First = Place non-tagged items first<br/> All First = Place items tagged with more styles first",
			section = panelSection
	)
	default SortMethod sortItems() { return SortMethod.ALL_FIRST; }


	@ConfigSection(
			name = "General Settings",
			description = "Settings plugin settings.",
			position = 10
	)
	String generalSection = "generalSection";

	@ConfigItem(
			keyName = "allowTaggingUnequipables",
			name = "Allow tagging unequipable items",
			description = "Should unequipable items be allowed to be tagged as melee/range/magic gear?",
			position = 10,
			section = generalSection
	)
	default boolean allowTaggingUnequipables() {
		return false;
	}

	@ConfigItem(
			keyName = "secondsBeforeTagging",
			name = "Tagging Delay (ms)",
			description = "Delay (in milliseconds) before tagging if the gear is still not switched?",
			position = 11,
			section = generalSection
	)
	default int millisecondsBeforeTagging() {
		return 0;
	}
}

package com.gearswitch;

import com.google.common.base.Strings;
import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Provides;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import net.runelite.api.*;
import net.runelite.api.Menu;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.MenuOpened;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemEquipmentStats;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStats;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.game.chatbox.ChatboxItemSearch;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.*;
import java.awt.datatransfer.StringSelection;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static com.gearswitch.AttackStyle.*;

@Slf4j
@PluginDescriptor(
		name = "Dynamic Inventory Tags"
)
public class GearSwitchAlertPlugin extends Plugin
{
	public static Map<String, String> profiles = new HashMap<>();

	@Inject
	private Client client;

	@Inject
	private ItemManager itemManager;

	@Inject
	private ConfigManager configManager;

	@Inject
	private GearSwitchAlertConfig config;

	@Inject
	public GearsInventoryTagsOverlay overlay;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private Gson gson;

	@Inject
	private ClientToolbar clientToolbar;
	@Inject
	private ClientThread clientThread;

	@Inject
	private SpriteManager spriteManager;

	@Inject
	@Getter
	private ChatboxItemSearch itemSearch;

	@Getter
    private AttackType attackType;
	private boolean isCurrentTwoHanded;
	private static final String TAG_KEY_PREFIX = "gear_tag_";
	private static final String PROFILES_PREFIX = "gear_profiles";
	private static final String SELECTED_PROFILE_PREFIX = "gear_selected_profile";
	private static final String CUSTOM_ID = "customId";
	private static final String ID_PREFIX = "ID";

	private GearSwitchAlertPanel panel;
	private NavigationButton navButton;

    private final Map<Prayer, BufferedImage> prayerSprites = new HashMap<>();

	@Override
	protected void startUp() throws Exception {
		clientThread.invoke(this::loadSprites);
		loadProfiles();
		overlayManager.add(overlay);

		panel = new GearSwitchAlertPanel(clientThread, this, itemManager, config);
		final BufferedImage icon = ImageUtil.loadImageResource(GearSwitchAlertPlugin.class, "dynamic_tags_icon.png");

		navButton = NavigationButton.builder()
				.tooltip("Dynamic Inventory Tags")
				.icon(icon)
				.panel(panel)
				.build();

		if (!config.hidePlugin()) {
			clientToolbar.addNavigation(navButton);
		}
	}

	@Override
	protected void shutDown() throws Exception {
		overlayManager.remove(overlay);

		if (!config.hidePlugin()) {
			clientToolbar.removeNavigation(navButton);
		}
	}

	@Subscribe
	public void onConfigChanged(final ConfigChanged event) {
		if (event.getGroup().equals(GearSwitchAlertConfig.GROUP)) {
			if (event.getKey().equals("hidePlugin")) {
				if (config.hidePlugin()) {
					clientToolbar.removeNavigation(navButton);
				} else {
					clientToolbar.addNavigation(navButton);
				}
			}
		}
	}


	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event) {
		ItemContainer itemContainer = event.getItemContainer();
		if (itemContainer != client.getItemContainer(InventoryID.EQUIPMENT)) {
			return;
		}

		UpdateEquippedWeaponInfo(true);
	}

	@Provides
    GearSwitchAlertConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(GearSwitchAlertConfig.class);
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event) {
		if (event.getVarpId() == VarPlayer.ATTACK_STYLE
				|| event.getVarbitId() == Varbits.EQUIPPED_WEAPON_TYPE
				|| event.getVarbitId() == Varbits.DEFENSIVE_CASTING_MODE) {
			UpdateEquippedWeaponInfo(false);
		}
	}

	private AttackStyle[] getWeaponTypeStyles(int weaponType)
	{
		// from script4525
		int weaponStyleEnum = client.getEnum(EnumID.WEAPON_STYLES).getIntValue(weaponType);
		int[] weaponStyleStructs = client.getEnum(weaponStyleEnum).getIntVals();

		AttackStyle[] styles = new AttackStyle[weaponStyleStructs.length];
		int i = 0;
		for (int style : weaponStyleStructs)
		{
			StructComposition attackStyleStruct = client.getStructComposition(style);
			String attackStyleName = attackStyleStruct.getStringValue(ParamID.ATTACK_STYLE_NAME);

			AttackStyle attackStyle = AttackStyle.valueOf(attackStyleName.toUpperCase());
			if (attackStyle == OTHER)
			{
				// "Other" is used for no style
				++i;
				continue;
			}

			// "Defensive" is used for Defensive and also Defensive casting
			if (i == 5 && attackStyle == DEFENSIVE)
			{
				attackStyle = DEFENSIVE_CASTING;
			}

			styles[i++] = attackStyle;
		}
		return styles;
	}

	private void UpdateEquippedWeaponInfo(boolean forceInvalidate) {
		final int attackStyleIndex = client.getVarpValue(VarPlayer.ATTACK_STYLE);
		final int currentEquippedWeaponTypeVarbit = client.getVarbitValue(Varbits.EQUIPPED_WEAPON_TYPE);
		final int castingMode = client.getVarbitValue(Varbits.DEFENSIVE_CASTING_MODE);

		AttackStyle newAttackStyle = OTHER;
		AttackStyle[] attackStyles = getWeaponTypeStyles(currentEquippedWeaponTypeVarbit);
		if (attackStyleIndex < attackStyles.length) {
			newAttackStyle = attackStyles[attackStyleIndex];
			if (newAttackStyle == null) {
				newAttackStyle = OTHER;
			} else if ((newAttackStyle == DEFENSIVE) && (attackStyles[0] == CASTING)) {
				newAttackStyle = DEFENSIVE_CASTING;
			} else if ((newAttackStyle == LONGRANGE) && (attackStyles[0] == CASTING)) {
				newAttackStyle = LONGRANGE_CASTING;
			}
		}

		AttackType newAttackType = AttackType.OTHER;
		switch (newAttackStyle) {
			case ACCURATE:
			case DEFENSIVE:
			case AGGRESSIVE:
			case CONTROLLED:
				newAttackType = AttackType.MELEE;
				break;
			case RANGING:
			case LONGRANGE:
				newAttackType = AttackType.RANGE;
				break;
			case CASTING:
			case DEFENSIVE_CASTING:
			case LONGRANGE_CASTING:
				newAttackType = AttackType.MAGIC;
				break;
		}

		if(newAttackType != attackType || forceInvalidate) {
			overlay.invalidateCache();
		}
		attackType = newAttackType;

		ItemContainer equipmentContainer = client.getItemContainer(InventoryID.EQUIPMENT);
		if(equipmentContainer != null) {
			Item weapon = equipmentContainer.getItem(EquipmentInventorySlot.WEAPON.getSlotIdx());
			if(weapon != null) {
				int weaponId = weapon.getId();
				isCurrentTwoHanded = getItemStats(weaponId).getEquipment().isTwoHanded();
			}
		}

		overlay.resetDelayTimer();
	}

	GearTagSettings getTag(int itemId) {
		ItemStats weaponStats = getItemStats(itemId);

		if (weaponStats != null) {
			ItemEquipmentStats eStats = weaponStats.getEquipment();
			if (eStats != null) {
				if (eStats.getSlot() != EquipmentInventorySlot.WEAPON.getSlotIdx()) {
					if (eStats.getSlot() == EquipmentInventorySlot.SHIELD.getSlotIdx() && isCurrentTwoHanded) {
						return null;
					}
				}
			}
		}

		String profile = loadSelectedProfile();
		String profilePrefix = profile.equals("0") ? "" : profile + "_";
		String tag = configManager.getConfiguration(GearSwitchAlertConfig.GROUP, TAG_KEY_PREFIX + profilePrefix + itemId);
		if (tag == null || tag.isEmpty()) {
			return null;
		}

		return gson.fromJson(tag, GearTagSettings.class);
	}

	ArrayList<GearTagSettingsWithItemID> getTagsForProfile(String profileID) {
		ArrayList<GearTagSettingsWithItemID> result = new ArrayList<>();
		String profilePrefix = profileID.equals("0") ? "" : profileID + "_";

		List<String> keys = configManager.getConfigurationKeys(GearSwitchAlertConfig.GROUP + "." + TAG_KEY_PREFIX + profilePrefix);

		if (keys == null || keys.isEmpty()) {
			return result;
		}

		if(profileID.equals("0")) {
			for (String key : keys) {
				String[] split = key.split(TAG_KEY_PREFIX + profilePrefix);
				boolean isNotDefaultProfileKey = split[1].startsWith(ID_PREFIX);
				if(!isNotDefaultProfileKey) {
					String tag = configManager.getConfiguration(GearSwitchAlertConfig.GROUP, TAG_KEY_PREFIX + profilePrefix + split[1]);
					if(tag != null && !tag.isEmpty()) {
						GearTagSettings gearTag = gson.fromJson(tag, GearTagSettings.class);
//						if(gearTag.isMeleeGear || gearTag.isRangeGear || gearTag.isMagicGear) {
						GearTagSettingsWithItemID tagWithID = new GearTagSettingsWithItemID(gearTag, key, itemManager);
						result.add(tagWithID);
//						}
					}
				}
			}
		} else {
			for (String key : keys) {
				String[] split = key.split(TAG_KEY_PREFIX + profilePrefix);
				String tag = configManager.getConfiguration(GearSwitchAlertConfig.GROUP, TAG_KEY_PREFIX + profilePrefix + split[1]);
				if(tag != null && !tag.isEmpty()) {
					GearTagSettings gearTag = gson.fromJson(tag, GearTagSettings.class);
//					if(gearTag.isMeleeGear || gearTag.isRangeGear || gearTag.isMagicGear) {
					GearTagSettingsWithItemID tagWithID = new GearTagSettingsWithItemID(gearTag, key, itemManager);
					result.add(tagWithID);
//					}
				}
			}
		}

		GearSwitchAlertConfig.SortMethod sortMethod = config.sortItems();
		if(sortMethod != GearSwitchAlertConfig.SortMethod.NONE) {
			result.sort((tag1, tag2) -> sortMethod == GearSwitchAlertConfig.SortMethod.ALL_FIRST ?
					tag2.getWeight() - tag1.getWeight() :
					tag1.getWeight() - tag2.getWeight() );
		}

		return result;
	}

	void setTag(int itemId, GearTagSettings gearTagSettings) {
		setTag(itemId, gearTagSettings, loadSelectedProfile());
	}

	void setTag(int itemId, GearTagSettings gearTagSettings, String profileUUID) {
		String json = gson.toJson(gearTagSettings);
		String profilePrefix = profileUUID.equals("0") ? "" : profileUUID + "_";
		configManager.setConfiguration(GearSwitchAlertConfig.GROUP, TAG_KEY_PREFIX + profilePrefix + itemId, json);
		overlay.invalidateCache();
		ProfilePanel tile = panel.getEnabledProfileTile();
		if(tile != null)
			clientThread.invokeLater(tile::rebuild);
	}

	void unsetTag(int itemId, String profileUUID) {
		String profilePrefix = profileUUID.equals("0") ? "" : profileUUID + "_";
		configManager.unsetConfiguration(GearSwitchAlertConfig.GROUP, TAG_KEY_PREFIX + profilePrefix + itemId);
	}

	@Subscribe
	public void onMenuOpened(final MenuOpened event) {
		if (!client.isKeyPressed(KeyCode.KC_SHIFT)) {
			return;
		}

		final MenuEntry[] entries = event.getMenuEntries();
		for (int idx = entries.length - 1; idx >= 0; --idx) {
			final MenuEntry entry = entries[idx];
			final Widget w = entry.getWidget();

			if(w != null) {
				final int group = WidgetUtil.componentToInterface(w.getId());
				if ((group == InterfaceID.INVENTORY || group == InterfaceID.EQUIPMENT)
						&& "Examine".equals(entry.getOption()) && entry.getIdentifier() == 10) {
					int itemId = w.getItemId();
					if (itemId == -1 && w.getChildren() != null) {
						for (Widget child : w.getChildren()) {
							itemId = child.getItemId();
							if (itemId != -1)
								break;
						}
					}

					if (itemId == -1)
						return;

					ItemStats itemStats = itemManager.getItemStats(itemId);
					if (!config.allowTaggingUnequipables() && (itemStats == null || !itemStats.isEquipable())) {
						return;
					}

					final GearTagSettings gearTagSettings = getTag(itemId);
					final Menu parent = client.getMenu().createMenuEntry(idx)
							.setOption("Gear Switch Alert Tagging")
							.createSubMenu();

					boolean isMeleeEnabled, isRangeEnabled, isMagicEnabled;
					if (gearTagSettings != null) {
						isMeleeEnabled = gearTagSettings.isMeleeGear;
						isRangeEnabled = gearTagSettings.isRangeGear;
						isMagicEnabled = gearTagSettings.isMagicGear;
					} else {
						isMagicEnabled = false;
						isMeleeEnabled = false;
						isRangeEnabled = false;
					}
					int finalItemId = itemId;

					parent.createMenuEntry(0)
							.setOption(ColorUtil.prependColorTag(isMeleeEnabled ? "Unset Melee Gear" : "Set Melee Gear", config.defaultColourMelee()))
							.setType(MenuAction.RUNELITE)
							.onClick(e ->
									toggleGearTag(gearTagSettings, finalItemId, true, false, false));

					parent.createMenuEntry(0)
							.setOption(ColorUtil.prependColorTag(isRangeEnabled ? "Unset Range Gear" : "Set Range Gear", config.defaultColourRanged()))
							.setType(MenuAction.RUNELITE)
							.onClick(e ->
									toggleGearTag(gearTagSettings, finalItemId, false, true, false));

					parent.createMenuEntry(0)
							.setOption(ColorUtil.prependColorTag(isMagicEnabled ? "Unset Magic Gear" : "Set Magic Gear", config.defaultColourMagic()))
							.setType(MenuAction.RUNELITE)
							.onClick(e ->
									toggleGearTag(gearTagSettings, finalItemId, false, false, true));

				}
			}
		}
	}

	public void toggleGearTag(GearTagSettingsWithItemID tag, boolean toggleMelee, boolean toggleRanged, boolean toggleMagic) {
		toggleGearTag(tag.origTag, tag.itemID, toggleMelee, toggleRanged, toggleMagic);
	}

	public void toggleGearTag(GearTagSettings tag, int itemId, boolean toggleMelee, boolean toggleRanged, boolean toggleMagic) {
		GearTagSettings newGearTagSettings = tag;
		if (newGearTagSettings == null)
			newGearTagSettings = new GearTagSettings();

		newGearTagSettings.isMeleeGear = toggleMelee != newGearTagSettings.isMeleeGear;
		newGearTagSettings.isRangeGear = toggleRanged != newGearTagSettings.isRangeGear;
		newGearTagSettings.isMagicGear = toggleMagic != newGearTagSettings.isMagicGear;
		setTag(itemId, newGearTagSettings);
	}

	private ItemStats getItemStats(int itemId) {
		return itemManager.getItemStats(itemId);
	}

	public String loadSelectedProfile() {
		String profileID = configManager.getConfiguration(GearSwitchAlertConfig.GROUP, SELECTED_PROFILE_PREFIX);

		if (Strings.isNullOrEmpty(profileID)) {
			return "0";
		}

		String ID = gson.fromJson(profileID, new TypeToken<String>() {
		}.getType());

		if(profiles.containsKey(ID))
			return ID;
		else
			return "0";
	}

	public void loadProfiles() {
		Map<String, String> parsed = new HashMap<>();
		parsed.put("0", "Default");
		//merge in any custom profiles
		Map<String, String> customProfiles = loadCustomProfiles();
		parsed.putAll(customProfiles);

		profiles = parsed;
	}

	private Map<String, String> loadCustomProfiles() {
		String json = configManager.getConfiguration(GearSwitchAlertConfig.GROUP, PROFILES_PREFIX);

		if (Strings.isNullOrEmpty(json)) {
			return new HashMap<>();
		}
		return gson.fromJson(json, new TypeToken<Map<String, String>>() {
		}.getType());
	}

	Integer loadCustomId() {
		String json = configManager.getConfiguration(GearSwitchAlertConfig.GROUP, CUSTOM_ID);

		if (Strings.isNullOrEmpty(json)) {
			//default to 9999 because we add 1, and I want it to start at an even 10k.
			return 0;
		}
		return gson.fromJson(json, new TypeToken<Integer>() {
		}.getType());
	}

	public String addProfile(String name) {
		int customId = loadCustomId() + 1;
		Map<String, String> customProfiles = loadCustomProfiles();
		String newID = ID_PREFIX + customId;
		customProfiles.put(newID, name);

		String json = gson.toJson(customProfiles);
		configManager.setConfiguration(GearSwitchAlertConfig.GROUP, PROFILES_PREFIX, json);
		configManager.setConfiguration(GearSwitchAlertConfig.GROUP, CUSTOM_ID, customId);

		return newID;
	}

	public void deleteProfile(String profileUUID) {
		if(profileUUID.equals("0"))
			return;

		String loadedProfile = loadSelectedProfile();
		if(loadedProfile.equals(profileUUID))
			setEnabledProfile("0");

		Map<String, String> customProfiles = loadCustomProfiles();
		customProfiles.remove(profileUUID);
		if (customProfiles.isEmpty()) {
			configManager.unsetConfiguration(GearSwitchAlertConfig.GROUP, PROFILES_PREFIX);
			return;
		}

		String json = gson.toJson(customProfiles);
		configManager.setConfiguration(GearSwitchAlertConfig.GROUP, PROFILES_PREFIX, json);
	}

	public void setEnabledProfile(String profileUUID) {
		configManager.setConfiguration(GearSwitchAlertConfig.GROUP, SELECTED_PROFILE_PREFIX, profileUUID);
	}

	private void loadSprites() {
		for (Prayer p : new Prayer[]{Prayer.PROTECT_FROM_MELEE, Prayer.PROTECT_FROM_MISSILES, Prayer.PROTECT_FROM_MAGIC}) {
			BufferedImage img = spriteManager.getSprite(p.getSpriteID(), 0);
			if (img != null) {
				BufferedImage norm = new BufferedImage(32, 32, BufferedImage.TYPE_INT_ARGB);
				Graphics g = norm.getGraphics();
				g.drawImage(img, norm.getWidth() / 2 - img.getWidth() / 2, norm.getHeight() / 2 - img.getHeight() / 2, null);
				prayerSprites.put(p, norm);
			}
		}

		if(panel != null)
			SwingUtilities.invokeLater(panel::loadProfiles);
	}

	BufferedImage getSprite(Prayer p) {
		return prayerSprites.get(p);
	}

	public void duplicateProfile(String profileUUID, String name) {
		clientThread.invokeLater(() -> {
			String newProfileID = addProfile(name);
			setEnabledProfile(newProfileID);
			for(GearTagSettingsWithItemID tag : getTagsForProfile(profileUUID)) {
				setTag(tag.itemID, tag.origTag, newProfileID);
			}

			loadProfiles();
			SwingUtilities.invokeLater(() -> {
				panel.reload();
			});
		});
	}

	public void addTagBySearch(String profileUDID) {
		if (client.getGameState() != GameState.LOGGED_IN) {
			JOptionPane.showMessageDialog(panel,
					"You must be logged in to search.",
					"Cannot Search for Item",
					JOptionPane.ERROR_MESSAGE);
			return;
		}

		itemSearch
				.tooltipText("Add item tag")
				.onItemSelected((itemId) ->
						clientThread.invokeLater(() ->
						{
							int finalId = itemManager.canonicalize(itemId);
							ItemStats itemStats = itemManager.getItemStats(finalId);
							if(config.allowTaggingUnequipables() || (itemStats != null && itemStats.isEquipable())) {
								setTag(finalId, new GearTagSettings(), profileUDID);
							} else {
								SwingUtilities.invokeLater(() ->
										JOptionPane.showMessageDialog(panel,
												"Only equipable items can be tagged!",
												"Cannot Add Item Tag",
												JOptionPane.ERROR_MESSAGE));
							}
						}))
				.build();
	}

	public void removeTag(Integer itemID, String profileUUID) {
		unsetTag(itemID, profileUUID);
		loadProfiles();
		overlay.invalidateCache();
		panel.reload();
	}

	public void removeAllTags(String profileUUID) {
		clientThread.invokeLater(() -> {
			for(GearTagSettingsWithItemID tag : getTagsForProfile(profileUUID)) {
				unsetTag(tag.itemID, profileUUID);
			}
			loadProfiles();
			overlay.invalidateCache();

			SwingUtilities.invokeLater(() -> {
				panel.reload();
			});
		});
	}

	public void importProfileFromClipboard(String clipboardText, Component parent) {
		clientThread.invokeLater(() -> {
			try {
				ProfileSerialization profileSerialization = gson.fromJson(clipboardText, new TypeToken<ProfileSerialization>() {
				}.getType());
				String profileID = addProfile(profileSerialization.name);
				for (Map.Entry<Integer, GearTagSettings> set : profileSerialization.tags.entrySet()) {
					Integer itemId = set.getKey();
					GearTagSettings tag = set.getValue();

					setTag(itemId, tag, profileID);
				}
				loadProfiles();
				overlay.invalidateCache();
				SwingUtilities.invokeLater(() -> {
					panel.reload();
				});
			} catch (JsonSyntaxException e) {
				SwingUtilities.invokeLater(() -> JOptionPane.showMessageDialog(parent, "Nothing in clipboard!", null, JOptionPane.ERROR_MESSAGE));
			}
		});
	}

	public void exportProfileToClipboard(String profileID, Component parent) {
		if(profiles.containsKey(profileID)) {
			clientThread.invokeLater(() -> {
				ProfileSerialization profileSerialization = new ProfileSerialization();
				profileSerialization.name = profiles.get(profileID);

				ArrayList<GearTagSettingsWithItemID> tags = getTagsForProfile(profileID);
				for (GearTagSettingsWithItemID tag : tags) {
					profileSerialization.tags.put(tag.itemID, tag.origTag);
				}

				String json = gson.toJson(profileSerialization);

				try {
					Toolkit.getDefaultToolkit().getSystemClipboard().setContents(new StringSelection(json), null);
				} catch (Exception e) {
					SwingUtilities.invokeLater(() -> JOptionPane.showMessageDialog(parent, "Failed to export to clipboard!", null, JOptionPane.ERROR_MESSAGE));
				}
			});
		} else {
			SwingUtilities.invokeLater(() -> JOptionPane.showMessageDialog(parent, "Profile Not Found!", null, JOptionPane.ERROR_MESSAGE));
		}
	}

	@Subscribe
	void onGameStateChanged(GameStateChanged event) {
		if(event.getGameState().equals(GameState.LOGGED_IN)) {
			overlay.resetDelayTimer();
		}
	}
}

package com.gearswitch;

import lombok.Data;

@Data
class GearTagSettings
{
    boolean isMeleeGear;
    boolean isRangeGear;
    boolean isMagicGear;

    public int getWeight() {
        return (isMeleeGear ? 100 : 0) + (isRangeGear ? 10 : 0) + (isMagicGear ? 1 : 0);
    }
}
package com.gearswitch;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.SpriteID;

@Getter
@RequiredArgsConstructor
enum Prayer
{
    PROTECT_FROM_MELEE(SpriteID.SKILL_ATTACK),
    PROTECT_FROM_MISSILES(SpriteID.SKILL_RANGED),
    PROTECT_FROM_MAGIC(SpriteID.SKILL_MAGIC);

    private final int spriteID;
}
package com.gearswitch;

import com.google.common.base.Strings;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.ArrayList;

import static java.awt.image.BufferedImage.TYPE_INT_ARGB;

@Slf4j
class ProfilePanel extends JPanel {

    private static final int ROW_WIDTH = PluginPanel.PANEL_WIDTH - 10;
    private static final int ROW_HEIGHT = 30;
    private static final int RIGHT_PANEL_WIDTH = 60;
    private static final int ITEMS_PER_ROW = 5;

    static final ImageIcon UNTICKED_ICON;
    static final ImageIcon UNTICKED_ICON_HOVER;
    private static final ImageIcon TICKED_ICON;
    static final ImageIcon TICKED_ICON_HOVER;
    private static final ImageIcon DELETE_ICON;
    private static final ImageIcon DELETE_ICON_HOVER;
    static final ImageIcon COLLAPSED_ICON;
    static final ImageIcon COLLAPSED_ICON_HOVER;
    static final ImageIcon EXPANDED_ICON;
    static final ImageIcon EXPANDED_ICON_HOVER;
    static final ImageIcon PLUS_ICON;
    static final ImageIcon PLUS_ICON_HOVER;
    private static final int PRAYER_SIZE = 12;

    final JPanel rowContainer = new JPanel();
    final JPanel rightPanel = new JPanel();
    final JLabel profileName;
    final JLabel addProfile;
    final JLabel removeProfile;
    private final GearSwitchAlertPlugin plugin;
    private final GearSwitchAlertPanel panel;
    private final ItemManager itemManager;
    private final ClientThread clientThread;
    private JLabel deleteCustomProfile;

    JLabel collapseBtn;

    private final JPanel tagsContainer = new JPanel();
    private final String profileUUID;
    private final Cache<Long, Image> fillCache;

    static {
        final BufferedImage untickedIcon = ImageUtil.loadImageResource(GearSwitchAlertPlugin.class, "unticked_icon.png");
        UNTICKED_ICON = new ImageIcon(untickedIcon);
        UNTICKED_ICON_HOVER =  new ImageIcon(ImageUtil.alphaOffset(untickedIcon, 0.53f));
        final BufferedImage tickedIcon = ImageUtil.loadImageResource(GearSwitchAlertPlugin.class, "ticked_icon.png");
        TICKED_ICON = new ImageIcon(tickedIcon);
        TICKED_ICON_HOVER =  new ImageIcon(ImageUtil.alphaOffset(tickedIcon, 0.50f));
        final BufferedImage deleteIcon = ImageUtil.loadImageResource(GearSwitchAlertPlugin.class, "delete_icon.png");
        DELETE_ICON = new ImageIcon(deleteIcon);
        DELETE_ICON_HOVER =  new ImageIcon(ImageUtil.alphaOffset(deleteIcon, 0.50f));
        final BufferedImage collapsedIcon = ImageUtil.loadImageResource(GearSwitchAlertPlugin.class, "collapsed_icon.png");
        COLLAPSED_ICON = new ImageIcon(collapsedIcon);
        COLLAPSED_ICON_HOVER =  new ImageIcon(ImageUtil.alphaOffset(collapsedIcon, 0.50f));
        final BufferedImage expandedIcon = ImageUtil.loadImageResource(GearSwitchAlertPlugin.class, "expanded_icon.png");
        EXPANDED_ICON = new ImageIcon(expandedIcon);
        EXPANDED_ICON_HOVER =  new ImageIcon(ImageUtil.alphaOffset(expandedIcon, 0.50f));
        final BufferedImage plusIcon = ImageUtil.loadImageResource(GearSwitchAlertPlugin.class, "plus_icon.png");
        PLUS_ICON = new ImageIcon(plusIcon);
        PLUS_ICON_HOVER =  new ImageIcon(ImageUtil.alphaOffset(plusIcon, 0.50f));
    }

    ProfilePanel(ClientThread clientThread, GearSwitchAlertPlugin plugin, ItemManager itemManager, GearSwitchAlertPanel panel, String profileUUID, String profileName) {
        super();
        this.clientThread = clientThread;

        fillCache = CacheBuilder.newBuilder()
                .concurrencyLevel(1)
                .maximumSize(32)
                .build();

        this.plugin = plugin;
        this.panel = panel;
        this.itemManager = itemManager;
        this.profileUUID = profileUUID;

        this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

        String selectedProfile = plugin.loadSelectedProfile();
        boolean enabled = profileUUID.equals(selectedProfile);

        rowContainer.setLayout(new BorderLayout());
        rowContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        rowContainer.setPreferredSize(new Dimension(ROW_WIDTH, ROW_HEIGHT));
        rowContainer.setBorder(new EmptyBorder(8, 8, 6, 8));
        add(rowContainer);

        add(Box.createRigidArea(new Dimension(ROW_WIDTH, 1)));

        this.profileName = new JLabel(profileName);
        this.profileName.setFont(FontManager.getRunescapeFont());
        if(!profileUUID.equals("0"))
            this.profileName.setToolTipText(profileUUID);
        rowContainer.add(this.profileName, BorderLayout.WEST);

        rightPanel.applyComponentOrientation(ComponentOrientation.RIGHT_TO_LEFT);
        rightPanel.setLayout(new BoxLayout(rightPanel, BoxLayout.LINE_AXIS));
        rightPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        rightPanel.setPreferredSize(new Dimension(RIGHT_PANEL_WIDTH, ROW_HEIGHT));
        rowContainer.add(rightPanel, BorderLayout.EAST);

        addProfile = new JLabel();
        addProfile.setIcon(UNTICKED_ICON);

        removeProfile = new JLabel();
        removeProfile.setIcon(TICKED_ICON);

        collapseBtn = new JLabel();
        collapseBtn.setIcon(EXPANDED_ICON);

        if (enabled) {
            rightPanel.add(removeProfile, BorderLayout.EAST);
            rightPanel.add(Box.createHorizontalStrut(8));
            rightPanel.add(collapseBtn, BorderLayout.EAST);
        } else {
            rightPanel.add(addProfile, BorderLayout.EAST);
        }
        rightPanel.add(Box.createHorizontalStrut(8));

        if(!profileUUID.equals("0")) {
            deleteCustomProfile = new JLabel();
            deleteCustomProfile.setIcon(DELETE_ICON);
            deleteCustomProfile.addMouseListener(new MouseAdapter() {
                @Override
                public void mousePressed(MouseEvent e) {
                    if (SwingUtilities.isLeftMouseButton(e)) {
                        final int result = JOptionPane.showOptionDialog(rowContainer,
                                "Are you sure you want to delete profile: "+ profileName +"?",
                                "Delete Profile?", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE,
                                null, new String[]{"Yes", "No"}, "No");

                        if (result == JOptionPane.YES_OPTION)
                        {
                            plugin.deleteProfile(profileUUID);
                            plugin.loadProfiles();
                            panel.loadProfiles();
                            rightPanel.revalidate();
                            rightPanel.repaint();
                        }
                    }
                }

                @Override
                public void mouseEntered(MouseEvent e) {
                    deleteCustomProfile.setIcon(DELETE_ICON_HOVER);
                }

                @Override
                public void mouseExited(MouseEvent e) {
                    deleteCustomProfile.setIcon(DELETE_ICON);
                }
            });
            rightPanel.add(deleteCustomProfile, BorderLayout.WEST);
        }

        final JMenuItem duplicate = new JMenuItem("Duplicate Profile");
        duplicate.addActionListener(e ->
        {
            final String result = JOptionPane.showInputDialog(rowContainer,
                    "What's the name of the new profile?",
                    "Duplicate Profile?", JOptionPane.INFORMATION_MESSAGE);

            if (result != null && !Strings.isNullOrEmpty(result))
            {
                plugin.duplicateProfile(profileUUID, result);
            } else {
                JOptionPane.showMessageDialog(rowContainer, "Must add a profile name!", null, JOptionPane.ERROR_MESSAGE);
            }
        });

        final JMenuItem reset = new JMenuItem("Reset Profile");
        reset.addActionListener(e ->
        {
            final int result = JOptionPane.showOptionDialog(rowContainer,
                    "Are you sure you want to reset profile: "+ profileName +"?",
                    "Reset Profile?", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE,
                    null, new String[]{"Yes", "No"}, "No");

            if (result == JOptionPane.YES_OPTION) {
                plugin.removeAllTags(profileUUID);
            }
        });

        final JMenuItem export = new JMenuItem("Export Profile");
        export.addActionListener(e -> plugin.exportProfileToClipboard(profileUUID, rowContainer));

        // Create popup menu
        final JPopupMenu popupMenu = new JPopupMenu();
        popupMenu.setBorder(new EmptyBorder(5, 5, 5, 5));
        popupMenu.add(duplicate);
        popupMenu.add(reset);
        popupMenu.add(export);
        rowContainer.setComponentPopupMenu(popupMenu);

        if(enabled) {
            add(tagsContainer, BorderLayout.CENTER);

            clientThread.invokeLater(this::rebuild);
        }
    }

    private void buildItems(ArrayList<GearTagSettingsWithItemID> items)
    {
        // Calculates how many rows need to be display to fit all items
        int size = items.size();

        tagsContainer.removeAll();
        tagsContainer.setLayout(new GridLayout(0, ITEMS_PER_ROW, 1, 1));

        final EmptyBorder emptyBorder = new EmptyBorder(5, 5, 5, 5);
        for (int i = 0; i < size; i++)
        {
            final GearTagSettingsWithItemID item = items.get(i);
            GearTagSettings tag = item.origTag;

            final JPanel slotContainer = new JPanel();
            slotContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

            final JLayeredPane layeredPanel = new JLayeredPane();

            final JLabel imageLabel = new JLabel();
            Integer itemID = item.itemID;
            imageLabel.setToolTipText(item.name);
            imageLabel.setVerticalAlignment(SwingConstants.CENTER);
            imageLabel.setHorizontalAlignment(SwingConstants.CENTER);

            AsyncBufferedImage itemImage = itemManager.getImage(itemID, 1, false);
            int width = itemImage.getWidth();
            int height = itemImage.getHeight();
            itemImage.addTo(imageLabel);

            imageLabel.setBounds( 0, 0, width, height );
            layeredPanel.add(imageLabel);
            layeredPanel.setLayer(imageLabel, 0);

            final JLabel imageLabel2 = new JLabel();
            imageLabel2.setVerticalAlignment(SwingConstants.BOTTOM);
            imageLabel2.setHorizontalAlignment(SwingConstants.CENTER);

            AsyncBufferedImage prayerImg = new AsyncBufferedImage(clientThread, width, PRAYER_SIZE, TYPE_INT_ARGB);
            prayerImg = applyPrayerToImage(prayerImg, tag.isMeleeGear, tag.isRangeGear, tag.isMagicGear);
            prayerImg.addTo(imageLabel2);

            imageLabel2.setBounds( 0, height, width, PRAYER_SIZE );
            layeredPanel.add(imageLabel2);
            layeredPanel.setLayer(imageLabel2, 10);
            layeredPanel.setPreferredSize(new Dimension(width, height+PRAYER_SIZE));

            // Create popup menu
            final JPopupMenu popupMenu = new JPopupMenu();
            popupMenu.setBorder(emptyBorder);
            layeredPanel.setComponentPopupMenu(popupMenu);

            final JMenuItem meleeToggle = new JMenuItem(tag.isMeleeGear ? "Unset Melee Gear" : "Set Melee Gear");
            meleeToggle.addActionListener(e ->
                    plugin.toggleGearTag(item, true, false, false));

            final JMenuItem rangeToggle = new JMenuItem(tag.isRangeGear ? "Unset Range Gear" : "Set Range Gear");
            rangeToggle.addActionListener(e ->
                    plugin.toggleGearTag(item, false, true, false));

            final JMenuItem magicToggle = new JMenuItem(tag.isMagicGear ? "Unset Magic Gear" : "Set Magic Gear");
            magicToggle.addActionListener(e ->
                    plugin.toggleGearTag(item, false, false, true));

            final JMenuItem removeTag = new JMenuItem("Remove Tag");
            removeTag.addActionListener(e ->
                    plugin.removeTag(item.itemID, profileUUID));

            popupMenu.add(meleeToggle);
            popupMenu.add(rangeToggle);
            popupMenu.add(magicToggle);
            popupMenu.add(removeTag);

            String enabledTagsText;
            if(!tag.isMeleeGear && !tag.isRangeGear && !tag.isMagicGear) {
                enabledTagsText = "No Tags Set";
            } else {
                StringBuilder str = new StringBuilder();
                String delimiter = " - ";
                if(tag.isMeleeGear)
                    str.append("Melee").append(delimiter);
                if(tag.isRangeGear)
                    str.append("Ranged").append(delimiter);
                if(tag.isMagicGear)
                    str.append("Magic").append(delimiter);

                String list = str.toString();
                enabledTagsText = list.substring(
                        0, list.length() - delimiter.length());
            }
            imageLabel2.setToolTipText(enabledTagsText);

            slotContainer.add(layeredPanel);

            tagsContainer.add(slotContainer);
            slotContainer.revalidate();
        }

        final JPanel slotContainer = new JPanel();
        slotContainer.setLayout(new BorderLayout());
        slotContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JLabel addLbl = new JLabel();
        addLbl.setIcon(PLUS_ICON);
        addLbl.setVerticalAlignment(SwingConstants.CENTER);
        addLbl.setHorizontalAlignment(SwingConstants.CENTER);
        addLbl.setPreferredSize(new Dimension(36, 32));
        slotContainer.add(addLbl, BorderLayout.CENTER);

        JLabel addLblTxt = new JLabel();
        addLblTxt.setText("Add Item");
        addLblTxt.setFont(FontManager.getRunescapeSmallFont());
        addLblTxt.setHorizontalAlignment(SwingConstants.CENTER);
        addLblTxt.setPreferredSize(new Dimension(36, PRAYER_SIZE));
        slotContainer.add(addLblTxt, BorderLayout.SOUTH);

        slotContainer.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                if (SwingUtilities.isLeftMouseButton(e)) {
                    plugin.addTagBySearch(profileUUID);
                }
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                addLbl.setIcon(PLUS_ICON_HOVER);
                applyDimmer(false, slotContainer);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                addLbl.setIcon(PLUS_ICON);
                applyDimmer(true, slotContainer);
            }
        });

        tagsContainer.add(slotContainer);
        slotContainer.revalidate();

        tagsContainer.revalidate();
    }

    public AsyncBufferedImage applyPrayerToImage(AsyncBufferedImage img, boolean melee, boolean range, boolean magic) {
        Graphics g = img.getGraphics();
        int imgWidth = img.getWidth();

        BufferedImage meleeSprite = plugin.getSprite(Prayer.PROTECT_FROM_MELEE);
        BufferedImage rangeSprite = plugin.getSprite(Prayer.PROTECT_FROM_MISSILES);
        BufferedImage magicSprite = plugin.getSprite(Prayer.PROTECT_FROM_MAGIC);
        g.drawImage(melee ? getFillImage(panel.config.defaultColourMelee(), meleeSprite, 0) : getFillImage(ColorUtil.colorWithAlpha(Color.GRAY, 30), meleeSprite, 4), 0, 0, PRAYER_SIZE, PRAYER_SIZE, null);
        g.drawImage(range ? getFillImage(panel.config.defaultColourRanged(), rangeSprite, 1) : getFillImage(ColorUtil.colorWithAlpha(Color.GRAY, 30), rangeSprite, 5), (imgWidth/2) - (PRAYER_SIZE/2), 0, PRAYER_SIZE, PRAYER_SIZE, null);
        g.drawImage(magic ? getFillImage(panel.config.defaultColourMagic(), magicSprite, 2) : getFillImage(ColorUtil.colorWithAlpha(Color.GRAY, 30), magicSprite, 6), imgWidth - PRAYER_SIZE, 0, PRAYER_SIZE, PRAYER_SIZE, null);

        return img;
    }

    void rebuild() {
        ArrayList<GearTagSettingsWithItemID> items = this.plugin.getTagsForProfile(profileUUID);

        SwingUtilities.invokeLater(() ->{
            buildItems(items);
            revalidate();
        });
    }

    void toggle()
    {
        if(tagsContainer == null)
            return;

        boolean collapsed = isCollapsed();
        tagsContainer.setVisible(collapsed);

        if(collapsed) {
            collapseBtn.setIcon(EXPANDED_ICON);
        } else {
            collapseBtn.setIcon(COLLAPSED_ICON);
        }
    }

    boolean isCollapsed()
    {
        return !tagsContainer.isVisible();
    }

    void applyDimmer(boolean brighten, JPanel panel)
    {
        for (Component component : panel.getComponents())
        {
            Color color = component.getForeground();

            component.setForeground(brighten ? color.brighter() : color.darker());
        }
    }

    private Image getFillImage(Color fillColor, BufferedImage img, long key)
    {
        Image image = fillCache.getIfPresent(key);
        if (image == null)
        {
            image = ImageUtil.fillImage(img, fillColor);
            fillCache.put(key, image);
        }
        return image;
    }
}
package com.gearswitch;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class GearSwitchAlertPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(GearSwitchAlertPlugin.class);
		RuneLite.main(args);
	}
}

