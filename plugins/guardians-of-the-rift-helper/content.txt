package com.datbear;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class GuardiansOfTheRiftPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(GuardiansOfTheRiftHelperPlugin.class);
		RuneLite.main(args);
	}
}
package com.datbear;

public enum TimerOverlayLocation {
    Hidden,
    Info_Box,
    Game_Overlay,
    Both
}

package com.datbear;

import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;

import javax.inject.Inject;
import java.awt.*;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Optional;

public class GuardiansOfTheRiftHelperStartTimerOverlay extends Overlay {
    private Client client;
    private GuardiansOfTheRiftHelperPlugin plugin;
    private GuardiansOfTheRiftHelperConfig config;

    @Inject
    public GuardiansOfTheRiftHelperStartTimerOverlay(Client client, GuardiansOfTheRiftHelperPlugin plugin, GuardiansOfTheRiftHelperConfig config) {
        super(plugin);
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        setLayer(OverlayLayer.ABOVE_SCENE);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if ((!plugin.isInMainRegion() && !plugin.isInMinigame())) {
            return null;
        }

        if(config.startTimerOverlayLocation() != TimerOverlayLocation.Game_Overlay && config.startTimerOverlayLocation() != TimerOverlayLocation.Both){
            return null;
        }

        Optional<Instant> gameStart = plugin.getNextGameStart();

        if (gameStart.isPresent()) {
            int timeToStart = ((int) ChronoUnit.SECONDS.between(Instant.now(), gameStart.get()));

            if (timeToStart < 0) {
                return null;
            }

            String startString = String.format("%02d", timeToStart % 60) + " seconds to game start";

            var parentWidget = client.getWidget(plugin.getParentWidgetId());
            var portalWidget = client.getWidget(plugin.getPortalWidgetId());
            var x = parentWidget.getRelativeX() + 16;
            var y = parentWidget.getRelativeY() + portalWidget.getRelativeY() + 60;

            int width = 180;
            int height = 15;

            Rectangle rect = new Rectangle(x, y, width, height);
            plugin.drawCenteredString(graphics, startString, rect, Optional.empty());
        }

        return null;
    }
}

package com.datbear;

import net.runelite.api.*;
import net.runelite.api.Point;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;

import javax.inject.Inject;
import java.awt.*;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Set;

public class GuardiansOfTheRiftHelperOverlay extends Overlay {
    private static final Color GREEN = new Color(0,255,0, 150);
    private static final Color RED = new Color(255, 0, 0, 150);

    private static final int GUARDIAN_TICK_COUNT = 33;
    private static final int PORTAL_TICK_COUNT = 43;

    private static final int RUNE_IMAGE_OFFSET = 505;

    @Inject
    private ItemManager itemManager;

    @Inject
    private ModelOutlineRenderer modelOutlineRenderer;

    private Client client;
    private GuardiansOfTheRiftHelperPlugin plugin;
    private GuardiansOfTheRiftHelperConfig config;

    @Inject
    public GuardiansOfTheRiftHelperOverlay(Client client, GuardiansOfTheRiftHelperPlugin plugin, GuardiansOfTheRiftHelperConfig config) {
        super();
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
        this.client = client;
        this.plugin = plugin;
        this.config = config;
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if(plugin.isInMainRegion()){
            renderActiveGuardians(graphics);
            highlightGreatGuardian(graphics);
            highlightUnchargedCellTable(graphics);
            highlightDepositPool(graphics);
            highlightEssencePiles(graphics);
            renderPortal(graphics);
        }
        return null;
    }

    private void renderPortal(Graphics2D graphics){
        if(plugin.getPortalSpawnTime().isPresent() && plugin.getPortal() != null){
            var spawnTime = plugin.getPortalSpawnTime().get();
            var portal = plugin.getPortal();
            var millis = ChronoUnit.MILLIS.between(Instant.now(), spawnTime.plusMillis((long)Math.floor(PORTAL_TICK_COUNT * 600)));
            var timeRemainingText = ""+(Math.round(millis/100)/10d);
            var textLocation =  Perspective.getCanvasTextLocation(client, graphics, portal.getLocalLocation(), timeRemainingText, 100);
            OverlayUtil.renderTextLocation(graphics, textLocation, timeRemainingText, Color.WHITE);
        }
    }

    private void highlightEssencePiles(Graphics2D graphics){
        if(plugin.isShouldMakeGuardian()) {
            var elementalEss = plugin.getElementalEssencePile();
            var catalyticEss = plugin.getCatalyticEssencePile();
            if(elementalEss != null) {
                modelOutlineRenderer.drawOutline(elementalEss, 2, config.essencePileColor(), 2);
            }
            if(catalyticEss != null) {
                modelOutlineRenderer.drawOutline(catalyticEss, 2, config.essencePileColor(), 2);
            }
        }
    }

    private CellType bestCell(final Set<GameObject> activeGuardians) {
        var best = CellType.Weak;
        for (final GameObject guardian : activeGuardians) {
            if(guardian == null) continue;
            var hull = guardian.getConvexHull();
            if(hull == null) continue;
            var info = getGuardianInfo(guardian.getId());

            if (info.cellType.compareTo(best) > 0 && info.levelRequired < client.getBoostedSkillLevel(Skill.RUNECRAFT)) {
                if (info.cellType == CellType.Overcharged) {
                    return CellType.Overcharged;
                }
                best = info.cellType;
            }
        }
        return best;
    }

    private PointBalance currentBalance() {
        final var potElementalPoints = plugin.potentialPointsElemental();
        final var potCatalyticPoints = plugin.potentialPointsCatalytic();
        if (potElementalPoints > potCatalyticPoints) {
            return PointBalance.NEED_CATALYTIC;
        } else if (potCatalyticPoints > potElementalPoints) {
            return PointBalance.NEED_ELEMENTAL;
        }
        return PointBalance.BALANCED;
    }

    private void renderActiveGuardians(Graphics2D graphics){
        if(!plugin.isInMainRegion()) return;

        var activeGuardians = plugin.getActiveGuardians();
        var guardians = plugin.getGuardians();
        var inventoryTalismans = plugin.getInventoryTalismans();

        var balance = PointBalance.BALANCED;
        CellType bestCell = null;

        if (config.pointBalanceHelper()) {
            balance = currentBalance();
        }

        for(GameObject guardian : activeGuardians) {
            if(guardian == null) continue;
            var hull = guardian.getConvexHull();
            if(hull == null) continue;

            var info = getGuardianInfo(guardian.getId());

            if (config.pointBalanceHelper()) {
                if (!info.isCatalytic && balance == PointBalance.NEED_CATALYTIC) {
                    continue;
                } else if (info.isCatalytic && balance == PointBalance.NEED_ELEMENTAL) {
                    continue;
                } else if (balance == PointBalance.BALANCED) {
                    if (bestCell == null) {
                        bestCell = bestCell(activeGuardians);
                    }
                    if (info.cellType != bestCell) {
                        continue;
                    }
                }
            }

            var color = info.getColor(config,  client.getBoostedSkillLevel(Skill.RUNECRAFT));
            graphics.setColor(color);

            if (config.guardianOutline()) {
                modelOutlineRenderer.drawOutline(guardian, config.guardianBorderWidth(), color, config.guardianOutlineFeather());
            }

            var img = info.getRuneImage(itemManager);
            if(config.guardianShowRuneIcons()){
                OverlayUtil.renderImageLocation(client, graphics, guardian.getLocalLocation(), img, RUNE_IMAGE_OFFSET);
            }

            if(!info.spawnTime.isPresent()) continue;

            var imgLocation = Perspective.getCanvasImageLocation(client, guardian.getLocalLocation(), img, RUNE_IMAGE_OFFSET);
            var millis = ChronoUnit.MILLIS.between(Instant.now(), info.spawnTime.get().plusMillis((long)Math.floor(GUARDIAN_TICK_COUNT * 600)));
            var timeRemainingText = ""+(Math.round(millis/100)/10d);
            var strBounds = graphics.getFontMetrics().getStringBounds(timeRemainingText, graphics);
            var textLocation =  Perspective.getCanvasTextLocation(client, graphics, guardian.getLocalLocation(), timeRemainingText, RUNE_IMAGE_OFFSET+60);
            if (textLocation == null) continue;

            textLocation = new Point((int)(imgLocation.getX() + img.getWidth()/2d - strBounds.getWidth()/2d), textLocation.getY());
            OverlayUtil.renderTextLocation(graphics, textLocation, timeRemainingText, Color.WHITE);
        }

        for(int talisman : inventoryTalismans){
            var talismanGuardian = guardians.stream().filter(x -> getGuardianInfo(x.getId()).talismanId == talisman).findFirst();

            if(talismanGuardian.isPresent() && activeGuardians.stream().noneMatch(x -> x.getId() == talismanGuardian.get().getId())) {
                var talismanGuardianInfo = getGuardianInfo(talismanGuardian.get().getId());
                if (config.guardianOutline()) {
                    modelOutlineRenderer.drawOutline(talismanGuardian.get(), config.guardianBorderWidth(), talismanGuardianInfo.getColor(config, client.getBoostedSkillLevel(Skill.RUNECRAFT)), config.guardianOutlineFeather());
                }
                OverlayUtil.renderImageLocation(client, graphics, talismanGuardian.get().getLocalLocation(), talismanGuardianInfo.getTalismanImage(itemManager), RUNE_IMAGE_OFFSET);
            }
        }
    }

    private GuardianInfo getGuardianInfo(int gameObjectId){
        return GuardianInfo.ALL.stream().filter(x -> x.gameObjectId == gameObjectId).findFirst().get();
    }

    private void highlightGreatGuardian(Graphics2D graphics) {
        if(!config.outlineGreatGuardian()){
            return;
        }

        NPC greatGuardian = plugin.getGreatGuardian();
        if(plugin.isHasAnyStones() && greatGuardian != null){
            modelOutlineRenderer.drawOutline(greatGuardian, 2, Color.GREEN, 2);
        }
    }

    private void highlightUnchargedCellTable(Graphics2D graphics) {
        if(!config.outlineCellTable()){
            return;
        }

        GameObject table = plugin.getUnchargedCellTable();
        if(plugin.isOutlineUnchargedCellTable() && table != null){
            modelOutlineRenderer.drawOutline(table, 2, GREEN, 2);
        }
    }

    private void highlightDepositPool(Graphics2D graphics) {
        if(!config.outlineDepositPool()){
            return;
        }

        var depositPool = plugin.getDepositPool();
        if(plugin.isHasAnyRunes() && depositPool != null){
            modelOutlineRenderer.drawOutline(depositPool, 2, GREEN, 2);
        }
    }
}

package com.datbear;

import com.google.common.collect.ImmutableSet;
import net.runelite.api.ItemID;
import net.runelite.client.game.ItemManager;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.time.Instant;
import java.util.Optional;
import java.util.Set;
import java.util.function.Function;

public class GuardianInfo {
    public static final GuardianInfo AIR = new GuardianInfo("Air", 43701, 1, ItemID.AIR_RUNE, 26887, 4353, false, CellType.Weak, x -> x.notifyAirGuardian());
    public static final GuardianInfo MIND = new GuardianInfo("Mind", 43705, 2, ItemID.MIND_RUNE, 26891, 4354, true, CellType.Weak, x -> x.notifyMindGuardian());
    public static final GuardianInfo WATER = new GuardianInfo("Water", 43702, 5, ItemID.WATER_RUNE, 26888, 4355, false, CellType.Medium, x -> x.notifyWaterGuardian());
    public static final GuardianInfo EARTH = new GuardianInfo("Earth", 43703, 9, ItemID.EARTH_RUNE, 26889, 4356, false, CellType.Strong, x -> x.notifyEarthGuardian());
    public static final GuardianInfo FIRE = new GuardianInfo("Fire", 43704, 14, ItemID.FIRE_RUNE, 26890, 4357, false, CellType.Overcharged, x -> x.notifyFireGuardian());
    public static final GuardianInfo BODY = new GuardianInfo("Body", 43709, 20, ItemID.BODY_RUNE, 26895, 4358, true, CellType.Weak, x -> x.notifyBodyGuardian());
    public static final GuardianInfo COSMIC = new GuardianInfo("Cosmic", 43710, 27, ItemID.COSMIC_RUNE, 26896, 4359, true, CellType.Medium, x -> x.notifyCosmicGuardian());
    public static final GuardianInfo CHAOS = new GuardianInfo("Chaos", 43706, 35, ItemID.CHAOS_RUNE, 26892, 4360, true, CellType.Medium, x -> x.notifyChaosGuardian());
    public static final GuardianInfo NATURE = new GuardianInfo("Nature", 43711, 44, ItemID.NATURE_RUNE, 26897, 4361, true, CellType.Strong, x -> x.notifyNatureGuardian());
    public static final GuardianInfo LAW = new GuardianInfo("Law", 43712, 54, ItemID.LAW_RUNE, 26898, 4362, true, CellType.Strong, x -> x.notifyLawGuardian());
    public static final GuardianInfo DEATH = new GuardianInfo("Death", 43707, 65, ItemID.DEATH_RUNE, 26893, 4363, true, CellType.Overcharged, x -> x.notifyDeathGuardian());
    public static final GuardianInfo BLOOD = new GuardianInfo("Blood", 43708, 77, ItemID.BLOOD_RUNE, 26894, 4364, true, CellType.Overcharged, x -> x.notifyBloodGuardian());

    public static final Set<GuardianInfo> ALL = ImmutableSet.of(AIR, MIND, WATER, EARTH, FIRE, BODY, COSMIC, CHAOS, NATURE, LAW, DEATH, BLOOD);

    public String name;
    public int gameObjectId;
    public int levelRequired;
    public int runeId;
    public int talismanId;
    public int spriteId;
    public boolean isCatalytic;
    public CellType cellType;
    public Function<GuardiansOfTheRiftHelperConfig, Boolean> notifyFunc;

    public Optional<Instant> spawnTime = Optional.empty();

    public GuardianInfo(String name, int gameObjectId, int levelRequired, int runeId, int talismanId, int spriteId, boolean isCatalytic, CellType cellType, Function<GuardiansOfTheRiftHelperConfig, Boolean> notifyFunc) {
        this.name = name;
        this.gameObjectId = gameObjectId;
        this.levelRequired = levelRequired;
        this.runeId = runeId;
        this.talismanId = talismanId;
        this.spriteId = spriteId;
        this.isCatalytic = isCatalytic;
        this.cellType = cellType;
        this.notifyFunc = notifyFunc;
    }

    public BufferedImage getRuneImage(ItemManager itemManager) {
        return itemManager.getImage(runeId);
    }

    public BufferedImage getTalismanImage(ItemManager itemManager) {
        return itemManager.getImage(talismanId);
    }

    public void spawn() {
        spawnTime = Optional.of(Instant.now());
    }

    public void despawn() {
        spawnTime = Optional.empty();
    }

    public Color getColor(GuardiansOfTheRiftHelperConfig config, int level) {
        if (config.colorGuardiansWithInsufficientRunecraftingLevel() && levelRequired > level) {
            return config.colorGuardiansWithInsufficientRunecraftingLevelColor();
        } else if (config.colorGuardiansByTier()) {
            switch (cellType) {
                case Weak:
                    return config.weakGuardianColor();
                case Medium:
                    return config.mediumGuardianColor();
                case Strong:
                    return config.strongGuardianColor();
                case Overcharged:
                    return config.overchargedGuardianColor();
            }
        } else {
            return isCatalytic ? config.catalyticGuardianColor() : config.elementalGuardianColor();
        }

        return Color.WHITE;
    }
}
package com.datbear;

import net.runelite.api.Client;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.awt.*;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Optional;

public class GuardiansOfTheRiftHelperPortalOverlay extends Overlay {
    private Client client;
    private GuardiansOfTheRiftHelperPlugin plugin;
    private GuardiansOfTheRiftHelperConfig config;
    private SpriteManager spriteManager;

    @Inject
    public GuardiansOfTheRiftHelperPortalOverlay(Client client, GuardiansOfTheRiftHelperPlugin plugin, GuardiansOfTheRiftHelperConfig config, SpriteManager spriteManager) {
        super(plugin);
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        this.spriteManager = spriteManager;
        setLayer(OverlayLayer.ABOVE_SCENE);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!plugin.isInMainRegion() && !plugin.isInMinigame()) {
            return null;
        }

        if(plugin.getNextGameStart().isPresent()){
            return null;
        }

        if(config.inactivePortalOverlayLocation() != TimerOverlayLocation.Game_Overlay && config.inactivePortalOverlayLocation() != TimerOverlayLocation.Both){
            return null;
        }

        Optional<Instant> despawn = plugin.getLastPortalDespawnTime();
        if(!despawn.isPresent()) return null;

        var parentWidget = client.getWidget(plugin.getParentWidgetId());
        var portalWidget = client.getWidget(plugin.getPortalWidgetId());

        if (parentWidget == null || portalWidget == null) {
            return null;
        }

        if (parentWidget.isHidden() || !portalWidget.isHidden()) {
            return null;
        }

        var image = ImageUtil.grayscaleImage(spriteManager.getSprite(plugin.getPortalSpriteId(), 0));

        var x = (int)parentWidget.getRelativeX() + portalWidget.getRelativeX() + 16;
        var y = (int)parentWidget.getRelativeY() + portalWidget.getRelativeY() + 10;
        var width = 32;
        var height = 32;

        graphics.drawImage(image, x, y, width, height, null);

        // simulates the delay that the widget has for the initial text
        if (plugin.isFirstPortal())
        {
            var timeSincePortalMillis = despawn.isPresent() ? ((int)(ChronoUnit.MILLIS.between(despawn.get(), Instant.now()))) : 0;
            if (timeSincePortalMillis < 1200) {
                return null;
            }
        }

        var timeSincePortal = ((int)(ChronoUnit.SECONDS.between(despawn.get(), Instant.now())));
        var color = plugin.getTimeSincePortalColor(timeSincePortal);
        var mins = String.format("%01d", timeSincePortal / 60);
        var secs = String.format("%02d", timeSincePortal % 60);
        var text = mins + ":" + secs;

        var textHeight = 24;
        Rectangle rect = new Rectangle(x, y + height, width, textHeight);

        plugin.drawCenteredString(graphics, text, rect, Optional.of(color));

        return null;
    }
}

package com.datbear;

import net.runelite.api.Client;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;

import javax.inject.Inject;
import java.awt.*;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Optional;

import static net.runelite.api.MenuAction.RUNELITE_OVERLAY_CONFIG;
import static net.runelite.client.ui.overlay.OverlayManager.OPTION_CONFIGURE;

public class GuardiansOfTheRiftHelperPanel extends OverlayPanel {
    private Client client;
    private GuardiansOfTheRiftHelperPlugin plugin;
    private GuardiansOfTheRiftHelperConfig config;

    @Inject
    public GuardiansOfTheRiftHelperPanel(Client client, GuardiansOfTheRiftHelperPlugin plugin, GuardiansOfTheRiftHelperConfig config) {
        super(plugin);
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        setPosition(OverlayPosition.TOP_CENTER);
        getMenuEntries().add(new OverlayMenuEntry(RUNELITE_OVERLAY_CONFIG, OPTION_CONFIGURE, "Guardians of the Rift Helper Overlay"));
    }


    @Override
    public Dimension render(Graphics2D graphics) {
        if ((!plugin.isInMainRegion() && !plugin.isInMinigame()) || !config.showPointsOverlay()) {
            return null;
        }

        Optional<Instant> gameStart = plugin.getNextGameStart();
        if (gameStart.isPresent()) {
            if (config.startTimerOverlayLocation() == TimerOverlayLocation.Info_Box || config.startTimerOverlayLocation() == TimerOverlayLocation.Both) {
                int timeToStart = ((int) ChronoUnit.SECONDS.between(Instant.now(), gameStart.get()));
                if (timeToStart >= 0) {
                    panelComponent.getChildren().add(LineComponent.builder()
                            .left("Time to start:")
                            .right("" + timeToStart)
                            .build());
                }
            }
        } else {
            if (config.inactivePortalOverlayLocation() == TimerOverlayLocation.Info_Box || config.inactivePortalOverlayLocation() == TimerOverlayLocation.Both) {
                Optional<Instant> despawn = plugin.getLastPortalDespawnTime();
                var timeSincePortal = despawn.isPresent() ? ((int) (ChronoUnit.SECONDS.between(despawn.get(), Instant.now()))) : 0;
                if (timeSincePortal >= 0) {
                    panelComponent.getChildren().add(LineComponent.builder()
                            .left("Time since portal:")
                            .right("" + timeSincePortal)
                            .rightColor(plugin.getTimeSincePortalColor(timeSincePortal))
                            .build());
                }
            }
        }

        panelComponent.getChildren().add(LineComponent.builder()
                .left("Reward points:")
                .right(plugin.getElementalRewardPoints() + "/" + plugin.getCatalyticRewardPoints())
                .build());

        if (config.potentialPoints()) {
            final int potElementalPoints = plugin.potentialPointsElemental();
            final int potCatalyticPoints = plugin.potentialPointsCatalytic();
            final int elementalRemain = plugin.getCurrentElementalRewardPoints() % 100;
            final int catalyticRemain = plugin.getCurrentCatalyticRewardPoints() % 100;
            final String potPoints = String.format("%d.%02d/%d.%02d", potElementalPoints, elementalRemain, potCatalyticPoints, catalyticRemain);
            Color potColor = Color.WHITE;
            if (config.highlightPotential()) {
                potColor = potElementalPoints == potCatalyticPoints ? config.potentialBalanceColor() : config.potentialUnbalanceColor();
            }
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Potential:")
                    .rightColor(potColor)
                    .right(potPoints)
                    .build());
        }
        return super.render(graphics);
    }

}

package com.datbear;

import com.google.inject.Provides;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Menu;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.Widget;
import net.runelite.client.Notifier;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

import javax.inject.Inject;
import java.awt.*;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Slf4j
@PluginDescriptor(
        name = "Guardians of the Rift Helper",
        description = "Show info about the Guardians of the Rift minigame",
        tags = {"minigame", "overlay", "guardians of the rift", "gotr"}
)
public class GuardiansOfTheRiftHelperPlugin extends Plugin {
    @Inject
    private Client client;

    @Inject
    private GuardiansOfTheRiftHelperConfig config;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private GuardiansOfTheRiftHelperOverlay overlay;

    @Inject
    private GuardiansOfTheRiftHelperPanel panel;

    @Inject
    private GuardiansOfTheRiftHelperStartTimerOverlay startTimerOverlay;

    @Inject
    private GuardiansOfTheRiftHelperPortalOverlay portalOverlay;

    @Inject
    private Notifier notifier;

    private static final int MINIGAME_MAIN_REGION = 14484;

    private static final Set<Integer> GUARDIAN_IDS = GuardianInfo.ALL.stream().mapToInt(x -> x.gameObjectId).boxed().collect(Collectors.toSet());
    private static final Set<Integer> RUNE_IDS = GuardianInfo.ALL.stream().mapToInt(x -> x.runeId).boxed().collect(Collectors.toSet());
    private static final Set<Integer> TALISMAN_IDS = GuardianInfo.ALL.stream().mapToInt(x -> x.talismanId).boxed().collect(Collectors.toSet());
    private static final int GREAT_GUARDIAN_ID = 11403;

    private static final int CATALYTIC_GUARDIAN_STONE_ID = 26880;
    private static final int ELEMENTAL_GUARDIAN_STONE_ID = 26881;
    private static final int POLYELEMENTAL_GUARDIAN_STONE_ID = 26941;

    private static final int ELEMENTAL_ESSENCE_PILE_ID = 43722;
    private static final int CATALYTIC_ESSENCE_PILE_ID = 43723;

    private static final int UNCHARGED_CELL_ITEM_ID = 26882;
    private static final int UNCHARGED_CELL_GAMEOBJECT_ID = 43732;
    private static final int CHISEL_ID = 1755;
    private static final int OVERCHARGED_CELL_ID = 26886;

    private static final Set<Integer> CHARGED_CELL_ITEM_IDS = new HashSet<>() {{
        add(ItemID.WEAK_CELL);
        add(ItemID.MEDIUM_CELL);
        add(ItemID.STRONG_CELL);
        add(ItemID.OVERCHARGED_CELL);
    }};

    private static final int DEPOSIT_POOL_ID = 43696;

    private static final int GUARDIAN_ACTIVE_ANIM = 9363;

    private static final int PARENT_WIDGET_ID = 48889858;
    private static final int CATALYTIC_RUNE_WIDGET_ID = 48889876;
    private static final int ELEMENTAL_RUNE_WIDGET_ID = 48889879;
    private static final int GUARDIAN_COUNT_WIDGET_ID = 48889886;
    private static final int PORTAL_WIDGET_ID = 48889882;
    private static final int PORTAL_TEXT_WIDGET_ID = 48889884;

    private final static int PORTAL_SPRITE_ID = 4368;

    private static final int PORTAL_ID = 43729;

    private static final String REWARD_POINT_REGEX = "Total elemental energy:[^>]+>([\\d,]+).*Total catalytic energy:[^>]+>([\\d,]+).";
    private static final Pattern REWARD_POINT_PATTERN = Pattern.compile(REWARD_POINT_REGEX);
    private static final String CHECK_POINT_REGEX = "You have (\\d+) catalytic energy and (\\d+) elemental energy";
    private static final Pattern CHECK_POINT_PATTERN = Pattern.compile(CHECK_POINT_REGEX);

    private static final int DIALOG_WIDGET_GROUP = 229;
    private static final int DIALOG_WIDGET_MESSAGE = 1;
    private static final String BARRIER_DIALOG_FINISHING_UP = "It looks like the adventurers within are just finishing up. You must<br>wait until they are done to join.";

    @Getter(AccessLevel.PACKAGE)
    private final Set<GameObject> guardians = new HashSet<>();
    @Getter(AccessLevel.PACKAGE)
    private final Set<GameObject> activeGuardians = new HashSet<>();
    @Getter(AccessLevel.PACKAGE)
    private final Set<Integer> inventoryTalismans = new HashSet<>();
    @Getter(AccessLevel.PACKAGE)
    private NPC greatGuardian;
    @Getter(AccessLevel.PACKAGE)
    private GameObject unchargedCellTable;
    @Getter(AccessLevel.PACKAGE)
    private GameObject depositPool;
    @Getter(AccessLevel.PACKAGE)
    private GameObject catalyticEssencePile;
    @Getter(AccessLevel.PACKAGE)
    private GameObject elementalEssencePile;
    @Getter(AccessLevel.PACKAGE)
    private GameObject portal;

    @Getter(AccessLevel.PACKAGE)
    private boolean isInMinigame;
    @Getter(AccessLevel.PACKAGE)
    private boolean isInMainRegion;
    @Getter(AccessLevel.PACKAGE)
    private boolean hasAnyStones = false;
    @Getter(AccessLevel.PACKAGE)
    private boolean outlineUnchargedCellTable = false;
    @Getter(AccessLevel.PACKAGE)
    private boolean hasAnyRunes = false;
    @Getter(AccessLevel.PACKAGE)
    private boolean hasAnyChargedCells = false;
    @Getter(AccessLevel.PACKAGE)
    private boolean hasAnyGuardianEssence = false;
    @Getter(AccessLevel.PACKAGE)
    private boolean hasFullInventory = false;
    @Getter(AccessLevel.PACKAGE)
    private boolean shouldMakeGuardian = false;
    @Getter(AccessLevel.PACKAGE)
    private boolean isFirstPortal = false;

    @Getter(AccessLevel.PACKAGE)
    private int elementalRewardPoints;
    @Getter(AccessLevel.PACKAGE)
    private int catalyticRewardPoints;
    @Getter(AccessLevel.PACKAGE)
    private int currentElementalRewardPoints;
    @Getter(AccessLevel.PACKAGE)
    private int currentCatalyticRewardPoints;

    @Getter(AccessLevel.PACKAGE)
    private Optional<Instant> portalSpawnTime = Optional.empty();
    @Getter(AccessLevel.PACKAGE)
    private Optional<Instant> lastPortalDespawnTime = Optional.empty();
    @Getter(AccessLevel.PACKAGE)
    private Optional<Instant> nextGameStart = Optional.empty();
    private Optional<Instant> gameStarted = Optional.empty();

    @Getter(AccessLevel.PACKAGE)
    private int lastRewardUsage;

    private boolean hasNotifiedGameStart = true;
    private boolean hasNotifiedFirstRift = true;
    private int previousGuardianFragments = 0;


    private String portalLocation;
    private int lastElementalRuneSprite;
    private int lastCatalyticRuneSprite;
    private boolean areGuardiansNeeded = false;
    private int entryBarrierClickCooldown = 0;

    private final Map<String, String> expandCardinal = new HashMap<>() {
        {
            put("S", "south");
            put("SW", "south west");
            put("W", "west");
            put("NW", "north west");
            put("N", "north");
            put("NE", "north east");
            put("E", "east");
            put("SE", "south east");
        }
    };

    private boolean checkInMinigame() {
        GameState gameState = client.getGameState();
        if (gameState != GameState.LOGGED_IN && gameState != GameState.LOADING) {
            return false;
        }

        Widget elementalRuneWidget = client.getWidget(PARENT_WIDGET_ID);
        return elementalRuneWidget != null;
    }

    private boolean checkInMainRegion() {
        int[] currentMapRegions = client.getMapRegions();
        return Arrays.stream(currentMapRegions).anyMatch(x -> x == MINIGAME_MAIN_REGION);
    }

    @Override
    protected void startUp() {
        overlayManager.add(overlay);
        overlayManager.add(panel);
        overlayManager.add(startTimerOverlay);
        overlayManager.add(portalOverlay);
        isInMinigame = true;

    }

    @Override
    protected void shutDown() {
        overlayManager.remove(overlay);
        overlayManager.remove(panel);
        overlayManager.remove(startTimerOverlay);
        overlayManager.remove(portalOverlay);
        reset();
    }

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event) {
        if ((!isInMainRegion && !isInMinigame) || event.getItemContainer() != client.getItemContainer(InventoryID.INVENTORY)) {
            return;
        }

        Item[] items = event.getItemContainer().getItems();
        hasAnyStones = Arrays.stream(items).anyMatch(x -> x.getId() == ELEMENTAL_GUARDIAN_STONE_ID || x.getId() == CATALYTIC_GUARDIAN_STONE_ID || x.getId() == POLYELEMENTAL_GUARDIAN_STONE_ID);
        outlineUnchargedCellTable = Arrays.stream(items).noneMatch(x -> x.getId() == UNCHARGED_CELL_ITEM_ID);
        shouldMakeGuardian = Arrays.stream(items).anyMatch(x -> x.getId() == CHISEL_ID) && Arrays.stream(items).anyMatch(x -> x.getId() == OVERCHARGED_CELL_ID) && areGuardiansNeeded;
        hasAnyRunes = Arrays.stream(items).anyMatch(x -> RUNE_IDS.contains(x.getId()));
        hasAnyChargedCells = Arrays.stream(items).anyMatch(x -> CHARGED_CELL_ITEM_IDS.contains(x.getId()));
        hasAnyGuardianEssence = Arrays.stream(items).anyMatch(x -> x.getId() == ItemID.GUARDIAN_ESSENCE);
        hasFullInventory = Arrays.stream(items).allMatch(x -> x.getId() != -1);

        List<Integer> invTalismans = Arrays.stream(items).mapToInt(x -> x.getId()).filter(x -> TALISMAN_IDS.contains(x)).boxed().collect(Collectors.toList());
        if (invTalismans.stream().count() != inventoryTalismans.stream().count()) {
            inventoryTalismans.clear();
            inventoryTalismans.addAll(invTalismans);
        }

        if (config.notifyGuardianFragments() && config.guardianFragmentsAmount() > 0) {
            var optNewFragments = Arrays.stream(items).filter(x -> x.getId() == ItemID.GUARDIAN_FRAGMENTS).findFirst();
            if (optNewFragments.isPresent()) {
                var quantity = optNewFragments.get().getQuantity();
                if (quantity >= config.guardianFragmentsAmount() && previousGuardianFragments < config.guardianFragmentsAmount()) {
                    notifier.notify("You have mined " + config.guardianFragmentsAmount() + "+ guardian fragments.");
                }
                previousGuardianFragments = quantity;
            }
        }
    }

    @Subscribe
    public void onGameTick(GameTick tick) {
        isInMinigame = checkInMinigame();
        isInMainRegion = checkInMainRegion();
        NotifyBeforeGameStart();
        NotifyBeforeFirstAltar();
        if (entryBarrierClickCooldown > 0) {
            entryBarrierClickCooldown--;
        }

        activeGuardians.removeIf(ag -> {
            Animation anim = ((DynamicObject) ag.getRenderable()).getAnimation();
            return anim == null || anim.getId() != GUARDIAN_ACTIVE_ANIM;
        });

        for (GameObject guardian : guardians) {
            Animation animation = ((DynamicObject) guardian.getRenderable()).getAnimation();
            if (animation != null && animation.getId() == GUARDIAN_ACTIVE_ANIM) {
                activeGuardians.add(guardian);
            }
        }

        Widget elementalRuneWidget = client.getWidget(ELEMENTAL_RUNE_WIDGET_ID);
        Widget catalyticRuneWidget = client.getWidget(CATALYTIC_RUNE_WIDGET_ID);
        Widget guardianCountWidget = client.getWidget(GUARDIAN_COUNT_WIDGET_ID);
        Widget portalTextWidget = client.getWidget(PORTAL_TEXT_WIDGET_ID);

        lastElementalRuneSprite = parseRuneWidget(elementalRuneWidget, lastElementalRuneSprite);
        lastCatalyticRuneSprite = parseRuneWidget(catalyticRuneWidget, lastCatalyticRuneSprite);

        if (guardianCountWidget != null) {
            String text = guardianCountWidget.getText();
            areGuardiansNeeded = text != null && !text.contains("10/10");
        }

        if (portalTextWidget != null && !portalTextWidget.isHidden()) {
            if (!portalSpawnTime.isPresent()) {
                lastPortalDespawnTime = Optional.empty();
                if (isFirstPortal) {
                    isFirstPortal = false;
                }
                if (config.notifyPortalSpawn()) {
                    String compass = portalTextWidget.getText().split(" ")[0];
                    String full = expandCardinal.getOrDefault(compass, "unknown");
                    notifier.notify("A portal has spawned in the " + full + ".");
                }
            }
            portalLocation = portalTextWidget.getText();
            portalSpawnTime = portalSpawnTime.isPresent() ? portalSpawnTime : Optional.of(Instant.now());
        } else if (elementalRuneWidget != null && !elementalRuneWidget.isHidden()) {
            if (portalSpawnTime.isPresent()) {
                lastPortalDespawnTime = Optional.of(Instant.now());
            }
            portalLocation = null;
            portalSpawnTime = Optional.empty();
        }

        Widget dialog = client.getWidget(DIALOG_WIDGET_GROUP, DIALOG_WIDGET_MESSAGE);
        if (dialog != null) {
            String dialogText = dialog.getText();
            if (dialogText.equals(BARRIER_DIALOG_FINISHING_UP)) {
                // Allow one click per tick while the portal is closed
                entryBarrierClickCooldown = 0;
            } else {
                final Matcher checkMatcher = CHECK_POINT_PATTERN.matcher(dialogText);
                if (checkMatcher.find(0)) {
                    //For some reason these are reversed compared to everything else
                    catalyticRewardPoints = Integer.parseInt(checkMatcher.group(1));
                    elementalRewardPoints = Integer.parseInt(checkMatcher.group(2));
                }
            }
        }
    }

    int parseRuneWidget(Widget runeWidget, int lastSpriteId) {
        if (runeWidget != null) {
            int spriteId = runeWidget.getSpriteId();
            if (spriteId != lastSpriteId) {
                if (lastSpriteId > 0) {
                    Optional<GuardianInfo> lastGuardian = GuardianInfo.ALL.stream().filter(g -> g.spriteId == lastSpriteId).findFirst();
                    if (lastGuardian.isPresent()) {
                        lastGuardian.get().despawn();
                    }
                }

                Optional<GuardianInfo> optionalGuardian = GuardianInfo.ALL.stream().filter(g -> g.spriteId == spriteId).findFirst();
                if (optionalGuardian.isPresent()) {
                    var currentGuardian = optionalGuardian.get();
                    currentGuardian.spawn();
                    if (currentGuardian.notifyFunc.apply(config)) {
                        var condition = config.notifyGuardianCondition();
                        if(condition == NotifyGuardianCondition.Always || (condition == NotifyGuardianCondition.Have_Guardian_Essence && hasAnyGuardianEssence) || (condition == NotifyGuardianCondition.Full_Inventory && hasFullInventory)){
                            notifier.notify("A portal to the " + currentGuardian.name + " altar has opened.");
                        }
                    }
                }
            }

            return spriteId;
        }
        return lastSpriteId;
    }

    @Subscribe
    public void onGameObjectSpawned(GameObjectSpawned event) {
        GameObject gameObject = event.getGameObject();
        if (GUARDIAN_IDS.contains(event.getGameObject().getId())) {
            guardians.removeIf(g -> g.getId() == gameObject.getId());
            activeGuardians.removeIf(g -> g.getId() == gameObject.getId());
            guardians.add(gameObject);
        }

        if (gameObject.getId() == UNCHARGED_CELL_GAMEOBJECT_ID) {
            unchargedCellTable = gameObject;
        }

        if (gameObject.getId() == DEPOSIT_POOL_ID) {
            depositPool = gameObject;
        }

        if (gameObject.getId() == ELEMENTAL_ESSENCE_PILE_ID) {
            elementalEssencePile = gameObject;
        }

        if (gameObject.getId() == CATALYTIC_ESSENCE_PILE_ID) {
            catalyticEssencePile = gameObject;
        }

        if (gameObject.getId() == PORTAL_ID) {
            portal = gameObject;
            if (config.notifyPortalSpawn()) {
                // The hint arrow is cleared under the following circumstances:
                // 1. Player enters the portal
                // 2. Plugin is "reset()"
                // 3. The portal despawns
                client.setHintArrow(portal.getWorldLocation());
            }
        }
    }

    @Subscribe
    public void onGameObjectDespawned(GameObjectDespawned event) {
        if (event.getGameObject().getId() == PORTAL_ID) {
            client.clearHintArrow();
        }
    }

    @Subscribe
    public void onNpcSpawned(NpcSpawned npcSpawned) {
        NPC npc = npcSpawned.getNpc();
        if (npc.getId() == GREAT_GUARDIAN_ID) {
            greatGuardian = npc;
        }
    }


    @Subscribe
    public void onGameStateChanged(GameStateChanged event) {
        if (event.getGameState() == GameState.LOADING) {
            // on region changes the tiles get set to null
            reset();
        } else if (event.getGameState() == GameState.LOGIN_SCREEN) {
            isInMinigame = false;
        }
    }

    @Subscribe
    public void onVarbitChanged(VarbitChanged event) {
        if (!isInMainRegion && !isInMinigame) return;
        currentElementalRewardPoints = Math.max(0, client.getVarbitValue(13686));
        currentCatalyticRewardPoints = Math.max(0, client.getVarbitValue(13685));
    }

    @Subscribe
    public void onChatMessage(ChatMessage chatMessage) {
        if ((!isInMainRegion && !isInMinigame)) return;
        if (chatMessage.getType() != ChatMessageType.SPAM && chatMessage.getType() != ChatMessageType.GAMEMESSAGE)
            return;

        String msg = chatMessage.getMessage();
        if (msg.contains("You step through the portal")) {
            client.clearHintArrow();
        }
        if (msg.contains("The rift becomes active!")) {
            lastPortalDespawnTime = Optional.of(Instant.now());
            nextGameStart = Optional.empty();
            gameStarted = Optional.of(Instant.now());
            isFirstPortal = true;
            hasNotifiedFirstRift = false;
        } else if (msg.contains("The rift will become active in 30 seconds.")) {
            hasNotifiedGameStart = config.beforeGameStartSeconds() > 30;
            nextGameStart = Optional.of(Instant.now().plusSeconds(30));
        } else if (msg.contains("The rift will become active in 10 seconds.")) {
            nextGameStart = Optional.of(Instant.now().plusSeconds(10));
            hasNotifiedGameStart = config.beforeGameStartSeconds() > 10;
        } else if (msg.contains("The rift will become active in 5 seconds.")) {
            nextGameStart = Optional.of(Instant.now().plusSeconds(5));
            hasNotifiedGameStart = config.beforeGameStartSeconds() > 5;
        } else if (msg.contains("The Portal Guardians will keep their rifts open for another 30 seconds.")) {
            hasNotifiedGameStart = false;
            nextGameStart = Optional.of(Instant.now().plusSeconds(60));
        } else if (msg.contains("You found some loot:")) {
            elementalRewardPoints = Math.max(0, elementalRewardPoints - 1);
            catalyticRewardPoints = Math.max(0, catalyticRewardPoints - 1);
        }

        Matcher rewardPointMatcher = REWARD_POINT_PATTERN.matcher(msg);
        if (rewardPointMatcher.find()) {
            // Use replaceAll to remove thousands separators from the text
            elementalRewardPoints = Integer.parseInt(rewardPointMatcher.group(1).replaceAll(",", ""));
            catalyticRewardPoints = Integer.parseInt(rewardPointMatcher.group(2).replaceAll(",", ""));
        }
        //log.info(msg);
    }

    @Provides
    GuardiansOfTheRiftHelperConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(GuardiansOfTheRiftHelperConfig.class);
    }

    @Subscribe
    public void onMenuOptionClicked(MenuOptionClicked event) {
        if (!config.quickPassCooldown()) return;

        // Only allow one click on the entry barrier's quick-pass option for every 3 game ticks
        if (event.getId() == 43700 && event.getMenuAction().getId() == 5) {
            if (entryBarrierClickCooldown > 0) {
                event.consume();
            } else {
                entryBarrierClickCooldown = 3;
            }
        }
    }

    @Subscribe
    public void onOverheadTextChanged(OverheadTextChanged event) {
        if (!("Apprentice Tamara".equals(event.getActor().getName()) || "Apprentice Cordelia".equals(event.getActor().getName()))) {
            return;
        }
        if (config.muteApprentices()) {
            event.getActor().setOverheadText(" ");
        }
    }

    @Subscribe(priority = -1)
    public void onPostMenuSort(PostMenuSort e) {
        if (!isInMinigame && !isInMainRegion) {
            return;
        }

        var menu = client.getMenu();
        SwapMenu(menu);

    }


    private void SwapMenu(Menu menu) {
        var entries = menu.getMenuEntries();
        if (config.hideGreatGuardianPowerUp() && !hasAnyStones) {
            entries = Arrays.stream(entries).filter(x -> !x.getOption().contains("Power-up") || !x.getTarget().contains("Great Guardian")).toArray(MenuEntry[]::new);
        }
        if (config.hideCellTilePlaceCell() && !hasAnyChargedCells) {
            entries = Arrays.stream(entries).filter(x -> !x.getOption().contains("Place-cell")).toArray(MenuEntry[]::new);
        }

        menu.setMenuEntries(entries);
    }

    private void reset() {
        guardians.clear();
        activeGuardians.clear();
        unchargedCellTable = null;
        depositPool = null;
        greatGuardian = null;
        catalyticEssencePile = null;
        elementalEssencePile = null;
        if (isInMinigame || isInMainRegion) {
            client.clearHintArrow();
        }
    }

    private void NotifyBeforeGameStart() {
        if (hasNotifiedGameStart || !nextGameStart.isPresent() || !config.notifyBeforeGameStart()) return;

        var start = nextGameStart.get();
        var secondsToStart = ChronoUnit.SECONDS.between(Instant.now(), start) - .5d;
        if (secondsToStart < config.beforeGameStartSeconds()) {
            if (config.beforeGameStartSeconds() > 0) {
                notifier.notify("The next game is starting in " + config.beforeGameStartSeconds() + " seconds!");
            } else {
                notifier.notify("The next game is starting now!");
            }
            hasNotifiedGameStart = true;
        }
    }

    private void NotifyBeforeFirstAltar() {
        if (hasNotifiedFirstRift || !gameStarted.isPresent() || !config.notifyBeforeFirstAltar()) return;

        var start = gameStarted.get();
        var secondsToRift = ChronoUnit.SECONDS.between(Instant.now(), start.plusSeconds(120)) - .5d;

        if (secondsToRift < config.beforeFirstAltarSeconds()) {
            if (config.beforeFirstAltarSeconds() > 0) {
                notifier.notify("The first altar is in " + config.beforeFirstAltarSeconds() + " seconds!");
            } else {
                notifier.notify("The first altar is opening now!");
            }
            hasNotifiedFirstRift = true;
        }
    }

    public Color getTimeSincePortalColor(int timeSincePortal) {
        if (isFirstPortal) {
            // first portal takes about 40 more seconds to spawn
            timeSincePortal -= 40;
        }
        if (timeSincePortal >= 108) {
            return Color.RED;
        } else if (timeSincePortal >= 85) {
            return Color.YELLOW;
        }
        return Color.GREEN;
    }

    public int getParentWidgetId() {
        return PARENT_WIDGET_ID;
    }

    public int getPortalWidgetId() {
        return PORTAL_WIDGET_ID;
    }

    public int getPortalSpriteId() {
        return PORTAL_SPRITE_ID;
    }

    public void drawCenteredString(Graphics g, String text, Rectangle rect, Optional<Color> textColor) {
        FontMetrics metrics = g.getFontMetrics();
        int x = rect.x + (rect.width - metrics.stringWidth(text)) / 2;
        int y = rect.y + ((rect.height - metrics.getHeight()) / 2) + metrics.getAscent();
        g.setColor(Color.BLACK);
        g.drawString(text, x + 1, y + 1);
        g.setColor(textColor.isPresent() ? textColor.get() : Color.WHITE);
        g.drawString(text, x, y);
    }

    public int potentialPointsElemental() {
        return potentialPoints(getElementalRewardPoints(), getCurrentElementalRewardPoints());
    }

    public int potentialPointsCatalytic() {
        return potentialPoints(getCatalyticRewardPoints(), getCurrentCatalyticRewardPoints());
    }

    private int potentialPoints(int savedPoints, int currentPoints) {
        if (currentPoints == 0) {
            return savedPoints;
        }
        return savedPoints += currentPoints / 100;
    }
}

package com.datbear;

public enum PointBalance {
    BALANCED,
    NEED_ELEMENTAL,
    NEED_CATALYTIC
}

package com.datbear;

import net.runelite.client.config.*;

import java.awt.*;

@ConfigGroup("guardiansOfTheRiftHelper")
public interface GuardiansOfTheRiftHelperConfig extends Config {
    @ConfigSection(
            name = "General Notifications",
            closedByDefault = false,
            position = 0,
            description = "Choose when you are notified."
    )
    String generalNotifications = "generalNotifications";

    @ConfigSection(
            name = "Menu Swaps",
            description = "All options relating to menu entry swaps",
            position = 1,
            closedByDefault = false
    )
    String menuSwaps = "menuSwaps";

    @ConfigSection(
            name = "Outlines",
            description = "All options relating to colored outlines",
            position = 2,
            closedByDefault = true
    )
    String outlines = "outlines";

    @ConfigSection(
            name = "Overlays",
            description = "All options relating to overlays",
            position = 3,
            closedByDefault = true

    )
    String overlays = "overlays";

    @ConfigSection(
            name = "Guardian Render Style",
            closedByDefault = true,
            position = 4,
            description = "Highlighting style"
    )
    String style = "style";

    @ConfigSection(
            name = "Guardian Active Notifications",
            closedByDefault = true,
            position = 5,
            description = "Choose when you are notified about guardians becoming active."
    )
    String guardianNotifications = "guardianNotifications";


    @ConfigItem(
            keyName = "quickPassCooldown",
            name = "Add cooldown to Quick-Pass",
            description = "Adds a 3 tick delay to the Quick-Pass menu option so you don't enter/leave by spam clicking the gate with Menu Entry Swapper's quick-pass option enabled."
    )
    default boolean quickPassCooldown() {
        return true;
    }

    @ConfigItem(
            keyName = "muteApprentices",
            name = "Mute game help messages",
            description = "Mutes the over head messages of the apprentices giving game advice."
    )
    default boolean muteApprentices() {
        return true;
    }





    @ConfigItem(
            keyName = "portalSpawn",
            name = "Notify on portal spawn",
            description = "Notifies you when a portal spawns.",
            position = 0,
            section = generalNotifications
    )
    default boolean notifyPortalSpawn() {
        return true;
    }

    @ConfigItem(
            keyName = "notifyBeforeGame",
            name = "Notify before game start",
            description = "Notifies you the specified number of seconds before the next game starts.",
            position = 1,
            section = generalNotifications
    )
    default boolean notifyBeforeGameStart() {
        return false;
    }

    @ConfigItem(
            keyName = "beforeGameSeconds",
            name = "Before game seconds",
            description = "Notifies you this many seconds before the next game starts.",
            position = 2,
            section = generalNotifications
    )
    @Range(min = 0, max = 59)
    default int beforeGameStartSeconds() {
        return 0;
    }

    @ConfigItem(
            keyName = "notifyBeforeFirstAltar",
            name = "Notify before first altar",
            description = "Notifies you the specified number of seconds before the game's first altar opens.",
            position = 3,
            section = generalNotifications
    )
    @Range(min = 0, max = 119)
    default boolean notifyBeforeFirstAltar() {
        return false;
    }

    @ConfigItem(
            keyName = "beforeFirstAltarSeconds",
            name = "First altar seconds",
            description = "Notifies you this many seconds before the game's first altar opens.",
            position = 4,
            section = generalNotifications
    )
    @Range(min = 0, max = 59)
    default int beforeFirstAltarSeconds() {
        return 0;
    }


    @ConfigItem(
            keyName = "notifyGuardianFragments",
            name = "Notify on Guardian Fragments",
            description = "Notifies you after you mine the specified amount of guardian fragments.",
            position = 4,
            section = generalNotifications
    )
    default boolean notifyGuardianFragments() {
        return true;
    }

    @ConfigItem(
            keyName = "guardianFragmentsAmount",
            name = "Guardian Fragments",
            description = "Notifies you when you hit the specified amount of guardian fragments in your inventory.",
            position = 5,
            section = generalNotifications
    )
    default int guardianFragmentsAmount() {
        return 0;
    }






    @ConfigItem(
            keyName = "hideGreatGuardianPowerUp",
            name = "Hide Power-Up",
            description = "Hides the left click Power-Up option on the Great Guardian when you can't power him up (no stones).",
            position = 1,
            section = menuSwaps
    )
    default boolean hideGreatGuardianPowerUp() {
        return false;
    }

    @ConfigItem(
            keyName = "hidePlaceCell",
            name = "Hide Place-cell",
            description = "Hides the left click Place-cell option on the cell tiles when you can't place a cell (no charged cells).",
            position = 2,
            section = menuSwaps
    )
    default boolean hideCellTilePlaceCell() {
        return false;
    }


    @ConfigItem(
            keyName = "guardianOutline",
            name = "Highlight outline",
            description = "Configures whether or not Guardian NPCs should be highlighted by outline.",
            section = style,
            position = 0
    )
    default boolean guardianOutline() {
        return true;
    }

    @ConfigItem(
            keyName = "guardianBorderWidth",
            name = "Border Width",
            description = "Width of the highlighted NPC border.",
            section = style,
            position = 1
    )
    default int guardianBorderWidth() {
        return 2;
    }

    @ConfigItem(

            keyName = "guardianOutlineFeather",
            name = "Outline feather",
            description = "Specify between 0-4 how much of the outline should be faded.",
            section = style,
            position = 2
    )
    @Range(min = 0, max = 4)
    default int guardianOutlineFeather() {
        return 0;
    }

    @ConfigItem(

            keyName = "guardianShowRuneIcons",
            name = "Show Rune Icons",
            description = "Toggles whether or not to show rune icons above guardians.",
            section = style,
            position = 3
    )
    default boolean guardianShowRuneIcons() {
        return true;
    }


    @ConfigItem(
            keyName = "outlineCellTable",
            name = "Outline cell table",
            description = "Outlines the Cell table when you have no cells remaining.",
            section = outlines,
            position = 1
    )
    default boolean outlineCellTable() {
        return true;
    }

    @ConfigItem(
            keyName = "outlineDepositPool",
            name = "Outline deposit pool",
            description = "Outlines the Deposit Pool when you have runes in your inventory.",
            section = outlines,
            position = 2
    )
    default boolean outlineDepositPool() {
        return true;
    }

    @ConfigItem(
            keyName = "outlineGreatGuardian",
            name = "Outline Great Guardian",
            description = "Outlines the Great Guardian when you have elemental or catalytic essence in your inventory.",
            section = outlines,
            position = 2
    )
    default boolean outlineGreatGuardian() {
        return true;
    }

    @Alpha
    @ConfigItem(
            keyName = "elementalGuardianColor",
            name = "Elemental outline",
            description = "Color of the outline on the active elemental guardian.",
            section = outlines,
            position = 3
    )
    default Color elementalGuardianColor() {
        return Color.GREEN;
    }

    @Alpha
    @ConfigItem(
            keyName = "catalyticGuardianColor",
            name = "Catalytic outline",
            description = "Color of the outline on the active catalytic guardian.",
            section = outlines,
            position = 4
    )
    default Color catalyticGuardianColor() {
        return Color.RED;
    }


    @ConfigItem(
            keyName = "outlineGuardiansByTier",
            name = "Color guardians by cell tier",
            description = "Outlines active portal guardians with colors based on their Cell charge tiers instead of Elemental vs Catalytic.",
            position = 5,
            section = outlines
    )
    default boolean colorGuardiansByTier() {
        return false;
    }

    @Alpha
    @ConfigItem(
            keyName = "weakGuardianColor",
            name = "Weak outline",
            description = "Color of the outline on an active weak guardian.",
            position = 6,
            section = outlines
    )
    default Color weakGuardianColor() {
        return Color.WHITE;
    }

    @Alpha
    @ConfigItem(
            keyName = "mediumGuardianColor",
            name = "Medium outline",
            description = "Color of the outline on an active medium guardian.",
            position = 7,
            section = outlines
    )
    default Color mediumGuardianColor() {
        return Color.BLUE;
    }

    @Alpha
    @ConfigItem(
            keyName = "strongGuardianColor",
            name = "Strong outline",
            description = "Color of the outline on an active strong guardian.",
            position = 8,
            section = outlines
    )
    default Color strongGuardianColor() {
        return Color.GREEN;
    }

    @Alpha
    @ConfigItem(
            keyName = "overchargedGuardianColor",
            name = "Overcharged outline",
            description = "Color of the outline on an active overcharged guardian.",
            position = 9,
            section = outlines
    )
    default Color overchargedGuardianColor() {
        return Color.RED;
    }

    @ConfigItem(
            keyName = "colorGuardiansWithInsufficientRunecraftingLevel",
            name = "Recolor Unusable Guardians",
            description = "Outlines active portal guardians with this color if the player is not a high enough Runecrafting level to use them.",
            position = 10,
            section = outlines
    )
    default boolean colorGuardiansWithInsufficientRunecraftingLevel() {
        return false;
    }

    @Alpha
    @ConfigItem(
            keyName = "colorGuardiansWithInsufficientRunecraftingLevelColor",
            name = "Unusable Guardian Colors",
            description = "Color of the outline on the active guardian if it is too high level.",
            position = 11,
            section = outlines
    )
    default Color colorGuardiansWithInsufficientRunecraftingLevelColor() {
        return Color.PINK;
    }

    @ConfigItem(
            keyName = "pointBalanceHelper",
            name = "Balance Helper",
            description = "Highlights the guardian needed to keep points balanced or highest tier",
            position = 12,
            section = outlines
    )
    default boolean pointBalanceHelper() {
        return false;
    }

    @Alpha
    @ConfigItem(
            keyName = "essencePileColor",
            name = "Essence pile outline",
            description = "Color of the outline on essence piles.",
            position = 13,
            section = outlines
    )
    default Color essencePileColor() {
        return Color.GREEN;
    }


    @ConfigItem(
            keyName = "startTimerOverlayLocation",
            name = "Start Timer Overlay Location",
            description = "Toggles the start timer overlay location.",
            position = 1,
            section = overlays
    )
    default TimerOverlayLocation startTimerOverlayLocation() {
        return TimerOverlayLocation.Info_Box;
    }

    @ConfigItem(
            keyName = "inactivePortalOverlayLocation",
            name = "Inactive Portal Overlay Location",
            description = "Toggles the inactive portal overlay location.",
            position = 2,
            section = overlays
    )
    default TimerOverlayLocation inactivePortalOverlayLocation() {
        return TimerOverlayLocation.Info_Box;
    }

    @ConfigItem(
            keyName = "showPointsOverlay",
            name = "Show Points Overlay",
            description = "Toggles the points overlay.",
            position = 3,
            section = overlays
    )
    default boolean showPointsOverlay() {
        return true;
    }

    @ConfigItem(
            keyName = "potentialPoints",
            name = "Show potential points",
            description = "Show tallied up points during a game",
            position = 4,
            section = overlays
    )
    default boolean potentialPoints() {
        return true;
    }

    @ConfigItem(
            keyName = "highlightPotential",
            name = "Highlight potential points",
            description = "Highlight potential points depending on balance",
            position = 5,
            section = overlays
    )
    default boolean highlightPotential() {
        return true;
    }

    @Alpha
    @ConfigItem(
            keyName = "potentialUnbalanceColor",
            name = "Unbalanced potential color",
            description = "Color to highlight potential points when unbalanced",
            position = 6,
            section = overlays
    )
    default Color potentialUnbalanceColor() {
        return Color.RED;
    }

    @Alpha
    @ConfigItem(
            keyName = "potentialBalanceColor",
            name = "Balanced potential color",
            description = "Color to highlight potential points when balanced",
            position = 7,
            section = overlays
    )
    default Color potentialBalanceColor() {
        return Color.GREEN;
    }





    @ConfigItem(
            keyName = "notifyGuardianCondition",
            name = "Notify on",
            description = "Determines when guardian notifications will trigger.",
            position = 0,
            section = guardianNotifications
    )
    default NotifyGuardianCondition notifyGuardianCondition() {
        return NotifyGuardianCondition.Full_Inventory;
    }


    @ConfigItem(
            keyName = "airSpawn",
            name = "Notify on Air Guardian",
            description = "Notifies you when an air guardian portal opens.",
            position = 1,
            section = guardianNotifications
    )
    default boolean notifyAirGuardian() {
        return false;
    }

    @ConfigItem(
            keyName = "mindSpawn",
            name = "Notify on Mind Guardian",
            description = "Notifies you when an mind guardian portal opens.",
            position = 2,
            section = guardianNotifications
    )
    default boolean notifyMindGuardian() {
        return false;
    }

    @ConfigItem(
            keyName = "waterSpawn",
            name = "Notify on Water Guardian",
            description = "Notifies you when a water guardian portal opens.",
            position = 3,
            section = guardianNotifications
    )
    default boolean notifyWaterGuardian() {
        return false;
    }

    @ConfigItem(
            keyName = "earthSpawn",
            name = "Notify on Earth Guardian",
            description = "Notifies you when an earth guardian portal opens.",
            position = 4,
            section = guardianNotifications
    )
    default boolean notifyEarthGuardian() {
        return false;
    }

    @ConfigItem(
            keyName = "fireSpawn",
            name = "Notify on Fire Guardian",
            description = "Notifies you when a fire guardian portal opens.",
            position = 5,
            section = guardianNotifications
    )
    default boolean notifyFireGuardian() {
        return false;
    }

    @ConfigItem(
            keyName = "bodySpawn",
            name = "Notify on Body Guardian",
            description = "Notifies you when a body guardian portal opens.",
            position = 6,
            section = guardianNotifications
    )
    default boolean notifyBodyGuardian() {
        return false;
    }

    @ConfigItem(
            keyName = "cosmicSpawn",
            name = "Notify on Cosmic Guardian",
            description = "Notifies you when a cosmic guardian portal opens.",
            position = 7,
            section = guardianNotifications
    )
    default boolean notifyCosmicGuardian() {
        return false;
    }

    @ConfigItem(
            keyName = "chaosSpawn",
            name = "Notify on Chaos Guardian",
            description = "Notifies you when a chaos guardian portal opens.",
            position = 8,
            section = guardianNotifications
    )
    default boolean notifyChaosGuardian() {
        return false;
    }

    @ConfigItem(
            keyName = "natureSpawn",
            name = "Notify on Nature Guardian",
            description = "Notifies you when a nature guardian portal opens.",
            position = 9,
            section = guardianNotifications
    )
    default boolean notifyNatureGuardian() {
        return false;
    }

    @ConfigItem(
            keyName = "lawSpawn",
            name = "Notify on Law Guardian",
            description = "Notifies you when a law guardian portal opens.",
            position = 10,
            section = guardianNotifications
    )
    default boolean notifyLawGuardian() {
        return false;
    }

    @ConfigItem(
            keyName = "deathSpawn",
            name = "Notify on Death Guardian",
            description = "Notifies you when a death guardian portal opens.",
            position = 11,
            section = guardianNotifications
    )
    default boolean notifyDeathGuardian() {
        return false;
    }

    @ConfigItem(
            keyName = "bloodSpawn",
            name = "Notify on Blood Guardian",
            description = "Notifies you when a blood guardian portal opens.",
            position = 12,
            section = guardianNotifications
    )
    default boolean notifyBloodGuardian() {
        return false;
    }
}

package com.datbear;

public enum CellType {
    Weak,
    Medium,
    Strong,
    Overcharged
}

package com.datbear;

public enum NotifyGuardianCondition {
    Always,
    Have_Guardian_Essence,
    Full_Inventory
}

