package shortestpath;

import java.util.Map;

import lombok.Getter;

public class TransportVarbit {
    @Getter
    private final int id;
    private final int value;
    private final TransportVarCheck check;

    public TransportVarbit(int id, int value, TransportVarCheck check) {
        this.id = id;
        this.value = value;
        this.check = check;
    }

    public boolean check(Map<Integer, Integer> values) {
        switch (check) {
            case EQUAL:
                return values.get(id) == value;
            case GREATER:
                return values.get(id) > value;
            case SMALLER:
                return values.get(id) < value;
            case BIT_SET:
                return (values.get(id) & value) > 0;
            case COOLDOWN_MINUTES:
                return ((System.currentTimeMillis() / 60000) - values.get(id)) > value;
        }
        return false;
    }
}

package shortestpath;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class Destination {
    private static void addDestinations(Map<String, Set<Integer>> destinations, String path) {
        final String DELIM_COLUMN = "\t";
        final String PREFIX_COMMENT = "#";
        final String FILE_EXTENSION = ".";
        final String DELIM_PATH = "/";
        final String DELIM = " ";

        try {
            String s = new String(Util.readAllBytes(ShortestPathPlugin.class.getResourceAsStream(path)), StandardCharsets.UTF_8);
            Scanner scanner = new Scanner(s);

            // Header line is the first line in the file and will start with either '#' or '# '
            String headerLine = scanner.nextLine();
            headerLine = headerLine.startsWith(PREFIX_COMMENT + " ") ? headerLine.replace(PREFIX_COMMENT + " ", PREFIX_COMMENT) : headerLine;
            headerLine = headerLine.startsWith(PREFIX_COMMENT) ? headerLine.replace(PREFIX_COMMENT, "") : headerLine;
            String[] headers = headerLine.split(DELIM_COLUMN);

            String[] parts = path.replace(FILE_EXTENSION, DELIM_PATH).split(DELIM_PATH);
            String entry = parts[parts.length - 2];

            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();

                if (line.startsWith(PREFIX_COMMENT) || line.isBlank()) {
                    continue;
                }

                String[] fields = line.split(DELIM_COLUMN);
                Map<String, List<String>> fieldMap = new HashMap<>();
                for (int i = 0; i < headers.length; i++) {
                    if (i < fields.length) {
                        List<String> values = fieldMap.getOrDefault(headers[i], new ArrayList<>());
                        values.add(fields[i]);
                        fieldMap.put(headers[i], values);
                    }
                }
                for (String field : fieldMap.keySet()) {
                    if ("Destination".equals(field)) {
                        for (String value : fieldMap.get(field)) {
                            try {
                                String[] destinationArray = value.split(DELIM);
                                if (destinationArray.length == 3) {
                                    Set<Integer> entryDestinations = destinations.getOrDefault(entry, new HashSet<>());
                                    entryDestinations.add(WorldPointUtil.packWorldPoint(
                                        Integer.parseInt(destinationArray[0]),
                                        Integer.parseInt(destinationArray[1]),
                                        Integer.parseInt(destinationArray[2])));
                                    destinations.put(entry, entryDestinations);
                                }
                            } catch (NumberFormatException e) {
                                log.error("Invalid destination coordinate", e);
                            }
                        }
                    }
                }
            }
            scanner.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public static Map<String, Set<Integer>> loadAllFromResources() {
        Map<String, Set<Integer>> destinations = new HashMap<>(10);
        addDestinations(destinations, "/destinations/game_features/altar.tsv");
        addDestinations(destinations, "/destinations/game_features/bank.tsv");
        addDestinations(destinations, "/destinations/training/anvil.tsv");
        addDestinations(destinations, "/destinations/shopping/apothecary.tsv");
        return destinations;
    }
}

package shortestpath;

public class PendingTask {
    private final int tick;
    private final Runnable task;

    PendingTask(int tick, Runnable task) {
        this.tick = tick;
        this.task = task;
    }

    public boolean check(int tick) {
        return tick >= this.tick;
    }

    public void run() {
        task.run();
    }
}

package shortestpath.pathfinder;

import java.util.BitSet;
import java.util.Locale;
import lombok.Getter;
import static net.runelite.api.Constants.REGION_SIZE;

public class FlagMap {
    private static final byte FLAG_COUNT = 2;
    private final BitSet flags;
    @Getter
    private final byte planeCount;
    private final int minX;
    private final int minY;

    public FlagMap(int minX, int minY, byte planeCount) {
        this.minX = minX;
        this.minY = minY;
        this.planeCount = planeCount;
        flags = new BitSet(REGION_SIZE * REGION_SIZE * planeCount * FLAG_COUNT);
    }

    public FlagMap(int minX, int minY, byte[] bytes) {
        this.minX = minX;
        this.minY = minY;
        flags = BitSet.valueOf(bytes);
        int scale = REGION_SIZE * REGION_SIZE * FLAG_COUNT;
        this.planeCount = (byte) ((flags.size() + scale - 1) / scale);
    }

    public byte[] toBytes() {
        return flags.toByteArray();
    }

    public boolean get(int x, int y, int z, int flag) {
        if (x < minX || x >= (minX + REGION_SIZE) || y < minY || y >= (minY + REGION_SIZE) || z < 0 || z >= planeCount) {
            return false;
        }

        return flags.get(index(x, y, z, flag));
    }

    public void set(int x, int y, int z, int flag, boolean value) {
        flags.set(index(x, y, z, flag), value);
    }

    private int index(int x, int y, int z, int flag) {
        if (x < minX || x >= (minX + REGION_SIZE) || y < minY || y >= (minY + REGION_SIZE) || z < 0 || z >= planeCount || flag < 0 || flag >= FLAG_COUNT) {
            throw new IndexOutOfBoundsException(
                String.format(Locale.ENGLISH, "[%d,%d,%d,%d] when extents are [>=%d,>=%d,>=%d,>=%d] - [<=%d,<=%d,<%d,<%d]",
                        x, y, z, flag,
                        minX, minY, 0, 0,
                        minX + REGION_SIZE - 1, minY + REGION_SIZE - 1, planeCount, FLAG_COUNT
                )
            );
        }

        return (z * REGION_SIZE * REGION_SIZE + (y - minY) * REGION_SIZE + (x - minX)) * FLAG_COUNT + flag;
    }
}

package shortestpath.pathfinder;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import shortestpath.WorldPointUtil;

public class Node {
    public final int packedPosition;
    public final Node previous;
    public final int cost;

    public Node(int packedPosition, Node previous, int cost) {
        this.packedPosition = packedPosition;
        this.previous = previous;
        this.cost = cost;
    }

    public Node(int packedPosition, Node previous) {
        this(packedPosition, previous, cost(packedPosition, previous));
    }

    public List<Integer> getPath() {
        List<Integer> path = new LinkedList<>();
        Node node = this;

        while (node != null) {
            path.add(0, node.packedPosition);
            node = node.previous;
        }

        return new ArrayList<>(path);
    }

    public List<Integer> getPathPacked() {
        List<Integer> path = new LinkedList<>();
        Node node = this;

        while (node != null) {
            path.add(0, node.packedPosition);
            node = node.previous;
        }

        return new ArrayList<>(path);
    }

    private static int cost(int packedPosition, Node previous) {
        int previousCost = 0;
        int travelTime = 0;

        if (previous != null) {
            previousCost = previous.cost;
            // Travel wait time in TransportNode and distance is compared as if the player is walking 1 tile/tick.
            // TODO: reduce the distance if the player is currently running and has enough run energy for the distance?
            travelTime = WorldPointUtil.distanceBetween(previous.packedPosition, packedPosition);
        }

        return previousCost + travelTime;
    }
}

package shortestpath.pathfinder;

import java.io.IOException;
import java.io.UncheckedIOException;
import java.util.HashMap;
import java.util.Map;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import shortestpath.ShortestPathPlugin;
import shortestpath.Util;

import static net.runelite.api.Constants.REGION_SIZE;

public class SplitFlagMap {
    @Getter
    private static RegionExtent regionExtents;

    @Getter
    private final byte[] regionMapPlaneCounts;
    // Size is automatically chosen based on the max extents of the collision data
    private final FlagMap[] regionMaps;
    private final int widthInclusive;

    public SplitFlagMap(Map<Integer, byte[]> compressedRegions) {
        widthInclusive = regionExtents.getWidth() + 1;
        final int heightInclusive = regionExtents.getHeight() + 1;
        regionMaps = new FlagMap[widthInclusive * heightInclusive];
        regionMapPlaneCounts = new byte[regionMaps.length];

        for (Map.Entry<Integer, byte[]> entry : compressedRegions.entrySet()) {
            final int pos = entry.getKey();
            final int x = unpackX(pos);
            final int y = unpackY(pos);
            final int index = getIndex(x, y);
            FlagMap flagMap = new FlagMap(x * REGION_SIZE, y * REGION_SIZE, entry.getValue());
            regionMaps[index] = flagMap;
            regionMapPlaneCounts[index] = flagMap.getPlaneCount();
        }
    }

    public boolean get(int x, int y, int z, int flag) {
        final int index = getIndex(x / REGION_SIZE, y / REGION_SIZE);
        if (index < 0 || index >= regionMaps.length || regionMaps[index] == null) {
            return false;
        }

        return regionMaps[index].get(x, y, z, flag);
    }

    private int getIndex(int regionX, int regionY) {
        return (regionX - regionExtents.getMinX()) + (regionY - regionExtents.getMinY()) * widthInclusive;
    }

    public static int unpackX(int position) {
        return position & 0xFFFF;
    }

    public static int unpackY(int position) {
        return (position >> 16) & 0xFFFF;
    }

    public static int packPosition(int x, int y) {
        return (x & 0xFFFF) | ((y & 0xFFFF) << 16);
    }

    public static SplitFlagMap fromResources() {
        Map<Integer, byte[]> compressedRegions = new HashMap<>();
        try (ZipInputStream in = new ZipInputStream(ShortestPathPlugin.class.getResourceAsStream("/collision-map.zip"))) {
            int minX = Integer.MAX_VALUE;
            int minY = Integer.MAX_VALUE;
            int maxX = 0;
            int maxY = 0;

            ZipEntry entry;
            while ((entry = in.getNextEntry()) != null) {
                String[] n = entry.getName().split("_");
                final int x = Integer.parseInt(n[0]);
                final int y = Integer.parseInt(n[1]);
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                maxX = Math.max(maxX, x);
                maxY = Math.max(maxY, y);

                compressedRegions.put(SplitFlagMap.packPosition(x, y), Util.readAllBytes(in));
            }

            regionExtents = new RegionExtent(minX, minY, maxX, maxY);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }

        return new SplitFlagMap(compressedRegions);
    }

    @RequiredArgsConstructor
    @Getter
    public static class RegionExtent {
        public final int minX, minY, maxX, maxY;

        public int getWidth() {
            return maxX - minX;
        }

        public int getHeight() {
            return maxY - minY;
        }
    }
}

package shortestpath.pathfinder;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import shortestpath.Transport;
import shortestpath.WorldPointUtil;

public class CollisionMap {

    // Enum.values() makes copies every time which hurts performance in the hotpath
    private static final OrdinalDirection[] ORDINAL_VALUES = OrdinalDirection.values();

    private final SplitFlagMap collisionData;

    public byte[] getPlanes() {
        return collisionData.getRegionMapPlaneCounts();
    }

    public CollisionMap(SplitFlagMap collisionData) {
        this.collisionData = collisionData;
    }

    private boolean get(int x, int y, int z, int flag) {
        return collisionData.get(x, y, z, flag);
    }

    public boolean n(int x, int y, int z) {
        return get(x, y, z, 0);
    }

    public boolean s(int x, int y, int z) {
        return n(x, y - 1, z);
    }

    public boolean e(int x, int y, int z) {
        return get(x, y, z, 1);
    }

    public boolean w(int x, int y, int z) {
        return e(x - 1, y, z);
    }

    private boolean ne(int x, int y, int z) {
        return n(x, y, z) && e(x, y + 1, z) && e(x, y, z) && n(x + 1, y, z);
    }

    private boolean nw(int x, int y, int z) {
        return n(x, y, z) && w(x, y + 1, z) && w(x, y, z) && n(x - 1, y, z);
    }

    private boolean se(int x, int y, int z) {
        return s(x, y, z) && e(x, y - 1, z) && e(x, y, z) && s(x + 1, y, z);
    }

    private boolean sw(int x, int y, int z) {
        return s(x, y, z) && w(x, y - 1, z) && w(x, y, z) && s(x - 1, y, z);
    }

    public boolean isBlocked(int x, int y, int z) {
        return !n(x, y, z) && !s(x, y, z) && !e(x, y, z) && !w(x, y, z);
    }

    private static int packedPointFromOrdinal(int startPacked, OrdinalDirection direction) {
        final int x = WorldPointUtil.unpackWorldX(startPacked);
        final int y = WorldPointUtil.unpackWorldY(startPacked);
        final int plane = WorldPointUtil.unpackWorldPlane(startPacked);
        return WorldPointUtil.packWorldPoint(x + direction.x, y + direction.y, plane);
    }

    // This is only safe if pathfinding is single-threaded
    private final List<Node> neighbors = new ArrayList<>(16);
    private final boolean[] traversable = new boolean[8];

    public List<Node> getNeighbors(Node node, VisitedTiles visited, PathfinderConfig config) {
        final int x = WorldPointUtil.unpackWorldX(node.packedPosition);
        final int y = WorldPointUtil.unpackWorldY(node.packedPosition);
        final int z = WorldPointUtil.unpackWorldPlane(node.packedPosition);

        neighbors.clear();

        @SuppressWarnings("unchecked") // Casting EMPTY_LIST to List<Transport> is safe here
        Set<Transport> transports = config.getTransportsPacked().getOrDefault(node.packedPosition, (Set<Transport>)Collections.EMPTY_SET);

        // Transports are pre-filtered by PathfinderConfig.refreshTransports
        // Thus any transports in the list are guaranteed to be valid per the user's settings
        for (Transport transport : transports) {
            if (visited.get(transport.getDestination())) continue;
            neighbors.add(new TransportNode(transport.getDestination(), node, transport.getDuration()));
        }

        if (isBlocked(x, y, z)) {
            boolean westBlocked = isBlocked(x - 1, y, z);
            boolean eastBlocked = isBlocked(x + 1, y, z);
            boolean southBlocked = isBlocked(x, y - 1, z);
            boolean northBlocked = isBlocked(x, y + 1, z);
            boolean southWestBlocked = isBlocked(x - 1, y - 1, z);
            boolean southEastBlocked = isBlocked(x + 1, y - 1, z);
            boolean northWestBlocked = isBlocked(x - 1, y + 1, z);
            boolean northEastBlocked = isBlocked(x + 1, y + 1, z);
            traversable[0] = !westBlocked;
            traversable[1] = !eastBlocked;
            traversable[2] = !southBlocked;
            traversable[3] = !northBlocked;
            traversable[4] = !southWestBlocked && !westBlocked && !southBlocked;
            traversable[5] = !southEastBlocked && !eastBlocked && !southBlocked;
            traversable[6] = !northWestBlocked && !westBlocked && !northBlocked;
            traversable[7] = !northEastBlocked && !eastBlocked && !northBlocked;
        } else {
            traversable[0] = w(x, y, z);
            traversable[1] = e(x, y, z);
            traversable[2] = s(x, y, z);
            traversable[3] = n(x, y, z);
            traversable[4] = sw(x, y, z);
            traversable[5] = se(x, y, z);
            traversable[6] = nw(x, y, z);
            traversable[7] = ne(x, y, z);
        }

        for (int i = 0; i < traversable.length; i++) {
            OrdinalDirection d = ORDINAL_VALUES[i];
            int neighborPacked = packedPointFromOrdinal(node.packedPosition, d);
            if (visited.get(neighborPacked)) continue;

            if (traversable[i]) {
                neighbors.add(new Node(neighborPacked, node));
            } else if (Math.abs(d.x + d.y) == 1 && isBlocked(x + d.x, y + d.y, z)) {
                // The transport starts from a blocked adjacent tile, e.g. fairy ring
                // Only checks non-teleport transports (includes portals and levers, but not items and spells)
                @SuppressWarnings("unchecked") // Casting EMPTY_LIST to List<Transport> is safe here
                Set<Transport> neighborTransports = config.getTransportsPacked().getOrDefault(neighborPacked, (Set<Transport>)Collections.EMPTY_SET);
                for (Transport transport : neighborTransports) {
                    if (transport.getOrigin() == Transport.UNDEFINED_ORIGIN || visited.get(transport.getOrigin())) {
                        continue;
                    }
                    neighbors.add(new Node(transport.getOrigin(), node));
                }
            }
        }

        return neighbors;
    }
}

package shortestpath.pathfinder;

public class TransportNode extends Node implements Comparable<TransportNode> {
    public TransportNode(int packedPosition, Node previous, int travelTime) {
        super(packedPosition, previous, cost(previous, travelTime));
    }

    private static int cost(Node previous, int travelTime) {
        return (previous != null ? previous.cost : 0) + travelTime;
    }

    @Override
    public int compareTo(TransportNode other) {
        return Integer.compare(cost, other.cost);
    }
}

package shortestpath.pathfinder;

import shortestpath.WorldPointUtil;
import static net.runelite.api.Constants.REGION_SIZE;

public class VisitedTiles {
    private final SplitFlagMap.RegionExtent regionExtents;
    private final int widthInclusive;

    private final VisitedRegion[] visitedRegions;
    private final byte[] visitedRegionPlanes;

    public VisitedTiles(CollisionMap map) {
        regionExtents = SplitFlagMap.getRegionExtents();
        widthInclusive = regionExtents.getWidth() + 1;
        final int heightInclusive = regionExtents.getHeight() + 1;

        visitedRegions = new VisitedRegion[widthInclusive * heightInclusive];
        visitedRegionPlanes = map.getPlanes();
    }

    public boolean get(int packedPoint) {
        final int x = WorldPointUtil.unpackWorldX(packedPoint);
        final int y = WorldPointUtil.unpackWorldY(packedPoint);
        final int plane = WorldPointUtil.unpackWorldPlane(packedPoint);
        return get(x, y, plane);
    }

    public boolean get(int x, int y, int plane) {
        final int regionIndex = getRegionIndex(x / REGION_SIZE, y / REGION_SIZE);
        if (regionIndex < 0 || regionIndex >= visitedRegions.length) {
            return true; // Region is out of bounds; report that it's been visited to avoid exploring it further
        }

        final VisitedRegion region = visitedRegions[regionIndex];
        if (region == null) {
            return false;
        }

        return region.get(x % REGION_SIZE, y % REGION_SIZE, plane);
    }

    public boolean set(int packedPoint) {
        final int x = WorldPointUtil.unpackWorldX(packedPoint);
        final int y = WorldPointUtil.unpackWorldY(packedPoint);
        final int plane = WorldPointUtil.unpackWorldPlane(packedPoint);
        return set(x, y, plane);
    }

    public boolean set(int x, int y, int plane) {
        final int regionIndex = getRegionIndex(x / REGION_SIZE, y / REGION_SIZE);
        if (regionIndex < 0 || regionIndex >= visitedRegions.length) {
            return false; // Region is out of bounds; report that it's been visited to avoid exploring it further
        }

        VisitedRegion region = visitedRegions[regionIndex];
        if (region == null) {
            region = new VisitedRegion(visitedRegionPlanes[regionIndex]);
            visitedRegions[regionIndex] = region;
        }

        return region.set(x % REGION_SIZE, y % REGION_SIZE, plane);
    }

    public void clear() {
        for (int i = 0; i < visitedRegions.length; ++i) {
            if (visitedRegions[i] != null) {
                visitedRegions[i] = null;
            }
        }
    }

    private int getRegionIndex(int regionX, int regionY) {
        return (regionX - regionExtents.minX) + (regionY - regionExtents.minY) * widthInclusive;
    }

    public int getRegionX(int regionIndex) {
        return (regionIndex % widthInclusive + regionExtents.minX) * REGION_SIZE;
    }

    public int getRegionY(int regionIndex) {
        return (regionIndex / widthInclusive + regionExtents.minY) * REGION_SIZE;
    }

    private static class VisitedRegion {
        // This assumes a row is at most 64 tiles and fits in a long
        private final long[] planes;
        private final byte planeCount;

        VisitedRegion(byte planeCount) {
            this.planeCount = planeCount;
            this.planes = new long[planeCount * REGION_SIZE];
        }

        // Sets a tile as visited in the tile bitset
        // Returns true if the tile is unique and hasn't been seen before or false if it was seen before
        public boolean set(int x, int y, int plane) {
            if (plane >= planeCount) {
                // Plane is out of bounds; report that it has been visited to avoid further exploration
                return false;
            }
            final int index = y + plane * REGION_SIZE;
            boolean unique = (planes[index] & (1L << x)) == 0;
            planes[index] |= 1L << x;
            return unique;
        }

        public boolean get(int x, int y, int plane) {
            if (plane >= planeCount) {
                // This check is necessary since we check visited tiles before checking the collision map, e.g. the node
                // at (2816, 3455, 1) will check its neighbour to the north which is in a new region with no plane = 1
                return true;
            }
            return (planes[y + plane * REGION_SIZE] & (1L << x)) != 0;
        }
    }
}

package shortestpath.pathfinder;

public enum OrdinalDirection {
    WEST(-1, 0),
    EAST(1, 0),
    SOUTH(0, -1),
    NORTH(0, 1),
    SOUTH_WEST(-1, -1),
    SOUTH_EAST(1, -1),
    NORTH_WEST(-1, 1),
    NORTH_EAST(1, 1);

    final int x;
    final int y;

    OrdinalDirection(int x, int y) {
        this.x = x;
        this.y = y;
    }
}

package shortestpath.pathfinder;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Set;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.EnumComposition;
import net.runelite.api.EnumID;
import net.runelite.api.GameState;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.Quest;
import net.runelite.api.QuestState;
import net.runelite.api.Skill;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;
import shortestpath.TeleportationItem;
import shortestpath.ShortestPathConfig;
import shortestpath.ShortestPathPlugin;
import shortestpath.Destination;
import shortestpath.PrimitiveIntHashMap;
import shortestpath.Transport;
import shortestpath.TransportItems;
import shortestpath.TransportType;
import shortestpath.TransportVarbit;
import shortestpath.TransportVarPlayer;
import shortestpath.WorldPointUtil;
import static shortestpath.TransportType.AGILITY_SHORTCUT;
import static shortestpath.TransportType.GRAPPLE_SHORTCUT;
import static shortestpath.TransportType.BOAT;
import static shortestpath.TransportType.CANOE;
import static shortestpath.TransportType.CHARTER_SHIP;
import static shortestpath.TransportType.SHIP;
import static shortestpath.TransportType.FAIRY_RING;
import static shortestpath.TransportType.GNOME_GLIDER;
import static shortestpath.TransportType.HOT_AIR_BALLOON;
import static shortestpath.TransportType.MINECART;
import static shortestpath.TransportType.QUETZAL;
import static shortestpath.TransportType.SPIRIT_TREE;
import static shortestpath.TransportType.TELEPORTATION_BOX;
import static shortestpath.TransportType.TELEPORTATION_LEVER;
import static shortestpath.TransportType.TELEPORTATION_MINIGAME;
import static shortestpath.TransportType.TELEPORTATION_PORTAL;
import static shortestpath.TransportType.TELEPORTATION_ITEM;
import static shortestpath.TransportType.TELEPORTATION_SPELL;
import static shortestpath.TransportType.WILDERNESS_OBELISK;

public class PathfinderConfig {
    private static final WorldArea WILDERNESS_ABOVE_GROUND = new WorldArea(2944, 3525, 448, 448, 0);
    private static final WorldArea WILDERNESS_ABOVE_GROUND_LEVEL_20 = new WorldArea(2944, 3680, 448, 448, 0);
    private static final WorldArea WILDERNESS_ABOVE_GROUND_LEVEL_30 = new WorldArea(2944, 3760, 448, 448, 0);
    private static final WorldArea WILDERNESS_UNDERGROUND = new WorldArea(2944, 9918, 320, 442, 0);
    private static final WorldArea WILDERNESS_UNDERGROUND_LEVEL_20 = new WorldArea(2944, 10075, 320, 442, 0);
    private static final WorldArea WILDERNESS_UNDERGROUND_LEVEL_30 = new WorldArea(2944, 10155, 320, 442, 0);
    private static final WorldArea FEROX_ENCLAVE_1 = new WorldArea(3123, 3622, 2, 10, 0);
    private static final WorldArea FEROX_ENCLAVE_2 = new WorldArea(3125, 3617, 16, 23, 0);
    private static final WorldArea FEROX_ENCLAVE_3 = new WorldArea(3138, 3636, 18, 10, 0);
    private static final WorldArea FEROX_ENCLAVE_4 = new WorldArea(3141, 3625, 14, 11, 0);
    private static final WorldArea FEROX_ENCLAVE_5 = new WorldArea(3141, 3619, 7, 6, 0);
    private static final WorldArea NOT_WILDERNESS_1 = new WorldArea(2997, 3525, 34, 9, 0);
    private static final WorldArea NOT_WILDERNESS_2 = new WorldArea(3005, 3534, 21, 10, 0);
    private static final WorldArea NOT_WILDERNESS_3 = new WorldArea(3000, 3534, 5, 5, 0);
    private static final WorldArea NOT_WILDERNESS_4 = new WorldArea(3031, 3525, 2, 2, 0);
    private static final List<Integer> RUNE_POUCHES = Arrays.asList(
        ItemID.BH_RUNE_POUCH, ItemID.BH_RUNE_POUCH_TROUVER,
        ItemID.DIVINE_RUNE_POUCH, ItemID.DIVINE_RUNE_POUCH_TROUVER
    );
    private static final int[] RUNE_POUCH_RUNE_VARBITS = {
        VarbitID.RUNE_POUCH_TYPE_1, VarbitID.RUNE_POUCH_TYPE_2, VarbitID.RUNE_POUCH_TYPE_3, VarbitID.RUNE_POUCH_TYPE_4,
        VarbitID.RUNE_POUCH_TYPE_5, VarbitID.RUNE_POUCH_TYPE_6
	};
    private static final int[] RUNE_POUCH_AMOUNT_VARBITS = {
        VarbitID.RUNE_POUCH_QUANTITY_1, VarbitID.RUNE_POUCH_QUANTITY_2, VarbitID.RUNE_POUCH_QUANTITY_3, VarbitID.RUNE_POUCH_QUANTITY_4,
        VarbitID.RUNE_POUCH_QUANTITY_5, VarbitID.RUNE_POUCH_QUANTITY_6
	};
    private static final Set<Integer> CURRENCIES = Set.of(
        ItemID.COINS, ItemID.VILLAGE_TRADE_STICKS, ItemID.ECTOTOKEN, ItemID.WARGUILD_TOKENS);

    private final SplitFlagMap mapData;
    private final ThreadLocal<CollisionMap> map;
    /** All transports by origin. The WorldPointUtil.UNDEFINED key is used for transports centered on the player. */
    private final Map<Integer, Set<Transport>> allTransports;
    private final Set<Transport> usableTeleports;
    private final Map<String, Set<Integer>> allDestinations;
    private final Map<String, Set<Integer>> filteredDestinations;
    private final Map<Integer, Integer> itemsAndQuantities = new HashMap<>(28 + 11 + 500);
    private final List<Integer> filteredTargets = new ArrayList<>(4);

    @Getter
    private final Map<Integer, Set<Transport>> transports;
    // Copy of transports with packed positions for the hotpath; lists are not copied and are the same reference in both maps
    @Getter
    private final PrimitiveIntHashMap<Set<Transport>> transportsPacked;
    /** Reference that points to either allDestinations or filteredDestinations */
    private Map<String, Set<Integer>> destinations;

    private final Client client;
    private final ShortestPathConfig config;

    @Getter
    private long calculationCutoffMillis;
    @Getter
    private boolean avoidWilderness;
    private boolean useAgilityShortcuts,
        useGrappleShortcuts,
        useBoats,
        useCanoes,
        useCharterShips,
        useShips,
        useFairyRings,
        useGnomeGliders,
        useHotAirBalloons,
        useMinecarts,
        useQuetzals,
        useSpiritTrees,
        useTeleportationBoxes,
        useTeleportationLevers,
        useTeleportationMinigames,
        useTeleportationPortals,
        useTeleportationSpells,
        useWildernessObelisks;
    private TeleportationItem useTeleportationItems;
    private int currencyThreshold;
    private final int[] boostedLevels = new int[Skill.values().length];
    private Map<Quest, QuestState> questStates = new HashMap<>();
    private Map<Integer, Integer> varbitValues = new HashMap<>();
    private Map<Integer, Integer> varPlayerValues = new HashMap<>();

    public ItemContainer bank = null;

    public PathfinderConfig(Client client, ShortestPathConfig config) {
        this.client = client;
        this.config = config;
        this.mapData = SplitFlagMap.fromResources();
        this.map = ThreadLocal.withInitial(() -> new CollisionMap(mapData));
        this.allTransports = Transport.loadAllFromResources();
        this.usableTeleports = new HashSet<>(allTransports.size() / 20);
        this.transports = new HashMap<>(allTransports.size() / 2);
        this.transportsPacked = new PrimitiveIntHashMap<>(allTransports.size() / 2);
        this.allDestinations = Destination.loadAllFromResources();
        this.filteredDestinations = filterDestinations(allDestinations);
        this.destinations = allDestinations;
    }

    public CollisionMap getMap() {
        return map.get();
    }

    public boolean hasDestination(String destinationType) {
        return destinations.containsKey(destinationType);
    }

    public Set<Integer> getDestinations(String destinationType) {
        return destinations.get(destinationType);
    }

    public void refresh() {
        calculationCutoffMillis = config.calculationCutoff() * Constants.GAME_TICK_LENGTH;
        avoidWilderness = ShortestPathPlugin.override("avoidWilderness", config.avoidWilderness());
        useAgilityShortcuts = ShortestPathPlugin.override("useAgilityShortcuts", config.useAgilityShortcuts());
        useGrappleShortcuts = ShortestPathPlugin.override("useGrappleShortcuts", config.useGrappleShortcuts());
        useBoats = ShortestPathPlugin.override("useBoats", config.useBoats());
        useCanoes = ShortestPathPlugin.override("useCanoes", config.useCanoes());
        useCharterShips = ShortestPathPlugin.override("useCharterShips", config.useCharterShips());
        useShips = ShortestPathPlugin.override("useShips", config.useShips());
        useFairyRings = ShortestPathPlugin.override("useFairyRings", config.useFairyRings());
        useGnomeGliders = ShortestPathPlugin.override("useGnomeGliders", config.useGnomeGliders());
        useHotAirBalloons = ShortestPathPlugin.override("useHotAirBalloons", config.useHotAirBalloons());
        useMinecarts = ShortestPathPlugin.override("useMinecarts", config.useMinecarts());
        useQuetzals = ShortestPathPlugin.override("useQuetzals", config.useQuetzals());
        useSpiritTrees = ShortestPathPlugin.override("useSpiritTrees", config.useSpiritTrees());
        useTeleportationItems = ShortestPathPlugin.override("useTeleportationItems", config.useTeleportationItems());
        useTeleportationBoxes = ShortestPathPlugin.override("useTeleportationBoxes", config.useTeleportationBoxes());
        useTeleportationLevers = ShortestPathPlugin.override("useTeleportationLevers", config.useTeleportationLevers());
        useTeleportationMinigames = ShortestPathPlugin.override("useTeleportationMinigames", config.useTeleportationMinigames());
        useTeleportationPortals = ShortestPathPlugin.override("useTeleportationPortals", config.useTeleportationPortals());
        useTeleportationSpells = ShortestPathPlugin.override("useTeleportationSpells", config.useTeleportationSpells());
        useWildernessObelisks = ShortestPathPlugin.override("useWildernessObelisks", config.useWildernessObelisks());
        currencyThreshold = ShortestPathPlugin.override("currencyThreshold", config.currencyThreshold());

        if (GameState.LOGGED_IN.equals(client.getGameState())) {
            for (int i = 0; i < Skill.values().length; i++) {
                boostedLevels[i] = client.getBoostedSkillLevel(Skill.values()[i]);
            }

            refreshTransports();
        }

        refreshDestinations();
    }

    /** Specialized method for only updating player-held item and spell transports */
    public void refreshTeleports(int packedLocation, int wildernessLevel) {
        Set<Transport> usableWildyTeleports = new HashSet<>(usableTeleports.size());

        for (Transport teleport : usableTeleports) {
            if (wildernessLevel <= teleport.getMaxWildernessLevel()) {
                usableWildyTeleports.add(teleport);
            }
        }

        if (!usableWildyTeleports.isEmpty()) {
            transports.put(packedLocation, usableWildyTeleports);
            transportsPacked.put(packedLocation, usableWildyTeleports);
        }
    }

    private void refreshDestinations() {
        destinations = avoidWilderness ? filteredDestinations : allDestinations;
    }

    /** Changes to the config might have invalidated some locations, e.g. those in the wilderness */
    public void filterLocations(Set<Integer> locations, boolean canReviveFiltered) {
        if (avoidWilderness) {
            locations.removeIf(location -> {
                boolean inWilderness = PathfinderConfig.isInWilderness(location);
                if (inWilderness) {
                    filteredTargets.add(location);
                }
                return inWilderness;
            });
            // If we ended up with no valid locations we re-include the filtered locations
            if (locations.isEmpty()) {
                locations.addAll(filteredTargets);
                filteredTargets.clear();
            }
        } else if (canReviveFiltered) { // Re-include previously filtered locations
            locations.addAll(filteredTargets);
            filteredTargets.clear();
        }
    }

    private Map<String, Set<Integer>> filterDestinations(Map<String, Set<Integer>> allDestinations) {
        Map<String, Set<Integer>> filteredDestinations = new HashMap<>(allDestinations.size());
        for (Map.Entry<String, Set<Integer>> entry : allDestinations.entrySet()) {
            String destinationType = entry.getKey();
            Set<Integer> usableDestinations = new HashSet<>(entry.getValue().size());
            boolean isDifferent = false;
            for (Integer destination : entry.getValue()) {
                // We filter based on whether the destination is inside or outside wilderness
                if (!PathfinderConfig.isInWilderness(destination)) {
                    usableDestinations.add(destination);
                    isDifferent = true;
                }
            }
            // If all destinations of a destination type have been filtered away then we don't add the entry
            if (!usableDestinations.isEmpty()) {
                // If no destinations of a destination type have been filtered away then we re-use the same set reference
                filteredDestinations.put(destinationType, isDifferent ? usableDestinations : entry.getValue());
            }
        }
        return filteredDestinations;
    }

    private void refreshTransports() {
        if (!Thread.currentThread().equals(client.getClientThread())) {
            return; // Has to run on the client thread; data will be refreshed when path finding commences
        }

        useFairyRings &= !QuestState.NOT_STARTED.equals(getQuestState(Quest.FAIRYTALE_II__CURE_A_QUEEN));
        useGnomeGliders &= QuestState.FINISHED.equals(getQuestState(Quest.THE_GRAND_TREE));
        useSpiritTrees &= QuestState.FINISHED.equals(getQuestState(Quest.TREE_GNOME_VILLAGE));

        transports.clear();
        transportsPacked.clear();
        usableTeleports.clear();
        for (Map.Entry<Integer, Set<Transport>> entry : allTransports.entrySet()) {
            int point = entry.getKey();
            Set<Transport> usableTransports = new HashSet<>(entry.getValue().size());
            for (Transport transport : entry.getValue()) {
                for (Quest quest : transport.getQuests()) {
                    try {
                        questStates.put(quest, getQuestState(quest));
                    } catch (NullPointerException ignored) {
                    }
                }

                for (TransportVarbit varbitRequirement : transport.getVarbits()) {
                    varbitValues.put(varbitRequirement.getId(), client.getVarbitValue(varbitRequirement.getId()));
                }
                for (TransportVarPlayer varPlayerRequirement : transport.getVarPlayers()) {
                    varPlayerValues.put(varPlayerRequirement.getId(), client.getVarpValue(varPlayerRequirement.getId()));
                }

                if (useTransport(transport) && hasRequiredItems(transport)) {
                    if (point == WorldPointUtil.UNDEFINED) {
                        usableTeleports.add(transport);
                    } else {
                        usableTransports.add(transport);
                    }
                }
            }

            if (point != WorldPointUtil.UNDEFINED && !usableTransports.isEmpty()) {
                transports.put(point, usableTransports);
                transportsPacked.put(point, usableTransports);
            }
        }
    }

    public static boolean isInWilderness(WorldPoint p) {
        return WILDERNESS_ABOVE_GROUND.distanceTo2D(p) == 0
            && FEROX_ENCLAVE_1.distanceTo2D(p) != 0
            && FEROX_ENCLAVE_2.distanceTo2D(p) != 0
            && FEROX_ENCLAVE_3.distanceTo2D(p) != 0
            && FEROX_ENCLAVE_4.distanceTo2D(p) != 0
            && FEROX_ENCLAVE_5.distanceTo2D(p) != 0
            && NOT_WILDERNESS_1.distanceTo2D(p) != 0
            && NOT_WILDERNESS_2.distanceTo2D(p) != 0
            && NOT_WILDERNESS_3.distanceTo2D(p) != 0
            && NOT_WILDERNESS_4.distanceTo2D(p) != 0
            || WILDERNESS_UNDERGROUND.distanceTo2D(p) == 0;
    }

    public static boolean isInWilderness(int packedPoint) {
        return WorldPointUtil.distanceToArea2D(packedPoint, WILDERNESS_ABOVE_GROUND) == 0
            && WorldPointUtil.distanceToArea2D(packedPoint, FEROX_ENCLAVE_1) != 0
            && WorldPointUtil.distanceToArea2D(packedPoint, FEROX_ENCLAVE_2) != 0
            && WorldPointUtil.distanceToArea2D(packedPoint, FEROX_ENCLAVE_3) != 0
            && WorldPointUtil.distanceToArea2D(packedPoint, FEROX_ENCLAVE_4) != 0
            && WorldPointUtil.distanceToArea2D(packedPoint, FEROX_ENCLAVE_5) != 0
            && WorldPointUtil.distanceToArea2D(packedPoint, NOT_WILDERNESS_1) != 0
            && WorldPointUtil.distanceToArea2D(packedPoint, NOT_WILDERNESS_2) != 0
            && WorldPointUtil.distanceToArea2D(packedPoint, NOT_WILDERNESS_3) != 0
            && WorldPointUtil.distanceToArea2D(packedPoint, NOT_WILDERNESS_4) != 0
            || WorldPointUtil.distanceToArea2D(packedPoint, WILDERNESS_UNDERGROUND) == 0;
    }

    public static boolean isInWilderness(Set<Integer> packedPoints) {
        for (int packedPoint : packedPoints) {
            if (isInWilderness(packedPoint)) {
                return true;
            }
        }
        return false;
    }

    public static boolean isInLevel20Wilderness(int packedPoint) {
        return WorldPointUtil.distanceToArea(packedPoint, WILDERNESS_ABOVE_GROUND_LEVEL_20) == 0
            || WorldPointUtil.distanceToArea(packedPoint, WILDERNESS_UNDERGROUND_LEVEL_20) == 0;
    }

    public static boolean isInLevel30Wilderness(int packedPoint){
        return WorldPointUtil.distanceToArea(packedPoint, WILDERNESS_ABOVE_GROUND_LEVEL_30) == 0
            || WorldPointUtil.distanceToArea(packedPoint, WILDERNESS_UNDERGROUND_LEVEL_30) == 0;

    }

    public boolean avoidWilderness(int packedPosition, int packedNeightborPosition, boolean targetInWilderness) {
        return avoidWilderness && !targetInWilderness
            && !isInWilderness(packedPosition) && isInWilderness(packedNeightborPosition);
    }

    public QuestState getQuestState(Quest quest) {
        return quest.getState(client);
    }

    private boolean completedQuests(Transport transport) {
        for (Quest quest : transport.getQuests()) {
            if (!QuestState.FINISHED.equals(questStates.getOrDefault(quest, QuestState.NOT_STARTED))) {
                return false;
            }
        }
        return true;
    }

    public boolean varbitChecks(Transport transport) {
        for (TransportVarbit varbitRequirement : transport.getVarbits()) {
            if (!varbitRequirement.check(varbitValues)) {
                return false;
            }
        }
        return true;
    }

    public boolean varPlayerChecks(Transport transport) {
        for (TransportVarPlayer varPlayerRequirement : transport.getVarPlayers()) {
            if (!varPlayerRequirement.check(varPlayerValues)) {
                return false;
            }
        }
        return true;
    }

    private boolean useTransport(Transport transport) {
        final boolean isQuestLocked = transport.isQuestLocked();

        if (!hasRequiredLevels(transport)) {
            return false;
        }

        TransportType type = transport.getType();

        if (AGILITY_SHORTCUT.equals(type) && !useAgilityShortcuts) {
            return false;
        } else if (GRAPPLE_SHORTCUT.equals(type) && !useGrappleShortcuts) {
            return false;
        } else if (BOAT.equals(type) && !useBoats) {
            return false;
        } else if (CANOE.equals(type) && !useCanoes) {
            return false;
        } else if (CHARTER_SHIP.equals(type) && !useCharterShips) {
            return false;
        } else if (SHIP.equals(type) && !useShips) {
            return false;
        } else if (FAIRY_RING.equals(type) && !useFairyRings) {
            return false;
        } else if (GNOME_GLIDER.equals(type) && !useGnomeGliders) {
            return false;
        } else if (HOT_AIR_BALLOON.equals(type) && !useHotAirBalloons) {
            return false;
        } else if (MINECART.equals(type) && !useMinecarts) {
            return false;
        } else if (QUETZAL.equals(type) && !useQuetzals) {
            return false;
        } else if (SPIRIT_TREE.equals(type) && !useSpiritTrees) {
            return false;
        } else if (TELEPORTATION_ITEM.equals(type)) {
            switch (useTeleportationItems) {
                case ALL:
                case INVENTORY:
                case INVENTORY_AND_BANK:
                    break;
                case NONE:
                    return false;
                case INVENTORY_NON_CONSUMABLE:
                case INVENTORY_AND_BANK_NON_CONSUMABLE:
                case ALL_NON_CONSUMABLE:
                    if (transport.isConsumable()) {
                        return false;
                    }
                    break;
            }
        } else if (TELEPORTATION_BOX.equals(type) && !useTeleportationBoxes) {
            return false;
        } else if (TELEPORTATION_LEVER.equals(type) && !useTeleportationLevers) {
            return false;
        } else if (TELEPORTATION_MINIGAME.equals(type) && !useTeleportationMinigames) {
            return false;
        } else if (TELEPORTATION_PORTAL.equals(type) && !useTeleportationPortals) {
            return false;
        } else if (TELEPORTATION_SPELL.equals(type) && !useTeleportationSpells) {
            return false;
        } else if (WILDERNESS_OBELISK.equals(type) && !useWildernessObelisks) {
            return false;
        }

        if (isQuestLocked && !completedQuests(transport)) {
            return false;
        }

        if (!varbitChecks(transport)) {
            return false;
        }

        if (!varPlayerChecks(transport)) {
            return false;
        }

        return true;
    }

    /** Checks if the player has all the required skill levels for the transport */
    private boolean hasRequiredLevels(Transport transport) {
        int[] requiredLevels = transport.getSkillLevels();
        for (int i = 0; i < boostedLevels.length; i++) {
            int boostedLevel = boostedLevels[i];
            int requiredLevel = requiredLevels[i];
            if (boostedLevel < requiredLevel) {
                return false;
            }
        }
        return true;
    }

    /** Checks if the player has all the required equipment and inventory items for the transport */
    private boolean hasRequiredItems(Transport transport) {
        if ((TeleportationItem.ALL.equals(useTeleportationItems) ||
            TeleportationItem.ALL_NON_CONSUMABLE.equals(useTeleportationItems)) &&
            TransportType.TELEPORTATION_ITEM.equals(transport.getType())) {
            return true;
        }
        if (TeleportationItem.NONE.equals(useTeleportationItems) &&
            TransportType.TELEPORTATION_ITEM.equals(transport.getType())) {
            return false;
        }
        itemsAndQuantities.clear();
        ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);
        ItemContainer equipment = client.getItemContainer(InventoryID.EQUIPMENT);
        if (inventory != null) {
            for (Item item : inventory.getItems()) {
                if (item.getId() >= 0 && item.getQuantity() > 0) {
                    itemsAndQuantities.put(item.getId(), item.getQuantity());
                }
            }
        }
        if (equipment != null) {
            for (Item item : equipment.getItems()) {
                if (item.getId() >= 0 && item.getQuantity() > 0) {
                    itemsAndQuantities.put(item.getId(), item.getQuantity());
                }
            }
        }
        if (bank != null
            && (TeleportationItem.INVENTORY_AND_BANK.equals(useTeleportationItems)
            || TeleportationItem.INVENTORY_AND_BANK_NON_CONSUMABLE.equals(useTeleportationItems))) {
            for (Item item : bank.getItems()) {
                if (item.getId() >= 0 && item.getQuantity() > 0) {
                    itemsAndQuantities.put(item.getId(), item.getQuantity());
                }
            }
        }
        if (RUNE_POUCHES.stream().anyMatch(runePouch -> itemsAndQuantities.containsKey(runePouch))) {
            EnumComposition runePouchEnum = client.getEnum(EnumID.RUNEPOUCH_RUNE);
            for (int i = 0; i < RUNE_POUCH_RUNE_VARBITS.length; i++) {
                int runeEnumId = client.getVarbitValue(RUNE_POUCH_RUNE_VARBITS[i]);
                int runeId = runeEnumId > 0 ? runePouchEnum.getIntValue(runeEnumId) : 0;
                int runeAmount = client.getVarbitValue(RUNE_POUCH_AMOUNT_VARBITS[i]);
                if (runeId > 0 && runeAmount > 0) {
                    itemsAndQuantities.put(runeId, runeAmount);
                }
            }
        }
        boolean usingStaff = false;
        boolean usingOffhand = false;
        TransportItems transportItems = transport.getItemRequirements();
        if (transportItems == null) {
            return true;
        }
        for (int i = 0; i < transportItems.getItems().length; i++) {
            boolean missing = true;
            if (transportItems.getItems()[i] != null) {
                for (int itemId : transportItems.getItems()[i]) {
                    int quantity = itemsAndQuantities.getOrDefault(itemId, 0);
                    int requiredQuantity = transportItems.getQuantities()[i];
                    if (requiredQuantity > 0 && quantity >= requiredQuantity || requiredQuantity == 0 && quantity == 0) {
                        if (CURRENCIES.contains(itemId) && requiredQuantity > currencyThreshold) {
                            return false;
                        }
                        missing = false;
                        break;
                    }
                }
            }
            if (missing && !usingStaff && transportItems.getStaves()[i] != null) {
                for (int itemId : transportItems.getStaves()[i]) {
                    int quantity = itemsAndQuantities.getOrDefault(itemId, 0);
                    int requiredQuantity = transportItems.getQuantities()[i];
                    if (requiredQuantity > 0 && quantity >= 1 || requiredQuantity == 0 && quantity == 0) {
                        usingStaff = true;
                        missing = false;
                        break;
                    }
                }
            }
            if (missing && !usingOffhand && transportItems.getOffhands()[i] != null) {
                for (int itemId : transportItems.getOffhands()[i]) {
                    int quantity = itemsAndQuantities.getOrDefault(itemId, 0);
                    int requiredQuantity = transportItems.getQuantities()[i];
                    if (requiredQuantity > 0 && quantity >= 1 || requiredQuantity == 0 && quantity == 0) {
                        usingOffhand = true;
                        missing = false;
                        break;
                    }
                }
            }
            if (missing) {
                return false;
            }
        }
        return true;
    }
}

package shortestpath.pathfinder;

import java.util.ArrayDeque;
import java.util.Collections;
import java.util.Deque;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Set;
import lombok.Getter;
import shortestpath.WorldPointUtil;

public class Pathfinder implements Runnable {
    private PathfinderStats stats;
    private volatile boolean done = false;
    private volatile boolean cancelled = false;

    @Getter
    private final int start;
    @Getter
    private final Set<Integer> targets;

    private final PathfinderConfig config;
    private final CollisionMap map;
    private final boolean targetInWilderness;

    // Capacities should be enough to store all nodes without requiring the queue to grow
    // They were found by checking the max queue size
    private final Deque<Node> boundary = new ArrayDeque<>(4096);
    private final Queue<Node> pending = new PriorityQueue<>(256);
    private final VisitedTiles visited;

    @SuppressWarnings("unchecked") // Casting EMPTY_LIST is safe here
    private List<Integer> path = (List<Integer>)Collections.EMPTY_LIST;
    private boolean pathNeedsUpdate = false;
    private Node bestLastNode;
    /**
     * Teleportation transports are updated when this changes.
     * Can be either:
     *  0 = all teleports can be used (e.g. Chronicle)
     * 20 = most teleports can be used (e.g. Varrock Teleport)
     * 30 = some teleports can be used (e.g. Amulet of Glory)
     * 31 = no teleports can be used
     */
    private int wildernessLevel;

    public Pathfinder(PathfinderConfig config, int start, Set<Integer> targets) {
        stats = new PathfinderStats();
        this.config = config;
        this.map = config.getMap();
        this.start = start;
        this.targets = targets;
        visited = new VisitedTiles(map);
        targetInWilderness = PathfinderConfig.isInWilderness(targets);
        wildernessLevel = 31;
    }

    public boolean isDone() {
        return done;
    }

    public void cancel() {
        cancelled = true;
    }

    public PathfinderStats getStats() {
        if (stats.started && stats.ended) {
            return stats;
        }

        // Don't give incomplete results
        return null;
    }

    public List<Integer> getPath() {
        Node lastNode = bestLastNode; // For thread safety, read bestLastNode once
        if (lastNode == null) {
            return path;
        }

        if (pathNeedsUpdate) {
            path = lastNode.getPath();
            pathNeedsUpdate = false;
        }

        return path;
    }

    private void addNeighbors(Node node) {
        List<Node> nodes = map.getNeighbors(node, visited, config);
        for (int i = 0; i < nodes.size(); ++i) {
            Node neighbor = nodes.get(i);

            if (config.avoidWilderness(node.packedPosition, neighbor.packedPosition, targetInWilderness)) {
                continue;
            }

            visited.set(neighbor.packedPosition);
            if (neighbor instanceof TransportNode) {
                pending.add(neighbor);
                ++stats.transportsChecked;
            } else {
                boundary.addLast(neighbor);
                ++stats.nodesChecked;
            }
        }
    }

    @Override
    public void run() {
        stats.start();
        boundary.addFirst(new Node(start, null));

        int bestDistance = Integer.MAX_VALUE;
        long bestHeuristic = Integer.MAX_VALUE;
        long cutoffDurationMillis = config.getCalculationCutoffMillis();
        long cutoffTimeMillis = System.currentTimeMillis() + cutoffDurationMillis;

        while (!cancelled && (!boundary.isEmpty() || !pending.isEmpty())) {
            Node node = boundary.peekFirst();
            Node p = pending.peek();

            if (p != null && (node == null || p.cost < node.cost)) {
                node = pending.poll();
            } else {
                node = boundary.removeFirst();
            }

            if (wildernessLevel > 0) {
                // We don't need to remove teleports when going from 20 to 21 or higher,
                // because the teleport is either used at the very start of the
                // path or when going from 31 or higher to 30, or from 21 or higher to 20.

                boolean update = false;
                
                // These are overlapping boundaries, so if the node isn't in level 30, it's in 0-29
                // likewise, if the node isn't in level 20, it's in 0-19
                if (wildernessLevel > 30 && !PathfinderConfig.isInLevel30Wilderness(node.packedPosition)) {
                    wildernessLevel = 30;
                    update = true;
                }
                if (wildernessLevel > 20 && !PathfinderConfig.isInLevel20Wilderness(node.packedPosition)) {
                    wildernessLevel = 20;
                    update = true;
                }
                if (wildernessLevel > 0 && !PathfinderConfig.isInWilderness(node.packedPosition)) {
                    wildernessLevel = 0;
                    update = true;
                }
                if (update) {
                    config.refreshTeleports(node.packedPosition, wildernessLevel);
                }
            }

            if (targets.contains(node.packedPosition)) {
                bestLastNode = node;
                pathNeedsUpdate = true;
                break;
            }

            for (int target : targets) {
                int distance = WorldPointUtil.distanceBetween(node.packedPosition, target);
                long heuristic = distance + (long) WorldPointUtil.distanceBetween(node.packedPosition, target, 2);
                if (heuristic < bestHeuristic || (heuristic <= bestHeuristic && distance < bestDistance)) {
                    bestLastNode = node;
                    pathNeedsUpdate = true;
                    bestDistance = distance;
                    bestHeuristic = heuristic;
                    cutoffTimeMillis = System.currentTimeMillis() + cutoffDurationMillis;
                }
            }

            if (System.currentTimeMillis() > cutoffTimeMillis) {
                break;
            }

            addNeighbors(node);
        }

        done = !cancelled;

        boundary.clear();
        visited.clear();
        pending.clear();

        stats.end(); // Include cleanup in stats to get the total cost of pathfinding
    }

    public static class PathfinderStats {
        @Getter
        private int nodesChecked = 0, transportsChecked = 0;
        private long startNanos, endNanos;
        private volatile boolean started = false, ended = false;

        public int getTotalNodesChecked() {
            return nodesChecked + transportsChecked;
        }

        public long getElapsedTimeNanos() {
            return endNanos - startNanos;
        }

        private void start() {
            started = true;
            nodesChecked = 0;
            transportsChecked = 0;
            startNanos = System.nanoTime();
        }

        private void end() {
            endNanos = System.nanoTime();
            ended = true;
        }
    }
}

package shortestpath;

import java.util.Map;

import lombok.Getter;

public class TransportVarPlayer {
    @Getter
    private final int id;
    private final int value;
    private final TransportVarCheck check;

    public TransportVarPlayer(int id, int value, TransportVarCheck check) {
        this.id = id;
        this.value = value;
        this.check = check;
    }

    public boolean check(Map<Integer, Integer> values) {
        switch (check) {
            case EQUAL:
                return values.get(id) == value;
            case GREATER:
                return values.get(id) > value;
            case SMALLER:
                return values.get(id) < value;
            case BIT_SET:
                return (values.get(id) & value) > 0;
            case COOLDOWN_MINUTES:
                return ((System.currentTimeMillis() / 60000) - values.get(id)) > value;
        }
        return false;
    }
}

package shortestpath;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum TeleportationItem {
    NONE("None"),
    INVENTORY("Inventory"),
    INVENTORY_NON_CONSUMABLE("Inventory (perm)"),
    INVENTORY_AND_BANK("Inventory and Bank"),
    INVENTORY_AND_BANK_NON_CONSUMABLE("Inventory and Bank (perm)"),
    ALL("All"),
    ALL_NON_CONSUMABLE("All (perm)"),
    ;

    private final String type;

    @Override
    public String toString() {
        return type;
    }

    public static TeleportationItem fromType(String type) {
        for (TeleportationItem teleportationItem : values()) {
            if (teleportationItem.type.equals(type)) {
                return teleportationItem;
            }
        }
        return null;
    }
}

package shortestpath;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;

public class Util {
    public static byte[] readAllBytes(InputStream in) throws IOException {
        ByteArrayOutputStream result = new ByteArrayOutputStream();
        byte[] buffer = new byte[1024];

        while (true) {
            int read = in.read(buffer, 0, buffer.length);

            if (read == -1) {
                return result.toByteArray();
            }

            result.write(buffer, 0, read);
        }
    }

    public static int[] concatenate(int[][] arrays) {
        int n = 0;
        for (int i = 0; i < arrays.length; i++) {
            n += (arrays[i] == null) ? 0 : arrays[i].length;
        }
        if (n == 0) {
            return null;
        }
        int[] array = new int[n];
        int k = 0;
        for (int i = 0; i < arrays.length; i++) {
            if (arrays[i] != null) {
                for (int j = 0; j < arrays[i].length; j++) {
                    array[k++] = arrays[i][j];
                }
            }
        }
        return array;
    }
}

package shortestpath;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum TileStyle {
    TILES("Tiles"),
    LINES("Lines");

    private final String type;

    public static TileStyle fromType(String type) {
        for (TileStyle tileStyle : values()) {
            if (tileStyle.type.equals(type)) {
                return tileStyle;
            }
        }
        return null;
    }
}

package shortestpath;

import net.runelite.api.gameval.ItemID;
import lombok.Getter;

public enum ItemVariations {
    AIR_RUNE(ItemID.AIRRUNE,
        ItemID.MISTRUNE,
        ItemID.DUSTRUNE,
        ItemID.SMOKERUNE),
    ARDOUGNE_CLOAK(ItemID.ARDY_CAPE_EASY,
        ItemID.ARDY_CAPE_MEDIUM,
        ItemID.ARDY_CAPE_HARD,
        ItemID.ARDY_CAPE_ELITE,
        ItemID.SKILLCAPE_MAX_ARDY),
    ASTRAL_RUNE(ItemID.ASTRALRUNE),
    AXE(ItemID.BRONZE_AXE,
        ItemID.IRON_AXE,
        ItemID.STEEL_AXE,
        ItemID.BLACK_AXE,
        ItemID.MITHRIL_AXE,
        ItemID.ADAMANT_AXE,
        ItemID.RUNE_AXE,
        ItemID.DRAGON_AXE,
        ItemID.INFERNAL_AXE,
        ItemID._3A_AXE,
        ItemID.CRYSTAL_AXE),
    BANANA(ItemID.BANANA),
    BLOOD_RUNE(ItemID.BLOODRUNE),
    BROWN_APRON(ItemID.BROWN_APRON,
        ItemID.GOLDEN_APRON,
        ItemID.SKILLCAPE_CRAFTING,
        ItemID.SKILLCAPE_CRAFTING_TRIMMED,
        ItemID.SKILLCAPE_CRAFTING_HOOD),
    BRYOPHYTAS_STAFF(ItemID.NATURE_STAFF_CHARGED),
    CAPESLOT(ItemID.CASTLEWARS_HOOD_SARADOMIN_PRIZE, // TODO: also use slot or item category
        ItemID.CASTLEWARS_HOOD_ZAMORAK_PRIZE),
    CLIMBING_BOOTS(ItemID.DEATH_CLIMBINGBOOTS,
        ItemID.CLIMBING_BOOTS_G),
    COINS(ItemID.COINS),
    CROSSBOW(ItemID.CROSSBOW,
        ItemID.PHOENIX_CROSSBOW,
        ItemID.DTTD_BONE_CROSSBOW,
        ItemID.HUNTING_CROSSBOW,
        ItemID.XBOWS_CROSSBOW_BRONZE,
        ItemID.XBOWS_CROSSBOW_IRON,
        ItemID.XBOWS_CROSSBOW_STEEL,
        ItemID.XBOWS_CROSSBOW_MITHRIL,
        ItemID.XBOWS_CROSSBOW_ADAMANTITE,
        ItemID.XBOWS_CROSSBOW_RUNITE,
        ItemID.XBOWS_CROSSBOW_DRAGON,
        ItemID.DRAGONHUNTER_XBOW,
        ItemID.BARROWS_KARIL_WEAPON,
        ItemID.BARROWS_KARIL_WEAPON_BROKEN,
        ItemID.BARROWS_KARIL_WEAPON_25,
        ItemID.BARROWS_KARIL_WEAPON_50,
        ItemID.BARROWS_KARIL_WEAPON_75,
        ItemID.BARROWS_KARIL_WEAPON_100,
        ItemID.ACB,
        ItemID.ZARYTE_XBOW),
    DUST_BATTLESTAFF(ItemID.DUST_BATTLESTAFF,
        ItemID.MYSTIC_DUST_BATTLESTAFF),
    DUST_RUNE(ItemID.DUSTRUNE),
    DUSTY_KEY(ItemID.DUSTY_KEY),
    EARTH_RUNE(ItemID.EARTHRUNE,
        ItemID.DUSTRUNE,
        ItemID.MUDRUNE,
        ItemID.LAVARUNE),
    ECTO_TOKEN(ItemID.ECTOTOKEN),
    FIRE_RUNE(ItemID.FIRERUNE,
        ItemID.SMOKERUNE,
        ItemID.STEAMRUNE,
        ItemID.LAVARUNE),
    GAMES_NECKLACE(ItemID.NECKLACE_OF_MINIGAMES_8,
        ItemID.NECKLACE_OF_MINIGAMES_7,
        ItemID.NECKLACE_OF_MINIGAMES_6,
        ItemID.NECKLACE_OF_MINIGAMES_5,
        ItemID.NECKLACE_OF_MINIGAMES_4,
        ItemID.NECKLACE_OF_MINIGAMES_3,
        ItemID.NECKLACE_OF_MINIGAMES_2,
        ItemID.NECKLACE_OF_MINIGAMES_1),
    GLOWING_FUNGUS(ItemID.GLOWING_FUNGUS),
    HEADSLOT(ItemID.CASTLEWARS_CLOAK_SARADOMIN_PRIZE, // TODO: also use slot or item category
        ItemID.CASTLEWARS_CLOAK_ZAMORAK_PRIZE),
    LAVA_BATTLESTAFF(ItemID.LAVA_BATTLESTAFF,
        ItemID.MYSTIC_LAVA_STAFF),
    LAVA_RUNE(ItemID.LAVARUNE),
    LAW_RUNE(ItemID.LAWRUNE),
    MAX_CAPE(ItemID.SKILLCAPE_MAX,
        ItemID.SKILLCAPE_MAX_WORN,
        ItemID.SKILLCAPE_MAX_FIRECAPE,
        ItemID.SKILLCAPE_MAX_FIRECAPE_DUMMY,
        ItemID.SKILLCAPE_MAX_FIRECAPE_TROUVER,
        ItemID.SKILLCAPE_MAX_SARADOMIN,
        ItemID.SKILLCAPE_MAX_ZAMORAK,
        ItemID.SKILLCAPE_MAX_GUTHIX,
        ItemID.SKILLCAPE_MAX_ANMA,
        ItemID.SKILLCAPE_MAX_ARDY,
        ItemID.SKILLCAPE_MAX_INFERNALCAPE,
        ItemID.SKILLCAPE_MAX_INFERNALCAPE_DUMMY,
        ItemID.SKILLCAPE_MAX_INFERNALCAPE_TROUVER,
        ItemID.SKILLCAPE_MAX_SARADOMIN2,
        ItemID.SKILLCAPE_MAX_SARADOMIN2_TROUVER,
        ItemID.SKILLCAPE_MAX_ZAMORAK2,
        ItemID.SKILLCAPE_MAX_ZAMORAK2_TROUVER,
        ItemID.SKILLCAPE_MAX_GUTHIX2,
        ItemID.SKILLCAPE_MAX_GUTHIX2_TROUVER,
        ItemID.SKILLCAPE_MAX_ASSEMBLER,
        ItemID.SKILLCAPE_MAX_ASSEMBLER_TROUVER,
        ItemID.SKILLCAPE_MAX_MYTHICAL,
        ItemID.SKILLCAPE_MAX_ASSEMBLER_MASORI,
        ItemID.SKILLCAPE_MAX_ASSEMBLER_MASORI_TROUVER,
        ItemID.SKILLCAPE_MAX_DIZANAS,
        ItemID.SKILLCAPE_MAX_DIZANAS_TROUVER),
    MAX_HOOD(ItemID.SKILLCAPE_MAX_HOOD,
        ItemID.SKILLCAPE_MAX_HOOD_FIRECAPE,
        ItemID.SKILLCAPE_MAX_HOOD_SARADOMIN,
        ItemID.SKILLCAPE_MAX_HOOD_ZAMORAK,
        ItemID.SKILLCAPE_MAX_HOOD_GUTHIX,
        ItemID.SKILLCAPE_MAX_HOOD_ANMA,
        ItemID.SKILLCAPE_MAX_HOOD_ARDY,
        ItemID.SKILLCAPE_MAX_HOOD_INFERNALCAPE,
        ItemID.SKILLCAPE_MAX_HOOD_SARADOMIN2,
        ItemID.SKILLCAPE_MAX_HOOD_ZAMORAK2,
        ItemID.SKILLCAPE_MAX_HOOD_GUTHIX2,
        ItemID.SKILLCAPE_MAX_HOOD_ASSEMBLER,
        ItemID.SKILLCAPE_MAX_HOOD_MYTHICAL,
        ItemID.SKILLCAPE_MAX_HOOD_ASSEMBLER_MASORI,
        ItemID.SKILLCAPE_MAX_HOOD_DIZANAS),
    MAZE_KEY(ItemID.MELZARKEY),
    MIND_RUNE(ItemID.MINDRUNE),
    MIST_BATTLESTAFF(ItemID.MIST_BATTLESTAFF,
        ItemID.MYSTIC_MIST_BATTLESTAFF),
    MIST_RUNE(ItemID.MISTRUNE),
    MITH_GRAPPLE(ItemID.XBOWS_GRAPPLE_TIP_BOLT_MITHRIL_ROPE),
    MUD_BATTLESTAFF(ItemID.MUD_BATTLESTAFF,
        ItemID.MYSTIC_MUD_STAFF),
    MUD_RUNE(ItemID.MUDRUNE),
    MYSTIC_DUST_STAFF(ItemID.MYSTIC_DUST_BATTLESTAFF),
    MYSTIC_LAVA_STAFF(ItemID.MYSTIC_LAVA_STAFF),
    MYSTIC_MIST_STAFF(ItemID.MYSTIC_MIST_BATTLESTAFF),
    MYSTIC_MUD_STAFF(ItemID.MYSTIC_MUD_STAFF),
    MYSTIC_SMOKE_STAFF(ItemID.MYSTIC_SMOKE_BATTLESTAFF),
    MYSTIC_STEAM_STAFF(ItemID.MYSTIC_STEAM_BATTLESTAFF),
    NATURE_RUNE(ItemID.NATURERUNE),
    ROPE(ItemID.ROPE),
    SHANTAY_PASS(ItemID.SHANTAY_PASS),
    SKAVID_MAP(ItemID.SKAVIDMAP),
    SMOKE_BATTLESTAFF(ItemID.SMOKE_BATTLESTAFF,
        ItemID.MYSTIC_SMOKE_BATTLESTAFF),
    SMOKE_RUNE(ItemID.SMOKERUNE),
    SOUL_RUNE(ItemID.SOULRUNE),
    STAFF_OF_AIR(ItemID.STAFF_OF_AIR,
        ItemID.AIR_BATTLESTAFF,
        ItemID.MIST_BATTLESTAFF,
        ItemID.DUST_BATTLESTAFF,
        ItemID.SMOKE_BATTLESTAFF,
        ItemID.MYSTIC_MIST_BATTLESTAFF,
        ItemID.MYSTIC_DUST_BATTLESTAFF,
        ItemID.MYSTIC_SMOKE_BATTLESTAFF),
    STAFF_OF_EARTH(ItemID.STAFF_OF_EARTH,
        ItemID.EARTH_BATTLESTAFF,
        ItemID.DUST_BATTLESTAFF,
        ItemID.MUD_BATTLESTAFF,
        ItemID.LAVA_BATTLESTAFF,
        ItemID.MYSTIC_DUST_BATTLESTAFF,
        ItemID.MYSTIC_MUD_STAFF,
        ItemID.MYSTIC_LAVA_STAFF),
    STAFF_OF_FIRE(ItemID.STAFF_OF_FIRE,
        ItemID.FIRE_BATTLESTAFF,
        ItemID.SMOKE_BATTLESTAFF,
        ItemID.STEAM_BATTLESTAFF,
        ItemID.LAVA_BATTLESTAFF,
        ItemID.MYSTIC_SMOKE_BATTLESTAFF,
        ItemID.MYSTIC_STEAM_BATTLESTAFF,
        ItemID.MYSTIC_LAVA_STAFF),
    STAFF_OF_WATER(ItemID.STAFF_OF_WATER,
        ItemID.WATER_BATTLESTAFF,
        ItemID.MIST_BATTLESTAFF,
        ItemID.MUD_BATTLESTAFF,
        ItemID.STEAM_BATTLESTAFF,
        ItemID.MYSTIC_MIST_BATTLESTAFF,
        ItemID.MYSTIC_MUD_STAFF,
        ItemID.MYSTIC_STEAM_BATTLESTAFF),
    STEAM_BATTLESTAFF(ItemID.STEAM_BATTLESTAFF,
        ItemID.MYSTIC_STEAM_BATTLESTAFF),
    STEAM_RUNE(ItemID.STEAMRUNE),
    TOME_OF_EARTH(ItemID.TOME_OF_EARTH),    
    TOME_OF_FIRE(ItemID.TOME_OF_FIRE),
    TOME_OF_WATER(ItemID.TOME_OF_WATER),
    WATER_RUNE(ItemID.WATERRUNE,
        ItemID.MISTRUNE,
        ItemID.MUDRUNE,
        ItemID.STEAMRUNE),
    ;

    @Getter
    private final int[] ids;

    ItemVariations(int... ids) {
        this.ids = ids;
    }

    public static int[] staves(ItemVariations itemVariation) {
        if (itemVariation == null) {
            return null;
        }
        switch (itemVariation) {
            case AIR_RUNE:
                return STAFF_OF_AIR.ids;
            case DUST_RUNE:
                return DUST_BATTLESTAFF.ids;
            case EARTH_RUNE:
                return STAFF_OF_EARTH.ids;
            case FIRE_RUNE:
                return STAFF_OF_FIRE.ids;
            case LAVA_RUNE:
                return LAVA_BATTLESTAFF.ids;
            case MIST_RUNE:
                return MIST_BATTLESTAFF.ids;
            case MUD_RUNE:
                return MUD_BATTLESTAFF.ids;
            case NATURE_RUNE:
                return BRYOPHYTAS_STAFF.ids;
            case SMOKE_RUNE:
                return SMOKE_BATTLESTAFF.ids;
            case STEAM_RUNE:
                return STEAM_BATTLESTAFF.ids;
            case WATER_RUNE:
                return STAFF_OF_WATER.ids;
            default:
                return null;
        }
    }

    public static int[] offhands(ItemVariations itemVariation) {
        if (itemVariation == null) {
            return null;
        }
        switch (itemVariation) {
            case EARTH_RUNE:
                return TOME_OF_EARTH.ids;
            case FIRE_RUNE:
                return TOME_OF_FIRE.ids;
            case WATER_RUNE:
                return TOME_OF_WATER.ids;
            default:
                return null;
        }
    }

    public static ItemVariations fromName(String name) {
        for (ItemVariations itemVariations : ItemVariations.values()) {
            if (itemVariations.name().equals(name)) {
                return itemVariations;
            }
        }
        return null;
    }
}
package shortestpath;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import lombok.Getter;
import net.runelite.api.Quest;
import net.runelite.api.Skill;
import lombok.extern.slf4j.Slf4j;

/**
 * This class represents a travel point between two WorldPoints.
 */
@Slf4j
public class Transport {
    public static final int UNDEFINED_ORIGIN = WorldPointUtil.UNDEFINED;
    public static final int UNDEFINED_DESTINATION = WorldPointUtil.UNDEFINED;
    /** A location placeholder different from null to use for permutation transports */
    private static final int LOCATION_PERMUTATION = WorldPointUtil.packWorldPoint(-1, -1, 1);
    private static final String DELIM_SPACE = " ";
    private static final String DELIM_MULTI = ";";
    private static final String DELIM_STATE = "=";
    private static final String DELIM_AND = "&";
    private static final String DELIM_OR = "|";

    /** The starting point of this transport */
    @Getter
    private int origin = UNDEFINED_ORIGIN;

    /** The ending point of this transport */
    @Getter
    private int destination = UNDEFINED_DESTINATION;

    /** The skill levels required to use this transport */
    @Getter
    private final int[] skillLevels = new int[Skill.values().length];

    /** The quests required to use this transport */
    @Getter
    private Set<Quest> quests = new HashSet<>();

    /** The item requirements to use this transport */
    @Getter
    private TransportItems itemRequirements;

    /** The type of transport */
    @Getter
    private TransportType type;

    /** The travel waiting time in number of ticks */
    @Getter
    private int duration;

    /** Info to display for this transport. For spirit trees, fairy rings,
     * and others, this is the destination option to pick. */
    @Getter
    private String displayInfo;

    /** If this is an item transport, this tracks if it is consumable (as opposed to having infinite uses) */
    @Getter
    private boolean isConsumable = false;

    /** The maximum wilderness level that the transport can be used in */
    @Getter
    private int maxWildernessLevel = -1;

    /** Any varbits to check for the transport to be valid. All must pass for a transport to be valid */
    @Getter
    private final Set<TransportVarbit> varbits = new HashSet<>();

    /** Any varplayers to check for the transport to be valid. All must pass for a transport to be valid */
    @Getter
    private final Set<TransportVarPlayer> varPlayers = new HashSet<>();

    /** Creates a new transport from an origin-only transport
     * and a destination-only transport, and merges requirements */
    Transport(Transport origin, Transport destination) {
        this.origin = origin.origin;
        this.destination = destination.destination;

        for (int i = 0; i < skillLevels.length; i++) {
            this.skillLevels[i] = Math.max(
                origin.skillLevels[i],
                destination.skillLevels[i]);
        }

        this.quests.addAll(origin.quests);
        this.quests.addAll(destination.quests);

        this.itemRequirements = destination.itemRequirements;

        this.type = origin.type;

        this.duration = Math.max(
            origin.duration,
            destination.duration);

        this.displayInfo = destination.displayInfo;

        this.isConsumable |= origin.isConsumable;
        this.isConsumable |= destination.isConsumable;

        this.maxWildernessLevel = Math.max(
            origin.maxWildernessLevel,
            destination.maxWildernessLevel);

        this.varbits.addAll(origin.varbits);
        this.varbits.addAll(destination.varbits);

        this.varPlayers.addAll(origin.varPlayers);
        this.varPlayers.addAll(destination.varPlayers);
    }

    Transport(Map<String, String> fieldMap, TransportType transportType) {
        String value;

        // If the origin field is null the transport is a teleportation item or spell
        // If the origin field has 3 elements it is a coordinate of a transport
        // Otherwise it is a transport that needs to be expanded into all permutations (e.g. fairy ring)
        if ((value = fieldMap.get("Origin")) != null) {
            String[] originArray = value.split(DELIM_SPACE);
            origin = originArray.length == 3 ? WorldPointUtil.packWorldPoint(
                Integer.parseInt(originArray[0]),
                Integer.parseInt(originArray[1]),
                Integer.parseInt(originArray[2])) : LOCATION_PERMUTATION;
        }

        if ((value = fieldMap.get("Destination")) != null) {
            String[] destinationArray = value.split(DELIM_SPACE);
            destination = destinationArray.length == 3 ? WorldPointUtil.packWorldPoint(
                Integer.parseInt(destinationArray[0]),
                Integer.parseInt(destinationArray[1]),
                Integer.parseInt(destinationArray[2])) : LOCATION_PERMUTATION;
        }

        if ((value = fieldMap.get("Skills")) != null) {
            String[] skillRequirements = value.split(DELIM_MULTI);

            try {
                for (String requirement : skillRequirements) {
                    if (requirement.isEmpty()) {
                        continue;
                    }
                    String[] levelAndSkill = requirement.split(DELIM_SPACE);
                    assert levelAndSkill.length == 2 : "Invalid level and skill: '" + requirement + "'";

                    int level = Integer.parseInt(levelAndSkill[0]);
                    String skillName = levelAndSkill[1];

                    Skill[] skills = Skill.values();
                    for (int i = 0; i < skills.length; i++) {
                        if (skills[i].getName().equals(skillName)) {
                            skillLevels[i] = level;
                            break;
                        }
                    }
                }
            } catch (NumberFormatException e) {
                log.error("Invalid level and skill: " + value);
            }
        }

        if ((value = fieldMap.get("Items")) != null && !value.isEmpty()) {
            value = value.replace(DELIM_SPACE, "");
            value = value.replace(DELIM_AND + DELIM_AND, DELIM_AND);
            value = value.replace(DELIM_OR + DELIM_OR, DELIM_OR);
            value = value.toUpperCase();
            String[] itemVariationAndQuantityList = value.split(DELIM_AND);
            try {
                int n = itemVariationAndQuantityList.length;
                int[][] items = new int[n][];
                int[][] staves = new int[n][];
                int[][] offhands = new int[n][];
                int[] quantities = new int[n];
                for (int i = 0; i < n; i++) {
                    int maxQuantity = -1;
                    String[] itemVariationsAndQuantities = itemVariationAndQuantityList[i].split("\\" + DELIM_OR);
                    int[][] multipleItems = new int[itemVariationsAndQuantities.length][];
                    int[][] multipleStaves = new int[itemVariationsAndQuantities.length][];
                    int[][] multipleOffhands = new int[itemVariationsAndQuantities.length][];
                    for (int k = 0; k < itemVariationsAndQuantities.length; k++) {
                        String[] itemVariationAndQuantity = itemVariationsAndQuantities[k].split(DELIM_STATE);
                        if (itemVariationAndQuantity.length == 2) {
                            ItemVariations itemVariations = ItemVariations.fromName(itemVariationAndQuantity[0]);
                            multipleItems[k] = itemVariations == null ? new int[]{Integer.parseInt(itemVariationAndQuantity[0])} : itemVariations.getIds();
                            multipleStaves[k] = ItemVariations.staves(itemVariations);
                            multipleOffhands[k] = ItemVariations.offhands(itemVariations);
                            maxQuantity = Math.max(maxQuantity, Integer.parseInt(itemVariationAndQuantity[1]));
                        } else {
                            throw new NumberFormatException(itemVariationAndQuantityList[i]);
                        }
                    }
                    items[i] = Util.concatenate(multipleItems);
                    staves[i] = Util.concatenate(multipleStaves);
                    offhands[i] = Util.concatenate(multipleOffhands);
                    quantities[i] = maxQuantity;
                }
                itemRequirements = new TransportItems(items, staves, offhands, quantities);
            } catch (NumberFormatException e) {
                log.error("Invalid item or quantity: " + value);
            }
        }

        if ((value = fieldMap.get("Quests")) != null) {
            this.quests = findQuests(value);
        }

        if ((value = fieldMap.get("Duration")) != null && !value.isEmpty()) {
            try {
                this.duration = Integer.parseInt(value);
            } catch (NumberFormatException e) {
                log.error("Invalid tick duration: " + value);
            }
        }
        if (TransportType.isTeleport(transportType)) {
            // Teleports should always have a non-zero wait,
            // so the pathfinder doesn't calculate the cost by distance
            this.duration = Math.max(this.duration, 1);
        }

        if ((value = fieldMap.get("Display info")) != null) {
            this.displayInfo = value;
        }

        if ((value = fieldMap.get("Consumable")) != null) {
            this.isConsumable = "T".equals(value) || "yes".equals(value.toLowerCase());
        }

        if ((value = fieldMap.get("Wilderness level")) != null && !value.isEmpty()) {
            try {
                this.maxWildernessLevel =  Integer.parseInt(value);
            } catch (NumberFormatException e) {
                log.error("Invalid wilderness level: " + value);
            }
        }

        if ((value = fieldMap.get("Varbits")) != null) {
            try {
                for (String varbitRequirement : value.split(DELIM_MULTI)) {
                    if (varbitRequirement.isEmpty()) {
                        continue;
                    }
                    String[] varbitParts = null;
                    for (TransportVarCheck check : TransportVarCheck.values()) {
                        varbitParts = varbitRequirement.split(check.getCode());
                        if (varbitParts.length == 2) {
                            int varbitId = Integer.parseInt(varbitParts[0]);
                            int varbitValue = Integer.parseInt(varbitParts[1]);
                            varbits.add(new TransportVarbit(varbitId, varbitValue, check));
                            break;
                        }
                    }
                    assert varbitParts.length == 2 : "Invalid varbit id and value: '" + varbitRequirement + "'";
                }
            } catch (NumberFormatException e) {
                log.error("Invalid varbit id and value: " + value);
            }
        }

        if ((value = fieldMap.get("VarPlayers")) != null) {
            try {
                for (String varPlayerRequirement : value.split(DELIM_MULTI)) {
                    if (varPlayerRequirement.isEmpty()) {
                        continue;
                    }
                    String[] varPlayerParts = null;
                    for (TransportVarCheck check : TransportVarCheck.values()) {
                        varPlayerParts = varPlayerRequirement.split(check.getCode());
                        if (varPlayerParts.length == 2) {
                            int varPlayerId = Integer.parseInt(varPlayerParts[0]);
                            int varPlayerValue = Integer.parseInt(varPlayerParts[1]);
                            varPlayers.add(new TransportVarPlayer(varPlayerId, varPlayerValue, check));
                            break;
                        }
                    }
                    assert varPlayerParts.length == 2 : "Invalid VarPlayer id and value: '" + varPlayerRequirement + "'";
                }
            } catch (NumberFormatException e) {
                log.error("Invalid VarPlayer id and value: " + value);
            }
        }

        this.type = transportType;
        if (TransportType.AGILITY_SHORTCUT.equals(transportType) &&
            (getRequiredLevel(Skill.RANGED) > 1 || getRequiredLevel(Skill.STRENGTH) > 1)) {
            this.type = TransportType.GRAPPLE_SHORTCUT;
        }
    }

    @Override
    public String toString() {
        return ("(" +
            WorldPointUtil.unpackWorldX(origin) + ", " +
            WorldPointUtil.unpackWorldY(origin) + ", " +
            WorldPointUtil.unpackWorldPlane(origin) + ") to ("+
            WorldPointUtil.unpackWorldX(destination) + ", " +
            WorldPointUtil.unpackWorldY(destination) + ", " +
            WorldPointUtil.unpackWorldPlane(destination) + ")");
    }

    /** The skill level required to use this transport */
    private int getRequiredLevel(Skill skill) {
        return skillLevels[skill.ordinal()];
    }

    /** Whether the transport has one or more quest requirements */
    public boolean isQuestLocked() {
        return !quests.isEmpty();
    }

    private static Set<Quest> findQuests(String questNamesCombined) {
        String[] questNames = questNamesCombined.split(";");
        Set<Quest> quests = new HashSet<>();
        for (String questName : questNames) {
            for (Quest quest : Quest.values()) {
                if (quest.getName().equals(questName)) {
                    quests.add(quest);
                    break;
                }
            }
        }
        return quests;
    }

    private static void addTransports(Map<Integer, Set<Transport>> transports, String path, TransportType transportType) {
        addTransports(transports, path, transportType, 0);
    }

    private static void addTransports(Map<Integer, Set<Transport>> transports, String path, TransportType transportType, int radiusThreshold) {
        final String DELIM_COLUMN = "\t";
        final String PREFIX_COMMENT = "#";

        try {
            String s = new String(Util.readAllBytes(ShortestPathPlugin.class.getResourceAsStream(path)), StandardCharsets.UTF_8);
            Scanner scanner = new Scanner(s);

            // Header line is the first line in the file and will start with either '#' or '# '
            String headerLine = scanner.nextLine();
            headerLine = headerLine.startsWith(PREFIX_COMMENT + " ") ? headerLine.replace(PREFIX_COMMENT + " ", PREFIX_COMMENT) : headerLine;
            headerLine = headerLine.startsWith(PREFIX_COMMENT) ? headerLine.replace(PREFIX_COMMENT, "") : headerLine;
            String[] headers = headerLine.split(DELIM_COLUMN);

            Set<Transport> newTransports = new HashSet<>();

            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();

                if (line.startsWith(PREFIX_COMMENT) || line.isBlank()) {
                    continue;
                }

                String[] fields = line.split(DELIM_COLUMN);
                Map<String, String> fieldMap = new HashMap<>();
                for (int i = 0; i < headers.length; i++) {
                    if (i < fields.length) {
                        fieldMap.put(headers[i], fields[i]);
                    }
                }

                Transport transport = new Transport(fieldMap, transportType);
                newTransports.add(transport);

            }
            scanner.close();

            /*
             * A transport with origin A and destination B is one-way and must
             * be duplicated as origin B and destination A to become two-way.
             * Example: key-locked doors
             * 
             * A transport with origin A and a missing destination is one-way,
             * but can go from origin A to all destinations with a missing origin.
             * Example: fairy ring AIQ -> <blank>
             * 
             * A transport with a missing origin and destination B is one-way,
             * but can go from all origins with a missing destination to destination B.
             * Example: fairy ring <blank> -> AIQ
             * 
             * Identical transports from origin A to destination A are skipped, and
             * non-identical transports from origin A to destination A can be skipped
             * by specifying a radius threshold to ignore almost identical coordinates.
             * Example: fairy ring AIQ -> AIQ
             */
            Set<Transport> transportOrigins = new HashSet<>();
            Set<Transport> transportDestinations = new HashSet<>();
            for (Transport transport : newTransports) {
                int origin = transport.getOrigin();
                int destination = transport.getDestination();
                // Logic to determine ordinary transport vs teleport vs permutation (e.g. fairy ring)
                if ((origin == UNDEFINED_ORIGIN && destination == UNDEFINED_DESTINATION)
                    || (origin == LOCATION_PERMUTATION && destination == LOCATION_PERMUTATION)) {
                    continue;
                } else if (origin != LOCATION_PERMUTATION && origin != UNDEFINED_ORIGIN
                    && destination == LOCATION_PERMUTATION) {
                    transportOrigins.add(transport);
                } else if (origin == LOCATION_PERMUTATION
                    && destination != LOCATION_PERMUTATION && destination != UNDEFINED_DESTINATION) {
                    transportDestinations.add(transport);
                }
                if (origin != LOCATION_PERMUTATION
                    && destination != UNDEFINED_DESTINATION && destination != LOCATION_PERMUTATION
                    && (origin == UNDEFINED_ORIGIN || origin != destination)) {
                    transports.computeIfAbsent(origin, k -> new HashSet<>()).add(transport);
                }
            }
            for (Transport origin : transportOrigins) {
                for (Transport destination : transportDestinations) {
                    // The radius threshold prevents transport permutations from including (almost) same origin and destination
                    if (WorldPointUtil.distanceBetween2D(origin.getOrigin(), destination.getDestination()) > radiusThreshold) {
                        transports.computeIfAbsent(origin.getOrigin(), k -> new HashSet<>())
                            .add(new Transport(origin, destination));
                    }
                }
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public static HashMap<Integer, Set<Transport>> loadAllFromResources() {
        HashMap<Integer, Set<Transport>> transports = new HashMap<>();
        addTransports(transports, "/transports/transports.tsv", TransportType.TRANSPORT);
        addTransports(transports, "/transports/agility_shortcuts.tsv", TransportType.AGILITY_SHORTCUT);
        addTransports(transports, "/transports/boats.tsv", TransportType.BOAT);
        addTransports(transports, "/transports/canoes.tsv", TransportType.CANOE);
        addTransports(transports, "/transports/charter_ships.tsv", TransportType.CHARTER_SHIP);
        addTransports(transports, "/transports/ships.tsv", TransportType.SHIP);
        addTransports(transports, "/transports/fairy_rings.tsv", TransportType.FAIRY_RING);
        addTransports(transports, "/transports/gnome_gliders.tsv", TransportType.GNOME_GLIDER, 6);
        addTransports(transports, "/transports/hot_air_balloons.tsv", TransportType.HOT_AIR_BALLOON, 7);
        addTransports(transports, "/transports/minecarts.tsv", TransportType.MINECART);
        addTransports(transports, "/transports/quetzals.tsv", TransportType.QUETZAL);
        addTransports(transports, "/transports/spirit_trees.tsv", TransportType.SPIRIT_TREE, 5);
        addTransports(transports, "/transports/teleportation_items.tsv", TransportType.TELEPORTATION_ITEM);
        addTransports(transports, "/transports/teleportation_boxes.tsv", TransportType.TELEPORTATION_BOX);
        addTransports(transports, "/transports/teleportation_levers.tsv", TransportType.TELEPORTATION_LEVER);
        addTransports(transports, "/transports/teleportation_minigames.tsv", TransportType.TELEPORTATION_MINIGAME);
        addTransports(transports, "/transports/teleportation_portals.tsv", TransportType.TELEPORTATION_PORTAL);
        addTransports(transports, "/transports/teleportation_spells.tsv", TransportType.TELEPORTATION_SPELL);
        addTransports(transports, "/transports/wilderness_obelisks.tsv", TransportType.WILDERNESS_OBELISK);
        return transports;
    }
}

package shortestpath;

import com.google.inject.Inject;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.geom.Line2D;
import java.awt.geom.Rectangle2D;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.Tile;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import shortestpath.pathfinder.CollisionMap;

public class PathTileOverlay extends Overlay {
    private final Client client;
    private final ShortestPathPlugin plugin;
    private static final int TRANSPORT_LABEL_GAP = 3;

    @Inject
    public PathTileOverlay(Client client, ShortestPathPlugin plugin) {
        this.client = client;
        this.plugin = plugin;
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(Overlay.PRIORITY_LOW);
        setLayer(OverlayLayer.ABOVE_SCENE);
    }

    private void renderTransports(Graphics2D graphics) {
        for (int a : plugin.getTransports().keySet()) {
            if (a == Transport.UNDEFINED_ORIGIN) {
                continue; // skip teleports
            }

            boolean drawStart = false;

            Point ca = tileCenter(a);

            if (ca == null) {
                continue;
            }

            StringBuilder s = new StringBuilder();
            for (Transport b : plugin.getTransports().getOrDefault(a, new HashSet<>())) {
                if (b == null || TransportType.isTeleport(b.getType())) {
                    continue; // skip teleports
                }
                for (int destination : WorldPointUtil.toLocalInstance(client, b.getDestination())) {
                    if (destination == Transport.UNDEFINED_DESTINATION) {
                        continue;
                    }
                    Point cb = tileCenter(destination);
                    if (cb != null) {
                        graphics.drawLine(ca.getX(), ca.getY(), cb.getX(), cb.getY());
                        drawStart = true;
                    }
                    if (WorldPointUtil.unpackWorldPlane(destination) > WorldPointUtil.unpackWorldPlane(a)) {
                        s.append("+");
                    } else if (WorldPointUtil.unpackWorldPlane(destination) < WorldPointUtil.unpackWorldPlane(a)) {
                        s.append("-");
                    } else {
                        s.append("=");
                    }
                }
            }

            if (drawStart) {
                drawTile(graphics, a, plugin.colourTransports, -1, true);
            }

            graphics.setColor(Color.WHITE);
            graphics.drawString(s.toString(), ca.getX(), ca.getY());
        }
    }

    private void renderCollisionMap(Graphics2D graphics) {
        CollisionMap map = plugin.getMap();
        for (Tile[] row : client.getScene().getTiles()[client.getPlane()]) {
            for (Tile tile : row) {
                if (tile == null) {
                    continue;
                }

                Polygon tilePolygon = Perspective.getCanvasTilePoly(client, tile.getLocalLocation());

                if (tilePolygon == null) {
                    continue;
                }

                int location = WorldPointUtil.fromLocalInstance(client, tile.getLocalLocation());
                int x = WorldPointUtil.unpackWorldX(location);
                int y = WorldPointUtil.unpackWorldY(location);
                int z = WorldPointUtil.unpackWorldPlane(location);

                String s = (!map.n(x, y, z) ? "n" : "") +
                        (!map.s(x, y, z) ? "s" : "") +
                        (!map.e(x, y, z) ? "e" : "") +
                        (!map.w(x, y, z) ? "w" : "");

                if (map.isBlocked(x, y, z)) {
                    graphics.setColor(plugin.colourCollisionMap);
                    graphics.fill(tilePolygon);
                }
                if (!s.isEmpty() && !s.equals("nsew")) {
                    graphics.setColor(Color.WHITE);
                    int stringX = (int) (tilePolygon.getBounds().getCenterX() - graphics.getFontMetrics().getStringBounds(s, graphics).getWidth() / 2);
                    int stringY = (int) tilePolygon.getBounds().getCenterY();
                    graphics.drawString(s, stringX, stringY);
                }
            }
        }
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (plugin.drawTransports) {
            renderTransports(graphics);
        }

        if (plugin.drawCollisionMap) {
            renderCollisionMap(graphics);
        }

        if (plugin.drawTiles && plugin.getPathfinder() != null && plugin.getPathfinder().getPath() != null) {
            Color colorCalculating = new Color(
                plugin.colourPathCalculating.getRed(),
                plugin.colourPathCalculating.getGreen(),
                plugin.colourPathCalculating.getBlue(),
                plugin.colourPathCalculating.getAlpha() / 2);
            Color color = plugin.getPathfinder().isDone()
                ? new Color(
                    plugin.colourPath.getRed(),
                    plugin.colourPath.getGreen(),
                    plugin.colourPath.getBlue(),
                    plugin.colourPath.getAlpha() / 2)
                : colorCalculating;

            List<Integer> path = plugin.getPathfinder().getPath();
            int counter = 0;
            if (TileStyle.LINES.equals(plugin.pathStyle)) {
                for (int i = 1; i < path.size(); i++) {
                    drawLine(graphics, path.get(i - 1), path.get(i), color, 1 + counter++);
                    drawTransportInfo(graphics, path.get(i - 1), path.get(i));
                }
            } else {
                boolean showTiles = TileStyle.TILES.equals(plugin.pathStyle);
                for (int i = 0; i < path.size(); i++) {
                    drawTile(graphics, path.get(i), color, counter++, showTiles);
                    drawTransportInfo(graphics, path.get(i), (i + 1 == path.size()) ? WorldPointUtil.UNDEFINED : path.get(i + 1));
                }
                for (int target : plugin.getPathfinder().getTargets()) {
                    if (path.size() > 0 && target != path.get(path.size() - 1)) {
                        drawTile(graphics, target, colorCalculating, -1, showTiles);
                    }
                }
            }
        }

        return null;
    }

    private Point tileCenter(int b) {
        if (b == WorldPointUtil.UNDEFINED || client == null) {
            return null;
        }

        if (WorldPointUtil.unpackWorldPlane(b) != client.getPlane()) {
            return null;
        }

        LocalPoint lp = WorldPointUtil.toLocalPoint(client, b);
        if (lp == null) {
            return null;
        }

        Polygon poly = Perspective.getCanvasTilePoly(client, lp);
        if (poly == null) {
            return null;
        }

        int cx = poly.getBounds().x + poly.getBounds().width / 2;
        int cy = poly.getBounds().y + poly.getBounds().height / 2;
        return new Point(cx, cy);
    }

    private void drawTile(Graphics2D graphics, int location, Color color, int counter, boolean draw) {
        if (client == null) {
            return;
        }

        for (int point : WorldPointUtil.toLocalInstance(client, location)) {
            if (point == WorldPointUtil.UNDEFINED) {
                continue;
            }

            LocalPoint lp = WorldPointUtil.toLocalPoint(client, point);
            if (lp == null) {
                continue;
            }

            Polygon poly = Perspective.getCanvasTilePoly(client, lp);
            if (poly == null) {
                continue;
            }

            if (draw) {
                graphics.setColor(color);
                graphics.fill(poly);
            }

            drawCounter(graphics, poly.getBounds().getCenterX(), poly.getBounds().getCenterY(), counter);
        }
    }

    private void drawLine(Graphics2D graphics, int startLoc, int endLoc, Color color, int counter) {
        Collection<Integer> starts = WorldPointUtil.toLocalInstance(client, startLoc);
        Collection<Integer> ends = WorldPointUtil.toLocalInstance(client, endLoc);

        if (starts.isEmpty() || ends.isEmpty()) {
            return;
        }

        int start = starts.iterator().next();
        int end = ends.iterator().next();

        final int z = client.getPlane();
        if (WorldPointUtil.unpackWorldPlane(start) != z) {
            return;
        }

        LocalPoint lpStart = WorldPointUtil.toLocalPoint(client, start);
        LocalPoint lpEnd = WorldPointUtil.toLocalPoint(client, end);

        if (lpStart == null || lpEnd == null) {
            return;
        }

        final int startHeight = Perspective.getTileHeight(client, lpStart, z);
        final int endHeight = Perspective.getTileHeight(client, lpEnd, z);

        Point p1 = Perspective.localToCanvas(client, lpStart.getX(), lpStart.getY(), startHeight);
        Point p2 = Perspective.localToCanvas(client, lpEnd.getX(), lpEnd.getY(), endHeight);

        if (p1 == null || p2 == null) {
            return;
        }

        Line2D.Double line = new Line2D.Double(p1.getX(), p1.getY(), p2.getX(), p2.getY());

        graphics.setColor(color);
        graphics.setStroke(new BasicStroke(4));
        graphics.draw(line);

        if (counter == 1) {
            drawCounter(graphics, p1.getX(), p1.getY(), 0);
        }
        drawCounter(graphics, p2.getX(), p2.getY(), counter);
    }

    private void drawCounter(Graphics2D graphics, double x, double y, int counter) {
        if (counter >= 0 && !TileCounter.DISABLED.equals(plugin.showTileCounter)) {
            int n = plugin.tileCounterStep > 0 ? plugin.tileCounterStep : 1;
            int s = plugin.getPathfinder().getPath().size();
            if ((counter % n != 0) && (s != (counter + 1))) {
                return;
            }
            if (TileCounter.REMAINING.equals(plugin.showTileCounter)) {
                counter = s - counter - 1;
            }
            if (n > 1 && counter == 0) {
                return;
            }
            String counterText = Integer.toString(counter);
            graphics.setColor(plugin.colourText);
            graphics.drawString(
                counterText,
                (int) (x - graphics.getFontMetrics().getStringBounds(counterText, graphics).getWidth() / 2), (int) y);
        }
    }

    private void drawTransportInfo(Graphics2D graphics, int location, int locationEnd) {
        if (locationEnd == WorldPointUtil.UNDEFINED || !plugin.showTransportInfo ||
            WorldPointUtil.unpackWorldPlane(location) != client.getPlane()) {
            return;
        }

        // Workaround for weird pathing inside PoH to instead show info on the player tile
        LocalPoint playerLocalPoint = client.getLocalPlayer().getLocalLocation();
        int playerPackedPoint = WorldPointUtil.fromLocalInstance(client, playerLocalPoint);
        int px = WorldPointUtil.unpackWorldX(playerPackedPoint);
        int py = WorldPointUtil.unpackWorldY(playerPackedPoint);
        int tx = WorldPointUtil.unpackWorldX(location);
        int ty = WorldPointUtil.unpackWorldY(location);
        boolean transportAndPlayerInsidePoh = (tx >= 1792 && tx <= 2047 && ty >= 5696 && ty <= 5767
            && px >= 1792 && px <= 2047 && py >= 5696 && py <= 5767);

        int vertical_offset = 0;
        for (Transport transport : plugin.getTransports().getOrDefault(location, new HashSet<>())) {
            if (locationEnd != transport.getDestination()) {
                continue;
            }

            String text = transport.getDisplayInfo();
            if (text == null || text.isEmpty()) {
                continue;
            }

            for (int point : WorldPointUtil.toLocalInstance(client, location)) {
                LocalPoint lp = WorldPointUtil.toLocalPoint(client, point);
                if (lp == null) {
                    continue;
                }

                Point p = Perspective.localToCanvas(client,
                    transportAndPlayerInsidePoh ? playerLocalPoint : lp, client.getPlane());
                if (p == null) {
                    continue;
                }

                Rectangle2D textBounds = graphics.getFontMetrics().getStringBounds(text, graphics);
                double height = textBounds.getHeight();
                int x = (int) (p.getX() - textBounds.getWidth() / 2);
                int y = (int) (p.getY() - height) - vertical_offset;
                graphics.setColor(Color.BLACK);
                graphics.drawString(text, x + 1, y + 1);
                graphics.setColor(plugin.colourText);
                graphics.drawString(text, x, y);

                vertical_offset += (int) height + TRANSPORT_LABEL_GAP;
            }
        }
    }
}

package shortestpath;

import java.util.Arrays;
import java.util.Collection;

// This class is not intended as a general purpose replacement for a hashmap; it lacks convenience features
// found in regular maps and has no way to remove elements or get a list of keys/values.
public class PrimitiveIntHashMap<V> {
    private static final int MINIMUM_SIZE = 8;

    // Unless the hash function is really unbalanced, most things should fit within at least 8-element buckets
    // Buckets will grow as needed without forcing a rehash of the whole map
    private static final int DEFAULT_BUCKET_SIZE = 4;

    // How full the map should get before growing it again. Smaller values speed up lookup times at the expense of space
    private static final float DEFAULT_LOAD_FACTOR = 0.75f;

    private static class IntNode<V> {
        private int key;
        private V value;

        private IntNode(int key, V value) {
            this.key = key;
            this.value = value;
        }
    }

    // If buckets become too large then it may be worth converting large buckets into an array-backed binary tree
    private IntNode<V>[][] buckets;
    private int size;
    private int capacity;
    private int maxSize;
    private int mask;
    private final float loadFactor;

    public PrimitiveIntHashMap(int initialSize) {
        this(initialSize, DEFAULT_LOAD_FACTOR);
    }

    public PrimitiveIntHashMap(int initialSize, float loadFactor) {
        if (loadFactor < 0.0f || loadFactor > 1.0f) {
            throw new IllegalArgumentException("Load factor must be between 0 and 1");
        }

        this.loadFactor = loadFactor;
        size = 0;
        setNewSize(initialSize);
        recreateArrays();
    }

    public int size() {
        return size;
    }

    public V get(int key) {
        return getOrDefault(key, null);
    }

    public V getOrDefault(int key, V defaultValue) {
        int bucket = getBucket(key);
        int index = bucketIndex(key, bucket);
        if (index == -1) {
            return defaultValue;
        }
        return buckets[bucket][index].value;
    }

    /* Associates the specified value with the specified key in this map.
     * If the map previously contained a mapping for the key, the old value is
     * replaced or appended if both the old and new value is a collection.
     */
    @SuppressWarnings("unchecked")
    public <E> V put(int key, V value) {
        if (value == null) {
            throw new IllegalArgumentException("Cannot insert a null value");
        }

        int bucketIndex = getBucket(key);
        IntNode<V>[] bucket = buckets[bucketIndex];

        if (bucket == null) {
            buckets[bucketIndex] = createBucket(DEFAULT_BUCKET_SIZE);
            buckets[bucketIndex][0] = new IntNode<>(key, value);
            incrementSize();
            return null;
        }

        for (int i = 0; i < bucket.length; ++i) {
            if (bucket[i] == null) {
                bucket[i] = new IntNode<>(key, value);
                incrementSize();
                return null;
            } else if (bucket[i].key == key) {
                V previous = bucket[i].value;
                if (previous instanceof Collection<?> && value instanceof Collection<?>) { // append
                    ((Collection<E>) bucket[i].value).addAll((Collection<E>) value);
                } else { // replace
                    bucket[i].value = value;
                }
                return previous;
            }
        }

        // No space in the bucket, grow it
        growBucket(bucketIndex)[bucket.length] = new IntNode<>(key, value);
        incrementSize();
        return null;
    }

    // This hash seems to be most effective for packed WorldPoint's
    private static int hash(int value) {
        return value ^ (value >>> 5) ^ (value >>> 25);
    }

    private int getBucket(int key) {
        return (hash(key) & 0x7FFFFFFF) & mask;
    }

    private int bucketIndex(int key, int bucketIndex) {
        IntNode<V>[] bucket = buckets[bucketIndex];
        if (bucket == null) {
            return -1;
        }

        for (int i = 0; i < bucket.length; ++i) {
            if (bucket[i] == null) {
                break;
            }
            if (bucket[i].key == key) {
                return i;
            }
        }

        // Searched the bucket and found nothing
        return -1;
    }

    private void incrementSize() {
        size++;
        if (size >= capacity) {
            rehash();
        }
    }

    private IntNode<V>[] growBucket(int bucketIndex) {
        IntNode<V>[] oldBucket = buckets[bucketIndex];
        IntNode<V>[] newBucket = createBucket(oldBucket.length * 2);
        System.arraycopy(oldBucket, 0, newBucket, 0, oldBucket.length);
        buckets[bucketIndex] = newBucket;
        return newBucket;
    }

    private int getNewMaxSize(int size) {
        int nextPow2 = -1 >>> Integer.numberOfLeadingZeros(size);
        if (nextPow2 >= (Integer.MAX_VALUE >>> 1)) {
            return (Integer.MAX_VALUE >>> 1) + 1;
        }
        return nextPow2 + 1;
    }

    private void setNewSize(int size) {
        if (size < MINIMUM_SIZE) {
            size = MINIMUM_SIZE - 1;
        }

        maxSize = getNewMaxSize(size);
        mask = maxSize - 1;
        capacity = (int)(maxSize * loadFactor);
    }

    private void growCapacity() {
        setNewSize(maxSize);
    }

    // Grow the bucket array then rehash all the values into new buckets and discard the old ones
    private void rehash() {
        growCapacity();

        IntNode<V>[][] oldBuckets = buckets;
        recreateArrays();

        for (int i = 0; i < oldBuckets.length; ++i) {
            IntNode<V>[] oldBucket = oldBuckets[i];
            if (oldBucket == null) {
                continue;
            }

            for (int ind = 0; ind < oldBucket.length; ++ind) {
                if (oldBucket[ind] == null) {
                    break;
                }

                int bucketIndex = getBucket(oldBucket[ind].key);
                IntNode<V>[] newBucket = buckets[bucketIndex];
                if (newBucket == null) {
                    newBucket = createBucket(DEFAULT_BUCKET_SIZE);
                    newBucket[0] = oldBucket[ind];
                    buckets[bucketIndex] = newBucket;
                } else {
                    int bInd;
                    for (bInd = 0; bInd < newBucket.length; ++bInd) {
                        if (newBucket[bInd] == null) {
                            newBucket[bInd] = oldBucket[ind];
                            break;
                        }
                    }

                    if (bInd >= newBucket.length) {
                        growBucket(bucketIndex)[newBucket.length] = oldBucket[ind];
                        return;
                    }
                }
            }
        }
    }

    private void recreateArrays() {
        @SuppressWarnings({"unchecked", "SuspiciousArrayCast"})
        IntNode<V>[][] temp = (IntNode<V>[][])new IntNode[maxSize][];
        buckets = temp;
    }

    private IntNode<V>[] createBucket(int size) {
        @SuppressWarnings({"unchecked", "SuspiciousArrayCast"})
        IntNode<V>[] temp = (IntNode<V>[])new IntNode[size];
        return temp;
    }

    // Debug helper to understand how effective a given hash may be at distributing values
    public double calculateFullness() {
        int size = 0;
        int usedSize = 0;
        for (int i = 0; i < buckets.length; ++i) {
            if (buckets[i] == null) continue;
            size += buckets[i].length;
            for (int j = 0; j < buckets[i].length; ++j) {
                if (buckets[i][j] == null) {
                    usedSize += j;
                    break;
                }
            }
        }
        return 100.0 * (double)usedSize / (double)size;
    }

    public void clear() {
        size = 0;
        Arrays.fill(buckets, null);
    }
}

package shortestpath;

import lombok.EqualsAndHashCode;
import lombok.Getter;

@Getter
@EqualsAndHashCode
public class TransportItems {
    // Each outer int[] holds item id requirements, e.g. AIR_RUNE, FIRE_RUNE, ...
    // Each inner int[] holds item id variations, e.g. AIR_RUNE, DUST_RUNE, ...
    private final int[][] items;
    private final int[][] staves;
    private final int[][] offhands;
    private final int[] quantities;

    public TransportItems(int[][] items, int[][] staves, int[][] offhands, int[] quantities) {
        this.items = items;
        this.staves = staves;
        this.offhands = offhands;
        this.quantities = quantities;
    }
}

package shortestpath;

import com.google.common.util.concurrent.ThreadFactoryBuilder;
import com.google.inject.Inject;
import com.google.inject.Provides;
import java.awt.Color;
import java.awt.Polygon;
import java.awt.Rectangle;
import java.awt.Shape;
import java.awt.geom.Ellipse2D;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ThreadFactory;
import java.util.regex.Pattern;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.KeyCode;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.Player;
import net.runelite.api.Point;
import net.runelite.api.SpriteID;
import net.runelite.api.Varbits;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.MenuOpened;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.worldmap.WorldMap;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.PluginMessage;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.JagexColors;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.worldmap.WorldMapPoint;
import net.runelite.client.ui.overlay.worldmap.WorldMapPointManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;
import shortestpath.pathfinder.CollisionMap;
import shortestpath.pathfinder.Pathfinder;
import shortestpath.pathfinder.PathfinderConfig;

@PluginDescriptor(
    name = "Shortest Path",
    description = "Draws the shortest path to a chosen destination on the map<br>" +
        "Right click on the world map or shift right click a tile to use",
    tags = {"pathfinder", "map", "waypoint", "navigation"}
)
public class ShortestPathPlugin extends Plugin {
    protected static final String CONFIG_GROUP = "shortestpath";
    private static final String PLUGIN_MESSAGE_PATH = "path";
    private static final String PLUGIN_MESSAGE_CLEAR = "clear";
    private static final String PLUGIN_MESSAGE_START = "start";
    private static final String PLUGIN_MESSAGE_TARGET = "target";
    private static final String PLUGIN_MESSAGE_CONFIG_OVERRIDE = "config";
    private static final String CLEAR = "Clear";
    private static final String PATH = ColorUtil.wrapWithColorTag("Path", JagexColors.MENU_TARGET);
    private static final String SET = "Set";
    private static final String FIND_CLOSEST = "Find closest";
    private static final String FLASH_ICONS = "Flash icons";
    private static final String START = ColorUtil.wrapWithColorTag("Start", JagexColors.MENU_TARGET);
    private static final String TARGET = ColorUtil.wrapWithColorTag("Target", JagexColors.MENU_TARGET);
    private static final BufferedImage MARKER_IMAGE = ImageUtil.loadImageResource(ShortestPathPlugin.class, "/marker.png");
    private static final Pattern TRANSPORT_OPTIONS_REGEX = Pattern.compile("^(avoidWilderness|currencyThreshold|use\\w+)$");

    @Inject
    private Client client;

    @Getter
    @Inject
    private ClientThread clientThread;

    @Inject
    private ShortestPathConfig config;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private PathTileOverlay pathOverlay;

    @Inject
    private PathMinimapOverlay pathMinimapOverlay;

    @Inject
    private PathMapOverlay pathMapOverlay;

    @Inject
    private PathMapTooltipOverlay pathMapTooltipOverlay;

    @Inject
    private DebugOverlayPanel debugOverlayPanel;

    @Inject
    private SpriteManager spriteManager;

    @Inject
    private WorldMapPointManager worldMapPointManager;

    boolean drawCollisionMap;
    boolean drawMap;
    boolean drawMinimap;
    boolean drawTiles;
    boolean drawTransports;
    boolean showTransportInfo;
    Color colourCollisionMap;
    Color colourPath;
    Color colourPathCalculating;
    Color colourText;
    Color colourTransports;
    int tileCounterStep;
    TileCounter showTileCounter;
    TileStyle pathStyle;

    private Point lastMenuOpenedPoint;
    private WorldMapPoint marker;
    private int lastLocation = WorldPointUtil.packWorldPoint(0, 0, 0);
    private Shape minimapClipFixed;
    private Shape minimapClipResizeable;
    private BufferedImage minimapSpriteFixed;
    private BufferedImage minimapSpriteResizeable;
    private Rectangle minimapRectangle = new Rectangle();

    private GameState lastGameState = null;
    private GameState lastLastGameState = null;
    private List<PendingTask> pendingTasks = new ArrayList<>(3);

    private ExecutorService pathfindingExecutor = Executors.newSingleThreadExecutor();
    private Future<?> pathfinderFuture;
    private final Object pathfinderMutex = new Object();
    private static final Map<String, Object> configOverride = new HashMap<>(50);
    @Getter
    private Pathfinder pathfinder;
    @Getter
    private PathfinderConfig pathfinderConfig;
    @Getter
    private boolean startPointSet = false;

    @Provides
    public ShortestPathConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(ShortestPathConfig.class);
    }

    @Override
    protected void startUp() {
        cacheConfigValues();

        pathfinderConfig = new PathfinderConfig(client, config);
        if (GameState.LOGGED_IN.equals(client.getGameState())) {
            clientThread.invokeLater(pathfinderConfig::refresh);
        }

        overlayManager.add(pathOverlay);
        overlayManager.add(pathMinimapOverlay);
        overlayManager.add(pathMapOverlay);
        overlayManager.add(pathMapTooltipOverlay);

        if (config.drawDebugPanel()) {
            overlayManager.add(debugOverlayPanel);
        }
    }

    @Override
    protected void shutDown() {
        overlayManager.remove(pathOverlay);
        overlayManager.remove(pathMinimapOverlay);
        overlayManager.remove(pathMapOverlay);
        overlayManager.remove(pathMapTooltipOverlay);
        overlayManager.remove(debugOverlayPanel);

        if (pathfindingExecutor != null) {
            pathfindingExecutor.shutdownNow();
            pathfindingExecutor = null;
        }
    }

    public void restartPathfinding(int start, Set<Integer> ends, boolean canReviveFiltered) {
        synchronized (pathfinderMutex) {
            if (pathfinder != null) {
                pathfinder.cancel();
                pathfinderFuture.cancel(true);
            }

            if (pathfindingExecutor == null) {
                ThreadFactory shortestPathNaming = new ThreadFactoryBuilder().setNameFormat("shortest-path-%d").build();
                pathfindingExecutor = Executors.newSingleThreadExecutor(shortestPathNaming);
            }
        }

        getClientThread().invokeLater(() -> {
            pathfinderConfig.refresh();
            pathfinderConfig.filterLocations(ends, canReviveFiltered);
            synchronized (pathfinderMutex) {
                if (ends.isEmpty()) {
                    setTarget(WorldPointUtil.UNDEFINED);
                } else {
                    pathfinder = new Pathfinder(pathfinderConfig, start, ends);
                    pathfinderFuture = pathfindingExecutor.submit(pathfinder);
                }
            }
        });
    }

    public void restartPathfinding(int start, Set<Integer> ends) {
        restartPathfinding(start, ends, true);
    }

    public boolean isNearPath(int location) {
        if (pathfinder == null || pathfinder.getPath() == null || pathfinder.getPath().isEmpty() ||
            config.recalculateDistance() < 0 || lastLocation == (lastLocation = location)) {
            return true;
        }

        for (int point : pathfinder.getPath()) {
            if (WorldPointUtil.distanceBetween(location, point) < config.recalculateDistance()) {
                return true;
            }
        }

        return false;
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        if (!CONFIG_GROUP.equals(event.getGroup())) {
            return;
        }

        cacheConfigValues();

        if ("drawDebugPanel".equals(event.getKey())) {
            if (config.drawDebugPanel()) {
                overlayManager.add(debugOverlayPanel);
            } else {
                overlayManager.remove(debugOverlayPanel);
            }
            return;
        }

        // Transport option changed; rerun pathfinding
        if (TRANSPORT_OPTIONS_REGEX.matcher(event.getKey()).find()) {
            if (pathfinder != null) {
                restartPathfinding(pathfinder.getStart(), pathfinder.getTargets());
            }
        }
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event) {
        if (pathfinderConfig == null
            || !GameState.LOGGING_IN.equals(lastLastGameState)
            || !GameState.LOADING.equals(lastLastGameState = lastGameState)
            || !GameState.LOGGED_IN.equals(lastGameState = event.getGameState())) {
            lastLastGameState = lastGameState;
            lastGameState = event.getGameState();
            return;
        }

        pendingTasks.add(new PendingTask(client.getTickCount() + 1, pathfinderConfig::refresh));
    }

    @Subscribe
    public void onPluginMessage(PluginMessage event) {
        if (!CONFIG_GROUP.equals(event.getNamespace())) {
            return;
        }

        String action = event.getName();
        if (PLUGIN_MESSAGE_PATH.equals(action)) {
            Map<String, Object> data = event.getData();
            Object objStart = data.getOrDefault(PLUGIN_MESSAGE_START, null);
            Object objTarget = data.getOrDefault(PLUGIN_MESSAGE_TARGET, null);
            Object objConfigOverride = data.getOrDefault(PLUGIN_MESSAGE_CONFIG_OVERRIDE, null);

            @SuppressWarnings("unchecked")
            Map<String, Object> configOverride = (objConfigOverride instanceof Map<?,?>) ? ((Map<String, Object>) objConfigOverride) : null;
            if (configOverride != null && !configOverride.isEmpty()) {
                this.configOverride.clear();
                for (String key : configOverride.keySet()) {
                    this.configOverride.put(key, configOverride.get(key));
                }
                cacheConfigValues();
            }

            if (objStart == null && objTarget == null) {
                return;
            }

            int start = (objStart instanceof WorldPoint) ? WorldPointUtil.packWorldPoint((WorldPoint) objStart)
                : ((objStart instanceof Integer) ? ((int) objStart) : WorldPointUtil.UNDEFINED);
            if (start == WorldPointUtil.UNDEFINED) {
                if (client.getLocalPlayer() == null) {
                    return;
                }
                start = WorldPointUtil.packWorldPoint(client.getLocalPlayer().getWorldLocation());
            }

            Set<Integer> targets = new HashSet<>();
            if (objTarget instanceof Integer) {
                int packedPoint = (Integer) objTarget;
                if (packedPoint == WorldPointUtil.UNDEFINED) {
                    return;
                }
                targets.add(packedPoint);
            } else if (objTarget instanceof WorldPoint) {
                int packedPoint = WorldPointUtil.packWorldPoint((WorldPoint) objTarget);
                if (packedPoint == WorldPointUtil.UNDEFINED) {
                    return;
                }
                targets.add(packedPoint);
            } else if (objTarget instanceof Set<?>) {
                @SuppressWarnings("unchecked")
                Set<Object> objTargets = (Set<Object>) objTarget;
                for (Object obj : objTargets) {
                    int packedPoint = WorldPointUtil.UNDEFINED;
                    if (obj instanceof Integer) {
                        packedPoint = (Integer) obj;
                    } else if (obj instanceof WorldPoint) {
                        packedPoint = WorldPointUtil.packWorldPoint((WorldPoint) obj);
                    }
                    if (packedPoint == WorldPointUtil.UNDEFINED) {
                        return;
                    }
                    targets.add(packedPoint);
                }
            }

            boolean useOld = targets.isEmpty() && pathfinder != null;
            restartPathfinding(start, useOld ? pathfinder.getTargets() : targets, useOld);
        } else if (PLUGIN_MESSAGE_CLEAR.equals(action)) {
            this.configOverride.clear();
            cacheConfigValues();
            setTarget(WorldPointUtil.UNDEFINED);
        }
    }

    @Subscribe
    public void onMenuOpened(MenuOpened event) {
        lastMenuOpenedPoint = client.getMouseCanvasPosition();
    }

    @Subscribe
    public void onGameTick(GameTick tick) {
        for (int i = 0; i < pendingTasks.size(); i++) {
            if (pendingTasks.get(i).check(client.getTickCount())) {
                pendingTasks.remove(i--).run();
            }
        }

        Player localPlayer = client.getLocalPlayer();
        if (localPlayer == null || pathfinder == null) {
            return;
        }

        int currentLocation = WorldPointUtil.fromLocalInstance(client, localPlayer.getLocalLocation());
        for (int target : pathfinder.getTargets()) {
            if (WorldPointUtil.distanceBetween(currentLocation, target) < config.reachedDistance()) {
                setTarget(WorldPointUtil.UNDEFINED);
                return;
            }
        }

        if (!startPointSet && !isNearPath(currentLocation)) {
            if (config.cancelInstead()) {
                setTarget(WorldPointUtil.UNDEFINED);
                return;
            }
            restartPathfinding(currentLocation, pathfinder.getTargets());
        }
    }

    @Subscribe
    public void onMenuEntryAdded(MenuEntryAdded event) {
        if (client.isKeyPressed(KeyCode.KC_SHIFT)
            && event.getType() == MenuAction.WALK.getId()) {
            addMenuEntry(event, SET, TARGET, 1);
            if (pathfinder != null) {
                if (pathfinder.getTargets().size() >= 1) {
                    addMenuEntry(event, SET, TARGET + ColorUtil.wrapWithColorTag(" " +
                        (pathfinder.getTargets().size() + 1), JagexColors.MENU_TARGET), 1);
                }
                for (int target : pathfinder.getTargets()) {
                    if (target != WorldPointUtil.UNDEFINED) {
                        addMenuEntry(event, SET, START, 1);
                        break;
                    }
                }
                int selectedTile = getSelectedWorldPoint();
                if (pathfinder.getPath() != null) {
                    for (int tile : pathfinder.getPath()) {
                        if (tile == selectedTile) {
                            addMenuEntry(event, CLEAR, PATH, 1);
                            break;
                        }
                    }
                }
            }
        }

        final Widget map = client.getWidget(ComponentID.WORLD_MAP_MAPVIEW);

        if (map != null) {
            if (map.getBounds().contains(
                client.getMouseCanvasPosition().getX(),
                client.getMouseCanvasPosition().getY())) {
                addMenuEntry(event, SET, TARGET, 0);
                if (pathfinder != null) {
                    if (pathfinder.getTargets().size() >= 1) {
                        addMenuEntry(event, SET, TARGET + ColorUtil.wrapWithColorTag(" " +
                            (pathfinder.getTargets().size() + 1), JagexColors.MENU_TARGET), 0);
                    }
                    for (int target : pathfinder.getTargets()) {
                        if (target != WorldPointUtil.UNDEFINED) {
                            addMenuEntry(event, SET, START, 0);
                            addMenuEntry(event, CLEAR, PATH, 0);
                        }
                    }
                }
            }
            if (event.getOption().equals(FLASH_ICONS) && pathfinderConfig.hasDestination(simplify(event.getTarget()))) {
                addMenuEntry(event, FIND_CLOSEST, event.getTarget(), 1);
            }
        }

        final Shape minimap = getMinimapClipArea();

        if (minimap != null && pathfinder != null
            && minimap.contains(
                client.getMouseCanvasPosition().getX(),
                client.getMouseCanvasPosition().getY())) {
            addMenuEntry(event, CLEAR, PATH, 0);
        }

        if (minimap != null && pathfinder != null
            && ("Floating World Map".equals(Text.removeTags(event.getOption()))
            || "Close Floating panel".equals(Text.removeTags(event.getOption())))) {
            addMenuEntry(event, CLEAR, PATH, 1);
        }
    }

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event) {
        if (event.getContainerId() != InventoryID.BANK) {
            return;
        }
        pathfinderConfig.bank = event.getItemContainer();
    }

    public Map<Integer, Set<Transport>> getTransports() {
        return pathfinderConfig.getTransports();
    }

    public CollisionMap getMap() {
        return pathfinderConfig.getMap();
    }

    public static boolean override(String configOverrideKey, boolean defaultValue) {
        if (!configOverride.isEmpty()) {
            Object value = configOverride.get(configOverrideKey);
            if (value instanceof Boolean) {
                return (boolean) value;
            }
        }
        return defaultValue;
    }

    private Color override(String configOverrideKey, Color defaultValue) {
        if (!configOverride.isEmpty()) {
            Object value = configOverride.get(configOverrideKey);
            if (value instanceof Color) {
                return (Color) value;
            }
        }
        return defaultValue;
    }

    public static int override(String configOverrideKey, int defaultValue) {
        if (!configOverride.isEmpty()) {
            Object value = configOverride.get(configOverrideKey);
            if (value instanceof Integer) {
                return (int) value;
            }
        }
        return defaultValue;
    }

    public static TeleportationItem override(String configOverrideKey, TeleportationItem defaultValue) {
        if (!configOverride.isEmpty()) {
            Object value = configOverride.get(configOverrideKey);
            if (value instanceof String) {
                TeleportationItem teleportationItem = TeleportationItem.fromType((String) value);
                if (teleportationItem != null) {
                    return teleportationItem;
                }
            }
        }
        return defaultValue;
    }

    private TileCounter override(String configOverrideKey, TileCounter defaultValue) {
        if (!configOverride.isEmpty()) {
            Object value = configOverride.get(configOverrideKey);
            if (value instanceof String) {
                TileCounter tileCounter = TileCounter.fromType((String) value);
                if (tileCounter != null) {
                    return tileCounter;
                }
            }
        }
        return defaultValue;
    }

    private TileStyle override(String configOverrideKey, TileStyle defaultValue) {
        if (!configOverride.isEmpty()) {
            Object value = configOverride.get(configOverrideKey);
            if (value instanceof String) {
                TileStyle tileStyle = TileStyle.fromType((String) value);
                if (tileStyle != null) {
                    return tileStyle;
                }
            }
        }
        return defaultValue;
    }

    private void cacheConfigValues() {
        drawCollisionMap = override("drawCollisionMap", config.drawCollisionMap());
        drawMap = override("drawMap", config.drawMap());
        drawMinimap = override("drawMinimap", config.drawMinimap());
        drawTiles = override("drawTiles", config.drawTiles());
        drawTransports = override("drawTransports", config.drawTransports());
        showTransportInfo = override("showTransportInfo", config.showTransportInfo());

        colourCollisionMap = override("colourCollisionMap", config.colourCollisionMap());
        colourPath = override("colourPath", config.colourPath());
        colourPathCalculating = override("colourPathCalculating", config.colourPathCalculating());
        colourText = override("colourText", config.colourText());
        colourTransports = override("colourTransports", config.colourTransports());

        tileCounterStep = override("tileCounterStep", config.tileCounterStep());

        showTileCounter = override("showTileCounter", config.showTileCounter());
        pathStyle = override("pathStyle", config.pathStyle());
    }

    private String simplify(String text) {
        return Text.removeTags(text).toLowerCase()
            .replaceAll("[^a-zA-Z ]", "")
            .replaceAll("[ ]", "_")
            .replace("__", "_");
    }

    private void onMenuOptionClicked(MenuEntry entry) {
        if (entry.getOption().equals(SET) && entry.getTarget().equals(TARGET)) {
            setTarget(getSelectedWorldPoint());
        } else if (entry.getOption().equals(SET) && pathfinder != null && entry.getTarget().equals(TARGET +
            ColorUtil.wrapWithColorTag(" " + (pathfinder.getTargets().size() + 1), JagexColors.MENU_TARGET))) {
            setTarget(getSelectedWorldPoint(), true);
        } else if (entry.getOption().equals(SET) && entry.getTarget().equals(START)) {
            setStart(getSelectedWorldPoint());
        } else if (entry.getOption().equals(CLEAR) && entry.getTarget().equals(PATH)) {
            setTarget(WorldPointUtil.UNDEFINED);
        } else if (entry.getOption().equals(FIND_CLOSEST)) {
            setTargets(pathfinderConfig.getDestinations(simplify(entry.getTarget())), true);
        }
    }

    private int getSelectedWorldPoint() {
        if (client.getWidget(ComponentID.WORLD_MAP_MAPVIEW) == null) {
            if (client.getSelectedSceneTile() != null) {
                return WorldPointUtil.fromLocalInstance(client, client.getSelectedSceneTile().getLocalLocation());
            }
        } else {
            return client.isMenuOpen()
                ? calculateMapPoint(lastMenuOpenedPoint.getX(), lastMenuOpenedPoint.getY())
                : calculateMapPoint(client.getMouseCanvasPosition().getX(), client.getMouseCanvasPosition().getY());
        }
        return WorldPointUtil.UNDEFINED;
    }

    private void setTarget(int target) {
        setTarget(target, false);
    }

    private void setTarget(int target, boolean append) {
        Set<Integer> targets = new HashSet<>();
        if (target != WorldPointUtil.UNDEFINED) {
            targets.add(target);
        }
        setTargets(targets, append);
    }

    private void setTargets(Set<Integer> targets, boolean append) {
        if (targets == null || targets.isEmpty()) {
            synchronized (pathfinderMutex) {
                if (pathfinder != null) {
                    pathfinder.cancel();
                }
                pathfinder = null;
            }

            worldMapPointManager.removeIf(x -> x == marker);
            marker = null;
            startPointSet = false;
        } else {
            Player localPlayer = client.getLocalPlayer();
            if (!startPointSet && localPlayer == null) {
                return;
            }
            worldMapPointManager.removeIf(x -> x == marker);
            if (targets.size() == 1) {
                marker = new WorldMapPoint(WorldPointUtil.unpackWorldPoint(targets.iterator().next()), MARKER_IMAGE);
                marker.setName("Target");
                marker.setTarget(marker.getWorldPoint());
                marker.setJumpOnClick(true);
                worldMapPointManager.add(marker);
            }

            int start = WorldPointUtil.fromLocalInstance(client, localPlayer.getLocalLocation());
            lastLocation = start;
            if (startPointSet && pathfinder != null) {
                start = pathfinder.getStart();
            }
            Set<Integer> destinations = new HashSet<>(targets);
            if (pathfinder != null && append) {
                destinations.addAll(pathfinder.getTargets());
            }
            restartPathfinding(start, destinations, append);
        }
    }

    private void setStart(int start) {
        if (pathfinder == null) {
            return;
        }
        startPointSet = true;
        restartPathfinding(start, pathfinder.getTargets());
    }

    public int calculateMapPoint(int pointX, int pointY) {
        WorldMap worldMap = client.getWorldMap();
        float zoom = worldMap.getWorldMapZoom();
        int mapPoint = WorldPointUtil.packWorldPoint(worldMap.getWorldMapPosition().getX(), worldMap.getWorldMapPosition().getY(), 0);
        int middleX = mapWorldPointToGraphicsPointX(mapPoint);
        int middleY = mapWorldPointToGraphicsPointY(mapPoint);

        if (pointX == Integer.MIN_VALUE || pointY == Integer.MIN_VALUE ||
            middleX == Integer.MIN_VALUE || middleY == Integer.MIN_VALUE) {
            return WorldPointUtil.UNDEFINED;
        }

        final int dx = (int) ((pointX - middleX) / zoom);
        final int dy = (int) ((-(pointY - middleY)) / zoom);

        return WorldPointUtil.dxdy(mapPoint, dx, dy);
    }

    public int mapWorldPointToGraphicsPointX(int packedWorldPoint) {
        WorldMap worldMap = client.getWorldMap();

        float pixelsPerTile = worldMap.getWorldMapZoom();

        Widget map = client.getWidget(ComponentID.WORLD_MAP_MAPVIEW);
        if (map != null) {
            Rectangle worldMapRect = map.getBounds();

            int widthInTiles = (int) Math.ceil(worldMapRect.getWidth() / pixelsPerTile);

            Point worldMapPosition = worldMap.getWorldMapPosition();

            int xTileOffset = WorldPointUtil.unpackWorldX(packedWorldPoint) + widthInTiles / 2 - worldMapPosition.getX();

            int xGraphDiff = ((int) (xTileOffset * pixelsPerTile));
            xGraphDiff += pixelsPerTile - Math.ceil(pixelsPerTile / 2);
            xGraphDiff += (int) worldMapRect.getX();

            return xGraphDiff;
        }
        return Integer.MIN_VALUE;
    }

    public int mapWorldPointToGraphicsPointY(int packedWorldPoint) {
        WorldMap worldMap = client.getWorldMap();

        float pixelsPerTile = worldMap.getWorldMapZoom();

        Widget map = client.getWidget(ComponentID.WORLD_MAP_MAPVIEW);
        if (map != null) {
            Rectangle worldMapRect = map.getBounds();

            int heightInTiles = (int) Math.ceil(worldMapRect.getHeight() / pixelsPerTile);

            Point worldMapPosition = worldMap.getWorldMapPosition();

            int yTileMax = worldMapPosition.getY() - heightInTiles / 2;
            int yTileOffset = (yTileMax - WorldPointUtil.unpackWorldY(packedWorldPoint) - 1) * -1;

            int yGraphDiff = (int) (yTileOffset * pixelsPerTile);
            yGraphDiff -= pixelsPerTile - Math.ceil(pixelsPerTile / 2);
            yGraphDiff = worldMapRect.height - yGraphDiff;
            yGraphDiff += (int) worldMapRect.getY();

            return yGraphDiff;
        }
        return Integer.MIN_VALUE;
    }

    private void addMenuEntry(MenuEntryAdded event, String option, String target, int position) {
        List<MenuEntry> entries = new LinkedList<>(Arrays.asList(client.getMenuEntries()));

        if (entries.stream().anyMatch(e -> e.getOption().equals(option) && e.getTarget().equals(target))) {
            return;
        }

        client.createMenuEntry(position)
            .setOption(option)
            .setTarget(target)
            .setParam0(event.getActionParam0())
            .setParam1(event.getActionParam1())
            .setIdentifier(event.getIdentifier())
            .setType(MenuAction.RUNELITE)
            .onClick(this::onMenuOptionClicked);
    }

    private Widget getMinimapDrawWidget() {
        if (client.isResized()) {
            if (client.getVarbitValue(Varbits.SIDE_PANELS) == 1) {
                return client.getWidget(ComponentID.RESIZABLE_VIEWPORT_BOTTOM_LINE_MINIMAP_DRAW_AREA);
            }
            return client.getWidget(ComponentID.RESIZABLE_VIEWPORT_MINIMAP_DRAW_AREA);
        }
        return client.getWidget(ComponentID.FIXED_VIEWPORT_MINIMAP_DRAW_AREA);
    }

    private Shape getMinimapClipAreaSimple() {
        Widget minimapDrawArea = getMinimapDrawWidget();

        if (minimapDrawArea == null || minimapDrawArea.isHidden()) {
            return null;
        }

        Rectangle bounds = minimapDrawArea.getBounds();

        return new Ellipse2D.Double(bounds.getX(), bounds.getY(), bounds.getWidth(), bounds.getHeight());
    }

    public Shape getMinimapClipArea() {
        Widget minimapWidget = getMinimapDrawWidget();

        if (minimapWidget == null || minimapWidget.isHidden() || !minimapRectangle.equals(minimapRectangle = minimapWidget.getBounds())) {
            minimapClipFixed = null;
            minimapClipResizeable = null;
            minimapSpriteFixed = null;
            minimapSpriteResizeable = null;
        }

        if (minimapWidget == null || minimapWidget.isHidden()) {
            return null;
        }

        if (client.isResized()) {
            if (minimapClipResizeable != null) {
                return minimapClipResizeable;
            }
            if (minimapSpriteResizeable == null) {
                minimapSpriteResizeable = spriteManager.getSprite(SpriteID.RESIZEABLE_MODE_MINIMAP_ALPHA_MASK, 0);
            }
            if (minimapSpriteResizeable != null) {
                minimapClipResizeable = bufferedImageToPolygon(minimapSpriteResizeable);
                return minimapClipResizeable;
            }
            return getMinimapClipAreaSimple();
        }
        if (minimapClipFixed != null) {
            return minimapClipFixed;
        }
        if (minimapSpriteFixed == null) {
            minimapSpriteFixed = spriteManager.getSprite(SpriteID.FIXED_MODE_MINIMAP_ALPHA_MASK, 0);
        }
        if (minimapSpriteFixed != null) {
            minimapClipFixed = bufferedImageToPolygon(minimapSpriteFixed);
            return minimapClipFixed;
        }
        return getMinimapClipAreaSimple();
    }

    private Polygon bufferedImageToPolygon(BufferedImage image) {
        Color outsideColour = null;
        Color previousColour;
        final int width = image.getWidth();
        final int height = image.getHeight();
        List<java.awt.Point> points = new ArrayList<>();
        for (int y = 0; y < height; y++) {
            previousColour = outsideColour;
            for (int x = 0; x < width; x++) {
                int rgb = image.getRGB(x, y);
                int a = (rgb & 0xff000000) >>> 24;
                int r = (rgb & 0x00ff0000) >> 16;
                int g = (rgb & 0x0000ff00) >> 8;
                int b = (rgb & 0x000000ff) >> 0;
                Color colour = new Color(r, g, b, a);
                if (x == 0 && y == 0) {
                    outsideColour = colour;
                    previousColour = colour;
                }
                if (!colour.equals(outsideColour) && previousColour.equals(outsideColour)) {
                    points.add(new java.awt.Point(x, y));
                }
                if ((colour.equals(outsideColour) || x == (width - 1)) && !previousColour.equals(outsideColour)) {
                    points.add(0, new java.awt.Point(x, y));
                }
                previousColour = colour;
            }
        }
        int offsetX = minimapRectangle.x;
        int offsetY = minimapRectangle.y;
        Polygon polygon = new Polygon();
        for (java.awt.Point point : points) {
            polygon.addPoint(point.x + offsetX, point.y + offsetY);
        }
        return polygon;
    }
}

package shortestpath;

import lombok.Getter;
import lombok.Setter;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.ComponentConstants;
import net.runelite.client.ui.overlay.components.LayoutableRenderableEntity;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import shortestpath.pathfinder.Pathfinder;

import javax.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.util.List;

public class DebugOverlayPanel extends OverlayPanel {
    private final ShortestPathPlugin plugin;
    private final SeparatorLine separator;

    @Inject
    public DebugOverlayPanel(ShortestPathPlugin plugin) {
        super(plugin);
        this.plugin = plugin;

        separator = new SeparatorLine();
        separator.setColor(new Color(0, true)); // Invisible color

        setPosition(OverlayPosition.TOP_LEFT);
    }

    private LineComponent makeLine(String left, String right) {
        return LineComponent.builder()
                .left(left)
                .right(right)
                .build();
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        Pathfinder pathfinder = plugin.getPathfinder();
        Pathfinder.PathfinderStats stats;
        if (pathfinder == null || (stats = pathfinder.getStats()) == null) {
            return null;
        }

        List<LayoutableRenderableEntity> components = panelComponent.getChildren();

        components.add(
                TitleComponent.builder()
                        .text("Shortest Path Debug")
                        .color(Color.ORANGE)
                        .build()
        );

        components.add(separator);

        String pathLength = Integer.toString(pathfinder.getPath().size());
        components.add(makeLine("Path Length:", pathLength));

        components.add(separator);

        String nodes = Integer.toString(stats.getNodesChecked());
        components.add(makeLine("Nodes:", nodes));

        String transports = Integer.toString(stats.getTransportsChecked());
        components.add(makeLine("Transports:", transports));

        String totalNodes = Integer.toString(stats.getTotalNodesChecked());
        components.add(makeLine("Total:", totalNodes));

        components.add(separator);

        double milliTime = stats.getElapsedTimeNanos() / 1000000.0;
        String time = String.format("%.2fms", milliTime);
        components.add(makeLine("Time:", time));

        return super.render(graphics);
    }

    @Setter
    private static class SeparatorLine implements LayoutableRenderableEntity {
        private Color color = Color.GRAY;
        private Point preferredLocation = new Point();
        private Dimension preferredSize = new Dimension(ComponentConstants.STANDARD_WIDTH, 4);

        @Getter
        private final Rectangle bounds = new Rectangle();

        @Override
        public Dimension render(Graphics2D graphics) {
            final int separatorX = preferredLocation.x;
            final int separatorY = preferredLocation.y + 4;
            final int width = preferredSize.width;
            final int height = Math.max(preferredSize.height, 2);

            // Draw bar
            if (color != null && color.getAlpha() != 0) {
                graphics.setColor(color);
                graphics.fillRect(separatorX, separatorY, width, height);
            }

            final Dimension dimension = new Dimension(width, height + 4);
            bounds.setLocation(preferredLocation);
            bounds.setSize(dimension);

            return dimension;
        }
    }
}

package shortestpath;

import com.google.inject.Inject;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.geom.Area;
import java.util.HashSet;
import java.util.List;
import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import shortestpath.pathfinder.CollisionMap;

public class PathMapOverlay extends Overlay {
    private final Client client;
    private final ShortestPathPlugin plugin;

    @Inject
    private PathMapOverlay(Client client, ShortestPathPlugin plugin) {
        this.client = client;
        this.plugin = plugin;
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(Overlay.PRIORITY_LOW);
        setLayer(OverlayLayer.MANUAL);
        drawAfterLayer(ComponentID.WORLD_MAP_MAPVIEW);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!plugin.drawMap) {
            return null;
        }

        if (client.getWidget(ComponentID.WORLD_MAP_MAPVIEW) == null) {
            return null;
        }

        Rectangle worldMapRectangle = client.getWidget(ComponentID.WORLD_MAP_MAPVIEW).getBounds();
        Area worldMapClipArea = getWorldMapClipArea(worldMapRectangle);
        graphics.setClip(worldMapClipArea);

        if (plugin.drawCollisionMap) {
            graphics.setColor(plugin.colourCollisionMap);
            int mapWorldPoint = plugin.calculateMapPoint(worldMapRectangle.x, worldMapRectangle.y);
            int extentX = WorldPointUtil.unpackWorldX(mapWorldPoint);
            int extentY = WorldPointUtil.unpackWorldY(mapWorldPoint);
            int extentWidth = getWorldMapExtentWidth(worldMapRectangle);
            int extentHeight = getWorldMapExtentHeight(worldMapRectangle);
            final CollisionMap map = plugin.getMap();
            final int z = client.getPlane();
            for (int x = extentX; x < (extentX + extentWidth + 1); x++) {
                for (int y = extentY - extentHeight; y < (extentY + 1); y++) {
                    if (map.isBlocked(x, y, z)) {
                        drawOnMap(graphics, WorldPointUtil.packWorldPoint(x, y, z), false, null);
                    }
                }
            }
        }

        if (plugin.drawTransports) {
            graphics.setColor(Color.WHITE);
            for (int a : plugin.getTransports().keySet()) {
                if (a == Transport.UNDEFINED_ORIGIN) {
                    continue; // skip teleports
                }

                int mapAX = plugin.mapWorldPointToGraphicsPointX(a);
                int mapAY = plugin.mapWorldPointToGraphicsPointY(a);
                if (!worldMapClipArea.contains(mapAX, mapAY)) {
                    continue;
                }

                for (Transport b : plugin.getTransports().getOrDefault(a, new HashSet<>())) {
                    if (b == null || TransportType.isTeleport(b.getType())) {
                        continue; // skip teleports
                    }

                    int mapBX = plugin.mapWorldPointToGraphicsPointX(b.getDestination());
                    int mapBY = plugin.mapWorldPointToGraphicsPointY(b.getDestination());
                    if (!worldMapClipArea.contains(mapBX, mapBY)) {
                        continue;
                    }

                    graphics.drawLine(mapAX, mapAY, mapBX, mapBY);
                }
            }
        }

        if (plugin.getPathfinder() != null) {
            Color colour = plugin.getPathfinder().isDone() ? plugin.colourPath : plugin.colourPathCalculating;
            List<Integer> path = plugin.getPathfinder().getPath();
            Point cursorPos = client.getMouseCanvasPosition();
            for (int i = 0; i < path.size(); i++) {
                graphics.setColor(colour);
                int point = path.get(i);
                int lastPoint = (i > 0) ? path.get(i - 1) : point;
                if (WorldPointUtil.distanceBetween(point, lastPoint) > 1) {
                    drawOnMap(graphics, lastPoint, point, true, cursorPos);
                }
                drawOnMap(graphics, point, true, cursorPos);
            }
            for (int target : plugin.getPathfinder().getTargets()) {
                if (path.size() > 0 && target != path.get(path.size() - 1)) {
                    graphics.setColor(plugin.colourPathCalculating);
                    drawOnMap(graphics, target, true, cursorPos);
                }
            }
        }

        return null;
    }

    private void drawOnMap(Graphics2D graphics, int point, boolean checkHover, Point cursorPos) {
        drawOnMap(graphics, point, WorldPointUtil.dxdy(point, 1, -1), checkHover, cursorPos);
    }

    private void drawOnMap(Graphics2D graphics, int point, int offsetPoint, boolean checkHover, Point cursorPos) {
        int startX = plugin.mapWorldPointToGraphicsPointX(point);
        int startY = plugin.mapWorldPointToGraphicsPointY(point);
        int endX = plugin.mapWorldPointToGraphicsPointX(offsetPoint);
        int endY = plugin.mapWorldPointToGraphicsPointY(offsetPoint);

        if (startX == Integer.MIN_VALUE || startY == Integer.MIN_VALUE ||
            endX == Integer.MIN_VALUE || endY == Integer.MIN_VALUE) {
            return;
        }

        int x = startX;
        int y = startY;
        final int width = endX - x;
        final int height = endY - y;
        x -= width / 2;
        y -= height / 2;

        if (WorldPointUtil.distanceBetween(point, offsetPoint) > 1) {
            graphics.setStroke(new BasicStroke(1, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0, new float[]{9}, 0));
            graphics.drawLine(startX, startY, endX, endY);
        } else {
            if (checkHover && cursorPos != null &&
                cursorPos.getX() >= x && cursorPos.getX() <= (endX - width / 2) &&
                cursorPos.getY() >= y && cursorPos.getY() <= (endY - width / 2)) {
                graphics.setColor(graphics.getColor().darker());
            }
            graphics.fillRect(x, y, width, height);
        }
    }

    private Area getWorldMapClipArea(Rectangle baseRectangle) {
        final Widget overview = client.getWidget(ComponentID.WORLD_MAP_OVERVIEW_MAP);
        final Widget surfaceSelector = client.getWidget(ComponentID.WORLD_MAP_SURFACE_SELECTOR);

        Area clipArea = new Area(baseRectangle);

        if (overview != null && !overview.isHidden()) {
            clipArea.subtract(new Area(overview.getBounds()));
        }

        if (surfaceSelector != null && !surfaceSelector.isHidden()) {
            clipArea.subtract(new Area(surfaceSelector.getBounds()));
        }

        return clipArea;
    }

    private int getWorldMapExtentWidth(Rectangle baseRectangle) {
        return (
            WorldPointUtil.unpackWorldX(
                plugin.calculateMapPoint(
                    baseRectangle.x + baseRectangle.width,
                    baseRectangle.y + baseRectangle.height)) -
            WorldPointUtil.unpackWorldX(
                plugin.calculateMapPoint(
                    baseRectangle.x,
                    baseRectangle.y)));
    }

    private int getWorldMapExtentHeight(Rectangle baseRectangle) {
        return (
            WorldPointUtil.unpackWorldY(
                plugin.calculateMapPoint(
                    baseRectangle.x,
                    baseRectangle.y)) -
            WorldPointUtil.unpackWorldY(
                plugin.calculateMapPoint(
                    baseRectangle.x + baseRectangle.width,
                    baseRectangle.y + baseRectangle.height)));
    }
}

package shortestpath;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum TileCounter {
    DISABLED("Disabled"),
    TRAVELLED("Travelled"),
    REMAINING("Remaining");

    private final String type;

    public static TileCounter fromType(String type) {
        for (TileCounter tileCounter : values()) {
            if (tileCounter.type.equals(type)) {
                return tileCounter;
            }
        }
        return null;
    }
}

package shortestpath;

import java.awt.Color;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;
import net.runelite.client.config.Units;

@ConfigGroup(ShortestPathPlugin.CONFIG_GROUP)
public interface ShortestPathConfig extends Config {
    @ConfigSection(
        name = "Settings",
        description = "Options for the pathfinding",
        position = 0
    )
    String sectionSettings = "sectionSettings";

    @ConfigItem(
        keyName = "avoidWilderness",
        name = "Avoid wilderness",
        description = "Whether the wilderness should be avoided if possible<br>" +
            "(otherwise, will e.g. use wilderness lever from Edgeville to Ardougne)",
        position = 1,
        section = sectionSettings
    )
    default boolean avoidWilderness() {
        return true;
    }

    @ConfigItem(
        keyName = "useAgilityShortcuts",
        name = "Use agility shortcuts",
        description = "Whether to include agility shortcuts in the path.<br>" +
            "You must also have the required agility level",
        position = 2,
        section = sectionSettings
    )
    default boolean useAgilityShortcuts() {
        return true;
    }

    @ConfigItem(
        keyName = "useGrappleShortcuts",
        name = "Use grapple shortcuts",
        description = "Whether to include crossbow grapple agility shortcuts in the path.<br>" +
            "You must also have the required agility, ranged and strength levels",
        position = 3,
        section = sectionSettings
    )
    default boolean useGrappleShortcuts() {
        return false;
    }

    @ConfigItem(
        keyName = "useBoats",
        name = "Use boats",
        description = "Whether to include small boats in the path<br>" +
            "(e.g. the boat to Fishing Platform)",
        position = 4,
        section = sectionSettings
    )
    default boolean useBoats() {
        return true;
    }

    @ConfigItem(
        keyName = "useCanoes",
        name = "Use canoes",
        description = "Whether to include canoes in the path",
        position = 5,
        section = sectionSettings
    )
    default boolean useCanoes() {
        return false;
    }

    @ConfigItem(
        keyName = "useCharterShips",
        name = "Use charter ships",
        description = "Whether to include charter ships in the path",
        position = 6,
        section = sectionSettings
    )
    default boolean useCharterShips() {
        return false;
    }

    @ConfigItem(
        keyName = "useShips",
        name = "Use ships",
        description = "Whether to include passenger ships in the path<br>" +
            "(e.g. the customs ships to Karamja)",
        position = 7,
        section = sectionSettings
    )
    default boolean useShips() {
        return true;
    }

    @ConfigItem(
        keyName = "useFairyRings",
        name = "Use fairy rings",
        description = "Whether to include fairy rings in the path.<br>" +
            "You must also have completed the required quests or miniquests",
        position = 8,
        section = sectionSettings
    )
    default boolean useFairyRings() {
        return true;
    }

    @ConfigItem(
        keyName = "useGnomeGliders",
        name = "Use gnome gliders",
        description = "Whether to include gnome gliders in the path",
        position = 9,
        section = sectionSettings
    )
    default boolean useGnomeGliders() {
        return true;
    }

    @ConfigItem(
        keyName = "useHotAirBalloons",
        name = "Use hot air balloons",
        description = "Whether to include hot air balloons in the path",
        position = 10,
        section = sectionSettings
    )
    default boolean useHotAirBalloons() {
        return false;
    }

    @ConfigItem(
        keyName = "useMinecarts",
        name = "Use minecarts",
        description = "Whether to include minecarts in the path<br>" +
            "(e.g. the Keldagrim and Lovakengj minecart networks)",
        position = 11,
        section = sectionSettings
    )
    default boolean useMinecarts() {
        return true;
    }

    @ConfigItem(
        keyName = "useQuetzals",
        name = "Use quetzals",
        description = "Whether to include quetzals in the path",
        position = 12,
        section = sectionSettings
    )
    default boolean useQuetzals() {
        return true;
    }

    @ConfigItem(
        keyName = "useSpiritTrees",
        name = "Use spirit trees",
        description = "Whether to include spirit trees in the path",
        position = 13,
        section = sectionSettings
    )
    default boolean useSpiritTrees() {
        return true;
    }

    @ConfigItem(
        keyName = "useTeleportationItems",
        name = "Use teleportation items",
        description = "Whether to include teleportation items from the player's inventory and equipment.<br>" +
            "Options labelled (perm) only use permanent non-charge items.",
        position = 14,
        section = sectionSettings
    )
    default TeleportationItem useTeleportationItems() {
        return TeleportationItem.INVENTORY_NON_CONSUMABLE;
    }

    @ConfigItem(
        keyName = "useTeleportationBoxes",
        name = "Use teleportation boxes",
        description = "Whether to include teleportation boxes or mounted items in the path<br>" +
            "(e.g. the PoH jewellery box or PoH mounted glory amulet)",
        position = 15,
        section = sectionSettings
    )
    default boolean useTeleportationBoxes() {
        return true;
    }

    @ConfigItem(
        keyName = "useTeleportationLevers",
        name = "Use teleportation levers",
        description = "Whether to include teleportation levers in the path<br>" +
            "(e.g. the lever from Edgeville to Wilderness)",
        position = 16,
        section = sectionSettings
    )
    default boolean useTeleportationLevers() {
        return true;
    }

    @ConfigItem(
        keyName = "useTeleportationPortals",
        name = "Use teleportation portals",
        description = "Whether to include teleportation portals in the path<br>" +
            "(e.g. the portal from Ferox Enclave to Castle Wars or the PoH portals/nexus)",
        position = 17,
        section = sectionSettings
    )
    default boolean useTeleportationPortals() {
        return true;
    }

    @ConfigItem(
        keyName = "useTeleportationSpells",
        name = "Use teleportation spells",
        description = "Whether to include teleportation spells in the path",
        position = 18,
        section = sectionSettings
    )
    default boolean useTeleportationSpells() {
        return true;
    }

    @ConfigItem(
        keyName = "useTeleportationMinigames",
        name = "Use teleportation to minigames",
        description = "Whether to include teleportation to minigames/activities/grouping in the path<br>" +
            "(e.g. the Nightmare Zone minigame teleport). These teleports share a 20 minute cooldown.",
        position = 19,
        section = sectionSettings
    )
    default boolean useTeleportationMinigames() {
        return true;
    }

    @ConfigItem(
        keyName = "useWildernessObelisks",
        name = "Use wilderness obelisks",
        description = "Whether to include wilderness obelisks in the path",
        position = 20,
        section = sectionSettings
    )
    default boolean useWildernessObelisks() {
        return true;
    }

    @ConfigItem(
        keyName = "currencyThreshold",
        name = "Currency threshold",
        description = "The maximum amount of currency to use on a single transportation method." +
            "<br>The currencies affected by the threshold are coins, trading sticks, ecto-tokens and warrior guild tokens.",
        position = 21,
        section = sectionSettings
    )
    default int currencyThreshold() {
        return 100000;
    }

    @ConfigItem(
        keyName = "cancelInstead",
        name = "Cancel instead of recalculating",
        description = "Whether the path should be cancelled rather than recalculated " +
            "when the recalculate distance limit is exceeded",
        position = 22,
        section = sectionSettings
    )
    default boolean cancelInstead() {
        return false;
    }

    @Range(
        min = -1,
        max = 20000
    )
    @ConfigItem(
        keyName = "recalculateDistance",
        name = "Recalculate distance",
        description = "Distance from the path the player should be for it to be recalculated (-1 for never)",
        position = 23,
        section = sectionSettings
    )
    default int recalculateDistance() {
        return 10;
    }

    @Range(
        min = -1,
        max = 50
    )
    @ConfigItem(
        keyName = "finishDistance",
        name = "Finish distance",
        description = "Distance from the target tile at which the path should be ended (-1 for never)",
        position = 24,
        section = sectionSettings
    )
    default int reachedDistance() {
        return 5;
    }

    @ConfigItem(
        keyName = "showTileCounter",
        name = "Show tile counter",
        description = "Whether to display the number of tiles travelled, number of tiles remaining or disable counting",
        position = 25,
        section = sectionSettings
    )
    default TileCounter showTileCounter() {
        return TileCounter.DISABLED;
    }

    @ConfigItem(
        keyName = "tileCounterStep",
        name = "Tile counter step",
        description = "The number of tiles between the displayed tile counter numbers",
        position = 26,
        section = sectionSettings
    )
    default int tileCounterStep()
    {
        return 1;
    }

    @Units(
        value = Units.TICKS
    )
    @Range(
        min = 1,
        max = 30
    )
    @ConfigItem(
        keyName = "calculationCutoff",
        name = "Calculation cutoff",
        description = "The cutoff threshold in number of ticks (0.6 seconds) of no progress being<br>" +
            "made towards the path target before the calculation will be stopped",
        position = 27,
        section = sectionSettings
    )
    default int calculationCutoff()
    {
        return 5;
    }

    @ConfigItem(
        keyName = "showTransportInfo",
        name = "Show transport info",
        description = "Whether to display transport destination hint info, e.g. which chat option and text to click",
        position = 28,
        section = sectionSettings
    )
    default boolean showTransportInfo() {
        return true;
    }

    @ConfigSection(
        name = "Display",
        description = "Options for displaying the path on the world map, minimap and scene tiles",
        position = 29
    )
    String sectionDisplay = "sectionDisplay";

    @ConfigItem(
        keyName = "drawMap",
        name = "Draw path on world map",
        description = "Whether the path should be drawn on the world map",
        position = 30,
        section = sectionDisplay
    )
    default boolean drawMap() {
        return true;
    }

    @ConfigItem(
        keyName = "drawMinimap",
        name = "Draw path on minimap",
        description = "Whether the path should be drawn on the minimap",
        position = 31,
        section = sectionDisplay
    )
    default boolean drawMinimap() {
        return true;
    }

    @ConfigItem(
        keyName = "drawTiles",
        name = "Draw path on tiles",
        description = "Whether the path should be drawn on the game tiles",
        position = 32,
        section = sectionDisplay
    )
    default boolean drawTiles() {
        return true;
    }

    @ConfigItem(
        keyName = "pathStyle",
        name = "Path style",
        description = "Whether to display the path as tiles or a segmented line",
        position = 33,
        section = sectionDisplay
    )
    default TileStyle pathStyle() {
        return TileStyle.TILES;
    }

    @ConfigSection(
        name = "Colours",
        description = "Colours for the path map, minimap and scene tiles",
        position = 34
    )
    String sectionColours = "sectionColours";

    @Alpha
    @ConfigItem(
        keyName = "colourPath",
        name = "Path",
        description = "Colour of the path tiles on the world map, minimap and in the game scene",
        position = 35,
        section = sectionColours
    )
    default Color colourPath() {
        return new Color(255, 0, 0);
    }

    @Alpha
    @ConfigItem(
        keyName = "colourPathCalculating",
        name = "Calculating",
        description = "Colour of the path tiles while the pathfinding calculation is in progress," +
            "<br>and the colour of unused targets if there are more than a single target",
        position = 36,
        section = sectionColours
    )
    default Color colourPathCalculating() {
        return new Color(0, 0, 255);
    }

    @Alpha
    @ConfigItem(
        keyName = "colourTransports",
        name = "Transports",
        description = "Colour of the transport tiles",
        position = 37,
        section = sectionColours
    )
    default Color colourTransports() {
        return new Color(0, 255, 0, 128);
    }

    @Alpha
    @ConfigItem(
        keyName = "colourCollisionMap",
        name = "Collision map",
        description = "Colour of the collision map tiles",
        position = 38,
        section = sectionColours
    )
    default Color colourCollisionMap() {
        return new Color(0, 128, 255, 128);
    }

    @Alpha
    @ConfigItem(
        keyName = "colourText",
        name = "Text",
        description = "Colour of the text of the tile counter and fairy ring codes",
        position = 39,
        section = sectionColours
    )
    default Color colourText() {
        return Color.WHITE;
    }

    @ConfigSection(
        name = "Debug Options",
        description = "Various options for debugging",
        position = 40,
        closedByDefault = true
    )
    String sectionDebug = "sectionDebug";

    @ConfigItem(
        keyName = "drawTransports",
        name = "Draw transports",
        description = "Whether transports should be drawn",
        position = 41,
        section = sectionDebug
    )
    default boolean drawTransports() {
        return false;
    }

    @ConfigItem(
        keyName = "drawCollisionMap",
        name = "Draw collision map",
        description = "Whether the collision map should be drawn",
        position = 42,
        section = sectionDebug
    )
    default boolean drawCollisionMap() {
        return false;
    }

    @ConfigItem(
        keyName = "drawDebugPanel",
        name = "Show debug panel",
        description = "Toggles displaying the pathfinding debug stats panel",
        position = 43,
        section = sectionDebug
    )
    default boolean drawDebugPanel() {
        return false;
    }
}

package shortestpath;

import com.google.inject.Inject;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.JagexColors;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

public class PathMapTooltipOverlay extends Overlay {
    private static final int TOOLTIP_OFFSET_HEIGHT = 25;
    private static final int TOOLTIP_OFFSET_WIDTH = 15;
    private static final int TOOLTIP_PADDING_HEIGHT = 1;
    private static final int TOOLTIP_PADDING_WIDTH = 2;
    private static final int TOOLTIP_TEXT_OFFSET_HEIGHT = -2;

    private final Client client;
    private final ShortestPathPlugin plugin;

    @Inject
    private PathMapTooltipOverlay(Client client, ShortestPathPlugin plugin) {
        this.client = client;
        this.plugin = plugin;
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(Overlay.PRIORITY_HIGHEST);
        setLayer(OverlayLayer.MANUAL);
        drawAfterInterface(InterfaceID.WORLD_MAP);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!plugin.drawMap || client.getWidget(ComponentID.WORLD_MAP_MAPVIEW) == null) {
            return null;
        }

        if (plugin.getPathfinder() != null) {
            List<Integer> path = plugin.getPathfinder().getPath();
            Point cursorPos = client.getMouseCanvasPosition();
            for (int i = 0; i < path.size(); i++) {
                int nextPoint = WorldPointUtil.UNDEFINED;
                if (path.size() > i + 1) {
                    nextPoint = path.get(i + 1);
                }
                if (drawTooltip(graphics, cursorPos, path.get(i), nextPoint, i + 1)) {
                    return null;
                }
            }
            for (int target : plugin.getPathfinder().getTargets()) {
                if (path.size() > 0 && target != path.get(path.size() - 1)) {
                    drawTooltip(graphics, cursorPos, target, WorldPointUtil.UNDEFINED, -1);
                }
            }
        }

        return null;
    }

    private boolean drawTooltip(Graphics2D graphics, Point cursorPos, int point, int nextPoint, int n) {
        int offsetPoint = WorldPointUtil.dxdy(point, 1, -1);
        int startX = plugin.mapWorldPointToGraphicsPointX(point);
        int startY = plugin.mapWorldPointToGraphicsPointY(point);
        int endX = plugin.mapWorldPointToGraphicsPointX(offsetPoint);
        int endY = plugin.mapWorldPointToGraphicsPointY(offsetPoint);

        if (startX == Integer.MIN_VALUE || startY == Integer.MIN_VALUE ||
            endX == Integer.MIN_VALUE || endY == Integer.MIN_VALUE) {
            return false;
        }

        int width = endX - startX;

        if (cursorPos.getX() < (startX - width / 2) || cursorPos.getX() > (endX - width / 2) ||
            cursorPos.getY() < (startY - width / 2) || cursorPos.getY() > (endY - width / 2)) {
            return false;
        }

        List<String> rows = new ArrayList<>(Arrays.asList("Shortest path:",
            n < 0 ? "Unused target" : ("Step " + n + " of " + plugin.getPathfinder().getPath().size())));
        if (nextPoint != WorldPointUtil.UNDEFINED) {
            for (Transport transport : plugin.getTransports().getOrDefault(point, new HashSet<>())) {
                if (nextPoint == transport.getDestination()
                    && transport.getDisplayInfo() != null && !transport.getDisplayInfo().isEmpty()) {
                    rows.add(transport.getDisplayInfo());
                    break;
                }
            }
        }

        graphics.setFont(FontManager.getRunescapeFont());
        FontMetrics fm = graphics.getFontMetrics();
        int tooltipHeight = fm.getHeight();
        int tooltipWidth = rows.stream().map(fm::stringWidth).max(Integer::compareTo).get();

        int clippedHeight = tooltipHeight * rows.size() + TOOLTIP_PADDING_HEIGHT * 2;
        int clippedWidth = tooltipWidth + TOOLTIP_PADDING_WIDTH * 2;

        Rectangle worldMapBounds = client.getWidget(ComponentID.WORLD_MAP_MAPVIEW).getBounds();
        int worldMapRightBoundary = worldMapBounds.width + worldMapBounds.x;
        int worldMapBottomBoundary = worldMapBounds.height + worldMapBounds.y;

        int drawPointX = startX + TOOLTIP_OFFSET_WIDTH;
        int drawPointY = startY;
        if (drawPointX + clippedWidth > worldMapRightBoundary) {
            drawPointX = worldMapRightBoundary - clippedWidth;
        }
        if (drawPointY + clippedHeight > worldMapBottomBoundary) {
            drawPointY = startY - clippedHeight;
        }
        drawPointY += TOOLTIP_OFFSET_HEIGHT;

        int tooltipRectX = drawPointX - TOOLTIP_PADDING_WIDTH;
        int tooltipRectY = drawPointY - TOOLTIP_PADDING_HEIGHT;

        graphics.setColor(JagexColors.TOOLTIP_BACKGROUND);
        graphics.fillRect(tooltipRectX, tooltipRectY, clippedWidth, clippedHeight);

        graphics.setColor(JagexColors.TOOLTIP_BORDER);
        graphics.drawRect(tooltipRectX, tooltipRectY, clippedWidth, clippedHeight);

        graphics.setColor(JagexColors.TOOLTIP_TEXT);
        for (int i = 0; i < rows.size(); i++) {
            graphics.drawString(rows.get(i), drawPointX, drawPointY + TOOLTIP_TEXT_OFFSET_HEIGHT + (i + 1) * tooltipHeight);
        }

        return true;
    }
}

package shortestpath;

public enum TransportType {
    TRANSPORT,
    AGILITY_SHORTCUT,
    GRAPPLE_SHORTCUT,
    BOAT,
    CANOE,
    CHARTER_SHIP,
    SHIP,
    FAIRY_RING,
    GNOME_GLIDER,
    HOT_AIR_BALLOON,
    MINECART,
    QUETZAL,
    SPIRIT_TREE,
    TELEPORTATION_BOX,
    TELEPORTATION_ITEM,
    TELEPORTATION_LEVER,
    TELEPORTATION_MINIGAME,
    TELEPORTATION_PORTAL,
    TELEPORTATION_SPELL,
    WILDERNESS_OBELISK,
    ;

    /*
     * Indicates whether a TransportType is a teleport.
     * Levers, portals and wilderness obelisks are considered transports
     * and not teleports because they have a pre-defined origin and no
     * wilderness level limit.
     */
    public static boolean isTeleport(TransportType transportType) {
        if (transportType == null) {
            return false;
        }
        switch (transportType) {
            case TELEPORTATION_ITEM:
            case TELEPORTATION_MINIGAME:
            case TELEPORTATION_SPELL:
                return true;
            default:
                return false;
        }
    }
}

package shortestpath;

import net.runelite.api.Client;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import static net.runelite.api.Constants.CHUNK_SIZE;
import static net.runelite.api.Perspective.LOCAL_COORD_BITS;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

public class WorldPointUtil {
    public static final int UNDEFINED = -1;

    public static int packWorldPoint(WorldPoint point) {
        if (point == null) {
            return -1;
        }
        return packWorldPoint(point.getX(), point.getY(), point.getPlane());
    }

    // Packs a world point into a single int
    // First 15 bits are x, next 15 are y, last 2 bits are the plane
    public static int packWorldPoint(int x, int y, int plane) {
        return (x & 0x7FFF) | ((y & 0x7FFF) << 15) | ((plane & 0x3) << 30);
    }

    public static WorldPoint unpackWorldPoint(int packedPoint) {
        final int x = unpackWorldX(packedPoint);
        final int y = unpackWorldY(packedPoint);
        final int plane = unpackWorldPlane(packedPoint);
        return new WorldPoint(x, y, plane);
    }

    public static int unpackWorldX(int packedPoint) {
        return packedPoint & 0x7FFF;
    }

    public static int unpackWorldY(int packedPoint) {
        return (packedPoint >> 15) & 0x7FFF;
    }

    public static int unpackWorldPlane(int packedPoint) {
        return (packedPoint >> 30) & 0x3;
    }

    public static int dxdy(int packedPoint, int dx, int dy) {
        int x = unpackWorldX(packedPoint);
        int y = unpackWorldY(packedPoint);
        int z = unpackWorldPlane(packedPoint);
        return packWorldPoint(x + dx, y + dy, z);
    }

    public static int distanceBetween(int previousPacked, int currentPacked) {
        return distanceBetween(previousPacked, currentPacked, 1);
    }

    public static int distanceBetween2D(int previousPacked, int currentPacked) {
        return distanceBetween2D(previousPacked, currentPacked, 1);
    }

    public static int distanceBetween(int previousPacked, int currentPacked, int diagonal) {
        final int previousX = WorldPointUtil.unpackWorldX(previousPacked);
        final int previousY = WorldPointUtil.unpackWorldY(previousPacked);
        final int previousZ = WorldPointUtil.unpackWorldPlane(previousPacked);
        final int currentX = WorldPointUtil.unpackWorldX(currentPacked);
        final int currentY = WorldPointUtil.unpackWorldY(currentPacked);
        final int currentZ = WorldPointUtil.unpackWorldPlane(currentPacked);
        return distanceBetween(previousX, previousY, previousZ,
            currentX, currentY, currentZ, diagonal);
    }

    public static int distanceBetween2D(int previousPacked, int currentPacked, int diagonal) {
        final int previousX = WorldPointUtil.unpackWorldX(previousPacked);
        final int previousY = WorldPointUtil.unpackWorldY(previousPacked);
        final int currentX = WorldPointUtil.unpackWorldX(currentPacked);
        final int currentY = WorldPointUtil.unpackWorldY(currentPacked);
        return distanceBetween2D(previousX, previousY, currentX, currentY, diagonal);
    }

    public static int distanceBetween(int previousX, int previousY, int previousZ,
        int currentX, int currentY, int currentZ, int diagonal) {
        final int dz = Math.abs(previousZ - currentZ);

        if (dz != 0) {
            return Integer.MAX_VALUE;
        }

        return distanceBetween2D(previousX, previousY, currentX, currentY, diagonal);
    }

    public static int distanceBetween2D(int previousX, int previousY,
        int currentX, int currentY, int diagonal) {
        final int dx = Math.abs(previousX - currentX);
        final int dy = Math.abs(previousY - currentY);

        if (diagonal == 1) {
            return Math.max(dx, dy);
        } else if (diagonal == 2) {
            return dx + dy;
        }

        return Integer.MAX_VALUE;
    }

    public static int distanceBetween(WorldPoint previous, WorldPoint current) {
        return distanceBetween(previous, current, 1);
    }

    public static int distanceBetween(WorldPoint previous, WorldPoint current, int diagonal) {
        return distanceBetween(previous.getX(), previous.getY(), previous.getPlane(),
            current.getX(), current.getY(), current.getPlane(), diagonal);
    }

    // Matches WorldArea.distanceTo
    public static int distanceToArea(int packedPoint, WorldArea area) {
        final int plane = unpackWorldPlane(packedPoint);
        if (area.getPlane() != plane) {
            return Integer.MAX_VALUE;
        }
        return distanceToArea2D(packedPoint, area);
    }

    public static int distanceToArea2D(int packedPoint, WorldArea area) {
        final int y = unpackWorldY(packedPoint);
        final int x = unpackWorldX(packedPoint);
        final int areaMaxX = area.getX() + area.getWidth() - 1;
        final int areaMaxY = area.getY() + area.getHeight() - 1;
        final int dx = Math.max(Math.max(area.getX() - x, 0), x - areaMaxX);
        final int dy = Math.max(Math.max(area.getY() - y, 0), y - areaMaxY);

        return Math.max(dx, dy);
    }

    private static int rotate(int originalX, int originalY, int z, int rotation) {
        int chunkX = originalX & ~(CHUNK_SIZE - 1);
        int chunkY = originalY & ~(CHUNK_SIZE - 1);
        int x = originalX & (CHUNK_SIZE - 1);
        int y = originalY & (CHUNK_SIZE - 1);
        switch (rotation) {
            case 1:
                return packWorldPoint(chunkX + y, chunkY + (CHUNK_SIZE - 1 - x), z);
            case 2:
                return packWorldPoint(chunkX + (CHUNK_SIZE - 1 - x), chunkY + (CHUNK_SIZE - 1 - y), z);
            case 3:
                return packWorldPoint(chunkX + (CHUNK_SIZE - 1 - y), chunkY + x, z);
        }
        return packWorldPoint(originalX, originalY, z);
    }

    public static int fromLocalInstance(Client client, LocalPoint localPoint) {
        WorldView worldView = client.getWorldView(localPoint.getWorldView());
        int plane = worldView.getPlane();

        if (!worldView.isInstance()) {
            return packWorldPoint(
                (localPoint.getX() >> LOCAL_COORD_BITS) + worldView.getBaseX(),
                (localPoint.getY() >> LOCAL_COORD_BITS) + worldView.getBaseY(),
                plane);
        }

        int[][][] instanceTemplateChunks = worldView.getInstanceTemplateChunks();

        // get position in the scene
        int sceneX = localPoint.getSceneX();
        int sceneY = localPoint.getSceneY();

        // get chunk from scene
        int chunkX = sceneX / CHUNK_SIZE;
        int chunkY = sceneY / CHUNK_SIZE;

        // get the template chunk for the chunk
        int templateChunk = instanceTemplateChunks[plane][chunkX][chunkY];

        int rotation = templateChunk >> 1 & 0x3;
        int templateChunkY = (templateChunk >> 3 & 0x7FF) * CHUNK_SIZE;
        int templateChunkX = (templateChunk >> 14 & 0x3FF) * CHUNK_SIZE;
        int templateChunkPlane = templateChunk >> 24 & 0x3;

        // calculate world point of the template
        int x = templateChunkX + (sceneX & (CHUNK_SIZE - 1));
        int y = templateChunkY + (sceneY & (CHUNK_SIZE - 1));

        // create and rotate point back to 0, to match with template
        return rotate(x, y, templateChunkPlane, 4 - rotation);
    }

    public static Collection<Integer> toLocalInstance(Client client, int packedPoint) {
        WorldView worldView = client.getTopLevelWorldView();

        if (!worldView.isInstance()) {
            return Collections.singleton(packedPoint);
        }

        int baseX = worldView.getBaseX();
        int baseY = worldView.getBaseY();
        int worldPointX = unpackWorldX(packedPoint);
        int worldPointY = unpackWorldY(packedPoint);
        int worldPointPlane = unpackWorldPlane(packedPoint);

        int[][][] instanceTemplateChunks = worldView.getInstanceTemplateChunks();

        // find instance chunks using the template point. there might be more than one.
        List<Integer> worldPoints = new ArrayList<>();
        for (int z = 0; z < instanceTemplateChunks.length; z++) {
            for (int x = 0; x < instanceTemplateChunks[z].length; ++x) {
                for (int y = 0; y < instanceTemplateChunks[z][x].length; ++y) {
                    int chunkData = instanceTemplateChunks[z][x][y];
                    int rotation = chunkData >> 1 & 0x3;
                    int templateChunkY = (chunkData >> 3 & 0x7FF) * CHUNK_SIZE;
                    int templateChunkX = (chunkData >> 14 & 0x3FF) * CHUNK_SIZE;
                    int plane = chunkData >> 24 & 0x3;
                    if (worldPointX >= templateChunkX && worldPointX < templateChunkX + CHUNK_SIZE
                        && worldPointY >= templateChunkY && worldPointY < templateChunkY + CHUNK_SIZE
                        && plane == worldPointPlane) {
                        worldPoints.add(rotate(
                            baseX + x * CHUNK_SIZE + (worldPointX & (CHUNK_SIZE - 1)),
                            baseY + y * CHUNK_SIZE + (worldPointY & (CHUNK_SIZE - 1)),
                            z,
                            rotation));
                    }
                }
            }
        }
        return worldPoints;
    }

    private static boolean isInScene(WorldView worldView, int packedPoint) {
        int x = unpackWorldX(packedPoint);
        int y = unpackWorldY(packedPoint);

        int baseX = worldView.getBaseX();
        int baseY = worldView.getBaseY();

        int maxX = baseX + worldView.getSizeX();
        int maxY = baseY + worldView.getSizeY();

        return x >= baseX && x < maxX && y >= baseY && y < maxY;
    }

    public static LocalPoint toLocalPoint(Client client, int packedPoint) {
        WorldView worldView = client.getTopLevelWorldView();

        if (worldView.getPlane() != unpackWorldPlane(packedPoint)) {
            return null;
        }

        if (!isInScene(worldView, packedPoint)) {
            return null;
        }

        return new LocalPoint(
            (unpackWorldX(packedPoint) - worldView.getBaseX() << LOCAL_COORD_BITS) + (1 << LOCAL_COORD_BITS - 1),
            (unpackWorldY(packedPoint) - worldView.getBaseY() << LOCAL_COORD_BITS) + (1 << LOCAL_COORD_BITS - 1),
            worldView.getId());
    }
}

package shortestpath;

import lombok.Getter;

public enum TransportVarCheck {
    BIT_SET("&"),
    COOLDOWN_MINUTES("@"),
    EQUAL("="),
    GREATER(">"),
    SMALLER("<"),
    ;

    @Getter
    private final String code;

    TransportVarCheck(String code) {
        this.code = code;
    }
}

package shortestpath;

import com.google.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.Shape;
import java.util.List;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

public class PathMinimapOverlay extends Overlay {
    private final Client client;
    private final ShortestPathPlugin plugin;

    @Inject
    private PathMinimapOverlay(Client client, ShortestPathPlugin plugin) {
        this.client = client;
        this.plugin = plugin;
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(Overlay.PRIORITY_LOW);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!plugin.drawMinimap || plugin.getPathfinder() == null) {
            return null;
        }

        Shape minimapClipArea = plugin.getMinimapClipArea();
        if (minimapClipArea == null) {
            return null;
        } else {
            graphics.setClip(plugin.getMinimapClipArea());
        }
        graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);

        List<Integer> pathPoints = plugin.getPathfinder().getPath();
        Color pathColor = plugin.getPathfinder().isDone() ? plugin.colourPath : plugin.colourPathCalculating;
        for (int pathPoint : pathPoints) {
            if (WorldPointUtil.unpackWorldPlane(pathPoint) != client.getPlane()) {
                continue;
            }

            drawOnMinimap(graphics, pathPoint, pathColor);
        }
        for (int target : plugin.getPathfinder().getTargets()) {
            if (pathPoints.size() > 0 && target != pathPoints.get(pathPoints.size() - 1)) {
                drawOnMinimap(graphics, target, plugin.colourPathCalculating);
            }
        }

        return null;
    }

    private void drawOnMinimap(Graphics2D graphics, int location, Color color) {
        for (int point : WorldPointUtil.toLocalInstance(client, location)) {
            LocalPoint lp = WorldPointUtil.toLocalPoint(client, point);

            if (lp == null) {
                continue;
            }

            Point posOnMinimap = Perspective.localToMinimap(client, lp);

            if (posOnMinimap == null) {
                continue;
            }

            renderMinimapRect(client, graphics, posOnMinimap, color);
        }
    }

    public static void renderMinimapRect(Client client, Graphics2D graphics, Point center, Color color) {
        double angle = client.getCameraYawTarget() * Perspective.UNIT;
        double tileSize = client.getMinimapZoom();
        int x = (int) Math.round(center.getX() - tileSize / 2);
        int y = (int) Math.round(center.getY() - tileSize / 2);
        int width = (int) Math.round(tileSize);
        int height = (int) Math.round(tileSize);
        graphics.setColor(color);
        graphics.rotate(angle, center.getX(), center.getY());
        graphics.fillRect(x, y, width, height);
        graphics.rotate(-angle, center.getX(), center.getY());
    }
}

package pathfinder;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;
import shortestpath.ShortestPathPlugin;

public class ShortestPathPluginTest {
    public static void main(String[] args) throws Exception {
        ExternalPluginManager.loadBuiltin(ShortestPathPlugin.class);
        RuneLite.main(args);
    }
}

package pathfinder;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.junit.Assert;
import org.junit.Test;
import shortestpath.PrimitiveIntHashMap;
import shortestpath.Transport;

public class PrimitiveIntHashMapTests {
    @Test(expected=IllegalArgumentException.class)
    public void checkNullValueProhibited() {
        PrimitiveIntHashMap<Boolean> map = new PrimitiveIntHashMap<>(8);
        map.put(0, null);
    }

    @Test
    public void tryInsertTransports() {
        HashMap<Integer, Set<Transport>> transports = Transport.loadAllFromResources();
        PrimitiveIntHashMap<Set<Transport>> map = new PrimitiveIntHashMap<>(transports.size());

        for (Map.Entry<Integer, Set<Transport>> entry : transports.entrySet()) {
            int packedPoint = entry.getKey();
            map.put(packedPoint, entry.getValue());
        }

        // Append empty set
        for (Map.Entry<Integer, Set<Transport>> entry : transports.entrySet()) {
            int packedPoint = entry.getKey();
            map.put(packedPoint, entry.getValue());
            Assert.assertEquals("Appending empty should not overwrite", map.put(packedPoint, new HashSet<>()), map.get(packedPoint));
        }

        // Append non-empty set
        for (Map.Entry<Integer, Set<Transport>> entry : transports.entrySet()) {
            int packedPoint = entry.getKey();
            map.put(packedPoint, entry.getValue());
            int sizeBefore = map.get(packedPoint).size();
            Set<Transport> nonEmpty = new HashSet<>();
            nonEmpty.add(null);
            map.put(packedPoint, nonEmpty);
            int sizeAfter = map.get(packedPoint).size();
            Assert.assertEquals("Appending non-empty should not overwrite", sizeBefore + 1, sizeAfter);
        }

        for (Map.Entry<Integer, Set<Transport>> entry : transports.entrySet()) {
            int packedPoint = entry.getKey();
            Assert.assertEquals("World Point " + entry.getKey() + " did not map to the correct value", entry.getValue(), map.get(packedPoint));
        }
    }

    @Test
    public void tryGrowMap() {
        PrimitiveIntHashMap<Integer> map = new PrimitiveIntHashMap<>(8);
        for (int i = 0; i < 1024; ++i) {
            map.put(i, i);
        }

        Assert.assertEquals(1024, map.size());

        for (int i = 0; i < 1024; ++i) {
            Assert.assertEquals(i, map.get(i).intValue());
        }
    }

    @Test
    public void checkNonexistentEntries() {
        PrimitiveIntHashMap<Integer> map = new PrimitiveIntHashMap<>(8);
        Assert.assertNull(map.get(667215));
    }

    @Test
    public void tryOverwriteValues() {
        final int keyStart = 9875643; // Use keys that aren't 0 or all low bits

        PrimitiveIntHashMap<Integer> map = new PrimitiveIntHashMap<>(2048);
        for (int i = 0; i < 1024; ++i) {
            map.put(i + keyStart, i);
        }

        // Overwrite values
        for (int i = 0; i < 1024; ++i) {
            map.put(i + keyStart, i + 1);
        }

        // Now check overwritten values stuck
        for (int i = 0; i < 1024; ++i) {
            Assert.assertEquals(i + 1, map.get(i + keyStart).intValue());
        }
    }

    @Test
    public void checkClearMap() {
        PrimitiveIntHashMap<Integer> map = new PrimitiveIntHashMap<>(8);
        for (int i = 0; i < 1024; ++i) {
            map.put(i, i);
        }

        Assert.assertEquals(1024, map.size());
        Assert.assertEquals(364, map.get(364).intValue());

        map.clear();
        Assert.assertEquals(0, map.size());
        Assert.assertNull(map.get(364));
    }

    @Test
    public void checkInsertOrderIrrelevant() {
        final int keyStart = 9875643; // Use keys that aren't 0 or all low bits
        PrimitiveIntHashMap<Integer> mapForward = new PrimitiveIntHashMap<>(8);
        PrimitiveIntHashMap<Integer> mapReversed = new PrimitiveIntHashMap<>(8);
        for (int i = 0; i < 1024; ++i) {
            mapForward.put(i + keyStart, i);
            mapReversed.put(1023 - i + keyStart, 1023 - i);
        }

        for (int i = 0; i < 1024; ++i) {
            Assert.assertEquals(mapForward.get(i + keyStart), mapReversed.get(i + keyStart));
        }
    }
}

package pathfinder;

import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import org.junit.Assert;
import org.junit.Test;

import java.util.ArrayList;
import java.util.List;

import static shortestpath.WorldPointUtil.distanceBetween;
import static shortestpath.WorldPointUtil.distanceToArea;
import static shortestpath.WorldPointUtil.packWorldPoint;
import static shortestpath.WorldPointUtil.unpackWorldPlane;
import static shortestpath.WorldPointUtil.unpackWorldPoint;
import static shortestpath.WorldPointUtil.unpackWorldX;
import static shortestpath.WorldPointUtil.unpackWorldY;

public class WorldPointTests {
    private static final WorldArea WILDERNESS_ABOVE_GROUND = new WorldArea(2944, 3523, 448, 448, 0);

    @Test
    public void testDistanceToArea() {
        List<WorldPoint> testPoints = new ArrayList<>(10);
        testPoints.add(new WorldPoint(2900, 3500, 0));
        testPoints.add(new WorldPoint(3000, 3500, 0));
        testPoints.add(new WorldPoint(3600, 3500, 0));
        testPoints.add(new WorldPoint(2900, 3622, 0));
        testPoints.add(new WorldPoint(3000, 3622, 0));
        testPoints.add(new WorldPoint(3600, 3622, 0));
        testPoints.add(new WorldPoint(2900, 4300, 0));
        testPoints.add(new WorldPoint(3000, 4300, 0));
        testPoints.add(new WorldPoint(3600, 4300, 0));
        testPoints.add(new WorldPoint(3600, 4200, 1));

        for (WorldPoint point : testPoints) {
            final int areaDistance = WILDERNESS_ABOVE_GROUND.distanceTo(point);
            final int packedPoint = packWorldPoint(point);
            final int worldUtilDistance = distanceToArea(packedPoint, WILDERNESS_ABOVE_GROUND);
            Assert.assertEquals("Calculating distance to " + point + " failed", areaDistance, worldUtilDistance);
        }
    }

    @Test
    public void testWorldPointPacking() {
        WorldPoint point = new WorldPoint(13, 24685, 1);

        final int packedPoint = packWorldPoint(point);
        Assert.assertEquals(0x7036800D, packedPoint); // Manually verified

        final int unpackedX = unpackWorldX(packedPoint);
        Assert.assertEquals(point.getX(), unpackedX);

        final int unpackedY = unpackWorldY(packedPoint);
        Assert.assertEquals(point.getY(), unpackedY);

        final int unpackedPlane = unpackWorldPlane(packedPoint);
        Assert.assertEquals(point.getPlane(), unpackedPlane);

        WorldPoint unpackedPoint = unpackWorldPoint(packedPoint);
        Assert.assertEquals(point, unpackedPoint);
    }

    @Test
    public void testDistanceBetween() {
        WorldPoint pointA = new WorldPoint(13, 24685, 1);
        WorldPoint pointB = new WorldPoint(29241, 3384, 1);
        WorldPoint pointC = new WorldPoint(292, 3384, 0); // Test point on different plane

        Assert.assertEquals(0, distanceBetween(pointA, pointA));
        Assert.assertEquals(29228, distanceBetween(pointA, pointB));
        Assert.assertEquals(29228, distanceBetween(pointB, pointA));
        Assert.assertEquals(Integer.MAX_VALUE, distanceBetween(pointA, pointC));

        // with diagonal = 2
        Assert.assertEquals(0, distanceBetween(pointA, pointA, 2));
        Assert.assertEquals(50529, distanceBetween(pointA, pointB, 2));
        Assert.assertEquals(50529, distanceBetween(pointB, pointA, 2));
        Assert.assertEquals(Integer.MAX_VALUE, distanceBetween(pointB, pointC, 2));
    }

    @Test
    public void testPackedDistanceBetween() {
        WorldPoint pointA = new WorldPoint(13, 24685, 1);
        WorldPoint pointB = new WorldPoint(29241, 3384, 1);
        WorldPoint pointC = new WorldPoint(292, 3384, 0); // Test point on different plane
        final int packedPointA = packWorldPoint(pointA);
        final int packedPointB = packWorldPoint(pointB);
        final int packedPointC = packWorldPoint(pointC);

        Assert.assertEquals(0, distanceBetween(packedPointA, packedPointA));
        Assert.assertEquals(29228, distanceBetween(packedPointA, packedPointB));
        Assert.assertEquals(29228, distanceBetween(packedPointB, packedPointA));
        Assert.assertEquals(Integer.MAX_VALUE, distanceBetween(packedPointA, packedPointC));

        // with diagonal = 2
        Assert.assertEquals(0, distanceBetween(packedPointA, packedPointA, 2));
        Assert.assertEquals(50529, distanceBetween(packedPointA, packedPointB, 2));
        Assert.assertEquals(50529, distanceBetween(packedPointB, packedPointA, 2));
        Assert.assertEquals(Integer.MAX_VALUE, distanceBetween(packedPointB, packedPointC, 2));
    }

    @Test
    public void testMaxWorldPoint() {
        Assert.assertEquals(packWorldPoint(-1, -1, -1), -1);
        Assert.assertEquals(packWorldPoint(-1, -1, 1), 2147483647);
    }
}

package pathfinder;

import java.util.Map;
import java.util.Set;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.Quest;
import net.runelite.api.QuestState;
import net.runelite.api.Skill;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import shortestpath.TeleportationItem;
import shortestpath.ItemVariations;
import shortestpath.ShortestPathConfig;
import shortestpath.Transport;
import shortestpath.TransportItems;
import shortestpath.TransportType;
import shortestpath.WorldPointUtil;
import shortestpath.pathfinder.Pathfinder;
import shortestpath.pathfinder.PathfinderConfig;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class PathfinderTest {
    private static final Map<Integer, Set<Transport>> transports = Transport.loadAllFromResources();

    private PathfinderConfig pathfinderConfig;

    @Mock
    Client client;

    @Mock
    ItemContainer inventory;

    @Mock
    ShortestPathConfig config;

    @Before
    public void before() {
        when(config.calculationCutoff()).thenReturn(30);
        when(config.currencyThreshold()).thenReturn(10000000);
    }

    @Test
    public void testAgilityShortcuts() {
        when(config.useAgilityShortcuts()).thenReturn(true);
        setupInventory(
            new Item(ItemID.ROPE, 1),
            new Item(ItemID.DEATH_CLIMBINGBOOTS, 1));
        testTransportLength(2, TransportType.AGILITY_SHORTCUT);
    }

    @Test
    public void testGrappleShortcuts() {
        when(config.useGrappleShortcuts()).thenReturn(true);
        setupInventory(
            new Item(ItemID.XBOWS_CROSSBOW_ADAMANTITE, 1),
            new Item(ItemID.XBOWS_GRAPPLE_TIP_BOLT_MITHRIL_ROPE, 1));
        testTransportLength(2, TransportType.GRAPPLE_SHORTCUT);
    }

    @Test
    public void testBoats() {
        when(config.useBoats()).thenReturn(true);
        setupInventory(
            new Item(ItemID.COINS, 10000),
            new Item(ItemID.ECTOTOKEN, 25));
        testTransportLength(2, TransportType.BOAT);
    }

    @Test
    public void testCanoes() {
        when(config.useCanoes()).thenReturn(true);
        setupInventory(new Item(ItemID.BRONZE_AXE, 1));
        testTransportLength(2, TransportType.CANOE);
    }

    @Test
    public void testCharterShips() {
        when(config.useCharterShips()).thenReturn(true);
        setupInventory(new Item(ItemID.COINS, 100000));
        testTransportLength(2, TransportType.CHARTER_SHIP);
    }

    @Test
    public void testShips() {
        when(config.useShips()).thenReturn(true);
        setupInventory(new Item(ItemID.COINS, 10000));
        testTransportLength(2, TransportType.SHIP);
    }

    @Test
    public void testFairyRings() {
        when(config.useFairyRings()).thenReturn(true);
        testTransportLength(2, TransportType.FAIRY_RING);
    }

    @Test
    public void testGnomeGliders() {
        when(config.useGnomeGliders()).thenReturn(true);
        testTransportLength(2, TransportType.GNOME_GLIDER);
    }

    @Test
    public void testHotAirBalloons() {
        when(config.useHotAirBalloons()).thenReturn(true);
        setupInventory(
            new Item(ItemID.LOGS, 2),
            new Item(ItemID.OAK_LOGS, 1),
            new Item(ItemID.WILLOW_LOGS, 1),
            new Item(ItemID.YEW_LOGS, 1),
            new Item(ItemID.MAGIC_LOGS, 1));
        testTransportLength(2, TransportType.HOT_AIR_BALLOON);
    }

    @Test
    public void testMinecarts() {
        when(config.useMinecarts()).thenReturn(true);
        setupInventory(new Item(ItemID.COINS, 1000));
        testTransportLength(2, TransportType.MINECART);
    }

    @Test
    public void testQuetzals() {
        when(config.useQuetzals()).thenReturn(true);
        testTransportLength(2, TransportType.QUETZAL);
    }

    @Test
    public void testSpiritTrees() {
        when(config.useSpiritTrees()).thenReturn(true);
        when(client.getVarbitValue(any(Integer.class))).thenReturn(20);
        testTransportLength(2, TransportType.SPIRIT_TREE);
    }

    @Test
    public void testTeleportationBoxes() {
        when(config.useTeleportationBoxes()).thenReturn(true);
        testTransportLength(2, TransportType.TELEPORTATION_BOX);
    }

    @Test
    public void testTeleportationLevers() {
        when(config.useTeleportationLevers()).thenReturn(true);
        testTransportLength(2, TransportType.TELEPORTATION_LEVER);
    }

    @Test
    public void testTeleportationMinigames() {
        when(config.useTeleportationMinigames()).thenReturn(true);
        when(config.useTeleportationSpells()).thenReturn(false);
        when(client.getVarbitValue(any(Integer.class))).thenReturn(0);
        when(client.getVarpValue(any(Integer.class))).thenReturn(0);
        testTransportLength(2,
            WorldPointUtil.packWorldPoint(3440, 3334, 0),  // Nature Spirit Grotto
            WorldPointUtil.packWorldPoint(2658, 3157, 0)); // Fishing Trawler
        testTransportLength(3,
            WorldPointUtil.packWorldPoint(3136, 3525, 0),  // In wilderness level 1
            WorldPointUtil.packWorldPoint(2658, 3157, 0)); // Fishing Trawler
    }

    @Test
    public void testTeleportationPortals() {
        when(config.useTeleportationPortals()).thenReturn(true);
        testTransportLength(2, TransportType.TELEPORTATION_PORTAL);
    }

    @Test
    public void testWildernessObelisks() {
        when(config.useWildernessObelisks()).thenReturn(true);
        testTransportLength(2, TransportType.WILDERNESS_OBELISK);
    }

    @Test
    public void testAgilityShortcutAndTeleportItem() {
        when(config.useAgilityShortcuts()).thenReturn(true);
        when(config.useTeleportationItems()).thenReturn(TeleportationItem.ALL);
        // Draynor Manor to Champions Guild via several stepping stones, but
        // enabling Combat bracelet teleport should not priotize over stepping stones
        // 5 tiles is using the stepping stones
        // ~40 tiles is using the combat bracelet teleport to Champions Guild
        // >100 tiles is walking around the river via Barbarian Village
        testTransportLength(6,
            WorldPointUtil.packWorldPoint(3149, 3363, 0),
            WorldPointUtil.packWorldPoint(3154, 3363, 0));
    }

    @Test
    public void testChronicle() {
        // South of river south of Champions Guild to Chronicle teleport destination
        testTransportLength(2,
            WorldPointUtil.packWorldPoint(3199, 3336, 0),
            WorldPointUtil.packWorldPoint(3200, 3355, 0),
            TeleportationItem.ALL);
    }

    @Test
    public void testVarrockTeleport() {
        // West of Varrock teleport destination to Varrock teleport destination
        when(config.useTeleportationSpells()).thenReturn(true);

        // With magic level 1 and no item requirements
        testTransportLength(4,
            WorldPointUtil.packWorldPoint(3216, 3424, 0),
            WorldPointUtil.packWorldPoint(3213, 3424, 0),
            TeleportationItem.NONE,
            1);

        // With magic level 99 and magic runes
        setupInventory(
            new Item(ItemID.LAWRUNE, 1),
            new Item(ItemID.AIRRUNE, 3),
            new Item(ItemID.FIRERUNE, 1));
        testTransportLength(2,
            WorldPointUtil.packWorldPoint(3216, 3424, 0),
            WorldPointUtil.packWorldPoint(3213, 3424, 0),
            TeleportationItem.INVENTORY,
            99);
    }

    @Test
    public void testPathViaOtherPlane() {
        // Shortest path from east to west Keldagrim is via the first floor
        // of the Keldagrim Palace, and not via the bridge to the north
        testTransportLength(64,
            WorldPointUtil.packWorldPoint(2894, 10199, 0), // east
            WorldPointUtil.packWorldPoint(2864, 10199, 0)); // west

        testTransportLength(64,
            WorldPointUtil.packWorldPoint(2864, 10199, 0), // west
            WorldPointUtil.packWorldPoint(2894, 10199, 0)); // east
    }

    @Test
    public void testImpossibleCharterShips() {
        // Shortest path for impossible charter ships has length 3 and goes
        // via an intermediate charter ship and not directly with length 2
        when(config.useCharterShips()).thenReturn(true);
        setupInventory(new Item(ItemID.COINS, 1000000));

        testTransportMinimumLength(3,
            WorldPointUtil.packWorldPoint(1455, 2968, 0), // Aldarin
            WorldPointUtil.packWorldPoint(1514, 2971, 0)); // Sunset Coast
        testTransportMinimumLength(3,
            WorldPointUtil.packWorldPoint(1514, 2971, 0), // Sunset Coast
            WorldPointUtil.packWorldPoint(1455, 2968, 0)); // Aldarin

        testTransportMinimumLength(3,
            WorldPointUtil.packWorldPoint(3702, 3503, 0), // Port Phasmatys
            WorldPointUtil.packWorldPoint(3671, 2931, 0)); // Mos Le'Harmless
        testTransportMinimumLength(3,
            WorldPointUtil.packWorldPoint(3671, 2931, 0), // Mos Le'Harmless
            WorldPointUtil.packWorldPoint(3702, 3503, 0)); // Port Phasmatys

        testTransportMinimumLength(3,
            WorldPointUtil.packWorldPoint(1808, 3679, 0), // Port Piscarilius
            WorldPointUtil.packWorldPoint(1496, 3403, 0)); // Land's End
        testTransportMinimumLength(3,
            WorldPointUtil.packWorldPoint(1496, 3403, 0), // Land's End
            WorldPointUtil.packWorldPoint(1808, 3679, 0)); // Port Piscarilius

        testTransportMinimumLength(3,
            WorldPointUtil.packWorldPoint(3038, 3192, 0), // Port Sarim
            WorldPointUtil.packWorldPoint(1496, 3403, 0)); // Land's End
        testTransportMinimumLength(3,
            WorldPointUtil.packWorldPoint(1496, 3403, 0), // Land's End
            WorldPointUtil.packWorldPoint(3038, 3192, 0)); // Port Sarim

        testTransportMinimumLength(3,
            WorldPointUtil.packWorldPoint(3038, 3192, 0), // Port Sarim
            WorldPointUtil.packWorldPoint(2954, 3158, 0)); // Musa Point
        testTransportMinimumLength(3,
            WorldPointUtil.packWorldPoint(2954, 3158, 0), // Musa Point
            WorldPointUtil.packWorldPoint(3038, 3192, 0)); // Port Sarim

        testTransportMinimumLength(3,
            WorldPointUtil.packWorldPoint(3038, 3192, 0), // Port Sarim
            WorldPointUtil.packWorldPoint(1808, 3679, 0)); // Port Piscarilius
        testTransportMinimumLength(3,
            WorldPointUtil.packWorldPoint(1808, 3679, 0), // Port Piscarilius
            WorldPointUtil.packWorldPoint(3038, 3192, 0)); // Port Sarim
    }

    @Test
    public void testNumberOfGnomeGliders() {
        // All permutations of gnome glider transports are resolved from origins and destinations
        int actualCount = 0;
        for (int origin : transports.keySet()) {
            for (Transport transport : transports.get(origin)) {
                if (TransportType.GNOME_GLIDER.equals(transport.getType())) {
                    actualCount++;
                }
            }
        }
        /* 
         * Info:
         * NB: Lemanto Andra (Digsite) can only be destination and not origin
         * single_glider_origin_locations * (number_of_gnome_gliders - 1)
         *   1 * 6   // Ta Quir Priw (Gnome Stronghold)
         * + 3 * 6   // Gandius (Karamja)
         * + 3 * 6   // Kar-Hewo (Al-Kharid)
         * + 2 * 6   // Sindarpos (White Wolf Mountain)
         * + 3 * 6   // Lemantolly Undri (Feldip Hills)
         * + 3 * 6   // Ookookolly Undri (Ape Atoll)
         * = 90
         */
        assertEquals(90, actualCount);
    }

    @Test
    public void testNumberOfHotAirBalloons() {
        // All permutations of hot air balloon transports are resolved from origins and destinations
        int actualCount = 0;
        for (int origin : transports.keySet()) {
            for (Transport transport : transports.get(origin)) {
                if (TransportType.HOT_AIR_BALLOON.equals(transport.getType())) {
                    actualCount++;
                }
            }
        }
        /* 
         * Info:
         * single_hot_air_balloon_origin_locations * (number_of_hot_air_balloons - 1)
         *   6 * 5   // Entrana
         * + 8 * 5   // Taverley
         * + 8 * 5   // Crafting Guild
         * + 8 * 5   // Varrock
         * + 7 * 5   // Castle Wars
         * + 8 * 5   // Grand Tree
         * = 225
         */
        assertEquals(225, actualCount);
    }

    @Test
    public void testNumberOfQuetzals() {
        // All but 2 permutations of quetzal transports are resolved from origins and destinations
        int actualCount = 0;
        for (int origin : transports.keySet()) {
            for (Transport transport : transports.get(origin)) {
                if (TransportType.QUETZAL.equals(transport.getType())) {
                    actualCount++;
                }
            }
        }
        /*
         * Info:
         * NB: Primio can only be used between Varrock and Civitas illa Fortis
         * single_quetzal_origin_locations * (number_of_quetzals - 1) + 2
         *   1 * 10 // Aldarin
         * + 1 * 10 // Civitas illa Fortis
         * + 1 * 10 // Hunter Guild
         * + 1 * 10 // Quetzacalli Gorge
         * + 1 * 10 // Sunset Coast
         * + 1 * 10 // The Teomat
         * + 1 * 10 // Fortis Colosseum
         * + 1 * 10 // Outer Fortis
         * + 1 * 10 // Colossal Wyrm Remains
         * + 1 * 10 // Cam Torum
         * + 1 * 10 // Salvager Overlook
         * + 1 // Varrock -> Civitas illa Fortis
         * + 1 // Civitas illa Fortis -> Varrock
         * = 110 + 2
         * = 112
         */
        assertEquals(112, actualCount);
    }

    @Test
    public void testNumberOfSpiritTrees() {
        // All permutations of spirit tree transports are resolved from origins and destinations
        int actualCount = 0;
        for (int origin : transports.keySet()) {
            for (Transport transport : transports.get(origin)) {
                if (TransportType.SPIRIT_TREE.equals(transport.getType())) {
                    actualCount++;
                }
            }
        }
        /*
         * Info:
         * single_tree_origin_locations * (number_of_spirit_trees - 1)
         *   15 * 11   // Tree Gnome Village
         * + 14 * 11   // Gnome Stronghold
         * +  8 * 11   // Battlefield of Khazard
         * +  8 * 11   // Grand Exchange
         * +  8 * 11   // Feldip Hills
         * +  7 * 11   // Prifddinas
         * + 12 * 11   // Port Sarim
         * + 12 * 11   // Etceteria
         * + 12 * 11   // Brimhaven
         * + 12 * 11   // Hosidius
         * + 12 * 11   // Farming Guild
         * +  0 * 11   // Player-owned house
         * + 12 * 11   // Poison Waste
         * = 1452
         */
        assertEquals(1452, actualCount);
    }

    @Test
    public void testNumberOfCharterShips() {
        int actualCount = 0;
        for (int origin : transports.keySet()) {
            for (Transport transport : transports.get(origin)) {
                if (TransportType.CHARTER_SHIP.equals(transport.getType())) {
                    actualCount++;
                }
            }
        }
        /*
         * Info:
         * There are currently 16 unique charter ship origin/destinations.
         * If every combination was possible then it would be 16^2 = 256.
         * It is impossible to travel from and to the same place, so subtract 16.
         * It is also impossible to travel between certain places, presumably
         * because the distance between them is too small. Currently 12 of these.
         */
        assertEquals(16 * 16 - 16 - 12, actualCount);
    }

    @Test
    public void testTransportItems() {
        TransportItems actual = null;
        for (Transport transport : transports.get(Transport.UNDEFINED_ORIGIN)) {
            if ("Varrock Teleport".equals(transport.getDisplayInfo())) {
                actual = transport.getItemRequirements();
                break;
            }
        }
        if (actual != null) {
            TransportItems expected = new TransportItems(
                new int[][]{
                    ItemVariations.AIR_RUNE.getIds(),
                    ItemVariations.FIRE_RUNE.getIds(),
                    ItemVariations.LAW_RUNE.getIds()},
                new int[][]{
                    ItemVariations.STAFF_OF_AIR.getIds(),
                    ItemVariations.STAFF_OF_FIRE.getIds(), null},
                new int[][]{null, ItemVariations.TOME_OF_FIRE.getIds(), null},
                new int[]{3, 1, 1});
            assertEquals(expected, actual);
        }
    }

    @Test
    public void testIsInWilderness() {
        assertEquals(true, PathfinderConfig.isInWilderness(
            WorldPointUtil.packWorldPoint(3339, 3696, 0))); // Green dragons
        assertEquals(false, PathfinderConfig.isInWilderness(
            WorldPointUtil.packWorldPoint(3134, 3629, 0))); // Ferox Enclave
        assertEquals(true, PathfinderConfig.isInWilderness(
            WorldPointUtil.packWorldPoint(3089, 9957, 0))); // Edgeville Dungeon
        assertEquals(true, PathfinderConfig.isInWilderness(
            WorldPointUtil.packWorldPoint(3039, 10260, 0))); // Lava Maze Dungeon
        assertEquals(false, PathfinderConfig.isInWilderness(
            WorldPointUtil.packWorldPoint(3009, 3531, 0))); // Non-wildy peninsula
        assertEquals(true, PathfinderConfig.isInWilderness(
            WorldPointUtil.packWorldPoint(3023, 3626, 1))); // Upstairs in Dark Warriors' Fortress
    }

    private void setupConfig(QuestState questState, int skillLevel, TeleportationItem useTeleportationItems) {
        pathfinderConfig = spy(new PathfinderConfig(client, config));

        when(client.getGameState()).thenReturn(GameState.LOGGED_IN);
        when(client.getClientThread()).thenReturn(Thread.currentThread());
        when(client.getBoostedSkillLevel(any(Skill.class))).thenReturn(skillLevel);
        when(config.useTeleportationItems()).thenReturn(useTeleportationItems);
        doReturn(true).when(pathfinderConfig).varbitChecks(any(Transport.class));
        doReturn(true).when(pathfinderConfig).varPlayerChecks(any(Transport.class));
        doReturn(questState).when(pathfinderConfig).getQuestState(any(Quest.class));

        pathfinderConfig.refresh();
    }

    private void setupInventory(Item... items) {
        doReturn(inventory).when(client).getItemContainer(InventoryID.INVENTORY);
        doReturn(items).when(inventory).getItems();
    }

    private void testTransportLength(int expectedLength, int origin, int destination) {
        testTransportLength(expectedLength, origin, destination, TeleportationItem.NONE, 99);
    }

    private void testTransportLength(int expectedLength, int origin, int destination,
        TeleportationItem useTeleportationItems) {
        testTransportLength(expectedLength, origin, destination, useTeleportationItems, 99);
    }

    private void testTransportLength(int expectedLength, int origin, int destination,
        TeleportationItem useTeleportationItems, int skillLevel) {
        setupConfig(QuestState.FINISHED, skillLevel, useTeleportationItems);
        assertEquals(expectedLength, calculatePathLength(origin, destination));
        System.out.println("Successfully completed transport length test from " +
            "(" + WorldPointUtil.unpackWorldX(origin) +
            ", " + WorldPointUtil.unpackWorldY(origin) +
            ", " + WorldPointUtil.unpackWorldPlane(origin) + ") to " +
            "(" + WorldPointUtil.unpackWorldX(destination) +
            ", " + WorldPointUtil.unpackWorldY(destination) +
            ", " + WorldPointUtil.unpackWorldPlane(destination) + ")");
    }

    private void testTransportLength(int expectedLength, TransportType transportType) {
        testTransportLength(expectedLength, transportType, QuestState.FINISHED, 99, TeleportationItem.NONE);
    }

    private void testTransportLength(int expectedLength, TransportType transportType, QuestState questState, int skillLevel,
        TeleportationItem useTeleportationItems) {
        setupConfig(questState, skillLevel, useTeleportationItems);

        int counter = 0;
        for (int origin : transports.keySet()) {
            for (Transport transport : transports.get(origin)) {
                if (transportType.equals(transport.getType())) {
                    counter++;
                    assertEquals(transport.toString(), expectedLength, calculateTransportLength(transport));
                }
            }
        }

        assertTrue("No tests were performed", counter > 0);
        System.out.println(String.format("Successfully completed %d " + transportType + " transport length tests", counter));
    }

    private void testTransportMinimumLength(int minimumLength, int origin, int destination) {
        setupConfig(QuestState.FINISHED, 99, TeleportationItem.ALL);
        int actualLength = calculatePathLength(origin, destination);
        assertTrue("An impossible transport was used with length " + actualLength, actualLength >= minimumLength);
        System.out.println("Successfully completed transport length test from " +
            "(" + WorldPointUtil.unpackWorldX(origin) +
            ", " + WorldPointUtil.unpackWorldY(origin) +
            ", " + WorldPointUtil.unpackWorldPlane(origin) + ") to " +
            "(" + WorldPointUtil.unpackWorldX(destination) +
            ", " + WorldPointUtil.unpackWorldY(destination) +
            ", " + WorldPointUtil.unpackWorldPlane(destination) + ")" +
            " with actual length = " + actualLength + " >= minimum length = " + minimumLength);
    }

    private int calculateTransportLength(Transport transport) {
        return calculatePathLength(transport.getOrigin(), transport.getDestination());
    }

    private int calculatePathLength(int origin, int destination) {
        Pathfinder pathfinder = new Pathfinder(pathfinderConfig, origin, Set.of(destination));
        pathfinder.run();
        return pathfinder.getPath().size();
    }
}

package pathfinder;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

public class TransportJsConverter {
    public static void main(String[] args) throws IOException {
        for (String transport : Files.readAllLines(Paths.get("src/main/resources/transports.txt"))) {
            if (transport.startsWith("#") || transport.isEmpty()) {
                continue;
            }

            transport = transport.split(" \"")[0];
            transport = transport.substring(0, transport.lastIndexOf(" "));
            String[] parts = transport.split(" ");

            String p1 = "new Position(" + parts[0] + ", " + parts[1] + ", " + parts[2] + ")";
            String p2 = "new Position(" + parts[3] + ", " + parts[4] + ", " + parts[5] + ")";
            StringBuilder rest = new StringBuilder();

            for (int i = 6; i < parts.length; i++) {
                rest.append(parts[i]);
                if (i < parts.length - 1) rest.append(" ");
            }

            System.out.println("this.addTransport(" + p1 + ", " + p2 + ", \"" + rest.toString() + "\");");
        }
    }
}

package pathfinder;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;
import shortestpath.ShortestPathPlugin;

public class PluginMessageTest {
    public static void main(String[] args) throws Exception {
        ExternalPluginManager.loadBuiltin(ShortestPathPlugin.class);
        ExternalPluginManager.loadBuiltin(PluginMessageTestPlugin.class);
        RuneLite.main(args);
    }
}

package pathfinder;

import java.awt.Color;
import java.awt.Rectangle;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.KeyCode;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.Point;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.MenuOpened;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.worldmap.WorldMap;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.PluginMessage;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.JagexColors;
import net.runelite.client.util.ColorUtil;

@PluginDescriptor(
    name = "Shortest Path Test",
    description = "Test the Shortest Path Plugin Message events"
)
public class PluginMessageTestPlugin extends Plugin {
    private static final String PLUGIN_MESSAGE_NAME = "shortestpath";
    private static final String PLUGIN_MESSAGE_PATH = "path";
    private static final String PLUGIN_MESSAGE_CLEAR = "clear";
    private static final String PLUGIN_MESSAGE_START = "start";
    private static final String PLUGIN_MESSAGE_TARGET = "target";
    private static final String PLUGIN_MESSAGE_CONFIG_OVERRIDE = "config";
    private static final String CLEAR = "Clear";
    private static final String PATH = ColorUtil.wrapWithColorTag("Path (PluginMessage)", JagexColors.MENU_TARGET);
    private static final String SET = "Set";
    private static final String START_INT = ColorUtil.wrapWithColorTag("Start Integer (PluginMessage)", JagexColors.MENU_TARGET);
    private static final String START_WP = ColorUtil.wrapWithColorTag("Start WorldPoint (PluginMessage)", JagexColors.MENU_TARGET);
    private static final String TARGET_INT = ColorUtil.wrapWithColorTag("Target Integer(s) (PluginMessage)", JagexColors.MENU_TARGET);
    private static final String TARGET_WP = ColorUtil.wrapWithColorTag("Target WorldPoint(s) (PluginMessage)", JagexColors.MENU_TARGET);
    private static final String CONFIG_COLOUR_PATH = ColorUtil.wrapWithColorTag("Yellow path colour (PluginMessage)", JagexColors.MENU_TARGET);

    private Set<WorldPoint> targets = new HashSet<>(10);
    private Point lastMenuOpenedPoint;

    @Inject
    private Client client;

    @Inject
    private EventBus eventBus;

    @Subscribe
    public void onMenuOpened(MenuOpened event) {
        lastMenuOpenedPoint = client.getMouseCanvasPosition();

        if (!client.isKeyPressed(KeyCode.KC_SHIFT)) {
            return;
        }

        for (MenuEntry menuEntry : event.getMenuEntries()) {
            if (MenuAction.WALK.equals(menuEntry.getType())) {
                addMenuEntry(event, SET, TARGET_INT, 1);
                addMenuEntry(event, SET, TARGET_WP, 1);
                addMenuEntry(event, SET, CONFIG_COLOUR_PATH, 1);
                if (!targets.isEmpty()) {
                    addMenuEntry(event, SET, START_INT, 1);
                    addMenuEntry(event, SET, START_WP, 1);
                }
                addMenuEntry(event, CLEAR, PATH, 1);
                break;
            }
        }

        final Widget map = client.getWidget(ComponentID.WORLD_MAP_MAPVIEW);

        if (map != null
            && map.getBounds().contains(
                client.getMouseCanvasPosition().getX(),
                client.getMouseCanvasPosition().getY())) {
            addMenuEntry(event, SET, TARGET_INT, 0);
            addMenuEntry(event, SET, TARGET_WP, 0);
            addMenuEntry(event, SET, CONFIG_COLOUR_PATH, 0);
            if (!targets.isEmpty()) {
                addMenuEntry(event, SET, START_INT, 0);
                addMenuEntry(event, SET, START_WP, 0);
                addMenuEntry(event, CLEAR, PATH, 0);
            }
        }
    }

    private void addMenuEntry(MenuOpened event, String option, String target, int position) {
        client.createMenuEntry(position)
            .setOption(option)
            .setTarget(target)
            .setType(MenuAction.RUNELITE)
            .onClick(this::onMenuOptionClicked);
    }

    private void onMenuOptionClicked(MenuEntry entry) {
        boolean isMessageInt = false;
        boolean overrideColourPath = false;
        WorldPoint start = null;
        WorldPoint target = null;

        if (entry.getOption().equals(SET) && entry.getTarget().equals(TARGET_INT)) {
            isMessageInt = true;
            target = getSelectedWorldPoint();
        } else if (entry.getOption().equals(SET) && entry.getTarget().equals(TARGET_WP)) {
            target = getSelectedWorldPoint();
        } else if (entry.getOption().equals(SET) && entry.getTarget().equals(START_INT)) {
            isMessageInt = true;
            start = getSelectedWorldPoint();
        } else if (entry.getOption().equals(SET) && entry.getTarget().equals(START_WP)) {
            start = getSelectedWorldPoint();
        } else if (entry.getOption().equals(SET) && entry.getTarget().equals(CONFIG_COLOUR_PATH)) {
            overrideColourPath = true;
        } else if (entry.getOption().equals(CLEAR) && entry.getTarget().equals(PATH)) {
            targets.clear();
            eventBus.post(new PluginMessage(PLUGIN_MESSAGE_NAME, PLUGIN_MESSAGE_CLEAR));
            return;
        }

        if (target != null) {
            targets.add(target);
        }

        Set<Integer> convertedTargets = new HashSet<>();
        if (isMessageInt) {
            for (WorldPoint t : targets) {
                convertedTargets.add(packWorldPoint(t));
            }
        }

        Map<String, Object> data = new HashMap<>();

        if (start != null) {
            data.put(PLUGIN_MESSAGE_START, isMessageInt ? packWorldPoint(start) : start);
        }

        if (!targets.isEmpty()) {
            data.put(PLUGIN_MESSAGE_TARGET,
                targets.size() != 1 ? (isMessageInt ? convertedTargets : targets)
                : (isMessageInt ? convertedTargets.iterator().next() : targets.iterator().next()));
        }

        if (overrideColourPath) {
            Map<String, Object> configOverride = new HashMap<>();
            configOverride.put("colourPath", new Color(255, 255, 0));
            data.put(PLUGIN_MESSAGE_CONFIG_OVERRIDE, configOverride);
        }

        eventBus.post(new PluginMessage(PLUGIN_MESSAGE_NAME, PLUGIN_MESSAGE_PATH, data));
    }

    private WorldPoint getSelectedWorldPoint() {
        if (client.getWidget(ComponentID.WORLD_MAP_MAPVIEW) == null) {
            if (client.getSelectedSceneTile() != null) {
                return WorldPoint.fromLocalInstance(client, client.getSelectedSceneTile().getLocalLocation());
            }
        } else {
            return client.isMenuOpen()
                ? calculateMapPoint(lastMenuOpenedPoint.getX(), lastMenuOpenedPoint.getY())
                : calculateMapPoint(client.getMouseCanvasPosition().getX(), client.getMouseCanvasPosition().getY());
        }
        return null;
    }

    private WorldPoint calculateMapPoint(int pointX, int pointY) {
        WorldMap worldMap = client.getWorldMap();
        float zoom = worldMap.getWorldMapZoom();
        WorldPoint mapPoint = new WorldPoint(worldMap.getWorldMapPosition().getX(), worldMap.getWorldMapPosition().getY(), 0);
        int middleX = mapWorldPointToGraphicsPointX(mapPoint);
        int middleY = mapWorldPointToGraphicsPointY(mapPoint);

        if (pointX == Integer.MIN_VALUE || pointY == Integer.MIN_VALUE ||
            middleX == Integer.MIN_VALUE || middleY == Integer.MIN_VALUE) {
            return null;
        }

        final int dx = (int) ((pointX - middleX) / zoom);
        final int dy = (int) ((-(pointY - middleY)) / zoom);

        return mapPoint.dx(dx).dy(dy);
    }

    public int mapWorldPointToGraphicsPointX(WorldPoint worldPoint) {
        WorldMap worldMap = client.getWorldMap();

        float pixelsPerTile = worldMap.getWorldMapZoom();

        Widget map = client.getWidget(ComponentID.WORLD_MAP_MAPVIEW);
        if (map != null) {
            Rectangle worldMapRect = map.getBounds();

            int widthInTiles = (int) Math.ceil(worldMapRect.getWidth() / pixelsPerTile);

            Point worldMapPosition = worldMap.getWorldMapPosition();

            int xTileOffset = worldPoint.getX() + widthInTiles / 2 - worldMapPosition.getX();

            int xGraphDiff = ((int) (xTileOffset * pixelsPerTile));
            xGraphDiff += pixelsPerTile - Math.ceil(pixelsPerTile / 2);
            xGraphDiff += (int) worldMapRect.getX();

            return xGraphDiff;
        }
        return Integer.MIN_VALUE;
    }

    public int mapWorldPointToGraphicsPointY(WorldPoint worldPoint) {
        WorldMap worldMap = client.getWorldMap();

        float pixelsPerTile = worldMap.getWorldMapZoom();

        Widget map = client.getWidget(ComponentID.WORLD_MAP_MAPVIEW);
        if (map != null) {
            Rectangle worldMapRect = map.getBounds();

            int heightInTiles = (int) Math.ceil(worldMapRect.getHeight() / pixelsPerTile);

            Point worldMapPosition = worldMap.getWorldMapPosition();

            int yTileMax = worldMapPosition.getY() - heightInTiles / 2;
            int yTileOffset = (yTileMax - worldPoint.getY() - 1) * -1;

            int yGraphDiff = (int) (yTileOffset * pixelsPerTile);
            yGraphDiff -= pixelsPerTile - Math.ceil(pixelsPerTile / 2);
            yGraphDiff = worldMapRect.height - yGraphDiff;
            yGraphDiff += (int) worldMapRect.getY();

            return yGraphDiff;
        }
        return Integer.MIN_VALUE;
    }

    private static int packWorldPoint(WorldPoint wp) {
        if (wp == null) {
            return -1;
        }
        return (wp.getX() & 0x7FFF) | ((wp.getY() & 0x7FFF) << 15) | ((wp.getPlane() & 0x3) << 30);
    }
}

