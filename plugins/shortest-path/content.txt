package shortestpath;

import java.util.Map;

import lombok.Getter;

public class TransportVarbit {
    @Getter
    private final int id;
    private final int value;
    private final TransportVarCheck check;

    public TransportVarbit(int id, int value, TransportVarCheck check) {
        this.id = id;
        this.value = value;
        this.check = check;
    }

    public boolean check(Map<Integer, Integer> values) {
        switch (check) {
            case EQUAL:
                return values.get(id) == value;
            case GREATER:
                return values.get(id) > value;
            case SMALLER:
                return values.get(id) < value;
            case BIT_SET:
                return (values.get(id) & value) > 0;
            case COOLDOWN_MINUTES:
                return ((System.currentTimeMillis() / 60000) - values.get(id)) > value;
        }
        return false;
    }
}

package shortestpath;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import lombok.extern.slf4j.Slf4j;

/**
 * Utility loader for destination coordinate sets grouped by feature category.
 * <p>
 * Destination data is stored in tab-separated value (TSV) resources under {@code /destinations/**}. Each file's
 * first non-empty line is treated as a header (leading comment markers {@code #} or {@code # } are stripped) and
 * defines column names. Rows beginning with {@code #} or blank lines are ignored. Columns named "Destination" are
 * parsed as space-delimited triples {@code (x y plane)} that are packed into single {@code int} values via
 * {@link WorldPointUtil#packWorldPoint(int, int, int)}.
 */
@Slf4j
public class Destination {
    /**
     * Parses a TSV resource of destination coordinates and merges them into the provided map.
     * The key in the destination map is derived from the directory component immediately preceding the file
     * name (e.g., {@code /destinations/game_features/bank.tsv -> bank}).
     *
     * @param destinations accumulator map of category key to a set of packed world point integers.
     * @param path classpath resource path to a TSV file beginning with a header line.
     * @throws RuntimeException wrapping {@link IOException} if the resource cannot be read.
     */
    private static void addDestinations(Map<String, Set<Integer>> destinations, String path) {
        final String DELIM_COLUMN = "\t";
        final String PREFIX_COMMENT = "#";
        final String FILE_EXTENSION = ".";
        final String DELIM_PATH = "/";
        final String DELIM = " ";

        try {
            String s = new String(Util.readAllBytes(ShortestPathPlugin.class.getResourceAsStream(path)), StandardCharsets.UTF_8);
            Scanner scanner = new Scanner(s);

            // Header line is the first line in the file and will start with either '#' or '# '
            String headerLine = scanner.nextLine();
            headerLine = headerLine.startsWith(PREFIX_COMMENT + " ") ? headerLine.replace(PREFIX_COMMENT + " ", PREFIX_COMMENT) : headerLine;
            headerLine = headerLine.startsWith(PREFIX_COMMENT) ? headerLine.replace(PREFIX_COMMENT, "") : headerLine;
            String[] headers = headerLine.split(DELIM_COLUMN);

            String[] parts = path.replace(FILE_EXTENSION, DELIM_PATH).split(DELIM_PATH);
            String entry = parts[parts.length - 2];

            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();

                if (line.startsWith(PREFIX_COMMENT) || line.isBlank()) {
                    continue;
                }

                String[] fields = line.split(DELIM_COLUMN);
                Map<String, List<String>> fieldMap = new HashMap<>();
                for (int i = 0; i < headers.length; i++) {
                    if (i < fields.length) {
                        List<String> values = fieldMap.getOrDefault(headers[i], new ArrayList<>());
                        values.add(fields[i]);
                        fieldMap.put(headers[i], values);
                    }
                }
                for (String field : fieldMap.keySet()) {
                    if ("Destination".equals(field)) {
                        for (String value : fieldMap.get(field)) {
                            try {
                                String[] destinationArray = value.split(DELIM);
                                if (destinationArray.length == 3) {
                                    Set<Integer> entryDestinations = destinations.getOrDefault(entry, new HashSet<>());
                                    entryDestinations.add(WorldPointUtil.packWorldPoint(
                                        Integer.parseInt(destinationArray[0]),
                                        Integer.parseInt(destinationArray[1]),
                                        Integer.parseInt(destinationArray[2])));
                                    destinations.put(entry, entryDestinations);
                                }
                            } catch (NumberFormatException e) {
                                log.error("Invalid destination coordinate", e);
                            }
                        }
                    }
                }
            }
            scanner.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Loads a predefined subset of destination categories from bundled TSV resources.
     *
     * @return a map from destination category key to a set of packed world point integers.
     */
    public static Map<String, Set<Integer>> loadAllFromResources() {
        Map<String, Set<Integer>> destinations = new HashMap<>(10);
        addDestinations(destinations, "/destinations/game_features/altar.tsv");
        addDestinations(destinations, "/destinations/game_features/bank.tsv");
        addDestinations(destinations, "/destinations/training/anvil.tsv");
        addDestinations(destinations, "/destinations/shopping/apothecary.tsv");
        return destinations;
    }
}

package shortestpath;

public class PendingTask {
    private final int tick;
    private final Runnable task;

    PendingTask(int tick, Runnable task) {
        this.tick = tick;
        this.task = task;
    }

    public boolean check(int tick) {
        return tick >= this.tick;
    }

    public void run() {
        task.run();
    }
}

package shortestpath.pathfinder;

import java.util.BitSet;
import java.util.Locale;
import lombok.Getter;
import static net.runelite.api.Constants.REGION_SIZE;

public class FlagMap {
    private static final byte FLAG_COUNT = 2;
    private final BitSet flags;
    @Getter
    private final byte planeCount;
    private final int minX;
    private final int minY;

    public FlagMap(int minX, int minY, byte planeCount) {
        this.minX = minX;
        this.minY = minY;
        this.planeCount = planeCount;
        flags = new BitSet(REGION_SIZE * REGION_SIZE * planeCount * FLAG_COUNT);
    }

    public FlagMap(int minX, int minY, byte[] bytes) {
        this.minX = minX;
        this.minY = minY;
        flags = BitSet.valueOf(bytes);
        int scale = REGION_SIZE * REGION_SIZE * FLAG_COUNT;
        this.planeCount = (byte) ((flags.size() + scale - 1) / scale);
    }

    public byte[] toBytes() {
        return flags.toByteArray();
    }

    public boolean get(int x, int y, int z, int flag) {
        if (x < minX || x >= (minX + REGION_SIZE) || y < minY || y >= (minY + REGION_SIZE) || z < 0 || z >= planeCount) {
            return false;
        }

        return flags.get(index(x, y, z, flag));
    }

    public void set(int x, int y, int z, int flag, boolean value) {
        flags.set(index(x, y, z, flag), value);
    }

    private int index(int x, int y, int z, int flag) {
        if (x < minX || x >= (minX + REGION_SIZE) || y < minY || y >= (minY + REGION_SIZE) || z < 0 || z >= planeCount || flag < 0 || flag >= FLAG_COUNT) {
            throw new IndexOutOfBoundsException(
                String.format(Locale.ENGLISH, "[%d,%d,%d,%d] when extents are [>=%d,>=%d,>=%d,>=%d] - [<=%d,<=%d,<%d,<%d]",
                        x, y, z, flag,
                        minX, minY, 0, 0,
                        minX + REGION_SIZE - 1, minY + REGION_SIZE - 1, planeCount, FLAG_COUNT
                )
            );
        }

        return (z * REGION_SIZE * REGION_SIZE + (y - minY) * REGION_SIZE + (x - minX)) * FLAG_COUNT + flag;
    }
}

package shortestpath.pathfinder;

import shortestpath.PrimitiveIntList;
import shortestpath.WorldPointUtil;

public class Node {
    public final int packedPosition;
    public final Node previous;
    public final int cost;

    public Node(int packedPosition, Node previous, int cost) {
        this.packedPosition = packedPosition;
        this.previous = previous;
        this.cost = cost;
    }

    public Node(int packedPosition, Node previous) {
        this(packedPosition, previous, cost(packedPosition, previous));
    }

    public PrimitiveIntList getPath() {
        Node node = this;
        int n = 0;

        while (node != null) {
            node = node.previous;
            n++;
        }
        PrimitiveIntList path = new PrimitiveIntList(n, true);
        node = this;
        while (node != null) {
            path.set(--n, node.packedPosition);
            node = node.previous;
        }

        return path;
    }

    private static int cost(int packedPosition, Node previous) {
        int previousCost = 0;
        int travelTime = 0;

        if (previous != null) {
            previousCost = previous.cost;
            // Travel wait time in TransportNode and distance is compared as if the player is walking 1 tile/tick.
            // TODO: reduce the distance if the player is currently running and has enough run energy for the distance?
            travelTime = WorldPointUtil.distanceBetween(previous.packedPosition, packedPosition);
        }

        return previousCost + travelTime;
    }
}

package shortestpath.pathfinder;

import java.io.IOException;
import java.io.UncheckedIOException;
import java.util.HashMap;
import java.util.Map;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import shortestpath.ShortestPathPlugin;
import shortestpath.Util;

import static net.runelite.api.Constants.REGION_SIZE;

public class SplitFlagMap {
    @Getter
    private static RegionExtent regionExtents;

    @Getter
    private final byte[] regionMapPlaneCounts;
    // Size is automatically chosen based on the max extents of the collision data
    private final FlagMap[] regionMaps;
    private final int widthInclusive;

    public SplitFlagMap(Map<Integer, byte[]> compressedRegions) {
        widthInclusive = regionExtents.getWidth() + 1;
        final int heightInclusive = regionExtents.getHeight() + 1;
        regionMaps = new FlagMap[widthInclusive * heightInclusive];
        regionMapPlaneCounts = new byte[regionMaps.length];

        for (Map.Entry<Integer, byte[]> entry : compressedRegions.entrySet()) {
            final int pos = entry.getKey();
            final int x = unpackX(pos);
            final int y = unpackY(pos);
            final int index = getIndex(x, y);
            FlagMap flagMap = new FlagMap(x * REGION_SIZE, y * REGION_SIZE, entry.getValue());
            regionMaps[index] = flagMap;
            regionMapPlaneCounts[index] = flagMap.getPlaneCount();
        }
    }

    public boolean get(int x, int y, int z, int flag) {
        final int index = getIndex(x / REGION_SIZE, y / REGION_SIZE);
        if (index < 0 || index >= regionMaps.length || regionMaps[index] == null) {
            return false;
        }

        return regionMaps[index].get(x, y, z, flag);
    }

    private int getIndex(int regionX, int regionY) {
        return (regionX - regionExtents.getMinX()) + (regionY - regionExtents.getMinY()) * widthInclusive;
    }

    public static int unpackX(int position) {
        return position & 0xFFFF;
    }

    public static int unpackY(int position) {
        return (position >> 16) & 0xFFFF;
    }

    public static int packPosition(int x, int y) {
        return (x & 0xFFFF) | ((y & 0xFFFF) << 16);
    }

    public static SplitFlagMap fromResources() {
        Map<Integer, byte[]> compressedRegions = new HashMap<>();
        try (ZipInputStream in = new ZipInputStream(ShortestPathPlugin.class.getResourceAsStream("/collision-map.zip"))) {
            int minX = Integer.MAX_VALUE;
            int minY = Integer.MAX_VALUE;
            int maxX = 0;
            int maxY = 0;

            ZipEntry entry;
            while ((entry = in.getNextEntry()) != null) {
                String[] n = entry.getName().split("_");
                final int x = Integer.parseInt(n[0]);
                final int y = Integer.parseInt(n[1]);
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                maxX = Math.max(maxX, x);
                maxY = Math.max(maxY, y);

                compressedRegions.put(SplitFlagMap.packPosition(x, y), Util.readAllBytes(in));
            }

            regionExtents = new RegionExtent(minX, minY, maxX, maxY);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }

        return new SplitFlagMap(compressedRegions);
    }

    @RequiredArgsConstructor
    @Getter
    public static class RegionExtent {
        public final int minX, minY, maxX, maxY;

        public int getWidth() {
            return maxX - minX;
        }

        public int getHeight() {
            return maxY - minY;
        }
    }
}

package shortestpath.pathfinder;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import shortestpath.Transport;
import shortestpath.WorldPointUtil;

public class CollisionMap {

    // Enum.values() makes copies every time which hurts performance in the hotpath
    private static final OrdinalDirection[] ORDINAL_VALUES = OrdinalDirection.values();

    private final SplitFlagMap collisionData;

    public byte[] getPlanes() {
        return collisionData.getRegionMapPlaneCounts();
    }

    public CollisionMap(SplitFlagMap collisionData) {
        this.collisionData = collisionData;
    }

    private boolean get(int x, int y, int z, int flag) {
        return collisionData.get(x, y, z, flag);
    }

    public boolean n(int x, int y, int z) {
        return get(x, y, z, 0);
    }

    public boolean s(int x, int y, int z) {
        return n(x, y - 1, z);
    }

    public boolean e(int x, int y, int z) {
        return get(x, y, z, 1);
    }

    public boolean w(int x, int y, int z) {
        return e(x - 1, y, z);
    }

    private boolean ne(int x, int y, int z) {
        return n(x, y, z) && e(x, y + 1, z) && e(x, y, z) && n(x + 1, y, z);
    }

    private boolean nw(int x, int y, int z) {
        return n(x, y, z) && w(x, y + 1, z) && w(x, y, z) && n(x - 1, y, z);
    }

    private boolean se(int x, int y, int z) {
        return s(x, y, z) && e(x, y - 1, z) && e(x, y, z) && s(x + 1, y, z);
    }

    private boolean sw(int x, int y, int z) {
        return s(x, y, z) && w(x, y - 1, z) && w(x, y, z) && s(x - 1, y, z);
    }

    public boolean isBlocked(int x, int y, int z) {
        return !n(x, y, z) && !s(x, y, z) && !e(x, y, z) && !w(x, y, z);
    }

    private static int packedPointFromOrdinal(int startPacked, OrdinalDirection direction) {
        final int x = WorldPointUtil.unpackWorldX(startPacked);
        final int y = WorldPointUtil.unpackWorldY(startPacked);
        final int plane = WorldPointUtil.unpackWorldPlane(startPacked);
        return WorldPointUtil.packWorldPoint(x + direction.x, y + direction.y, plane);
    }

    // This is only safe if pathfinding is single-threaded
    private final List<Node> neighbors = new ArrayList<>(16);
    private final boolean[] traversable = new boolean[8];

    public List<Node> getNeighbors(Node node, VisitedTiles visited, PathfinderConfig config) {
        final int x = WorldPointUtil.unpackWorldX(node.packedPosition);
        final int y = WorldPointUtil.unpackWorldY(node.packedPosition);
        final int z = WorldPointUtil.unpackWorldPlane(node.packedPosition);

        neighbors.clear();

        @SuppressWarnings("unchecked") // Casting EMPTY_LIST to List<Transport> is safe here
        Set<Transport> transports = config.getTransportsPacked().getOrDefault(node.packedPosition, (Set<Transport>)Collections.EMPTY_SET);

        // Transports are pre-filtered by PathfinderConfig.refreshTransports
        // Thus any transports in the list are guaranteed to be valid per the user's settings
        for (Transport transport : transports) {
            if (visited.get(transport.getDestination())) continue;
            neighbors.add(new TransportNode(transport.getDestination(), node, transport.getDuration()));
        }

        if (isBlocked(x, y, z)) {
            boolean westBlocked = isBlocked(x - 1, y, z);
            boolean eastBlocked = isBlocked(x + 1, y, z);
            boolean southBlocked = isBlocked(x, y - 1, z);
            boolean northBlocked = isBlocked(x, y + 1, z);
            boolean southWestBlocked = isBlocked(x - 1, y - 1, z);
            boolean southEastBlocked = isBlocked(x + 1, y - 1, z);
            boolean northWestBlocked = isBlocked(x - 1, y + 1, z);
            boolean northEastBlocked = isBlocked(x + 1, y + 1, z);
            traversable[0] = !westBlocked;
            traversable[1] = !eastBlocked;
            traversable[2] = !southBlocked;
            traversable[3] = !northBlocked;
            traversable[4] = !southWestBlocked && !westBlocked && !southBlocked;
            traversable[5] = !southEastBlocked && !eastBlocked && !southBlocked;
            traversable[6] = !northWestBlocked && !westBlocked && !northBlocked;
            traversable[7] = !northEastBlocked && !eastBlocked && !northBlocked;
        } else {
            traversable[0] = w(x, y, z);
            traversable[1] = e(x, y, z);
            traversable[2] = s(x, y, z);
            traversable[3] = n(x, y, z);
            traversable[4] = sw(x, y, z);
            traversable[5] = se(x, y, z);
            traversable[6] = nw(x, y, z);
            traversable[7] = ne(x, y, z);
        }

        for (int i = 0; i < traversable.length; i++) {
            OrdinalDirection d = ORDINAL_VALUES[i];
            int neighborPacked = packedPointFromOrdinal(node.packedPosition, d);
            if (visited.get(neighborPacked)) continue;

            if (traversable[i]) {
                neighbors.add(new Node(neighborPacked, node));
            } else if (Math.abs(d.x + d.y) == 1 && isBlocked(x + d.x, y + d.y, z)) {
                // The transport starts from a blocked adjacent tile, e.g. fairy ring
                // Only checks non-teleport transports (includes portals and levers, but not items and spells)
                @SuppressWarnings("unchecked") // Casting EMPTY_LIST to List<Transport> is safe here
                Set<Transport> neighborTransports = config.getTransportsPacked().getOrDefault(neighborPacked, (Set<Transport>)Collections.EMPTY_SET);
                for (Transport transport : neighborTransports) {
                    if (transport.getOrigin() == Transport.UNDEFINED_ORIGIN || visited.get(transport.getOrigin())) {
                        continue;
                    }
                    neighbors.add(new Node(transport.getOrigin(), node));
                }
            }
        }

        return neighbors;
    }
}

package shortestpath.pathfinder;

public class TransportNode extends Node implements Comparable<TransportNode> {
    public TransportNode(int packedPosition, Node previous, int travelTime) {
        super(packedPosition, previous, cost(previous, travelTime));
    }

    private static int cost(Node previous, int travelTime) {
        return (previous != null ? previous.cost : 0) + travelTime;
    }

    @Override
    public int compareTo(TransportNode other) {
        return Integer.compare(cost, other.cost);
    }
}

package shortestpath.pathfinder;

import shortestpath.WorldPointUtil;
import static net.runelite.api.Constants.REGION_SIZE;

public class VisitedTiles {
    private final SplitFlagMap.RegionExtent regionExtents;
    private final int widthInclusive;

    private final VisitedRegion[] visitedRegions;
    private final byte[] visitedRegionPlanes;

    public VisitedTiles(CollisionMap map) {
        regionExtents = SplitFlagMap.getRegionExtents();
        widthInclusive = regionExtents.getWidth() + 1;
        final int heightInclusive = regionExtents.getHeight() + 1;

        visitedRegions = new VisitedRegion[widthInclusive * heightInclusive];
        visitedRegionPlanes = map.getPlanes();
    }

    public boolean get(int packedPoint) {
        final int x = WorldPointUtil.unpackWorldX(packedPoint);
        final int y = WorldPointUtil.unpackWorldY(packedPoint);
        final int plane = WorldPointUtil.unpackWorldPlane(packedPoint);
        return get(x, y, plane);
    }

    public boolean get(int x, int y, int plane) {
        final int regionIndex = getRegionIndex(x / REGION_SIZE, y / REGION_SIZE);
        if (regionIndex < 0 || regionIndex >= visitedRegions.length) {
            return true; // Region is out of bounds; report that it's been visited to avoid exploring it further
        }

        final VisitedRegion region = visitedRegions[regionIndex];
        if (region == null) {
            return false;
        }

        return region.get(x % REGION_SIZE, y % REGION_SIZE, plane);
    }

    public boolean set(int packedPoint) {
        final int x = WorldPointUtil.unpackWorldX(packedPoint);
        final int y = WorldPointUtil.unpackWorldY(packedPoint);
        final int plane = WorldPointUtil.unpackWorldPlane(packedPoint);
        return set(x, y, plane);
    }

    public boolean set(int x, int y, int plane) {
        final int regionIndex = getRegionIndex(x / REGION_SIZE, y / REGION_SIZE);
        if (regionIndex < 0 || regionIndex >= visitedRegions.length) {
            return false; // Region is out of bounds; report that it's been visited to avoid exploring it further
        }

        VisitedRegion region = visitedRegions[regionIndex];
        if (region == null) {
            region = new VisitedRegion(visitedRegionPlanes[regionIndex]);
            visitedRegions[regionIndex] = region;
        }

        return region.set(x % REGION_SIZE, y % REGION_SIZE, plane);
    }

    public void clear() {
        for (int i = 0; i < visitedRegions.length; ++i) {
            if (visitedRegions[i] != null) {
                visitedRegions[i] = null;
            }
        }
    }

    private int getRegionIndex(int regionX, int regionY) {
        return (regionX - regionExtents.minX) + (regionY - regionExtents.minY) * widthInclusive;
    }

    public int getRegionX(int regionIndex) {
        return (regionIndex % widthInclusive + regionExtents.minX) * REGION_SIZE;
    }

    public int getRegionY(int regionIndex) {
        return (regionIndex / widthInclusive + regionExtents.minY) * REGION_SIZE;
    }

    private static class VisitedRegion {
        // This assumes a row is at most 64 tiles and fits in a long
        private final long[] planes;
        private final byte planeCount;

        VisitedRegion(byte planeCount) {
            this.planeCount = planeCount;
            this.planes = new long[planeCount * REGION_SIZE];
        }

        // Sets a tile as visited in the tile bitset
        // Returns true if the tile is unique and hasn't been seen before or false if it was seen before
        public boolean set(int x, int y, int plane) {
            if (plane >= planeCount) {
                // Plane is out of bounds; report that it has been visited to avoid further exploration
                return false;
            }
            final int index = y + plane * REGION_SIZE;
            boolean unique = (planes[index] & (1L << x)) == 0;
            planes[index] |= 1L << x;
            return unique;
        }

        public boolean get(int x, int y, int plane) {
            if (plane >= planeCount) {
                // This check is necessary since we check visited tiles before checking the collision map, e.g. the node
                // at (2816, 3455, 1) will check its neighbour to the north which is in a new region with no plane = 1
                return true;
            }
            return (planes[y + plane * REGION_SIZE] & (1L << x)) != 0;
        }
    }
}

package shortestpath.pathfinder;

public enum OrdinalDirection {
    WEST(-1, 0),
    EAST(1, 0),
    SOUTH(0, -1),
    NORTH(0, 1),
    SOUTH_WEST(-1, -1),
    SOUTH_EAST(1, -1),
    NORTH_WEST(-1, 1),
    NORTH_EAST(1, 1);

    final int x;
    final int y;

    OrdinalDirection(int x, int y) {
        this.x = x;
        this.y = y;
    }
}

package shortestpath.pathfinder;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Set;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.EnumComposition;
import net.runelite.api.EnumID;
import net.runelite.api.GameState;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.Quest;
import net.runelite.api.QuestState;
import net.runelite.api.Skill;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;
import shortestpath.TeleportationItem;
import shortestpath.ShortestPathConfig;
import shortestpath.ShortestPathPlugin;
import shortestpath.Destination;
import shortestpath.ItemVariations;
import shortestpath.PrimitiveIntHashMap;
import shortestpath.Transport;
import shortestpath.TransportItems;
import shortestpath.TransportType;
import shortestpath.TransportVarbit;
import shortestpath.TransportVarPlayer;
import shortestpath.WorldPointUtil;
import static shortestpath.TransportType.AGILITY_SHORTCUT;
import static shortestpath.TransportType.GRAPPLE_SHORTCUT;
import static shortestpath.TransportType.BOAT;
import static shortestpath.TransportType.CANOE;
import static shortestpath.TransportType.CHARTER_SHIP;
import static shortestpath.TransportType.SHIP;
import static shortestpath.TransportType.FAIRY_RING;
import static shortestpath.TransportType.GNOME_GLIDER;
import static shortestpath.TransportType.HOT_AIR_BALLOON;
import static shortestpath.TransportType.MAGIC_CARPET;
import static shortestpath.TransportType.MAGIC_MUSHTREE;
import static shortestpath.TransportType.MINECART;
import static shortestpath.TransportType.QUETZAL;
import static shortestpath.TransportType.SPIRIT_TREE;
import static shortestpath.TransportType.TELEPORTATION_BOX;
import static shortestpath.TransportType.TELEPORTATION_LEVER;
import static shortestpath.TransportType.TELEPORTATION_MINIGAME;
import static shortestpath.TransportType.TELEPORTATION_PORTAL;
import static shortestpath.TransportType.TELEPORTATION_ITEM;
import static shortestpath.TransportType.TELEPORTATION_SPELL;
import static shortestpath.TransportType.WILDERNESS_OBELISK;

public class PathfinderConfig {
    private static final WorldArea WILDERNESS_ABOVE_GROUND = new WorldArea(2944, 3525, 448, 448, 0);
    private static final WorldArea WILDERNESS_ABOVE_GROUND_LEVEL_20 = new WorldArea(2944, 3680, 448, 448, 0);
    private static final WorldArea WILDERNESS_ABOVE_GROUND_LEVEL_30 = new WorldArea(2944, 3760, 448, 448, 0);
    private static final WorldArea WILDERNESS_UNDERGROUND = new WorldArea(2944, 9918, 320, 442, 0);
    private static final WorldArea WILDERNESS_UNDERGROUND_LEVEL_20 = new WorldArea(2944, 10075, 320, 442, 0);
    private static final WorldArea WILDERNESS_UNDERGROUND_LEVEL_30 = new WorldArea(2944, 10155, 320, 442, 0);
    private static final WorldArea FEROX_ENCLAVE_1 = new WorldArea(3123, 3622, 2, 10, 0);
    private static final WorldArea FEROX_ENCLAVE_2 = new WorldArea(3125, 3617, 16, 23, 0);
    private static final WorldArea FEROX_ENCLAVE_3 = new WorldArea(3138, 3636, 18, 10, 0);
    private static final WorldArea FEROX_ENCLAVE_4 = new WorldArea(3141, 3625, 14, 11, 0);
    private static final WorldArea FEROX_ENCLAVE_5 = new WorldArea(3141, 3619, 7, 6, 0);
    private static final WorldArea NOT_WILDERNESS_1 = new WorldArea(2997, 3525, 34, 9, 0);
    private static final WorldArea NOT_WILDERNESS_2 = new WorldArea(3005, 3534, 21, 10, 0);
    private static final WorldArea NOT_WILDERNESS_3 = new WorldArea(3000, 3534, 5, 5, 0);
    private static final WorldArea NOT_WILDERNESS_4 = new WorldArea(3031, 3525, 2, 2, 0);
    private static final List<Integer> RUNE_POUCHES = Arrays.asList(
        ItemID.BH_RUNE_POUCH, ItemID.BH_RUNE_POUCH_TROUVER,
        ItemID.DIVINE_RUNE_POUCH, ItemID.DIVINE_RUNE_POUCH_TROUVER
    );
    private static final int[] RUNE_POUCH_RUNE_VARBITS = {
        VarbitID.RUNE_POUCH_TYPE_1, VarbitID.RUNE_POUCH_TYPE_2, VarbitID.RUNE_POUCH_TYPE_3, VarbitID.RUNE_POUCH_TYPE_4,
        VarbitID.RUNE_POUCH_TYPE_5, VarbitID.RUNE_POUCH_TYPE_6
	};
    private static final int[] RUNE_POUCH_AMOUNT_VARBITS = {
        VarbitID.RUNE_POUCH_QUANTITY_1, VarbitID.RUNE_POUCH_QUANTITY_2, VarbitID.RUNE_POUCH_QUANTITY_3, VarbitID.RUNE_POUCH_QUANTITY_4,
        VarbitID.RUNE_POUCH_QUANTITY_5, VarbitID.RUNE_POUCH_QUANTITY_6
	};
    private static final Set<Integer> CURRENCIES = Set.of(
        ItemID.COINS, ItemID.VILLAGE_TRADE_STICKS, ItemID.ECTOTOKEN, ItemID.WARGUILD_TOKENS);
    private static final TransportItems DRAMEN_STAFF = new TransportItems(
        new int[][]{null},
        new int[][]{ItemVariations.DRAMEN_STAFF.getIds()},
        new int[][]{null},
        new int[]{1});

    private final SplitFlagMap mapData;
    private final ThreadLocal<CollisionMap> map;
    /** All transports by origin. The WorldPointUtil.UNDEFINED key is used for transports centered on the player. */
    private final Map<Integer, Set<Transport>> allTransports;
    private final Set<Transport> usableTeleports;
    private final Map<String, Set<Integer>> allDestinations;
    private final Map<String, Set<Integer>> filteredDestinations;
    private final Map<Integer, Integer> itemsAndQuantities = new HashMap<>(28 + 11 + 500);
    private final List<Integer> filteredTargets = new ArrayList<>(4);

    @Getter
    private final Map<Integer, Set<Transport>> transports;
    // Copy of transports with packed positions for the hotpath; lists are not copied and are the same reference in both maps
    @Getter
    private final PrimitiveIntHashMap<Set<Transport>> transportsPacked;
    /** Reference that points to either allDestinations or filteredDestinations */
    private Map<String, Set<Integer>> destinations;

    private final Client client;
    private final ShortestPathConfig config;

    @Getter
    private long calculationCutoffMillis;
    @Getter
    private boolean avoidWilderness;
    private boolean useAgilityShortcuts,
        useGrappleShortcuts,
        useBoats,
        useCanoes,
        useCharterShips,
        useShips,
        useFairyRings,
        useGnomeGliders,
        useHotAirBalloons,
        useMagicCarpets,
        useMagicMushtrees,
        useMinecarts,
        useQuetzals,
        useSpiritTrees,
        useTeleportationBoxes,
        useTeleportationLevers,
        useTeleportationMinigames,
        useTeleportationPortals,
        useTeleportationSpells,
        useWildernessObelisks;
    private TeleportationItem useTeleportationItems;
    private int currencyThreshold;
    private final int[] boostedLevels = new int[Skill.values().length];
    private Map<Quest, QuestState> questStates = new HashMap<>();
    private Map<Integer, Integer> varbitValues = new HashMap<>();
    private Map<Integer, Integer> varPlayerValues = new HashMap<>();

    public ItemContainer bank = null;

    public PathfinderConfig(Client client, ShortestPathConfig config) {
        this.client = client;
        this.config = config;
        this.mapData = SplitFlagMap.fromResources();
        this.map = ThreadLocal.withInitial(() -> new CollisionMap(mapData));
        this.allTransports = Transport.loadAllFromResources();
        this.usableTeleports = new HashSet<>(allTransports.size() / 20);
        this.transports = new HashMap<>(allTransports.size() / 2);
        this.transportsPacked = new PrimitiveIntHashMap<>(allTransports.size() / 2);
        this.allDestinations = Destination.loadAllFromResources();
        this.filteredDestinations = filterDestinations(allDestinations);
        this.destinations = allDestinations;
    }

    public CollisionMap getMap() {
        return map.get();
    }

    public boolean hasDestination(String destinationType) {
        return destinations.containsKey(destinationType);
    }

    public Set<Integer> getDestinations(String destinationType) {
        return destinations.get(destinationType);
    }

    public void refresh() {
        calculationCutoffMillis = config.calculationCutoff() * Constants.GAME_TICK_LENGTH;
        avoidWilderness = ShortestPathPlugin.override("avoidWilderness", config.avoidWilderness());
        useAgilityShortcuts = ShortestPathPlugin.override("useAgilityShortcuts", config.useAgilityShortcuts());
        useGrappleShortcuts = ShortestPathPlugin.override("useGrappleShortcuts", config.useGrappleShortcuts());
        useBoats = ShortestPathPlugin.override("useBoats", config.useBoats());
        useCanoes = ShortestPathPlugin.override("useCanoes", config.useCanoes());
        useCharterShips = ShortestPathPlugin.override("useCharterShips", config.useCharterShips());
        useShips = ShortestPathPlugin.override("useShips", config.useShips());
        useFairyRings = ShortestPathPlugin.override("useFairyRings", config.useFairyRings());
        useGnomeGliders = ShortestPathPlugin.override("useGnomeGliders", config.useGnomeGliders());
        useHotAirBalloons = ShortestPathPlugin.override("useHotAirBalloons", config.useHotAirBalloons());
        useMagicCarpets = ShortestPathPlugin.override("useMagicCarpets", config.useMagicCarpets());
        useMagicMushtrees = ShortestPathPlugin.override("useMagicMushtrees", config.useMagicMushtrees());
        useMinecarts = ShortestPathPlugin.override("useMinecarts", config.useMinecarts());
        useQuetzals = ShortestPathPlugin.override("useQuetzals", config.useQuetzals());
        useSpiritTrees = ShortestPathPlugin.override("useSpiritTrees", config.useSpiritTrees());
        useTeleportationItems = ShortestPathPlugin.override("useTeleportationItems", config.useTeleportationItems());
        useTeleportationBoxes = ShortestPathPlugin.override("useTeleportationBoxes", config.useTeleportationBoxes());
        useTeleportationLevers = ShortestPathPlugin.override("useTeleportationLevers", config.useTeleportationLevers());
        useTeleportationMinigames = ShortestPathPlugin.override("useTeleportationMinigames", config.useTeleportationMinigames());
        useTeleportationPortals = ShortestPathPlugin.override("useTeleportationPortals", config.useTeleportationPortals());
        useTeleportationSpells = ShortestPathPlugin.override("useTeleportationSpells", config.useTeleportationSpells());
        useWildernessObelisks = ShortestPathPlugin.override("useWildernessObelisks", config.useWildernessObelisks());
        currencyThreshold = ShortestPathPlugin.override("currencyThreshold", config.currencyThreshold());

        if (GameState.LOGGED_IN.equals(client.getGameState())) {
            for (int i = 0; i < Skill.values().length; i++) {
                boostedLevels[i] = client.getBoostedSkillLevel(Skill.values()[i]);
            }

            refreshTransports();
        }

        refreshDestinations();
    }

    /** Specialized method for only updating player-held item and spell transports */
    public void refreshTeleports(int packedLocation, int wildernessLevel) {
        Set<Transport> usableWildyTeleports = new HashSet<>(usableTeleports.size());

        for (Transport teleport : usableTeleports) {
            if (wildernessLevel <= teleport.getMaxWildernessLevel()) {
                usableWildyTeleports.add(teleport);
            }
        }

        if (!usableWildyTeleports.isEmpty()) {
            Set<Transport> oldTransports = transports.getOrDefault(packedLocation, new HashSet<>());
            oldTransports.addAll(usableWildyTeleports);
            transports.put(packedLocation, oldTransports);
            transportsPacked.put(packedLocation, usableWildyTeleports); // appends for collections
        }
    }

    private void refreshDestinations() {
        destinations = avoidWilderness ? filteredDestinations : allDestinations;
    }

    /** Changes to the config might have invalidated some locations, e.g. those in the wilderness */
    public void filterLocations(Set<Integer> locations, boolean canReviveFiltered) {
        if (avoidWilderness) {
            locations.removeIf(location -> {
                boolean inWilderness = PathfinderConfig.isInWilderness(location);
                if (inWilderness) {
                    filteredTargets.add(location);
                }
                return inWilderness;
            });
            // If we ended up with no valid locations we re-include the filtered locations
            if (locations.isEmpty()) {
                locations.addAll(filteredTargets);
                filteredTargets.clear();
            }
        } else if (canReviveFiltered) { // Re-include previously filtered locations
            locations.addAll(filteredTargets);
            filteredTargets.clear();
        }
    }

    private Map<String, Set<Integer>> filterDestinations(Map<String, Set<Integer>> allDestinations) {
        Map<String, Set<Integer>> filteredDestinations = new HashMap<>(allDestinations.size());
        for (Map.Entry<String, Set<Integer>> entry : allDestinations.entrySet()) {
            String destinationType = entry.getKey();
            Set<Integer> usableDestinations = new HashSet<>(entry.getValue().size());
            boolean isDifferent = false;
            for (Integer destination : entry.getValue()) {
                // We filter based on whether the destination is inside or outside wilderness
                if (!PathfinderConfig.isInWilderness(destination)) {
                    usableDestinations.add(destination);
                    isDifferent = true;
                }
            }
            // If all destinations of a destination type have been filtered away then we don't add the entry
            if (!usableDestinations.isEmpty()) {
                // If no destinations of a destination type have been filtered away then we re-use the same set reference
                filteredDestinations.put(destinationType, isDifferent ? usableDestinations : entry.getValue());
            }
        }
        return filteredDestinations;
    }

    private void refreshTransports() {
        if (!Thread.currentThread().equals(client.getClientThread())) {
            return; // Has to run on the client thread; data will be refreshed when path finding commences
        }

        useFairyRings &= ((client.getVarbitValue(VarbitID.FAIRY2_QUEENCURE_QUEST) > 39)
            && (client.getVarbitValue(VarbitID.LUMBRIDGE_DIARY_ELITE_COMPLETE) == 1 || hasRequiredItems(DRAMEN_STAFF)));
        useGnomeGliders &= QuestState.FINISHED.equals(getQuestState(Quest.THE_GRAND_TREE));
        useMagicMushtrees &= QuestState.FINISHED.equals(getQuestState(Quest.BONE_VOYAGE));
        useSpiritTrees &= QuestState.FINISHED.equals(getQuestState(Quest.TREE_GNOME_VILLAGE));

        transports.clear();
        transportsPacked.clear();
        usableTeleports.clear();
        for (Map.Entry<Integer, Set<Transport>> entry : allTransports.entrySet()) {
            int point = entry.getKey();
            Set<Transport> usableTransports = new HashSet<>(entry.getValue().size());
            for (Transport transport : entry.getValue()) {
                for (Quest quest : transport.getQuests()) {
                    try {
                        questStates.put(quest, getQuestState(quest));
                    } catch (NullPointerException ignored) {
                    }
                }

                for (TransportVarbit varbitRequirement : transport.getVarbits()) {
                    varbitValues.put(varbitRequirement.getId(), client.getVarbitValue(varbitRequirement.getId()));
                }
                for (TransportVarPlayer varPlayerRequirement : transport.getVarPlayers()) {
                    varPlayerValues.put(varPlayerRequirement.getId(), client.getVarpValue(varPlayerRequirement.getId()));
                }

                if (useTransport(transport) && hasRequiredItems(transport)) {
                    if (point == WorldPointUtil.UNDEFINED) {
                        usableTeleports.add(transport);
                    } else {
                        usableTransports.add(transport);
                    }
                }
            }

            if (point != WorldPointUtil.UNDEFINED && !usableTransports.isEmpty()) {
                transports.put(point, usableTransports);
                transportsPacked.put(point, usableTransports);
            }
        }
    }

    public static boolean isInWilderness(WorldPoint p) {
        return WILDERNESS_ABOVE_GROUND.distanceTo2D(p) == 0
            && FEROX_ENCLAVE_1.distanceTo2D(p) != 0
            && FEROX_ENCLAVE_2.distanceTo2D(p) != 0
            && FEROX_ENCLAVE_3.distanceTo2D(p) != 0
            && FEROX_ENCLAVE_4.distanceTo2D(p) != 0
            && FEROX_ENCLAVE_5.distanceTo2D(p) != 0
            && NOT_WILDERNESS_1.distanceTo2D(p) != 0
            && NOT_WILDERNESS_2.distanceTo2D(p) != 0
            && NOT_WILDERNESS_3.distanceTo2D(p) != 0
            && NOT_WILDERNESS_4.distanceTo2D(p) != 0
            || WILDERNESS_UNDERGROUND.distanceTo2D(p) == 0;
    }

    public static boolean isInWilderness(int packedPoint) {
        return WorldPointUtil.distanceToArea2D(packedPoint, WILDERNESS_ABOVE_GROUND) == 0
            && WorldPointUtil.distanceToArea2D(packedPoint, FEROX_ENCLAVE_1) != 0
            && WorldPointUtil.distanceToArea2D(packedPoint, FEROX_ENCLAVE_2) != 0
            && WorldPointUtil.distanceToArea2D(packedPoint, FEROX_ENCLAVE_3) != 0
            && WorldPointUtil.distanceToArea2D(packedPoint, FEROX_ENCLAVE_4) != 0
            && WorldPointUtil.distanceToArea2D(packedPoint, FEROX_ENCLAVE_5) != 0
            && WorldPointUtil.distanceToArea2D(packedPoint, NOT_WILDERNESS_1) != 0
            && WorldPointUtil.distanceToArea2D(packedPoint, NOT_WILDERNESS_2) != 0
            && WorldPointUtil.distanceToArea2D(packedPoint, NOT_WILDERNESS_3) != 0
            && WorldPointUtil.distanceToArea2D(packedPoint, NOT_WILDERNESS_4) != 0
            || WorldPointUtil.distanceToArea2D(packedPoint, WILDERNESS_UNDERGROUND) == 0;
    }

    public static boolean isInWilderness(Set<Integer> packedPoints) {
        for (int packedPoint : packedPoints) {
            if (isInWilderness(packedPoint)) {
                return true;
            }
        }
        return false;
    }

    public static boolean isInLevel20Wilderness(int packedPoint) {
        return WorldPointUtil.distanceToArea2D(packedPoint, WILDERNESS_ABOVE_GROUND_LEVEL_20) == 0
            || WorldPointUtil.distanceToArea2D(packedPoint, WILDERNESS_UNDERGROUND_LEVEL_20) == 0;
    }

    public static boolean isInLevel30Wilderness(int packedPoint){
        return WorldPointUtil.distanceToArea2D(packedPoint, WILDERNESS_ABOVE_GROUND_LEVEL_30) == 0
            || WorldPointUtil.distanceToArea2D(packedPoint, WILDERNESS_UNDERGROUND_LEVEL_30) == 0;
    }

    public boolean avoidWilderness(int packedPosition, int packedNeightborPosition, boolean targetInWilderness) {
        return avoidWilderness && !targetInWilderness
            && !isInWilderness(packedPosition) && isInWilderness(packedNeightborPosition);
    }

    public QuestState getQuestState(Quest quest) {
        return quest.getState(client);
    }

    private boolean completedQuests(Transport transport) {
        for (Quest quest : transport.getQuests()) {
            if (!QuestState.FINISHED.equals(questStates.getOrDefault(quest, QuestState.NOT_STARTED))) {
                return false;
            }
        }
        return true;
    }

    public boolean varbitChecks(Transport transport) {
        for (TransportVarbit varbitRequirement : transport.getVarbits()) {
            if (!varbitRequirement.check(varbitValues)) {
                return false;
            }
        }
        return true;
    }

    public boolean varPlayerChecks(Transport transport) {
        for (TransportVarPlayer varPlayerRequirement : transport.getVarPlayers()) {
            if (!varPlayerRequirement.check(varPlayerValues)) {
                return false;
            }
        }
        return true;
    }

    private boolean useTransport(Transport transport) {
        final boolean isQuestLocked = transport.isQuestLocked();

        if (!hasRequiredLevels(transport)) {
            return false;
        }

        TransportType type = transport.getType();

        if (AGILITY_SHORTCUT.equals(type) && !useAgilityShortcuts) {
            return false;
        } else if (GRAPPLE_SHORTCUT.equals(type) && !useGrappleShortcuts) {
            return false;
        } else if (BOAT.equals(type) && !useBoats) {
            return false;
        } else if (CANOE.equals(type) && !useCanoes) {
            return false;
        } else if (CHARTER_SHIP.equals(type) && !useCharterShips) {
            return false;
        } else if (SHIP.equals(type) && !useShips) {
            return false;
        } else if (FAIRY_RING.equals(type) && !useFairyRings) {
            return false;
        } else if (GNOME_GLIDER.equals(type) && !useGnomeGliders) {
            return false;
        } else if (HOT_AIR_BALLOON.equals(type) && !useHotAirBalloons) {
            return false;
        } else if (MAGIC_CARPET.equals(type) && !useMagicCarpets) {
            return false;
        } else if (MAGIC_MUSHTREE.equals(type) && !useMagicMushtrees) {
            return false;
        } else if (MINECART.equals(type) && !useMinecarts) {
            return false;
        } else if (QUETZAL.equals(type) && !useQuetzals) {
            return false;
        } else if (SPIRIT_TREE.equals(type) && !useSpiritTrees) {
            return false;
        } else if (TELEPORTATION_ITEM.equals(type)) {
            switch (useTeleportationItems) {
                case ALL:
                case INVENTORY:
                case INVENTORY_AND_BANK:
                    break;
                case NONE:
                    return false;
                case INVENTORY_NON_CONSUMABLE:
                case INVENTORY_AND_BANK_NON_CONSUMABLE:
                case ALL_NON_CONSUMABLE:
                    if (transport.isConsumable()) {
                        return false;
                    }
                    break;
            }
        } else if (TELEPORTATION_BOX.equals(type) && !useTeleportationBoxes) {
            return false;
        } else if (TELEPORTATION_LEVER.equals(type) && !useTeleportationLevers) {
            return false;
        } else if (TELEPORTATION_MINIGAME.equals(type) && !useTeleportationMinigames) {
            return false;
        } else if (TELEPORTATION_PORTAL.equals(type) && !useTeleportationPortals) {
            return false;
        } else if (TELEPORTATION_SPELL.equals(type) && !useTeleportationSpells) {
            return false;
        } else if (WILDERNESS_OBELISK.equals(type) && !useWildernessObelisks) {
            return false;
        }

        if (isQuestLocked && !completedQuests(transport)) {
            return false;
        }

        if (!varbitChecks(transport)) {
            return false;
        }

        if (!varPlayerChecks(transport)) {
            return false;
        }

        return true;
    }

    /** Checks if the player has all the required skill levels for the transport */
    private boolean hasRequiredLevels(Transport transport) {
        int[] requiredLevels = transport.getSkillLevels();
        for (int i = 0; i < boostedLevels.length; i++) {
            int boostedLevel = boostedLevels[i];
            int requiredLevel = requiredLevels[i];
            if (boostedLevel < requiredLevel) {
                return false;
            }
        }
        return true;
    }

    /** Checks if the player has all the required equipment and inventory items for the transport */
    private boolean hasRequiredItems(Transport transport) {
        if ((TeleportationItem.ALL.equals(useTeleportationItems) ||
            TeleportationItem.ALL_NON_CONSUMABLE.equals(useTeleportationItems)) &&
            TransportType.TELEPORTATION_ITEM.equals(transport.getType())) {
            return true;
        }
        if (TeleportationItem.NONE.equals(useTeleportationItems) &&
            TransportType.TELEPORTATION_ITEM.equals(transport.getType())) {
            return false;
        }
        return hasRequiredItems(transport.getItemRequirements());
    }

    /** Checks if the player has all the required equipment and inventory items for the transport */
    private boolean hasRequiredItems(TransportItems transportItems) {
        if (transportItems == null) {
            return true;
        }
        itemsAndQuantities.clear();
        ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);
        ItemContainer equipment = client.getItemContainer(InventoryID.EQUIPMENT);
        if (inventory != null) {
            for (Item item : inventory.getItems()) {
                if (item.getId() >= 0 && item.getQuantity() > 0) {
                    itemsAndQuantities.put(item.getId(), item.getQuantity());
                }
            }
        }
        if (equipment != null) {
            for (Item item : equipment.getItems()) {
                if (item.getId() >= 0 && item.getQuantity() > 0) {
                    itemsAndQuantities.put(item.getId(), item.getQuantity());
                }
            }
        }
        if (bank != null
            && (TeleportationItem.INVENTORY_AND_BANK.equals(useTeleportationItems)
            || TeleportationItem.INVENTORY_AND_BANK_NON_CONSUMABLE.equals(useTeleportationItems))) {
            for (Item item : bank.getItems()) {
                if (item.getId() >= 0 && item.getQuantity() > 0) {
                    itemsAndQuantities.put(item.getId(), item.getQuantity());
                }
            }
        }
        if (RUNE_POUCHES.stream().anyMatch(runePouch -> itemsAndQuantities.containsKey(runePouch))) {
            EnumComposition runePouchEnum = client.getEnum(EnumID.RUNEPOUCH_RUNE);
            for (int i = 0; i < RUNE_POUCH_RUNE_VARBITS.length; i++) {
                int runeEnumId = client.getVarbitValue(RUNE_POUCH_RUNE_VARBITS[i]);
                int runeId = runeEnumId > 0 ? runePouchEnum.getIntValue(runeEnumId) : 0;
                int runeAmount = client.getVarbitValue(RUNE_POUCH_AMOUNT_VARBITS[i]);
                if (runeId > 0 && runeAmount > 0) {
                    itemsAndQuantities.put(runeId, runeAmount);
                }
            }
        }
        boolean usingStaff = false;
        boolean usingOffhand = false;
        for (int i = 0; i < transportItems.getItems().length; i++) {
            boolean missing = true;
            if (transportItems.getItems()[i] != null) {
                for (int itemId : transportItems.getItems()[i]) {
                    int quantity = itemsAndQuantities.getOrDefault(itemId, 0);
                    int requiredQuantity = transportItems.getQuantities()[i];
                    if (requiredQuantity > 0 && quantity >= requiredQuantity || requiredQuantity == 0 && quantity == 0) {
                        if (CURRENCIES.contains(itemId) && requiredQuantity > currencyThreshold) {
                            return false;
                        }
                        missing = false;
                        break;
                    }
                }
            }
            if (missing && !usingStaff && transportItems.getStaves()[i] != null) {
                for (int itemId : transportItems.getStaves()[i]) {
                    int quantity = itemsAndQuantities.getOrDefault(itemId, 0);
                    int requiredQuantity = transportItems.getQuantities()[i];
                    if (requiredQuantity > 0 && quantity >= 1 || requiredQuantity == 0 && quantity == 0) {
                        usingStaff = true;
                        missing = false;
                        break;
                    }
                }
            }
            if (missing && !usingOffhand && transportItems.getOffhands()[i] != null) {
                for (int itemId : transportItems.getOffhands()[i]) {
                    int quantity = itemsAndQuantities.getOrDefault(itemId, 0);
                    int requiredQuantity = transportItems.getQuantities()[i];
                    if (requiredQuantity > 0 && quantity >= 1 || requiredQuantity == 0 && quantity == 0) {
                        usingOffhand = true;
                        missing = false;
                        break;
                    }
                }
            }
            if (missing) {
                return false;
            }
        }
        return true;
    }
}

package shortestpath.pathfinder;

import java.util.ArrayDeque;
import java.util.Deque;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Set;
import lombok.Getter;
import shortestpath.PrimitiveIntList;
import shortestpath.ShortestPathPlugin;
import shortestpath.WorldPointUtil;

public class Pathfinder implements Runnable {
    private PathfinderStats stats;
    private volatile boolean done = false;
    private volatile boolean cancelled = false;

    @Getter
    private final int start;
    @Getter
    private final Set<Integer> targets;

    private final ShortestPathPlugin plugin;
    private final PathfinderConfig config;
    private final CollisionMap map;
    private final boolean targetInWilderness;

    // Capacities should be enough to store all nodes without requiring the queue to grow
    // They were found by checking the max queue size
    private final Deque<Node> boundary = new ArrayDeque<>(4096);
    private final Queue<Node> pending = new PriorityQueue<>(256);
    private final VisitedTiles visited;

    private PrimitiveIntList path = new PrimitiveIntList();
    private boolean pathNeedsUpdate = false;
    private Node bestLastNode;
    /**
     * Teleportation transports are updated when this changes.
     * Can be either:
     *  0 = all teleports can be used (e.g. Chronicle)
     * 20 = most teleports can be used (e.g. Varrock Teleport)
     * 30 = some teleports can be used (e.g. Amulet of Glory)
     * 31 = no teleports can be used
     */
    private int wildernessLevel;

    public Pathfinder(ShortestPathPlugin plugin, PathfinderConfig config, int start, Set<Integer> targets) {
        stats = new PathfinderStats();
        this.plugin = plugin;
        this.config = config;
        this.map = config.getMap();
        this.start = start;
        this.targets = targets;
        visited = new VisitedTiles(map);
        targetInWilderness = PathfinderConfig.isInWilderness(targets);
        wildernessLevel = 31;
    }

    public boolean isDone() {
        return done;
    }

    public void cancel() {
        cancelled = true;
    }

    public PathfinderStats getStats() {
        if (stats.started && stats.ended) {
            return stats;
        }

        // Don't give incomplete results
        return null;
    }

    public PrimitiveIntList getPath() {
        Node lastNode = bestLastNode; // For thread safety, read bestLastNode once
        if (lastNode == null) {
            return path;
        }

        if (pathNeedsUpdate) {
            path = lastNode.getPath();
            pathNeedsUpdate = false;
        }

        return path;
    }

    private void addNeighbors(Node node) {
        List<Node> nodes = map.getNeighbors(node, visited, config);
        for (int i = 0; i < nodes.size(); ++i) {
            Node neighbor = nodes.get(i);

            if (config.avoidWilderness(node.packedPosition, neighbor.packedPosition, targetInWilderness)) {
                continue;
            }

            visited.set(neighbor.packedPosition);
            if (neighbor instanceof TransportNode) {
                pending.add(neighbor);
                ++stats.transportsChecked;
            } else {
                boundary.addLast(neighbor);
                ++stats.nodesChecked;
            }
        }
    }

    @Override
    public void run() {
        stats.start();
        boundary.addFirst(new Node(start, null));

        int bestDistance = Integer.MAX_VALUE;
        long bestHeuristic = Integer.MAX_VALUE;
        long cutoffDurationMillis = config.getCalculationCutoffMillis();
        long cutoffTimeMillis = System.currentTimeMillis() + cutoffDurationMillis;

        while (!cancelled && (!boundary.isEmpty() || !pending.isEmpty())) {
            Node node = boundary.peekFirst();
            Node p = pending.peek();

            if (p != null && (node == null || p.cost < node.cost)) {
                node = pending.poll();
            } else {
                node = boundary.removeFirst();
            }

            if (wildernessLevel > 0) {
                // We don't need to remove teleports when going from 20 to 21 or higher,
                // because the teleport is either used at the very start of the
                // path or when going from 31 or higher to 30, or from 21 or higher to 20.

                boolean update = false;
                
                // These are overlapping boundaries, so if the node isn't in level 30, it's in 0-29
                // likewise, if the node isn't in level 20, it's in 0-19
                if (wildernessLevel > 30 && !PathfinderConfig.isInLevel30Wilderness(node.packedPosition)) {
                    wildernessLevel = 30;
                    update = true;
                }
                if (wildernessLevel > 20 && !PathfinderConfig.isInLevel20Wilderness(node.packedPosition)) {
                    wildernessLevel = 20;
                    update = true;
                }
                if (wildernessLevel > 0 && !PathfinderConfig.isInWilderness(node.packedPosition)) {
                    wildernessLevel = 0;
                    update = true;
                }
                if (update) {
                    config.refreshTeleports(node.packedPosition, wildernessLevel);
                }
            }

            if (targets.contains(node.packedPosition)) {
                bestLastNode = node;
                pathNeedsUpdate = true;
                break;
            }

            for (int target : targets) {
                int distance = WorldPointUtil.distanceBetween(node.packedPosition, target);
                long heuristic = distance + (long) WorldPointUtil.distanceBetween(node.packedPosition, target, 2);
                if (heuristic < bestHeuristic || (heuristic <= bestHeuristic && distance < bestDistance)) {
                    bestLastNode = node;
                    pathNeedsUpdate = true;
                    bestDistance = distance;
                    bestHeuristic = heuristic;
                    cutoffTimeMillis = System.currentTimeMillis() + cutoffDurationMillis;
                }
            }

            if (System.currentTimeMillis() > cutoffTimeMillis) {
                break;
            }

            addNeighbors(node);
        }

        done = !cancelled;

        boundary.clear();
        visited.clear();
        pending.clear();

        stats.end(); // Include cleanup in stats to get the total cost of pathfinding

        plugin.postPluginMessages();
    }

    public static class PathfinderStats {
        @Getter
        private int nodesChecked = 0, transportsChecked = 0;
        private long startNanos, endNanos;
        private volatile boolean started = false, ended = false;

        public int getTotalNodesChecked() {
            return nodesChecked + transportsChecked;
        }

        public long getElapsedTimeNanos() {
            return endNanos - startNanos;
        }

        private void start() {
            started = true;
            nodesChecked = 0;
            transportsChecked = 0;
            startNanos = System.nanoTime();
        }

        private void end() {
            endNanos = System.nanoTime();
            ended = true;
        }
    }
}

package shortestpath;

import java.util.Map;

import lombok.Getter;

public class TransportVarPlayer {
    @Getter
    private final int id;
    private final int value;
    private final TransportVarCheck check;

    public TransportVarPlayer(int id, int value, TransportVarCheck check) {
        this.id = id;
        this.value = value;
        this.check = check;
    }

    public boolean check(Map<Integer, Integer> values) {
        switch (check) {
            case EQUAL:
                return values.get(id) == value;
            case GREATER:
                return values.get(id) > value;
            case SMALLER:
                return values.get(id) < value;
            case BIT_SET:
                return (values.get(id) & value) > 0;
            case COOLDOWN_MINUTES:
                return ((System.currentTimeMillis() / 60000) - values.get(id)) > value;
        }
        return false;
    }
}

package shortestpath;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum TeleportationItem {
    NONE("None"),
    INVENTORY("Inventory"),
    INVENTORY_NON_CONSUMABLE("Inventory (perm)"),
    INVENTORY_AND_BANK("Inventory and Bank"),
    INVENTORY_AND_BANK_NON_CONSUMABLE("Inventory and Bank (perm)"),
    ALL("All"),
    ALL_NON_CONSUMABLE("All (perm)"),
    ;

    private final String type;

    @Override
    public String toString() {
        return type;
    }

    public static TeleportationItem fromType(String type) {
        for (TeleportationItem teleportationItem : values()) {
            if (teleportationItem.type.equals(type)) {
                return teleportationItem;
            }
        }
        return null;
    }
}

package shortestpath;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * General utility helpers for I/O and primitive array manipulation used by the shortest path plugin.
 */
public class Util {
    /**
     * Reads all bytes from the provided {@link InputStream} until EOF.
     * This method does not close the stream; the caller retains responsibility for resource management.
     *
     * @param in the input stream to read from.
     * @return a newly allocated byte array containing all bytes read (may be empty, never {@code null}).
     * @throws IOException if an I/O error occurs while reading.
     */
    public static byte[] readAllBytes(InputStream in) throws IOException {
        ByteArrayOutputStream result = new ByteArrayOutputStream();
        byte[] buffer = new byte[1024];

        while (true) {
            int read = in.read(buffer, 0, buffer.length);

            if (read == -1) {
                return result.toByteArray();
            }

            result.write(buffer, 0, read);
        }
    }

    /**
     * Concatenates the contents of multiple {@code int[]} arrays into one contiguous array.
     * {@code null} elements in {@code arrays} are skipped. If all arrays are {@code null} or empty, {@code null}
     * is returned (this mirrors the existing behavior relied upon by callers).
     *
     * @param arrays an array of {@code int[]} segments to concatenate (may contain {@code null}).
     * @return a new combined array, or {@code null} if there are no elements to copy.
     */
    public static int[] concatenate(int[][] arrays) {
        int n = 0;
        for (int i = 0; i < arrays.length; i++) {
            n += (arrays[i] == null) ? 0 : arrays[i].length;
        }
        if (n == 0) {
            return null;
        }
        int[] array = new int[n];
        int k = 0;
        for (int i = 0; i < arrays.length; i++) {
            if (arrays[i] != null) {
                for (int j = 0; j < arrays[i].length; j++) {
                    array[k++] = arrays[i][j];
                }
            }
        }
        return array;
    }
}

package shortestpath;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum TileStyle {
    TILES("Tiles"),
    LINES("Lines");

    private final String type;

    public static TileStyle fromType(String type) {
        for (TileStyle tileStyle : values()) {
            if (tileStyle.type.equals(type)) {
                return tileStyle;
            }
        }
        return null;
    }
}

package shortestpath;

import net.runelite.api.gameval.ItemID;
import lombok.Getter;

public enum ItemVariations {
    AIR_RUNE(ItemID.AIRRUNE,
        ItemID.MISTRUNE,
        ItemID.DUSTRUNE,
        ItemID.SMOKERUNE),
    ARDOUGNE_CLOAK(ItemID.ARDY_CAPE_EASY,
        ItemID.ARDY_CAPE_MEDIUM,
        ItemID.ARDY_CAPE_HARD,
        ItemID.ARDY_CAPE_ELITE,
        ItemID.SKILLCAPE_MAX_ARDY),
    ASTRAL_RUNE(ItemID.ASTRALRUNE),
    AXE(ItemID.BRONZE_AXE,
        ItemID.IRON_AXE,
        ItemID.STEEL_AXE,
        ItemID.BLACK_AXE,
        ItemID.MITHRIL_AXE,
        ItemID.ADAMANT_AXE,
        ItemID.RUNE_AXE,
        ItemID.DRAGON_AXE,
        ItemID.INFERNAL_AXE,
        ItemID._3A_AXE,
        ItemID.CRYSTAL_AXE),
    BANANA(ItemID.BANANA),
    BLOOD_RUNE(ItemID.BLOODRUNE),
    BROWN_APRON(ItemID.BROWN_APRON,
        ItemID.GOLDEN_APRON,
        ItemID.SKILLCAPE_CRAFTING,
        ItemID.SKILLCAPE_CRAFTING_TRIMMED,
        ItemID.SKILLCAPE_CRAFTING_HOOD),
    BRYOPHYTAS_STAFF(ItemID.NATURE_STAFF_CHARGED),
    CAPESLOT(ItemID.CASTLEWARS_HOOD_SARADOMIN_PRIZE, // TODO: also use slot or item category
        ItemID.CASTLEWARS_HOOD_ZAMORAK_PRIZE),
    CLIMBING_BOOTS(ItemID.DEATH_CLIMBINGBOOTS,
        ItemID.CLIMBING_BOOTS_G),
    COINS(ItemID.COINS),
    CROSSBOW(ItemID.CROSSBOW,
        ItemID.PHOENIX_CROSSBOW,
        ItemID.DTTD_BONE_CROSSBOW,
        ItemID.HUNTING_CROSSBOW,
        ItemID.XBOWS_CROSSBOW_BRONZE,
        ItemID.XBOWS_CROSSBOW_IRON,
        ItemID.XBOWS_CROSSBOW_STEEL,
        ItemID.XBOWS_CROSSBOW_MITHRIL,
        ItemID.XBOWS_CROSSBOW_ADAMANTITE,
        ItemID.XBOWS_CROSSBOW_RUNITE,
        ItemID.XBOWS_CROSSBOW_DRAGON,
        ItemID.DRAGONHUNTER_XBOW,
        ItemID.BARROWS_KARIL_WEAPON,
        ItemID.BARROWS_KARIL_WEAPON_BROKEN,
        ItemID.BARROWS_KARIL_WEAPON_25,
        ItemID.BARROWS_KARIL_WEAPON_50,
        ItemID.BARROWS_KARIL_WEAPON_75,
        ItemID.BARROWS_KARIL_WEAPON_100,
        ItemID.ACB,
        ItemID.ZARYTE_XBOW),
    DRAMEN_STAFF(ItemID.DRAMEN_STAFF,
        ItemID.DRAMEN_STAFF_AIR,
        ItemID.DRAMEN_STAFF_FIRE,
        ItemID.DRAMEN_STAFF_WATER,
        ItemID.LUNAR_MOONCLAN_LIMINAL_STAFF),
    DUST_BATTLESTAFF(ItemID.DUST_BATTLESTAFF,
        ItemID.MYSTIC_DUST_BATTLESTAFF),
    DUST_RUNE(ItemID.DUSTRUNE),
    DUSTY_KEY(ItemID.DUSTY_KEY),
    EARTH_RUNE(ItemID.EARTHRUNE,
        ItemID.DUSTRUNE,
        ItemID.MUDRUNE,
        ItemID.LAVARUNE),
    ECTO_TOKEN(ItemID.ECTOTOKEN),
    FIRE_RUNE(ItemID.FIRERUNE,
        ItemID.SMOKERUNE,
        ItemID.STEAMRUNE,
        ItemID.LAVARUNE),
    GAMES_NECKLACE(ItemID.NECKLACE_OF_MINIGAMES_8,
        ItemID.NECKLACE_OF_MINIGAMES_7,
        ItemID.NECKLACE_OF_MINIGAMES_6,
        ItemID.NECKLACE_OF_MINIGAMES_5,
        ItemID.NECKLACE_OF_MINIGAMES_4,
        ItemID.NECKLACE_OF_MINIGAMES_3,
        ItemID.NECKLACE_OF_MINIGAMES_2,
        ItemID.NECKLACE_OF_MINIGAMES_1),
    GLOWING_FUNGUS(ItemID.GLOWING_FUNGUS),
    HEADSLOT(ItemID.CASTLEWARS_CLOAK_SARADOMIN_PRIZE, // TODO: also use slot or item category
        ItemID.CASTLEWARS_CLOAK_ZAMORAK_PRIZE),
    LAVA_BATTLESTAFF(ItemID.LAVA_BATTLESTAFF,
        ItemID.MYSTIC_LAVA_STAFF),
    LAVA_RUNE(ItemID.LAVARUNE),
    LAW_RUNE(ItemID.LAWRUNE),
    MACHETE(ItemID.MACHETTE,
        ItemID.MACHETTE_OPAL,
        ItemID.MACHETTE_JADE,
        ItemID.MACHETTE_REDTOPAZ),
    MAX_CAPE(ItemID.SKILLCAPE_MAX,
        ItemID.SKILLCAPE_MAX_WORN,
        ItemID.SKILLCAPE_MAX_FIRECAPE,
        ItemID.SKILLCAPE_MAX_FIRECAPE_DUMMY,
        ItemID.SKILLCAPE_MAX_FIRECAPE_TROUVER,
        ItemID.SKILLCAPE_MAX_SARADOMIN,
        ItemID.SKILLCAPE_MAX_ZAMORAK,
        ItemID.SKILLCAPE_MAX_GUTHIX,
        ItemID.SKILLCAPE_MAX_ANMA,
        ItemID.SKILLCAPE_MAX_ARDY,
        ItemID.SKILLCAPE_MAX_INFERNALCAPE,
        ItemID.SKILLCAPE_MAX_INFERNALCAPE_DUMMY,
        ItemID.SKILLCAPE_MAX_INFERNALCAPE_TROUVER,
        ItemID.SKILLCAPE_MAX_SARADOMIN2,
        ItemID.SKILLCAPE_MAX_SARADOMIN2_TROUVER,
        ItemID.SKILLCAPE_MAX_ZAMORAK2,
        ItemID.SKILLCAPE_MAX_ZAMORAK2_TROUVER,
        ItemID.SKILLCAPE_MAX_GUTHIX2,
        ItemID.SKILLCAPE_MAX_GUTHIX2_TROUVER,
        ItemID.SKILLCAPE_MAX_ASSEMBLER,
        ItemID.SKILLCAPE_MAX_ASSEMBLER_TROUVER,
        ItemID.SKILLCAPE_MAX_MYTHICAL,
        ItemID.SKILLCAPE_MAX_ASSEMBLER_MASORI,
        ItemID.SKILLCAPE_MAX_ASSEMBLER_MASORI_TROUVER,
        ItemID.SKILLCAPE_MAX_DIZANAS,
        ItemID.SKILLCAPE_MAX_DIZANAS_TROUVER),
    MAX_HOOD(ItemID.SKILLCAPE_MAX_HOOD,
        ItemID.SKILLCAPE_MAX_HOOD_FIRECAPE,
        ItemID.SKILLCAPE_MAX_HOOD_SARADOMIN,
        ItemID.SKILLCAPE_MAX_HOOD_ZAMORAK,
        ItemID.SKILLCAPE_MAX_HOOD_GUTHIX,
        ItemID.SKILLCAPE_MAX_HOOD_ANMA,
        ItemID.SKILLCAPE_MAX_HOOD_ARDY,
        ItemID.SKILLCAPE_MAX_HOOD_INFERNALCAPE,
        ItemID.SKILLCAPE_MAX_HOOD_SARADOMIN2,
        ItemID.SKILLCAPE_MAX_HOOD_ZAMORAK2,
        ItemID.SKILLCAPE_MAX_HOOD_GUTHIX2,
        ItemID.SKILLCAPE_MAX_HOOD_ASSEMBLER,
        ItemID.SKILLCAPE_MAX_HOOD_MYTHICAL,
        ItemID.SKILLCAPE_MAX_HOOD_ASSEMBLER_MASORI,
        ItemID.SKILLCAPE_MAX_HOOD_DIZANAS),
    MAZE_KEY(ItemID.MELZARKEY),
    MIND_RUNE(ItemID.MINDRUNE),
    MIST_BATTLESTAFF(ItemID.MIST_BATTLESTAFF,
        ItemID.MYSTIC_MIST_BATTLESTAFF),
    MIST_RUNE(ItemID.MISTRUNE),
    MITH_GRAPPLE(ItemID.XBOWS_GRAPPLE_TIP_BOLT_MITHRIL_ROPE),
    MUD_BATTLESTAFF(ItemID.MUD_BATTLESTAFF,
        ItemID.MYSTIC_MUD_STAFF),
    MUD_RUNE(ItemID.MUDRUNE),
    MYSTIC_DUST_STAFF(ItemID.MYSTIC_DUST_BATTLESTAFF),
    MYSTIC_LAVA_STAFF(ItemID.MYSTIC_LAVA_STAFF),
    MYSTIC_MIST_STAFF(ItemID.MYSTIC_MIST_BATTLESTAFF),
    MYSTIC_MUD_STAFF(ItemID.MYSTIC_MUD_STAFF),
    MYSTIC_SMOKE_STAFF(ItemID.MYSTIC_SMOKE_BATTLESTAFF),
    MYSTIC_STEAM_STAFF(ItemID.MYSTIC_STEAM_BATTLESTAFF),
    NATURE_RUNE(ItemID.NATURERUNE),
    ROPE(ItemID.ROPE),
    SHANTAY_PASS(ItemID.SHANTAY_PASS),
    SKAVID_MAP(ItemID.SKAVIDMAP),
    SMOKE_BATTLESTAFF(ItemID.SMOKE_BATTLESTAFF,
        ItemID.MYSTIC_SMOKE_BATTLESTAFF),
    SMOKE_RUNE(ItemID.SMOKERUNE),
    SOUL_RUNE(ItemID.SOULRUNE),
    STAFF_OF_AIR(ItemID.STAFF_OF_AIR,
        ItemID.AIR_BATTLESTAFF,
        ItemID.MIST_BATTLESTAFF,
        ItemID.DUST_BATTLESTAFF,
        ItemID.SMOKE_BATTLESTAFF,
        ItemID.MYSTIC_MIST_BATTLESTAFF,
        ItemID.MYSTIC_DUST_BATTLESTAFF,
        ItemID.MYSTIC_SMOKE_BATTLESTAFF),
    STAFF_OF_EARTH(ItemID.STAFF_OF_EARTH,
        ItemID.EARTH_BATTLESTAFF,
        ItemID.DUST_BATTLESTAFF,
        ItemID.MUD_BATTLESTAFF,
        ItemID.LAVA_BATTLESTAFF,
        ItemID.MYSTIC_DUST_BATTLESTAFF,
        ItemID.MYSTIC_MUD_STAFF,
        ItemID.MYSTIC_LAVA_STAFF),
    STAFF_OF_FIRE(ItemID.STAFF_OF_FIRE,
        ItemID.FIRE_BATTLESTAFF,
        ItemID.SMOKE_BATTLESTAFF,
        ItemID.STEAM_BATTLESTAFF,
        ItemID.LAVA_BATTLESTAFF,
        ItemID.MYSTIC_SMOKE_BATTLESTAFF,
        ItemID.MYSTIC_STEAM_BATTLESTAFF,
        ItemID.MYSTIC_LAVA_STAFF),
    STAFF_OF_WATER(ItemID.STAFF_OF_WATER,
        ItemID.WATER_BATTLESTAFF,
        ItemID.MIST_BATTLESTAFF,
        ItemID.MUD_BATTLESTAFF,
        ItemID.STEAM_BATTLESTAFF,
        ItemID.MYSTIC_MIST_BATTLESTAFF,
        ItemID.MYSTIC_MUD_STAFF,
        ItemID.MYSTIC_STEAM_BATTLESTAFF),
    STEAM_BATTLESTAFF(ItemID.STEAM_BATTLESTAFF,
        ItemID.MYSTIC_STEAM_BATTLESTAFF),
    STEAM_RUNE(ItemID.STEAMRUNE),
    TOME_OF_EARTH(ItemID.TOME_OF_EARTH),    
    TOME_OF_FIRE(ItemID.TOME_OF_FIRE),
    TOME_OF_WATER(ItemID.TOME_OF_WATER),
    WATER_RUNE(ItemID.WATERRUNE,
        ItemID.MISTRUNE,
        ItemID.MUDRUNE,
        ItemID.STEAMRUNE),
    ;

    @Getter
    private final int[] ids;

    ItemVariations(int... ids) {
        this.ids = ids;
    }

    public static int[] staves(ItemVariations itemVariation) {
        if (itemVariation == null) {
            return null;
        }
        switch (itemVariation) {
            case AIR_RUNE:
                return STAFF_OF_AIR.ids;
            case DUST_RUNE:
                return DUST_BATTLESTAFF.ids;
            case EARTH_RUNE:
                return STAFF_OF_EARTH.ids;
            case FIRE_RUNE:
                return STAFF_OF_FIRE.ids;
            case LAVA_RUNE:
                return LAVA_BATTLESTAFF.ids;
            case MIST_RUNE:
                return MIST_BATTLESTAFF.ids;
            case MUD_RUNE:
                return MUD_BATTLESTAFF.ids;
            case NATURE_RUNE:
                return BRYOPHYTAS_STAFF.ids;
            case SMOKE_RUNE:
                return SMOKE_BATTLESTAFF.ids;
            case STEAM_RUNE:
                return STEAM_BATTLESTAFF.ids;
            case WATER_RUNE:
                return STAFF_OF_WATER.ids;
            default:
                return null;
        }
    }

    public static int[] offhands(ItemVariations itemVariation) {
        if (itemVariation == null) {
            return null;
        }
        switch (itemVariation) {
            case EARTH_RUNE:
                return TOME_OF_EARTH.ids;
            case FIRE_RUNE:
                return TOME_OF_FIRE.ids;
            case WATER_RUNE:
                return TOME_OF_WATER.ids;
            default:
                return null;
        }
    }

    public static ItemVariations fromName(String name) {
        for (ItemVariations itemVariations : ItemVariations.values()) {
            if (itemVariations.name().equals(name)) {
                return itemVariations;
            }
        }
        return null;
    }
}

package shortestpath;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import lombok.Getter;
import net.runelite.api.Quest;
import net.runelite.api.Skill;
import lombok.extern.slf4j.Slf4j;

/**
 * This class represents a travel point between two WorldPoints.
 */
@Slf4j
public class Transport {
    public static final int UNDEFINED_ORIGIN = WorldPointUtil.UNDEFINED;
    public static final int UNDEFINED_DESTINATION = WorldPointUtil.UNDEFINED;
    /** A location placeholder different from null to use for permutation transports */
    private static final int LOCATION_PERMUTATION = WorldPointUtil.packWorldPoint(-1, -1, 1);
    private static final String DELIM_SPACE = " ";
    private static final String DELIM_MULTI = ";";
    private static final String DELIM_STATE = "=";
    private static final String DELIM_AND = "&";
    private static final String DELIM_OR = "|";

    /** The starting point of this transport */
    @Getter
    private int origin = UNDEFINED_ORIGIN;

    /** The ending point of this transport */
    @Getter
    private int destination = UNDEFINED_DESTINATION;

    /** The skill levels required to use this transport */
    @Getter
    private final int[] skillLevels = new int[Skill.values().length];

    /** The quests required to use this transport */
    @Getter
    private Set<Quest> quests = new HashSet<>();

    /** The item requirements to use this transport */
    @Getter
    private TransportItems itemRequirements;

    /** The type of transport */
    @Getter
    private TransportType type;

    /** The travel waiting time in number of ticks */
    @Getter
    private int duration;

    /** Info to display for this transport. For spirit trees, fairy rings,
     * and others, this is the destination option to pick. */
    @Getter
    private String displayInfo = null;

    /** If this is an item transport, this tracks if it is consumable (as opposed to having infinite uses) */
    @Getter
    private boolean isConsumable = false;

    /** The maximum wilderness level that the transport can be used in */
    @Getter
    private int maxWildernessLevel = -1;

    /** Object information for this transport */
    @Getter
    private String objectInfo = null;

    /** Any varbits to check for the transport to be valid. All must pass for a transport to be valid */
    @Getter
    private final Set<TransportVarbit> varbits = new HashSet<>();

    /** Any varplayers to check for the transport to be valid. All must pass for a transport to be valid */
    @Getter
    private final Set<TransportVarPlayer> varPlayers = new HashSet<>();

    /** Creates a new transport from an origin-only transport
     * and a destination-only transport, and merges requirements */
    Transport(Transport origin, Transport destination) {
        this.origin = origin.origin;
        this.destination = destination.destination;

        for (int i = 0; i < skillLevels.length; i++) {
            this.skillLevels[i] = Math.max(
                origin.skillLevels[i],
                destination.skillLevels[i]);
        }

        this.quests.addAll(origin.quests);
        this.quests.addAll(destination.quests);

        this.itemRequirements = destination.itemRequirements;

        this.type = origin.type;

        this.duration = Math.max(
            origin.duration,
            destination.duration);

        this.displayInfo = destination.displayInfo;

        this.isConsumable |= origin.isConsumable;
        this.isConsumable |= destination.isConsumable;

        this.maxWildernessLevel = Math.max(
            origin.maxWildernessLevel,
            destination.maxWildernessLevel);

        this.objectInfo = origin.objectInfo;

        this.varbits.addAll(origin.varbits);
        this.varbits.addAll(destination.varbits);

        this.varPlayers.addAll(origin.varPlayers);
        this.varPlayers.addAll(destination.varPlayers);
    }

    Transport(Map<String, String> fieldMap, TransportType transportType) {
        String value;

        // If the origin field is null the transport is a teleportation item or spell
        // If the origin field has 3 elements it is a coordinate of a transport
        // Otherwise it is a transport that needs to be expanded into all permutations (e.g. fairy ring)
        if ((value = fieldMap.get("Origin")) != null) {
            String[] originArray = value.split(DELIM_SPACE);
            origin = originArray.length == 3 ? WorldPointUtil.packWorldPoint(
                Integer.parseInt(originArray[0]),
                Integer.parseInt(originArray[1]),
                Integer.parseInt(originArray[2])) : LOCATION_PERMUTATION;
        }

        if ((value = fieldMap.get("Destination")) != null) {
            String[] destinationArray = value.split(DELIM_SPACE);
            destination = destinationArray.length == 3 ? WorldPointUtil.packWorldPoint(
                Integer.parseInt(destinationArray[0]),
                Integer.parseInt(destinationArray[1]),
                Integer.parseInt(destinationArray[2])) : LOCATION_PERMUTATION;
        }

        if ((value = fieldMap.get("Skills")) != null) {
            String[] skillRequirements = value.split(DELIM_MULTI);

            try {
                for (String requirement : skillRequirements) {
                    if (requirement.isEmpty()) {
                        continue;
                    }
                    String[] levelAndSkill = requirement.split(DELIM_SPACE);
                    assert levelAndSkill.length == 2 : "Invalid level and skill: '" + requirement + "'";

                    int level = Integer.parseInt(levelAndSkill[0]);
                    String skillName = levelAndSkill[1];

                    Skill[] skills = Skill.values();
                    for (int i = 0; i < skills.length; i++) {
                        if (skills[i].getName().equals(skillName)) {
                            skillLevels[i] = level;
                            break;
                        }
                    }
                }
            } catch (NumberFormatException e) {
                log.error("Invalid level and skill: " + value);
            }
        }

        if ((value = fieldMap.get("Items")) != null && !value.isEmpty()) {
            value = value.replace(DELIM_SPACE, "");
            value = value.replace(DELIM_AND + DELIM_AND, DELIM_AND);
            value = value.replace(DELIM_OR + DELIM_OR, DELIM_OR);
            value = value.toUpperCase();
            String[] itemVariationAndQuantityList = value.split(DELIM_AND);
            try {
                int n = itemVariationAndQuantityList.length;
                int[][] items = new int[n][];
                int[][] staves = new int[n][];
                int[][] offhands = new int[n][];
                int[] quantities = new int[n];
                for (int i = 0; i < n; i++) {
                    int maxQuantity = -1;
                    String[] itemVariationsAndQuantities = itemVariationAndQuantityList[i].split("\\" + DELIM_OR);
                    int[][] multipleItems = new int[itemVariationsAndQuantities.length][];
                    int[][] multipleStaves = new int[itemVariationsAndQuantities.length][];
                    int[][] multipleOffhands = new int[itemVariationsAndQuantities.length][];
                    for (int k = 0; k < itemVariationsAndQuantities.length; k++) {
                        String[] itemVariationAndQuantity = itemVariationsAndQuantities[k].split(DELIM_STATE);
                        if (itemVariationAndQuantity.length == 2) {
                            ItemVariations itemVariations = ItemVariations.fromName(itemVariationAndQuantity[0]);
                            multipleItems[k] = itemVariations == null ? new int[]{Integer.parseInt(itemVariationAndQuantity[0])} : itemVariations.getIds();
                            multipleStaves[k] = ItemVariations.staves(itemVariations);
                            multipleOffhands[k] = ItemVariations.offhands(itemVariations);
                            maxQuantity = Math.max(maxQuantity, Integer.parseInt(itemVariationAndQuantity[1]));
                        } else {
                            throw new NumberFormatException(itemVariationAndQuantityList[i]);
                        }
                    }
                    items[i] = Util.concatenate(multipleItems);
                    staves[i] = Util.concatenate(multipleStaves);
                    offhands[i] = Util.concatenate(multipleOffhands);
                    quantities[i] = maxQuantity;
                }
                itemRequirements = new TransportItems(items, staves, offhands, quantities);
            } catch (NumberFormatException e) {
                log.error("Invalid item or quantity: " + value);
            }
        }

        if ((value = fieldMap.get("Quests")) != null) {
            this.quests = findQuests(value);
        }

        if ((value = fieldMap.get("Duration")) != null && !value.isEmpty()) {
            try {
                this.duration = Integer.parseInt(value);
            } catch (NumberFormatException e) {
                log.error("Invalid tick duration: " + value);
            }
        }
        if (TransportType.isTeleport(transportType)) {
            // Teleports should always have a non-zero wait,
            // so the pathfinder doesn't calculate the cost by distance
            this.duration = Math.max(this.duration, 1);
        }

        if ((value = fieldMap.get("Display info")) != null) {
            this.displayInfo = value;
        }

        if ((value = fieldMap.get("Consumable")) != null) {
            this.isConsumable = "T".equals(value) || "yes".equals(value.toLowerCase());
        }

        if ((value = fieldMap.get("Wilderness level")) != null && !value.isEmpty()) {
            try {
                this.maxWildernessLevel =  Integer.parseInt(value);
            } catch (NumberFormatException e) {
                log.error("Invalid wilderness level: " + value);
            }
        }

        if ((value = fieldMap.get("menuOption menuTarget objectID")) != null) {
            this.objectInfo = value;
        }

        if ((value = fieldMap.get("Varbits")) != null) {
            try {
                for (String varbitRequirement : value.split(DELIM_MULTI)) {
                    if (varbitRequirement.isEmpty()) {
                        continue;
                    }
                    String[] varbitParts = null;
                    for (TransportVarCheck check : TransportVarCheck.values()) {
                        varbitParts = varbitRequirement.split(check.getCode());
                        if (varbitParts.length == 2) {
                            int varbitId = Integer.parseInt(varbitParts[0]);
                            int varbitValue = Integer.parseInt(varbitParts[1]);
                            varbits.add(new TransportVarbit(varbitId, varbitValue, check));
                            break;
                        }
                    }
                    assert varbitParts.length == 2 : "Invalid varbit id and value: '" + varbitRequirement + "'";
                }
            } catch (NumberFormatException e) {
                log.error("Invalid varbit id and value: " + value);
            }
        }

        if ((value = fieldMap.get("VarPlayers")) != null) {
            try {
                for (String varPlayerRequirement : value.split(DELIM_MULTI)) {
                    if (varPlayerRequirement.isEmpty()) {
                        continue;
                    }
                    String[] varPlayerParts = null;
                    for (TransportVarCheck check : TransportVarCheck.values()) {
                        varPlayerParts = varPlayerRequirement.split(check.getCode());
                        if (varPlayerParts.length == 2) {
                            int varPlayerId = Integer.parseInt(varPlayerParts[0]);
                            int varPlayerValue = Integer.parseInt(varPlayerParts[1]);
                            varPlayers.add(new TransportVarPlayer(varPlayerId, varPlayerValue, check));
                            break;
                        }
                    }
                    assert varPlayerParts.length == 2 : "Invalid VarPlayer id and value: '" + varPlayerRequirement + "'";
                }
            } catch (NumberFormatException e) {
                log.error("Invalid VarPlayer id and value: " + value);
            }
        }

        this.type = transportType;
        if (TransportType.AGILITY_SHORTCUT.equals(transportType) &&
            (getRequiredLevel(Skill.RANGED) > 1 || getRequiredLevel(Skill.STRENGTH) > 1)) {
            this.type = TransportType.GRAPPLE_SHORTCUT;
        }
    }

    @Override
    public String toString() {
        return ("(" +
            WorldPointUtil.unpackWorldX(origin) + ", " +
            WorldPointUtil.unpackWorldY(origin) + ", " +
            WorldPointUtil.unpackWorldPlane(origin) + ") to ("+
            WorldPointUtil.unpackWorldX(destination) + ", " +
            WorldPointUtil.unpackWorldY(destination) + ", " +
            WorldPointUtil.unpackWorldPlane(destination) + ")");
    }

    /** The skill level required to use this transport */
    private int getRequiredLevel(Skill skill) {
        return skillLevels[skill.ordinal()];
    }

    /** Whether the transport has one or more quest requirements */
    public boolean isQuestLocked() {
        return !quests.isEmpty();
    }

    private static Set<Quest> findQuests(String questNamesCombined) {
        String[] questNames = questNamesCombined.split(";");
        Set<Quest> quests = new HashSet<>();
        for (String questName : questNames) {
            for (Quest quest : Quest.values()) {
                if (quest.getName().equals(questName)) {
                    quests.add(quest);
                    break;
                }
            }
        }
        return quests;
    }

    private static void addTransports(Map<Integer, Set<Transport>> transports, String path, TransportType transportType) {
        addTransports(transports, path, transportType, 0);
    }

    private static void addTransports(Map<Integer, Set<Transport>> transports, String path, TransportType transportType, int radiusThreshold) {
        final String DELIM_COLUMN = "\t";
        final String PREFIX_COMMENT = "#";

        try {
            String s = new String(Util.readAllBytes(ShortestPathPlugin.class.getResourceAsStream(path)), StandardCharsets.UTF_8);
            Scanner scanner = new Scanner(s);

            // Header line is the first line in the file and will start with either '#' or '# '
            String headerLine = scanner.nextLine();
            headerLine = headerLine.startsWith(PREFIX_COMMENT + " ") ? headerLine.replace(PREFIX_COMMENT + " ", PREFIX_COMMENT) : headerLine;
            headerLine = headerLine.startsWith(PREFIX_COMMENT) ? headerLine.replace(PREFIX_COMMENT, "") : headerLine;
            String[] headers = headerLine.split(DELIM_COLUMN);

            Set<Transport> newTransports = new HashSet<>();

            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();

                if (line.startsWith(PREFIX_COMMENT) || line.isBlank()) {
                    continue;
                }

                String[] fields = line.split(DELIM_COLUMN);
                Map<String, String> fieldMap = new HashMap<>();
                for (int i = 0; i < headers.length; i++) {
                    if (i < fields.length) {
                        fieldMap.put(headers[i], fields[i]);
                    }
                }

                Transport transport = new Transport(fieldMap, transportType);
                newTransports.add(transport);

            }
            scanner.close();

            /*
             * A transport with origin A and destination B is one-way and must
             * be duplicated as origin B and destination A to become two-way.
             * Example: key-locked doors
             * 
             * A transport with origin A and a missing destination is one-way,
             * but can go from origin A to all destinations with a missing origin.
             * Example: fairy ring AIQ -> <blank>
             * 
             * A transport with a missing origin and destination B is one-way,
             * but can go from all origins with a missing destination to destination B.
             * Example: fairy ring <blank> -> AIQ
             * 
             * Identical transports from origin A to destination A are skipped, and
             * non-identical transports from origin A to destination A can be skipped
             * by specifying a radius threshold to ignore almost identical coordinates.
             * Example: fairy ring AIQ -> AIQ
             */
            Set<Transport> transportOrigins = new HashSet<>();
            Set<Transport> transportDestinations = new HashSet<>();
            for (Transport transport : newTransports) {
                int origin = transport.getOrigin();
                int destination = transport.getDestination();
                // Logic to determine ordinary transport vs teleport vs permutation (e.g. fairy ring)
                if ((origin == UNDEFINED_ORIGIN && destination == UNDEFINED_DESTINATION)
                    || (origin == LOCATION_PERMUTATION && destination == LOCATION_PERMUTATION)) {
                    continue;
                } else if (origin != LOCATION_PERMUTATION && origin != UNDEFINED_ORIGIN
                    && destination == LOCATION_PERMUTATION) {
                    transportOrigins.add(transport);
                } else if (origin == LOCATION_PERMUTATION
                    && destination != LOCATION_PERMUTATION && destination != UNDEFINED_DESTINATION) {
                    transportDestinations.add(transport);
                }
                if (origin != LOCATION_PERMUTATION
                    && destination != UNDEFINED_DESTINATION && destination != LOCATION_PERMUTATION
                    && (origin == UNDEFINED_ORIGIN || origin != destination)) {
                    transports.computeIfAbsent(origin, k -> new HashSet<>()).add(transport);
                }
            }
            for (Transport origin : transportOrigins) {
                for (Transport destination : transportDestinations) {
                    // The radius threshold prevents transport permutations from including (almost) same origin and destination
                    if (WorldPointUtil.distanceBetween2D(origin.getOrigin(), destination.getDestination()) > radiusThreshold) {
                        transports.computeIfAbsent(origin.getOrigin(), k -> new HashSet<>())
                            .add(new Transport(origin, destination));
                    }
                }
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public static HashMap<Integer, Set<Transport>> loadAllFromResources() {
        HashMap<Integer, Set<Transport>> transports = new HashMap<>();
        addTransports(transports, "/transports/transports.tsv", TransportType.TRANSPORT);
        addTransports(transports, "/transports/agility_shortcuts.tsv", TransportType.AGILITY_SHORTCUT);
        addTransports(transports, "/transports/boats.tsv", TransportType.BOAT);
        addTransports(transports, "/transports/canoes.tsv", TransportType.CANOE);
        addTransports(transports, "/transports/charter_ships.tsv", TransportType.CHARTER_SHIP);
        addTransports(transports, "/transports/ships.tsv", TransportType.SHIP);
        addTransports(transports, "/transports/fairy_rings.tsv", TransportType.FAIRY_RING);
        addTransports(transports, "/transports/gnome_gliders.tsv", TransportType.GNOME_GLIDER, 6);
        addTransports(transports, "/transports/hot_air_balloons.tsv", TransportType.HOT_AIR_BALLOON, 7);
        addTransports(transports, "/transports/magic_carpets.tsv", TransportType.MAGIC_CARPET);
        addTransports(transports, "/transports/magic_mushtrees.tsv", TransportType.MAGIC_MUSHTREE, 5);
        addTransports(transports, "/transports/minecarts.tsv", TransportType.MINECART);
        addTransports(transports, "/transports/quetzals.tsv", TransportType.QUETZAL);
        addTransports(transports, "/transports/spirit_trees.tsv", TransportType.SPIRIT_TREE, 5);
        addTransports(transports, "/transports/teleportation_items.tsv", TransportType.TELEPORTATION_ITEM);
        addTransports(transports, "/transports/teleportation_boxes.tsv", TransportType.TELEPORTATION_BOX);
        addTransports(transports, "/transports/teleportation_levers.tsv", TransportType.TELEPORTATION_LEVER);
        addTransports(transports, "/transports/teleportation_minigames.tsv", TransportType.TELEPORTATION_MINIGAME);
        addTransports(transports, "/transports/teleportation_portals.tsv", TransportType.TELEPORTATION_PORTAL);
        addTransports(transports, "/transports/teleportation_spells.tsv", TransportType.TELEPORTATION_SPELL);
        addTransports(transports, "/transports/wilderness_obelisks.tsv", TransportType.WILDERNESS_OBELISK);
        return transports;
    }
}

package shortestpath;

import com.google.inject.Inject;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.geom.Line2D;
import java.awt.geom.Rectangle2D;
import java.util.HashSet;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.Tile;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import shortestpath.pathfinder.CollisionMap;

public class PathTileOverlay extends Overlay {
    private final Client client;
    private final ShortestPathPlugin plugin;
    private static final int TRANSPORT_LABEL_GAP = 3;

    @Inject
    public PathTileOverlay(Client client, ShortestPathPlugin plugin) {
        this.client = client;
        this.plugin = plugin;
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(Overlay.PRIORITY_LOW);
        setLayer(OverlayLayer.ABOVE_SCENE);
    }

    private void renderTransports(Graphics2D graphics) {
        for (int a : plugin.getTransports().keySet()) {
            if (a == Transport.UNDEFINED_ORIGIN) {
                continue; // skip teleports
            }

            boolean drawStart = false;

            Point ca = tileCenter(a);

            if (ca == null) {
                continue;
            }

            StringBuilder s = new StringBuilder();
            for (Transport b : plugin.getTransports().getOrDefault(a, new HashSet<>())) {
                if (b == null || TransportType.isTeleport(b.getType())) {
                    continue; // skip teleports
                }
                PrimitiveIntList destinations = WorldPointUtil.toLocalInstance(client, b.getDestination());
                for (int i = 0; i < destinations.size(); i++) {
                    int destination = destinations.get(i);
                    if (destination == Transport.UNDEFINED_DESTINATION) {
                        continue;
                    }
                    Point cb = tileCenter(destination);
                    if (cb != null) {
                        graphics.drawLine(ca.getX(), ca.getY(), cb.getX(), cb.getY());
                        drawStart = true;
                    }
                    if (WorldPointUtil.unpackWorldPlane(destination) > WorldPointUtil.unpackWorldPlane(a)) {
                        s.append("+");
                    } else if (WorldPointUtil.unpackWorldPlane(destination) < WorldPointUtil.unpackWorldPlane(a)) {
                        s.append("-");
                    } else {
                        s.append("=");
                    }
                }
            }

            if (drawStart) {
                drawTile(graphics, a, plugin.colourTransports, -1, true);
            }

            graphics.setColor(Color.WHITE);
            graphics.drawString(s.toString(), ca.getX(), ca.getY());
        }
    }

    private void renderCollisionMap(Graphics2D graphics) {
        CollisionMap map = plugin.getMap();
        for (Tile[] row : client.getScene().getTiles()[client.getPlane()]) {
            for (Tile tile : row) {
                if (tile == null) {
                    continue;
                }

                Polygon tilePolygon = Perspective.getCanvasTilePoly(client, tile.getLocalLocation());

                if (tilePolygon == null) {
                    continue;
                }

                int location = WorldPointUtil.fromLocalInstance(client, tile.getLocalLocation());
                int x = WorldPointUtil.unpackWorldX(location);
                int y = WorldPointUtil.unpackWorldY(location);
                int z = WorldPointUtil.unpackWorldPlane(location);

                String s = (!map.n(x, y, z) ? "n" : "") +
                        (!map.s(x, y, z) ? "s" : "") +
                        (!map.e(x, y, z) ? "e" : "") +
                        (!map.w(x, y, z) ? "w" : "");

                if (map.isBlocked(x, y, z)) {
                    graphics.setColor(plugin.colourCollisionMap);
                    graphics.fill(tilePolygon);
                }
                if (!s.isEmpty() && !s.equals("nsew")) {
                    graphics.setColor(Color.WHITE);
                    int stringX = (int) (tilePolygon.getBounds().getCenterX() - graphics.getFontMetrics().getStringBounds(s, graphics).getWidth() / 2);
                    int stringY = (int) tilePolygon.getBounds().getCenterY();
                    graphics.drawString(s, stringX, stringY);
                }
            }
        }
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (plugin.drawTransports) {
            renderTransports(graphics);
        }

        if (plugin.drawCollisionMap) {
            renderCollisionMap(graphics);
        }

        if (plugin.drawTiles && plugin.getPathfinder() != null && plugin.getPathfinder().getPath() != null) {
            Color colorCalculating = new Color(
                plugin.colourPathCalculating.getRed(),
                plugin.colourPathCalculating.getGreen(),
                plugin.colourPathCalculating.getBlue(),
                plugin.colourPathCalculating.getAlpha() / 2);
            Color color = plugin.getPathfinder().isDone()
                ? new Color(
                    plugin.colourPath.getRed(),
                    plugin.colourPath.getGreen(),
                    plugin.colourPath.getBlue(),
                    plugin.colourPath.getAlpha() / 2)
                : colorCalculating;

            PrimitiveIntList path = plugin.getPathfinder().getPath();
            int counter = 0;
            if (TileStyle.LINES.equals(plugin.pathStyle)) {
                for (int i = 1; i < path.size(); i++) {
                    drawLine(graphics, path.get(i - 1), path.get(i), color, 1 + counter++);
                    drawTransportInfo(graphics, path.get(i - 1), path.get(i));
                }
            } else {
                boolean showTiles = TileStyle.TILES.equals(plugin.pathStyle);
                for (int i = 0; i < path.size(); i++) {
                    drawTile(graphics, path.get(i), color, counter++, showTiles);
                    drawTransportInfo(graphics, path.get(i), (i + 1 == path.size()) ? WorldPointUtil.UNDEFINED : path.get(i + 1));
                }
                for (int target : plugin.getPathfinder().getTargets()) {
                    if (path.size() > 0 && target != path.get(path.size() - 1)) {
                        drawTile(graphics, target, colorCalculating, -1, showTiles);
                    }
                }
            }
        }

        return null;
    }

    private Point tileCenter(int b) {
        if (b == WorldPointUtil.UNDEFINED || client == null) {
            return null;
        }

        if (WorldPointUtil.unpackWorldPlane(b) != client.getPlane()) {
            return null;
        }

        LocalPoint lp = WorldPointUtil.toLocalPoint(client, b);
        if (lp == null) {
            return null;
        }

        Polygon poly = Perspective.getCanvasTilePoly(client, lp);
        if (poly == null) {
            return null;
        }

        int cx = poly.getBounds().x + poly.getBounds().width / 2;
        int cy = poly.getBounds().y + poly.getBounds().height / 2;
        return new Point(cx, cy);
    }

    private void drawTile(Graphics2D graphics, int location, Color color, int counter, boolean draw) {
        if (client == null) {
            return;
        }

        PrimitiveIntList points = WorldPointUtil.toLocalInstance(client, location);
        for (int i = 0; i < points.size(); i++) {
            int point = points.get(i);
            if (point == WorldPointUtil.UNDEFINED) {
                continue;
            }

            LocalPoint lp = WorldPointUtil.toLocalPoint(client, point);
            if (lp == null) {
                continue;
            }

            Polygon poly = Perspective.getCanvasTilePoly(client, lp);
            if (poly == null) {
                continue;
            }

            if (draw) {
                graphics.setColor(color);
                graphics.fill(poly);
            }

            drawCounter(graphics, poly.getBounds().getCenterX(), poly.getBounds().getCenterY(), counter);
        }
    }

    private void drawLine(Graphics2D graphics, int startLoc, int endLoc, Color color, int counter) {
        PrimitiveIntList starts = WorldPointUtil.toLocalInstance(client, startLoc);
        PrimitiveIntList ends = WorldPointUtil.toLocalInstance(client, endLoc);

        if (starts.isEmpty() || ends.isEmpty()) {
            return;
        }

        int start = starts.get(0);
        int end = ends.get(0);

        final int z = client.getPlane();
        if (WorldPointUtil.unpackWorldPlane(start) != z) {
            return;
        }

        LocalPoint lpStart = WorldPointUtil.toLocalPoint(client, start);
        LocalPoint lpEnd = WorldPointUtil.toLocalPoint(client, end);

        if (lpStart == null || lpEnd == null) {
            return;
        }

        final int startHeight = Perspective.getTileHeight(client, lpStart, z);
        final int endHeight = Perspective.getTileHeight(client, lpEnd, z);

        Point p1 = Perspective.localToCanvas(client, lpStart.getX(), lpStart.getY(), startHeight);
        Point p2 = Perspective.localToCanvas(client, lpEnd.getX(), lpEnd.getY(), endHeight);

        if (p1 == null || p2 == null) {
            return;
        }

        Line2D.Double line = new Line2D.Double(p1.getX(), p1.getY(), p2.getX(), p2.getY());

        graphics.setColor(color);
        graphics.setStroke(new BasicStroke(4));
        graphics.draw(line);

        if (counter == 1) {
            drawCounter(graphics, p1.getX(), p1.getY(), 0);
        }
        drawCounter(graphics, p2.getX(), p2.getY(), counter);
    }

    private void drawCounter(Graphics2D graphics, double x, double y, int counter) {
        if (counter >= 0 && !TileCounter.DISABLED.equals(plugin.showTileCounter)) {
            int n = plugin.tileCounterStep > 0 ? plugin.tileCounterStep : 1;
            int s = plugin.getPathfinder().getPath().size();
            if ((counter % n != 0) && (s != (counter + 1))) {
                return;
            }
            if (TileCounter.REMAINING.equals(plugin.showTileCounter)) {
                counter = s - counter - 1;
            }
            if (n > 1 && counter == 0) {
                return;
            }
            String counterText = Integer.toString(counter);
            graphics.setColor(plugin.colourText);
            graphics.drawString(
                counterText,
                (int) (x - graphics.getFontMetrics().getStringBounds(counterText, graphics).getWidth() / 2), (int) y);
        }
    }

    private void drawTransportInfo(Graphics2D graphics, int location, int locationEnd) {
        if (locationEnd == WorldPointUtil.UNDEFINED || !plugin.showTransportInfo ||
            WorldPointUtil.unpackWorldPlane(location) != client.getPlane()) {
            return;
        }

        // Workaround for weird pathing inside PoH to instead show info on the player tile
        LocalPoint playerLocalPoint = client.getLocalPlayer().getLocalLocation();
        int playerPackedPoint = WorldPointUtil.fromLocalInstance(client, playerLocalPoint);
        int px = WorldPointUtil.unpackWorldX(playerPackedPoint);
        int py = WorldPointUtil.unpackWorldY(playerPackedPoint);
        int tx = WorldPointUtil.unpackWorldX(location);
        int ty = WorldPointUtil.unpackWorldY(location);
        boolean transportAndPlayerInsidePoh = (tx >= 1792 && tx <= 2047 && ty >= 5696 && ty <= 5767
            && px >= 1792 && px <= 2047 && py >= 5696 && py <= 5767);

        int vertical_offset = 0;
        for (Transport transport : plugin.getTransports().getOrDefault(location, new HashSet<>())) {
            if (locationEnd != transport.getDestination()) {
                continue;
            }

            String text = transport.getDisplayInfo();
            if (text == null || text.isEmpty()) {
                continue;
            }

            PrimitiveIntList points = WorldPointUtil.toLocalInstance(client, location);
            for (int i = 0; i < points.size(); i++) {
                LocalPoint lp = WorldPointUtil.toLocalPoint(client, points.get(i));
                if (lp == null) {
                    continue;
                }

                Point p = Perspective.localToCanvas(client,
                    transportAndPlayerInsidePoh ? playerLocalPoint : lp, client.getPlane());
                if (p == null) {
                    continue;
                }

                Rectangle2D textBounds = graphics.getFontMetrics().getStringBounds(text, graphics);
                double height = textBounds.getHeight();
                int x = (int) (p.getX() - textBounds.getWidth() / 2);
                int y = (int) (p.getY() - height) - vertical_offset;
                graphics.setColor(Color.BLACK);
                graphics.drawString(text, x + 1, y + 1);
                graphics.setColor(plugin.colourText);
                graphics.drawString(text, x, y);

                vertical_offset += (int) height + TRANSPORT_LABEL_GAP;
            }
        }
    }
}

package shortestpath;

import java.util.Arrays;
import java.util.Collection;

/**
 * A lightweight hash map keyed by primitive {@code int} values with open addressed bucket arrays.
 * <p>
 * Each top-level slot in {@link #buckets} references an array (the "bucket") of entries. Buckets grow
 * individually when full, avoiding the cost of rehashing the entire map on every local expansion. When the
 * aggregate {@linkplain #size entry count} reaches the configured {@linkplain #capacity load threshold}, the
 * map resizes and rehashes all entries into a larger bucket array whose length is always a power of two.
 * <p>
 * This implementation is intentionally minimal and tailored for the plugin's pathfinding needs:
 * <ul>
 *   <li>No support for removing entries.</li>
 *   <li>No iteration views (keys, values, or entry set) are exposed.</li>
 *   <li>Collisions within a bucket are handled by linear probing inside the bucket array.</li>
 *   <li>Duplicate key insertion replaces the previous value, or appends collection contents when both the
 *       old and new values are {@link Collection}s (best effort; falls back to replacement on errors).</li>
 * </ul>
 * @param <V> the value type stored for each primitive {@code int} key. Must be non-null.
 */
public class PrimitiveIntHashMap<V> {
    private static final int MINIMUM_SIZE = 8;

    // Unless the hash function is really unbalanced, most things should fit within at least 8-element buckets
    // Buckets will grow as needed without forcing a rehash of the whole map
    private static final int DEFAULT_BUCKET_SIZE = 4;

    // How full the map should get before growing it again. Smaller values speed up lookup times at the expense of space
    private static final float DEFAULT_LOAD_FACTOR = 0.75f;

    /** Entry node storing a primitive key and associated value. */
    private static class IntNode<V> {
        private int key;
        private V value;

        private IntNode(int key, V value) {
            this.key = key;
            this.value = value;
        }
    }

    // If buckets become too large then it may be worth converting large buckets into an array-backed binary tree
    private IntNode<V>[][] buckets;
    private int size;
    private int capacity;
    private int maxSize;
    private int mask;
    private final float loadFactor;

    /**
     * Creates a new map with the specified initial size and the default load factor (0.75).
     *
     * @param initialSize initial expected number of elements; rounded to the next power of two internally.
     */
    public PrimitiveIntHashMap(int initialSize) {
        this(initialSize, DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new map with the given initial size and load factor.
     *
     * @param initialSize initial expected number of elements; rounded up to maintain a power-of-two capacity.
     * @param loadFactor a value in the range {@code [0.0, 1.0]} determining when the map rehashes. Higher values
     *                   reduce space overhead but increase average lookup cost.
     * @throws IllegalArgumentException if {@code loadFactor} is outside the inclusive range 0..1.
     */
    public PrimitiveIntHashMap(int initialSize, float loadFactor) {
        if (loadFactor < 0.0f || loadFactor > 1.0f) {
            throw new IllegalArgumentException("Load factor must be between 0 and 1");
        }

        this.loadFactor = loadFactor;
        size = 0;
        setNewSize(initialSize);
        recreateArrays();
    }

    /**
     * Returns the number of key/value pairs currently stored.
     *
     * @return current entry count (always {@code >= 0}).
     */
    public int size() {
        return size;
    }

    /**
     * Retrieves the value mapped to the provided key, or {@code null} if absent.
     *
     * @param key primitive key to look up.
     * @return the mapped value, or {@code null} if the key does not exist.
     */
    public V get(int key) {
        return getOrDefault(key, null);
    }

    /**
     * Retrieves the value mapped to the provided key.
     *
     * @param key primitive key to look up.
     * @param defaultValue value to return if the key is not present.
     * @return the mapped value, or {@code defaultValue} when absent.
     */
    public V getOrDefault(int key, V defaultValue) {
        int bucket = getBucket(key);
        int index = bucketIndex(key, bucket);
        if (index == -1) {
            return defaultValue;
        }
        return buckets[bucket][index].value;
    }

    /**
     * Associates the specified value with the given key.
     * <p>
     * If a mapping already exists and both the existing and new values implement {@link Collection}, the method
     * attempts to append all elements of the new collection into the existing one. If the append fails (e.g., due
     * to incompatible element types or an unsupported operation) the existing value is replaced entirely.
     * Otherwise the existing value is simply replaced.
     *
     * @param key primitive key to insert or update.
     * @param value non-null value to associate.
     * @param <E> inferred element type if both values are collections.
     * @return the previous value mapped to {@code key} (if any), or {@code null} if inserting a new entry.
     * @throws IllegalArgumentException if {@code value} is {@code null}.
     */
    @SuppressWarnings("unchecked")
    public <E> V put(int key, V value) {
        if (value == null) {
            throw new IllegalArgumentException("Cannot insert a null value");
        }

        int bucketIndex = getBucket(key);
        IntNode<V>[] bucket = buckets[bucketIndex];

        if (bucket == null) {
            buckets[bucketIndex] = createBucket(DEFAULT_BUCKET_SIZE);
            buckets[bucketIndex][0] = new IntNode<>(key, value);
            incrementSize();
            return null;
        }

        for (int i = 0; i < bucket.length; ++i) {
            if (bucket[i] == null) {
                bucket[i] = new IntNode<>(key, value);
                incrementSize();
                return null;
            } else if (bucket[i].key == key) {
                V previous = bucket[i].value;
                if (previous instanceof Collection<?> && value instanceof Collection<?>) { // append
                    try {
                        Collection<E> prevCollection = (Collection<E>) bucket[i].value;
                        Collection<E> newCollection = (Collection<E>) value;
                        prevCollection.addAll(newCollection);
                    } catch (ClassCastException | UnsupportedOperationException e) {
                        // If the collections contain incompatible types or the operation is not supported,
                        // just replace instead of append
                        bucket[i].value = value;
                    }
                } else { // replace
                    bucket[i].value = value;
                }
                return previous;
            }
        }

        // No space in the bucket, grow it
        growBucket(bucketIndex)[bucket.length] = new IntNode<>(key, value);
        incrementSize();
        return null;
    }

    /**
     * Hash function tuned for packed world point integer encodings. Mixes higher bits downward to
     * reduce clustering while remaining inexpensive.
     */
    private static int hash(int value) {
        return value ^ (value >>> 5) ^ (value >>> 25);
    }

    private int getBucket(int key) {
        return (hash(key) & 0x7FFFFFFF) & mask;
    }

    private int bucketIndex(int key, int bucketIndex) {
        IntNode<V>[] bucket = buckets[bucketIndex];
        if (bucket == null) {
            return -1;
        }

        for (int i = 0; i < bucket.length; ++i) {
            if (bucket[i] == null) {
                break;
            }
            if (bucket[i].key == key) {
                return i;
            }
        }

        // Searched the bucket and found nothing
        return -1;
    }

    private void incrementSize() {
        size++;
        if (size >= capacity) {
            rehash();
        }
    }

    private IntNode<V>[] growBucket(int bucketIndex) {
        IntNode<V>[] oldBucket = buckets[bucketIndex];
        IntNode<V>[] newBucket = createBucket(Math.min(oldBucket.length, Integer.MAX_VALUE / 2 - 4) * 2);
        System.arraycopy(oldBucket, 0, newBucket, 0, oldBucket.length);
        buckets[bucketIndex] = newBucket;
        return newBucket;
    }

    private int getNewMaxSize(int size) {
        int nextPow2 = -1 >>> Integer.numberOfLeadingZeros(size);
        if (nextPow2 >= (Integer.MAX_VALUE >>> 1)) {
            return (Integer.MAX_VALUE >>> 1) + 1;
        }
        return nextPow2 + 1;
    }

    private void setNewSize(int size) {
        if (size < MINIMUM_SIZE) {
            size = MINIMUM_SIZE - 1;
        }

        maxSize = getNewMaxSize(size);
        mask = maxSize - 1;
        capacity = (int)(maxSize * loadFactor);
    }

    private void growCapacity() {
        setNewSize(maxSize);
    }

    // Grow the bucket array then rehash all the values into new buckets and discard the old ones
    private void rehash() {
        growCapacity();

        IntNode<V>[][] oldBuckets = buckets;
        recreateArrays();

        for (int i = 0; i < oldBuckets.length; ++i) {
            IntNode<V>[] oldBucket = oldBuckets[i];
            if (oldBucket == null) {
                continue;
            }

            for (int ind = 0; ind < oldBucket.length; ++ind) {
                if (oldBucket[ind] == null) {
                    break;
                }

                int bucketIndex = getBucket(oldBucket[ind].key);
                IntNode<V>[] newBucket = buckets[bucketIndex];
                if (newBucket == null) {
                    newBucket = createBucket(DEFAULT_BUCKET_SIZE);
                    newBucket[0] = oldBucket[ind];
                    buckets[bucketIndex] = newBucket;
                } else {
                    int bInd;
                    for (bInd = 0; bInd < newBucket.length; ++bInd) {
                        if (newBucket[bInd] == null) {
                            newBucket[bInd] = oldBucket[ind];
                            break;
                        }
                    }

                    if (bInd >= newBucket.length) {
                        // No space in the target bucket; grow it and append the entry,
                        // but continue rehashing remaining entries instead of returning early.
                        IntNode<V>[] grown = growBucket(bucketIndex);
                        grown[newBucket.length] = oldBucket[ind];
                        continue;
                    }
                }
            }
        }
    }

    private void recreateArrays() {
        @SuppressWarnings({"unchecked", "SuspiciousArrayCast"})
        IntNode<V>[][] temp = (IntNode<V>[][])new IntNode[maxSize][];
        buckets = temp;
    }

    private IntNode<V>[] createBucket(int size) {
        @SuppressWarnings({"unchecked", "SuspiciousArrayCast"})
        IntNode<V>[] temp = (IntNode<V>[])new IntNode[size];
        return temp;
    }

    /**
     * Calculates the percentage of bucket capacity used prior to first null sentinel entries across all buckets.
     * <p>
     * For each non-null bucket, usage counts entries until the first {@code null} slot (which indicates the end
     * of populated entries for that bucket). The resulting percentage is: {@code usedEntrySlots / totalAllocatedSlots * 100}.
     *
     * @return approximate fullness percentage in the range {@code [0.0, 100.0]}.
     */
    public double calculateFullness() {
        int size = 0;
        int usedSize = 0;
        for (int i = 0; i < buckets.length; ++i) {
            if (buckets[i] == null) continue;
            size += buckets[i].length;
            for (int j = 0; j < buckets[i].length; ++j) {
                if (buckets[i][j] == null) {
                    usedSize += j;
                    break;
                }
            }
        }
        return 100.0 * (double)usedSize / (double)size;
    }

    /**
     * Removes all entries from the map. Bucket arrays are discarded and recreated lazily on subsequent inserts.
     */
    public void clear() {
        size = 0;
        Arrays.fill(buckets, null);
    }
}

package shortestpath;

import java.util.Arrays;

import lombok.EqualsAndHashCode;
import lombok.Getter;

@Getter
@EqualsAndHashCode
public class TransportItems {
    // Each outer int[] holds item id requirements, e.g. AIR_RUNE, FIRE_RUNE, ...
    // Each inner int[] holds item id variations, e.g. AIR_RUNE, DUST_RUNE, ...
    private final int[][] items;
    private final int[][] staves;
    private final int[][] offhands;
    private final int[] quantities;

    public TransportItems(int[][] items, int[][] staves, int[][] offhands, int[] quantities) {
        this.items = items;
        this.staves = staves;
        this.offhands = offhands;
        this.quantities = quantities;
    }

    @Override
    public String toString() {
        return "[" +
            toString(items) + ", " +
            toString(staves) + ", " +
            toString(offhands) + ", " +
            Arrays.toString(quantities) + "]";
    }

    private String toString(int[][] array) {
        String text = "";
        for (int[] inner : array) {
            text += (text.isEmpty() ? "" : ", ") + Arrays.toString(inner);
        }
        return "[" + text + "]";
    }
}

package shortestpath;

import java.util.Arrays;

/**
 * A minimal, growable list implementation for primitive {@code int} values.
 * <p>
 * This class avoids boxing overhead present in {@link java.util.List Integer} collections
 * by storing values in a backing {@code int[]} that grows as needed. It purposefully
 * implements only the operations required by the pathfinding logic in this plugin; it is
 * <strong>not</strong> a drop‑in replacement for {@link java.util.ArrayList}.
 * <p>
 * The growth policy increases capacity by 50% (similar to {@code ArrayList}) when the
 * existing array is exhausted. Capacity never shrinks.
 */
public class PrimitiveIntList {
    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

    private int[] elementData;
    private int size;

    /**
     * Creates a new list with the specified initial capacity.
     *
     * @param initialCapacity the initial length of the backing array (must be {@code >= 0}).
     * @param initialize if {@code true}, the {@link #size} is set equal to {@code initialCapacity},
     *                   effectively pre-filling the logical list with zeroes. If {@code false},
     *                   the list is created empty.
     * @throws IllegalArgumentException if {@code initialCapacity < 0}.
     */
    public PrimitiveIntList(int initialCapacity, boolean initialize) {
        if (initialCapacity < 0) {
            throw new IllegalArgumentException("Illegal capacity: " + initialCapacity);
        }
        this.elementData = new int[initialCapacity];
        if (initialize) {
            size = initialCapacity;
        }
    }

    /**
     * Creates an empty list with the given backing array capacity.
     *
     * @param initialCapacity initial length of the internal array (must be {@code >= 0}).
     */
    public PrimitiveIntList(int initialCapacity) {
        this(initialCapacity, false);
    }

    /**
     * Creates an empty list with a default initial capacity of 10.
     */
    public PrimitiveIntList() {
        this(10);
    }


    /**
     * Ensures that the backing array can store at least {@code minCapacity} elements.
     * If the current capacity is already sufficient the call is a no-op.
     *
     * @param minCapacity the desired minimum capacity (ignored if {@code <= 0}).
     */
    public void ensureCapacity(int minCapacity) {
        if (minCapacity > 0) {
            ensureCapacityInternal(minCapacity);
        }
    }

    private void ensureCapacityInternal(int minCapacity) {
        if (minCapacity - elementData.length > 0) {
            grow(minCapacity);
        }
    }

    private void grow(int minCapacity) {
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        if (newCapacity - minCapacity < 0) {
            newCapacity = minCapacity;
        }
        if (newCapacity - MAX_ARRAY_SIZE > 0) {
            newCapacity = hugeCapacity(minCapacity);
        }
        elementData = Arrays.copyOf(elementData, newCapacity);
    }

    private static int hugeCapacity(int minCapacity) {
        if (minCapacity < 0) { // overflow
            throw new OutOfMemoryError();
        }
        return (minCapacity > MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;
    }

    /**
     * Returns the number of elements that have been added to (or initialized in) this list.
     *
     * @return current element count (always {@code >= 0}).
     */
    public int size() {
        return size;
    }

    /**
     * Indicates whether the list currently holds zero elements.
     *
     * @return {@code true} if {@link #size()} is zero; {@code false} otherwise.
     */
    public boolean isEmpty() {
        return size == 0;
    }

    /**
     * Tests whether the specified primitive value exists in the list.
     *
     * @param e the value to search for.
     * @return {@code true} if the value occurs at least once; {@code false} otherwise.
     */
    public boolean contains(int e) {
        return indexOf(e) >= 0;
    }

    /**
     * Returns the index of the first occurrence of the given value, or {@code -1} if absent.
     *
     * @param e the value to locate.
     * @return zero-based index of the value, or {@code -1} if not found.
     */
    public int indexOf(int e) {
        for (int i = 0; i < size; i++) {
            if (e == elementData[i]) {
                return i;
            }
        }
        return -1;
    }

    /**
     * Retrieves the value at the specified index.
     *
     * @param index zero-based position of the element to return.
     * @return the value stored at {@code index}.
     * @throws IndexOutOfBoundsException if {@code index < 0 || index >= size}.
     */
    public int get(int index) {
        rangeCheck(index);
        return elementData[index];
    }

    /**
     * Replaces the value at the specified index.
     *
     * @param index zero-based position of the element to overwrite.
     * @param element the new value.
     * @return the previous value stored at {@code index}.
     * @throws IndexOutOfBoundsException if {@code index < 0 || index >= size}.
     */
    public int set(int index, int element) {
        rangeCheck(index);
        int oldValue = elementData[index];
        elementData[index] = element;
        return oldValue;
    }


    /**
     * Appends a value to the end of the list, growing the backing array if required.
     *
     * @param e value to append.
     * @return always {@code true}
     */
    public boolean add(int e) {
        ensureCapacityInternal(size + 1);
        elementData[size++] = e;
        return true;
    }

    /**
     * Inserts a value at the specified index, shifting subsequent elements one position to the right.
     *
     * @param index zero-based insertion point (may be equal to {@link #size()} to append).
     * @param element the value to insert.
     * @throws IndexOutOfBoundsException if {@code index < 0 || index > size}.
     */
    public void add(int index, int element) {
        rangeCheckForAdd(index);
        ensureCapacityInternal(size + 1);
        System.arraycopy(elementData, index, elementData, index + 1, size - index);
        elementData[index] = element;
        size++;
    }

    /**
     * Removes the value at the specified index and compacts the list.
     *
     * @param index zero-based index of the element to remove.
     * @return the removed value.
     * @throws IndexOutOfBoundsException if {@code index < 0 || index >= size}.
     */
    public int removeAt(int index) {
        rangeCheck(index);
        int oldValue = elementData[index];
        int numMoved = size - index - 1;
        if (numMoved > 0) {
            System.arraycopy(elementData, index + 1, elementData, index, numMoved);
        }
        elementData[--size] = 0;
        return oldValue;
    }

    /**
     * Removes the first occurrence of the specified value, if present.
     *
     * @param e value to remove.
     * @return {@code true} if a value was removed; {@code false} otherwise.
     */
    public boolean remove(int e) {
        for (int i = 0; i < size; i++) {
            if (e == elementData[i]) {
                fastRemove(i);
                return true;
            }
        }
        return false;
    }

    private void fastRemove(int index) {
        int numMoved = size - index - 1;
        if (numMoved > 0) {
            System.arraycopy(elementData, index+1, elementData, index, numMoved);
        }
        elementData[--size] = 0;
    }

    /**
     * Removes all elements from the list and resets {@link #size()} to zero.
     * The backing array is retained for reuse.
     */
    public void clear() {
        for (int i = 0; i < size; i++) {
            elementData[i] = 0;
        }
        size = 0;
    }

    private void rangeCheck(int index) {
        if (index >= size) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        }
    }

    private void rangeCheckForAdd(int index) {
        if (index > size || index < 0) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        }
    }
}

package shortestpath;

import com.google.common.util.concurrent.ThreadFactoryBuilder;
import com.google.inject.Inject;
import com.google.inject.Provides;
import java.awt.Color;
import java.awt.Polygon;
import java.awt.Rectangle;
import java.awt.Shape;
import java.awt.geom.Ellipse2D;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ThreadFactory;
import java.util.regex.Pattern;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.KeyCode;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.Player;
import net.runelite.api.Point;
import net.runelite.api.ScriptID;
import net.runelite.api.SpriteID;
import net.runelite.api.Varbits;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.MenuOpened;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.worldmap.WorldMap;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.PluginMessage;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.JagexColors;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.worldmap.WorldMapPoint;
import net.runelite.client.ui.overlay.worldmap.WorldMapPointManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;
import shortestpath.pathfinder.CollisionMap;
import shortestpath.pathfinder.Pathfinder;
import shortestpath.pathfinder.PathfinderConfig;

@PluginDescriptor(
    name = "Shortest Path",
    description = "Draws the shortest path to a chosen destination on the map<br>" +
        "Right click on the world map or shift right click a tile to use",
    tags = {"pathfinder", "map", "waypoint", "navigation"}
)
public class ShortestPathPlugin extends Plugin {
    protected static final String CONFIG_GROUP = "shortestpath";
    private static final String PLUGIN_MESSAGE_PATH = "path";
    private static final String PLUGIN_MESSAGE_CLEAR = "clear";
    private static final String PLUGIN_MESSAGE_START = "start";
    private static final String PLUGIN_MESSAGE_TARGET = "target";
    private static final String PLUGIN_MESSAGE_CONFIG_OVERRIDE = "config";
    private static final String PLUGIN_MESSAGE_TRANSPORTS = "transports";
    private static final String CLEAR = "Clear";
    private static final String PATH = ColorUtil.wrapWithColorTag("Path", JagexColors.MENU_TARGET);
    private static final String SET = "Set";
    private static final String FIND_CLOSEST = "Find closest";
    private static final String FLASH_ICONS = "Flash icons";
    private static final String START = ColorUtil.wrapWithColorTag("Start", JagexColors.MENU_TARGET);
    private static final String TARGET = ColorUtil.wrapWithColorTag("Target", JagexColors.MENU_TARGET);
    private static final BufferedImage MARKER_IMAGE = ImageUtil.loadImageResource(ShortestPathPlugin.class, "/marker.png");
    private static final Pattern TRANSPORT_OPTIONS_REGEX = Pattern.compile("^(avoidWilderness|currencyThreshold|use\\w+)$");

    @Inject
    private Client client;

    @Getter
    @Inject
    private ClientThread clientThread;

    @Inject
    private ShortestPathConfig config;

    @Inject
    private EventBus eventBus;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private PathTileOverlay pathOverlay;

    @Inject
    private PathMinimapOverlay pathMinimapOverlay;

    @Inject
    private PathMapOverlay pathMapOverlay;

    @Inject
    private PathMapTooltipOverlay pathMapTooltipOverlay;

    @Inject
    private DebugOverlayPanel debugOverlayPanel;

    @Inject
    private SpriteManager spriteManager;

    @Inject
    private WorldMapPointManager worldMapPointManager;

    boolean drawCollisionMap;
    boolean drawMap;
    boolean drawMinimap;
    boolean drawTiles;
    boolean drawTransports;
    boolean showTransportInfo;
    Color colourCollisionMap;
    Color colourPath;
    Color colourPathCalculating;
    Color colourText;
    Color colourTransports;
    int tileCounterStep;
    TileCounter showTileCounter;
    TileStyle pathStyle;

    private Point lastMenuOpenedPoint;
    private WorldMapPoint marker;
    private int lastLocation = WorldPointUtil.packWorldPoint(0, 0, 0);
    private Shape minimapClipFixed;
    private Shape minimapClipResizeable;
    private BufferedImage minimapSpriteFixed;
    private BufferedImage minimapSpriteResizeable;
    private Rectangle minimapRectangle = new Rectangle();

    private GameState lastGameState = null;
    private GameState lastLastGameState = null;
    private List<PendingTask> pendingTasks = new ArrayList<>(3);

    private ExecutorService pathfindingExecutor = Executors.newSingleThreadExecutor();
    private Future<?> pathfinderFuture;
    private final Object pathfinderMutex = new Object();
    private static final Map<String, Object> configOverride = new HashMap<>(50);
    @Getter
    private Pathfinder pathfinder;
    @Getter
    private PathfinderConfig pathfinderConfig;
    @Getter
    private boolean startPointSet = false;

    @Provides
    public ShortestPathConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(ShortestPathConfig.class);
    }

    @Override
    protected void startUp() {
        cacheConfigValues();

        pathfinderConfig = new PathfinderConfig(client, config);
        if (GameState.LOGGED_IN.equals(client.getGameState())) {
            clientThread.invokeLater(pathfinderConfig::refresh);
        }

        overlayManager.add(pathOverlay);
        overlayManager.add(pathMinimapOverlay);
        overlayManager.add(pathMapOverlay);
        overlayManager.add(pathMapTooltipOverlay);

        if (config.drawDebugPanel()) {
            overlayManager.add(debugOverlayPanel);
        }
    }

    @Override
    protected void shutDown() {
        overlayManager.remove(pathOverlay);
        overlayManager.remove(pathMinimapOverlay);
        overlayManager.remove(pathMapOverlay);
        overlayManager.remove(pathMapTooltipOverlay);
        overlayManager.remove(debugOverlayPanel);

        if (pathfindingExecutor != null) {
            pathfindingExecutor.shutdownNow();
            pathfindingExecutor = null;
        }
    }

    public void restartPathfinding(int start, Set<Integer> ends, boolean canReviveFiltered) {
        synchronized (pathfinderMutex) {
            if (pathfinder != null) {
                pathfinder.cancel();
                pathfinderFuture.cancel(true);
            }

            if (pathfindingExecutor == null) {
                ThreadFactory shortestPathNaming = new ThreadFactoryBuilder().setNameFormat("shortest-path-%d").build();
                pathfindingExecutor = Executors.newSingleThreadExecutor(shortestPathNaming);
            }
        }

        getClientThread().invokeLater(() -> {
            pathfinderConfig.refresh();
            pathfinderConfig.filterLocations(ends, canReviveFiltered);
            synchronized (pathfinderMutex) {
                if (ends.isEmpty()) {
                    setTarget(WorldPointUtil.UNDEFINED);
                } else {
                    pathfinder = new Pathfinder(this, pathfinderConfig, start, ends);
                    pathfinderFuture = pathfindingExecutor.submit(pathfinder);
                }
            }
        });
    }

    public void restartPathfinding(int start, Set<Integer> ends) {
        restartPathfinding(start, ends, true);
    }

    public boolean isNearPath(int location) {
        PrimitiveIntList path = null;
        if (pathfinder == null || (path = pathfinder.getPath()) == null || path.isEmpty() ||
            config.recalculateDistance() < 0 || lastLocation == (lastLocation = location)) {
            return true;
        }

        for (int i = 0; i < path.size(); i++) {
            if (WorldPointUtil.distanceBetween(location, path.get(i)) < config.recalculateDistance()) {
                return true;
            }
        }

        return false;
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        if (!CONFIG_GROUP.equals(event.getGroup())) {
            return;
        }

        cacheConfigValues();

        if ("drawDebugPanel".equals(event.getKey())) {
            if (config.drawDebugPanel()) {
                overlayManager.add(debugOverlayPanel);
            } else {
                overlayManager.remove(debugOverlayPanel);
            }
            return;
        }

        // Transport option changed; rerun pathfinding
        if (TRANSPORT_OPTIONS_REGEX.matcher(event.getKey()).find()) {
            if (pathfinder != null) {
                restartPathfinding(pathfinder.getStart(), pathfinder.getTargets());
            }
        }
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event) {
        if (pathfinderConfig == null
            || !GameState.LOGGING_IN.equals(lastLastGameState)
            || !GameState.LOADING.equals(lastLastGameState = lastGameState)
            || !GameState.LOGGED_IN.equals(lastGameState = event.getGameState())) {
            lastLastGameState = lastGameState;
            lastGameState = event.getGameState();
            return;
        }

        pendingTasks.add(new PendingTask(client.getTickCount() + 1, pathfinderConfig::refresh));
    }

    @Subscribe
    public void onPluginMessage(PluginMessage event) {
        if (!CONFIG_GROUP.equals(event.getNamespace())) {
            return;
        }

        String action = event.getName();
        if (PLUGIN_MESSAGE_PATH.equals(action)) {
            Map<String, Object> data = event.getData();
            Object objStart = data.getOrDefault(PLUGIN_MESSAGE_START, null);
            Object objTarget = data.getOrDefault(PLUGIN_MESSAGE_TARGET, null);
            Object objConfigOverride = data.getOrDefault(PLUGIN_MESSAGE_CONFIG_OVERRIDE, null);

            @SuppressWarnings("unchecked")
            Map<String, Object> configOverride = (objConfigOverride instanceof Map<?,?>) ? ((Map<String, Object>) objConfigOverride) : null;
            if (configOverride != null && !configOverride.isEmpty()) {
                this.configOverride.clear();
                for (String key : configOverride.keySet()) {
                    this.configOverride.put(key, configOverride.get(key));
                }
                cacheConfigValues();
            }

            if (objStart == null && objTarget == null) {
                return;
            }

            int start = (objStart instanceof WorldPoint) ? WorldPointUtil.packWorldPoint((WorldPoint) objStart)
                : ((objStart instanceof Integer) ? ((int) objStart) : WorldPointUtil.UNDEFINED);
            if (start == WorldPointUtil.UNDEFINED) {
                if (client.getLocalPlayer() == null) {
                    return;
                }
                start = WorldPointUtil.packWorldPoint(client.getLocalPlayer().getWorldLocation());
            }

            Set<Integer> targets = new HashSet<>();
            if (objTarget instanceof Integer) {
                int packedPoint = (Integer) objTarget;
                if (packedPoint == WorldPointUtil.UNDEFINED) {
                    return;
                }
                targets.add(packedPoint);
            } else if (objTarget instanceof WorldPoint) {
                int packedPoint = WorldPointUtil.packWorldPoint((WorldPoint) objTarget);
                if (packedPoint == WorldPointUtil.UNDEFINED) {
                    return;
                }
                targets.add(packedPoint);
            } else if (objTarget instanceof Set<?>) {
                @SuppressWarnings("unchecked")
                Set<Object> objTargets = (Set<Object>) objTarget;
                for (Object obj : objTargets) {
                    int packedPoint = WorldPointUtil.UNDEFINED;
                    if (obj instanceof Integer) {
                        packedPoint = (Integer) obj;
                    } else if (obj instanceof WorldPoint) {
                        packedPoint = WorldPointUtil.packWorldPoint((WorldPoint) obj);
                    }
                    if (packedPoint == WorldPointUtil.UNDEFINED) {
                        return;
                    }
                    targets.add(packedPoint);
                }
            }

            boolean useOld = targets.isEmpty() && pathfinder != null;
            restartPathfinding(start, useOld ? pathfinder.getTargets() : targets, useOld);
        } else if (PLUGIN_MESSAGE_CLEAR.equals(action)) {
            this.configOverride.clear();
            cacheConfigValues();
            setTarget(WorldPointUtil.UNDEFINED);
        }
    }

    public void postPluginMessages() {
        if (pathfinder == null) {
            return;
        }
        if (override("postTransports", config.postTransports())) {
            Map<String, Object> data = new HashMap<>();
            List<WorldPoint> transportOrigins = new ArrayList<>();
            List<WorldPoint> transportDestinations = new ArrayList<>();
            List<String> transportObjectInfos = new ArrayList<>();
            List<String> transportDisplayInfos = new ArrayList<>();
            PrimitiveIntList currentPath = pathfinder.getPath();
            for (int i = 1; i < currentPath.size(); i++) {
                int origin = currentPath.get(i-1);
                int destination = currentPath.get(i);
                for (Transport transport : pathfinderConfig.getTransports().getOrDefault(origin, new HashSet<>())) {
                    if (transport.getDestination() == destination) {
                        transportOrigins.add(WorldPointUtil.unpackWorldPoint(origin));
                        transportDestinations.add(WorldPointUtil.unpackWorldPoint(destination));
                        transportObjectInfos.add(transport.getObjectInfo());
                        transportDisplayInfos.add(transport.getDisplayInfo());
                    }
                }
            }
            data.put("origin", transportOrigins);
            data.put("destination", transportDestinations);
            data.put("objectInfo", transportObjectInfos);
            data.put("displayInfo", transportDisplayInfos);
            eventBus.post(new PluginMessage(CONFIG_GROUP, PLUGIN_MESSAGE_TRANSPORTS, data));
        }
    }

    @Subscribe
    public void onMenuOpened(MenuOpened event) {
        lastMenuOpenedPoint = client.getMouseCanvasPosition();
    }

    @Subscribe
    public void onGameTick(GameTick tick) {
        for (int i = 0; i < pendingTasks.size(); i++) {
            if (pendingTasks.get(i).check(client.getTickCount())) {
                pendingTasks.remove(i--).run();
            }
        }

        Player localPlayer = client.getLocalPlayer();
        if (localPlayer == null || pathfinder == null) {
            return;
        }

        int currentLocation = WorldPointUtil.fromLocalInstance(client, localPlayer.getLocalLocation());
        for (int target : pathfinder.getTargets()) {
            if (WorldPointUtil.distanceBetween(currentLocation, target) < config.reachedDistance()) {
                setTarget(WorldPointUtil.UNDEFINED);
                return;
            }
        }

        if (!startPointSet && !isNearPath(currentLocation)) {
            if (config.cancelInstead()) {
                setTarget(WorldPointUtil.UNDEFINED);
                return;
            }
            restartPathfinding(currentLocation, pathfinder.getTargets());
        }
    }

    @Subscribe
    public void onMenuEntryAdded(MenuEntryAdded event) {
        if (client.isKeyPressed(KeyCode.KC_SHIFT)
            && event.getType() == MenuAction.WALK.getId()) {
            addMenuEntry(event, SET, TARGET, 1);
            if (pathfinder != null) {
                if (pathfinder.getTargets().size() >= 1) {
                    addMenuEntry(event, SET, TARGET + ColorUtil.wrapWithColorTag(" " +
                        (pathfinder.getTargets().size() + 1), JagexColors.MENU_TARGET), 1);
                }
                for (int target : pathfinder.getTargets()) {
                    if (target != WorldPointUtil.UNDEFINED) {
                        addMenuEntry(event, SET, START, 1);
                        break;
                    }
                }
                int selectedTile = getSelectedWorldPoint();
                PrimitiveIntList path = null;
                if ((path = pathfinder.getPath()) != null) {
                    for (int i = 0; i < path.size(); i++) {
                        if (path.get(i) == selectedTile) {
                            addMenuEntry(event, CLEAR, PATH, 1);
                            break;
                        }
                    }
                }
            }
        }

        final Widget map = client.getWidget(ComponentID.WORLD_MAP_MAPVIEW);

        if (map != null) {
            if (map.getBounds().contains(
                client.getMouseCanvasPosition().getX(),
                client.getMouseCanvasPosition().getY())) {
                addMenuEntry(event, SET, TARGET, 0);
                if (pathfinder != null) {
                    if (pathfinder.getTargets().size() >= 1) {
                        addMenuEntry(event, SET, TARGET + ColorUtil.wrapWithColorTag(" " +
                            (pathfinder.getTargets().size() + 1), JagexColors.MENU_TARGET), 0);
                    }
                    for (int target : pathfinder.getTargets()) {
                        if (target != WorldPointUtil.UNDEFINED) {
                            addMenuEntry(event, SET, START, 0);
                            addMenuEntry(event, CLEAR, PATH, 0);
                        }
                    }
                }
            }
            if (event.getOption().equals(FLASH_ICONS) && pathfinderConfig.hasDestination(simplify(event.getTarget()))) {
                addMenuEntry(event, FIND_CLOSEST, event.getTarget(), 1);
            }
        }

        final Shape minimap = getMinimapClipArea();

        if (minimap != null && pathfinder != null
            && minimap.contains(
                client.getMouseCanvasPosition().getX(),
                client.getMouseCanvasPosition().getY())) {
            addMenuEntry(event, CLEAR, PATH, 0);
        }

        if (minimap != null && pathfinder != null
            && ("Floating World Map".equals(Text.removeTags(event.getOption()))
            || "Close Floating panel".equals(Text.removeTags(event.getOption())))) {
            addMenuEntry(event, CLEAR, PATH, 1);
        }
    }

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event) {
        if (event.getContainerId() != InventoryID.BANK) {
            return;
        }
        pathfinderConfig.bank = event.getItemContainer();
    }

    @Subscribe
    public void onWidgetLoaded(WidgetLoaded event) {
        if (pathfinder != null && event.getGroupId() == InterfaceID.FAIRYRINGS_LOG) {
            scrollFairyRingPanel();
        }
    }

    private void scrollFairyRingPanel() {
        PrimitiveIntList path = null;
        Map<Integer, Set<Transport>> transports = null;

        if (pathfinder == null
            || (path = pathfinder.getPath()) == null
            || (transports = getTransports()) == null) {
            return;
        }

        String fairyRingCode = null;

        for (int i = 1; i < path.size(); i++) {
            int destination = path.get(i);
            int origin = path.get(i - 1);
            Set<Transport> candidateTransports = transports.get(origin);
            if (candidateTransports != null) {
                for (Transport transport : candidateTransports) {
                    if (transport.getDestination() == destination
                        && TransportType.FAIRY_RING.equals(transport.getType())) {
                        fairyRingCode = transport.getDisplayInfo();
                    }
                }
            }
        }
        if (fairyRingCode == null) {
            return;
        }

        Widget codeWidget = null;

        Widget favesPanel = client.getWidget(InterfaceID.FairyringsLog.FAVES);
        if (favesPanel != null) {
            for (Widget widget : favesPanel.getStaticChildren()) {
                if (widget != null && fairyRingCode.equals(widget.getText())) {
                    codeWidget = widget;
                    break;
                }
            }
        }

        Widget contentsList = client.getWidget(InterfaceID.FairyringsLog.CONTENTS);
        if (contentsList != null && codeWidget == null) {
            for (Widget widget : contentsList.getDynamicChildren()) {
                if (widget != null && fairyRingCode.equals(widget.getText())) {
                    codeWidget = widget;
                    break;
                }
            }
        }

        if (codeWidget == null) {
            return;
        }

        int panelScrollY = Math.min(
            codeWidget.getRelativeY(),
            contentsList.getScrollHeight() - contentsList.getHeight()
        );

        contentsList.setScrollY(panelScrollY);
        contentsList.revalidateScroll();

        codeWidget.setTextColor(0x00FF00);
        codeWidget.setText("(Shortest Path) " + codeWidget.getText());

        client.runScript(
            ScriptID.UPDATE_SCROLLBAR,
            InterfaceID.FairyringsLog.SCROLLBAR,
            InterfaceID.FairyringsLog.CONTENTS,
            panelScrollY
        );
    }

    public Map<Integer, Set<Transport>> getTransports() {
        return pathfinderConfig.getTransports();
    }

    public CollisionMap getMap() {
        return pathfinderConfig.getMap();
    }

    public static boolean override(String configOverrideKey, boolean defaultValue) {
        if (!configOverride.isEmpty()) {
            Object value = configOverride.get(configOverrideKey);
            if (value instanceof Boolean) {
                return (boolean) value;
            }
        }
        return defaultValue;
    }

    private Color override(String configOverrideKey, Color defaultValue) {
        if (!configOverride.isEmpty()) {
            Object value = configOverride.get(configOverrideKey);
            if (value instanceof Color) {
                return (Color) value;
            }
        }
        return defaultValue;
    }

    public static int override(String configOverrideKey, int defaultValue) {
        if (!configOverride.isEmpty()) {
            Object value = configOverride.get(configOverrideKey);
            if (value instanceof Integer) {
                return (int) value;
            }
        }
        return defaultValue;
    }

    public static TeleportationItem override(String configOverrideKey, TeleportationItem defaultValue) {
        if (!configOverride.isEmpty()) {
            Object value = configOverride.get(configOverrideKey);
            if (value instanceof String) {
                TeleportationItem teleportationItem = TeleportationItem.fromType((String) value);
                if (teleportationItem != null) {
                    return teleportationItem;
                }
            }
        }
        return defaultValue;
    }

    private TileCounter override(String configOverrideKey, TileCounter defaultValue) {
        if (!configOverride.isEmpty()) {
            Object value = configOverride.get(configOverrideKey);
            if (value instanceof String) {
                TileCounter tileCounter = TileCounter.fromType((String) value);
                if (tileCounter != null) {
                    return tileCounter;
                }
            }
        }
        return defaultValue;
    }

    private TileStyle override(String configOverrideKey, TileStyle defaultValue) {
        if (!configOverride.isEmpty()) {
            Object value = configOverride.get(configOverrideKey);
            if (value instanceof String) {
                TileStyle tileStyle = TileStyle.fromType((String) value);
                if (tileStyle != null) {
                    return tileStyle;
                }
            }
        }
        return defaultValue;
    }

    private void cacheConfigValues() {
        drawCollisionMap = override("drawCollisionMap", config.drawCollisionMap());
        drawMap = override("drawMap", config.drawMap());
        drawMinimap = override("drawMinimap", config.drawMinimap());
        drawTiles = override("drawTiles", config.drawTiles());
        drawTransports = override("drawTransports", config.drawTransports());
        showTransportInfo = override("showTransportInfo", config.showTransportInfo());

        colourCollisionMap = override("colourCollisionMap", config.colourCollisionMap());
        colourPath = override("colourPath", config.colourPath());
        colourPathCalculating = override("colourPathCalculating", config.colourPathCalculating());
        colourText = override("colourText", config.colourText());
        colourTransports = override("colourTransports", config.colourTransports());

        tileCounterStep = override("tileCounterStep", config.tileCounterStep());

        showTileCounter = override("showTileCounter", config.showTileCounter());
        pathStyle = override("pathStyle", config.pathStyle());
    }

    private String simplify(String text) {
        return Text.removeTags(text).toLowerCase()
            .replaceAll("[^a-zA-Z ]", "")
            .replaceAll("[ ]", "_")
            .replace("__", "_");
    }

    private void onMenuOptionClicked(MenuEntry entry) {
        if (entry.getOption().equals(SET) && entry.getTarget().equals(TARGET)) {
            setTarget(getSelectedWorldPoint());
        } else if (entry.getOption().equals(SET) && pathfinder != null && entry.getTarget().equals(TARGET +
            ColorUtil.wrapWithColorTag(" " + (pathfinder.getTargets().size() + 1), JagexColors.MENU_TARGET))) {
            setTarget(getSelectedWorldPoint(), true);
        } else if (entry.getOption().equals(SET) && entry.getTarget().equals(START)) {
            setStart(getSelectedWorldPoint());
        } else if (entry.getOption().equals(CLEAR) && entry.getTarget().equals(PATH)) {
            setTarget(WorldPointUtil.UNDEFINED);
        } else if (entry.getOption().equals(FIND_CLOSEST)) {
            setTargets(pathfinderConfig.getDestinations(simplify(entry.getTarget())), true);
        }
    }

    private int getSelectedWorldPoint() {
        if (client.getWidget(ComponentID.WORLD_MAP_MAPVIEW) == null) {
            if (client.getSelectedSceneTile() != null) {
                return WorldPointUtil.fromLocalInstance(client, client.getSelectedSceneTile().getLocalLocation());
            }
        } else {
            return client.isMenuOpen()
                ? calculateMapPoint(lastMenuOpenedPoint.getX(), lastMenuOpenedPoint.getY())
                : calculateMapPoint(client.getMouseCanvasPosition().getX(), client.getMouseCanvasPosition().getY());
        }
        return WorldPointUtil.UNDEFINED;
    }

    private void setTarget(int target) {
        setTarget(target, false);
    }

    private void setTarget(int target, boolean append) {
        Set<Integer> targets = new HashSet<>();
        if (target != WorldPointUtil.UNDEFINED) {
            targets.add(target);
        }
        setTargets(targets, append);
    }

    private void setTargets(Set<Integer> targets, boolean append) {
        if (targets == null || targets.isEmpty()) {
            synchronized (pathfinderMutex) {
                if (pathfinder != null) {
                    pathfinder.cancel();
                }
                pathfinder = null;
            }

            worldMapPointManager.removeIf(x -> x == marker);
            marker = null;
            startPointSet = false;
        } else {
            Player localPlayer = client.getLocalPlayer();
            if (!startPointSet && localPlayer == null) {
                return;
            }
            worldMapPointManager.removeIf(x -> x == marker);
            if (targets.size() == 1) {
                marker = new WorldMapPoint(WorldPointUtil.unpackWorldPoint(targets.iterator().next()), MARKER_IMAGE);
                marker.setName("Target");
                marker.setTarget(marker.getWorldPoint());
                marker.setJumpOnClick(true);
                worldMapPointManager.add(marker);
            }

            int start = WorldPointUtil.fromLocalInstance(client, localPlayer.getLocalLocation());
            lastLocation = start;
            if (startPointSet && pathfinder != null) {
                start = pathfinder.getStart();
            }
            Set<Integer> destinations = new HashSet<>(targets);
            if (pathfinder != null && append) {
                destinations.addAll(pathfinder.getTargets());
            }
            restartPathfinding(start, destinations, append);
        }
    }

    private void setStart(int start) {
        if (pathfinder == null) {
            return;
        }
        startPointSet = true;
        restartPathfinding(start, pathfinder.getTargets());
    }

    public int calculateMapPoint(int pointX, int pointY) {
        WorldMap worldMap = client.getWorldMap();
        float zoom = worldMap.getWorldMapZoom();
        int mapPoint = WorldPointUtil.packWorldPoint(worldMap.getWorldMapPosition().getX(), worldMap.getWorldMapPosition().getY(), 0);
        int middleX = mapWorldPointToGraphicsPointX(mapPoint);
        int middleY = mapWorldPointToGraphicsPointY(mapPoint);

        if (pointX == Integer.MIN_VALUE || pointY == Integer.MIN_VALUE ||
            middleX == Integer.MIN_VALUE || middleY == Integer.MIN_VALUE) {
            return WorldPointUtil.UNDEFINED;
        }

        final int dx = (int) ((pointX - middleX) / zoom);
        final int dy = (int) ((-(pointY - middleY)) / zoom);

        return WorldPointUtil.dxdy(mapPoint, dx, dy);
    }

    public int mapWorldPointToGraphicsPointX(int packedWorldPoint) {
        WorldMap worldMap = client.getWorldMap();

        float pixelsPerTile = worldMap.getWorldMapZoom();

        Widget map = client.getWidget(ComponentID.WORLD_MAP_MAPVIEW);
        if (map != null) {
            Rectangle worldMapRect = map.getBounds();

            int widthInTiles = (int) Math.ceil(worldMapRect.getWidth() / pixelsPerTile);

            Point worldMapPosition = worldMap.getWorldMapPosition();

            int xTileOffset = WorldPointUtil.unpackWorldX(packedWorldPoint) + widthInTiles / 2 - worldMapPosition.getX();

            int xGraphDiff = ((int) (xTileOffset * pixelsPerTile));
            xGraphDiff += pixelsPerTile - Math.ceil(pixelsPerTile / 2);
            xGraphDiff += (int) worldMapRect.getX();

            return xGraphDiff;
        }
        return Integer.MIN_VALUE;
    }

    public int mapWorldPointToGraphicsPointY(int packedWorldPoint) {
        WorldMap worldMap = client.getWorldMap();

        float pixelsPerTile = worldMap.getWorldMapZoom();

        Widget map = client.getWidget(ComponentID.WORLD_MAP_MAPVIEW);
        if (map != null) {
            Rectangle worldMapRect = map.getBounds();

            int heightInTiles = (int) Math.ceil(worldMapRect.getHeight() / pixelsPerTile);

            Point worldMapPosition = worldMap.getWorldMapPosition();

            int yTileMax = worldMapPosition.getY() - heightInTiles / 2;
            int yTileOffset = (yTileMax - WorldPointUtil.unpackWorldY(packedWorldPoint) - 1) * -1;

            int yGraphDiff = (int) (yTileOffset * pixelsPerTile);
            yGraphDiff -= pixelsPerTile - Math.ceil(pixelsPerTile / 2);
            yGraphDiff = worldMapRect.height - yGraphDiff;
            yGraphDiff += (int) worldMapRect.getY();

            return yGraphDiff;
        }
        return Integer.MIN_VALUE;
    }

    private void addMenuEntry(MenuEntryAdded event, String option, String target, int position) {
        List<MenuEntry> entries = new LinkedList<>(Arrays.asList(client.getMenuEntries()));

        if (entries.stream().anyMatch(e -> e.getOption().equals(option) && e.getTarget().equals(target))) {
            return;
        }

        client.createMenuEntry(position)
            .setOption(option)
            .setTarget(target)
            .setParam0(event.getActionParam0())
            .setParam1(event.getActionParam1())
            .setIdentifier(event.getIdentifier())
            .setType(MenuAction.RUNELITE)
            .onClick(this::onMenuOptionClicked);
    }

    private Widget getMinimapDrawWidget() {
        if (client.isResized()) {
            if (client.getVarbitValue(Varbits.SIDE_PANELS) == 1) {
                return client.getWidget(ComponentID.RESIZABLE_VIEWPORT_BOTTOM_LINE_MINIMAP_DRAW_AREA);
            }
            return client.getWidget(ComponentID.RESIZABLE_VIEWPORT_MINIMAP_DRAW_AREA);
        }
        return client.getWidget(ComponentID.FIXED_VIEWPORT_MINIMAP_DRAW_AREA);
    }

    private Shape getMinimapClipAreaSimple() {
        Widget minimapDrawArea = getMinimapDrawWidget();

        if (minimapDrawArea == null || minimapDrawArea.isHidden()) {
            return null;
        }

        Rectangle bounds = minimapDrawArea.getBounds();

        return new Ellipse2D.Double(bounds.getX(), bounds.getY(), bounds.getWidth(), bounds.getHeight());
    }

    public Shape getMinimapClipArea() {
        Widget minimapWidget = getMinimapDrawWidget();

        if (minimapWidget == null || minimapWidget.isHidden() || !minimapRectangle.equals(minimapRectangle = minimapWidget.getBounds())) {
            minimapClipFixed = null;
            minimapClipResizeable = null;
            minimapSpriteFixed = null;
            minimapSpriteResizeable = null;
        }

        if (minimapWidget == null || minimapWidget.isHidden()) {
            return null;
        }

        if (client.isResized()) {
            if (minimapClipResizeable != null) {
                return minimapClipResizeable;
            }
            if (minimapSpriteResizeable == null) {
                minimapSpriteResizeable = spriteManager.getSprite(SpriteID.RESIZEABLE_MODE_MINIMAP_ALPHA_MASK, 0);
            }
            if (minimapSpriteResizeable != null) {
                minimapClipResizeable = bufferedImageToPolygon(minimapSpriteResizeable);
                return minimapClipResizeable;
            }
            return getMinimapClipAreaSimple();
        }
        if (minimapClipFixed != null) {
            return minimapClipFixed;
        }
        if (minimapSpriteFixed == null) {
            minimapSpriteFixed = spriteManager.getSprite(SpriteID.FIXED_MODE_MINIMAP_ALPHA_MASK, 0);
        }
        if (minimapSpriteFixed != null) {
            minimapClipFixed = bufferedImageToPolygon(minimapSpriteFixed);
            return minimapClipFixed;
        }
        return getMinimapClipAreaSimple();
    }

    private Polygon bufferedImageToPolygon(BufferedImage image) {
        Color outsideColour = null;
        Color previousColour;
        final int width = image.getWidth();
        final int height = image.getHeight();
        List<java.awt.Point> points = new ArrayList<>();
        for (int y = 0; y < height; y++) {
            previousColour = outsideColour;
            for (int x = 0; x < width; x++) {
                int rgb = image.getRGB(x, y);
                int a = (rgb & 0xff000000) >>> 24;
                int r = (rgb & 0x00ff0000) >> 16;
                int g = (rgb & 0x0000ff00) >> 8;
                int b = (rgb & 0x000000ff) >> 0;
                Color colour = new Color(r, g, b, a);
                if (x == 0 && y == 0) {
                    outsideColour = colour;
                    previousColour = colour;
                }
                if (!colour.equals(outsideColour) && previousColour.equals(outsideColour)) {
                    points.add(new java.awt.Point(x, y));
                }
                if ((colour.equals(outsideColour) || x == (width - 1)) && !previousColour.equals(outsideColour)) {
                    points.add(0, new java.awt.Point(x, y));
                }
                previousColour = colour;
            }
        }
        int offsetX = minimapRectangle.x;
        int offsetY = minimapRectangle.y;
        Polygon polygon = new Polygon();
        for (java.awt.Point point : points) {
            polygon.addPoint(point.x + offsetX, point.y + offsetY);
        }
        return polygon;
    }
}

package shortestpath;

import lombok.Getter;
import lombok.Setter;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.ComponentConstants;
import net.runelite.client.ui.overlay.components.LayoutableRenderableEntity;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import shortestpath.pathfinder.Pathfinder;

import javax.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.util.List;

public class DebugOverlayPanel extends OverlayPanel {
    private final ShortestPathPlugin plugin;
    private final SeparatorLine separator;

    @Inject
    public DebugOverlayPanel(ShortestPathPlugin plugin) {
        super(plugin);
        this.plugin = plugin;

        separator = new SeparatorLine();
        separator.setColor(new Color(0, true)); // Invisible color

        setPosition(OverlayPosition.TOP_LEFT);
    }

    private LineComponent makeLine(String left, String right) {
        return LineComponent.builder()
                .left(left)
                .right(right)
                .build();
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        Pathfinder pathfinder = plugin.getPathfinder();
        Pathfinder.PathfinderStats stats;
        if (pathfinder == null || (stats = pathfinder.getStats()) == null) {
            return null;
        }

        List<LayoutableRenderableEntity> components = panelComponent.getChildren();

        components.add(
                TitleComponent.builder()
                        .text("Shortest Path Debug")
                        .color(Color.ORANGE)
                        .build()
        );

        components.add(separator);

        String pathLength = Integer.toString(pathfinder.getPath().size());
        components.add(makeLine("Path Length:", pathLength));

        components.add(separator);

        String nodes = Integer.toString(stats.getNodesChecked());
        components.add(makeLine("Nodes:", nodes));

        String transports = Integer.toString(stats.getTransportsChecked());
        components.add(makeLine("Transports:", transports));

        String totalNodes = Integer.toString(stats.getTotalNodesChecked());
        components.add(makeLine("Total:", totalNodes));

        components.add(separator);

        double milliTime = stats.getElapsedTimeNanos() / 1000000.0;
        String time = String.format("%.2fms", milliTime);
        components.add(makeLine("Time:", time));

        return super.render(graphics);
    }

    @Setter
    private static class SeparatorLine implements LayoutableRenderableEntity {
        private Color color = Color.GRAY;
        private Point preferredLocation = new Point();
        private Dimension preferredSize = new Dimension(ComponentConstants.STANDARD_WIDTH, 4);

        @Getter
        private final Rectangle bounds = new Rectangle();

        @Override
        public Dimension render(Graphics2D graphics) {
            final int separatorX = preferredLocation.x;
            final int separatorY = preferredLocation.y + 4;
            final int width = preferredSize.width;
            final int height = Math.max(preferredSize.height, 2);

            // Draw bar
            if (color != null && color.getAlpha() != 0) {
                graphics.setColor(color);
                graphics.fillRect(separatorX, separatorY, width, height);
            }

            final Dimension dimension = new Dimension(width, height + 4);
            bounds.setLocation(preferredLocation);
            bounds.setSize(dimension);

            return dimension;
        }
    }
}

package shortestpath;

import com.google.inject.Inject;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.geom.Area;
import java.util.HashSet;
import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import shortestpath.pathfinder.CollisionMap;

public class PathMapOverlay extends Overlay {
    private final Client client;
    private final ShortestPathPlugin plugin;

    @Inject
    private PathMapOverlay(Client client, ShortestPathPlugin plugin) {
        this.client = client;
        this.plugin = plugin;
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(Overlay.PRIORITY_LOW);
        setLayer(OverlayLayer.MANUAL);
        drawAfterLayer(ComponentID.WORLD_MAP_MAPVIEW);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!plugin.drawMap) {
            return null;
        }

        if (client.getWidget(ComponentID.WORLD_MAP_MAPVIEW) == null) {
            return null;
        }

        Rectangle worldMapRectangle = client.getWidget(ComponentID.WORLD_MAP_MAPVIEW).getBounds();
        Area worldMapClipArea = getWorldMapClipArea(worldMapRectangle);
        graphics.setClip(worldMapClipArea);

        if (plugin.drawCollisionMap) {
            graphics.setColor(plugin.colourCollisionMap);
            int mapWorldPoint = plugin.calculateMapPoint(worldMapRectangle.x, worldMapRectangle.y);
            int extentX = WorldPointUtil.unpackWorldX(mapWorldPoint);
            int extentY = WorldPointUtil.unpackWorldY(mapWorldPoint);
            int extentWidth = getWorldMapExtentWidth(worldMapRectangle);
            int extentHeight = getWorldMapExtentHeight(worldMapRectangle);
            final CollisionMap map = plugin.getMap();
            final int z = client.getPlane();
            for (int x = extentX; x < (extentX + extentWidth + 1); x++) {
                for (int y = extentY - extentHeight; y < (extentY + 1); y++) {
                    if (map.isBlocked(x, y, z)) {
                        drawOnMap(graphics, WorldPointUtil.packWorldPoint(x, y, z), false, null);
                    }
                }
            }
        }

        if (plugin.drawTransports) {
            graphics.setColor(Color.WHITE);
            for (int a : plugin.getTransports().keySet()) {
                if (a == Transport.UNDEFINED_ORIGIN) {
                    continue; // skip teleports
                }

                int mapAX = plugin.mapWorldPointToGraphicsPointX(a);
                int mapAY = plugin.mapWorldPointToGraphicsPointY(a);
                if (!worldMapClipArea.contains(mapAX, mapAY)) {
                    continue;
                }

                for (Transport b : plugin.getTransports().getOrDefault(a, new HashSet<>())) {
                    if (b == null || TransportType.isTeleport(b.getType())) {
                        continue; // skip teleports
                    }

                    int mapBX = plugin.mapWorldPointToGraphicsPointX(b.getDestination());
                    int mapBY = plugin.mapWorldPointToGraphicsPointY(b.getDestination());
                    if (!worldMapClipArea.contains(mapBX, mapBY)) {
                        continue;
                    }

                    graphics.drawLine(mapAX, mapAY, mapBX, mapBY);
                }
            }
        }

        if (plugin.getPathfinder() != null) {
            Color colour = plugin.getPathfinder().isDone() ? plugin.colourPath : plugin.colourPathCalculating;
            PrimitiveIntList path = plugin.getPathfinder().getPath();
            Point cursorPos = client.getMouseCanvasPosition();
            for (int i = 0; i < path.size(); i++) {
                graphics.setColor(colour);
                int point = path.get(i);
                int lastPoint = (i > 0) ? path.get(i - 1) : point;
                if (WorldPointUtil.distanceBetween(point, lastPoint) > 1) {
                    drawOnMap(graphics, lastPoint, point, true, cursorPos);
                }
                drawOnMap(graphics, point, true, cursorPos);
            }
            for (int target : plugin.getPathfinder().getTargets()) {
                if (path.size() > 0 && target != path.get(path.size() - 1)) {
                    graphics.setColor(plugin.colourPathCalculating);
                    drawOnMap(graphics, target, true, cursorPos);
                }
            }
        }

        return null;
    }

    private void drawOnMap(Graphics2D graphics, int point, boolean checkHover, Point cursorPos) {
        drawOnMap(graphics, point, WorldPointUtil.dxdy(point, 1, -1), checkHover, cursorPos);
    }

    private void drawOnMap(Graphics2D graphics, int point, int offsetPoint, boolean checkHover, Point cursorPos) {
        int startX = plugin.mapWorldPointToGraphicsPointX(point);
        int startY = plugin.mapWorldPointToGraphicsPointY(point);
        int endX = plugin.mapWorldPointToGraphicsPointX(offsetPoint);
        int endY = plugin.mapWorldPointToGraphicsPointY(offsetPoint);

        if (startX == Integer.MIN_VALUE || startY == Integer.MIN_VALUE ||
            endX == Integer.MIN_VALUE || endY == Integer.MIN_VALUE) {
            return;
        }

        int x = startX;
        int y = startY;
        final int width = endX - x;
        final int height = endY - y;
        x -= width / 2;
        y -= height / 2;

        if (WorldPointUtil.distanceBetween(point, offsetPoint) > 1) {
            graphics.setStroke(new BasicStroke(1, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0, new float[]{9}, 0));
            graphics.drawLine(startX, startY, endX, endY);
        } else {
            if (checkHover && cursorPos != null &&
                cursorPos.getX() >= x && cursorPos.getX() <= (endX - width / 2) &&
                cursorPos.getY() >= y && cursorPos.getY() <= (endY - width / 2)) {
                graphics.setColor(graphics.getColor().darker());
            }
            graphics.fillRect(x, y, width, height);
        }
    }

    private Area getWorldMapClipArea(Rectangle baseRectangle) {
        final Widget overview = client.getWidget(ComponentID.WORLD_MAP_OVERVIEW_MAP);
        final Widget surfaceSelector = client.getWidget(ComponentID.WORLD_MAP_SURFACE_SELECTOR);

        Area clipArea = new Area(baseRectangle);

        if (overview != null && !overview.isHidden()) {
            clipArea.subtract(new Area(overview.getBounds()));
        }

        if (surfaceSelector != null && !surfaceSelector.isHidden()) {
            clipArea.subtract(new Area(surfaceSelector.getBounds()));
        }

        return clipArea;
    }

    private int getWorldMapExtentWidth(Rectangle baseRectangle) {
        return (
            WorldPointUtil.unpackWorldX(
                plugin.calculateMapPoint(
                    baseRectangle.x + baseRectangle.width,
                    baseRectangle.y + baseRectangle.height)) -
            WorldPointUtil.unpackWorldX(
                plugin.calculateMapPoint(
                    baseRectangle.x,
                    baseRectangle.y)));
    }

    private int getWorldMapExtentHeight(Rectangle baseRectangle) {
        return (
            WorldPointUtil.unpackWorldY(
                plugin.calculateMapPoint(
                    baseRectangle.x,
                    baseRectangle.y)) -
            WorldPointUtil.unpackWorldY(
                plugin.calculateMapPoint(
                    baseRectangle.x + baseRectangle.width,
                    baseRectangle.y + baseRectangle.height)));
    }
}

package shortestpath;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum TileCounter {
    DISABLED("Disabled"),
    TRAVELLED("Travelled"),
    REMAINING("Remaining");

    private final String type;

    public static TileCounter fromType(String type) {
        for (TileCounter tileCounter : values()) {
            if (tileCounter.type.equals(type)) {
                return tileCounter;
            }
        }
        return null;
    }
}

package shortestpath;

import java.awt.Color;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;
import net.runelite.client.config.Units;

@ConfigGroup(ShortestPathPlugin.CONFIG_GROUP)
public interface ShortestPathConfig extends Config {
    @ConfigSection(
        name = "Settings",
        description = "Options for the pathfinding",
        position = 0
    )
    String sectionSettings = "sectionSettings";

    @ConfigItem(
        keyName = "avoidWilderness",
        name = "Avoid wilderness",
        description = "Whether the wilderness should be avoided if possible<br>" +
            "(otherwise, will e.g. use wilderness lever from Edgeville to Ardougne)",
        position = 1,
        section = sectionSettings
    )
    default boolean avoidWilderness() {
        return true;
    }

    @ConfigItem(
        keyName = "useAgilityShortcuts",
        name = "Use agility shortcuts",
        description = "Whether to include agility shortcuts in the path.<br>" +
            "You must also have the required agility level",
        position = 2,
        section = sectionSettings
    )
    default boolean useAgilityShortcuts() {
        return true;
    }

    @ConfigItem(
        keyName = "useGrappleShortcuts",
        name = "Use grapple shortcuts",
        description = "Whether to include crossbow grapple agility shortcuts in the path.<br>" +
            "You must also have the required agility, ranged and strength levels",
        position = 3,
        section = sectionSettings
    )
    default boolean useGrappleShortcuts() {
        return false;
    }

    @ConfigItem(
        keyName = "useBoats",
        name = "Use boats",
        description = "Whether to include small boats in the path<br>" +
            "(e.g. the boat to Fishing Platform)",
        position = 4,
        section = sectionSettings
    )
    default boolean useBoats() {
        return true;
    }

    @ConfigItem(
        keyName = "useCanoes",
        name = "Use canoes",
        description = "Whether to include canoes in the path",
        position = 5,
        section = sectionSettings
    )
    default boolean useCanoes() {
        return false;
    }

    @ConfigItem(
        keyName = "useCharterShips",
        name = "Use charter ships",
        description = "Whether to include charter ships in the path",
        position = 6,
        section = sectionSettings
    )
    default boolean useCharterShips() {
        return false;
    }

    @ConfigItem(
        keyName = "useShips",
        name = "Use ships",
        description = "Whether to include passenger ships in the path<br>" +
            "(e.g. the customs ships to Karamja)",
        position = 7,
        section = sectionSettings
    )
    default boolean useShips() {
        return true;
    }

    @ConfigItem(
        keyName = "useFairyRings",
        name = "Use fairy rings",
        description = "Whether to include fairy rings in the path.<br>" +
            "You must also have completed the required quests or miniquests",
        position = 8,
        section = sectionSettings
    )
    default boolean useFairyRings() {
        return true;
    }

    @ConfigItem(
        keyName = "useGnomeGliders",
        name = "Use gnome gliders",
        description = "Whether to include gnome gliders in the path",
        position = 9,
        section = sectionSettings
    )
    default boolean useGnomeGliders() {
        return true;
    }

    @ConfigItem(
        keyName = "useHotAirBalloons",
        name = "Use hot air balloons",
        description = "Whether to include hot air balloons in the path",
        position = 10,
        section = sectionSettings
    )
    default boolean useHotAirBalloons() {
        return false;
    }

    @ConfigItem(
        keyName = "useMagicCarpets",
        name = "Use magic carpets",
        description = "Whether to include magic carpets in the path",
        position = 11,
        section = sectionSettings
    )
    default boolean useMagicCarpets() {
        return true;
    }

    @ConfigItem(
        keyName = "useMagicMushtrees",
        name = "Use magic mushtrees",
        description = "Whether to include Fossil Island Magic Mushtrees in the path<br>" +
            "(e.g. the Mycelium transport network from Verdant Valley to Mushroom Meadow)",
        position = 12,
        section = sectionSettings
    )
    default boolean useMagicMushtrees() {
        return true;
    }

    @ConfigItem(
        keyName = "useMinecarts",
        name = "Use minecarts",
        description = "Whether to include minecarts in the path<br>" +
            "(e.g. the Keldagrim and Lovakengj minecart networks)",
        position = 13,
        section = sectionSettings
    )
    default boolean useMinecarts() {
        return true;
    }

    @ConfigItem(
        keyName = "useQuetzals",
        name = "Use quetzals",
        description = "Whether to include quetzals in the path",
        position = 14,
        section = sectionSettings
    )
    default boolean useQuetzals() {
        return true;
    }

    @ConfigItem(
        keyName = "useSpiritTrees",
        name = "Use spirit trees",
        description = "Whether to include spirit trees in the path",
        position = 15,
        section = sectionSettings
    )
    default boolean useSpiritTrees() {
        return true;
    }

    @ConfigItem(
        keyName = "useTeleportationItems",
        name = "Use teleportation items",
        description = "Whether to include teleportation items from the player's inventory and equipment.<br>" +
            "Options labelled (perm) only use permanent non-charge items.",
        position = 16,
        section = sectionSettings
    )
    default TeleportationItem useTeleportationItems() {
        return TeleportationItem.INVENTORY_NON_CONSUMABLE;
    }

    @ConfigItem(
        keyName = "useTeleportationBoxes",
        name = "Use teleportation boxes",
        description = "Whether to include teleportation boxes or mounted items in the path<br>" +
            "(e.g. the PoH jewellery box or PoH mounted glory amulet)",
        position = 17,
        section = sectionSettings
    )
    default boolean useTeleportationBoxes() {
        return true;
    }

    @ConfigItem(
        keyName = "useTeleportationLevers",
        name = "Use teleportation levers",
        description = "Whether to include teleportation levers in the path<br>" +
            "(e.g. the lever from Edgeville to Wilderness)",
        position = 18,
        section = sectionSettings
    )
    default boolean useTeleportationLevers() {
        return true;
    }

    @ConfigItem(
        keyName = "useTeleportationPortals",
        name = "Use teleportation portals",
        description = "Whether to include teleportation portals in the path<br>" +
            "(e.g. the portal from Ferox Enclave to Castle Wars or the PoH portals/nexus)",
        position = 19,
        section = sectionSettings
    )
    default boolean useTeleportationPortals() {
        return true;
    }

    @ConfigItem(
        keyName = "useTeleportationSpells",
        name = "Use teleportation spells",
        description = "Whether to include teleportation spells in the path",
        position = 20,
        section = sectionSettings
    )
    default boolean useTeleportationSpells() {
        return true;
    }

    @ConfigItem(
        keyName = "useTeleportationMinigames",
        name = "Use teleportation to minigames",
        description = "Whether to include teleportation to minigames/activities/grouping in the path<br>" +
            "(e.g. the Nightmare Zone minigame teleport). These teleports share a 20 minute cooldown.",
        position = 21,
        section = sectionSettings
    )
    default boolean useTeleportationMinigames() {
        return true;
    }

    @ConfigItem(
        keyName = "useWildernessObelisks",
        name = "Use wilderness obelisks",
        description = "Whether to include wilderness obelisks in the path",
        position = 22,
        section = sectionSettings
    )
    default boolean useWildernessObelisks() {
        return true;
    }

    @ConfigItem(
        keyName = "currencyThreshold",
        name = "Currency threshold",
        description = "The maximum amount of currency to use on a single transportation method." +
            "<br>The currencies affected by the threshold are coins, trading sticks, ecto-tokens and warrior guild tokens.",
        position = 23,
        section = sectionSettings
    )
    default int currencyThreshold() {
        return 100000;
    }

    @ConfigItem(
        keyName = "cancelInstead",
        name = "Cancel instead of recalculating",
        description = "Whether the path should be cancelled rather than recalculated " +
            "when the recalculate distance limit is exceeded",
        position = 24,
        section = sectionSettings
    )
    default boolean cancelInstead() {
        return false;
    }

    @Range(
        min = -1,
        max = 20000
    )
    @ConfigItem(
        keyName = "recalculateDistance",
        name = "Recalculate distance",
        description = "Distance from the path the player should be for it to be recalculated (-1 for never)",
        position = 25,
        section = sectionSettings
    )
    default int recalculateDistance() {
        return 10;
    }

    @Range(
        min = -1,
        max = 50
    )
    @ConfigItem(
        keyName = "finishDistance",
        name = "Finish distance",
        description = "Distance from the target tile at which the path should be ended (-1 for never)",
        position = 26,
        section = sectionSettings
    )
    default int reachedDistance() {
        return 5;
    }

    @ConfigItem(
        keyName = "showTileCounter",
        name = "Show tile counter",
        description = "Whether to display the number of tiles travelled, number of tiles remaining or disable counting",
        position = 27,
        section = sectionSettings
    )
    default TileCounter showTileCounter() {
        return TileCounter.DISABLED;
    }

    @ConfigItem(
        keyName = "tileCounterStep",
        name = "Tile counter step",
        description = "The number of tiles between the displayed tile counter numbers",
        position = 28,
        section = sectionSettings
    )
    default int tileCounterStep()
    {
        return 1;
    }

    @Units(
        value = Units.TICKS
    )
    @Range(
        min = 1,
        max = 30
    )
    @ConfigItem(
        keyName = "calculationCutoff",
        name = "Calculation cutoff",
        description = "The cutoff threshold in number of ticks (0.6 seconds) of no progress being<br>" +
            "made towards the path target before the calculation will be stopped",
        position = 29,
        section = sectionSettings
    )
    default int calculationCutoff()
    {
        return 5;
    }

    @ConfigItem(
        keyName = "showTransportInfo",
        name = "Show transport info",
        description = "Whether to display transport destination hint info, e.g. which chat option and text to click",
        position = 30,
        section = sectionSettings
    )
    default boolean showTransportInfo() {
        return true;
    }

    @ConfigSection(
        name = "Display",
        description = "Options for displaying the path on the world map, minimap and scene tiles",
        position = 31
    )
    String sectionDisplay = "sectionDisplay";

    @ConfigItem(
        keyName = "drawMap",
        name = "Draw path on world map",
        description = "Whether the path should be drawn on the world map",
        position = 32,
        section = sectionDisplay
    )
    default boolean drawMap() {
        return true;
    }

    @ConfigItem(
        keyName = "drawMinimap",
        name = "Draw path on minimap",
        description = "Whether the path should be drawn on the minimap",
        position = 33,
        section = sectionDisplay
    )
    default boolean drawMinimap() {
        return true;
    }

    @ConfigItem(
        keyName = "drawTiles",
        name = "Draw path on tiles",
        description = "Whether the path should be drawn on the game tiles",
        position = 34,
        section = sectionDisplay
    )
    default boolean drawTiles() {
        return true;
    }

    @ConfigItem(
        keyName = "pathStyle",
        name = "Path style",
        description = "Whether to display the path as tiles or a segmented line",
        position = 35,
        section = sectionDisplay
    )
    default TileStyle pathStyle() {
        return TileStyle.TILES;
    }

    @ConfigSection(
        name = "Colours",
        description = "Colours for the path map, minimap and scene tiles",
        position = 36
    )
    String sectionColours = "sectionColours";

    @Alpha
    @ConfigItem(
        keyName = "colourPath",
        name = "Path",
        description = "Colour of the path tiles on the world map, minimap and in the game scene",
        position = 37,
        section = sectionColours
    )
    default Color colourPath() {
        return new Color(255, 0, 0);
    }

    @Alpha
    @ConfigItem(
        keyName = "colourPathCalculating",
        name = "Calculating",
        description = "Colour of the path tiles while the pathfinding calculation is in progress," +
            "<br>and the colour of unused targets if there are more than a single target",
        position = 38,
        section = sectionColours
    )
    default Color colourPathCalculating() {
        return new Color(0, 0, 255);
    }

    @Alpha
    @ConfigItem(
        keyName = "colourTransports",
        name = "Transports",
        description = "Colour of the transport tiles",
        position = 39,
        section = sectionColours
    )
    default Color colourTransports() {
        return new Color(0, 255, 0, 128);
    }

    @Alpha
    @ConfigItem(
        keyName = "colourCollisionMap",
        name = "Collision map",
        description = "Colour of the collision map tiles",
        position = 40,
        section = sectionColours
    )
    default Color colourCollisionMap() {
        return new Color(0, 128, 255, 128);
    }

    @Alpha
    @ConfigItem(
        keyName = "colourText",
        name = "Text",
        description = "Colour of the text of the tile counter and fairy ring codes",
        position = 41,
        section = sectionColours
    )
    default Color colourText() {
        return Color.WHITE;
    }

    @ConfigSection(
        name = "Debug Options",
        description = "Various options for debugging",
        position = 42,
        closedByDefault = true
    )
    String sectionDebug = "sectionDebug";

    @ConfigItem(
        keyName = "drawTransports",
        name = "Draw transports",
        description = "Whether transports should be drawn",
        position = 43,
        section = sectionDebug
    )
    default boolean drawTransports() {
        return false;
    }

    @ConfigItem(
        keyName = "drawCollisionMap",
        name = "Draw collision map",
        description = "Whether the collision map should be drawn",
        position = 44,
        section = sectionDebug
    )
    default boolean drawCollisionMap() {
        return false;
    }

    @ConfigItem(
        keyName = "drawDebugPanel",
        name = "Show debug panel",
        description = "Toggles displaying the pathfinding debug stats panel",
        position = 45,
        section = sectionDebug
    )
    default boolean drawDebugPanel() {
        return false;
    }

    @ConfigItem(
        keyName = "postTransports",
        name = "Post transports",
        description = "Whether to post the transports used in the current path as a PluginMessage event",
        position = 46,
        section = sectionDebug
    )
    default boolean postTransports() {
        return false;
    }
}

package shortestpath;

import com.google.inject.Inject;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.JagexColors;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

public class PathMapTooltipOverlay extends Overlay {
    private static final int TOOLTIP_OFFSET_HEIGHT = 25;
    private static final int TOOLTIP_OFFSET_WIDTH = 15;
    private static final int TOOLTIP_PADDING_HEIGHT = 1;
    private static final int TOOLTIP_PADDING_WIDTH = 2;
    private static final int TOOLTIP_TEXT_OFFSET_HEIGHT = -2;

    private final Client client;
    private final ShortestPathPlugin plugin;

    @Inject
    private PathMapTooltipOverlay(Client client, ShortestPathPlugin plugin) {
        this.client = client;
        this.plugin = plugin;
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(Overlay.PRIORITY_HIGHEST);
        setLayer(OverlayLayer.MANUAL);
        drawAfterInterface(InterfaceID.WORLD_MAP);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!plugin.drawMap || client.getWidget(ComponentID.WORLD_MAP_MAPVIEW) == null) {
            return null;
        }

        if (plugin.getPathfinder() != null) {
            PrimitiveIntList path = plugin.getPathfinder().getPath();
            Point cursorPos = client.getMouseCanvasPosition();
            for (int i = 0; i < path.size(); i++) {
                int nextPoint = WorldPointUtil.UNDEFINED;
                if (path.size() > i + 1) {
                    nextPoint = path.get(i + 1);
                }
                if (drawTooltip(graphics, cursorPos, path.get(i), nextPoint, i + 1)) {
                    return null;
                }
            }
            for (int target : plugin.getPathfinder().getTargets()) {
                if (path.size() > 0 && target != path.get(path.size() - 1)) {
                    drawTooltip(graphics, cursorPos, target, WorldPointUtil.UNDEFINED, -1);
                }
            }
        }

        return null;
    }

    private boolean drawTooltip(Graphics2D graphics, Point cursorPos, int point, int nextPoint, int n) {
        int offsetPoint = WorldPointUtil.dxdy(point, 1, -1);
        int startX = plugin.mapWorldPointToGraphicsPointX(point);
        int startY = plugin.mapWorldPointToGraphicsPointY(point);
        int endX = plugin.mapWorldPointToGraphicsPointX(offsetPoint);
        int endY = plugin.mapWorldPointToGraphicsPointY(offsetPoint);

        if (startX == Integer.MIN_VALUE || startY == Integer.MIN_VALUE ||
            endX == Integer.MIN_VALUE || endY == Integer.MIN_VALUE) {
            return false;
        }

        int width = endX - startX;

        if (cursorPos.getX() < (startX - width / 2) || cursorPos.getX() > (endX - width / 2) ||
            cursorPos.getY() < (startY - width / 2) || cursorPos.getY() > (endY - width / 2)) {
            return false;
        }

        List<String> rows = new ArrayList<>(Arrays.asList("Shortest path:",
            n < 0 ? "Unused target" : ("Step " + n + " of " + plugin.getPathfinder().getPath().size())));
        if (nextPoint != WorldPointUtil.UNDEFINED) {
            for (Transport transport : plugin.getTransports().getOrDefault(point, new HashSet<>())) {
                if (nextPoint == transport.getDestination()
                    && transport.getDisplayInfo() != null && !transport.getDisplayInfo().isEmpty()) {
                    rows.add(transport.getDisplayInfo());
                    break;
                }
            }
        }

        graphics.setFont(FontManager.getRunescapeFont());
        FontMetrics fm = graphics.getFontMetrics();
        int tooltipHeight = fm.getHeight();
        int tooltipWidth = rows.stream().map(fm::stringWidth).max(Integer::compareTo).get();

        int clippedHeight = tooltipHeight * rows.size() + TOOLTIP_PADDING_HEIGHT * 2;
        int clippedWidth = tooltipWidth + TOOLTIP_PADDING_WIDTH * 2;

        Rectangle worldMapBounds = client.getWidget(ComponentID.WORLD_MAP_MAPVIEW).getBounds();
        int worldMapRightBoundary = worldMapBounds.width + worldMapBounds.x;
        int worldMapBottomBoundary = worldMapBounds.height + worldMapBounds.y;

        int drawPointX = startX + TOOLTIP_OFFSET_WIDTH;
        int drawPointY = startY;
        if (drawPointX + clippedWidth > worldMapRightBoundary) {
            drawPointX = worldMapRightBoundary - clippedWidth;
        }
        if (drawPointY + clippedHeight > worldMapBottomBoundary) {
            drawPointY = startY - clippedHeight;
        }
        drawPointY += TOOLTIP_OFFSET_HEIGHT;

        int tooltipRectX = drawPointX - TOOLTIP_PADDING_WIDTH;
        int tooltipRectY = drawPointY - TOOLTIP_PADDING_HEIGHT;

        graphics.setColor(JagexColors.TOOLTIP_BACKGROUND);
        graphics.fillRect(tooltipRectX, tooltipRectY, clippedWidth, clippedHeight);

        graphics.setColor(JagexColors.TOOLTIP_BORDER);
        graphics.drawRect(tooltipRectX, tooltipRectY, clippedWidth, clippedHeight);

        graphics.setColor(JagexColors.TOOLTIP_TEXT);
        for (int i = 0; i < rows.size(); i++) {
            graphics.drawString(rows.get(i), drawPointX, drawPointY + TOOLTIP_TEXT_OFFSET_HEIGHT + (i + 1) * tooltipHeight);
        }

        return true;
    }
}

package shortestpath;

public enum TransportType {
    TRANSPORT,
    AGILITY_SHORTCUT,
    GRAPPLE_SHORTCUT,
    BOAT,
    CANOE,
    CHARTER_SHIP,
    SHIP,
    FAIRY_RING,
    GNOME_GLIDER,
    HOT_AIR_BALLOON,
    MAGIC_CARPET,
    MAGIC_MUSHTREE,
    MINECART,
    QUETZAL,
    SPIRIT_TREE,
    TELEPORTATION_BOX,
    TELEPORTATION_ITEM,
    TELEPORTATION_LEVER,
    TELEPORTATION_MINIGAME,
    TELEPORTATION_PORTAL,
    TELEPORTATION_SPELL,
    WILDERNESS_OBELISK,
    ;

    /*
     * Indicates whether a TransportType is a teleport.
     * Levers, portals and wilderness obelisks are considered transports
     * and not teleports because they have a pre-defined origin and no
     * wilderness level limit.
     */
    public static boolean isTeleport(TransportType transportType) {
        if (transportType == null) {
            return false;
        }
        switch (transportType) {
            case TELEPORTATION_ITEM:
            case TELEPORTATION_MINIGAME:
            case TELEPORTATION_SPELL:
                return true;
            default:
                return false;
        }
    }
}

package shortestpath;

import net.runelite.api.Client;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import static net.runelite.api.Constants.CHUNK_SIZE;
import static net.runelite.api.Perspective.LOCAL_COORD_BITS;

/**
 * Utility functions for packing, unpacking, and transforming {@link WorldPoint} coordinates as compact {@code int} values.
 * <p>
 * A packed world point encodes {@code x}, {@code y}, and {@code plane} into a single 32-bit integer using:
 * <pre>
 * bits 0..14   : x (15 bits)
 * bits 15..29  : y (15 bits)
 * bits 30..31  : plane (2 bits)
 * </pre>
 * This representation allows efficient storage and hashing of coordinates within the pathfinding data structures.
 */
public class WorldPointUtil {
    public static final int UNDEFINED = -1;

    /**
     * Packs a {@link WorldPoint} into a compact {@code int} encoding.
     *
     * @param point world point (may be {@code null}).
     * @return packed integer value, or {@link #UNDEFINED} if {@code point} is {@code null}.
     */
    public static int packWorldPoint(WorldPoint point) {
        if (point == null) {
            return -1;
        }
        return packWorldPoint(point.getX(), point.getY(), point.getPlane());
    }

    /**
     * Packs the provided coordinate triple into a single {@code int}.
     * First 15 bits are {@code x}, next 15 bits are {@code y}, final 2 bits are the plane.
     * Values are masked into range; overflow bits are discarded.
     *
     * @param x world x (0..32767 effectively supported).
     * @param y world y (0..32767 effectively supported).
     * @param plane plane (0..3).
     * @return packed integer representation.
     */
    public static int packWorldPoint(int x, int y, int plane) {
        return (x & 0x7FFF) | ((y & 0x7FFF) << 15) | ((plane & 0x3) << 30);
    }

    /**
     * Unpacks a packed world point into a new {@link WorldPoint} instance.
     *
     * @param packedPoint packed coordinate.
     * @return decoded {@link WorldPoint}.
     */
    public static WorldPoint unpackWorldPoint(int packedPoint) {
        final int x = unpackWorldX(packedPoint);
        final int y = unpackWorldY(packedPoint);
        final int plane = unpackWorldPlane(packedPoint);
        return new WorldPoint(x, y, plane);
    }

    /**
     * Extracts the x component from a packed world point.
     * @param packedPoint packed coordinate.
     * @return x value.
     */
    public static int unpackWorldX(int packedPoint) {
        return packedPoint & 0x7FFF;
    }

    /**
     * Extracts the y component from a packed world point.
     * @param packedPoint packed coordinate.
     * @return y value.
     */
    public static int unpackWorldY(int packedPoint) {
        return (packedPoint >> 15) & 0x7FFF;
    }

    /**
     * Extracts the plane component from a packed world point.
     * @param packedPoint packed coordinate.
     * @return plane value (0..3).
     */
    public static int unpackWorldPlane(int packedPoint) {
        return (packedPoint >> 30) & 0x3;
    }

    /**
     * Offsets a packed world point by {@code (dx, dy)} on the same plane.
     *
     * @param packedPoint base packed point.
     * @param dx delta x to add.
     * @param dy delta y to add.
     * @return packed point after applying deltas.
     */
    public static int dxdy(int packedPoint, int dx, int dy) {
        int x = unpackWorldX(packedPoint);
        int y = unpackWorldY(packedPoint);
        int z = unpackWorldPlane(packedPoint);
        return packWorldPoint(x + dx, y + dy, z);
    }

    /**
     * Computes the distance between two packed points using Chebyshev metric (diagonal = 1).
     */
    public static int distanceBetween(int previousPacked, int currentPacked) {
        return distanceBetween(previousPacked, currentPacked, 1);
    }

    /**
     * Computes the 2D distance (ignoring plane) between two packed points using Chebyshev metric (diagonal = 1).
     */
    public static int distanceBetween2D(int previousPacked, int currentPacked) {
        return distanceBetween2D(previousPacked, currentPacked, 1);
    }

    /**
     * Computes distance between two packed points with selectable distance metric.
     *
     * @param previousPacked first packed point.
     * @param currentPacked second packed point.
     * @param diagonal {@code 1} for Chebyshev (max), {@code 2} for Manhattan (sum). Any other value returns {@code Integer.MAX_VALUE}.
     * @return distance or {@code Integer.MAX_VALUE} if plane differs or metric is unsupported.
     */
    public static int distanceBetween(int previousPacked, int currentPacked, int diagonal) {
        final int previousX = WorldPointUtil.unpackWorldX(previousPacked);
        final int previousY = WorldPointUtil.unpackWorldY(previousPacked);
        final int previousZ = WorldPointUtil.unpackWorldPlane(previousPacked);
        final int currentX = WorldPointUtil.unpackWorldX(currentPacked);
        final int currentY = WorldPointUtil.unpackWorldY(currentPacked);
        final int currentZ = WorldPointUtil.unpackWorldPlane(currentPacked);
        return distanceBetween(previousX, previousY, previousZ,
            currentX, currentY, currentZ, diagonal);
    }

    /**
     * Computes 2D distance (ignoring plane) between two packed points with selectable metric.
     * @see #distanceBetween(int, int, int, int, int, int, int)
     */
    public static int distanceBetween2D(int previousPacked, int currentPacked, int diagonal) {
        final int previousX = WorldPointUtil.unpackWorldX(previousPacked);
        final int previousY = WorldPointUtil.unpackWorldY(previousPacked);
        final int currentX = WorldPointUtil.unpackWorldX(currentPacked);
        final int currentY = WorldPointUtil.unpackWorldY(currentPacked);
        return distanceBetween2D(previousX, previousY, currentX, currentY, diagonal);
    }

    /**
     * Computes distance between two coordinates with selectable metric; returns {@code Integer.MAX_VALUE} if planes differ.
     *
     * @param previousX x of first point.
     * @param previousY y of first point.
     * @param previousZ plane of first point.
     * @param currentX x of second point.
     * @param currentY y of second point.
     * @param currentZ plane of second point.
     * @param diagonal metric selector ({@code 1}=Chebyshev, {@code 2}=Manhattan).
     * @return distance or {@code Integer.MAX_VALUE} if planes differ or unsupported metric.
     */
    public static int distanceBetween(int previousX, int previousY, int previousZ,
        int currentX, int currentY, int currentZ, int diagonal) {
        final int dz = Math.abs(previousZ - currentZ);

        if (dz != 0) {
            return Integer.MAX_VALUE;
        }

        return distanceBetween2D(previousX, previousY, currentX, currentY, diagonal);
    }

    /**
     * Computes a 2D distance using either Chebyshev or Manhattan metric.
     *
     * @param previousX x of first point.
     * @param previousY y of first point.
     * @param currentX x of second point.
     * @param currentY y of second point.
     * @param diagonal metric selector ({@code 1}=Chebyshev, {@code 2}=Manhattan).
     * @return distance or {@code Integer.MAX_VALUE} for unsupported metric.
     */
    public static int distanceBetween2D(int previousX, int previousY,
        int currentX, int currentY, int diagonal) {
        final int dx = Math.abs(previousX - currentX);
        final int dy = Math.abs(previousY - currentY);

        if (diagonal == 1) {
            return Math.max(dx, dy);
        } else if (diagonal == 2) {
            return dx + dy;
        }

        return Integer.MAX_VALUE;
    }

    /**
     * Convenience overload using Chebyshev distance between two {@link WorldPoint}s.
     */
    public static int distanceBetween(WorldPoint previous, WorldPoint current) {
        return distanceBetween(previous, current, 1);
    }

    /**
     * Distance between two {@link WorldPoint}s with selectable metric.
     * @see #distanceBetween(int, int, int, int, int, int, int)
     */
    public static int distanceBetween(WorldPoint previous, WorldPoint current, int diagonal) {
        return distanceBetween(previous.getX(), previous.getY(), previous.getPlane(),
            current.getX(), current.getY(), current.getPlane(), diagonal);
    }

    /**
     * Distance from a packed point to a {@link WorldArea} using Chebyshev metric, respecting plane.
     * Returns {@code Integer.MAX_VALUE} if the plane differs.
     */
    public static int distanceToArea(int packedPoint, WorldArea area) {
        final int plane = unpackWorldPlane(packedPoint);
        if (area.getPlane() != plane) {
            return Integer.MAX_VALUE;
        }
        return distanceToArea2D(packedPoint, area);
    }

    /**
     * 2D distance (Chebyshev) from a packed point to a {@link WorldArea} ignoring plane, equivalent to
     * {@link WorldArea#distanceTo(WorldPoint)} semantics in 2D.
     */
    public static int distanceToArea2D(int packedPoint, WorldArea area) {
        final int y = unpackWorldY(packedPoint);
        final int x = unpackWorldX(packedPoint);
        final int areaMaxX = area.getX() + area.getWidth() - 1;
        final int areaMaxY = area.getY() + area.getHeight() - 1;
        final int dx = Math.max(Math.max(area.getX() - x, 0), x - areaMaxX);
        final int dy = Math.max(Math.max(area.getY() - y, 0), y - areaMaxY);

        return Math.max(dx, dy);
    }

    private static int rotate(int originalX, int originalY, int z, int rotation) {
        int chunkX = originalX & ~(CHUNK_SIZE - 1);
        int chunkY = originalY & ~(CHUNK_SIZE - 1);
        int x = originalX & (CHUNK_SIZE - 1);
        int y = originalY & (CHUNK_SIZE - 1);
        switch (rotation) {
            case 1:
                return packWorldPoint(chunkX + y, chunkY + (CHUNK_SIZE - 1 - x), z);
            case 2:
                return packWorldPoint(chunkX + (CHUNK_SIZE - 1 - x), chunkY + (CHUNK_SIZE - 1 - y), z);
            case 3:
                return packWorldPoint(chunkX + (CHUNK_SIZE - 1 - y), chunkY + x, z);
        }
        return packWorldPoint(originalX, originalY, z);
    }

    /**
     * Converts an instanced {@link LocalPoint} to its corresponding packed world point coordinate, resolving the
     * underlying template chunk mapping and rotation.
     *
     * @param client RuneLite client.
     * @param localPoint local scene coordinate.
     * @return packed world point.
     */
    public static int fromLocalInstance(Client client, LocalPoint localPoint) {
        WorldView worldView = client.getWorldView(localPoint.getWorldView());
        int plane = worldView.getPlane();

        if (!worldView.isInstance()) {
            return packWorldPoint(
                (localPoint.getX() >> LOCAL_COORD_BITS) + worldView.getBaseX(),
                (localPoint.getY() >> LOCAL_COORD_BITS) + worldView.getBaseY(),
                plane);
        }

        int[][][] instanceTemplateChunks = worldView.getInstanceTemplateChunks();

        // get position in the scene
        int sceneX = localPoint.getSceneX();
        int sceneY = localPoint.getSceneY();

        // get chunk from scene
        int chunkX = sceneX / CHUNK_SIZE;
        int chunkY = sceneY / CHUNK_SIZE;

        // get the template chunk for the chunk
        int templateChunk = instanceTemplateChunks[plane][chunkX][chunkY];

        int rotation = templateChunk >> 1 & 0x3;
        int templateChunkY = (templateChunk >> 3 & 0x7FF) * CHUNK_SIZE;
        int templateChunkX = (templateChunk >> 14 & 0x3FF) * CHUNK_SIZE;
        int templateChunkPlane = templateChunk >> 24 & 0x3;

        // calculate world point of the template
        int x = templateChunkX + (sceneX & (CHUNK_SIZE - 1));
        int y = templateChunkY + (sceneY & (CHUNK_SIZE - 1));

        // create and rotate point back to 0, to match with template
        return rotate(x, y, templateChunkPlane, 4 - rotation);
    }

    /**
     * Converts a packed world point to one or more packed world points representing its locations within an instanced
     * map (e.g., dungeons or raids). If the current top-level world is not instanced, the result contains exactly the
     * original point.
     *
     * @param client RuneLite client.
     * @param packedPoint packed world coordinate.
     * @return list of packed coordinates valid in the current instance.
     */
    public static PrimitiveIntList toLocalInstance(Client client, int packedPoint) {
        WorldView worldView = client.getTopLevelWorldView();

        PrimitiveIntList worldPoints = new PrimitiveIntList();
        if (!worldView.isInstance()) {
            worldPoints.add(packedPoint);
            return worldPoints;
        }

        int baseX = worldView.getBaseX();
        int baseY = worldView.getBaseY();
        int worldPointX = unpackWorldX(packedPoint);
        int worldPointY = unpackWorldY(packedPoint);
        int worldPointPlane = unpackWorldPlane(packedPoint);

        int[][][] instanceTemplateChunks = worldView.getInstanceTemplateChunks();

        // find instance chunks using the template point. there might be more than one.
        for (int z = 0; z < instanceTemplateChunks.length; z++) {
            for (int x = 0; x < instanceTemplateChunks[z].length; ++x) {
                for (int y = 0; y < instanceTemplateChunks[z][x].length; ++y) {
                    int chunkData = instanceTemplateChunks[z][x][y];
                    int rotation = chunkData >> 1 & 0x3;
                    int templateChunkY = (chunkData >> 3 & 0x7FF) * CHUNK_SIZE;
                    int templateChunkX = (chunkData >> 14 & 0x3FF) * CHUNK_SIZE;
                    int plane = chunkData >> 24 & 0x3;
                    if (worldPointX >= templateChunkX && worldPointX < templateChunkX + CHUNK_SIZE
                        && worldPointY >= templateChunkY && worldPointY < templateChunkY + CHUNK_SIZE
                        && plane == worldPointPlane) {
                        worldPoints.add(rotate(
                            baseX + x * CHUNK_SIZE + (worldPointX & (CHUNK_SIZE - 1)),
                            baseY + y * CHUNK_SIZE + (worldPointY & (CHUNK_SIZE - 1)),
                            z,
                            rotation));
                    }
                }
            }
        }
        return worldPoints;
    }

    private static boolean isInScene(WorldView worldView, int packedPoint) {
        int x = unpackWorldX(packedPoint);
        int y = unpackWorldY(packedPoint);

        int baseX = worldView.getBaseX();
        int baseY = worldView.getBaseY();

        int maxX = baseX + worldView.getSizeX();
        int maxY = baseY + worldView.getSizeY();

        return x >= baseX && x < maxX && y >= baseY && y < maxY;
    }

    /**
     * Converts a packed world point into a {@link LocalPoint} relative to the top-level world view if it resides in
     * the currently loaded scene and on the same plane; returns {@code null} otherwise.
     *
     * @param client RuneLite client.
     * @param packedPoint packed world point.
     * @return {@link LocalPoint} or {@code null} if out of scene or plane.
     */
    public static LocalPoint toLocalPoint(Client client, int packedPoint) {
        WorldView worldView = client.getTopLevelWorldView();

        if (worldView.getPlane() != unpackWorldPlane(packedPoint)) {
            return null;
        }

        if (!isInScene(worldView, packedPoint)) {
            return null;
        }

        return new LocalPoint(
            (unpackWorldX(packedPoint) - worldView.getBaseX() << LOCAL_COORD_BITS) + (1 << LOCAL_COORD_BITS - 1),
            (unpackWorldY(packedPoint) - worldView.getBaseY() << LOCAL_COORD_BITS) + (1 << LOCAL_COORD_BITS - 1),
            worldView.getId());
    }
}

package shortestpath;

import lombok.Getter;

public enum TransportVarCheck {
    BIT_SET("&"),
    COOLDOWN_MINUTES("@"),
    EQUAL("="),
    GREATER(">"),
    SMALLER("<"),
    ;

    @Getter
    private final String code;

    TransportVarCheck(String code) {
        this.code = code;
    }
}

package shortestpath;

import com.google.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.Shape;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

public class PathMinimapOverlay extends Overlay {
    private final Client client;
    private final ShortestPathPlugin plugin;

    @Inject
    private PathMinimapOverlay(Client client, ShortestPathPlugin plugin) {
        this.client = client;
        this.plugin = plugin;
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(Overlay.PRIORITY_LOW);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!plugin.drawMinimap || plugin.getPathfinder() == null) {
            return null;
        }

        Shape minimapClipArea = plugin.getMinimapClipArea();
        if (minimapClipArea == null) {
            return null;
        } else {
            graphics.setClip(plugin.getMinimapClipArea());
        }
        graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);

        PrimitiveIntList pathPoints = plugin.getPathfinder().getPath();
        Color pathColor = plugin.getPathfinder().isDone() ? plugin.colourPath : plugin.colourPathCalculating;
        for (int i = 0; i < pathPoints.size(); i++) {
            int pathPoint = pathPoints.get(i);
            if (WorldPointUtil.unpackWorldPlane(pathPoint) != client.getPlane()) {
                continue;
            }

            drawOnMinimap(graphics, pathPoint, pathColor);
        }
        for (int target : plugin.getPathfinder().getTargets()) {
            if (pathPoints.size() > 0 && target != pathPoints.get(pathPoints.size() - 1)) {
                drawOnMinimap(graphics, target, plugin.colourPathCalculating);
            }
        }

        return null;
    }

    private void drawOnMinimap(Graphics2D graphics, int location, Color color) {
        PrimitiveIntList points = WorldPointUtil.toLocalInstance(client, location);
        for (int i = 0; i < points.size(); i++) {
            LocalPoint lp = WorldPointUtil.toLocalPoint(client, points.get(i));

            if (lp == null) {
                continue;
            }

            Point posOnMinimap = Perspective.localToMinimap(client, lp);

            if (posOnMinimap == null) {
                continue;
            }

            renderMinimapRect(client, graphics, posOnMinimap, color);
        }
    }

    public static void renderMinimapRect(Client client, Graphics2D graphics, Point center, Color color) {
        double angle = client.getCameraYawTarget() * Perspective.UNIT;
        double tileSize = client.getMinimapZoom();
        int x = (int) Math.round(center.getX() - tileSize / 2);
        int y = (int) Math.round(center.getY() - tileSize / 2);
        int width = (int) Math.round(tileSize);
        int height = (int) Math.round(tileSize);
        graphics.setColor(color);
        graphics.rotate(angle, center.getX(), center.getY());
        graphics.fillRect(x, y, width, height);
        graphics.rotate(-angle, center.getX(), center.getY());
    }
}

package shortestpath.pathfinder;

import static org.junit.Assert.assertEquals;

import java.util.Map;
import java.util.Set;
import org.junit.Test;

import shortestpath.Transport;
import shortestpath.TransportType;

public class TransportCountingTest {
    private static final Map<Integer, Set<Transport>> transports = Transport.loadAllFromResources();

@Test
    public void testNumberOfHotAirBalloons() {
        // All permutations of hot air balloon transports are resolved from origins and destinations
        int actualCount = 0;
        for (int origin : transports.keySet()) {
            for (Transport transport : transports.get(origin)) {
                if (TransportType.HOT_AIR_BALLOON.equals(transport.getType())) {
                    actualCount++;
                }
            }
        }
        /* 
         * Info:
         * single_hot_air_balloon_origin_locations * (number_of_hot_air_balloons - 1)
         *   6 * 5   // Entrana
         * + 8 * 5   // Taverley
         * + 8 * 5   // Crafting Guild
         * + 8 * 5   // Varrock
         * + 7 * 5   // Castle Wars
         * + 8 * 5   // Grand Tree
         * = 225
         */
        assertEquals(225, actualCount);
    }

    @Test
    public void testNumberOfMagicMushtrees() {
        // All permutations of magic mushtree transports are resolved from origins and destinations
        int actualCount = 0;
        for (int origin : transports.keySet()) {
            for (Transport transport : transports.get(origin)) {
                if (TransportType.MAGIC_MUSHTREE.equals(transport.getType())) {
                    actualCount++;
                }
            }
        }
        /*
         * Info:
         * single_mushtree_origin_locations * (number_of_magic_mushtrees - 1)
         *   2 * 3   // House on the Hill
         * + 2 * 3   // Verdant Valley
         * + 2 * 3   // Sticky Swamp
         * + 2 * 3   // Mushroom Meadow
         * = 24
         */
        assertEquals(24, actualCount);
    }

    @Test
    public void testNumberOfQuetzals() {
        // All but 2 permutations of quetzal transports are resolved from origins and destinations
        int actualCount = 0;
        for (int origin : transports.keySet()) {
            for (Transport transport : transports.get(origin)) {
                if (TransportType.QUETZAL.equals(transport.getType())) {
                    actualCount++;
                }
            }
        }
        /*
         * Info:
         * NB: Primio can only be used between Varrock and Civitas illa Fortis
         * single_quetzal_origin_locations * (number_of_quetzals - 1) + 2
         *   1 * 13 // Aldarin
         * + 1 * 13 // Auburnvale
         * + 1 * 13 // Civitas illa Fortis
         * + 1 * 13 // Hunter Guild
         * + 1 * 13 // Quetzacalli Gorge
         * + 1 * 13 // Sunset Coast
         * + 1 * 13 // Tal Teklan
         * + 1 * 13 // The Teomat
         * + 1 * 13 // Cam Torum entrance
         * + 1 * 13 // Colossal Wyrm Remains
         * + 1 * 13 // Fortis Colosseum
         * + 1 * 13 // Kastori
         * + 1 * 13 // Outer Fortis
         * + 1 * 13 // Salvager Overlook
         * + 1 // Varrock -> Civitas illa Fortis
         * + 1 // Civitas illa Fortis -> Varrock
         * = 182 + 2
         * = 184
         */
        assertEquals(184, actualCount);
    }

    @Test
    public void testNumberOfSpiritTrees() {
        // All permutations of spirit tree transports are resolved from origins and destinations
        int actualCount = 0;
        for (int origin : transports.keySet()) {
            for (Transport transport : transports.get(origin)) {
                if (TransportType.SPIRIT_TREE.equals(transport.getType())) {
                    actualCount++;
                }
            }
        }
        /*
         * Info:
         * single_tree_origin_locations * (number_of_spirit_trees - 1)
         *   15 * 11   // Tree Gnome Village
         * + 14 * 11   // Gnome Stronghold
         * +  8 * 11   // Battlefield of Khazard
         * +  8 * 11   // Grand Exchange
         * +  8 * 11   // Feldip Hills
         * +  7 * 11   // Prifddinas
         * + 12 * 11   // Port Sarim
         * + 12 * 11   // Etceteria
         * + 12 * 11   // Brimhaven
         * + 12 * 11   // Hosidius
         * + 12 * 11   // Farming Guild
         * +  0 * 11   // Player-owned house
         * + 12 * 11   // Poison Waste
         * = 1452
         */
        assertEquals(1452, actualCount);
    }

    @Test
    public void testNumberOfCharterShips() {
        int actualCount = 0;
        for (int origin : transports.keySet()) {
            for (Transport transport : transports.get(origin)) {
                if (TransportType.CHARTER_SHIP.equals(transport.getType())) {
                    actualCount++;
                }
            }
        }
        /*
         * Info:
         * There are currently 16 unique charter ship origin/destinations.
         * If every combination was possible then it would be 16^2 = 256.
         * It is impossible to travel from and to the same place, so subtract 16.
         * It is also impossible to travel between certain places, presumably
         * because the distance between them is too small. Currently 12 of these.
         */
        assertEquals(16 * 16 - 16 - 12, actualCount);
    }
}

package shortestpath.pathfinder;

import java.util.Map;
import java.util.Set;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.Quest;
import net.runelite.api.QuestState;
import net.runelite.api.Skill;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;

import shortestpath.ItemVariations;
import shortestpath.ShortestPathConfig;
import shortestpath.ShortestPathPlugin;
import shortestpath.TeleportationItem;
import shortestpath.Transport;
import shortestpath.TransportItems;
import shortestpath.TransportType;
import shortestpath.WorldPointUtil;
import shortestpath.pathfinder.Pathfinder;
import shortestpath.pathfinder.PathfinderConfig;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class PathfinderTest {
    private static final Map<Integer, Set<Transport>> transports = Transport.loadAllFromResources();

    private PathfinderConfig pathfinderConfig;

    @Mock
    Client client;

    @Mock
    ItemContainer inventory;

    @Mock
    ShortestPathPlugin plugin;

    @Mock
    ShortestPathConfig config;

    @Before
    public void before() {
        when(config.calculationCutoff()).thenReturn(30);
        when(config.currencyThreshold()).thenReturn(10000000);
    }

    @Test
    public void testAgilityShortcuts() {
        when(config.useAgilityShortcuts()).thenReturn(true);
        setupInventory(
            new Item(ItemID.ROPE, 1),
            new Item(ItemID.DEATH_CLIMBINGBOOTS, 1));
        testTransportLength(2, TransportType.AGILITY_SHORTCUT);
    }

    @Test
    public void testGrappleShortcuts() {
        when(config.useGrappleShortcuts()).thenReturn(true);
        setupInventory(
            new Item(ItemID.XBOWS_CROSSBOW_ADAMANTITE, 1),
            new Item(ItemID.XBOWS_GRAPPLE_TIP_BOLT_MITHRIL_ROPE, 1));
        testTransportLength(2, TransportType.GRAPPLE_SHORTCUT);
    }

    @Test
    public void testBoats() {
        when(config.useBoats()).thenReturn(true);
        setupInventory(
            new Item(ItemID.COINS, 10000),
            new Item(ItemID.ECTOTOKEN, 25));
        testTransportLength(2, TransportType.BOAT);
    }

    @Test
    public void testCanoes() {
        when(config.useCanoes()).thenReturn(true);
        setupInventory(new Item(ItemID.BRONZE_AXE, 1));
        testTransportLength(2, TransportType.CANOE);
    }

    @Test
    public void testCharterShips() {
        when(config.useCharterShips()).thenReturn(true);
        setupInventory(new Item(ItemID.COINS, 100000));
        testTransportLength(2, TransportType.CHARTER_SHIP);
    }

    @Test
    public void testShips() {
        when(config.useShips()).thenReturn(true);
        setupInventory(new Item(ItemID.COINS, 10000));
        testTransportLength(2, TransportType.SHIP);
    }

    @Test
    public void testFairyRings() {
        when(config.useFairyRings()).thenReturn(true);
        setupInventory(new Item(ItemID.DRAMEN_STAFF, 1));
        when(client.getVarbitValue(VarbitID.FAIRY2_QUEENCURE_QUEST)).thenReturn(100);
        testTransportLength(2, TransportType.FAIRY_RING);
    }

    @Test
    public void testGnomeGliders() {
        when(config.useGnomeGliders()).thenReturn(true);
        testTransportLength(2, TransportType.GNOME_GLIDER);
    }

    @Test
    public void testHotAirBalloons() {
        when(config.useHotAirBalloons()).thenReturn(true);
        setupInventory(
            new Item(ItemID.LOGS, 2),
            new Item(ItemID.OAK_LOGS, 1),
            new Item(ItemID.WILLOW_LOGS, 1),
            new Item(ItemID.YEW_LOGS, 1),
            new Item(ItemID.MAGIC_LOGS, 1));
        testTransportLength(2, TransportType.HOT_AIR_BALLOON);
    }

    @Test
    public void testMagicCarpets() {
        when(config.useMagicCarpets()).thenReturn(true);
        setupInventory(
            new Item(ItemID.COINS, 200));
        testTransportLength(2, TransportType.MAGIC_CARPET);
    }

    @Test
    public void testMagicMushtrees() {
        when(config.useMagicMushtrees()).thenReturn(true);
        testTransportLength(2, TransportType.MAGIC_MUSHTREE);
    }

    @Test
    public void testMinecarts() {
        when(config.useMinecarts()).thenReturn(true);
        setupInventory(new Item(ItemID.COINS, 1000));
        testTransportLength(2, TransportType.MINECART);
    }

    @Test
    public void testQuetzals() {
        when(config.useQuetzals()).thenReturn(true);
        testTransportLength(2, TransportType.QUETZAL);
    }

    @Test
    public void testSpiritTrees() {
        when(config.useSpiritTrees()).thenReturn(true);
        when(client.getVarbitValue(any(Integer.class))).thenReturn(20);
        testTransportLength(2, TransportType.SPIRIT_TREE);
    }

    @Test
    public void testTeleportationBoxes() {
        when(config.useTeleportationBoxes()).thenReturn(true);
        testTransportLength(2, TransportType.TELEPORTATION_BOX);
    }

    @Test
    public void testTeleportationLevers() {
        when(config.useTeleportationLevers()).thenReturn(true);
        testTransportLength(2, TransportType.TELEPORTATION_LEVER);
    }

    @Test
    public void testTeleportationMinigames() {
        when(config.useTeleportationMinigames()).thenReturn(true);
        when(config.useTeleportationSpells()).thenReturn(false);
        when(client.getVarbitValue(any(Integer.class))).thenReturn(0);
        when(client.getVarpValue(any(Integer.class))).thenReturn(0);
        testTransportLength(2,
            WorldPointUtil.packWorldPoint(3440, 3334, 0),  // Nature Spirit Grotto
            WorldPointUtil.packWorldPoint(2658, 3157, 0)); // Fishing Trawler
        testTransportLength(3,
            WorldPointUtil.packWorldPoint(3136, 3525, 0),  // In wilderness level 1
            WorldPointUtil.packWorldPoint(2658, 3157, 0)); // Fishing Trawler
    }

    @Test
    public void testTeleportationPortals() {
        when(config.useTeleportationPortals()).thenReturn(true);
        testTransportLength(2, TransportType.TELEPORTATION_PORTAL);
    }

    @Test
    public void testWildernessObelisks() {
        when(config.useWildernessObelisks()).thenReturn(true);
        testTransportLength(2, TransportType.WILDERNESS_OBELISK);
    }

    @Test
    public void testAgilityShortcutAndTeleportItem() {
        when(config.useAgilityShortcuts()).thenReturn(true);
        when(config.useTeleportationItems()).thenReturn(TeleportationItem.ALL);
        // Draynor Manor to Champions Guild via several stepping stones, but
        // enabling Combat bracelet teleport should not prioritize over stepping stones
        // 5 tiles is using the stepping stones
        // ~40 tiles is using the combat bracelet teleport to Champions Guild
        // >100 tiles is walking around the river via Barbarian Village
        testTransportLength(6,
            WorldPointUtil.packWorldPoint(3149, 3363, 0),
            WorldPointUtil.packWorldPoint(3154, 3363, 0));
    }

    @Test
    public void testChronicle() {
        // South of river south of Champions Guild to Chronicle teleport destination
        testTransportLength(2,
            WorldPointUtil.packWorldPoint(3199, 3336, 0),
            WorldPointUtil.packWorldPoint(3200, 3355, 0),
            TeleportationItem.ALL);
    }

    @Test
    public void testVarrockTeleport() {
        // West of Varrock teleport destination to Varrock teleport destination
        when(config.useTeleportationSpells()).thenReturn(true);

        // With magic level 1 and no item requirements
        testTransportLength(4,
            WorldPointUtil.packWorldPoint(3216, 3424, 0),
            WorldPointUtil.packWorldPoint(3213, 3424, 0),
            TeleportationItem.NONE,
            1);

        // With magic level 99 and magic runes
        setupInventory(
            new Item(ItemID.LAWRUNE, 1),
            new Item(ItemID.AIRRUNE, 3),
            new Item(ItemID.FIRERUNE, 1));
        testTransportLength(2,
            WorldPointUtil.packWorldPoint(3216, 3424, 0),
            WorldPointUtil.packWorldPoint(3213, 3424, 0),
            TeleportationItem.INVENTORY,
            99);
    }

    @Test
    public void testCaves() {
        // Eadgar's Cave
        testTransportLength(2,
            WorldPointUtil.packWorldPoint(2892, 3671, 0),
            WorldPointUtil.packWorldPoint(2893, 10074, 2));
        testTransportLength(2,
            WorldPointUtil.packWorldPoint(2893, 3671, 0),
            WorldPointUtil.packWorldPoint(2893, 10074, 2));
        testTransportLength(2,
            WorldPointUtil.packWorldPoint(2894, 3671, 0),
            WorldPointUtil.packWorldPoint(2893, 10074, 2));
        testTransportLength(2,
            WorldPointUtil.packWorldPoint(2895, 3672, 0),
            WorldPointUtil.packWorldPoint(2893, 10074, 2));
        testTransportLength(2,
            WorldPointUtil.packWorldPoint(2892, 10074, 2),
            WorldPointUtil.packWorldPoint(2893, 3671, 0));
        testTransportLength(2,
            WorldPointUtil.packWorldPoint(2893, 10074, 2),
            WorldPointUtil.packWorldPoint(2893, 3671, 0));
        testTransportLength(2,
            WorldPointUtil.packWorldPoint(2894, 10074, 2),
            WorldPointUtil.packWorldPoint(2893, 3671, 0));
    }

    @Test
    public void testPathViaOtherPlane() {
        // Shortest path from east to west Keldagrim is via the first floor
        // of the Keldagrim Palace, and not via the bridge to the north
        testTransportLength(64,
            WorldPointUtil.packWorldPoint(2894, 10199, 0), // east
            WorldPointUtil.packWorldPoint(2864, 10199, 0)); // west

        testTransportLength(64,
            WorldPointUtil.packWorldPoint(2864, 10199, 0), // west
            WorldPointUtil.packWorldPoint(2894, 10199, 0)); // east
    }

    @Test
    public void testImpossibleCharterShips() {
        // Shortest path for impossible charter ships has length 3 and goes
        // via an intermediate charter ship and not directly with length 2
        when(config.useCharterShips()).thenReturn(true);
        setupInventory(new Item(ItemID.COINS, 1000000));

        testTransportMinimumLength(3,
            WorldPointUtil.packWorldPoint(1455, 2968, 0), // Aldarin
            WorldPointUtil.packWorldPoint(1514, 2971, 0)); // Sunset Coast
        testTransportMinimumLength(3,
            WorldPointUtil.packWorldPoint(1514, 2971, 0), // Sunset Coast
            WorldPointUtil.packWorldPoint(1455, 2968, 0)); // Aldarin

        testTransportMinimumLength(3,
            WorldPointUtil.packWorldPoint(3702, 3503, 0), // Port Phasmatys
            WorldPointUtil.packWorldPoint(3671, 2931, 0)); // Mos Le'Harmless
        testTransportMinimumLength(3,
            WorldPointUtil.packWorldPoint(3671, 2931, 0), // Mos Le'Harmless
            WorldPointUtil.packWorldPoint(3702, 3503, 0)); // Port Phasmatys

        testTransportMinimumLength(3,
            WorldPointUtil.packWorldPoint(1808, 3679, 0), // Port Piscarilius
            WorldPointUtil.packWorldPoint(1496, 3403, 0)); // Land's End
        testTransportMinimumLength(3,
            WorldPointUtil.packWorldPoint(1496, 3403, 0), // Land's End
            WorldPointUtil.packWorldPoint(1808, 3679, 0)); // Port Piscarilius

        testTransportMinimumLength(3,
            WorldPointUtil.packWorldPoint(3038, 3192, 0), // Port Sarim
            WorldPointUtil.packWorldPoint(1496, 3403, 0)); // Land's End
        testTransportMinimumLength(3,
            WorldPointUtil.packWorldPoint(1496, 3403, 0), // Land's End
            WorldPointUtil.packWorldPoint(3038, 3192, 0)); // Port Sarim

        testTransportMinimumLength(3,
            WorldPointUtil.packWorldPoint(3038, 3192, 0), // Port Sarim
            WorldPointUtil.packWorldPoint(2954, 3158, 0)); // Musa Point
        testTransportMinimumLength(3,
            WorldPointUtil.packWorldPoint(2954, 3158, 0), // Musa Point
            WorldPointUtil.packWorldPoint(3038, 3192, 0)); // Port Sarim

        testTransportMinimumLength(3,
            WorldPointUtil.packWorldPoint(3038, 3192, 0), // Port Sarim
            WorldPointUtil.packWorldPoint(1808, 3679, 0)); // Port Piscarilius
        testTransportMinimumLength(3,
            WorldPointUtil.packWorldPoint(1808, 3679, 0), // Port Piscarilius
            WorldPointUtil.packWorldPoint(3038, 3192, 0)); // Port Sarim
    }

    @Test
    public void testNumberOfGnomeGliders() {
        // All permutations of gnome glider transports are resolved from origins and destinations
        int actualCount = 0;
        for (int origin : transports.keySet()) {
            for (Transport transport : transports.get(origin)) {
                if (TransportType.GNOME_GLIDER.equals(transport.getType())) {
                    actualCount++;
                }
            }
        }
        /* 
         * Info:
         * NB: Lemanto Andra (Digsite) can only be destination and not origin
         * single_glider_origin_locations * (number_of_gnome_gliders - 1)
         *   1 * 6   // Ta Quir Priw (Gnome Stronghold)
         * + 3 * 6   // Gandius (Karamja)
         * + 3 * 6   // Kar-Hewo (Al-Kharid)
         * + 2 * 6   // Sindarpos (White Wolf Mountain)
         * + 3 * 6   // Lemantolly Undri (Feldip Hills)
         * + 3 * 6   // Ookookolly Undri (Ape Atoll)
         * = 90
         */
        assertEquals(90, actualCount);
    }


    @Test
    public void testTransportItems() {
        // Varrock Teleport
        TransportItems actual = null;
        for (Transport transport : transports.get(Transport.UNDEFINED_ORIGIN)) {
            if ("Varrock Teleport".equals(transport.getDisplayInfo())) {
                actual = transport.getItemRequirements();
                break;
            }
        }
        TransportItems expected = null;
        if (actual != null) {
            expected = new TransportItems(
                new int[][]{
                    ItemVariations.AIR_RUNE.getIds(),
                    ItemVariations.FIRE_RUNE.getIds(),
                    ItemVariations.LAW_RUNE.getIds()},
                new int[][]{
                    ItemVariations.STAFF_OF_AIR.getIds(),
                    ItemVariations.STAFF_OF_FIRE.getIds(), null},
                new int[][]{null, ItemVariations.TOME_OF_FIRE.getIds(), null},
                new int[]{3, 1, 1});
            assertEquals(expected, actual);
        }

        // Trollheim Teleport
        actual = null;
        for (Transport transport : transports.get(Transport.UNDEFINED_ORIGIN)) {
            if ("Trollheim Teleport".equals(transport.getDisplayInfo())) {
                actual = transport.getItemRequirements();
                break;
            }
        }
        expected = null;
        if (actual != null) {
            expected = new TransportItems(
                new int[][]{
                    ItemVariations.FIRE_RUNE.getIds(),
                    ItemVariations.LAW_RUNE.getIds()},
                new int[][]{
                    ItemVariations.STAFF_OF_FIRE.getIds(),
                    null},
                new int[][]{
                    ItemVariations.TOME_OF_FIRE.getIds(),
                    null},
                new int[]{2, 2});
            assertEquals(expected, actual);
        }
    }

    @Test
    public void testIsInWilderness() {
        assertEquals(true, PathfinderConfig.isInWilderness(
            WorldPointUtil.packWorldPoint(3339, 3696, 0))); // Green dragons
        assertEquals(false, PathfinderConfig.isInWilderness(
            WorldPointUtil.packWorldPoint(3134, 3629, 0))); // Ferox Enclave
        assertEquals(true, PathfinderConfig.isInWilderness(
            WorldPointUtil.packWorldPoint(3089, 9957, 0))); // Edgeville Dungeon
        assertEquals(true, PathfinderConfig.isInWilderness(
            WorldPointUtil.packWorldPoint(3039, 10260, 0))); // Lava Maze Dungeon
        assertEquals(false, PathfinderConfig.isInWilderness(
            WorldPointUtil.packWorldPoint(3009, 3531, 0))); // Non-wildy peninsula
        assertEquals(true, PathfinderConfig.isInWilderness(
            WorldPointUtil.packWorldPoint(3023, 3626, 1))); // Upstairs in Dark Warriors' Fortress
    }

    private void setupConfig(QuestState questState, int skillLevel, TeleportationItem useTeleportationItems) {
        pathfinderConfig = spy(new PathfinderConfig(client, config));

        when(client.getGameState()).thenReturn(GameState.LOGGED_IN);
        when(client.getClientThread()).thenReturn(Thread.currentThread());
        when(client.getBoostedSkillLevel(any(Skill.class))).thenReturn(skillLevel);
        when(config.useTeleportationItems()).thenReturn(useTeleportationItems);
        doReturn(true).when(pathfinderConfig).varbitChecks(any(Transport.class));
        doReturn(true).when(pathfinderConfig).varPlayerChecks(any(Transport.class));
        doReturn(questState).when(pathfinderConfig).getQuestState(any(Quest.class));

        pathfinderConfig.refresh();
    }

    private void setupInventory(Item... items) {
        doReturn(inventory).when(client).getItemContainer(InventoryID.INVENTORY);
        doReturn(items).when(inventory).getItems();
    }

    private void testTransportLength(int expectedLength, int origin, int destination) {
        testTransportLength(expectedLength, origin, destination, TeleportationItem.NONE, 99);
    }

    private void testTransportLength(int expectedLength, int origin, int destination,
        TeleportationItem useTeleportationItems) {
        testTransportLength(expectedLength, origin, destination, useTeleportationItems, 99);
    }

    private void testTransportLength(int expectedLength, int origin, int destination,
        TeleportationItem useTeleportationItems, int skillLevel) {
        setupConfig(QuestState.FINISHED, skillLevel, useTeleportationItems);
        assertEquals(expectedLength, calculatePathLength(origin, destination));
        System.out.println("Successfully completed transport length test from " +
            "(" + WorldPointUtil.unpackWorldX(origin) +
            ", " + WorldPointUtil.unpackWorldY(origin) +
            ", " + WorldPointUtil.unpackWorldPlane(origin) + ") to " +
            "(" + WorldPointUtil.unpackWorldX(destination) +
            ", " + WorldPointUtil.unpackWorldY(destination) +
            ", " + WorldPointUtil.unpackWorldPlane(destination) + ")");
    }

    private void testTransportLength(int expectedLength, TransportType transportType) {
        testTransportLength(expectedLength, transportType, QuestState.FINISHED, 99, TeleportationItem.NONE);
    }

    private void testTransportLength(int expectedLength, TransportType transportType, QuestState questState, int skillLevel,
        TeleportationItem useTeleportationItems) {
        setupConfig(questState, skillLevel, useTeleportationItems);

        int counter = 0;
        for (int origin : transports.keySet()) {
            for (Transport transport : transports.get(origin)) {
                if (transportType.equals(transport.getType())) {
                    counter++;
                    assertEquals(transport.toString(), expectedLength, calculateTransportLength(transport));
                }
            }
        }

        assertTrue("No tests were performed", counter > 0);
        System.out.println(String.format("Successfully completed %d " + transportType + " transport length tests", counter));
    }

    private void testTransportMinimumLength(int minimumLength, int origin, int destination) {
        setupConfig(QuestState.FINISHED, 99, TeleportationItem.ALL);
        int actualLength = calculatePathLength(origin, destination);
        assertTrue("An impossible transport was used with length " + actualLength, actualLength >= minimumLength);
        System.out.println("Successfully completed transport length test from " +
            "(" + WorldPointUtil.unpackWorldX(origin) +
            ", " + WorldPointUtil.unpackWorldY(origin) +
            ", " + WorldPointUtil.unpackWorldPlane(origin) + ") to " +
            "(" + WorldPointUtil.unpackWorldX(destination) +
            ", " + WorldPointUtil.unpackWorldY(destination) +
            ", " + WorldPointUtil.unpackWorldPlane(destination) + ")" +
            " with actual length = " + actualLength + " >= minimum length = " + minimumLength);
    }

    private int calculateTransportLength(Transport transport) {
        return calculatePathLength(transport.getOrigin(), transport.getDestination());
    }

    private int calculatePathLength(int origin, int destination) {
        Pathfinder pathfinder = new Pathfinder(plugin, pathfinderConfig, origin, Set.of(destination));
        pathfinder.run();
        return pathfinder.getPath().size();
    }
}

package shortestpath;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ShortestPathPluginTest {
    public static void main(String[] args) throws Exception {
        ExternalPluginManager.loadBuiltin(ShortestPathPlugin.class);
        RuneLite.main(args);
    }
}

package shortestpath;

import org.junit.Test;
import org.junit.Assert;

import java.io.ByteArrayInputStream;
import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Random;

/**
 * Unit tests for {@link Util} helper methods.
 */
public class UtilTest {

    // --- readAllBytes -----------------------------------------------------

    @Test
    public void readAllBytesEmptyStream() throws IOException {
        byte[] data = Util.readAllBytes(new ByteArrayInputStream(new byte[0]));
        Assert.assertNotNull(data);
        Assert.assertEquals(0, data.length);
    }

    @Test
    public void readAllBytesSmall() throws IOException {
        byte[] expected = {1,2,3,4,5};
        byte[] data = Util.readAllBytes(new ByteArrayInputStream(expected));
        Assert.assertArrayEquals(expected, data);
    }

    @Test
    public void readAllBytesLargerThanBuffer() throws IOException {
        // Create data larger than the internal 1024 byte buffer to exercise loop logic
        byte[] expected = new byte[4096];
        for (int i = 0; i < expected.length; i++) {
            expected[i] = (byte)(i * 31); // deterministic pattern
        }
        byte[] data = Util.readAllBytes(new ByteArrayInputStream(expected));
        Assert.assertArrayEquals(expected, data);
    }

    @Test(expected = IOException.class)
    public void readAllBytesPropagatesIOException() throws IOException {
        // InputStream that throws after first read
        InputStream failing = new FilterInputStream(new ByteArrayInputStream(new byte[]{1,2,3})) {
            private boolean first = true;
            @Override
            public int read(byte[] b, int off, int len) throws IOException {
                if (first) {
                    first = false;
                    return super.read(b, off, len);
                }
                throw new IOException("boom");
            }
        };
        // Should throw on second read attempt
        Util.readAllBytes(failing);
    }

    // --- concatenate ------------------------------------------------------

    @Test
    public void concatenateAllNullOrEmptyReturnsNull() {
        Assert.assertNull(Util.concatenate(new int[][]{null, new int[0], null}));
    }

    @Test
    public void concatenateSingleArrayIdentity() {
        int[] a = {1,2,3};
        Assert.assertArrayEquals(a, Util.concatenate(new int[][]{a}));
    }

    @Test
    public void concatenateSkipsNulls() {
        int[] a = {1,2};
        int[] b = null;
        int[] c = {3};
        int[] result = Util.concatenate(new int[][]{a,b,c});
        Assert.assertArrayEquals(new int[]{1,2,3}, result);
    }

    @Test
    public void concatenateMultiple() {
        int[] a = {1};
        int[] b = {2,3};
        int[] c = {4,5,6};
        int[] result = Util.concatenate(new int[][]{a,b,c});
        Assert.assertArrayEquals(new int[]{1,2,3,4,5,6}, result);
    }

    @Test
    public void concatenateLarge() {
        // Use random sizes to stress size accumulation & copy loop
        Random rnd = new Random(123);
        int[][] arrays = new int[50][];
        int total = 0;
        for (int i = 0; i < arrays.length; i++) {
            int len = rnd.nextInt(10); // small to keep test fast
            if (len == 0) {
                arrays[i] = new int[0];
            } else {
                arrays[i] = new int[len];
                for (int j = 0; j < len; j++) arrays[i][j] = i * 100 + j;
                total += len;
            }
        }
        int[] combined = Util.concatenate(arrays);
        if (total == 0) {
            Assert.assertNull(combined);
        } else {
            int count = 0;
            for (int i = 0; i < arrays.length; i++) {
                int[] arr = arrays[i];
                if (arr == null) continue;
                for (int v : arr) {
                    Assert.assertEquals(v, combined[count++]);
                }
            }
            Assert.assertEquals(total, combined.length);
        }
    }
}

package shortestpath;

import org.junit.Assert;
import org.junit.Test;

public class PrimitiveIntListTests {
    @Test
    public void tryAddAndGet() {
        PrimitiveIntList intList = new PrimitiveIntList();
        intList.add(10);
        intList.add(11);
        Assert.assertEquals(2, intList.size());
        Assert.assertEquals(10, intList.get(0));
        Assert.assertEquals(11, intList.get(1));
    }

    @Test
    public void tryGrow() {
        PrimitiveIntList intList = new PrimitiveIntList(4);
        intList.add(10);
        intList.add(11);
        intList.add(12);
        intList.add(13);
        intList.add(14);
        Assert.assertEquals(5, intList.size());
        int sum = 0;
        for (int i = 0; i < intList.size(); i++) {
            sum += intList.get(i);
        }
        Assert.assertEquals(10 + 11 + 12 + 13 + 14, sum);
    }

    @Test
    public void tryInitialize() {
        PrimitiveIntList intList = new PrimitiveIntList(3, true);
        Assert.assertEquals(3, intList.size());
        Assert.assertEquals(0, intList.get(0));
        Assert.assertEquals(0, intList.get(1));
        Assert.assertEquals(0, intList.get(2));
        intList.set(0, 10);
        intList.set(1, 11);
        intList.set(2, 12);
        Assert.assertEquals(10, intList.get(0));
        Assert.assertEquals(11, intList.get(1));
        Assert.assertEquals(12, intList.get(2));
    }

    @Test
    public void tryIterate() {
        int sum = 0;
        PrimitiveIntList intList = new PrimitiveIntList();
        intList.add(10);
        intList.add(11);
        for (int i = 0; i < intList.size(); i++) {
            sum += intList.get(i);
        }
        Assert.assertEquals(10 + 11, sum);
    }

    @Test
    public void tryRemove() {
        PrimitiveIntList intList = new PrimitiveIntList();
        intList.add(10);
        intList.add(11);
        Assert.assertEquals(2, intList.size());
        Assert.assertEquals(10, intList.removeAt(0));
        Assert.assertEquals(true, intList.remove(11));
        Assert.assertEquals(true, intList.isEmpty());
    }

    @Test
    public void defaultConstructor() {
        PrimitiveIntList intList = new PrimitiveIntList();
        Assert.assertEquals(0, intList.size());
        Assert.assertTrue(intList.isEmpty());
    }

    @Test
    public void capacityOnlyConstructor() {
        PrimitiveIntList intList = new PrimitiveIntList(5);
        // The list is not initialized so the size is 0
        Assert.assertEquals(0, intList.size());
        Assert.assertTrue(intList.isEmpty());
        intList.add(42);
        Assert.assertEquals(1, intList.size());
        Assert.assertEquals(42, intList.get(0));
    }

    @Test(expected = IllegalArgumentException.class)
    public void negativeCapacityConstructor() {
        new PrimitiveIntList(-1);
    }

    @Test
    public void zeroCapacityConstructor() {
        PrimitiveIntList intList = new PrimitiveIntList(0);
        Assert.assertEquals(0, intList.size());
        Assert.assertTrue(intList.isEmpty());
    }
    
    @Test
    public void addAtIndex() {
        PrimitiveIntList intList = new PrimitiveIntList();
        intList.add(1);
        intList.add(2);
        intList.add(1, 99); // insert in middle
        Assert.assertEquals(3, intList.size());
        Assert.assertEquals(1, intList.get(0));
        Assert.assertEquals(99, intList.get(1));
        Assert.assertEquals(2, intList.get(2));
        intList.add(3, 100); // insert at end (index == size before add)
        Assert.assertEquals(4, intList.size());
        Assert.assertEquals(100, intList.get(3));
    }

    @Test(expected = IndexOutOfBoundsException.class)
    public void addAtIndexOutOfBoundsHigh() {
        PrimitiveIntList intList = new PrimitiveIntList();
        intList.add(1, 5);
    }

    @Test(expected = IndexOutOfBoundsException.class)
    public void addAtIndexOutOfBoundsNegative() {
        PrimitiveIntList intList = new PrimitiveIntList();
        intList.add(-1, 5);
    }

    @Test
    public void setReturnsOldValue() {
        PrimitiveIntList intList = new PrimitiveIntList();
        intList.add(10);
        int old = intList.set(0, 20);
        Assert.assertEquals(10, old);
        Assert.assertEquals(20, intList.get(0));
    }

    @Test
    public void containsAndIndexOf() {
        PrimitiveIntList intList = new PrimitiveIntList();
        intList.add(5);
        intList.add(6);
        intList.add(7);
        Assert.assertTrue(intList.contains(6));
        Assert.assertEquals(1, intList.indexOf(6));
        Assert.assertFalse(intList.contains(8));
        Assert.assertEquals(-1, intList.indexOf(8));
    }

    @Test
    public void removeNotPresent() {
        PrimitiveIntList intList = new PrimitiveIntList();
        intList.add(1);
        Assert.assertFalse(intList.remove(2));
        Assert.assertEquals(1, intList.size());
    }

    @Test
    public void clearEmptiesList() {
        PrimitiveIntList intList = new PrimitiveIntList();
        intList.add(1);
        intList.add(2);
        intList.clear();
        Assert.assertEquals(0, intList.size());
        Assert.assertTrue(intList.isEmpty());
        intList.add(3); // ensure list still usable
        Assert.assertEquals(1, intList.size());
        Assert.assertEquals(3, intList.get(0));
    }

    @Test(expected = IndexOutOfBoundsException.class)
    public void getOutOfBounds() {
        PrimitiveIntList intList = new PrimitiveIntList();
        intList.add(1);
        intList.get(1); // size == 1 so index 1 invalid
    }

    @Test(expected = IndexOutOfBoundsException.class)
    public void setOutOfBounds() {
        PrimitiveIntList intList = new PrimitiveIntList();
        intList.add(1);
        intList.set(1, 2);
    }

    @Test(expected = IndexOutOfBoundsException.class)
    public void removeAtOutOfBounds() {
        PrimitiveIntList intList = new PrimitiveIntList();
        intList.add(1);
        intList.removeAt(1);
    }

    @Test
    public void ensureCapacityNoOpAndGrowth() {
        PrimitiveIntList intList = new PrimitiveIntList();
        // ensureCapacity(0) should be a no-op and size unchanged
        intList.ensureCapacity(0);
        Assert.assertEquals(0, intList.size());

        // Pre-grow to capacity for 500 elements
        intList.ensureCapacity(500);
        // Add 500 elements and assert size; this should work without errors
        for (int i = 0; i < 500; i++) {
            intList.add(i);
        }
        Assert.assertEquals(500, intList.size());
        // Spot check a few values
        Assert.assertEquals(0, intList.get(0));
        Assert.assertEquals(123, intList.get(123));
        Assert.assertEquals(499, intList.get(499));
    }

    @Test
    public void ensureCapacityIdempotentForSmaller() {
        PrimitiveIntList intList = new PrimitiveIntList(4);
        intList.add(1);
        intList.add(2);
        intList.ensureCapacity(2); // already at least 2; should not affect size
        Assert.assertEquals(2, intList.size());
        Assert.assertEquals(1, intList.get(0));
        Assert.assertEquals(2, intList.get(1));
    }
}

package shortestpath;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import org.junit.Assert;
import org.junit.Test;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

public class PrimitiveIntHashMapTests {
    @Test(expected=IllegalArgumentException.class)
    public void checkNullValueProhibited() {
        PrimitiveIntHashMap<Boolean> map = new PrimitiveIntHashMap<>(8);
        map.put(0, null);
    }

    @Test
    public void tryInsertTransports() {
        HashMap<Integer, Set<Transport>> transports = Transport.loadAllFromResources();
        PrimitiveIntHashMap<Set<Transport>> map = new PrimitiveIntHashMap<>(transports.size());

        for (Map.Entry<Integer, Set<Transport>> entry : transports.entrySet()) {
            int packedPoint = entry.getKey();
            map.put(packedPoint, entry.getValue());
        }

        // Append empty set
        for (Map.Entry<Integer, Set<Transport>> entry : transports.entrySet()) {
            int packedPoint = entry.getKey();
            map.put(packedPoint, entry.getValue());
            Assert.assertEquals("Appending empty should not overwrite", map.put(packedPoint, new HashSet<>()), map.get(packedPoint));
        }

        // Append non-empty set
        for (Map.Entry<Integer, Set<Transport>> entry : transports.entrySet()) {
            int packedPoint = entry.getKey();
            map.put(packedPoint, entry.getValue());
            int sizeBefore = map.get(packedPoint).size();
            Set<Transport> nonEmpty = new HashSet<>();
            nonEmpty.add(null);
            map.put(packedPoint, nonEmpty);
            int sizeAfter = map.get(packedPoint).size();
            Assert.assertEquals("Appending non-empty should not overwrite", sizeBefore + 1, sizeAfter);
        }

        for (Map.Entry<Integer, Set<Transport>> entry : transports.entrySet()) {
            int packedPoint = entry.getKey();
            Assert.assertEquals("World Point " + entry.getKey() + " did not map to the correct value", entry.getValue(), map.get(packedPoint));
        }
    }

    @Test
    public void tryGrowMap() {
        PrimitiveIntHashMap<Integer> map = new PrimitiveIntHashMap<>(8);
        for (int i = 0; i < 1024; ++i) {
            map.put(i, i);
        }

        Assert.assertEquals(1024, map.size());

        for (int i = 0; i < 1024; ++i) {
            Assert.assertEquals(i, map.get(i).intValue());
        }
    }

    @Test
    public void checkNonexistentEntries() {
        PrimitiveIntHashMap<Integer> map = new PrimitiveIntHashMap<>(8);
        Assert.assertNull(map.get(667215));
    }

    @Test
    public void tryOverwriteValues() {
        final int keyStart = 9875643; // Use keys that aren't 0 or all low bits

        PrimitiveIntHashMap<Integer> map = new PrimitiveIntHashMap<>(2048);
        for (int i = 0; i < 1024; ++i) {
            map.put(i + keyStart, i);
        }

        // Overwrite values
        for (int i = 0; i < 1024; ++i) {
            map.put(i + keyStart, i + 1);
        }

        // Now check overwritten values stuck
        for (int i = 0; i < 1024; ++i) {
            Assert.assertEquals(i + 1, map.get(i + keyStart).intValue());
        }
    }

    @Test
    public void checkClearMap() {
        PrimitiveIntHashMap<Integer> map = new PrimitiveIntHashMap<>(8);
        for (int i = 0; i < 1024; ++i) {
            map.put(i, i);
        }

        Assert.assertEquals(1024, map.size());
        Assert.assertEquals(364, map.get(364).intValue());

        map.clear();
        Assert.assertEquals(0, map.size());
        Assert.assertNull(map.get(364));
    }

    @Test
    public void checkInsertOrderIrrelevant() {
        final int keyStart = 9875643; // Use keys that aren't 0 or all low bits
        PrimitiveIntHashMap<Integer> mapForward = new PrimitiveIntHashMap<>(8);
        PrimitiveIntHashMap<Integer> mapReversed = new PrimitiveIntHashMap<>(8);
        for (int i = 0; i < 1024; ++i) {
            mapForward.put(i + keyStart, i);
            mapReversed.put(1023 - i + keyStart, 1023 - i);
        }

        for (int i = 0; i < 1024; ++i) {
            Assert.assertEquals(mapForward.get(i + keyStart), mapReversed.get(i + keyStart));
        }
    }

    // Copy of the map's private hash to synthesize collisions in tests
    private static int testHash(int value) {
        return value ^ (value >>> 5) ^ (value >>> 25);
    }

    @Test
    public void sizeAndBasicPutGet() {
        PrimitiveIntHashMap<String> map = new PrimitiveIntHashMap<>(8);
        assertEquals(0, map.size());
        assertNull(map.get(42));

        assertNull(map.put(1, "a"));
        assertNull(map.put(2, "b"));
        assertEquals(2, map.size());
        assertEquals("a", map.get(1));
        assertEquals("b", map.get(2));

        // overwrite existing non-collection
        String prev = map.put(1, "a2");
        assertEquals("a", prev);
        assertEquals("a2", map.get(1));
        assertEquals(2, map.size()); // size unchanged on replace
    }

    @Test
    public void getOrDefaultWorks() {
        PrimitiveIntHashMap<Integer> map = new PrimitiveIntHashMap<>(4);
        assertEquals(Integer.valueOf(99), map.getOrDefault(123, 99));
        map.put(123, 7);
        assertEquals(Integer.valueOf(7), map.getOrDefault(123, 99));
    }

    @Test(expected = IllegalArgumentException.class)
    public void putNullDisallowed() {
        PrimitiveIntHashMap<String> map = new PrimitiveIntHashMap<>(4);
        map.put(5, null);
    }

    @Test
    public void negativeKeysSupported() {
        PrimitiveIntHashMap<String> map = new PrimitiveIntHashMap<>(4);
        map.put(-1, "neg1");
        map.put(Integer.MIN_VALUE, "min");
        assertEquals("neg1", map.get(-1));
        assertEquals("min", map.get(Integer.MIN_VALUE));
    }

    @Test
    public void clearResetsState() {
        PrimitiveIntHashMap<String> map = new PrimitiveIntHashMap<>(16);
        for (int i = 0; i < 10; i++) {
            map.put(i, "v" + i);
        }
        assertTrue(map.size() > 0);
        map.clear();
        assertEquals(0, map.size());
        for (int i = 0; i < 10; i++) {
            assertNull(map.get(i));
        }
    }

    @Test
    public void collectionValuesAppendOnDuplicateKey() {
        PrimitiveIntHashMap<List<Integer>> map = new PrimitiveIntHashMap<>(8);
        List<Integer> a = new ArrayList<>(Arrays.asList(1, 2));
        List<Integer> b = new ArrayList<>(Arrays.asList(3, 4, 5));

        assertNull(map.put(7, a));
        List<Integer> prev = map.put(7, b);

        // Returned value is the previous instance and it has been mutated by addAll
        assertSame(a, prev);
        assertSame(a, map.get(7));
        assertEquals(Arrays.asList(1, 2, 3, 4, 5), map.get(7));
        assertEquals(1, map.size());
    }

    @Test
    public void rehashPreservesEntries() {
        // Use default load factor so rehashes will happen as size grows
        PrimitiveIntHashMap<String> map = new PrimitiveIntHashMap<>(8);

        int n = 10_000;
        for (int i = 0; i < n; i++) {
            map.put(i, "v" + i);
        }
        assertEquals(n, map.size());

        // verify random subset
        Random rnd = new Random(123);
        for (int i = 0; i < 2000; i++) {
            int k = rnd.nextInt(n);
            assertEquals("v" + k, map.get(k));
        }
    }

    @Test
    public void heavyCollisionsGrowBucketWithoutRehash() {
        // With loadFactor=1.0 and initial size < MINIMUM_SIZE, maxSize becomes 8 and
        // capacity is 8.
        // We'll place 6 entries into the SAME bucket so the internal bucket needs to
        // grow beyond DEFAULT_BUCKET_SIZE (4)
        PrimitiveIntHashMap<String> map = new PrimitiveIntHashMap<>(1, 1.0f);
        int mask = 8 - 1; // maxSize for initial map (given MINIMUM_SIZE=8)

        int targetBucket = 0; // any bucket works; pick 0
        List<Integer> collidingKeys = new ArrayList<>();
        for (int k = 0; collidingKeys.size() < 6 && k < 100_000; k++) {
            int bucket = (testHash(k) & 0x7FFFFFFF) & mask;
            if (bucket == targetBucket)
                collidingKeys.add(k);
        }
        assertEquals(6, collidingKeys.size());

        int i = 0;
        for (int key : collidingKeys) {
            assertNull(map.put(key, "v" + (i++)));
        }
        assertEquals(6, map.size());
        for (int idx = 0; idx < collidingKeys.size(); idx++) {
            int key = collidingKeys.get(idx);
            assertEquals("v" + idx, map.get(key));
        }
    }

    @Test
    public void calculateFullnessWithinBounds() {
        PrimitiveIntHashMap<Integer> map = new PrimitiveIntHashMap<>(8);
        double f0 = map.calculateFullness();
        assertTrue("empty map fullness should be NaN", Double.isNaN(f0));

        for (int i = 0; i < 100; i++)
            map.put(i, i);
        double f1 = map.calculateFullness();
        assertTrue("fullness in [0,100]", f1 >= 0.0 && f1 <= 100.0);
    }

    @Test
    public void constructorRejectsInvalidLoadFactor() {
        try {
            new PrimitiveIntHashMap<>(8, -0.1f);
            fail("Expected IllegalArgumentException");
        } catch (IllegalArgumentException expected) {
        }

        try {
            new PrimitiveIntHashMap<>(8, 1.1f);
            fail("Expected IllegalArgumentException");
        } catch (IllegalArgumentException expected) {
        }

        // Edge values allowed
        new PrimitiveIntHashMap<>(8, 0.0f);
        new PrimitiveIntHashMap<>(8, 1.0f);
    }

    @Test
    public void replacingDoesNotIncreaseSize() {
        PrimitiveIntHashMap<String> map = new PrimitiveIntHashMap<>(8);
        assertNull(map.put(10, "a"));
        int s1 = map.size();
        String prev = map.put(10, "b");
        assertEquals("a", prev);
        assertEquals(s1, map.size());
        assertEquals("b", map.get(10));
    }

    @Test
    public void manyRandomInsertionsAndLookups() {
        PrimitiveIntHashMap<Integer> map = new PrimitiveIntHashMap<>(32);
        Random rnd = new Random(42);
        Set<Integer> keys = new HashSet<>();

        for (int i = 0; i < 50_000; i++) {
            int k = rnd.nextInt();
            // avoid null values
            int v = i;
            Integer prev = map.put(k, v);
            if (!keys.add(k)) {
                // replacement path: previous value must be non-null
                assertNotNull(prev);
            }
            assertEquals(Integer.valueOf(v), map.get(k));
        }

        assertEquals(keys.size(), map.size());

        // sample lookups
        int checked = 0;
        for (int k : keys) {
            assertNotNull(map.get(k));
            if (++checked > 2000)
                break;
        }
    }

    @Test
    public void zeroLoadFactorCreatesMinimumCapacity() {
        PrimitiveIntHashMap<String> map = new PrimitiveIntHashMap<>(4, 0.0f);
        // With loadFactor 0.0, capacity should be 0, but map should still be usable
        assertNull(map.put(1, "test"));
        assertEquals("test", map.get(1));
        assertEquals(1, map.size());
    }

    @Test
    public void emptyCollectionAppending() {
        PrimitiveIntHashMap<List<Integer>> map = new PrimitiveIntHashMap<>(8);
        List<Integer> originalList = new ArrayList<>(Arrays.asList(1, 2, 3));
        List<Integer> emptyList = new ArrayList<>();

        map.put(10, originalList);
        List<Integer> prev = map.put(10, emptyList);

        // Original list should be returned and remain unchanged since empty list adds
        // nothing
        assertSame(originalList, prev);
        assertSame(originalList, map.get(10));
        assertEquals(Arrays.asList(1, 2, 3), map.get(10));
    }

    @Test
    public void mixedCollectionAndNonCollectionReplace() {
        PrimitiveIntHashMap<Object> map = new PrimitiveIntHashMap<>(8);
        List<Integer> list = new ArrayList<>(Arrays.asList(1, 2));

        // Start with non-collection value
        map.put(5, "string");

        // Replace with collection - should replace, not append
        Object prev = map.put(5, list);
        assertEquals("string", prev);
        assertSame(list, map.get(5));

        // Replace collection with non-collection - should replace, not append
        prev = map.put(5, "another string");
        assertSame(list, prev);
        assertEquals("another string", map.get(5));
    }

    @Test
    public void calculateFullnessEdgeCases() {
        // Test with completely empty map
        PrimitiveIntHashMap<Integer> map = new PrimitiveIntHashMap<>(8);
        assertTrue("Empty map fullness should be NaN", Double.isNaN(map.calculateFullness()));

        // Test with single element
        map.put(1, 1);
        double fullness = map.calculateFullness();
        assertTrue("Single element fullness should be valid", fullness >= 0.0 && fullness <= 100.0);

        // Test with all buckets having exactly one element
        map.clear();
        // Fill exactly one slot in each bucket if possible
        for (int i = 0; i < 8; i++) {
            map.put(i * 1000, i); // Use keys that likely hash to different buckets
        }
        fullness = map.calculateFullness();
        assertTrue("Evenly distributed fullness should be valid", fullness >= 0.0 && fullness <= 100.0);
    }

    @Test
    public void integerOverflowKeys() {
        PrimitiveIntHashMap<String> map = new PrimitiveIntHashMap<>(16);

        // Test keys near integer overflow boundaries
        map.put(Integer.MAX_VALUE, "max");
        map.put(Integer.MAX_VALUE - 1, "max-1");
        map.put(Integer.MIN_VALUE, "min");
        map.put(Integer.MIN_VALUE + 1, "min+1");
        map.put(0, "zero");
        map.put(-1, "neg-one");

        assertEquals("max", map.get(Integer.MAX_VALUE));
        assertEquals("max-1", map.get(Integer.MAX_VALUE - 1));
        assertEquals("min", map.get(Integer.MIN_VALUE));
        assertEquals("min+1", map.get(Integer.MIN_VALUE + 1));
        assertEquals("zero", map.get(0));
        assertEquals("neg-one", map.get(-1));
        assertEquals(6, map.size());
    }

    @Test
    public void extremeCollisionScenario() {
        // Force many collisions by using a small initial size and load factor 1.0
        PrimitiveIntHashMap<String> map = new PrimitiveIntHashMap<>(2, 1.0f);

        // Add many items that will definitely cause collisions and bucket growth
        for (int i = 0; i < 100; i++) {
            map.put(i, "value" + i);
        }

        // Verify all values are still accessible
        for (int i = 0; i < 100; i++) {
            assertEquals("value" + i, map.get(i));
        }
        assertEquals(100, map.size());
    }

    @Test
    public void largeCollectionAppending() {
        PrimitiveIntHashMap<List<Integer>> map = new PrimitiveIntHashMap<>(8);
        List<Integer> list1 = new ArrayList<>();
        for (int i = 0; i < 10000; i++) {
            list1.add(i);
        }

        List<Integer> list2 = new ArrayList<>();
        for (int i = 10000; i < 20000; i++) {
            list2.add(i);
        }

        map.put(1, list1);
        List<Integer> prev = map.put(1, list2);

        assertSame(list1, prev);
        assertSame(list1, map.get(1));
        assertEquals(20000, map.get(1).size());
        assertEquals(Integer.valueOf(0), map.get(1).get(0));
        assertEquals(Integer.valueOf(19999), map.get(1).get(19999));
    }

    @Test
    public void rehashDuringCollectionAppend() {
        // Create a map that will trigger rehash when a specific key is added
        PrimitiveIntHashMap<List<Integer>> map = new PrimitiveIntHashMap<>(4, 0.75f);

        // Add items until we're close to the rehash threshold
        map.put(1, new ArrayList<>(Arrays.asList(1)));
        map.put(2, new ArrayList<>(Arrays.asList(2)));

        // This should trigger a rehash when the collection is appended
        List<Integer> appendList = new ArrayList<>(Arrays.asList(100, 200));
        List<Integer> prev = map.put(1, appendList);

        assertNotNull(prev);
        assertEquals(Arrays.asList(1, 100, 200), map.get(1));
        assertEquals(Arrays.asList(2), map.get(2));
        assertEquals(2, map.size());
    }

    @Test
    public void sameKeyDifferentHashBehavior() {
        PrimitiveIntHashMap<String> map = new PrimitiveIntHashMap<>(8);

        // Test that same key always returns same value regardless of hash collisions
        map.put(42, "first");
        assertEquals("first", map.get(42));

        String prev = map.put(42, "second");
        assertEquals("first", prev);
        assertEquals("second", map.get(42));
        assertEquals(1, map.size()); // Size should not change
    }

    @Test
    public void clearAfterComplexOperations() {
        PrimitiveIntHashMap<List<String>> map = new PrimitiveIntHashMap<>(4);

        // Perform complex operations that cause growth and collection appending
        for (int i = 0; i < 50; i++) {
            List<String> list = new ArrayList<>(Arrays.asList("item" + i));
            map.put(i % 10, list); // This will cause appending for repeated keys
        }

        assertTrue(map.size() > 0);
        double fullness = map.calculateFullness();
        assertTrue(!Double.isNaN(fullness));

        // Clear should reset everything
        map.clear();
        assertEquals(0, map.size());
        assertTrue(Double.isNaN(map.calculateFullness()));

        // Should be able to use normally after clear
        map.put(1, new ArrayList<>(Arrays.asList("after clear")));
        assertEquals(1, map.size());
        assertEquals(Arrays.asList("after clear"), map.get(1));
    }

    @Test
    public void incompatibleCollectionTypes() {
        PrimitiveIntHashMap<Object> map = new PrimitiveIntHashMap<>(8);

        // Put a list of strings
        List<String> stringList = new ArrayList<>(Arrays.asList("hello", "world"));
        map.put(10, stringList);

        // Try to append a list of integers - this should handle the ClassCastException
        // gracefully
        List<Integer> intList = new ArrayList<>(Arrays.asList(1, 2, 3));
        try {
            Object prev = map.put(10, intList);
            // If we get here, the implementation should have handled the type mismatch
            assertSame(stringList, prev);
        } catch (ClassCastException e) {
            // This is also acceptable behavior - the implementation throws when types don't
            // match
            // In this case, verify the original value is still there
            assertSame(stringList, map.get(10));
        }
    }

    @Test
    public void bucketGrowthIntegerOverflow() {
        PrimitiveIntHashMap<String> map = new PrimitiveIntHashMap<>(8);

        // This test ensures that bucket growth doesn't cause integer overflow
        // We can't easily test the actual overflow case, but we can test large bucket
        // growth
        for (int i = 0; i < 1000; i++) {
            map.put(i, "value" + i);
        }

        // Verify all values are still accessible after many bucket growth operations
        for (int i = 0; i < 1000; i++) {
            assertEquals("value" + i, map.get(i));
        }
        assertEquals(1000, map.size());
    }

    @Test
    public void constructorHandlesNegativeInitialSize() {
        PrimitiveIntHashMap<String> map = new PrimitiveIntHashMap<>(-5);
        assertNull(map.get(1));
        map.put(1, "a");
        map.put(2, "b");
        assertEquals("a", map.get(1));
        assertEquals("b", map.get(2));
        assertEquals(2, map.size());
    }

    @Test
    public void appendToUnmodifiableCollectionReplaces() {
        PrimitiveIntHashMap<List<String>> map = new PrimitiveIntHashMap<>(8);
        List<String> fixed = Arrays.asList("x", "y"); // fixed-size list => addAll throws UnsupportedOperationException
        List<String> replacement = new ArrayList<>(Arrays.asList("a", "b", "c"));

        assertNull(map.put(42, fixed));
        List<String> prev = map.put(42, replacement);

        // Should have replaced rather than appended due to
        // UnsupportedOperationException
        assertSame(fixed, prev);
        assertSame(replacement, map.get(42));
        assertEquals(Arrays.asList("a", "b", "c"), map.get(42));
        assertEquals(1, map.size());
    }

    @Test
    public void getOrDefaultAllowsNullDefault() {
        PrimitiveIntHashMap<Integer> map = new PrimitiveIntHashMap<>(8);
        assertNull(map.getOrDefault(999, null));
        map.put(999, 123);
        assertEquals(Integer.valueOf(123), map.getOrDefault(999, null));
    }

    @Test
    public void selfCollectionAppendDuplicatesSafely() {
        PrimitiveIntHashMap<List<Integer>> map = new PrimitiveIntHashMap<>(8);
        List<Integer> list = new ArrayList<>(Arrays.asList(1, 2));
        map.put(7, list);
        // Appending the same instance to itself should not crash and should duplicate
        // elements
        List<Integer> prev = map.put(7, list);
        assertSame(list, prev);
        assertSame(list, map.get(7));
        assertEquals(4, map.get(7).size());
        assertEquals(Arrays.asList(1, 2, 1, 2), map.get(7));
        assertEquals(1, map.size());
    }

    @Test
    public void zeroLoadFactorStress() {
        PrimitiveIntHashMap<Integer> map = new PrimitiveIntHashMap<>(8, 0.0f);
        // Keep this small to avoid exponential rehash growth with loadFactor=0.0
        for (int i = 0; i < 16; i++) {
            map.put(i, i);
        }
        for (int i = 0; i < 16; i++) {
            assertEquals(Integer.valueOf(i), map.get(i));
        }
        assertEquals(16, map.size());
    }
}

package shortestpath;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PluginMessageTest {
    public static void main(String[] args) throws Exception {
        ExternalPluginManager.loadBuiltin(ShortestPathPlugin.class);
        ExternalPluginManager.loadBuiltin(PluginMessageTestPlugin.class);
        RuneLite.main(args);
    }
}

package shortestpath;

import java.awt.Color;
import java.awt.Rectangle;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.KeyCode;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.Point;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.MenuOpened;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.worldmap.WorldMap;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.PluginMessage;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.JagexColors;
import net.runelite.client.util.ColorUtil;

@PluginDescriptor(
    name = "Shortest Path Test",
    description = "Test the Shortest Path Plugin Message events"
)
public class PluginMessageTestPlugin extends Plugin {
    private static final String PLUGIN_MESSAGE_NAME = "shortestpath";
    private static final String PLUGIN_MESSAGE_PATH = "path";
    private static final String PLUGIN_MESSAGE_CLEAR = "clear";
    private static final String PLUGIN_MESSAGE_START = "start";
    private static final String PLUGIN_MESSAGE_TARGET = "target";
    private static final String PLUGIN_MESSAGE_CONFIG_OVERRIDE = "config";
    private static final String CLEAR = "Clear";
    private static final String PATH = ColorUtil.wrapWithColorTag("Path (PluginMessage)", JagexColors.MENU_TARGET);
    private static final String SET = "Set";
    private static final String START_INT = ColorUtil.wrapWithColorTag("Start Integer (PluginMessage)", JagexColors.MENU_TARGET);
    private static final String START_WP = ColorUtil.wrapWithColorTag("Start WorldPoint (PluginMessage)", JagexColors.MENU_TARGET);
    private static final String TARGET_INT = ColorUtil.wrapWithColorTag("Target Integer(s) (PluginMessage)", JagexColors.MENU_TARGET);
    private static final String TARGET_WP = ColorUtil.wrapWithColorTag("Target WorldPoint(s) (PluginMessage)", JagexColors.MENU_TARGET);
    private static final String CONFIG_COLOUR_PATH = ColorUtil.wrapWithColorTag("Yellow path colour (PluginMessage)", JagexColors.MENU_TARGET);

    private Set<WorldPoint> targets = new HashSet<>(10);
    private Point lastMenuOpenedPoint;

    @Inject
    private Client client;

    @Inject
    private EventBus eventBus;

    @Subscribe
    public void onMenuOpened(MenuOpened event) {
        lastMenuOpenedPoint = client.getMouseCanvasPosition();

        if (!client.isKeyPressed(KeyCode.KC_SHIFT)) {
            return;
        }

        for (MenuEntry menuEntry : event.getMenuEntries()) {
            if (MenuAction.WALK.equals(menuEntry.getType())) {
                addMenuEntry(event, SET, TARGET_INT, 1);
                addMenuEntry(event, SET, TARGET_WP, 1);
                addMenuEntry(event, SET, CONFIG_COLOUR_PATH, 1);
                if (!targets.isEmpty()) {
                    addMenuEntry(event, SET, START_INT, 1);
                    addMenuEntry(event, SET, START_WP, 1);
                }
                addMenuEntry(event, CLEAR, PATH, 1);
                break;
            }
        }

        final Widget map = client.getWidget(ComponentID.WORLD_MAP_MAPVIEW);

        if (map != null
            && map.getBounds().contains(
                client.getMouseCanvasPosition().getX(),
                client.getMouseCanvasPosition().getY())) {
            addMenuEntry(event, SET, TARGET_INT, 0);
            addMenuEntry(event, SET, TARGET_WP, 0);
            addMenuEntry(event, SET, CONFIG_COLOUR_PATH, 0);
            if (!targets.isEmpty()) {
                addMenuEntry(event, SET, START_INT, 0);
                addMenuEntry(event, SET, START_WP, 0);
                addMenuEntry(event, CLEAR, PATH, 0);
            }
        }
    }

    private void addMenuEntry(MenuOpened event, String option, String target, int position) {
        client.createMenuEntry(position)
            .setOption(option)
            .setTarget(target)
            .setType(MenuAction.RUNELITE)
            .onClick(this::onMenuOptionClicked);
    }

    private void onMenuOptionClicked(MenuEntry entry) {
        boolean isMessageInt = false;
        boolean overrideColourPath = false;
        WorldPoint start = null;
        WorldPoint target = null;

        if (entry.getOption().equals(SET) && entry.getTarget().equals(TARGET_INT)) {
            isMessageInt = true;
            target = getSelectedWorldPoint();
        } else if (entry.getOption().equals(SET) && entry.getTarget().equals(TARGET_WP)) {
            target = getSelectedWorldPoint();
        } else if (entry.getOption().equals(SET) && entry.getTarget().equals(START_INT)) {
            isMessageInt = true;
            start = getSelectedWorldPoint();
        } else if (entry.getOption().equals(SET) && entry.getTarget().equals(START_WP)) {
            start = getSelectedWorldPoint();
        } else if (entry.getOption().equals(SET) && entry.getTarget().equals(CONFIG_COLOUR_PATH)) {
            overrideColourPath = true;
        } else if (entry.getOption().equals(CLEAR) && entry.getTarget().equals(PATH)) {
            targets.clear();
            eventBus.post(new PluginMessage(PLUGIN_MESSAGE_NAME, PLUGIN_MESSAGE_CLEAR));
            return;
        }

        if (target != null) {
            targets.add(target);
        }

        Set<Integer> convertedTargets = new HashSet<>();
        if (isMessageInt) {
            for (WorldPoint t : targets) {
                convertedTargets.add(packWorldPoint(t));
            }
        }

        Map<String, Object> data = new HashMap<>();

        if (start != null) {
            data.put(PLUGIN_MESSAGE_START, isMessageInt ? packWorldPoint(start) : start);
        }

        if (!targets.isEmpty()) {
            data.put(PLUGIN_MESSAGE_TARGET,
                targets.size() != 1 ? (isMessageInt ? convertedTargets : targets)
                : (isMessageInt ? convertedTargets.iterator().next() : targets.iterator().next()));
        }

        if (overrideColourPath) {
            Map<String, Object> configOverride = new HashMap<>();
            configOverride.put("colourPath", new Color(255, 255, 0));
            data.put(PLUGIN_MESSAGE_CONFIG_OVERRIDE, configOverride);
        }

        eventBus.post(new PluginMessage(PLUGIN_MESSAGE_NAME, PLUGIN_MESSAGE_PATH, data));
    }

    private WorldPoint getSelectedWorldPoint() {
        if (client.getWidget(ComponentID.WORLD_MAP_MAPVIEW) == null) {
            if (client.getSelectedSceneTile() != null) {
                return WorldPoint.fromLocalInstance(client, client.getSelectedSceneTile().getLocalLocation());
            }
        } else {
            return client.isMenuOpen()
                ? calculateMapPoint(lastMenuOpenedPoint.getX(), lastMenuOpenedPoint.getY())
                : calculateMapPoint(client.getMouseCanvasPosition().getX(), client.getMouseCanvasPosition().getY());
        }
        return null;
    }

    private WorldPoint calculateMapPoint(int pointX, int pointY) {
        WorldMap worldMap = client.getWorldMap();
        float zoom = worldMap.getWorldMapZoom();
        WorldPoint mapPoint = new WorldPoint(worldMap.getWorldMapPosition().getX(), worldMap.getWorldMapPosition().getY(), 0);
        int middleX = mapWorldPointToGraphicsPointX(mapPoint);
        int middleY = mapWorldPointToGraphicsPointY(mapPoint);

        if (pointX == Integer.MIN_VALUE || pointY == Integer.MIN_VALUE ||
            middleX == Integer.MIN_VALUE || middleY == Integer.MIN_VALUE) {
            return null;
        }

        final int dx = (int) ((pointX - middleX) / zoom);
        final int dy = (int) ((-(pointY - middleY)) / zoom);

        return mapPoint.dx(dx).dy(dy);
    }

    public int mapWorldPointToGraphicsPointX(WorldPoint worldPoint) {
        WorldMap worldMap = client.getWorldMap();

        float pixelsPerTile = worldMap.getWorldMapZoom();

        Widget map = client.getWidget(ComponentID.WORLD_MAP_MAPVIEW);
        if (map != null) {
            Rectangle worldMapRect = map.getBounds();

            int widthInTiles = (int) Math.ceil(worldMapRect.getWidth() / pixelsPerTile);

            Point worldMapPosition = worldMap.getWorldMapPosition();

            int xTileOffset = worldPoint.getX() + widthInTiles / 2 - worldMapPosition.getX();

            int xGraphDiff = ((int) (xTileOffset * pixelsPerTile));
            xGraphDiff += pixelsPerTile - Math.ceil(pixelsPerTile / 2);
            xGraphDiff += (int) worldMapRect.getX();

            return xGraphDiff;
        }
        return Integer.MIN_VALUE;
    }

    public int mapWorldPointToGraphicsPointY(WorldPoint worldPoint) {
        WorldMap worldMap = client.getWorldMap();

        float pixelsPerTile = worldMap.getWorldMapZoom();

        Widget map = client.getWidget(ComponentID.WORLD_MAP_MAPVIEW);
        if (map != null) {
            Rectangle worldMapRect = map.getBounds();

            int heightInTiles = (int) Math.ceil(worldMapRect.getHeight() / pixelsPerTile);

            Point worldMapPosition = worldMap.getWorldMapPosition();

            int yTileMax = worldMapPosition.getY() - heightInTiles / 2;
            int yTileOffset = (yTileMax - worldPoint.getY() - 1) * -1;

            int yGraphDiff = (int) (yTileOffset * pixelsPerTile);
            yGraphDiff -= pixelsPerTile - Math.ceil(pixelsPerTile / 2);
            yGraphDiff = worldMapRect.height - yGraphDiff;
            yGraphDiff += (int) worldMapRect.getY();

            return yGraphDiff;
        }
        return Integer.MIN_VALUE;
    }

    private static int packWorldPoint(WorldPoint wp) {
        if (wp == null) {
            return -1;
        }
        return (wp.getX() & 0x7FFF) | ((wp.getY() & 0x7FFF) << 15) | ((wp.getPlane() & 0x3) << 30);
    }
}

package shortestpath;

import net.runelite.api.Client;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import org.junit.Test;
import org.mockito.Mockito;

import java.util.ArrayList;
import java.util.List;

import static net.runelite.api.Constants.CHUNK_SIZE;
import static net.runelite.api.Perspective.LOCAL_COORD_BITS;
import static org.junit.Assert.*;

/**
 * Unit tests for {@link WorldPointUtil}.
 */
public class WorldPointUtilTest {

    @Test
    public void packAndUnpackRoundTrip() {
        WorldPoint p = new WorldPoint(1234, 5678, 2);
        int packed = WorldPointUtil.packWorldPoint(p);
        assertEquals(1234, WorldPointUtil.unpackWorldX(packed));
        assertEquals(5678, WorldPointUtil.unpackWorldY(packed));
        assertEquals(2, WorldPointUtil.unpackWorldPlane(packed));

        WorldPoint unpacked = WorldPointUtil.unpackWorldPoint(packed);
        assertEquals(p, unpacked);
    }

    @Test
    public void packMasksHighBits() {
        int x = 40000; // exceeds 15 bits
        int y = 50000; // exceeds 15 bits
        int plane = 7; // exceeds 2 bits
        int packed = WorldPointUtil.packWorldPoint(x, y, plane);
        assertEquals(x & 0x7FFF, WorldPointUtil.unpackWorldX(packed));
        assertEquals(y & 0x7FFF, WorldPointUtil.unpackWorldY(packed));
        assertEquals(plane & 0x3, WorldPointUtil.unpackWorldPlane(packed));
    }

    @Test
    public void dxdyOffsetsCorrectly() {
        int base = WorldPointUtil.packWorldPoint(3200, 3200, 1);
        int moved = WorldPointUtil.dxdy(base, 5, -7);
        assertEquals(3200 + 5, WorldPointUtil.unpackWorldX(moved));
        assertEquals(3200 - 7, WorldPointUtil.unpackWorldY(moved));
        assertEquals(1, WorldPointUtil.unpackWorldPlane(moved));
    }

    @Test
    public void distanceChebyshevAndManhattan() {
        int a = WorldPointUtil.packWorldPoint(10, 10, 0);
        int b = WorldPointUtil.packWorldPoint(15, 13, 0); // dx=5 dy=3
        assertEquals(5, WorldPointUtil.distanceBetween(a, b)); // Chebyshev
        assertEquals(5, WorldPointUtil.distanceBetween2D(a, b)); // Chebyshev 2D
        assertEquals(5 + 3, WorldPointUtil.distanceBetween(a, b, 2)); // Manhattan
        assertEquals(Integer.MAX_VALUE, WorldPointUtil.distanceBetween(a, b, 99));
    }

    @Test
    public void distanceDifferentPlanesReturnsMax() {
        int a = WorldPointUtil.packWorldPoint(10, 10, 0);
        int b = WorldPointUtil.packWorldPoint(11, 11, 1);
        assertEquals(Integer.MAX_VALUE, WorldPointUtil.distanceBetween(a, b));
    }

    @Test
    public void distanceWorldPointOverloads() {
        WorldPoint a = new WorldPoint(100, 150, 0);
        WorldPoint b = new WorldPoint(103, 160, 0); // dx=3 dy=10
        assertEquals(10, WorldPointUtil.distanceBetween(a, b)); // Chebyshev
        assertEquals(13, WorldPointUtil.distanceBetween(a, b, 2)); // Manhattan
    }

    @Test
    public void distanceToAreaInsideAndOutside() {
        WorldArea area = new WorldArea(3000, 4000, 5, 4, 0); // x:[3000..3004], y:[4000..4003]
        int inside = WorldPointUtil.packWorldPoint(3002, 4001, 0);
        int leftOutside = WorldPointUtil.packWorldPoint(2995, 4002, 0);
        int diagOutside = WorldPointUtil.packWorldPoint(2990, 3990, 0);
        int otherPlane = WorldPointUtil.packWorldPoint(3002, 4001, 1);

        assertEquals(0, WorldPointUtil.distanceToArea(inside, area));
        assertEquals(0, WorldPointUtil.distanceToArea2D(inside, area));
        // leftOutside: dx = 3000-2995=5, dy=0 => Chebyshev 5
        assertEquals(5, WorldPointUtil.distanceToArea(leftOutside, area));
        assertEquals(5, WorldPointUtil.distanceToArea2D(leftOutside, area));
        // diagOutside: dx=3000-2990=10, dy=4000-3990=10 => Chebyshev 10
        assertEquals(10, WorldPointUtil.distanceToArea(diagOutside, area));
        assertEquals(10, WorldPointUtil.distanceToArea2D(diagOutside, area));
        // plane mismatch
        assertEquals(Integer.MAX_VALUE, WorldPointUtil.distanceToArea(otherPlane, area));
    }

    @Test
    public void toLocalPointWithinScene() {
        Client client = Mockito.mock(Client.class);
        WorldView worldView = Mockito.mock(WorldView.class);
        Mockito.when(client.getTopLevelWorldView()).thenReturn(worldView);
        Mockito.when(worldView.getPlane()).thenReturn(0);
        Mockito.when(worldView.getBaseX()).thenReturn(3200);
        Mockito.when(worldView.getBaseY()).thenReturn(3200);
        Mockito.when(worldView.getSizeX()).thenReturn(104); // typical scene size
        Mockito.when(worldView.getSizeY()).thenReturn(104);
        Mockito.when(worldView.getId()).thenReturn(0);

        int packed = WorldPointUtil.packWorldPoint(3210, 3220, 0);
        LocalPoint lp = WorldPointUtil.toLocalPoint(client, packed);
        assertNotNull(lp);
        int expectedLocalX = ((3210 - 3200) << LOCAL_COORD_BITS) + (1 << (LOCAL_COORD_BITS - 1));
        int expectedLocalY = ((3220 - 3200) << LOCAL_COORD_BITS) + (1 << (LOCAL_COORD_BITS - 1));
        assertEquals(expectedLocalX, lp.getX());
        assertEquals(expectedLocalY, lp.getY());
    }

    @Test
    public void toLocalPointOutOfSceneOrPlane() {
        Client client = Mockito.mock(Client.class);
        WorldView worldView = Mockito.mock(WorldView.class);
        Mockito.when(client.getTopLevelWorldView()).thenReturn(worldView);
        Mockito.when(worldView.getPlane()).thenReturn(0);
        Mockito.when(worldView.getBaseX()).thenReturn(3200);
        Mockito.when(worldView.getBaseY()).thenReturn(3200);
        Mockito.when(worldView.getSizeX()).thenReturn(104);
        Mockito.when(worldView.getSizeY()).thenReturn(104);
        Mockito.when(worldView.getId()).thenReturn(0);

        // Plane mismatch
        int packedWrongPlane = WorldPointUtil.packWorldPoint(3210, 3210, 1);
        assertNull(WorldPointUtil.toLocalPoint(client, packedWrongPlane));

        // Outside scene (x less than baseX)
        int packedOutside = WorldPointUtil.packWorldPoint(3199, 3210, 0);
        assertNull(WorldPointUtil.toLocalPoint(client, packedOutside));
    }

    @Test
    public void toLocalInstanceNonInstanceWorld() {
        Client client = Mockito.mock(Client.class);
        WorldView top = Mockito.mock(WorldView.class);
        Mockito.when(client.getTopLevelWorldView()).thenReturn(top);
        Mockito.when(top.isInstance()).thenReturn(false);
        int packed = WorldPointUtil.packWorldPoint(4000, 5000, 2);
        PrimitiveIntList list = WorldPointUtil.toLocalInstance(client, packed);
        assertEquals(1, list.size());
        assertEquals(packed, list.get(0));
    }

    @Test
    public void fromLocalInstanceNonInstanceWorld() {
        Client client = Mockito.mock(Client.class);
        WorldView view = Mockito.mock(WorldView.class);
        Mockito.when(client.getWorldView(0)).thenReturn(view);
        Mockito.when(view.getPlane()).thenReturn(0);
        Mockito.when(view.isInstance()).thenReturn(false);
        Mockito.when(view.getBaseX()).thenReturn(3200);
        Mockito.when(view.getBaseY()).thenReturn(3200);

        int tileX = 3210;
        int tileY = 3222;
        // LocalPoint stores scene (local) coordinates relative to base, so subtract base before shifting
        int localTileX = tileX - 3200;
        int localTileY = tileY - 3200;
        LocalPoint lp = new LocalPoint(localTileX << LOCAL_COORD_BITS, localTileY << LOCAL_COORD_BITS, 0);
        int packed = WorldPointUtil.fromLocalInstance(client, lp);
        assertEquals(tileX, WorldPointUtil.unpackWorldX(packed));
        assertEquals(tileY, WorldPointUtil.unpackWorldY(packed));
        assertEquals(0, WorldPointUtil.unpackWorldPlane(packed));
    }

    @Test
    public void toLocalInstanceSimpleInstanceMatch() {
        // Build a minimal instance template where a single chunk maps to a template containing our point
        Client client = Mockito.mock(Client.class);
        WorldView top = Mockito.mock(WorldView.class);
        Mockito.when(client.getTopLevelWorldView()).thenReturn(top);
        Mockito.when(top.isInstance()).thenReturn(true);
        Mockito.when(top.getBaseX()).thenReturn(0);
        Mockito.when(top.getBaseY()).thenReturn(0);

        // one plane, 2x2 chunks
        int planes = 1;
        int size = 2; // chunk dimensions in each axis
        int[][][] chunks = new int[planes][size][size];

        // Target world point inside template chunk at chunk indices (1,1)
        int worldX = 100; // arbitrary
        int worldY = 200;
        int templateChunkX = (worldX & ~(CHUNK_SIZE - 1));
        int templateChunkY = (worldY & ~(CHUNK_SIZE - 1));
        int chunkIndexX = 1;
        int chunkIndexY = 1;
        int rotation = 0;
        int plane = 0;
        int chunkData = (plane << 24) | ((templateChunkX / CHUNK_SIZE) << 14) | ((templateChunkY / CHUNK_SIZE) << 3) | (rotation << 1);
        chunks[0][chunkIndexX][chunkIndexY] = chunkData;
        Mockito.when(top.getInstanceTemplateChunks()).thenReturn(chunks);
        Mockito.when(top.getPlane()).thenReturn(0);

        int packed = WorldPointUtil.packWorldPoint(worldX, worldY, 0);
        PrimitiveIntList list = WorldPointUtil.toLocalInstance(client, packed);
        assertTrue("Expected at least one mapping", list.size() >= 1);
        // The produced local instance point should be within the instance chunk bounds
        int mapped = list.get(0);
        int mx = WorldPointUtil.unpackWorldX(mapped);
        int my = WorldPointUtil.unpackWorldY(mapped);
        assertTrue(mx >= chunkIndexX * CHUNK_SIZE && mx < (chunkIndexX + 1) * CHUNK_SIZE + CHUNK_SIZE); // loose bound
        assertTrue(my >= chunkIndexY * CHUNK_SIZE && my < (chunkIndexY + 1) * CHUNK_SIZE + CHUNK_SIZE);
    }

    // --- Tests merged from WorldPointTests.java ---

    private static final WorldArea WILDERNESS_ABOVE_GROUND = new WorldArea(2944, 3523, 448, 448, 0);

    @Test
    public void testDistanceToArea() {
        List<WorldPoint> testPoints = new ArrayList<>(10);
        testPoints.add(new WorldPoint(2900, 3500, 0));
        testPoints.add(new WorldPoint(3000, 3500, 0));
        testPoints.add(new WorldPoint(3600, 3500, 0));
        testPoints.add(new WorldPoint(2900, 3622, 0));
        testPoints.add(new WorldPoint(3000, 3622, 0));
        testPoints.add(new WorldPoint(3600, 3622, 0));
        testPoints.add(new WorldPoint(2900, 4300, 0));
        testPoints.add(new WorldPoint(3000, 4300, 0));
        testPoints.add(new WorldPoint(3600, 4300, 0));
        testPoints.add(new WorldPoint(3600, 4200, 1));

        for (WorldPoint point : testPoints) {
            final int areaDistance = WILDERNESS_ABOVE_GROUND.distanceTo(point);
            final int packedPoint = WorldPointUtil.packWorldPoint(point);
            final int worldUtilDistance = WorldPointUtil.distanceToArea(packedPoint, WILDERNESS_ABOVE_GROUND);
            assertEquals("Calculating distance to " + point + " failed", areaDistance, worldUtilDistance);
        }
    }

    @Test
    public void testWorldPointPacking() {
        WorldPoint point = new WorldPoint(13, 24685, 1);

        final int packedPoint = WorldPointUtil.packWorldPoint(point);
        assertEquals((1 << 30) | (24685 << 15) | 13, packedPoint);
        final int unpackedX = WorldPointUtil.unpackWorldX(packedPoint);
        assertEquals(point.getX(), unpackedX);

        final int unpackedY = WorldPointUtil.unpackWorldY(packedPoint);
        assertEquals(point.getY(), unpackedY);

        final int unpackedPlane = WorldPointUtil.unpackWorldPlane(packedPoint);
        assertEquals(point.getPlane(), unpackedPlane);

        WorldPoint unpackedPoint = WorldPointUtil.unpackWorldPoint(packedPoint);
        assertEquals(point, unpackedPoint);
    }

    @Test
    public void testDistanceBetween() {
        WorldPoint pointA = new WorldPoint(13, 24685, 1);
        WorldPoint pointB = new WorldPoint(29241, 3384, 1);
        WorldPoint pointC = new WorldPoint(292, 3384, 0); // Test point on different plane

        assertEquals(0, WorldPointUtil.distanceBetween(pointA, pointA));
        assertEquals(29228, WorldPointUtil.distanceBetween(pointA, pointB));
        assertEquals(29228, WorldPointUtil.distanceBetween(pointB, pointA));
        assertEquals(Integer.MAX_VALUE, WorldPointUtil.distanceBetween(pointA, pointC));

        // with diagonal = 2
        assertEquals(0, WorldPointUtil.distanceBetween(pointA, pointA, 2));
        assertEquals(50529, WorldPointUtil.distanceBetween(pointA, pointB, 2));
        assertEquals(50529, WorldPointUtil.distanceBetween(pointB, pointA, 2));
        assertEquals(Integer.MAX_VALUE, WorldPointUtil.distanceBetween(pointB, pointC, 2));
    }

    @Test
    public void testPackedDistanceBetween() {
        WorldPoint pointA = new WorldPoint(13, 24685, 1);
        WorldPoint pointB = new WorldPoint(29241, 3384, 1);
        WorldPoint pointC = new WorldPoint(292, 3384, 0); // Test point on different plane
        final int packedPointA = WorldPointUtil.packWorldPoint(pointA);
        final int packedPointB = WorldPointUtil.packWorldPoint(pointB);
        final int packedPointC = WorldPointUtil.packWorldPoint(pointC);

        assertEquals(0, WorldPointUtil.distanceBetween(packedPointA, packedPointA));
        assertEquals(29228, WorldPointUtil.distanceBetween(packedPointA, packedPointB));
        assertEquals(29228, WorldPointUtil.distanceBetween(packedPointB, packedPointA));
        assertEquals(Integer.MAX_VALUE, WorldPointUtil.distanceBetween(packedPointA, packedPointC));

        // with diagonal = 2
        assertEquals(0, WorldPointUtil.distanceBetween(packedPointA, packedPointA, 2));
        assertEquals(50529, WorldPointUtil.distanceBetween(packedPointA, packedPointB, 2));
        assertEquals(50529, WorldPointUtil.distanceBetween(packedPointB, packedPointA, 2));
        assertEquals(Integer.MAX_VALUE, WorldPointUtil.distanceBetween(packedPointB, packedPointC, 2));
    }

    @Test
    public void testMaxWorldPoint() {
        assertEquals(WorldPointUtil.packWorldPoint(-1, -1, -1), -1);
        assertEquals(WorldPointUtil.packWorldPoint(-1, -1, 1), Integer.MAX_VALUE);
    }
}

/*
 * Copyright (c) 2016-2017, Adam <Adam@sigterm.info>
 * Copyright (c) 2022, Skretzo <https://github.com/Skretzo>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package net.runelite.cache;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.BitSet;
import java.util.Collection;
import net.runelite.cache.definitions.ObjectDefinition;
import net.runelite.cache.fs.Store;
import net.runelite.cache.region.Location;
import net.runelite.cache.region.Position;
import net.runelite.cache.region.Region;
import net.runelite.cache.region.RegionLoader;
import net.runelite.cache.util.KeyProvider;
import net.runelite.cache.util.XteaKeyManager;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;

/**
 * Collision map dumper
 *
 * Cache and XTEA keys can be downloaded from:
 * https://archive.openrs2.org/caches
 * and replace "mapsquare" with "region" and "key" with "keys".
 * Compile the client with "mvn install -f pom.xml -DskipTests -U".
 * Run "java net.runelite.cache.CollisionMapDumper --cachedir ../cache --xteapath ../keys.json --outputdir ../output"
 */
public class CollisionMapDumper
{
	private final RegionLoader regionLoader;
	private final ObjectManager objectManager;

	public CollisionMapDumper(Store store, KeyProvider keyProvider)
	{
		this(store, new RegionLoader(store, keyProvider));
	}

	public CollisionMapDumper(Store store, RegionLoader regionLoader)
	{
		this.regionLoader = regionLoader;
		this.objectManager = new ObjectManager(store);
	}

	public CollisionMapDumper load() throws IOException
	{
		objectManager.load();
		regionLoader.loadRegions();
		regionLoader.calculateBounds();

		return this;
	}

	private ObjectDefinition findObject(int id)
	{
		return objectManager.getObject(id);
	}

	public static void main(String[] args) throws IOException
	{
		Options options = new Options();
		options.addOption(Option.builder().longOpt("cachedir").hasArg().required().build());
		options.addOption(Option.builder().longOpt("xteapath").hasArg().required().build());
		options.addOption(Option.builder().longOpt("outputdir").hasArg().required().build());

		CommandLineParser parser = new DefaultParser();
		CommandLine cmd;
		try
		{
			cmd = parser.parse(options, args);
		}
		catch (ParseException ex)
		{
			System.err.println("Error parsing command line options: " + ex.getMessage());
			System.exit(-1);
			return;
		}

		final String cacheDirectory = cmd.getOptionValue("cachedir");
		final String xteaJSONPath = cmd.getOptionValue("xteapath");
		final String outputDirectory = cmd.getOptionValue("outputdir");

		XteaKeyManager xteaKeyManager = new XteaKeyManager();
		try (FileInputStream fin = new FileInputStream(xteaJSONPath))
		{
			xteaKeyManager.loadKeys(fin);
		}

		File base = new File(cacheDirectory);
		File outDir = new File(outputDirectory);
		outDir.mkdirs();

		try (Store store = new Store(base))
		{
			store.load();

			CollisionMapDumper dumper = new CollisionMapDumper(store, xteaKeyManager);
			dumper.load();

			Collection<Region> regions = dumper.regionLoader.getRegions();

			int n = 0;
			int total = regions.size();

			for (Region region : regions)
			{
				dumper.makeCollisionMap(region, outputDirectory, ++n, total);
			}
		}
	}

	private void makeCollisionMap(Region region, String outputDirectory, int n, int total)
	{
		int baseX = region.getBaseX();
		int baseY = region.getBaseY();

		FlagMap flagMap = new FlagMap(baseX, baseY, baseX + Region.X - 1, baseY + Region.Y - 1);

		addCollisions(flagMap, region);
		addNeighborCollisions(flagMap, region, -1, -1);
		addNeighborCollisions(flagMap, region, -1, 0);
		addNeighborCollisions(flagMap, region, -1, 1);
		addNeighborCollisions(flagMap, region, 0, -1);
		addNeighborCollisions(flagMap, region, 0, 1);
		addNeighborCollisions(flagMap, region, 1, -1);
		addNeighborCollisions(flagMap, region, 1, 0);
		addNeighborCollisions(flagMap, region, 1, 1);

		String name = region.getRegionX() + "_" + region.getRegionY();

		byte[] buf = flagMap.toBytes();
		if (buf.length > 0)
		{
			try (FileOutputStream out = new FileOutputStream(outputDirectory + "/" + name))
			{
				out.write(buf, 0, buf.length);
				System.out.println("Exporting region " + name + " (" + n + " / " + total + ")");
			}
			catch (IOException e)
			{
				System.out.println("Unable to write compressed output bytes for " + name + ". " + e);
			}
		}
	}

	private void addNeighborCollisions(FlagMap flagMap, Region region, int dx, int dy)
	{
		Region neighbor = regionLoader.findRegionForRegionCoordinates(region.getRegionX() + dx, region.getRegionY() + dy);
		if (neighbor == null)
		{
			return;
		}
		addCollisions(flagMap, neighbor);
	}

	private void addCollisions(FlagMap flagMap, Region region)
	{
		int baseX = region.getBaseX();
		int baseY = region.getBaseY();

		for (int z = 0; z < Region.Z; z++)
		{
			for (int localX = 0; localX < Region.X; localX++)
			{
				int regionX = baseX + localX;
				for (int localY = 0; localY < Region.Y; localY++)
				{
					int regionY = baseY + localY;

					boolean isBridge = (region.getTileSetting(1, localX, localY) & 2) != 0;
					int tileZ = z + (isBridge ? 1 : 0);

					for (Location loc : region.getLocations())
					{
						Position pos = loc.getPosition();
						if (pos.getX() != regionX || pos.getY() != regionY || pos.getZ() != tileZ)
						{
							continue;
						}

						boolean tile = FlagMap.TILE_BLOCKED;
						Boolean exclusion = Exclusion.matches(loc.getId());

						int X = loc.getPosition().getX();
						int Y = loc.getPosition().getY();
						int Z = z;

						int type = loc.getType();
						int orientation = loc.getOrientation();

						ObjectDefinition object = findObject(loc.getId());

						int sizeX = (orientation == 1 || orientation == 3) ? object.getSizeY() : object.getSizeX();
						int sizeY = (orientation == 1 || orientation == 3) ? object.getSizeX() : object.getSizeY();

						// Walls
						if (type >= 0 && type <= 3)
						{
							Z = z != tileZ ? z : loc.getPosition().getZ();

							if (object.getMapSceneID() != -1)
							{
								if (exclusion != null)
								{
									tile = exclusion;
								}
								else if (object.getInteractType() == 0)
								{
									continue;
								}
								for (int sx = 0; sx < sizeX; sx++)
								{
									for (int sy = 0; sy < sizeY; sy++)
									{
										flagMap.set(X + sx, Y + sy, Z, FlagMap.FLAG_NORTH, tile);
										flagMap.set(X + sx, Y + sy, Z, FlagMap.FLAG_EAST, tile);
										flagMap.set(X + sx, Y + sy - 1, Z, FlagMap.FLAG_NORTH, tile);
										flagMap.set(X + sx - 1, Y + sy, Z, FlagMap.FLAG_EAST, tile);
									}
								}
							}
							else
							{
								boolean door = object.getWallOrDoor() != 0;
								boolean doorway = !door && object.getInteractType() == 0 && type == 0;
								tile = door ? FlagMap.TILE_DEFAULT : FlagMap.TILE_BLOCKED;
								if (exclusion != null)
								{
									tile = exclusion;
								}
								else if (doorway)
								{
									continue;
								}

								if (type == 0 || type == 2)
								{
									if (orientation == 0) // wall on west
									{
										flagMap.set(X - 1, Y, Z, FlagMap.FLAG_WEST, tile);
									}
									else if (orientation == 1) // wall on north
									{
										flagMap.set(X, Y, Z, FlagMap.FLAG_NORTH, tile);
									}
									else if (orientation == 2) // wall on east
									{
										flagMap.set(X, Y, Z, FlagMap.FLAG_EAST, tile);
									}
									else if (orientation == 3) // wall on south
									{
										flagMap.set(X, Y - 1, Z, FlagMap.FLAG_SOUTH, tile);
									}
								}

								/*
								if (type == 3)
								{
									if (orientation == 0) // corner north-west
									{
										flagMap.set(X - 1, Y, Z, FlagMap.FLAG_WEST, tile);
									}
									else if (orientation == 1) // corner north-east
									{
										flagMap.set(X, Y, Z, FlagMap.FLAG_NORTH, tile);
									}
									else if (orientation == 2) // corner south-east
									{
										flagMap.set(X, Y, Z, FlagMap.FLAG_EAST, tile);
									}
									else if (orientation == 3) // corner south-west
									{
										flagMap.set(X, Y - 1, Z, FlagMap.FLAG_SOUTH, tile);
									}
								}
								*/

								if (type == 2) // double walls
								{
									if (orientation == 3)
									{
										flagMap.set(X - 1, Y, Z, FlagMap.FLAG_WEST, tile);
									}
									else if (orientation == 0)
									{
										flagMap.set(X, Y, Z, FlagMap.FLAG_NORTH, tile);
									}
									else if (orientation == 1)
									{
										flagMap.set(X, Y, Z, FlagMap.FLAG_EAST, tile);
									}
									else if (orientation == 2)
									{
										flagMap.set(X, Y - 1, Z, FlagMap.FLAG_SOUTH, tile);
									}
								}
							}
						}

						// Diagonal walls
						if (type == 9)
						{
							if (object.getMapSceneID() != -1)
							{
								if (exclusion != null)
								{
									tile = exclusion;
								}
								for (int sx = 0; sx < sizeX; sx++)
								{
									for (int sy = 0; sy < sizeY; sy++)
									{
										flagMap.set(X + sx, Y + sy, Z, FlagMap.FLAG_NORTH, tile);
										flagMap.set(X + sx, Y + sy, Z, FlagMap.FLAG_EAST, tile);
										flagMap.set(X + sx, Y + sy - 1, Z, FlagMap.FLAG_NORTH, tile);
										flagMap.set(X + sx - 1, Y + sy, Z, FlagMap.FLAG_EAST, tile);
									}
								}
							}
							else
							{
								boolean door = object.getWallOrDoor() != 0;
								tile = door ? FlagMap.TILE_DEFAULT : FlagMap.TILE_BLOCKED;
								if (exclusion != null)
								{
									tile = exclusion;
								}

								if (orientation != 0 && orientation != 2) // diagonal wall pointing north-east
								{
									flagMap.set(X, Y, Z, FlagMap.FLAG_NORTH, tile);
									flagMap.set(X, Y, Z, FlagMap.FLAG_EAST, tile);
									flagMap.set(X, Y - 1, Z, FlagMap.FLAG_NORTH, tile);
									flagMap.set(X - 1, Y, Z, FlagMap.FLAG_EAST, tile);
								}
								else // diagonal wall pointing north-west
								{
									flagMap.set(X, Y, Z, FlagMap.FLAG_NORTH, tile);
									flagMap.set(X, Y, Z, FlagMap.FLAG_WEST, tile);
									flagMap.set(X, Y - 1, Z, FlagMap.FLAG_NORTH, tile);
									flagMap.set(X - 1, Y, Z, FlagMap.FLAG_WEST, tile);
								}
							}
						}

						// Remaining objects
						if (type == 22 || (type >= 9 && type <= 11) || (type >= 12 && type <= 21))
						{
							if (object.getInteractType() != 0 && (object.getWallOrDoor() == 1 || (type >= 10 && type <= 21)))
							{
								if (exclusion != null)
								{
									tile = exclusion;
								}

								for (int sx = 0; sx < sizeX; sx++)
								{
									for (int sy = 0; sy < sizeY; sy++)
									{
										flagMap.set(X + sx, Y + sy, Z, FlagMap.FLAG_NORTH, tile);
										flagMap.set(X + sx, Y + sy, Z, FlagMap.FLAG_EAST, tile);
										flagMap.set(X + sx, Y + sy - 1, Z, FlagMap.FLAG_NORTH, tile);
										flagMap.set(X + sx - 1, Y + sy, Z, FlagMap.FLAG_EAST, tile);
									}
								}
							}
						}
					}

					// Tile without floor / floating in the air ("noclip" tiles, typically found where z > 0)
					int underlayId = region.getUnderlayId(z < 3 ? tileZ : z, localX, localY);
					int overlayId = region.getOverlayId(z < 3 ? tileZ : z, localX, localY);
					boolean noFloor = underlayId == 0 && overlayId == 0;

					// Nomove
					int floorType = region.getTileSetting(z < 3 ? tileZ : z, localX, localY);
					if (floorType == 1 || // water, rooftop wall
						floorType == 3 || // bridge wall
						floorType == 5 || // house wall/roof
						floorType == 7 || // house wall
						noFloor)
					{
						flagMap.set(regionX, regionY, z, FlagMap.FLAG_NORTH, FlagMap.TILE_BLOCKED);
						flagMap.set(regionX, regionY, z, FlagMap.FLAG_EAST, FlagMap.TILE_BLOCKED);
						flagMap.set(regionX, regionY - 1, z, FlagMap.FLAG_NORTH, FlagMap.TILE_BLOCKED);
						flagMap.set(regionX - 1, regionY, z, FlagMap.FLAG_EAST, FlagMap.TILE_BLOCKED);
					}
				}
			}
		}
	}

	private static class FlagMap
	{
		/**
		 * The default value of a tile in the compressed collision map
		 */
		public static final boolean TILE_DEFAULT = true;

		/**
		 * The value of a blocked tile in the compressed collision map
		 */
		public static final boolean TILE_BLOCKED = false;

		/**
		 * Number of possible z-planes: 0, 1, 2, 3
		 */
		private static final int PLANE_COUNT = 4;

		/**
		 * Number of possible flags: 0 = north/south, 1 = east/west
		 */
		private static final int FLAG_COUNT = 2;
		public static final int FLAG_NORTH = 0;
		public static final int FLAG_SOUTH = 0;
		public static final int FLAG_EAST = 1;
		public static final int FLAG_WEST = 1;

		public final BitSet flags;
		private final int minX;
		private final int minY;
		private final int maxX;
		private final int maxY;
		private final int width;
		private final int height;

		public FlagMap(int minX, int minY, int maxX, int maxY)
		{
			this(minX, minY, maxX, maxY, TILE_DEFAULT);
		}

		public FlagMap(int minX, int minY, int maxX, int maxY, boolean value)
		{
			this.minX = minX;
			this.minY = minY;
			this.maxX = maxX;
			this.maxY = maxY;
			width = (maxX - minX + 1);
			height = (maxY - minY + 1);
			flags = new BitSet(width * height * PLANE_COUNT * FLAG_COUNT);
			flags.set(0, flags.size(), value);
		}

		public byte[] toBytes()
		{
			return flags.toByteArray();
		}

		public void set(int x, int y, int z, int flag, boolean value)
		{
			if (isValidIndex(x, y, z, flag))
			{
				flags.set(index(x, y, z, flag), value);
			}
		}

		private boolean isValidIndex(int x, int y, int z, int flag)
		{
			return x >= minX && x <= maxX && y >= minY && y <= maxY && z >= 0 && z <= PLANE_COUNT - 1 && flag >= 0 && flag <= FLAG_COUNT - 1;
		}

		private int index(int x, int y, int z, int flag)
		{
			if (isValidIndex(x, y, z, flag))
			{
				return (z * width * height + (y - minY) * width + (x - minX)) * FLAG_COUNT + flag;
			}
			throw new IndexOutOfBoundsException(x + " " + y + " " + z);
		}
	}

	private enum Exclusion
	{
		AMETHYST_CRYSTALS_EMPTY_WALL_11393(11393),

		APE_ATOLL_JAIL_DOOR_4800(4800),
		APE_ATOLL_JAIL_DOOR_4801(4801),

		ARDOUGNE_BASEMENT_CELL_DOOR_35795(35795),

		BRIMHAVEN_DUNGEON_EXIT_20878(20878),

		CELL_DOOR_9562(9562),

		COOKING_GUILD_DOOR_10045(10045),
		COOKING_GUILD_DOOR_24958(24958),

		CRAFTING_GUILD_DOOR_14910(14910),

		CRANDOR_WALL_2606(2606),

		DARKMEYER_CELL_DOOR_38014(38014),

		DESERT_MINING_CAMP_PRISON_DOOR_2689(2689),

		DIGSITE_GATE_24560(24560),
		DIGSITE_GATE_24561(24561),

		DRAYNOR_MANOR_LARGE_DOOR_134(134),
		DRAYNOR_MANOR_LARGE_DOOR_135(135),

		DRUIDS_ROBES_4035(4035),
		DRUIDS_ROBES_4036(4036),

		DWARF_CANNON_RAILING_15601(15601), // type = 9 is full blocked diagonal, type = 0 is wall, type = 1 is corner

		EDGEVILLE_DUNGEON_DOOR_1804(1804),

		FALADOR_GRAPPLE_WALL_17049(17049),
		FALADOR_GRAPPLE_WALL_17050(17050),
		FALADOR_GRAPPLE_WALL_17051(17051),
		FALADOR_GRAPPLE_WALL_17052(17052),

		FEROX_ENCLAVE_BARRIER_39652(39652),
		FEROX_ENCLAVE_BARRIER_39653(39653),

		FIGHT_ARENA_PRISON_DOOR_79(79),
		FIGHT_ARENA_PRISON_DOOR_80(80),

		FISHING_TRAWLER_RAIL_41400(41400),

		FORTHOS_DUNGEON_TEMPLE_DOOR_34843(34843),
		FORTHOS_DUNGEON_WALL_34854(34854),

		GOBLIN_TEMPLE_PRISON_DOOR_43457(43457),

		GRAND_EXCHANGE_BOOTH_10060(10060),
		GRAND_EXCHANGE_BOOTH_10061(10061),
		GRAND_EXCHANGE_BOOTH_30390(30390),

		GREAT_KOUREND_CELL_DOOR_41801(41801),

		GRIM_TALES_DOOR_24759(24759),

		HARDWOOD_GROVE_DOORS_9038(9038),
		HARDWOOD_GROVE_DOORS_9039(9039),

		HAUNTED_MINE_DOOR_4963(4963),
		HAUNTED_MINE_DOOR_4964(4964),

		HOSIDIUS_VINES_41814(41814),
		HOSIDIUS_VINES_41815(41815),
		HOSIDIUS_VINES_41816(41816),
		HOSIDIUS_VINES_46380(46380),
		HOSIDIUS_VINES_46381(46381),
		HOSIDIUS_VINES_46382(46382),

		KENDAL_STANDING_SPEARS_5860(5860),

		KRUKS_DUNGEON_WALL_28681(28681),
		KRUKS_DUNGEON_WALL_28798(28798),

		LUMBRIDGE_RECIPE_FOR_DISASTER_DOOR_12348(12348),
		LUMBRIDGE_RECIPE_FOR_DISASTER_DOOR_12349(12349),
		LUMBRIDGE_RECIPE_FOR_DISASTER_DOOR_12350(12350),

		MAGIC_AXE_HUT_DOOR_11726(11726),

		MCGRUBORS_WOOD_GATE_52(52),
		MCGRUBORS_WOOD_GATE_53(53),

		MEIYERDITCH_DOOR_17973(17973),

		MELZARS_MAZE_BLUE_DOOR_2599(2599),
		MELZARS_MAZE_DOOR_2595(2595),
		MELZARS_MAZE_EXIT_DOOR_2602(2602),
		MELZARS_MAZE_GREEN_DOOR_2601(2601),
		MELZARS_MAZE_MAGENTA_DOOR_2600(2600),
		MELZARS_MAZE_ORANGE_DOOR_2597(2597),
		MELZARS_MAZE_RED_DOOR_2596(2596),
		MELZARS_MAZE_YELLOW_DOOR_2598(2598),

		// MEMBERS_GATE_1727(1727), // Taverley, Falador, Brimhaven, Wilderness, Edgeville Dungeon
		// MEMBERS_GATE_1728(1728), // Taverley, Falador, Brimhaven, Wilderness, Edgeville Dungeon

		OLD_SCHOOL_MUSEUM_CURTAIN_31885(31885), // type = 9 is full blocked diagonal, type = 0 is wall

		PATERDOMUS_TEMPLE_CELL_DOOR_3463(3463),

		PEST_CONTROL_WALL_14216(14216),
		PEST_CONTROL_WALL_14217(14217),
		PEST_CONTROL_WALL_14218(14218),
		PEST_CONTROL_WALL_14219(14219),
		PEST_CONTROL_WALL_14225(14225),
		PEST_CONTROL_WALL_14226(14226),
		PEST_CONTROL_WALL_14228(14228),
		PEST_CONTROL_WALL_14229(14229),
		PEST_CONTROL_WALL_25636(25636), // type = 9 is full blocked diagonal, type = 0 is wall

		PORT_SARIM_PRISON_DOOR_9563(9563),
		PORT_SARIM_PRISON_DOOR_9565(9565),

		PRINCE_ALI_RESCUE_PRISON_GATE_2881(2881),

		RANGING_GUILD_DOOR_11665(11665),

		RAT_PITS_RAT_WALL_10335(10335), // type = 9 is full blocked diagonal, type = 2 is wall
		RAT_PITS_RAT_WALL_10337(10337), // type = 9 is full blocked diagonal, type = 2 is wall
		RAT_PITS_RAT_WALL_10342(10342), // type = 9 is full blocked diagonal, type = 2 is wall
		RAT_PITS_RAT_WALL_10344(10344), // type = 9 is full blocked diagonal, type = 2 is wall

		SCRUBFOOTS_CAVE_CREVICE_40889(40889),

		SHANTAY_PASS_PRISON_DOOR_2692(2692),

		TAI_BWO_WANNAI_ROTTEN_VILLAGE_FENCE_9025(9025),
		TAI_BWO_WANNAI_PARTIAL_FENCE_9026(9026),
		TAI_BWO_WANNAI_SHORT_FENCE_9027(9027),
		TAI_BWO_WANNAI_MEDIUM_FENCE_9028(9028),
		TAI_BWO_WANNAI_VILLAGE_FENCE_9029(9029),

		TAVERLEY_DUNGEON_PRISON_DOOR_2143(2143),
		TAVERLEY_DUNGEON_PRISON_DOOR_2144(2144),
		TAVERLEY_DUNGEON_DUSTY_KEY_DOOR_2623(2623),

		TEMPLE_OF_IKOV_DOOR_102(102),

		TEMPLE_OF_MARIMBO_DUNGEON_EXIT_16061(16061),
		TEMPLE_OF_MARIMBO_DUNGEON_EXIT_16100(16100),

		TREE_GNOME_STRONGHOLD_PRISON_DOOR_3367(3367),

		TROLL_STRONGHOLD_CELL_DOOR_3763(3763),
		TROLL_STRONGHOLD_CELL_DOOR_3765(3765),
		TROLL_STRONGHOLD_CELL_DOOR_3767(3767),
		TROLL_STRONGHOLD_EXIT_3772(3772),
		TROLL_STRONGHOLD_EXIT_3773(3773),
		TROLL_STRONGHOLD_EXIT_3774(3774),
		TROLL_STRONGHOLD_PRISON_DOOR_3780(3780),

		VARROCK_FENCE_SHORTCUT_16518(16518),

		VIYELDI_CAVES_CREVICE_2918(2918),

		WATERFALL_DUNGEON_DOOR_2002(2002),

		WEISS_BROKEN_FENCE_46815(46815),
		WEISS_BROKEN_FENCE_46816(46816),
		WEISS_BROKEN_FENCE_46817(46817),

		WILDERNESS_RESOURCE_AREA_GATE_26760(26760),

		YANILLE_DUNGEON_DOOR_11728(11728),
		YANILLE_GRAPPLE_WALL_17047(17047),
		YANILLE_GRAPPLE_WALL_17048(17058),

		ZANARIS_SHED_DOOR_2406(2406),
		;

		/**
		 * The object ID to be excluded
		 */
		private final int id;

		/**
		 * Whether the exclusion tile should be blocked or empty
		 */
		private final boolean tile;

		Exclusion(int id)
		{
			this(id, FlagMap.TILE_BLOCKED);
		}

		Exclusion(int id, boolean tile)
		{
			this.id = id;
			this.tile = tile;
		}

		public static Boolean matches(int id)
		{
			for (Exclusion exclusion : values())
			{
				if (exclusion.id == id)
				{
					return exclusion.tile;
				}
			}
			return null;
		}
	}
}

