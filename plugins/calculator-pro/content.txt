package com.calculatorpro;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class CalculatorProPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(CalculatorProPlugin.class);
		RuneLite.main(args);
	}
}
/*
 * Copyright (c) 2020, Spedwards <https://github.com/Spedwards>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.calculatorpro.uiSpedwards;

import java.awt.Dimension;
import java.awt.Font;
import javax.swing.JButton;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class CalculatorButton extends JButton
{
    private static final Dimension PREFERRED_SIZE = new Dimension(55, 55);

    //Cyborger1 edit
    private static final Dimension MINIMUM_SIZE = new Dimension(54, 55);
    //end Cyborger1 edit

    public CalculatorButton(String text)
    {
        super(text);

        setPreferredSize(PREFERRED_SIZE);
        //Cyborger1 edit
        setMinimumSize(MINIMUM_SIZE);
        //end Cyborger1 edit

        // Use Arial. Zero and Asterisk look funny in "Runescape Standard"
        setFont(new Font("Arial", Font.BOLD, 20));
    }

//    public CalculatorButton(Icon icon)
//    {
//        super(icon);
//
//        setPreferredSize(PREFERRED_SIZE);
//        //Cyborger1 edit
//        setMinimumSize(MINIMUM_SIZE);
//        //end Cyborger1 edit
//    }
}
/*
 * Copyright (c) 2020, Spedwards <https://github.com/Spedwards>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.calculatorpro.uiSpedwards;

import javax.swing.JTextField;
import lombok.Data;
import lombok.EqualsAndHashCode;
import com.calculatorpro.CalculatorProPlugin;
import java.math.RoundingMode;
import java.text.DecimalFormat;

@EqualsAndHashCode(callSuper = true)
@Data
public class DisplayField extends JTextField
{
    Double result;
    public String previousResult = "0";
    public String input = "";
    public String output = "0";
    boolean calcDone = false;

    //called after hitting =
    protected void calculateResult()
    {
        //kanderson66 edit
        //check end of equation validity
        //split equation into individual components
        String[] components = input.split("(?<=[-+*/^()\\[\\]])|(?=[-+*/^()\\[\\]])");

        //restrict math if equation is only (up to 3) "mathless" operations
        switch (components.length)
        {
            //dont do math on single component
            case 1:
                return;
            //dont do math if only max 1 number
            case 2:
                //check for - or (
                if (components[0].equals("-") || components[0].equals("("))
                {
                    return;
                }
            case 3:
                //check for -( or -- or (- or ((
                if ((components[0].equals("-") || components[0].equals("(")) && (components[1].equals("-") || components[1].equals("(")))
                {
                    return;
                }
        }

        //cant end in math symbol (remove it)
        switch (components[components.length-1])
        {
            case "+":
            case "-":
            case "*":
            case "/":
            case "^":
            case "(":
                components[components.length-1] = "";

                //reform input, re-enter Calculate result
                input = "";
                for (String component : components)
                {
                    input += component;
                }
                calculateResult();
                return;
            //last input is a ### - check if ended in a . (remove it)
            default:
                //# is a single digit, cant be a .
                if (components[components.length-1].length() != 1 ) {
                    //# ended in . (remove it)
                    if (components[components.length-1].charAt(components[components.length-1].length()-1) == '.')
                    {
                        components[components.length-1] = components[components.length-1].substring(0,components[components.length-1].length()-1);
                        break;
                    }
                }
                break;
        }

        //count num Open & closed Parenthesis '(' and ')'
        int countOpenParen = 0;
        int countClosedParen = 0;
        input="";

        for(String component : components){
            switch (component){
                case "(":
                    countOpenParen++;
                    break;
                case ")":
                    countClosedParen++;
                    break;
                default:
                    break;
            }
            //put components back into 1 string if anything changed
            input += component;
        }
        //if more '(' than ')', add as many ')' to end as needed
        if (countOpenParen-countClosedParen != 0)
        {
            for(int n=0; n<(countOpenParen-countClosedParen); n++)
            {
                input += ")";
            }
        }

        //evaluate the math equation string
        result = CalculatorProPlugin.eval(input.replaceAll(",",""));

        //check for divide by 0 error message ("Infinity")
        if(result.toString().charAt(0)=='I'){
            output = "Cant divide by 0";
            calcDone = true;
            return;
        }
        //todo add ability to custom set how many decimals to display from CalculatorProConfig.numDecimals()
//        CalculatorProConfig config = new CalculatorProConfig() {
//            @Override
//            public int numDecimals() {
//                return CalculatorProConfig.super.numDecimals();
//            }
//        };
//        System.out.println(config.numDecimals());
        //reduce answer to 3 decimal places or less & include commas for easier reading
        DecimalFormat df = new DecimalFormat("#,###.###");
        df.setRoundingMode(RoundingMode.HALF_UP);

        output = df.format(result);
        calcDone = true;
        previousResult = output;
    } //end kanderson66 edit

    protected void reset()
    {
        result = 0.0;
        input = "";
        update();
    }

    protected void clear()
    {
        reset();
    }

    protected void update()
    {
        if(calcDone)
        {
            super.setText(this.input + " = " + this.output);
            input = "";
            calcDone = false;
        }
        else {
            super.setText(this.input);
        }
        repaint();
    }
}
/*
 * Copyright (c) 2020, Spedwards <https://github.com/Spedwards>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.calculatorpro.uiSpedwards;

import java.awt.Component;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.math.RoundingMode;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import java.text.DecimalFormat;

public class CalculatorPanel extends JPanel
{
    private static final Insets INSETS_LEFT_BORDER = new Insets(1, 0, 1, 1);
    private static final Insets INSETS_RIGHT_BORDER = new Insets(1, 1, 1, 0);
    private static final Insets INSETS = new Insets(1, 1, 1, 1);

    private final CalculatorPluginPanel panel;
    private final DisplayField displayField;
    private final GridBagConstraints c;

    protected CalculatorPanel(CalculatorPluginPanel panel)
    {
        super();
        this.panel = panel;
        this.displayField = panel.getDisplayField();

        setLayout(new GridBagLayout());
        //Cyborger1 edit
        setBorder(new EmptyBorder(0, 1, 0, 1));
        //end Cyborger1 edit

        c = new GridBagConstraints();
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 0;
        c.gridy = 0;
        //Cyborger1 edit
        c.weightx = 1;
        c.weighty = 1;
        //end Cyborger1 edit

//        CalculatorButton plusMinus = new CalculatorButton(PLUS_MINUS_ICON);

        addButton("+");
        addButton("7");
        addButton("8");
        addButton("9");

        addButton("-");
        addButton("4");
        addButton("5");
        addButton("6");

        addButton("*");
        addButton("1");
        addButton("2");
        addButton("3");

        addButton("/");
        addButton(".");
        addButton("0");
        addButton("=");


        addButton("(");
        addButton(")");
        addButton("^");
        addButton("<");
//        addComp(plusMinus);

        addButton("C");
        c.gridwidth = 3;
        addButton("Clear History");
    }

    private void addButton(String key)
    {
        //todo: add keyboard inputs (ctrl+v, nums, backspace, etc)
        CalculatorButton btn = new CalculatorButton(key);
        btn.addActionListener(e ->
        {
            //create string from button inputs, validate key presses on the go, dont allow invalid key presses
            String text = btn.getText();
            switch (text) {
                case "=":
                    if (displayField.input.equals("")) {
                        return;
                    }

                    //add extra ) if needed, check end of equation valid
                    displayField.calculateResult();

                    // Add new calculation to history
                    if(displayField.calcDone){
                        panel.getHistoryPanel().addHistoryItem(displayField.input + " =", displayField.output);
                    }
                    break;

                //clear display
                case "C":
                    displayField.clear();
                    return;

                //clear history
                case "Clear History":
                    panel.getHistoryPanel().clearHistory();
                    displayField.previousResult = "0";
                    return;

                //kanderson66 edit
                //backspace function for display panel
                case "<":
                    displayField.input = deleteLastCharacter(displayField.input);
                    break;
                //input is a #
                default:
                    displayField.input += text;
                    //input not valid, remove last input
                    if (!inputValid(displayField.input.replaceAll(",", ""))) {
                        displayField.input = deleteLastCharacter(displayField.input);
                        return;
                    }
                    break;
                    //end kanderson66 edit
            }
            displayField.update();
        });
        addComp(btn);
    }

    private void addComp(Component component)
    {
        switch (c.gridx)
        {
            case 0:
                c.insets = INSETS_LEFT_BORDER;
                break;
            case 3:
                c.insets = INSETS_RIGHT_BORDER;
                break;
            default:
                c.insets = INSETS;
        }
        if (c.gridwidth == 3)
        {
            c.insets = INSETS_RIGHT_BORDER;
        }
        add(component, c);
        c.gridx = ++c.gridx % 4;
        c.gridy = c.gridx == 0 ? ++c.gridy : c.gridy;
    }

    //kanderson66 edit
    private String deleteLastCharacter(String string)
    {
        if (string.equals(""))
        {
            return string;
        }
        return string.substring(0, string.length() - 1);
    }

    private boolean inputValid(String input)
    {
        //split equation into individual components
        String[] components = input.split("(?<=[-+*/^()\\[\\]])|(?=[-+*/^()\\[\\]])");

        //check # ) never above # (
        int length=components.length;
        int countOpenParen = 0;
        int countClosedParen = 0;

        for(String component : components){
            switch (component){
                case "(":
                    countOpenParen++;
                    break;
                case ")":
                    countClosedParen++;
                    if(countClosedParen>countOpenParen){
                        return false;
                    }
                    break;
                default:
                    break;
            }
        }

        //check all math operators legal
        for(int n=0;n<length;n++){
            //grab last result if first digit pressed is math symbol & display has not been cleared
            if (n==0  && !displayField.previousResult.equals("0") && length == 1){
                switch(components[n]){
                    case "+":
                    case "-":
                    case "*":
                    case "/":
                    case "^":
                        //ensure last result enter properly w comma
                        String temp = components[n];
                        components[n] = displayField.previousResult.replaceAll(",","") + temp;
                        //re-submit value to properly separate previousResult and math operator
                        if (inputValid(components[n].replaceAll(",","")))
                        {
                            return true;
                        }
                        return false;
                    default:
                        break;
                }
            }
            //check if previous component was ###. with no number after decimal (remove last decimal)
            //# of length 1 does not have a .
            if(n != 0 && components[n - 1].length() != 1) {
                if (components[n - 1].charAt(components[n - 1].length() - 1) == '.') {
                    components[n - 1] = components[n - 1].substring(0, components[n - 1].length() - 1);
                }
            }
            //  +*/^) cant come after +-*/^( or start of equation
            switch(components[n]){
                case "+":
                case "*":
                case "/":
                case "^":
                case ")":
                    if (n!=0)
                    {
                        switch (components[n-1]){
                            case "+":
                            case "-":
                            case "*":
                            case "/":
                            case "^":
                            case "(":
                                return false;
                            default:
                                break;
                        }
                        break;
                    }
                    //cant have math symbol at start of equation (except ( or -)
                    else
                    {
                        return false;
                    }
                //check proper input before (
                case "(":
                    if (n!=0)
                    {
                        switch (components[n-1]){
                            case "+":
                            case "-":
                            case "*":
                            case "/":
                            case "^":
                            case "(":
                                break;
                            //add * before ( if needed  ("56(4-2)" changes to "56*(4-2)")
                            default:
                                components[n] = "*(";
                                break;
                        }
                    }
                    break;
            }

            //check . is before at least 1 # & only 1 in component
            if(components[n].matches(".*[.]+.*")){
                String[] split = components[n].split("\\.");
                switch (split.length)
                {
                    // "."
                    case 0:
                        components[n] = "0.";
                        break;
                    // "4."
                    case 1:
                        break;
                    // "4.4" or "4.4."
                    case 2:
                        //check if last character is .
                        if (components[n].charAt(components[n].length()-1) == '.')
                        {
                            return false;
                        }
                        break;
                    // "4.4.4"
                    //should not reach- should be corrected when 2nd . entered
                    default:
                        return false;
                }
            }
        } //end for

        //include commas for easier reading, display max 15 decimal points in input field
        //(answer field decimal limit is set separately in DisplayField.java)
        DecimalFormat df = new DecimalFormat("#,###.###############");
        df.setRoundingMode(RoundingMode.HALF_UP);

        //convert components back into 1 string, update displayField input incase changed
        displayField.input="";
        for (String component : components) {
            if (component.length() > 3) {
                displayField.input += df.format(Double.parseDouble(component));
            } else {
                displayField.input += component;
            }
        }
        return true;
    }
    //end kanderson66 edit
}



/*
 * Copyright (c) 2020, Spedwards <https://github.com/Spedwards>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.calculatorpro.uiSpedwards;

import java.awt.BorderLayout;
import lombok.Getter;
import net.runelite.client.ui.PluginPanel;

public class CalculatorPluginPanel extends PluginPanel
{
    private final DisplayPanel displayPanel = new DisplayPanel();

    @Getter
    private final HistoryPanel historyPanel = new HistoryPanel();

    public CalculatorPluginPanel()
    {
        super();

        CalculatorPanel calculatorPanel = new CalculatorPanel(this);

        setLayout(new BorderLayout(5, 5));

        add(displayPanel, BorderLayout.NORTH);
        add(calculatorPanel, BorderLayout.CENTER);
        add(historyPanel, BorderLayout.SOUTH);
    }

    protected DisplayField getDisplayField()
    {
        return displayPanel.getDisplayField();
    }
}
/*
 * Copyright (c) 2020, Spedwards <https://github.com/Spedwards>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.calculatorpro.uiSpedwards;

import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JPanel;

public class HistoryPanel extends JPanel
{
    private final List<HistoryItemPanel> itemPanels = new ArrayList<>();
    private final GridBagConstraints c;

    public HistoryPanel()
    {
        super();

        setLayout(new GridBagLayout());

        c = new GridBagConstraints();
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 0;
        c.gridy = 0;
        c.weightx = 1;
        c.weighty = 0;
        c.insets = new Insets(0, 0, 7, 0);
    }

    protected void addHistoryItem(String line1, String line2)
    {
        // Herein lies my horrible attempt at creating a new item at the top and pushing everything else down
        // ¯\_(ツ)_/¯
        removeAll();
        HistoryItemPanel itemPanel = new HistoryItemPanel(line1, line2);
        itemPanels.add(0, itemPanel);
        c.gridy = 0;
        itemPanels.forEach(panel -> {
            add(panel, c, 0);
            c.gridy++;
        });

        repaint();
        revalidate();
    }

    protected void clearHistory()
    {
        removeAll();
        itemPanels.clear();
        repaint();
        revalidate();
    }
}
/*
 * Copyright (c) 2020, Spedwards <https://github.com/Spedwards>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.calculatorpro.uiSpedwards;

import com.calculatorpro.CalculatorProPlugin;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.MatteBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;

public class HistoryItemPanel extends JPanel
{
    private static final ImageIcon CLIPBOARD_ICON;

    static
    {
        BufferedImage clipboardIcon = ImageUtil.loadImageResource(CalculatorProPlugin.class, "/clipboard_icon.png");
        clipboardIcon = ImageUtil.resizeImage(clipboardIcon,20,20);
        CLIPBOARD_ICON = new ImageIcon(clipboardIcon);
    }

    public HistoryItemPanel(String line1, String line2)
    {
        super();

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setBorder(new MatteBorder(0, 5, 0, 0, ColorScheme.BRAND_ORANGE));

        JPanel text = new JPanel(new BorderLayout());
        text.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        JLabel lineOneLabel = new JLabel(line1);
        lineOneLabel.setHorizontalAlignment(JLabel.CENTER);
        JLabel lineTwoLabel = new JLabel(line2);
        lineTwoLabel.setHorizontalAlignment(JLabel.CENTER);
        text.add(lineOneLabel, BorderLayout.NORTH);
        text.add(lineTwoLabel, BorderLayout.SOUTH);

        add(text, BorderLayout.CENTER);

        JButton copy = new JButton(CLIPBOARD_ICON);
        copy.setPreferredSize(new Dimension(40, 40));
        copy.setToolTipText("Copy result to clipboard");
        copy.addActionListener(e ->
        {
            StringSelection selection = new StringSelection(line2);
            Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
            clipboard.setContents(selection, null);
        });

        add(copy, BorderLayout.EAST);
    }
}
/*
 * Copyright (c) 2020, Spedwards <https://github.com/Spedwards>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.calculatorpro.uiSpedwards;

import java.awt.BorderLayout;
import java.awt.Dimension;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import lombok.Getter;

public class DisplayPanel extends JPanel
{
    @Getter
    private final DisplayField displayField = new DisplayField();

    public DisplayPanel()
    {
        super();

        setLayout(new BorderLayout(4, 4));
        setBorder(new EmptyBorder(0, 1, 0, 1));

        displayField.setPreferredSize(new Dimension(228, 50));
        displayField.setMinimumSize(new Dimension(170, 50));
        displayField.setEditable(false);

        add(displayField, BorderLayout.CENTER);

    }
}
/*
 * Copyright (c) 2023,  <https://github.com/kanderson66/Calculator-Pro>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.calculatorpro;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("calculatorpro")
public interface CalculatorProConfig extends Config {
	@ConfigItem(
			position = 1,
			keyName = "panel",
			name = "Panel Active",
			description = "Configures whether to turn the Calculator panel on or off"
	)
	default boolean panelActive()
	{
		return true;
	}

	@ConfigItem(
			position = 2,
			keyName = "calculate",
			name = "Calculator Command",
			description = "Configures whether the Calculator command is enabled  !calc 3*4"
	)
	default boolean calcCommand()
	{
		return true;
	}

	@ConfigItem(
			position = 3,
			keyName = "numDecimals",
			name = "Decimals to Display",
			description = "Configures how many decimal places to display on the Calculator chat result (max 15)"
	)
	default int numDecimals() {
		return 3;
	}

	//Make section for instructions, so they can be collapsible
	@ConfigSection(
			name = "Chatbox Instructions",
			description = "How to use the calculator in the chatbox",
			position = 4,
			closedByDefault = false
	)
	String instructionSection = "instructions";

	//STRING VALUE (TEXTBOX) collapsible instructions
	@ConfigItem(
			position = 5,
			keyName = "instructions",
			name = "Instructions",
			description = "How to use the calculator in the chatbox",
			section = instructionSection
	)
	default String instructions()
	{
		return "Call the calculator through the chatbox using:" +
				"\n!calc 2+3\n\n" +
				"You can create a tag for the result: \n!calc [tagName] 2+3" +
				"\n\nIf a [tagName] is not provided for the result, an auto-generated name will be supplied\n\n" +
				"You can reference tags in your equation:\n" +
				"!calc 5*tagName+3\n\n"+
				"You can clear all tags created through the chatbox, or only remove a certain tag:\n" +
				"!calc !clear\n!calc !remove tagName\n\n" +
				"There are some built-in tags:\n" +
				"lvl1  --experience at lvl 1, up to\nlvl126\n" +
				"last  --result of last calculation\n\n" +
				"Math functions such as ^2, sqrt, sin, cos, tan are also supported:\n" +
				"!calc sqrt(9^3)\n\n" +
				"Handles complex calculations:\n!calc 5*((tagName+2)-cos(2+6)/3)";
	}

	@ConfigSection(
			name = "Custom Tags",
			description = "Text-based custom tags",
			position = 6)
	String customTagsSection = "Custom Tags";

	@ConfigItem(
			keyName = "customTags",
			name = "Custom Tags",
			description = "Tags to use in the calculator",
			section = customTagsSection,
			position = 7
	)
	default String customTags() {
		return "tag1=123\noak=37.5\nexample=oak+tag1\n\n###\nInsert tags above this line, notes below this line"
				+"\n\nTags should look like this:\n"
				+"tagName=###\n\nWhere \"tagName\" is at least 1 letter, and can contain letters and numbers, but no symbols"
				+"\n\nAnd \"###\" is a real number or equation (negative numbers, scientific notation (33k), fractions and decimals are ok)"
				+"\n\nYou can then reference these tags in your equation\n!calc 4*tagName";
	}

	@ConfigSection(
			name = "Custom Equation",
			description = "Text-based custom equation",
			position = 8)
	String customEquationSection = "Custom Equation";

	@ConfigItem(
			keyName = "customEquation",
			name = "Custom Equation",
			description = "Equation to execute by calling \"!calc\" with nothing after it",
			section = customEquationSection,
			position = 9
	)
	default String customEquation() {
		return "[tag] (lvl99-lvl60)/oak\n\n" +
				"###\nWrite the equation you want to execute on the top line of this textbox. " +
				"Long equations that wrap onto a new line are ok\n\n" +
				"Execute this equation in-game by calling: \n" +
				"!calc \n" +
				"in-game with nothing after it";
	}
}
/*
 * Copyright (c) 2023,  <https://github.com/kanderson66/Calculator-Pro>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.calculatorpro;

import com.google.inject.Provides;
import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.MessageNode;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatCommandManager;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import javax.inject.Inject;
import java.io.IOException;
import java.math.RoundingMode;
import java.text.DecimalFormat;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import com.calculatorpro.uiSpedwards.CalculatorPluginPanel;
import java.awt.image.BufferedImage;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import java.io.InputStream;
import javax.imageio.ImageIO;
import net.runelite.client.util.ImageUtil;

@PluginDescriptor(
		name = "Calculator Pro",
		description = "Perform calculations using the side panel or in-game chat commands",
		tags = {"calculator", "math", "chat", "command"}
)
public class CalculatorProPlugin extends Plugin {
	//calc panel from Spedwards
	@Inject
	private ClientToolbar clientToolbar;
	private NavigationButton navButton;
	//end calc panel from Spedwards
	@Inject
	private CalculatorProConfig config;
	@Inject
	private ChatCommandManager chatCommandManager;
	@Inject
	private Client client;

	private static final String CALCULATE_STRING = "!calc";

	//store xp values of each lvl (lvl 1-126)
	final HashMap<String, String> lvlTags = new HashMap<>();
	//store custom tags from config panel
	final HashMap<String, String> configTags = new HashMap<>();
	//store tags made by user during runtime (last, etc)
	final HashMap<String, String> runTimeTags = new HashMap<>();

	//store whether the panel is currently active or not
	boolean panelActive = false;

	//track autoTag values
	boolean needAutoTag;
	int autoTag = 0;

	//ignore checking in runTimeTags if new tag is coming from Config textbox
	boolean isConfigTag=false;

	//store the newTagName (after tagName is valid, wait for value to pass check)
	String newTagName;
	//Message to output (Error/result)
	String output;
	//Store equation from Config textbox
	String customEquation ="";

	@Override
	public void startUp() {
		//load lvl xp tags (lvl 1-126)
		loadLvlTags();
		//load runTime tags (default with a0-a9 with value 0)
		loadRunTimeTags();
		//load tags & equation from Config text boxes
		reloadTags();

		//watch for !calc keyword in chat, perform calculate function if found
		chatCommandManager.registerCommandAsync(CALCULATE_STRING, this::calculate);

		CalculatorPluginPanel panel = new CalculatorPluginPanel();

		BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/icon.png");

		navButton = NavigationButton.builder()
				.tooltip("Calculator Pro")
				.priority(7)
				.icon(icon)
				.panel(panel)
				.build();

		if (config.panelActive()){
			clientToolbar.addNavigation(navButton);
			panelActive = true;
		}
	}
	@Override
	public void shutDown() {

		chatCommandManager.unregisterCommand(CALCULATE_STRING);

		//calc panel from Spedwards
		if (panelActive){
			clientToolbar.removeNavigation(navButton);
			panelActive = false;
		}
		//end calc panel from Spedwards
	}
	//adds Calculator Pro to config panel
	@Provides
	CalculatorProConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(CalculatorProConfig.class);
	}
	//load tags for xp at each lvl (lvl1-lvl126)
	public void loadLvlTags(){
		//Formula from Wiki 'Experience' page (see 'Formula')
		for(Integer lvl = 1;lvl<127;lvl++){
			lvlTags.put("lvl"+ lvl,Integer.toString(Integer.valueOf((int)eval("(1/8)*("+ lvl+"^2-"+ lvl+"+600*((2^("+ lvl+"/7)-2^(1/7)))/(2^(1/7)-1))-("+ lvl+"/10)"))));
		}
	}

	//reserve last and a0-a9 tags for autoTag (not a hard reserve)
	private void loadRunTimeTags(){
		runTimeTags.put("last","0");

		for(;autoTag<10;autoTag++){
			runTimeTags.put("a"+autoTag,"0");
		}
		autoTag=0;
	}

	//detect change in Config textbox, update tags & equation
	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged) {
		if (configChanged.getGroup().equals("calculatorpro")) {
			reloadTags();

			//todo: check if custom equation changed (and != ""), output to chat (no !calc command needed)
			//client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Example says ", null);

			if (!config.panelActive() && panelActive){
				clientToolbar.removeNavigation(navButton);
				panelActive = false;
			}
			if (config.panelActive() && !panelActive){
				clientToolbar.addNavigation(navButton);
				panelActive = true;
			}
		}
	}

	//clear current config panel Tags & equation & update with new tags from Config Text boxes
	private void reloadTags()
	{
		configTags.clear();
		customEquation="";

		loadTags(config.customTags());
		loadEquation(config.customEquation());
	}

	//load tags from Config text box
	private void loadTags(String textbox)
	{
		//HashMap<String, String> swaps = new HashMap<String, String>();
		for (String line : textbox.split("\n")) {
			//get next line if this line is empty
			if (line.trim().equals("")) {
				continue;
			}
			//end of tags, now entering notes
			if(line.trim().equals("###")){
				break;
			}
			line=line.toLowerCase();
			line=line.replaceAll("\\s","");
			//Split string between tag & value
			String[] split = line.split("=");

			//check if tag has name (possibly empty) and value
			if (split.length != 2){
				System.out.println("no value");
				continue;
			}
			//validate the tag
			// config tag skips looking in runTime tags (replace it if exists, after value validated)
			isConfigTag = true;
			if (!checkTagName(split[0])) {
				isConfigTag = false;
				continue;
			}
			isConfigTag = false;

			//validate the value of the tag
			String correctedEquation = checkEquation(split[1]);

			//Error with tag value- dont add
			if (correctedEquation.charAt(0)=='E'){
				System.out.println(correctedEquation);
				continue;
			}
			//add tag
			configTags.put(split[0], correctedEquation);

			//remove tag from runTimeTags if it exists
			if(runTimeTags.get(split[0])!=null){
				runTimeTags.remove(split[0]);
			}
		}
	}

	//load equation from Config text box
	private void loadEquation(String textbox)
	{
		//add a new line incase user has equation on 1 line w/o any new lines
		textbox = textbox +"\n";
		String[] equation = textbox.split("\n",2);

		customEquation = equation[0];
		if (customEquation.isEmpty()){
			customEquation = "Error- Custom Equation box is empty";
			return;
		}
		customEquation = customEquation.toLowerCase();
		//remove any whitespaces and , in equation
		customEquation = customEquation.replaceAll("\\s","");
		customEquation = customEquation.replaceAll(",","");
	}

	//check that the config or runTime tag is valid
	private boolean checkTagName(String newTagString){
        /*
            ERRORS TO CHECK
            -value not # DONE
            -value has spaces DONE
            -tag name needs at least 1 letter DONE
            -tag name contain only numbers and/or letters DONE
            -tag name doesnt already exist DONE
         */

		//ensure tag has a name
		if(newTagString.isEmpty()){
			output = "Error- no tag name";
			System.out.println(output);
			return false;
		}
		//tag name contains at least 1 letter
		if(!newTagString.matches(".*[a-z]+.*")){
			output = "Error- tag name (no letters): \""+newTagString+"\"";
			System.out.println(output);
			return false;
		}
		//tag name contains only letters and/or #s
		int len = newTagString.length();
		for (int i = 0; i < len; i++) {
			if (!Character.isLetterOrDigit(newTagString.charAt(i))) {
				output = "Error- tag name (contains symbols): \""+newTagString+"\"";
				System.out.println(output);
				return false;
			}
		}
		//check if tag already exists
		if(configTags.get(newTagString)!=null || lvlTags.get(newTagString)!= null){
			output = "Error- tag \""+newTagString+"\" already exists";
			System.out.println(output);
			return false;
		}
		//config tag overrides tags in runTimeTags
		if(!isConfigTag && runTimeTags.get(newTagString)!= null){
			output = "Error- tag \""+newTagString+"\" already exists";
			System.out.println(output);
			return false;
		}
		//check if tag is reserved
		switch (newTagString){
			case "sqrt":
			case "cos":
			case "sin":
			case "tan":
				output = "Error- tag \""+newTagString+"\" is reserved for math operations";
				System.out.println(output);
				return false;
			case "last":
			case "a0":
			case "a1":
			case "a2":
			case "a3":
			case "a4":
			case "a5":
			case "a6":
			case "a7":
			case "a8":
			case "a9":
				output = "Error- tag \""+newTagString+"\" is reserved for default tags";
				System.out.println(output);
				return false;
			default:
				break;
		}
		return true;
	}

	//check that the Config tag value is a real number
	//no longer used- value now passed to checkEquation to allow for tags in value
//    private boolean checkTagValue(String newTagString){
//        //can we pass into checkEquation here to allow for tag names in config tags?
//            //no, checkTagValue only allows #s, no math symbols
//
//        //checks tag value only real # (+'ve or -'ve, whole # or decimal, no letters)
//        // ^-? start of string contains 0 or 1 '-'
//        // \\d+ followed by 1 or more #s
//        // \\.? followed by 0 or 1 . (decimal point)
//        // \\d* followed by 0 or more #s
//        // $ end of string
//        if(!Pattern.matches("^-?\\d+\\.?\\d*$",newTagString)){
//            output = "Error- tag value can only contain #s: "+newTagString;
//            System.out.println(output);
//            return false;
//        }
//        return true;
//    }

	//perform all checks, commands, calculations and tagging
	private void calculate(ChatMessage chatMessage, String equation) {
		//command turned off
		if (!config.calcCommand()) {
			return;
		}
		output ="";
		newTagName="";
		needAutoTag = false;
		Double answer = 0.0;

		equation=equation.toLowerCase();
		//remove any whitespaces and , in equation
		equation=equation.replaceAll("\\s","");

		//remove !calc beginning
		String[] split=equation.split("!calc");

		//check if nothing entered after !calc
		switch (split.length){
			case 0:
				//check if Custom Equation was valid
				if(customEquation.charAt(0)=='E'){
					build(equation, customEquation, answer.toString(), chatMessage);
					return;
				}
				//get equation from Custom Equation textbox in Config Panel
				equation = customEquation;
				break;
			case 2:
				//success
				//get equation from chatbox w/o !calc command
				equation = split[1];
				break;
			default:
				//should never reach, but just for safety
				build(equation, "Error- invalid entry", answer.toString(), chatMessage);
				return;
		}

		//check for header (!command or [tagName])
		if(equation.charAt(0)=='!' || equation.charAt(0) =='['){
			equation = checkHeaders(equation);
			if(output.charAt(0)=='E' || output.equals("Command Complete")){
				//print output
				build(equation, output, answer.toString(), chatMessage);
				return;
			}
		} //equation is removed of !calc and any !commands or [tagName]

		//no [tagName] entered, add new autoTag
		else{
			needAutoTag = true;
		}

		//check equation for errors, replace any variables needed
		String correctedEquation = checkEquation(equation);

		//Check for error message
		if (correctedEquation.charAt(0) == 'E') {
			build(equation, correctedEquation, answer.toString(), chatMessage);
			return;
		}

		//evaluate expression, remove any , present
		answer = eval(correctedEquation.replaceAll(",",""));

		//check for divide by 0 error message ("Infinity")
		if(answer.toString().charAt(0)=='I'){
			build(equation, correctedEquation, answer.toString(), chatMessage);
			return;
		}

		//reduce answer to desired # decimal places or less & include commas for easier reading
		String format = "#,###";

		if (config.numDecimals() > 0)
		{
			format += ".";

			//limit decimal points to 15 places
			if(config.numDecimals() > 15)
			{
				for (int n=0; n<15; n++)
				{
					format += "#";
				}
			}
			else
			{
				for (int n=0; n<config.numDecimals(); n++)
				{
					format += "#";
				}
			}
		}
		DecimalFormat df = new DecimalFormat(format);
		df.setRoundingMode(RoundingMode.HALF_UP);

		//update runTimeTags to include last & custom tag or default tag (a1-a9)
		addNewTag(df.format(answer));

		//output results
		build(equation, correctedEquation, "["+newTagName+"] "+df.format(answer), chatMessage);
	}

	//check !command or [newTag] are valid
	//returns just equation, no !command or [tagName]
	public String checkHeaders(String input){
		//input is either [tagName] equation or !command ????
		String[] split;

		switch (input.charAt(0)){
			//check if new tag name & separate tag name from equation
			case '[':
				split=input.split("\\[");
				split=split[1].split("]");
				//check if tag name was followed by ]
				if(split.length<2){
					output = "Error- missing ']' or missing equation after ']'";
					return input;
				}
				//remove whitespace from tag name
				split[0]=split[0].replaceAll("\\s","");
				if(!checkTagName(split[0])){
					return input;
				} //split[0] has tagName split[1] has equation

				//valid tag. Save name to assign if value also passes
				newTagName = split[0];
				output = split[1];
				break;
			case '!':
				//!clear command. Clear all saved values, but keep last if currently set
				if (input.equals("!clear")){
					String temp = "0";
					if(runTimeTags.get("last")!=null){
						temp = runTimeTags.get("last");
					}
					runTimeTags.clear();
					loadRunTimeTags();
					runTimeTags.replace("last",temp);
					autoTag = 0;
					output = "Command Complete";
					return input;
				}
				//!remove command
				else if (input.charAt(1)=='r') {
					split = input.split("!remove");
					//nothing after !remove
					if(split.length!=2){
						output = "Error- invalid command. Usage: !remove tagName";
						return input;
					}

					//tagName not found in runTimeTags (cant remove tags from other HashMaps)
					if(runTimeTags.get(split[1])==null){
						output = "Error- tagName not found. Usage: !remove tagName";
						return input;
					}
					//remove the desired tag from runTimeTags
					runTimeTags.remove(split[1]);
					output = "Command Complete";
					return "!remove "+split[1];
				} //end !remove command
				else{
					output = "Error- unknown command";
					return input;
				}
			default:
				//should never reach
				output = "Error- headers";
				return input;
		}//end switch 1st character
		//returns the equation w/o headers
		return output;
	}

	//check equation will evaluate properly (no illegal characters or tags, etc)
	//input just equation (no !command or [tagName])
	public String checkEquation(String input) {

		//check no illegal characters or spaces
		//remove any math symbols
		Pattern p = Pattern.compile("(.{1})");
		Matcher m = p.matcher("(),.+-/*^");
		String temp = input.replaceAll(m.replaceAll("\\\\$1\\|"), "");


		//check if remaining are just letters and #s
		int len = temp.length();
		for (int i = 0; i < len; i++) {
			if (!Character.isLetterOrDigit(temp.charAt(i))) {
				output = "Error- unsupported symbols";
				return output;
			}
		}

		//split equation into individual components
		String[] components = input.split("(?<=[-+*/^()\\[\\]])|(?=[-+*/^()\\[\\]])");

		//check # ) never above # (
		int length=components.length;
		int countOpenParen = 0;
		int countClosedParen = 0;
		//for(int n=0;n<length;n++){
		for(String component : components){
			switch (component){
				case "(":
					countOpenParen++;
					break;
				case ")":
					countClosedParen++;
					if(countClosedParen>countOpenParen){
						output = "Error- found ) before (";
						return output;
					}
					break;
				default:
					break;
			}
		}

		//check all math operators legal
		for(int n=0;n<length;n++){
			// -+*/^( cant be followed by +*/^)
			switch(components[n]){
				case "+":
				case "-":
				case "*":
				case "/":
				case "^":
				case "(":
					if(n+1 != length){
						switch (components[n+1]){
							case "+":
							case "*":
							case "/":
							case "^":
							case ")":
								output = "Error- 2 math operators together";
								return output;
							default:
								break;
						}
					} else{
						output = "Error- cant end equation in math operator";
						return output;
					}
			}
			//add * before ( if needed  ("56(4-2)" changes to "56*(4-2)")
			if(components[n].equals("(") && n!=0){
				switch (components[n-1]){
					case "+":
					case "-":
					case "*":
					case "/":
					case "^":
					case "(":
					case "sqrt":
					case "cos":
					case "sin":
					case "tan":
						break;
					default:
						components[n]="*(";
						break;
				}
				//add * after ) if not end of equation, or followed by math operator
			} else if (components[n].equals(")") && n+1!=length) {
				switch (components[n+1]) {
					case "+":
					case "-":
					case "*":
					case "/":
						break;
					default:
						components[n] = ")*";
						break;
				}
			}
			//dont allow math tag at end of equation
			switch (components[n]){
				case "sqrt":
				case "cos":
				case "sin":
				case "tan":
					if(n+1==length){
						output = "Error- math tag not followed by (###)";
						return output;
					} else if (!components[n+1].equals("(")) {
						output = "Error- math tag not followed by (###)";
						return output;
					}
					break;
				default:
					break;
			}

			//check . is before at least 1 # & only 1 in component
			if(components[n].matches(".*[.]+.*")){
				String[] split = components[n].split("\\.");
				if (split.length != 2){
					output = "Error- incorrect decimal usage";
					return output;
				}
			}

			//if component contains a letter, its a tag or scientific notation (ignore math tags (sqrt, sin, cos, tan))
			if(components[n].matches(".*[a-zA-Z]+.*")){
				switch (components[n]){
					case "sqrt":
					case "cos":
					case "sin":
					case "tan":
						break;
					default:
						//check for scientific notation
						//component would be # ended in k m or b (10.6k)
						String[] split = components[n].split("(?=[k|m|b])");

						//check for possible scientific notation (### k)
						if (split[0].matches("\\d+.+|\\d+") && split.length == 2) {

							boolean isScientific = false;

							//check if 2nd index is scientific notation
							switch (split[1]) {
								case "k":
									components[n]= "(" + split[0] + "*1000)";
									isScientific = true;
									break;
								case "m":
									components[n]= "(" + split[0] + "*1000000)";
									isScientific = true;
									break;
								case "b":
									components[n]= "(" + split[0] + "*1000000000)";
									isScientific = true;
									break;
								default:
									break;
							}
							//dont check if is a tag if is scientific notation
							if (isScientific){
								break;
							}
						}

						//check if is a tag
						if (configTags.get(components[n])!=null){
							components[n]=configTags.get(components[n]);
						} else if(lvlTags.get(components[n])!=null){
							components[n]=lvlTags.get(components[n]);
						} else if(runTimeTags.get(components[n])!=null){
							components[n]=runTimeTags.get(components[n]);
						} else{
							output = "Error- no \""+components[n]+"\" tag found";
							System.out.println(output);
							return output;
						}
						break;
				} //end switch
			} //end if
		} //end for

		//convert components back into 1 string
		output="";
		for (String component : components) {
			output += component;
		}

		//add missing ) if needed
		for (int n=0; n<(countOpenParen-countClosedParen); n++){
			output += ")";
		}
		return output;
	}

	//evaluate string math equation
	public static double eval(final String str) {
		return new Object() {
			int pos = -1, ch;

			void nextChar() {
				ch = (++pos < str.length()) ? str.charAt(pos) : -1;
			}

			boolean eat(int charToEat) {
				while (ch == ' ') nextChar();
				if (ch == charToEat) {
					nextChar();
					return true;
				}
				return false;
			}

			double parse() {
				nextChar();
				double x = parseExpression();
				if (pos < str.length()) throw new RuntimeException("Unexpected: " + (char) ch);
				return x;
			}

			// Grammar:
			// expression = term | expression `+` term | expression `-` term
			// term = factor | term `*` factor | term `/` factor
			// factor = `+` factor | `-` factor | `(` expression `)` | number
			//        | functionName `(` expression `)` | functionName factor
			//        | factor `^` factor

			double parseExpression() {
				double x = parseTerm();
				for (; ; ) {
					if (eat('+')) x += parseTerm(); // addition
					else if (eat('-')) x -= parseTerm(); // subtraction
					else return x;
				}
			}

			double parseTerm() {
				double x = parseFactor();
				for (; ; ) {
					if (eat('*')) x *= parseFactor(); // multiplication
					else if (eat('/')) x /= parseFactor(); // division
					else return x;
				}
			}

			double parseFactor() {
				if (eat('+')) return +parseFactor(); // unary plus
				if (eat('-')) return -parseFactor(); // unary minus

				double x;
				int startPos = this.pos;
				if (eat('(')) { // parentheses
					x = parseExpression();
					if (!eat(')')) throw new RuntimeException("Missing ')'");
				} else if ((ch >= '0' && ch <= '9') || ch == '.') { // numbers
					while ((ch >= '0' && ch <= '9') || ch == '.') nextChar();
					x = Double.parseDouble(str.substring(startPos, this.pos));
				} else if (ch >= 'a' && ch <= 'z') { // functions
					while (ch >= 'a' && ch <= 'z') nextChar();
					String func = str.substring(startPos, this.pos);
					if (eat('(')) {
						x = parseExpression();
						if (!eat(')')) throw new RuntimeException("Missing ')' after argument to " + func);
					} else {
						x = parseFactor();
					}
					switch (func) {
						case "sqrt":
							x = Math.sqrt(x);
							break;
						case "sin":
							x = Math.sin(Math.toRadians(x));
							break;
						case "cos":
							x = Math.cos(Math.toRadians(x));
							break;
						case "tan":
							x = Math.tan(Math.toRadians(x));
							break;
						default:
							throw new RuntimeException("Unknown function: " + func);
					}
				} else {
					throw new RuntimeException("Unexpected: " + (char) ch);
				}

				if (eat('^')) x = Math.pow(x, parseFactor()); // exponentiation

				return x;
			}
		}.parse();
	}

	//add new tag & value to runTimeTags
	public void addNewTag(String value){
		//add auto tag (no tag name provided)
		if(needAutoTag){
			//only hold 10 auto-tags (a0-a9), then write-over old auto tags
			if(autoTag==10){
				autoTag=0;
			}

			newTagName = "a"+autoTag++;

			if (runTimeTags.get(newTagName)!=null) {
				runTimeTags.remove(newTagName);
			}
			runTimeTags.put(newTagName,value);
		}

		//add new tag & value
		else{
			runTimeTags.put(newTagName,value);
		}

		//update "last" tag to last result value
		if(runTimeTags.get("last")!=null){
			runTimeTags.remove("last");
		}
		runTimeTags.put("last",value);
	}

	//build chat message (error or result)
	public void build(final String equ, String corEqu, String ans, ChatMessage chatMessage) {
		String response;
		//error message received, print error message
		if (corEqu.charAt(0) == 'E' || corEqu.charAt(0)=='C'){
			System.out.println(equ + " " + corEqu);
			response = new ChatMessageBuilder()
					.append(ChatColorType.NORMAL)
					.append(equ)
					.append(ChatColorType.HIGHLIGHT)
					.append(" "+corEqu)
					.build();
		} else if (ans.charAt(0) == 'I') {
			System.out.println(equ + " Error- cannot divide by 0");
			//build new message
			response = new ChatMessageBuilder()
					.append(ChatColorType.NORMAL)
					.append(equ)
					.append(ChatColorType.HIGHLIGHT)
					.append(" Error- cannot divide by 0")
					.build();
		} else {
			//build new message
			response = new ChatMessageBuilder()
					.append(ChatColorType.NORMAL)
					.append(equ)
					.append(ChatColorType.HIGHLIGHT)
					.append(" equals ")
					.append(ChatColorType.NORMAL)
					.append(ans) //removed .toString()
					.build();
		}

		//print new message to chatbox
		final MessageNode messageNode = chatMessage.getMessageNode();
		messageNode.setRuneLiteFormatMessage(response);
		client.refreshChat();
	}
}
