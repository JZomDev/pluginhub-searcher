/*
 * Copyright (c) 2024, NullBot
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.osrschatlogger;

import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

import javax.inject.Inject;
import java.awt.*;

/**
 * Overlay showing OSRS Chatlogger connection status.
 */
public class OsrsChatloggerOverlay extends Overlay
{
    private static final Color COLOR_CONNECTED = new Color(0, 200, 83);
    private static final Color COLOR_DISCONNECTED = new Color(255, 82, 82);
    private static final Color COLOR_PENDING = new Color(255, 193, 7);
    private static final Color COLOR_INFO = new Color(100, 181, 246);

    private final Client client;
    private final OsrsChatloggerConfig config;
    private final ChatSender chatSender;
    private final PanelComponent panelComponent = new PanelComponent();

    @Inject
    public OsrsChatloggerOverlay(Client client, OsrsChatloggerConfig config, ChatSender chatSender)
    {
        this.client = client;
        this.config = config;
        this.chatSender = chatSender;

        setPosition(OverlayPosition.TOP_LEFT);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPriority(OverlayPriority.LOW);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        // Check if overlay should be shown
        if (!config.showOverlay())
        {
            return null;
        }

        // Check if API key is configured
        String apiKey = config.apiKey();
        if (apiKey == null || apiKey.isEmpty())
        {
            return null;
        }

        panelComponent.getChildren().clear();

        // Title
        panelComponent.getChildren().add(TitleComponent.builder()
            .text("Chatlogger")
            .color(Color.WHITE)
            .build());

        // Connection status
        boolean connected = chatSender.isConnected();
        panelComponent.getChildren().add(LineComponent.builder()
            .left("Status:")
            .right(connected ? "Connected" : "Disconnected")
            .rightColor(connected ? COLOR_CONNECTED : COLOR_DISCONNECTED)
            .build());

        // Message counts
        if (config.showMessageCount())
        {
            int sent = chatSender.getSentCount();
            int pending = chatSender.getPendingCount();

            panelComponent.getChildren().add(LineComponent.builder()
                .left("Sent:")
                .right(formatNumber(sent))
                .rightColor(COLOR_INFO)
                .build());

            if (pending > 0)
            {
                panelComponent.getChildren().add(LineComponent.builder()
                    .left("Pending:")
                    .right(String.valueOf(pending))
                    .rightColor(COLOR_PENDING)
                    .build());
            }
        }

        // Show username if connected
        String username = chatSender.getUsername();
        if (connected && username != null && !username.isEmpty())
        {
            panelComponent.getChildren().add(LineComponent.builder()
                .left("User:")
                .right(username)
                .rightColor(Color.WHITE)
                .build());
        }

        return panelComponent.render(graphics);
    }

    /**
     * Format large numbers with K/M suffix.
     */
    private String formatNumber(int number)
    {
        if (number >= 1_000_000)
        {
            return String.format("%.1fM", number / 1_000_000.0);
        }
        else if (number >= 1_000)
        {
            return String.format("%.1fK", number / 1_000.0);
        }
        return String.valueOf(number);
    }
}

/*
 * Copyright (c) 2024, NullBot
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.osrschatlogger;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;

@ConfigGroup("osrschatlogger")
public interface OsrsChatloggerConfig extends Config
{
    // =========================================================================
    // API Configuration
    // =========================================================================
    
    @ConfigSection(
        name = "API Settings",
        description = "Configure your OSRS Chatlogger API connection",
        position = 0
    )
    String apiSection = "apiSection";

    @ConfigItem(
        keyName = "apiKey",
        name = "API Key",
        description = "Your OSRS Chatlogger API key (get one at osrschatlogger.com/settings/api)",
        position = 1,
        section = apiSection,
        secret = true
    )
    default String apiKey()
    {
        return "";
    }

    @ConfigItem(
        keyName = "serverUrl",
        name = "Server URL",
        description = "OSRS Chatlogger server URL (default: https://osrschatlogger.com)",
        position = 2,
        section = apiSection
    )
    default String serverUrl()
    {
        return "https://osrschatlogger.com";
    }

    // =========================================================================
    // Chat Type Filters
    // =========================================================================
    
    @ConfigSection(
        name = "Chat Types",
        description = "Select which chat types to sync",
        position = 10
    )
    String chatTypesSection = "chatTypesSection";

    @ConfigItem(
        keyName = "logPublicChat",
        name = "Public Chat",
        description = "Log public chat messages",
        position = 11,
        section = chatTypesSection
    )
    default boolean logPublicChat()
    {
        return true;
    }

    @ConfigItem(
        keyName = "logPrivateChat",
        name = "Private Messages",
        description = "Log private messages (sent and received)",
        position = 12,
        section = chatTypesSection
    )
    default boolean logPrivateChat()
    {
        return true;
    }

    @ConfigItem(
        keyName = "logClanChat",
        name = "Clan Chat",
        description = "Log clan chat messages",
        position = 13,
        section = chatTypesSection
    )
    default boolean logClanChat()
    {
        return true;
    }

    @ConfigItem(
        keyName = "logGroupChat",
        name = "Group Ironman Chat",
        description = "Log Group Ironman chat messages",
        position = 14,
        section = chatTypesSection
    )
    default boolean logGroupChat()
    {
        return true;
    }

    @ConfigItem(
        keyName = "logFriendsChat",
        name = "Friends Chat",
        description = "Log friends chat (FC) messages",
        position = 15,
        section = chatTypesSection
    )
    default boolean logFriendsChat()
    {
        return true;
    }

    @ConfigItem(
        keyName = "logGameMessages",
        name = "Game Messages",
        description = "Log game messages (drops, level ups, etc.)",
        position = 16,
        section = chatTypesSection
    )
    default boolean logGameMessages()
    {
        return true;
    }

    @ConfigItem(
        keyName = "logTradeRequests",
        name = "Trade Requests",
        description = "Log trade requests",
        position = 17,
        section = chatTypesSection
    )
    default boolean logTradeRequests()
    {
        return false;
    }

    // =========================================================================
    // Display Options
    // =========================================================================
    
    @ConfigSection(
        name = "Display",
        description = "Overlay and display settings",
        position = 20
    )
    String displaySection = "displaySection";

    @ConfigItem(
        keyName = "showOverlay",
        name = "Show Status Overlay",
        description = "Show connection status overlay in-game",
        position = 21,
        section = displaySection
    )
    default boolean showOverlay()
    {
        return true;
    }

    @ConfigItem(
        keyName = "showMessageCount",
        name = "Show Message Count",
        description = "Show number of messages synced in overlay",
        position = 22,
        section = displaySection
    )
    default boolean showMessageCount()
    {
        return true;
    }

    // =========================================================================
    // Advanced Options
    // =========================================================================
    
    @ConfigSection(
        name = "Advanced",
        description = "Advanced configuration options",
        position = 30,
        closedByDefault = true
    )
    String advancedSection = "advancedSection";

    @ConfigItem(
        keyName = "batchSize",
        name = "Batch Size",
        description = "Number of messages to batch before sending (1-50)",
        position = 31,
        section = advancedSection
    )
    @Range(min = 1, max = 50)
    default int batchSize()
    {
        return 10;
    }

    @ConfigItem(
        keyName = "batchDelayMs",
        name = "Batch Delay (ms)",
        description = "Max time to wait before sending batch (500-10000ms)",
        position = 32,
        section = advancedSection
    )
    @Range(min = 500, max = 10000)
    default int batchDelayMs()
    {
        return 2000;
    }

    @ConfigItem(
        keyName = "retryAttempts",
        name = "Retry Attempts",
        description = "Number of retry attempts on failure (0-5)",
        position = 33,
        section = advancedSection
    )
    @Range(min = 0, max = 5)
    default int retryAttempts()
    {
        return 3;
    }

    @ConfigItem(
        keyName = "debugMode",
        name = "Debug Mode",
        description = "Enable debug logging (check RuneLite logs)",
        position = 34,
        section = advancedSection
    )
    default boolean debugMode()
    {
        return false;
    }
}

/*
 * Copyright (c) 2024, NullBot
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.osrschatlogger;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Handles sending chat messages to the OSRS Chatlogger server.
 * Features: batching, buffering, retry logic, connection status tracking.
 */
@Slf4j
@Singleton
public class ChatSender
{
    private static final MediaType JSON_MEDIA_TYPE = MediaType.parse("application/json; charset=utf-8");
    private static final int MAX_BUFFER_SIZE = 1000;
    private static final String USER_AGENT = "OSRS-Chatlogger-RuneLite/1.0";

    private final OkHttpClient httpClient;
    private final Gson gson;
    private final OsrsChatloggerConfig config;

    // Message buffer for batching
    private final List<ChatData> messageBuffer = new ArrayList<>();
    private final Object bufferLock = new Object();

    // Scheduled executor for batch sending
    private ScheduledExecutorService scheduler;
    private ScheduledFuture<?> batchTask;

    // Connection state
    private final AtomicBoolean connected = new AtomicBoolean(false);
    private final AtomicBoolean validated = new AtomicBoolean(false);
    private final AtomicInteger sentCount = new AtomicInteger(0);
    private final AtomicInteger pendingCount = new AtomicInteger(0);

    private volatile String username = null;

    @Inject
public ChatSender(OsrsChatloggerConfig config, Gson gson, OkHttpClient httpClient)
{
    this.config = config;
    this.gson = gson;
    this.httpClient = httpClient;

    startScheduler();
}

    private void startScheduler()
    {
        if (scheduler != null && !scheduler.isShutdown())
        {
            return;
        }

        scheduler = Executors.newSingleThreadScheduledExecutor(r -> {
            Thread t = new Thread(r, "osrs-chatlogger-sender");
            t.setDaemon(true);
            return t;
        });

        // Schedule periodic batch sending
        int delayMs = Math.max(500, Math.min(10000, config.batchDelayMs()));
        batchTask = scheduler.scheduleAtFixedRate(
            this::sendBatch,
            delayMs,
            delayMs,
            TimeUnit.MILLISECONDS
        );
    }

    /**
     * Validate the API key with the server.
     */
    public void validateApiKey()
    {
        String apiKey = config.apiKey();
        if (apiKey == null || apiKey.isEmpty())
        {
            log.warn("No API key configured");
            validated.set(false);
            connected.set(false);
            return;
        }

        if (!apiKey.startsWith("oscl_"))
        {
            log.warn("Invalid API key format - should start with 'oscl_'");
            validated.set(false);
            connected.set(false);
            return;
        }

        String url = config.serverUrl() + "/api/v1/auth/validate";

        Request request = new Request.Builder()
            .url(url)
            .post(RequestBody.create(JSON_MEDIA_TYPE, "{}"))
            .addHeader("Authorization", "Bearer " + apiKey)
            .addHeader("User-Agent", USER_AGENT)
            .build();

        httpClient.newCall(request).enqueue(new Callback()
        {
            @Override
            public void onFailure(Call call, IOException e)
            {
                log.error("Failed to validate API key: {}", e.getMessage());
                connected.set(false);
                validated.set(false);
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException
            {
                try (ResponseBody body = response.body())
                {
                    if (response.isSuccessful() && body != null)
                    {
                        String responseBody = body.string();
                        JsonObject json = new JsonParser().parse(responseBody).getAsJsonObject();
                        
                        if (json.has("valid") && json.get("valid").getAsBoolean())
                        {
                            username = json.has("username") ? json.get("username").getAsString() : null;
                            validated.set(true);
                            connected.set(true);
                            log.info("API key validated for user: {}", username);
                        }
                        else
                        {
                            validated.set(false);
                            connected.set(false);
                            log.warn("API key validation failed - key may be invalid or revoked");
                        }
                    }
                    else
                    {
                        validated.set(false);
                        connected.set(false);
                        log.warn("API key validation failed: HTTP {}", response.code());
                    }
                }
            }
        });
    }

    /**
     * Queue a message to be sent.
     */
    public void queueMessage(ChatData chatData)
    {
        if (!validated.get())
        {
            if (config.debugMode())
            {
                log.debug("Not queueing message - API key not validated");
            }
            return;
        }

        synchronized (bufferLock)
        {
            // Don't buffer too many messages
            if (messageBuffer.size() >= MAX_BUFFER_SIZE)
            {
                log.warn("Message buffer full, dropping oldest message");
                messageBuffer.remove(0);
            }

            messageBuffer.add(chatData);
            pendingCount.set(messageBuffer.size());

            if (config.debugMode())
            {
                log.debug("Queued message: {} (buffer size: {})", chatData, messageBuffer.size());
            }

            // Send immediately if batch is full
            int batchSize = Math.max(1, Math.min(50, config.batchSize()));
            if (messageBuffer.size() >= batchSize)
            {
                scheduler.submit(this::sendBatch);
            }
        }
    }

    /**
     * Send current batch of messages.
     */
    private void sendBatch()
    {
        List<ChatData> toSend;

        synchronized (bufferLock)
        {
            if (messageBuffer.isEmpty())
            {
                return;
            }

            // Copy and clear buffer
            toSend = new ArrayList<>(messageBuffer);
            messageBuffer.clear();
            pendingCount.set(0);
        }

        sendMessages(toSend, config.retryAttempts());
    }

    /**
     * Send a list of messages to the server.
     */
    private void sendMessages(List<ChatData> messages, int retriesLeft)
    {
        if (messages.isEmpty() || !validated.get())
        {
            return;
        }

        String url = config.serverUrl() + "/api/v1/chat/batch";

        // Build batch request
        JsonObject requestBody = new JsonObject();
        requestBody.add("messages", gson.toJsonTree(messages));

        // Include RSN and world from first message
        ChatData first = messages.get(0);
        if (first.getRsn() != null)
        {
            requestBody.addProperty("rsn", first.getRsn());
        }
        if (first.getWorld() > 0)
        {
            requestBody.addProperty("world", first.getWorld());
        }

        if (config.debugMode())
        {
            log.debug("Sending batch of {} messages", messages.size());
        }

        Request request = new Request.Builder()
            .url(url)
            .post(RequestBody.create(JSON_MEDIA_TYPE, requestBody.toString()))
            .addHeader("Authorization", "Bearer " + config.apiKey())
            .addHeader("User-Agent", USER_AGENT)
            .build();

        httpClient.newCall(request).enqueue(new Callback()
        {
            @Override
            public void onFailure(Call call, IOException e)
            {
                log.error("Failed to send messages: {}", e.getMessage());
                connected.set(false);
                handleSendFailure(messages, retriesLeft, e.getMessage());
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException
            {
                try (ResponseBody body = response.body())
                {
                    if (response.isSuccessful())
                    {
                        connected.set(true);
                        sentCount.addAndGet(messages.size());

                        if (config.debugMode())
                        {
                            log.debug("Successfully sent {} messages (total: {})", 
                                messages.size(), sentCount.get());
                        }
                    }
                    else if (response.code() == 429)
                    {
                        // Rate limited
                        String retryAfter = response.header("Retry-After", "60");
                        int waitSeconds = Integer.parseInt(retryAfter);
                        log.warn("Rate limited, waiting {} seconds", waitSeconds);

                        // Re-queue messages for later
                        scheduler.schedule(() -> {
                            synchronized (bufferLock)
                            {
                                messageBuffer.addAll(0, messages);
                                pendingCount.set(messageBuffer.size());
                            }
                        }, waitSeconds, TimeUnit.SECONDS);
                    }
                    else if (response.code() == 401)
                    {
                        // Invalid API key
                        validated.set(false);
                        connected.set(false);
                        log.error("API key rejected by server - please check your key");
                    }
                    else
                    {
                        log.warn("Server returned HTTP {}", response.code());
                        connected.set(false);
                        handleSendFailure(messages, retriesLeft, "HTTP " + response.code());
                    }
                }
            }
        });
    }

    private void handleSendFailure(List<ChatData> messages, int retriesLeft, String reason)
    {
        if (retriesLeft > 0)
        {
            // Exponential backoff
            int attempt = config.retryAttempts() - retriesLeft + 1;
            int delayMs = attempt * 2000;

            if (config.debugMode())
            {
                log.debug("Retry {} in {}ms: {}", attempt, delayMs, reason);
            }

            scheduler.schedule(() -> sendMessages(messages, retriesLeft - 1),
                delayMs, TimeUnit.MILLISECONDS);
        }
        else
        {
            // Re-buffer messages for later attempt
            log.warn("Failed to send {} messages after all retries, re-buffering", messages.size());
            synchronized (bufferLock)
            {
                // Add to front of buffer (oldest first)
                for (int i = messages.size() - 1; i >= 0; i--)
                {
                    if (messageBuffer.size() < MAX_BUFFER_SIZE)
                    {
                        messageBuffer.add(0, messages.get(i));
                    }
                }
                pendingCount.set(messageBuffer.size());
            }
        }
    }

    /**
     * Flush all buffered messages immediately.
     */
    public void flush()
    {
        sendBatch();
    }

    /**
     * Shutdown the sender gracefully.
     */
   public void shutdown()
{
    log.info("Shutting down ChatSender...");
    
    // Send any remaining messages
    flush();

    if (batchTask != null)
    {
        batchTask.cancel(false);
    }

    if (scheduler != null)
    {
        scheduler.shutdownNow();
    }
}

    // Status getters
    public boolean isConnected()
    {
        return connected.get() && validated.get();
    }

    public boolean isValidated()
    {
        return validated.get();
    }

    public int getSentCount()
    {
        return sentCount.get();
    }

    public int getPendingCount()
    {
        return pendingCount.get();
    }

    public String getUsername()
    {
        return username;
    }
}

/*
 * Copyright (c) 2024, NullBot
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.osrschatlogger;

import lombok.Data;

/**
 * Represents a chat message to be sent to the server.
 */
@Data
public class ChatData
{
    private String type;
    private String sender;
    private String message;
    private String timestamp;
    private String rsn;
    private int world;
    private String clan;
    private String ironmanType;

    public ChatData()
    {
    }

    public ChatData(String type, String sender, String message, String timestamp)
    {
        this.type = type;
        this.sender = sender;
        this.message = message;
        this.timestamp = timestamp;
    }

    @Override
    public String toString()
    {
        return String.format("ChatData{type=%s, sender=%s, message=%s, ironmanType=%s}", type, sender, message, ironmanType);
    }
}

/*
 * Copyright (c) 2024, NullBot
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.osrschatlogger;

import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

import javax.inject.Inject;
import java.time.Instant;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.EnumSet;
import java.util.Set;

@Slf4j
@PluginDescriptor(
    name = "OSRS Chatlogger",
    description = "Sync your chat messages to osrschatlogger.com in real-time",
    tags = {"chat", "log", "logger", "sync", "chatlogger", "osrs"}
)
public class OsrsChatloggerPlugin extends Plugin
{
    private static final DateTimeFormatter ISO_FORMATTER = 
        DateTimeFormatter.ISO_INSTANT.withZone(ZoneOffset.UTC);

    @Inject
    private Client client;

    @Inject
    private OsrsChatloggerConfig config;

    @Inject
    private ChatSender chatSender;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private OsrsChatloggerOverlay overlay;

    // Chat types to capture
    private static final Set<ChatMessageType> LOGGED_TYPES = EnumSet.of(
        ChatMessageType.PUBLICCHAT,
        ChatMessageType.MODCHAT,
        ChatMessageType.PRIVATECHAT,
        ChatMessageType.PRIVATECHATOUT,
        ChatMessageType.CLAN_CHAT,
        ChatMessageType.CLAN_MESSAGE,
        ChatMessageType.CLAN_GIM_CHAT,
        ChatMessageType.CLAN_GIM_MESSAGE,
        ChatMessageType.CLAN_GUEST_CHAT,
        ChatMessageType.CLAN_GUEST_MESSAGE,
        ChatMessageType.FRIENDSCHAT,
        ChatMessageType.TRADEREQ,
        ChatMessageType.GAMEMESSAGE,
        ChatMessageType.ENGINE,
        ChatMessageType.BROADCAST,
        ChatMessageType.SPAM
    );

    private String currentRsn = null;
    private int currentWorld = -1;

    @Override
    protected void startUp() throws Exception
    {
        log.info("OSRS Chatlogger started!");
        overlayManager.add(overlay);
        
        // Validate API key on startup
        if (isConfigured())
        {
            chatSender.validateApiKey();
        }
    }

    @Override
    protected void shutDown() throws Exception
    {
        log.info("OSRS Chatlogger stopped!");
        overlayManager.remove(overlay);
        chatSender.shutdown();
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event)
    {
        if (event.getGameState() == GameState.LOGGED_IN)
        {
            // Get player info when logged in
            if (client.getLocalPlayer() != null)
            {
                currentRsn = client.getLocalPlayer().getName();
                currentWorld = client.getWorld();
                log.debug("Logged in as {} on world {}", currentRsn, currentWorld);
                
                // Re-validate API key when logging into game
                if (isConfigured())
                {
                    chatSender.validateApiKey();
                }
            }
        }
        else if (event.getGameState() == GameState.LOGIN_SCREEN)
        {
            // Flush any remaining messages when logging out
            chatSender.flush();
            currentRsn = null;
            currentWorld = -1;
        }
    }

    @Subscribe
    public void onChatMessage(ChatMessage event)
    {
        // Check if plugin is configured
        if (!isConfigured())
        {
            return;
        }

        // Check if this message type should be logged
        ChatMessageType type = event.getType();
        if (!shouldLogType(type))
        {
            return;
        }

        // Build message data
        ChatData chatData = new ChatData();
        chatData.setType(mapChatType(type));
        chatData.setIronmanType(detectIronmanType(event.getName()));
        chatData.setSender(cleanName(event.getName()));
        chatData.setMessage(cleanMessage(event.getMessage()));
        chatData.setTimestamp(ISO_FORMATTER.format(Instant.now()));
        chatData.setRsn(currentRsn);
        chatData.setWorld(currentWorld);

        // Send to server
        chatSender.queueMessage(chatData);
    }

    private boolean isConfigured()
    {
        String apiKey = config.apiKey();
        return apiKey != null && !apiKey.isEmpty() && apiKey.startsWith("oscl_");
    }

    private boolean shouldLogType(ChatMessageType type)
    {
        if (!LOGGED_TYPES.contains(type))
        {
            return false;
        }

        // Check user preferences
        switch (type)
        {
            case PUBLICCHAT:
            case MODCHAT:
                return config.logPublicChat();
            
            case PRIVATECHAT:
            case PRIVATECHATOUT:
                return config.logPrivateChat();
            
            case CLAN_CHAT:
            case CLAN_MESSAGE:
            case CLAN_GUEST_CHAT:
            case CLAN_GUEST_MESSAGE:
                return config.logClanChat();
            
            case CLAN_GIM_CHAT:
            case CLAN_GIM_MESSAGE:
                return config.logGroupChat();
            
            case FRIENDSCHAT:
                return config.logFriendsChat();
            
            case GAMEMESSAGE:
            case ENGINE:
            case BROADCAST:
            case SPAM:
                return config.logGameMessages();
            
            case TRADEREQ:
                return config.logTradeRequests();
            
            default:
                return true;
        }
    }

    private String mapChatType(ChatMessageType type)
    {
        switch (type)
        {
            case PUBLICCHAT:
            case MODCHAT:
                return "PUBLIC";
            case PRIVATECHAT:
                return "PRIVATE";
            case PRIVATECHATOUT:
                return "PRIVATE_OUT";
            case CLAN_CHAT:
            case CLAN_MESSAGE:
                return "CLAN_CHAT";
            case CLAN_GUEST_CHAT:
            case CLAN_GUEST_MESSAGE:
                return "CLAN_GUEST";
            case CLAN_GIM_CHAT:
            case CLAN_GIM_MESSAGE:
                return "CLAN_GIM_CHAT";
            case FRIENDSCHAT:
                return "FRIENDSCHAT";
            case TRADEREQ:
                return "TRADE";
            case GAMEMESSAGE:
            case SPAM:
                return "GAME";
            case ENGINE:
                return "ENGINE";
            case BROADCAST:
                return "BROADCAST";
            default:
                return type.name();
        }
    }
    private String detectIronmanType(String name)
    {
        if (name == null)
        {
            return "";
        }
        if (name.contains("<img=2>")) return "ironman";
        if (name.contains("<img=10>")) return "hardcore";
        if (name.contains("<img=3>")) return "ultimate";
        if (name.contains("<img=41>")) return "group";
        return "";
    }
    
    private String cleanName(String name)
    {
        if (name == null)
        {
            return "";
        }
        // Remove img tags (ironman icons, etc.)
        return name.replaceAll("<img=\\d+>", "").trim();
    }

    private String cleanMessage(String message)
    {
        if (message == null)
        {
            return "";
        }
        // Remove color tags and formatting
        return message
            .replaceAll("<col=[^>]+>", "")
            .replaceAll("</col>", "")
            .replaceAll("<br>", "\n")
            .trim();
    }

    @Provides
    OsrsChatloggerConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(OsrsChatloggerConfig.class);
    }

    // Getters for overlay
    public boolean isConnected()
    {
        return chatSender.isConnected();
    }

    public int getPendingCount()
    {
        return chatSender.getPendingCount();
    }

    public int getSentCount()
    {
        return chatSender.getSentCount();
    }
}

