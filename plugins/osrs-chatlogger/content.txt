/*
 * Copyright (c) 2024, NullBot
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.osrschatlogger;

import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

import javax.inject.Inject;
import java.awt.*;

/**
 * Overlay showing OSRS Chatlogger connection status.
 */
public class OsrsChatloggerOverlay extends Overlay
{
    private static final Color COLOR_CONNECTED = new Color(0, 200, 83);
    private static final Color COLOR_DISCONNECTED = new Color(255, 82, 82);
    private static final Color COLOR_PENDING = new Color(255, 193, 7);
    private static final Color COLOR_INFO = new Color(100, 181, 246);

    private final Client client;
    private final OsrsChatloggerConfig config;
    private final ChatSender chatSender;
    private final PanelComponent panelComponent = new PanelComponent();

    @Inject
    public OsrsChatloggerOverlay(Client client, OsrsChatloggerConfig config, ChatSender chatSender)
    {
        this.client = client;
        this.config = config;
        this.chatSender = chatSender;

        setPosition(OverlayPosition.TOP_LEFT);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPriority(OverlayPriority.LOW);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        // Check if overlay should be shown
        if (!config.showOverlay())
        {
            return null;
        }

        // Check if API key is configured
        String apiKey = config.apiKey();
        if (apiKey == null || apiKey.isEmpty())
        {
            return null;
        }

        panelComponent.getChildren().clear();

        // Title
        panelComponent.getChildren().add(TitleComponent.builder()
            .text("Chatlogger")
            .color(Color.WHITE)
            .build());

        // Connection status
        boolean connected = chatSender.isConnected();
        panelComponent.getChildren().add(LineComponent.builder()
            .left("Status:")
            .right(connected ? "Connected" : "Disconnected")
            .rightColor(connected ? COLOR_CONNECTED : COLOR_DISCONNECTED)
            .build());

        // Message counts
        if (config.showMessageCount())
        {
            int sent = chatSender.getSentCount();
            int pending = chatSender.getPendingCount();

            panelComponent.getChildren().add(LineComponent.builder()
                .left("Sent:")
                .right(formatNumber(sent))
                .rightColor(COLOR_INFO)
                .build());

            if (pending > 0)
            {
                panelComponent.getChildren().add(LineComponent.builder()
                    .left("Pending:")
                    .right(String.valueOf(pending))
                    .rightColor(COLOR_PENDING)
                    .build());
            }
        }

        // Show username if connected
        String username = chatSender.getUsername();
        if (connected && username != null && !username.isEmpty())
        {
            panelComponent.getChildren().add(LineComponent.builder()
                .left("User:")
                .right(username)
                .rightColor(Color.WHITE)
                .build());
        }

        return panelComponent.render(graphics);
    }

    /**
     * Format large numbers with K/M suffix.
     */
    private String formatNumber(int number)
    {
        if (number >= 1_000_000)
        {
            return String.format("%.1fM", number / 1_000_000.0);
        }
        else if (number >= 1_000)
        {
            return String.format("%.1fK", number / 1_000.0);
        }
        return String.valueOf(number);
    }
}

/*
 * Copyright (c) 2024, NullBot
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.osrschatlogger;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;

@ConfigGroup("osrschatlogger")
public interface OsrsChatloggerConfig extends Config
{
    // =========================================================================
    // API Configuration
    // =========================================================================
    
    @ConfigSection(
        name = "API Settings",
        description = "Configure your OSRS Chatlogger API connection",
        position = 0
    )
    String apiSection = "apiSection";

    @ConfigItem(
        keyName = "apiKey",
        name = "API Key",
        description = "Your OSRS Chatlogger API key (get one at osrschatlogger.com/settings/api)",
        position = 1,
        section = apiSection,
        secret = true
    )
    default String apiKey()
    {
        return "";
    }

    @ConfigItem(
        keyName = "serverUrl",
        name = "Server URL",
        description = "OSRS Chatlogger server URL (default: https://osrschatlogger.com)",
        position = 2,
        section = apiSection
    )
    default String serverUrl()
    {
        return "https://osrschatlogger.com";
    }

    // =========================================================================
    // Chat Type Filters
    // =========================================================================
    
    @ConfigSection(
        name = "Chat Types",
        description = "Select which chat types to sync",
        position = 10
    )
    String chatTypesSection = "chatTypesSection";

    @ConfigItem(
        keyName = "logPublicChat",
        name = "Public Chat",
        description = "Log public chat messages",
        position = 11,
        section = chatTypesSection
    )
    default boolean logPublicChat()
    {
        return true;
    }

    @ConfigItem(
        keyName = "logPrivateChat",
        name = "Private Messages",
        description = "Log private messages (sent and received)",
        position = 12,
        section = chatTypesSection
    )
    default boolean logPrivateChat()
    {
        return true;
    }

    @ConfigItem(
        keyName = "logClanChat",
        name = "Clan Chat",
        description = "Log clan chat messages",
        position = 13,
        section = chatTypesSection
    )
    default boolean logClanChat()
    {
        return true;
    }

    @ConfigItem(
        keyName = "logGroupChat",
        name = "Group Ironman Chat",
        description = "Log Group Ironman chat messages",
        position = 14,
        section = chatTypesSection
    )
    default boolean logGroupChat()
    {
        return true;
    }

    @ConfigItem(
        keyName = "logFriendsChat",
        name = "Friends Chat",
        description = "Log friends chat (FC) messages",
        position = 15,
        section = chatTypesSection
    )
    default boolean logFriendsChat()
    {
        return true;
    }

    @ConfigItem(
        keyName = "logGameMessages",
        name = "Game Messages",
        description = "Log game messages (drops, level ups, etc.)",
        position = 16,
        section = chatTypesSection
    )
    default boolean logGameMessages()
    {
        return true;
    }

    @ConfigItem(
        keyName = "logTradeRequests",
        name = "Trade Requests",
        description = "Log trade requests",
        position = 17,
        section = chatTypesSection
    )
    default boolean logTradeRequests()
    {
        return false;
    }

    // =========================================================================
    // Display Options
    // =========================================================================
    
    @ConfigSection(
        name = "Display",
        description = "Overlay and display settings",
        position = 20
    )
    String displaySection = "displaySection";

    @ConfigItem(
        keyName = "showOverlay",
        name = "Show Status Overlay",
        description = "Show connection status overlay in-game",
        position = 21,
        section = displaySection
    )
    default boolean showOverlay()
    {
        return true;
    }

    @ConfigItem(
        keyName = "showMessageCount",
        name = "Show Message Count",
        description = "Show number of messages synced in overlay",
        position = 22,
        section = displaySection
    )
    default boolean showMessageCount()
    {
        return true;
    }

    // =========================================================================
    // Advanced Options
    // =========================================================================
    
    @ConfigSection(
        name = "Advanced",
        description = "Advanced configuration options",
        position = 30,
        closedByDefault = true
    )
    String advancedSection = "advancedSection";

    @ConfigItem(
        keyName = "batchSize",
        name = "Batch Size",
        description = "Number of messages to batch before sending (1-50)",
        position = 31,
        section = advancedSection
    )
    @Range(min = 1, max = 50)
    default int batchSize()
    {
        return 10;
    }

    @ConfigItem(
        keyName = "batchDelayMs",
        name = "Batch Delay (ms)",
        description = "Max time to wait before sending batch (500-10000ms)",
        position = 32,
        section = advancedSection
    )
    @Range(min = 500, max = 10000)
    default int batchDelayMs()
    {
        return 2000;
    }

    @ConfigItem(
        keyName = "retryAttempts",
        name = "Retry Attempts",
        description = "Number of retry attempts on failure (0-5)",
        position = 33,
        section = advancedSection
    )
    @Range(min = 0, max = 5)
    default int retryAttempts()
    {
        return 3;
    }

    @ConfigItem(
        keyName = "debugMode",
        name = "Debug Mode",
        description = "Enable debug logging (check RuneLite logs)",
        position = 34,
        section = advancedSection
    )
    default boolean debugMode()
    {
        return false;
    }
}

/*
 * Copyright (c) 2024, NullBot
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.osrschatlogger;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Handles sending chat messages to the OSRS Chatlogger server.
 * Features: batching, buffering, retry logic, connection status tracking.
 */
@Slf4j
@Singleton
public class ChatSender
{
    private static final MediaType JSON_MEDIA_TYPE = MediaType.parse("application/json; charset=utf-8");
    private static final int MAX_BUFFER_SIZE = 1000;
    private static final String USER_AGENT = "OSRS-Chatlogger-RuneLite/1.0";

    private final OkHttpClient httpClient;
    private final Gson gson;
    private final OsrsChatloggerConfig config;

    // Message buffer for batching
    private final List<ChatData> messageBuffer = new ArrayList<>();
    private final Object bufferLock = new Object();

    // Scheduled executor for batch sending
    private ScheduledExecutorService scheduler;
    private ScheduledFuture<?> batchTask;

    // Connection state
    private final AtomicBoolean connected = new AtomicBoolean(false);
    private final AtomicBoolean validated = new AtomicBoolean(false);
    private final AtomicInteger sentCount = new AtomicInteger(0);
    private final AtomicInteger pendingCount = new AtomicInteger(0);

    private volatile String username = null;

    @Inject
    public ChatSender(OsrsChatloggerConfig config, Gson gson, OkHttpClient httpClient)
    {
        this.config = config;
        this.gson = gson;
        // Configure timeouts to prevent hanging on slow/dead connections
        this.httpClient = httpClient.newBuilder()
            .connectTimeout(10, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            .build();

        startScheduler();
    }

    private void startScheduler()
    {
        if (scheduler != null && !scheduler.isShutdown())
        {
            return;
        }

        scheduler = Executors.newSingleThreadScheduledExecutor(r -> {
            Thread t = new Thread(r, "osrs-chatlogger-sender");
            t.setDaemon(true);
            return t;
        });

        // Schedule periodic batch sending
        int delayMs = Math.max(500, Math.min(10000, config.batchDelayMs()));
        batchTask = scheduler.scheduleAtFixedRate(
            this::sendBatch,
            delayMs,
            delayMs,
            TimeUnit.MILLISECONDS
        );
    }

    /**
     * Validate the API key with the server.
     */
    public void validateApiKey()
    {
        String apiKey = config.apiKey();
        if (apiKey == null || apiKey.isEmpty())
        {
            log.warn("No API key configured");
            validated.set(false);
            connected.set(false);
            return;
        }

        if (!apiKey.startsWith("oscl_"))
        {
            log.warn("Invalid API key format - should start with 'oscl_'");
            validated.set(false);
            connected.set(false);
            return;
        }

        String url = config.serverUrl() + "/api/v1/auth/validate";

        Request request = new Request.Builder()
            .url(url)
            .post(RequestBody.create(JSON_MEDIA_TYPE, "{}"))
            .addHeader("Authorization", "Bearer " + apiKey)
            .addHeader("User-Agent", USER_AGENT)
            .build();

        httpClient.newCall(request).enqueue(new Callback()
        {
            @Override
            public void onFailure(Call call, IOException e)
            {
                log.error("Failed to validate API key: {}", e.getMessage());
                connected.set(false);
                validated.set(false);
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException
            {
                try (ResponseBody body = response.body())
                {
                    if (response.isSuccessful() && body != null)
                    {
                        String responseBody = body.string();
                        JsonObject json = gson.fromJson(responseBody, JsonObject.class);
                        
                        if (json.has("valid") && json.get("valid").getAsBoolean())
                        {
                            username = json.has("username") ? json.get("username").getAsString() : null;
                            validated.set(true);
                            connected.set(true);
                            log.info("API key validated for user: {}", username);
                        }
                        else
                        {
                            validated.set(false);
                            connected.set(false);
                            log.warn("API key validation failed - key may be invalid or revoked");
                        }
                    }
                    else
                    {
                        validated.set(false);
                        connected.set(false);
                        log.warn("API key validation failed: HTTP {}", response.code());
                    }
                }
            }
        });
    }

    /**
     * Queue a message to be sent.
     */
    public void queueMessage(ChatData chatData)
    {
        if (!validated.get())
        {
            if (config.debugMode())
            {
                log.debug("Not queueing message - API key not validated");
            }
            return;
        }

        synchronized (bufferLock)
        {
            // Don't buffer too many messages
            if (messageBuffer.size() >= MAX_BUFFER_SIZE)
            {
                log.warn("Message buffer full, dropping oldest message");
                messageBuffer.remove(0);
            }

            messageBuffer.add(chatData);
            pendingCount.set(messageBuffer.size());

            if (config.debugMode())
            {
                log.debug("Queued message: {} (buffer size: {})", chatData, messageBuffer.size());
            }

            // Send immediately if batch is full
            int batchSize = Math.max(1, Math.min(50, config.batchSize()));
            if (messageBuffer.size() >= batchSize)
            {
                scheduler.submit(this::sendBatch);
            }
        }
    }

    /**
     * Send current batch of messages.
     */
    private void sendBatch()
    {
        List<ChatData> toSend;

        synchronized (bufferLock)
        {
            if (messageBuffer.isEmpty())
            {
                return;
            }

            // Copy and clear buffer
            toSend = new ArrayList<>(messageBuffer);
            messageBuffer.clear();
            pendingCount.set(0);
        }

        sendMessages(toSend, config.retryAttempts());
    }

    /**
     * Send a list of messages to the server.
     */
    private void sendMessages(List<ChatData> messages, int retriesLeft)
    {
        if (messages.isEmpty() || !validated.get())
        {
            return;
        }

        String url = config.serverUrl() + "/api/v1/chat/batch";

        // Build batch request
        JsonObject requestBody = new JsonObject();
        requestBody.add("messages", gson.toJsonTree(messages));

        // Include RSN and world from first message
        ChatData first = messages.get(0);
        if (first.getRsn() != null)
        {
            requestBody.addProperty("rsn", first.getRsn());
        }
        if (first.getWorld() > 0)
        {
            requestBody.addProperty("world", first.getWorld());
        }

        if (config.debugMode())
        {
            log.debug("Sending batch of {} messages", messages.size());
        }

        Request request = new Request.Builder()
            .url(url)
            .post(RequestBody.create(JSON_MEDIA_TYPE, requestBody.toString()))
            .addHeader("Authorization", "Bearer " + config.apiKey())
            .addHeader("User-Agent", USER_AGENT)
            .build();

        httpClient.newCall(request).enqueue(new Callback()
        {
            @Override
            public void onFailure(Call call, IOException e)
            {
                log.error("Failed to send messages: {}", e.getMessage());
                connected.set(false);
                handleSendFailure(messages, retriesLeft, e.getMessage());
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException
            {
                try (ResponseBody body = response.body())
                {
                    if (response.isSuccessful())
                    {
                        connected.set(true);
                        sentCount.addAndGet(messages.size());

                        if (config.debugMode())
                        {
                            log.debug("Successfully sent {} messages (total: {})", 
                                messages.size(), sentCount.get());
                        }
                    }
                    else if (response.code() == 429)
                    {
                        // Rate limited
                        String retryAfter = response.header("Retry-After", "60");
                        int waitSeconds = Integer.parseInt(retryAfter);
                        log.warn("Rate limited, waiting {} seconds", waitSeconds);

                        // Re-queue messages for later
                        scheduler.schedule(() -> {
                            synchronized (bufferLock)
                            {
                                messageBuffer.addAll(0, messages);
                                pendingCount.set(messageBuffer.size());
                            }
                        }, waitSeconds, TimeUnit.SECONDS);
                    }
                    else if (response.code() == 401)
                    {
                        // Invalid API key
                        validated.set(false);
                        connected.set(false);
                        log.error("API key rejected by server - please check your key");
                    }
                    else
                    {
                        log.warn("Server returned HTTP {}", response.code());
                        connected.set(false);
                        handleSendFailure(messages, retriesLeft, "HTTP " + response.code());
                    }
                }
            }
        });
    }

    private void handleSendFailure(List<ChatData> messages, int retriesLeft, String reason)
    {
        if (retriesLeft > 0)
        {
            // Exponential backoff
            int attempt = config.retryAttempts() - retriesLeft + 1;
            int delayMs = attempt * 2000;

            if (config.debugMode())
            {
                log.debug("Retry {} in {}ms: {}", attempt, delayMs, reason);
            }

            scheduler.schedule(() -> sendMessages(messages, retriesLeft - 1),
                delayMs, TimeUnit.MILLISECONDS);
        }
        else
        {
            // Re-buffer messages for later attempt
            log.warn("Failed to send {} messages after all retries, re-buffering", messages.size());
            synchronized (bufferLock)
            {
                // Add to front of buffer (oldest first)
                for (int i = messages.size() - 1; i >= 0; i--)
                {
                    if (messageBuffer.size() < MAX_BUFFER_SIZE)
                    {
                        messageBuffer.add(0, messages.get(i));
                    }
                }
                pendingCount.set(messageBuffer.size());
            }
        }
    }

    /**
     * Flush all buffered messages immediately.
     */
    public void flush()
    {
        sendBatch();
    }

    /**
     * Shutdown the sender gracefully.
     */
   public void shutdown()
{
    log.info("Shutting down ChatSender...");
    
    // Send any remaining messages
    flush();

    if (batchTask != null)
    {
        batchTask.cancel(false);
    }

    if (scheduler != null)
    {
        scheduler.shutdownNow();
    }
}

    // Status getters
    public boolean isConnected()
    {
        return connected.get() && validated.get();
    }

    public boolean isValidated()
    {
        return validated.get();
    }

    public int getSentCount()
    {
        return sentCount.get();
    }

    public int getPendingCount()
    {
        return pendingCount.get();
    }

    public String getUsername()
    {
        return username;
    }
}

/*
 * Copyright (c) 2024, NullBot
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.osrschatlogger;

import lombok.Data;

/**
 * Represents a chat message to be sent to the server.
 */
@Data
public class ChatData
{
    private String type;
    private String sender;
    private String message;
    private String timestamp;
    private String rsn;
    private int world;
    private String clan;
    private String ironmanType;

    public ChatData()
    {
    }

    public ChatData(String type, String sender, String message, String timestamp)
    {
        this.type = type;
        this.sender = sender;
        this.message = message;
        this.timestamp = timestamp;
    }

    @Override
    public String toString()
    {
        return String.format("ChatData{type=%s, sender=%s, message=%s, ironmanType=%s}", type, sender, message, ironmanType);
    }
}

/*
 * Copyright (c) 2024, NullBot
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.osrschatlogger;

import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.clan.ClanChannel;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.awt.image.BufferedImage;
import java.time.Instant;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.EnumSet;
import java.util.Set;

@Slf4j
@PluginDescriptor(
    name = "OSRS Chatlogger",
    description = "Sync your chat messages to osrschatlogger.com in real-time",
    tags = {"chat", "log", "logger", "sync", "chatlogger", "osrs"}
)
public class OsrsChatloggerPlugin extends Plugin
{
    private static final DateTimeFormatter ISO_FORMATTER = 
        DateTimeFormatter.ISO_INSTANT.withZone(ZoneOffset.UTC);

    @Inject
    private Client client;

    @Inject
    private OsrsChatloggerConfig config;

    @Inject
    private ChatSender chatSender;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private OsrsChatloggerOverlay overlay;

    @Inject
    private ClientToolbar clientToolbar;

    private NavigationButton navButton;
    private OsrsChatloggerPanel panel;

    // Chat types to capture
    private static final Set<ChatMessageType> LOGGED_TYPES = EnumSet.of(
        ChatMessageType.PUBLICCHAT,
        ChatMessageType.MODCHAT,
        ChatMessageType.PRIVATECHAT,
        ChatMessageType.PRIVATECHATOUT,
        ChatMessageType.CLAN_CHAT,
        ChatMessageType.CLAN_MESSAGE,
        ChatMessageType.CLAN_GIM_CHAT,
        ChatMessageType.CLAN_GIM_MESSAGE,
        ChatMessageType.CLAN_GUEST_CHAT,
        ChatMessageType.CLAN_GUEST_MESSAGE,
        ChatMessageType.FRIENDSCHAT,
        ChatMessageType.TRADEREQ,
        ChatMessageType.GAMEMESSAGE,
        ChatMessageType.ENGINE,
        ChatMessageType.BROADCAST,
        ChatMessageType.SPAM
    );

    private String currentRsn = null;
    private int currentWorld = -1;
    private String currentClanName = null;

    @Override
    protected void startUp() throws Exception
    {
        log.info("OSRS Chatlogger started!");
        overlayManager.add(overlay);
        
        // Create and register the side panel
        panel = new OsrsChatloggerPanel(chatSender);
        
        final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/icon.png");
        
        navButton = NavigationButton.builder()
            .tooltip("OSRS Chatlogger")
            .icon(icon)
            .priority(5)
            .panel(panel)
            .build();
        
        clientToolbar.addNavigation(navButton);
        
        // Validate API key on startup
        if (isConfigured())
        {
            chatSender.validateApiKey();
        }
    }

    @Override
    protected void shutDown() throws Exception
    {
        log.info("OSRS Chatlogger stopped!");
        overlayManager.remove(overlay);
        clientToolbar.removeNavigation(navButton);
        chatSender.shutdown();
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event)
    {
        if (event.getGameState() == GameState.LOGGED_IN)
        {
            // Get player info when logged in
            if (client.getLocalPlayer() != null)
            {
                currentRsn = client.getLocalPlayer().getName();
                currentWorld = client.getWorld();
                
                // Capture clan name (null-safe)
                ClanChannel clanChannel = client.getClanChannel();
                currentClanName = (clanChannel != null) ? clanChannel.getName() : null;
                
                log.debug("Logged in as {} on world {}, clan: {}", currentRsn, currentWorld, currentClanName);
                
                // Re-validate API key when logging into game
                if (isConfigured())
                {
                    chatSender.validateApiKey();
                }
            }
        }
        else if (event.getGameState() == GameState.LOGIN_SCREEN)
        {
            // Flush any remaining messages when logging out
            chatSender.flush();
            currentRsn = null;
            currentWorld = -1;
            currentClanName = null;
        }
    }

    @Subscribe
    public void onChatMessage(ChatMessage event)
    {
        // Check if plugin is configured
        if (!isConfigured())
        {
            return;
        }

        // Check if this message type should be logged
        ChatMessageType type = event.getType();
        if (!shouldLogType(type))
        {
            return;
        }

        // Build message data
        ChatData chatData = new ChatData();
        chatData.setType(mapChatType(type));
        chatData.setIronmanType(detectIronmanType(event.getName()));
        chatData.setSender(cleanName(event.getName()));
        chatData.setMessage(cleanMessage(event.getMessage()));
        chatData.setTimestamp(ISO_FORMATTER.format(Instant.now()));
        chatData.setRsn(currentRsn);
        chatData.setWorld(currentWorld);
        
        // Populate clan name for clan-related message types
        if (isClanMessageType(type) && currentClanName != null)
        {
            chatData.setClan(currentClanName);
        }

        // Send to server
        chatSender.queueMessage(chatData);
    }
    
    private boolean isClanMessageType(ChatMessageType type)
    {
        return type == ChatMessageType.CLAN_CHAT 
            || type == ChatMessageType.CLAN_MESSAGE
            || type == ChatMessageType.CLAN_GUEST_CHAT
            || type == ChatMessageType.CLAN_GUEST_MESSAGE
            || type == ChatMessageType.CLAN_GIM_CHAT
            || type == ChatMessageType.CLAN_GIM_MESSAGE;
    }

    private boolean isConfigured()
    {
        String apiKey = config.apiKey();
        return apiKey != null && !apiKey.isEmpty() && apiKey.startsWith("oscl_");
    }

    private boolean shouldLogType(ChatMessageType type)
    {
        if (!LOGGED_TYPES.contains(type))
        {
            return false;
        }

        // Check user preferences
        switch (type)
        {
            case PUBLICCHAT:
            case MODCHAT:
                return config.logPublicChat();
            
            case PRIVATECHAT:
            case PRIVATECHATOUT:
                return config.logPrivateChat();
            
            case CLAN_CHAT:
            case CLAN_MESSAGE:
            case CLAN_GUEST_CHAT:
            case CLAN_GUEST_MESSAGE:
                return config.logClanChat();
            
            case CLAN_GIM_CHAT:
            case CLAN_GIM_MESSAGE:
                return config.logGroupChat();
            
            case FRIENDSCHAT:
                return config.logFriendsChat();
            
            case GAMEMESSAGE:
            case ENGINE:
            case BROADCAST:
            case SPAM:
                return config.logGameMessages();
            
            case TRADEREQ:
                return config.logTradeRequests();
            
            default:
                return true;
        }
    }

    private String mapChatType(ChatMessageType type)
    {
        switch (type)
        {
            case PUBLICCHAT:
            case MODCHAT:
                return "PUBLIC";
            case PRIVATECHAT:
                return "PRIVATE";
            case PRIVATECHATOUT:
                return "PRIVATE_OUT";
            case CLAN_CHAT:
            case CLAN_MESSAGE:
                return "CLAN_CHAT";
            case CLAN_GUEST_CHAT:
            case CLAN_GUEST_MESSAGE:
                return "CLAN_GUEST";
            case CLAN_GIM_CHAT:
            case CLAN_GIM_MESSAGE:
                return "CLAN_GIM_CHAT";
            case FRIENDSCHAT:
                return "FRIENDSCHAT";
            case TRADEREQ:
                return "TRADE";
            case GAMEMESSAGE:
            case SPAM:
                return "GAME";
            case ENGINE:
                return "ENGINE";
            case BROADCAST:
                return "BROADCAST";
            default:
                return type.name();
        }
    }
    private String detectIronmanType(String name)
    {
        if (name == null)
        {
            return "";
        }
        if (name.contains("<img=2>")) return "ironman";
        if (name.contains("<img=10>")) return "hardcore";
        if (name.contains("<img=3>")) return "ultimate";
        if (name.contains("<img=41>")) return "group";
        return "";
    }
    
    private String cleanName(String name)
    {
        if (name == null)
        {
            return "";
        }
        // Remove img tags (ironman icons, etc.)
        return name.replaceAll("<img=\\d+>", "").trim();
    }

    private String cleanMessage(String message)
    {
        if (message == null)
        {
            return "";
        }
        // Remove color tags and formatting
        return message
            .replaceAll("<col=[^>]+>", "")
            .replaceAll("</col>", "")
            .replaceAll("<br>", "\n")
            .trim();
    }

    @Provides
    OsrsChatloggerConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(OsrsChatloggerConfig.class);
    }

    // Getters for overlay
    public boolean isConnected()
    {
        return chatSender.isConnected();
    }

    public int getPendingCount()
    {
        return chatSender.getPendingCount();
    }

    public int getSentCount()
    {
        return chatSender.getSentCount();
    }
}

/*
 * Copyright (c) 2024, NullBot
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.osrschatlogger;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.image.BufferedImage;
import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.LinkBrowser;

/**
 * Side panel for OSRS Chatlogger plugin with quick links.
 */
@Slf4j
public class OsrsChatloggerPanel extends PluginPanel
{
    private static final String WEBSITE_URL = "https://osrschatlogger.com";
    private static final String DISCORD_URL = "https://discord.gg/xAa3JXaVb5";
    private static final String GITHUB_URL = "https://github.com/NullBotOSRS";

    private static final int ICON_SIZE = 16;

    private final ChatSender chatSender;

    public OsrsChatloggerPanel(ChatSender chatSender)
    {
        super(false);
        this.chatSender = chatSender;

        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new BorderLayout());

        // Create header with title and icon row
        JPanel headerPanel = createHeaderPanel();
        add(headerPanel, BorderLayout.NORTH);

        // Create status panel
        JPanel statusPanel = createStatusPanel();
        add(statusPanel, BorderLayout.CENTER);
    }

    private JPanel createHeaderPanel()
    {
        JPanel headerPanel = new JPanel(new BorderLayout());
        headerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        headerPanel.setBorder(new EmptyBorder(10, 10, 5, 10));

        // Title label
        JLabel titleLabel = new JLabel("OSRS Chatlogger");
        titleLabel.setForeground(Color.WHITE);
        headerPanel.add(titleLabel, BorderLayout.WEST);

        // Icon row panel
        JPanel iconRow = new JPanel(new FlowLayout(FlowLayout.RIGHT, 8, 0));
        iconRow.setBackground(ColorScheme.DARK_GRAY_COLOR);

        // Website icon
        iconRow.add(createIconButton(createWebsiteIcon(), "Website", WEBSITE_URL));

        // Discord icon
        iconRow.add(createIconButton(createDiscordIcon(), "Discord", DISCORD_URL));

        // GitHub icon
        iconRow.add(createIconButton(createGithubIcon(), "GitHub", GITHUB_URL));

        headerPanel.add(iconRow, BorderLayout.EAST);

        return headerPanel;
    }

    private JLabel createIconButton(BufferedImage icon, String tooltip, String url)
    {
        JLabel label = new JLabel(new ImageIcon(icon));
        label.setToolTipText(tooltip);
        label.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
        label.addMouseListener(new java.awt.event.MouseAdapter()
        {
            @Override
            public void mouseClicked(java.awt.event.MouseEvent e)
            {
                LinkBrowser.browse(url);
            }

            @Override
            public void mouseEntered(java.awt.event.MouseEvent e)
            {
                label.setBorder(BorderFactory.createLineBorder(ColorScheme.BRAND_ORANGE, 1));
            }

            @Override
            public void mouseExited(java.awt.event.MouseEvent e)
            {
                label.setBorder(null);
            }
        });
        return label;
    }

    private JPanel createStatusPanel()
    {
        JPanel statusPanel = new JPanel();
        statusPanel.setLayout(new BorderLayout());
        statusPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        statusPanel.setBorder(new EmptyBorder(10, 10, 10, 10));

        JPanel infoPanel = new JPanel();
        infoPanel.setLayout(new javax.swing.BoxLayout(infoPanel, javax.swing.BoxLayout.Y_AXIS));
        infoPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Instructions
        JLabel instructionLabel = new JLabel("<html><body style='width: 180px'>" +
            "Configure your API key in the plugin settings to start syncing chat messages." +
            "</body></html>");
        instructionLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        instructionLabel.setBorder(new EmptyBorder(0, 0, 10, 0));
        infoPanel.add(instructionLabel);

        // Get API key link
        JLabel apiKeyLink = new JLabel("<html><u>Get your API key</u></html>");
        apiKeyLink.setForeground(ColorScheme.BRAND_ORANGE);
        apiKeyLink.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
        apiKeyLink.addMouseListener(new java.awt.event.MouseAdapter()
        {
            @Override
            public void mouseClicked(java.awt.event.MouseEvent e)
            {
                LinkBrowser.browse(WEBSITE_URL + "/settings/api");
            }
        });
        infoPanel.add(apiKeyLink);

        statusPanel.add(infoPanel, BorderLayout.NORTH);

        return statusPanel;
    }

    /**
     * Create a simple globe/world icon for website link.
     */
    private BufferedImage createWebsiteIcon()
    {
        BufferedImage image = new BufferedImage(ICON_SIZE, ICON_SIZE, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g = image.createGraphics();
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        // Draw globe circle
        g.setColor(new Color(100, 181, 246)); // Light blue
        g.fillOval(1, 1, ICON_SIZE - 2, ICON_SIZE - 2);

        // Draw meridian lines
        g.setColor(new Color(66, 133, 244)); // Darker blue
        g.drawOval(1, 1, ICON_SIZE - 3, ICON_SIZE - 3);
        g.drawLine(ICON_SIZE / 2, 1, ICON_SIZE / 2, ICON_SIZE - 2);
        g.drawLine(1, ICON_SIZE / 2, ICON_SIZE - 2, ICON_SIZE / 2);
        // Curved meridian
        g.drawArc(3, 1, ICON_SIZE - 6, ICON_SIZE - 3, 90, 180);
        g.drawArc(5, 1, ICON_SIZE - 6, ICON_SIZE - 3, -90, 180);

        g.dispose();
        return image;
    }

    /**
     * Create a simple chat bubble icon for Discord link.
     */
    private BufferedImage createDiscordIcon()
    {
        BufferedImage image = new BufferedImage(ICON_SIZE, ICON_SIZE, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g = image.createGraphics();
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        // Discord blurple color
        g.setColor(new Color(88, 101, 242));

        // Draw rounded rectangle (chat bubble body)
        g.fillRoundRect(1, 2, ICON_SIZE - 2, ICON_SIZE - 5, 4, 4);

        // Draw small triangle at bottom for speech bubble
        int[] xPoints = {3, 6, 6};
        int[] yPoints = {ICON_SIZE - 3, ICON_SIZE - 3, ICON_SIZE - 1};
        g.fillPolygon(xPoints, yPoints, 3);

        // Draw two dots (simplified Discord logo eyes)
        g.setColor(Color.WHITE);
        g.fillOval(4, 6, 3, 3);
        g.fillOval(9, 6, 3, 3);

        g.dispose();
        return image;
    }

    /**
     * Create a simple code bracket icon for GitHub link.
     */
    private BufferedImage createGithubIcon()
    {
        BufferedImage image = new BufferedImage(ICON_SIZE, ICON_SIZE, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g = image.createGraphics();
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        // GitHub gray color
        g.setColor(new Color(110, 118, 129));

        // Draw circle background
        g.fillOval(0, 0, ICON_SIZE, ICON_SIZE);

        // Draw simplified octocat silhouette (circle with ears)
        g.setColor(new Color(36, 41, 46)); // Dark background
        g.fillOval(2, 3, ICON_SIZE - 4, ICON_SIZE - 4);

        // Draw face area (lighter)
        g.setColor(new Color(110, 118, 129));
        g.fillOval(4, 5, ICON_SIZE - 8, ICON_SIZE - 7);

        // Small ears
        g.setColor(new Color(36, 41, 46));
        int[] leftEarX = {3, 5, 6};
        int[] leftEarY = {5, 2, 5};
        g.fillPolygon(leftEarX, leftEarY, 3);
        int[] rightEarX = {13, 11, 10};
        int[] rightEarY = {5, 2, 5};
        g.fillPolygon(rightEarX, rightEarY, 3);

        g.dispose();
        return image;
    }
}

