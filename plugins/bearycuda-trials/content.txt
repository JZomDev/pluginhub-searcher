package com.datbear;

import net.runelite.client.config.*;

import java.awt.*;

@ConfigGroup("bearycudaTrials")
public interface BearycudaTrialsConfig extends Config {

    @ConfigSection(name = "Outlines/Colors", description = "All options relating to colors & outlines", position = 1, closedByDefault = false)
    String outlines = "outlines";

    @ConfigSection(name = "Menu Swaps", description = "All options relating to menu entry swaps", position = 2, closedByDefault = true)
    String menuSwaps = "menuSwaps";

    @ConfigSection(name = "Boat True Tile/Heading", description = "Options for showing the boat's true tile and heading arrows", position = 3, closedByDefault = false)
    String boatTrueTileHeading = "boatTrueTileHeading";

    @ConfigSection(name = "Debug", description = "Debugging options (menu items, extra overlays)", position = 4, closedByDefault = true)
    String debug = "debug";

    //outlines
    @ConfigItem(keyName = "showRouteLines", name = "Show route lines", description = "Toggle drawing of the route polyline", section = outlines, position = 2)
    default boolean showRouteLines() {
        return true;
    }

    @ConfigItem(keyName = "routeLineColor", name = "Route line color", description = "Color used to draw the route polyline", section = outlines, position = 3)
    default Color routeLineColor() {
        return new Color(0, 255, 255, 200);
    }

    @Alpha
    @ConfigItem(keyName = "showRouteDots", name = "Show route dots", description = "Toggle drawing of route waypoint dots", section = outlines, position = 4)
    default boolean showRouteDots() {
        return true;
    }

    @ConfigItem(keyName = "routeDotColor", name = "Route dot color", description = "Color used for route waypoint dots", section = outlines, position = 5)
    default Color routeDotColor() {
        return new Color(255, 255, 255, 200);
    }

    @Alpha
    @ConfigItem(keyName = "showCrateHighlights", name = "Show crate highlights", description = "Toggle outlining of trial crates", section = outlines, position = 6)
    default boolean showCrateHighlights() {
        return true;
    }

    @ConfigItem(keyName = "crateHighlightColor", name = "Crate highlight color", description = "Outline color for trial crates", section = outlines, position = 7)
    default Color crateHighlightColor() {
        return Color.YELLOW;
    }

    @Alpha
    @ConfigItem(keyName = "showBoostHighlights", name = "Show boost highlights", description = "Toggle highlighting of speed-boost tiles/objects", section = outlines, position = 8)
    default boolean showBoostHighlights() {
        return true;
    }

    @ConfigItem(keyName = "boostHighlightColor", name = "Boost highlight color", description = "Highlight color for speed-boost tiles/objects", section = outlines, position = 9)
    default Color boostHighlightColor() {
        return Color.BLUE;
    }

    @Alpha
    @ConfigItem(keyName = "showTrimSailHighlights", name = "Show trim sail highlights", description = "Toggle highlights for trimmable sails", section = outlines, position = 10)
    default boolean showTrimSailHighlights() {
        return true;
    }

    @ConfigItem(keyName = "trimSailHighlightColor", name = "Trim sail highlight color", description = "Highlight color used for trimmable sails", section = outlines, position = 11)
    default Color trimSailHighlightColor() {
        return new Color(0, 255, 0, 150);
    }

    @Alpha
    @ConfigItem(keyName = "showJubblyToadHighlights", name = "Show Jubbly toad flag highlights", description = "Toggle highlighting of Jubbly toad flags", section = outlines, position = 12)
    default boolean showJubblyToadHighlights() {
        return true;
    }

    @ConfigItem(keyName = "jubblyToadInRangeColor", name = "Jubbly toad in-range color", description = "Color used for toad flags when within range", section = outlines, position = 13)
    default Color jubblyToadInRangeColor() {
        return new Color(0, 255, 0, 200);
    }

    @Alpha
    @ConfigItem(keyName = "jubblyToadOutOfRangeColor", name = "Jubbly toad out-of-range color", description = "Color used for toad flags when out of range", section = outlines, position = 14)
    default Color jubblyToadOutOfRangeColor() {
        return new Color(255, 0, 0, 150);
    }

    @ConfigItem(keyName = "showPortalRouteArrows", name = "Show portal route arrows", description = "Toggle showing route direction arrows when near portals", section = outlines, position = 15)
    default boolean showPortalRouteArrows() {
        return true;
    }

    @Alpha
    @ConfigItem(keyName = "portalRouteArrowColor", name = "Portal route arrow color", description = "Color used for portal route direction arrows", section = outlines, position = 16)
    default Color portalRouteArrowColor() {
        return new Color(0, 255, 255, 200);
    }

    @ConfigItem(keyName = "showPortalBoatArrows", name = "Show portal boat arrows", description = "Toggle showing boat direction arrows when near portals", section = outlines, position = 17)
    default boolean showPortalBoatArrows() {
        return true;
    }

    @Alpha
    @ConfigItem(keyName = "portalBoatArrowColor", name = "Portal boat arrow color", description = "Color used for portal boat direction arrows", section = outlines, position = 18)
    default Color portalBoatArrowColor() {
        return new Color(0, 255, 0, 200);
    }

    @ConfigItem(keyName = "showObstacleOutlines", name = "Show obstacle outlines", description = "Toggle outlining of obstacle tiles during trials", section = outlines, position = 19)
    default boolean showObstacleOutlines() {
        return false;
    }

    @Alpha
    @ConfigItem(keyName = "obstacleOutlineColor", name = "Obstacle outline color", description = "Color used to outline obstacle tiles", section = outlines, position = 20)
    default Color obstacleOutlineColor() {
        return new Color(255, 0, 0, 255);
    }

    @ConfigItem(keyName = "hideDecorations", name = "Hide decorations", description = "Hide decorative objects during trials", section = outlines, position = 21)
    default boolean hideDecorations() {
        return true;
    }

    @ConfigItem(keyName = "showSpeedBoostRemaining", name = "Show speed boost remaining", description = "Show a radial cooldown and ticks remaining on the wind mote button", section = outlines, position = 22)
    default boolean showSpeedBoostRemaining() {
        return true;
    }

    @ConfigItem(keyName = "showTrialBoatHighlights", name = "Show trial boat highlights", description = "Toggle outlining of the active trial boats", section = outlines, position = 23)
    default boolean showTrialBoatHighlights() {
        return true;
    }

    @Alpha
    @ConfigItem(keyName = "trialBoatHighlightColor", name = "Trial boat highlight color", description = "Outline color used when highlighting trial boats", section = outlines, position = 24)
    default Color trialBoatHighlightColor() {
        return new Color(0, 255, 255, 200);
    }

    // true boat tile / heading
    @ConfigItem(keyName = "showBoatTrueTile", name = "Show true boat tile", description = "Highlight the boat's true tile", section = boatTrueTileHeading, position = 1)
    default boolean showBoatTrueTile() {
        return true;
    }

    @Alpha
    @ConfigItem(keyName = "boatTrueTileFillColor", name = "True boat tile fill color", description = "Fill color for the boat's true tile", section = boatTrueTileHeading, position = 2)
    default Color boatTrueTileFillColor() {
        return new Color(255, 255, 255, 45);
    }

    @ConfigItem(keyName = "boatTrueTileBorderColor", name = "True boat tile border color", description = "Border color for the boat's true tile", section = boatTrueTileHeading, position = 3)
    default Color boatTrueTileBorderColor() {
        return Color.BLACK;
    }

    @ConfigItem(keyName = "showCurrentHeading", name = "Show current heading", description = "Show the current heading arrow", section = boatTrueTileHeading, position = 4)
    default boolean showCurrentHeading() {
        return false;
    }

    @Alpha
    @ConfigItem(keyName = "currentHeadingColor", name = "Current heading color", description = "Color for the current heading arrow", section = boatTrueTileHeading, position = 5)
    default Color currentHeadingColor() {
        return Color.GREEN;
    }

    @ConfigItem(keyName = "showRequestedHeading", name = "Show requested heading", description = "Show the requested heading arrow", section = boatTrueTileHeading, position = 6)
    default boolean showRequestedHeading() {
        return false;
    }

    @Alpha
    @ConfigItem(keyName = "requestedHeadingColor", name = "Requested heading color", description = "Color for the requested heading arrow", section = boatTrueTileHeading, position = 7)
    default Color requestedHeadingColor() {
        return Color.YELLOW;
    }

    @ConfigItem(keyName = "showHoveredHeading", name = "Show hovered heading", description = "Show the hovered heading arrow", section = boatTrueTileHeading, position = 8)
    default boolean showHoveredHeading() {
        return false;
    }

    @Alpha
    @ConfigItem(keyName = "hoveredHeadingColor", name = "Hovered heading color", description = "Color for the hovered heading arrow", section = boatTrueTileHeading, position = 9)
    default Color hoveredHeadingColor() {
        return Color.WHITE;
    }

    //menu swaps
    @ConfigItem(keyName = "enableStartPreviousRankLeftClick", name = "Enable 'Start-previous-rank' left-click", description = "When enabled, this will swap the left-click action on trial npcs to Start-previous-rank", section = menuSwaps, position = 1)
    default boolean enableStartPreviousRankLeftClick() {
        return true;
    }

    @ConfigItem(keyName = "enableQuickResetLeftClick", name = "Enable 'Quick-reset' left-click", description = "When enabled, this will swap the left-click action on the reset button in the HUD to Quick-reset", section = menuSwaps, position = 2)
    default boolean enableQuickResetLeftClick() {
        return true;
    }

    @ConfigItem(keyName = "disableStopNavigating", name = "Disable 'Stop-navigating' left-click during trials", description = "When enabled, this will remove the left-click 'Stop-navigating' action on the helm while in a trial", section = menuSwaps, position = 3)
    default boolean disableStopNavigating() {
        return true;
    }

    @ConfigItem(keyName = "disableUnsetSail", name = "Disable 'Unset sail' left-click during trials", description = "When enabled, this will remove the left-click 'Unset' action on the sail while in a trial", section = menuSwaps, position = 4)
    default boolean disableUnsetSail() {
        return true;
    }

    //debug
    @ConfigItem(keyName = "showDebugOverlay", name = "Show debug overlay", description = "Show debugging info (player/instance coords & next waypoint indices)", section = debug, position = 1)
    default boolean showDebugOverlay() {
        return false;
    }

    @ConfigItem(keyName = "showDebugMenuCopyTileOptions", name = "Show debug tile copy menu options", description = "Adds 'Copy worldpoint' and 'Copy tile worldpoint' menu items for debugging", section = debug, position = 2)
    default boolean showDebugMenuCopyTileOptions() {
        return false;
    }

    @ConfigItem(keyName = "showDebugRouteModificationOptions", name = "Show debug route modification menu options", description = "Adds '[BT]' menu items for route modifications", section = debug, position = 3)
    default boolean showDebugRouteModificationOptions() {
        return false;
    }

    @ConfigItem(keyName = "enableCratePickupDebug", name = "Track crate pickup distance", description = "Log and display crate pickup distances for debugging", section = debug, position = 4)
    default boolean enableCratePickupDebug() {
        return false;
    }

    @ConfigItem(keyName = "enableBoatPathDebug", name = "Show boat path overlay", description = "Draw boat path tiles for the last several ticks", section = debug, position = 5)
    default boolean enableBoatPathDebug() {
        return false;
    }

}

package com.datbear;

import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.*;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;

import javax.inject.Inject;

import com.datbear.data.Directions;
import com.datbear.data.TrialRoute;
import com.datbear.overlay.WorldLines;
import com.datbear.overlay.WorldPerspective;

import lombok.extern.slf4j.Slf4j;

import java.awt.*;

@Slf4j
public class BearycudaTrialsOverlay extends Overlay {
    @Inject
    private ItemManager itemManager;

    @Inject
    private SpriteManager spriteManager;

    @Inject
    private ModelOutlineRenderer modelOutlineRenderer;

    private Client client;
    private BearycudaTrialsPlugin plugin;
    private BearycudaTrialsConfig config;

    private final int MOTE_SPRITE_ID = 7075;
    private int nextMoteIndex = -1;

    @Inject
    public BearycudaTrialsOverlay(Client client, BearycudaTrialsPlugin plugin, BearycudaTrialsConfig config) {
        super();
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        this.client = client;
        this.plugin = plugin;
        this.config = config;
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (client.getGameState() != GameState.LOGGED_IN)
            return null;

        var player = client.getLocalPlayer();
        if (player == null)
            return null;

        var boatLocation = BoatLocation.fromLocal(client, player.getLocalLocation());
        if (boatLocation == null)
            return null;

        var playerLocation = player.getWorldLocation();

        renderLastMenuCanvasWorldPointOutline(graphics);
        highlightTrimmableSails(graphics);

        var route = plugin.getActiveTrialRoute();
        if (route == null) {
            if (config.showDebugOverlay()) {
                renderDebugInfo(graphics, route);
            }
            return null;
        }

        renderTrueInfo(graphics, boatLocation, playerLocation);
        renderPortalArrows(graphics, route, playerLocation);
        highlightToadFlags(graphics, boatLocation);
        highlightCrates(graphics);
        highlightBoosts(graphics);
        renderWindMote(graphics);
        renderWindMoteCooldown(graphics);
        highlightTrialBoat(graphics, boatLocation);

        var visible = plugin.getVisibleActiveLineForPlayer(boatLocation, 5);
        if (config.showRouteLines() && visible.size() >= 2) {
            WorldLines.drawLinesOnWorld(graphics, client, visible, config.routeLineColor(), boatLocation.getPlane());
        }

        renderRouteDots(graphics, route);

        if (config.showDebugOverlay()) {
            renderDebugInfo(graphics, route);
        }
        return null;
    }

    private void renderTrueInfo(Graphics2D graphics, WorldPoint boatLocation, WorldPoint playerLocation) {
        if (config.showBoatTrueTile()) {
            highlightBoatTrueTile(graphics, boatLocation);
        }

        if (config.showHoveredHeading()) {
            renderHeadingTriangle(graphics, playerLocation, plugin.getHoveredHeadingDirection(), config.hoveredHeadingColor(), 30, 8);
        }

        if (config.showRequestedHeading()) {
            renderHeadingTriangle(graphics, playerLocation, plugin.getRequestedHeadingDirection(), config.requestedHeadingColor(), 30, 8);
        }

        if (config.showCurrentHeading()) {
            renderHeadingTriangle(graphics, playerLocation, plugin.getCurrentHeadingDirection(), config.currentHeadingColor(), 30, 8);
        }
    }

    private void renderRouteDots(Graphics2D graphics, TrialRoute route) {
        var nextIndices = plugin.getNextUnvisitedIndicesForActiveRoute(5);
        if (config.showRouteDots()) {
            for (int idx : nextIndices) {
                if (route.Points == null || idx < 0 || idx >= route.Points.size())
                    continue;
                var real = route.Points.get(idx);
                var wp = WorldPerspective.getInstanceWorldPointFromReal(client, client.getTopLevelWorldView(), real);
                if (wp == null)
                    continue;
                var pts = WorldPerspective.worldToCanvasWithOffset(client, wp, wp.getPlane());
                if (pts.isEmpty())
                    continue;
                var p = pts.get(0);

                renderLineDots(graphics, wp, config.routeDotColor(), idx, p);
            }
        }
    }

    private void renderLineDots(Graphics2D graphics, WorldPoint wp, Color color, int i, Point start) {
        final int size = (i == 0 ? 10 : 6);
        final Color fill = color;
        final Color border = new Color(0, 0, 0, 200);

        graphics.setColor(fill);
        graphics.fillOval(start.getX() - size / 2, start.getY() - size / 2, size, size);

        graphics.setColor(border);
        graphics.setStroke(new BasicStroke(2f));
        graphics.drawOval(start.getX() - size / 2, start.getY() - size / 2, size, size);

        // Draw label (index) near the point so it's easy to match route-to-data
        final String label = String.valueOf(i);
        graphics.setColor(Color.BLACK);
        graphics.setFont(graphics.getFont().deriveFont(Font.BOLD, 12f));
        graphics.drawString(label, start.getX() + (size / 2) + 2, start.getY() - (size / 2) - 2);
    }

    private void renderDebugInfo(Graphics2D graphics, TrialRoute active) {
        if (client.getGameState() != GameState.LOGGED_IN) {
            return;
        }

        var player = client.getLocalPlayer();
        if (player == null)
            return;

        int x = 10;
        int y = 200;
        graphics.setFont(graphics.getFont().deriveFont(Font.BOLD, 15f));
        graphics.setColor(Color.WHITE);

        graphics.drawString("tick = " + client.getTickCount(), x, y += 15);
        graphics.drawString("boarded boat = " + plugin.getBoardedBoat(), x, y += 15);

        var boatLoc = BoatLocation.fromLocal(client, player.getLocalLocation());
        var playerLoc = player.getWorldLocation();
        graphics.drawString("boat loc = " + (boatLoc == null ? "null" : boatLoc.toString()), x, y += 15);
        graphics.drawString("player loc = " + (playerLoc == null ? "null" : playerLoc.toString()), x, y += 15);
        if (active != null) {
            graphics.drawString("active route = " + active.Location + " " + active.Rank, x, y += 15);
        } else {
            graphics.drawString("active route = null", x, y += 15);
        }
        graphics.drawString("last visited idx = " + plugin.getLastVisitedIndex(), x, y += 15);
        graphics.drawString("toad flag idx = " + plugin.getHighlightedToadFlagIndex(), x, y += 15);
        graphics.drawString("next mote idx = " + nextMoteIndex, x, y += 15);

        // Varbit-derived plugin state
        graphics.drawString("boatSpawnedAngle = " + plugin.getBoatSpawnedAngle(), x, y += 15);
        graphics.drawString("boatSpawnedFineX = " + plugin.getBoatSpawnedFineX(), x, y += 15);
        graphics.drawString("boatSpawnedFineZ = " + plugin.getBoatSpawnedFineZ(), x, y += 15);
        graphics.drawString("boatBaseSpeed = " + plugin.getBoatBaseSpeed(), x, y += 15);
        graphics.drawString("boatSpeedCap = " + plugin.getBoatSpeedCap(), x, y += 15);
        graphics.drawString("boatSpeedBoostDuration = " + plugin.getBoatSpeedBoostDuration(), x, y += 15);
        graphics.drawString("windMoteReleasedTick = " + plugin.getWindMoteReleasedTick(), x, y += 15);
        graphics.drawString("isInTrial = " + plugin.getIsInTrial(), x, y += 15);
        if (config.enableCratePickupDebug()) {
            if (plugin.getLastCratePickupDistance() > 0) {
                graphics.drawString("lastCratePickupDistance = " + plugin.getLastCratePickupDistance(), x, y += 15);
            }
            if (plugin.getMinCratePickupDistance() > 0) {
                graphics.drawString("minCratePickupDistance = " + plugin.getMinCratePickupDistance(), x, y += 15);
            }
            if (plugin.getMaxCratePickupDistance() > 0) {
                graphics.drawString("maxCratePickupDistance = " + plugin.getMaxCratePickupDistance(), x, y += 15);
            }
        }

    }

    private void renderLastMenuCanvasWorldPointOutline(Graphics2D graphics) {
        var pos = plugin.getLastMenuCanvasWorldPoint();
        if (pos == null) {
            return;
        }

        var localPoints = WorldPerspective.getInstanceLocalPointFromReal(client, pos);
        if (localPoints == null || localPoints.isEmpty()) {
            return;
        }

        for (var lp : localPoints) {
            if (lp == null)
                continue;
            java.awt.Polygon poly = Perspective.getCanvasTilePoly(client, lp);
            if (poly == null)
                continue;

            // Draw a translucent fill and a bold border so the tile is obvious
            Color fill = new Color(255, 0, 255, 45);
            Color border = Color.MAGENTA;
            Stroke oldStroke = graphics.getStroke();
            Composite oldComposite = graphics.getComposite();

            graphics.setColor(fill);
            graphics.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.35f));
            graphics.fill(poly);

            graphics.setComposite(oldComposite);
            graphics.setColor(border);
            graphics.setStroke(new BasicStroke(3f));
            graphics.draw(poly);

            // restore previous graphics state
            graphics.setStroke(oldStroke);
            graphics.setComposite(oldComposite);

            // only draw first matching instance tile
            break;
        }
    }

    private void highlightToadFlags(Graphics2D graphics, WorldPoint boatLocation) {
        if (!config.showJubblyToadHighlights()) {
            return;
        }
        var toadGameObjects = plugin.getToadFlagToHighlight();
        if (toadGameObjects == null || toadGameObjects.isEmpty()) {
            return;
        }
        Color inRangeColor = config.jubblyToadInRangeColor();
        Color outRangeColor = config.jubblyToadOutOfRangeColor();
        for (var toadGameObject : toadGameObjects) {
            var color = toadGameObject.getWorldLocation().distanceTo(boatLocation) <= 15 ? inRangeColor : outRangeColor;
            modelOutlineRenderer.drawOutline(toadGameObject, 3, color, 2);
        }
    }

    private void highlightCrates(Graphics2D graphics) {
        if (!config.showCrateHighlights()) {
            return;
        }
        var crates = plugin.getTrialCratesById();
        Color crateColor = config.crateHighlightColor();
        for (var crate : crates.values()) {
            modelOutlineRenderer.drawOutline(crate, 2, crateColor, 2);
        }
    }

    private void highlightBoosts(Graphics2D graphics) {
        if (!config.showBoostHighlights()) {
            return;
        }
        var boosts = plugin.getTrialBoostsById();
        Color boostColor = config.boostHighlightColor();
        for (var boostList : boosts.values()) {
            for (var boost : boostList) {
                var poly = boost.getCanvasTilePoly();
                if (poly != null) {
                    OverlayUtil.renderPolygon(graphics, poly, boostColor);
                }
            }
        }
    }

    private void highlightTrialBoat(Graphics2D graphics, WorldPoint boatLocation) {
        if (!config.showTrialBoatHighlights()) {
            return;
        }
        var boats = plugin.getTrialBoatsToHighlight();
        if (boats == null || boats.isEmpty()) {
            return;
        }
        Color highlightColor = config.trialBoatHighlightColor();
        for (var boat : boats) {
            modelOutlineRenderer.drawOutline(boat, 3, highlightColor, 2);
        }
    }

    private void renderWindMote(Graphics2D graphics) {
        var route = plugin.getActiveTrialRoute();
        if (route == null || plugin.getLastVisitedIndex() < 0) {
            return;
        }
        var optionalMoteIndex = route.WindMoteIndices.stream().filter(x -> x >= plugin.getLastVisitedIndex()).min(Integer::compareTo);
        nextMoteIndex = optionalMoteIndex.isPresent() ? optionalMoteIndex.get() : -1;
        var moteWorldPoint = nextMoteIndex != -1 && nextMoteIndex - Math.max(0, plugin.getLastVisitedIndex()) < 3 ? route.Points.get(nextMoteIndex) : null;
        if (moteWorldPoint == null) {
            return;
        }

        var localPoint = WorldPerspective.getInstanceLocalPointFromReal(client, moteWorldPoint);
        if (localPoint == null || localPoint.isEmpty()) {
            return;
        }

        var img = spriteManager.getSprite(MOTE_SPRITE_ID, 0);
        OverlayUtil.renderImageLocation(client, graphics, localPoint.get(0), img, 0);
    }

    private void highlightTrimmableSails(Graphics2D graphics) {
        if (!config.showTrimSailHighlights() || !plugin.isNeedsTrim()) {
            return;
        }
        var sail = plugin.getSailGameObject();
        if (sail == null || sail.getWorldView() == null) {
            return;
        }
        var hull = sail.getConvexHull();
        if (hull == null) {
            return;
        }
        OverlayUtil.renderPolygon(graphics, hull, config.trimSailHighlightColor());
    }

    private void renderPortalArrows(Graphics2D graphics, TrialRoute route, WorldPoint boatLoc) {
        var portalDirection = plugin.getVisiblePortalDirection(route);
        if (portalDirection == null) {
            return;
        }

        if (config.showPortalBoatArrows()) {
            renderHeadingTriangle(graphics, boatLoc, portalDirection.BoatDirection, config.portalBoatArrowColor(), 100, 18);
        }

        if (config.showPortalRouteArrows() && portalDirection.FirstMovementDirection != portalDirection.BoatDirection) {
            renderHeadingTriangle(graphics, boatLoc, portalDirection.FirstMovementDirection, config.portalRouteArrowColor(), 100, 18);
            renderHeadingTriangle(graphics, boatLoc, plugin.getHoveredHeadingDirection(), config.hoveredHeadingColor(), 100, 12);
        }
    }

    private void highlightBoatTrueTile(Graphics2D graphics, WorldPoint worldPoint) {
        var localPoints = WorldPerspective.getInstanceLocalPointFromReal(client, worldPoint);
        if (localPoints == null || localPoints.isEmpty()) {
            return;
        }

        for (var lp : localPoints) {
            if (lp == null)
                continue;
            var poly = Perspective.getCanvasTilePoly(client, lp);
            if (poly == null)
                continue;

            // Draw a translucent fill and a bold border so the tile is obvious
            Color fill = config.boatTrueTileFillColor();
            Color border = config.boatTrueTileBorderColor();
            Stroke oldStroke = graphics.getStroke();
            Composite oldComposite = graphics.getComposite();

            graphics.setColor(fill);
            graphics.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.5f));
            graphics.fill(poly);

            graphics.setComposite(oldComposite);
            graphics.setColor(border);
            graphics.setStroke(new BasicStroke(3f));
            graphics.draw(poly);

            // restore previous graphics state
            graphics.setStroke(oldStroke);
            graphics.setComposite(oldComposite);

            // only draw first matching instance tile
            break;
        }
    }

    private void renderHeadingTriangle(Graphics2D graphics, WorldPoint worldPoint, Directions direction, Color color, int offset, int size) {
        if (graphics == null || worldPoint == null || direction == null) {
            return;
        }

        if (color == null) {
            color = Color.WHITE;
        }

        if (offset <= 0) {
            offset = 10;
        }

        var lp = LocalPoint.fromWorld(client, worldPoint);

        if (lp == null) {
            //log.info("LP is null for worldPoint {}", worldPoint);
            return;
        }

        var poly = Perspective.getCanvasTilePoly(client, lp);
        if (poly == null) {
            //log.info("Poly is null for localPoint {}", lp);
            return;
        }

        Rectangle bounds = poly.getBounds();
        int centerX = bounds.x + bounds.width / 2;
        int centerY = bounds.y + bounds.height / 2;

        // Compute a world-space direction vector from the enum ordinal, then rotate by camera yaw.
        // Assume Directions is ordered starting at South and rotating counter-clockwise in 22.5° steps.
        int stepIndex = direction.ordinal();
        double angleRad = Math.toRadians(stepIndex * 22.5);
        // For stepIndex = 0 (South), we want wx=0, wy=-1, so use sin/cos with a 90° phase shift.
        double wx = -Math.sin(angleRad);
        double wy = -Math.cos(angleRad);

        int yaw = client.getCameraYaw() & 2047;
        double yawRad = yaw * (Math.PI / 1024.0);
        double baseAngle = Math.atan2(wx, wy);
        double total = yawRad + baseAngle;

        double dx = Math.sin(total);
        double dy = -Math.cos(total);

        int tipX = (int) Math.round(centerX + dx * offset);
        int tipY = (int) Math.round(centerY + dy * offset);

        int baseHalfWidth = size * 3 / 4;
        int baseBack = size;

        double leftAngle = Math.atan2(dy, dx) + Math.PI / 2.0;
        double rightAngle = Math.atan2(dy, dx) - Math.PI / 2.0;

        int baseCenterX = (int) Math.round(centerX + dx * (offset - baseBack));
        int baseCenterY = (int) Math.round(centerY + dy * (offset - baseBack));

        int leftX = (int) Math.round(baseCenterX + Math.cos(leftAngle) * baseHalfWidth);
        int leftY = (int) Math.round(baseCenterY + Math.sin(leftAngle) * baseHalfWidth);
        int rightX = (int) Math.round(baseCenterX + Math.cos(rightAngle) * baseHalfWidth);
        int rightY = (int) Math.round(baseCenterY + Math.sin(rightAngle) * baseHalfWidth);

        int[] xs = new int[] { tipX, leftX, rightX };
        int[] ys = new int[] { tipY, leftY, rightY };

        Color border = new Color(0, 0, 0, Math.min(255, color.getAlpha()));
        Stroke previous = graphics.getStroke();

        graphics.setColor(color);
        graphics.fillPolygon(xs, ys, 3);

        graphics.setColor(border);
        graphics.setStroke(new BasicStroke(1f));
        graphics.drawPolygon(xs, ys, 3);

        graphics.setStroke(previous);
    }

    void renderWindMoteCooldown(Graphics2D graphics) {
        if (!config.showSpeedBoostRemaining()) {
            return;
        }

        var durationTicks = plugin.getBoatSpeedBoostDuration();
        var elapsedTicks = client.getTickCount() - plugin.getWindMoteReleasedTick();

        if (plugin.getBoatSpeedBoostDuration() <= 0 || plugin.getWindMoteReleasedTick() <= 0 || elapsedTicks >= durationTicks) {
            return;
        }

        var remainingRatio = 1.0 - (double) elapsedTicks / (double) durationTicks;
        var button = plugin.getWindMoteButtonWidget();
        if (button == null || button.isHidden() || remainingRatio <= 0) {
            return;
        }

        var bounds = button.getBounds();
        if (bounds == null) {
            return;
        }

        var x = bounds.x;
        var y = bounds.y;
        var width = bounds.width;
        var height = bounds.height;
        //log.info("rendering wind mote cooldown overlay at x={}, y={}, width={}, height={}", x, y, width, height);

        if (width <= 0 || height <= 0) {
            return;
        }

        // Lerp color: remainingRatio=1 => green (0,255,0); remainingRatio=0 => red (255,0,0)
        int r = (int) Math.round(255 * (1.0 - remainingRatio));
        int g = (int) Math.round(255 * remainingRatio);
        int b = 0;
        Color durationColor = new Color(r, g, b, 150);

        var oldClip = graphics.getClip();
        var oldComposite = graphics.getComposite();
        var oldColor = graphics.getColor();

        graphics.setClip(new Rectangle(x, y, width, height));
        //graphics.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, .6f));
        graphics.setColor(durationColor);

        var centerX = x + width / 2;
        var centerY = y + height / 2;
        var radius = Math.max(width, height);
        var angle = (int) Math.round(remainingRatio * 360.0);
        // Draw remaining cooldown as a clockwise pie slice (use negative arcAngle for clockwise in AWT)
        graphics.fillArc(centerX - radius, centerY - radius, radius * 2, radius * 2, 90, angle);

        // Ticks remaining label (large font, centered). Color lerps from green->red as duration lowers.
        int ticksRemaining = durationTicks - elapsedTicks;
        if (ticksRemaining < 0) {
            ticksRemaining = 0;
        }

        var textColor = Color.YELLOW;

        // Choose a font size that fits inside the widget
        int baseSize = Math.min(width, height);
        float fontSize = Math.max(12f, baseSize * 0.6f);
        Font oldFont = graphics.getFont();
        Font bigFont = oldFont.deriveFont(Font.BOLD, fontSize);
        graphics.setFont(bigFont);
        FontMetrics fm = graphics.getFontMetrics();
        String label = String.valueOf(ticksRemaining);
        int textWidth = fm.stringWidth(label);
        int textHeight = fm.getAscent();
        int textX = x + (width - textWidth) / 2;
        int textY = y + (height + textHeight) / 2 - fm.getDescent();
        graphics.setColor(Color.BLACK);
        graphics.drawString(label, textX + 1, textY + 1); // shadow for readability
        graphics.setColor(textColor);
        graphics.drawString(label, textX, textY);
        graphics.setFont(oldFont);

        graphics.setClip(oldClip);
        graphics.setComposite(oldComposite);
        graphics.setColor(oldColor);
    }

}

package com.datbear;

import net.runelite.api.Client;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import java.awt.*;

import static net.runelite.api.MenuAction.RUNELITE_OVERLAY_CONFIG;
import static net.runelite.client.ui.overlay.OverlayManager.OPTION_CONFIGURE;

public class BearycudaTrialsPanel extends OverlayPanel {
    private Client client;
    private BearycudaTrialsPlugin plugin;
    private BearycudaTrialsConfig config;

    @Inject
    public BearycudaTrialsPanel(Client client, BearycudaTrialsPlugin plugin, BearycudaTrialsConfig config) {
        super(plugin);
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        setPosition(OverlayPosition.TOP_CENTER);
        getMenuEntries().add(
                new OverlayMenuEntry(
                        RUNELITE_OVERLAY_CONFIG,
                        OPTION_CONFIGURE,
                        "Bearycuda Trials Panel"));
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        // Clear previous children each frame to prevent uncontrolled growth
        panelComponent.getChildren().clear();
        // var container = client.getItemContainer(33733);
        // var itemCount = 0;
        // if (container != null) {
        // itemCount = container.count();
        // }
        // panelComponent.getChildren().add(
        // LineComponent.builder().left("Sailing!")
        // .right(plugin.getCargoItemCount() + " items").build());

        return super.render(graphics);
    }

}

package com.datbear;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import javax.inject.Inject;

import com.datbear.data.*;
import com.datbear.debug.BoatPathHelper;
import com.datbear.debug.BoatPathOverlay;
import com.datbear.ui.*;
import com.google.common.base.Strings;
import com.google.inject.Provides;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.DynamicObject;
import net.runelite.api.GameObject;
import net.runelite.api.GameState;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.Model;
import net.runelite.api.ObjectComposition;
import net.runelite.api.Point;
import net.runelite.api.Renderable;
import net.runelite.api.Scene;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.PostMenuSort;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.events.WorldViewUnloaded;
import net.runelite.api.gameval.ObjectID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.gameval.InterfaceID.SailingSidepanel;
import net.runelite.api.widgets.Widget;
import net.runelite.client.Notifier;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

@Slf4j @PluginDescriptor(name = "Bearycuda Trials", description = "Show info to help with barracuda trials", tags = { "overlay", "sailing", "barracuda", "trials" })
public class BearycudaTrialsPlugin extends Plugin {
    @Inject
    private Client client;

    @Inject
    private OverlayManager overlayManager;
    @Inject
    private Notifier notifier;

    @Inject
    private BearycudaTrialsConfig config;

    @Inject
    private BearycudaTrialsOverlay overlay;

    @Inject
    private BoatPathOverlay boatPathOverlay;

    private boolean boatPathOverlayAdded = false;

    @Inject
    private BearycudaTrialsPanel panel;

    @Provides
    BearycudaTrialsConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(BearycudaTrialsConfig.class);
    }

    private final Set<Integer> TRIAL_CRATE_ANIMS = Set.of(8867);
    private final Set<Integer> SPEED_BOOST_ANIMS = Set.of(13159, 13160, 13163);
    private final Set<Integer> DECORATION_ANIMS = Set.of(1071, 13537, 13538, 13539);

    private final String TRIM_AVAILABLE_TEXT = "you feel a gust of wind.";
    private final String TRIM_SUCCESS_TEXT = "you trim the sails";
    private final String TRIM_FAIL_TEXT = "the wind dies down";
    private final String WIND_MOTE_RELEASED_TEXT = "you release the wind mote for a burst of speed";

    private final String MENU_OPTION_START_PREVIOUS_RANK = "start-previous";
    private final String MENU_OPTION_QUICK_RESET = "quick-reset";
    private final String MENU_OPTION_STOP_NAVIGATING = "stop-navigating";
    private final String MENU_OPTION_UNSET = "un-set";

    private static final int VISIT_TOLERANCE = 10;

    private static final int WIND_MOTE_INACTIVE_SPRITE_ID = 7076;
    private static final int WIND_MOTE_ACTIVE_SPRITE_ID = 7075;

    private List<String> FirstMenuEntries = new ArrayList<String>();
    private List<String> DeprioritizeMenuEntriesDuringTrial = new ArrayList<String>();
    private List<String> RemoveMenuEntriesDuringTrial = new ArrayList<String>();

    @Getter(AccessLevel.PACKAGE)
    private TrialInfo currentTrial = null;

    @Getter(AccessLevel.PACKAGE)
    private boolean needsTrim = false;

    @Getter(AccessLevel.PACKAGE)
    private int lastVisitedIndex = -1;

    @Getter(AccessLevel.PACKAGE)
    private int toadsThrown = 0;

    // Number of consecutive game ticks where TrialInfo.getCurrent(client) returned null
    // Used to allow a grace period before clearing currentTrial during transient nulls
    private int nullTrialConsecutiveTicks = 0;

    private final Set<Integer> TRIAL_BOAT_GAMEOBJECT_IDS = Set.of(
            ObjectID.SAILING_BT_TEMPOR_TANTRUM_NORTH_LOC_PARENT,
            ObjectID.SAILING_BT_TEMPOR_TANTRUM_SOUTH_LOC_PARENT,
            ObjectID.SAILING_BT_JUBBLY_JIVE_TOAD_SUPPLIES_PARENT);

    private final Map<Integer, List<GameObject>> toadFlagsById = new HashMap<>();
    @Getter(AccessLevel.PACKAGE)
    private final Map<Integer, GameObject> trialCratesById = new HashMap<>();
    @Getter(AccessLevel.PACKAGE)
    private final Map<Integer, List<GameObject>> trialBoostsById = new HashMap<>();
    @Getter(AccessLevel.PACKAGE)
    private GameObject sailGameObject = null;

    @Getter(AccessLevel.PACKAGE)
    private final Map<Integer, List<GameObject>> obstacleGameObjectsById = new HashMap<>();
    @Getter(AccessLevel.PACKAGE)
    private final Set<WorldPoint> obstacleWorldPoints = new HashSet<>();

    @Getter(AccessLevel.PACKAGE)
    private Map<Integer, GameObject> trialBoatsById = new HashMap<>();

    @Getter(AccessLevel.PACKAGE)
    private Point lastMenuCanvasPosition = null;
    @Getter(AccessLevel.PACKAGE)
    private WorldPoint lastMenuCanvasWorldPoint = null;

    //varbits...
    @Getter(AccessLevel.PACKAGE)
    private int boatSpawnedAngle;

    @Getter(AccessLevel.PACKAGE)
    private int boatSpawnedFineX;

    @Getter(AccessLevel.PACKAGE)
    private int boatSpawnedFineZ;

    @Getter(AccessLevel.PACKAGE)
    private int boatBaseSpeed;

    @Getter(AccessLevel.PACKAGE)
    private int boatSpeedCap;

    @Getter(AccessLevel.PACKAGE)
    private int boatSpeedBoostDuration;

    @Getter(AccessLevel.PACKAGE)
    private int boatAcceleration;

    @Getter(AccessLevel.PACKAGE)
    private int isInTrial;

    @Getter(AccessLevel.PUBLIC)
    private int boardedBoat;

    @Getter(AccessLevel.PACKAGE)
    private Directions currentHeadingDirection = Directions.North;

    @Getter(AccessLevel.PACKAGE)
    private Directions requestedHeadingDirection = currentHeadingDirection;

    @Getter(AccessLevel.PACKAGE)
    private Directions hoveredHeadingDirection = Directions.North;

    @Getter(AccessLevel.PACKAGE)
    private int windMoteReleasedTick;

    @Getter(AccessLevel.PACKAGE)
    private Widget windMoteButtonWidget;

    @Getter(AccessLevel.PACKAGE)
    private double lastCratePickupDistance;

    @Getter(AccessLevel.PACKAGE)
    private double minCratePickupDistance;

    @Getter(AccessLevel.PACKAGE)
    private double maxCratePickupDistance;

    @Override
    protected void startUp() {
        //log.info("Bearycuda Trials Plugin started!");
        overlayManager.add(overlay);
        refreshBoatPathOverlayState();
        overlayManager.add(panel);

        //menu entries
        if (config.enableStartPreviousRankLeftClick()) {
            FirstMenuEntries.add(MENU_OPTION_START_PREVIOUS_RANK);
        }
        if (config.enableQuickResetLeftClick()) {
            FirstMenuEntries.add(MENU_OPTION_QUICK_RESET);
        }
        if (config.disableStopNavigating()) {
            DeprioritizeMenuEntriesDuringTrial.add(MENU_OPTION_STOP_NAVIGATING);
        }
        if (config.disableUnsetSail()) {
            DeprioritizeMenuEntriesDuringTrial.add(MENU_OPTION_UNSET);
        }
    }

    @Override
    protected void shutDown() {
        overlayManager.remove(overlay);
        overlayManager.remove(boatPathOverlay);
        boatPathOverlayAdded = false;
        overlayManager.remove(panel);
        reset();
        //log.info("BearycudaTrialsPlugin shutDown: panel removed and state reset.");
    }

    private void refreshBoatPathOverlayState() {
        if (config.enableBoatPathDebug()) {
            if (!boatPathOverlayAdded) {
                overlayManager.add(boatPathOverlay);
                boatPathOverlayAdded = true;
            }
        } else if (boatPathOverlayAdded) {
            overlayManager.remove(boatPathOverlay);
            boatPathOverlayAdded = false;
        }
    }

    @Subscribe
    public void onClientTick(ClientTick clientTick) {
        if (!config.enableBoatPathDebug()) {
            return;
        }

        var localPlayer = client.getLocalPlayer();
        if (localPlayer == null) {
            return;
        }

        var tick = client.getTickCount();
        var position = BoatLocation.fromLocal(client, localPlayer.getLocalLocation());
        if (tick <= 0 || position == null) {
            return;
        }

        //log.info("Client tick! {} {}", tick, position);

        if (BoatPathHelper.HasTickData(tick)) {
            //log.info("Adding visited point for tick {}: {}", tick, position);
            BoatPathHelper.AddVisitedPoint(tick, position);
        } else {
            BoatPathHelper.StartNewTick(tick, position, currentHeadingDirection);
        }
    }

    @Subscribe
    public void onGameTick(GameTick tick) {
        if (client == null || client.getLocalPlayer() == null) {
            return;
        }

        updateFromVarbits();
        updateCurrentTrial();
        updateCurrentHeading();

        updateWindMoteButtonWidget();

        final var player = client.getLocalPlayer();
        var boatLocation = BoatLocation.fromLocal(client, player.getLocalLocation());

        if (boatLocation == null)
            return;

        TrialRoute active = getActiveTrialRoute();
        if (active != null) {
            markNextWaypointVisited(boatLocation, active, VISIT_TOLERANCE);
        }
    }

    @Subscribe
    public void onVarbitChanged(VarbitChanged event) {
        if (event.getVarbitId() == VarbitID.SAILING_BOAT_SPAWNED_ANGLE) {
            //log.info("[ANGLE VARBIT CHANGED] {}", event.getValue());
            boatSpawnedAngle = event.getValue();
            updateCurrentHeadingFromVarbit(boatSpawnedAngle);
        }

        trackCratePickups(event);
    }

    private void updateCurrentHeadingFromVarbit(int value) {
        var ordinal = value / 128;
        Directions[] directions = Directions.values();
        if (ordinal < 0 || ordinal >= directions.length) {
            return;
        }
        var newDir = directions[ordinal];
        //log.info("[UPDATE HEADING FROM VARBIT] {} = {}", value, newDir);
        currentHeadingDirection = newDir;
    }

    @Subscribe
    public void onGameObjectSpawned(GameObjectSpawned event) {
        var obj = event.getGameObject();
        if (obj == null) {
            return;
        }
        var id = obj.getId();

        var isToadFlag = ToadFlagGameObject.All.stream().anyMatch(t -> t.GameObjectIds.contains(id));
        if (isToadFlag) {
            toadFlagsById.computeIfAbsent(id, k -> new ArrayList<>()).add(obj);
        }
        var isTrialBoat = TRIAL_BOAT_GAMEOBJECT_IDS.contains(id);
        if (isTrialBoat) {
            trialBoatsById.put(id, obj);
            //log.info("Tracked trial boat gameobject id {} at {} - {}", id, obj.getWorldLocation(), BoatLocation.fromLocal(client, obj.getLocalLocation()));

        }

        var isObstacle = ObstacleTracking.OBSTACLE_GAMEOBJECT_IDS.contains(id);
        if (isObstacle && config.showObstacleOutlines()) {
            obstacleGameObjectsById.computeIfAbsent(id, k -> new ArrayList<>()).add(obj);
            // Add world points for all tiles covered by this obstacle's footprint
            try {
                var worldView = client.getTopLevelWorldView();
                var scene = worldView != null ? worldView.getScene() : null;
                if (scene != null) {
                    var min = obj.getSceneMinLocation();
                    var max = obj.getSceneMaxLocation();
                    if (min != null && max != null) {
                        int plane = worldView.getPlane();
                        for (int x = min.getX(); x <= max.getX(); x++) {
                            for (int y = min.getY(); y <= max.getY(); y++) {
                                WorldPoint wp = WorldPoint.fromScene(worldView, x, y, plane);
                                obstacleWorldPoints.add(wp);
                            }
                        }
                    } else {
                        obstacleWorldPoints.add(obj.getWorldLocation());
                    }
                } else {
                    obstacleWorldPoints.add(obj.getWorldLocation());
                }
            } catch (Exception ex) {
                obstacleWorldPoints.add(obj.getWorldLocation());
            }
            if (currentTrial != null) {
                removeGameObjectFromScene(obj);
            }
        }
        var isSail = AllSails.GAMEOBJECT_IDS.contains(id);
        if (isSail) {
            sailGameObject = obj;
        }
        var renderable = obj.getRenderable();
        if (renderable != null) {
            if (renderable instanceof DynamicObject) {
                var dynObj = (DynamicObject) renderable;
                var anim = dynObj.getAnimation();
                var animId = anim != null ? anim.getId() : -1;
                if (TRIAL_CRATE_ANIMS.contains(animId)) {
                    trialCratesById.put(id, obj);
                } else if (SPEED_BOOST_ANIMS.contains(animId)) {
                    trialBoostsById.computeIfAbsent(id, k -> new ArrayList<>()).add(obj);
                } else if (DECORATION_ANIMS.contains(animId)) {
                    if (config.hideDecorations()) {
                        removeGameObjectFromScene(obj);
                    }
                }
            }
        }
    }

    @Subscribe
    public void onGameObjectDespawned(GameObjectDespawned event) {
        var obj = event.getGameObject();
        if (obj == null)
            return;
        var id = obj.getId();
        List<GameObject> cacheList = toadFlagsById.get(id);
        if (cacheList != null) {
            cacheList.removeIf(x -> x == null || x.getHash() == obj.getHash());
            if (cacheList.isEmpty()) {
                toadFlagsById.remove(id);
            }
        }
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event) {
        if (event.getGameState() == GameState.LOADING) {
            // on region changes the tiles and gameobjects get set to null
            reset();
        } else if (event.getGameState() == GameState.LOGIN_SCREEN) {

        }
    }

    @Subscribe
    public void onWorldViewUnloaded(WorldViewUnloaded event) {
        for (var boat : trialBoatsById.values()) {
            if (event.getWorldView() == boat.getWorldView()) {
                //log.info("Removing trial boat gameobject id {} at {} due to world view unload", boat.getId(), boat.getWorldLocation());
                trialBoatsById.remove(boat.getId());
            }
        }
    }

    @Subscribe
    public void onMenuOptionClicked(MenuOptionClicked event) {
        RouteModificationHelper.handleMenuOptionClicked(event, client, getActiveTrialRoute(), lastMenuCanvasPosition, lastVisitedIndex);
        handleHeadingClicks(event);

        if (!config.showDebugMenuCopyTileOptions()) {
            return;
        }

        final var copyOption = "Copy worldpoint";
        final var copyTileOption = "Copy tile worldpoint";
        if (event.getMenuOption() != null && event.getMenuOption().equals(copyOption)) {
            var player = client.getLocalPlayer();
            if (player == null)
                return;

            var wp = BoatLocation.fromLocal(client, player.getLocalLocation());
            if (wp == null)
                return;

            var toCopy = String.format("new WorldPoint(%d, %d, %d),", wp.getX(), wp.getY(), wp.getPlane());

            try {
                var sel = new java.awt.datatransfer.StringSelection(toCopy);
                java.awt.Toolkit.getDefaultToolkit().getSystemClipboard().setContents(sel, null);
                notifier.notify("Copied worldpoint to clipboard: " + toCopy);
            } catch (Exception ex) {
                log.warn("Failed to copy worldpoint to clipboard: {}", ex.toString());
            }

            event.consume();
        } else if (event.getMenuOption() != null && event.getMenuOption().equals(copyTileOption)) {
            var mouse = lastMenuCanvasPosition != null ? lastMenuCanvasPosition : client.getMouseCanvasPosition();
            lastMenuCanvasWorldPoint = null;

            try {
                var worldView = client.getTopLevelWorldView();
                var scene = worldView.getScene();
                var z = worldView.getPlane();
                var tiles = scene.getTiles();

                if (tiles != null && z >= 0 && z < tiles.length) {
                    var plane = tiles[z];
                    for (var x = 0; x < plane.length; x++) {
                        for (var y = 0; y < plane[x].length; y++) {
                            var tile = plane[x][y];
                            if (tile == null)
                                continue;
                            var lp = tile.getLocalLocation();
                            var poly = net.runelite.api.Perspective.getCanvasTilePoly(client, lp);
                            if (poly == null || mouse == null)
                                continue;
                            if (poly.contains(mouse.getX(), mouse.getY())) {
                                lastMenuCanvasWorldPoint = WorldPoint.fromLocalInstance(client, lp);
                                break;
                            }
                        }
                        if (lastMenuCanvasWorldPoint != null)
                            break;
                    }
                }
            } catch (Throwable ex) {
                // fall back to null
            }

            var worldPoint = lastMenuCanvasWorldPoint == null ? client.getLocalPlayer() == null ? null
                    : client.getLocalPlayer().getWorldLocation() : lastMenuCanvasWorldPoint;
            if (worldPoint == null)
                return;

            var toCopy = String.format("new WorldPoint(%d, %d, %d),", worldPoint.getX(), worldPoint.getY(), worldPoint.getPlane());
            try {
                var sel = new java.awt.datatransfer.StringSelection(toCopy);
                java.awt.Toolkit.getDefaultToolkit().getSystemClipboard().setContents(sel, null);
                notifier.notify("Copied tile worldpoint to clipboard: " + toCopy);
            } catch (Exception ex) {
                log.warn("Failed to copy tile worldpoint to clipboard: {}", ex.toString());
            }

            event.consume();
            // Clear the stored menu-open position so we don't reuse it on subsequent clicks
            lastMenuCanvasPosition = null;
        }
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        if (event == null) {
            return;
        }
        // Only react to our plugin's config group
        if (!event.getGroup().equals("bearycudaTrials")) {
            return;
        }

        if (config.enableStartPreviousRankLeftClick()) {
            if (FirstMenuEntries.stream().noneMatch(x -> x.equals(MENU_OPTION_START_PREVIOUS_RANK))) {
                FirstMenuEntries.add(MENU_OPTION_START_PREVIOUS_RANK);
            }
        } else {
            if (FirstMenuEntries.stream().anyMatch(x -> x.equals(MENU_OPTION_START_PREVIOUS_RANK))) {
                FirstMenuEntries.remove(MENU_OPTION_START_PREVIOUS_RANK);
            }
        }

        if (config.enableQuickResetLeftClick()) {
            if (FirstMenuEntries.stream().noneMatch(x -> x.equals(MENU_OPTION_QUICK_RESET))) {
                FirstMenuEntries.add(MENU_OPTION_QUICK_RESET);
            }
        } else {
            if (FirstMenuEntries.stream().anyMatch(x -> x.equals(MENU_OPTION_QUICK_RESET))) {
                FirstMenuEntries.remove(MENU_OPTION_QUICK_RESET);
            }
        }

        if (config.disableStopNavigating()) {
            if (DeprioritizeMenuEntriesDuringTrial.stream().noneMatch(x -> x.equals(MENU_OPTION_STOP_NAVIGATING))) {
                DeprioritizeMenuEntriesDuringTrial.add(MENU_OPTION_STOP_NAVIGATING);
            }
        } else {
            if (DeprioritizeMenuEntriesDuringTrial.stream().anyMatch(x -> x.equals(MENU_OPTION_STOP_NAVIGATING))) {
                DeprioritizeMenuEntriesDuringTrial.remove(MENU_OPTION_STOP_NAVIGATING);
            }
        }

        if (config.disableUnsetSail()) {
            if (DeprioritizeMenuEntriesDuringTrial.stream().noneMatch(x -> x.equals(MENU_OPTION_UNSET))) {
                DeprioritizeMenuEntriesDuringTrial.add(MENU_OPTION_UNSET);
            }
        } else {
            if (DeprioritizeMenuEntriesDuringTrial.stream().anyMatch(x -> x.equals(MENU_OPTION_UNSET))) {
                DeprioritizeMenuEntriesDuringTrial.remove(MENU_OPTION_UNSET);
            }
        }

        refreshBoatPathOverlayState();
    }

    @Subscribe
    public void onChatMessage(ChatMessage e) {
        if (e.getType() != ChatMessageType.GAMEMESSAGE && e.getType() != ChatMessageType.SPAM) {
            //log.info("[CHAT-IGNORED] {}", e.getMessage());
            return;
        }

        String msg = e.getMessage().toLowerCase();
        //log.info("[CHAT] {}", msg);
        if (msg == null || msg.isEmpty()) {
            return;
        }

        if (msg.contains(WIND_MOTE_RELEASED_TEXT)) {
            windMoteReleasedTick = client.getTickCount();
        }
        if (msg.contains(TRIM_AVAILABLE_TEXT)) {
            needsTrim = true;
        } else if (msg.contains(TRIM_SUCCESS_TEXT) || msg.contains(TRIM_FAIL_TEXT)) {
            needsTrim = false;
        }
    }

    @Subscribe(priority = -1)
    public void onPostMenuSort(PostMenuSort e) {
        manageHeadingHovers(e);

        if (client.isMenuOpen()) {
            return;
        }
        var entries = client.getMenuEntries();

        entries = swapMenuEntries(entries);
        entries = addDebugMenuEntries(entries);

        if (currentTrial != null && !DeprioritizeMenuEntriesDuringTrial.isEmpty()) {
            entries = deprioritizeMenuEntries(entries, DeprioritizeMenuEntriesDuringTrial);
        }
        if (currentTrial != null && !RemoveMenuEntriesDuringTrial.isEmpty()) {
            entries = removeMenuEntries(entries, RemoveMenuEntriesDuringTrial);
        }

        if (currentTrial != null && config.showDebugRouteModificationOptions()) {
            entries = RouteModificationHelper.addRouteModificationEntries(client, entries, getActiveTrialRoute());
        }

        client.setMenuEntries(entries);
    }

    private void updateCurrentTrial() {
        TrialInfo newTrialInfo = TrialInfo.getCurrent(client);

        // Allow a grace period of 18 game ticks where TrialInfo may be null (e.g., region/load transitions) before clearing currentTrial.
        // We only apply the null after 18 consecutive null ticks.
        if (newTrialInfo != null) {
            // If trial info reappears, clear any null-grace countdown
            nullTrialConsecutiveTicks = 0;

            // If the trial changed (location/rank/reset time), reset route state
            if (currentTrial == null || currentTrial.Location != newTrialInfo.Location || currentTrial.Rank != newTrialInfo.Rank || newTrialInfo.CurrentTimeSeconds < currentTrial.CurrentTimeSeconds) {
                resetRouteData();
            }

            updateToadsThrown(newTrialInfo);
            currentTrial = newTrialInfo;
        } else {
            if (currentTrial != null) {
                nullTrialConsecutiveTicks += 1;
                if (nullTrialConsecutiveTicks >= 18) {
                    resetRouteData();
                    currentTrial = null;
                }
            } else {
                nullTrialConsecutiveTicks = 0;
            }
        }
    }

    private MenuEntry[] removeMenuEntries(MenuEntry[] entries, Collection<String> toRemove) {
        if (entries == null || entries.length == 0 || toRemove == null || toRemove.isEmpty()) {
            return entries;
        }
        var entryList = new ArrayList<MenuEntry>(Arrays.asList(entries));
        var it = entryList.iterator();
        while (it.hasNext()) {
            var menuEntry = it.next();
            if (menuEntry == null) {
                continue;
            }
            var opt = menuEntry.getOption();
            if (opt == null) {
                continue;
            }
            if (toRemove.stream().anyMatch(x -> opt.toLowerCase().contains(x))) {
                it.remove();
            }
        }
        return entryList.toArray(new MenuEntry[0]);
    }

    private MenuEntry[] deprioritizeMenuEntries(MenuEntry[] entries, Collection<String> toRemove) {
        if (entries == null || entries.length == 0 || toRemove == null || toRemove.isEmpty()) {
            return entries;
        }
        var walkHereEntry = Arrays.stream(entries)
                .filter(x -> x != null && x.getOption().toLowerCase().equals("walk here") || x.getOption().toLowerCase().equals("set heading"))
                .findFirst().orElse(null);
        var entryList = new ArrayList<MenuEntry>(Arrays.asList(entries));
        var it = entryList.iterator();
        while (it.hasNext()) {
            var menuEntry = it.next();
            if (menuEntry == null) {
                continue;
            }
            var opt = menuEntry.getOption();
            if (opt == null) {
                continue;
            }
            if (toRemove.stream().anyMatch(x -> opt.toLowerCase().contains(x))) {
                if (walkHereEntry != null) {
                    var walkIdx = entryList.indexOf(walkHereEntry);
                    var currIdx = entryList.indexOf(menuEntry);
                    entryList.set(walkIdx, menuEntry);
                    entryList.set(currIdx, walkHereEntry);
                }
            }
        }
        return entryList.toArray(new MenuEntry[0]);
    }

    private MenuEntry[] swapMenuEntries(MenuEntry[] entries) {
        if (entries == null || entries.length == 0) {
            return entries;
        }
        var toMove = new ArrayList<MenuEntry>();
        var entriesAsList = new ArrayList<>(Arrays.asList(entries));
        var it = entriesAsList.iterator();
        while (it.hasNext()) {
            var menuEntry = it.next();
            if (menuEntry == null) {
                continue;
            }
            var opt = menuEntry.getOption();
            if (opt == null) {
                continue;
            }
            if (FirstMenuEntries.stream().anyMatch(x -> opt.toLowerCase().contains(x))) {
                toMove.add(menuEntry);
                it.remove();
            }
        }
        if (!toMove.isEmpty()) {
            entriesAsList.addAll(toMove);
        }
        entries = entriesAsList.toArray(new MenuEntry[0]);
        return entries;
    }

    private MenuEntry[] addDebugMenuEntries(MenuEntry[] entries) {
        if (!config.showDebugMenuCopyTileOptions()) {
            return entries;
        }

        var p = client.getLocalPlayer();
        if (p == null) {
            return entries;
        }

        var hasCopyPlayerLocation = false;
        var hasCopyTileLocation = false;
        if (entries != null) {
            for (var entry : entries) {
                if (entry == null) {
                    continue;
                }
                if (entry.getOption().equals("Copy worldpoint")) {
                    hasCopyPlayerLocation = true;
                }
                if (entry.getOption().equals("Copy tile worldpoint")) {
                    hasCopyTileLocation = true;
                }
            }
        }

        var list = new ArrayList<MenuEntry>();

        if (!hasCopyTileLocation) {
            var copyTile = client.getMenu().createMenuEntry(-1).setOption("Copy tile worldpoint")
                    .setTarget("").setType(MenuAction.RUNELITE);
            list.add(copyTile);
        }

        if (!hasCopyPlayerLocation) {
            var copyPlayer = client.getMenu().createMenuEntry(-1).setOption("Copy worldpoint")
                    .setTarget("").setType(MenuAction.RUNELITE);
            list.add(copyPlayer);
        }

        // Capture the menu-open canvas position so we can later use that exact location for "Copy tile worldpoint" when the menu item is clicked.
        lastMenuCanvasPosition = client.getMouseCanvasPosition();
        if (entries != null) {
            list.addAll(Arrays.asList(entries));
        }
        return list.toArray(new MenuEntry[0]);
    }

    private void resetRouteData() {
        lastVisitedIndex = -1;
        toadsThrown = 0;
    }

    private void reset() {
        // Clear runtime caches and tracked state on region change / shutdown
        toadFlagsById.clear();
        trialCratesById.clear();
        trialBoostsById.clear();
        sailGameObject = null;
        requestedHeadingDirection = currentHeadingDirection;
    }

    private void updateToadsThrown(TrialInfo newTrialInfo) {
        if (currentTrial == null) {
            toadsThrown = 0;
            return;
        }
        if (newTrialInfo.ToadCount < currentTrial.ToadCount) {
            toadsThrown += 1;
        }
    }

    public void markNextWaypointVisited(final WorldPoint player, final TrialRoute route, final int tolerance) {
        if (player == null || route == null || route.Points == null || route.Points.isEmpty()) {
            return;
        }
        int nextIdx = lastVisitedIndex + 1;
        if (nextIdx >= route.Points.size()) {
            return; // finished route
        }
        WorldPoint target = route.Points.get(nextIdx);
        if (target == null) {
            return;
        }
        double dist = Math.hypot(player.getX() - target.getX(), player.getY() - target.getY());
        if (dist <= tolerance) {
            lastVisitedIndex = nextIdx;
            //log.info("Visited waypoint {} / {} for route {}", lastVisitedIndex, route.Points.size() - 1, route.Rank);
        }
    }

    public List<Integer> getNextIndicesAfterLastVisited(final TrialRoute route, final int limit) {
        if (route == null || route.Points == null || route.Points.isEmpty() || limit <= 0) {
            return Collections.emptyList();
        }
        int start = Math.max(0, lastVisitedIndex);
        if (start >= route.Points.size()) {
            return Collections.emptyList();
        }
        List<Integer> out = new ArrayList<>(limit);
        var nextPortal = route.PortalDirections.stream()
                .filter(x -> x.Index >= lastVisitedIndex)
                .min((a, b) -> Integer.compare(a.Index, b.Index))
                .orElse(null);
        for (int i = start; i < route.Points.size() && out.size() < limit; i++) {
            if (nextPortal != null && i > nextPortal.Index) {
                break;
            }
            out.add(i);
        }
        return out;
    }

    public List<WorldPoint> getVisibleLineForRoute(final WorldPoint player, final TrialRoute route, final int limit) {
        if (player == null || route == null || lastVisitedIndex == -1) {
            return Collections.emptyList();
        }

        final List<Integer> nextIdx = getNextIndicesAfterLastVisited(route, limit);
        if (nextIdx.isEmpty()) {
            return Collections.emptyList();
        }

        List<WorldPoint> out = new ArrayList<>();
        for (int idx : nextIdx) {
            WorldPoint real = route.Points.get(idx);
            out.add(real);
        }
        return out;
    }

    public PortalDirection getVisiblePortalDirection(TrialRoute route) {
        var portalDirection = route.PortalDirections.stream()
                .filter(x -> x.Index - 1 == lastVisitedIndex || x.Index == lastVisitedIndex || x.Index + 1 == lastVisitedIndex)
                .min((a, b) -> Integer.compare(a.Index, b.Index))
                .orElse(null);

        return portalDirection;
    }

    public List<GameObject> getToadFlagGameObjectsForIds(Set<Integer> ids) {
        var out = new ArrayList<GameObject>();
        if (ids == null || ids.isEmpty()) {
            return out;
        }
        for (int id : ids) {
            var list = toadFlagsById.get(id);
            if (list != null && !list.isEmpty()) {
                out.addAll(list);
            }
        }
        return out;
    }

    public TrialRoute getActiveTrialRoute() {
        if (currentTrial == null)
            return null;

        for (TrialRoute route : TrialRoute.AllTrialRoutes) {
            if (route == null) {
                continue;
            }

            if (route.Location == currentTrial.Location && route.Rank == currentTrial.Rank) {
                return route;
            }
        }
        return null;
    }

    public List<WorldPoint> getVisibleActiveLineForPlayer(final WorldPoint player, final int limit) {
        var route = getActiveTrialRoute();
        if (route == null) {
            return Collections.emptyList();
        }

        return getVisibleLineForRoute(player, route, limit);
    }

    public List<Integer> getNextUnvisitedIndicesForActiveRoute(final int limit) {
        var route = getActiveTrialRoute();
        if (route == null) {
            return Collections.emptyList();
        }
        return getNextIndicesAfterLastVisited(route, limit);
    }

    public int getHighlightedToadFlagIndex() {
        var route = getActiveTrialRoute();
        if (route == null || currentTrial == null) {
            return 0;
        }
        return getHighlightedToadFlagIndex(route);
    }

    private int getHighlightedToadFlagIndex(TrialRoute route) {
        return toadsThrown < route.ToadOrder.size() ? toadsThrown : 0;
    }

    public List<GameObject> getToadFlagToHighlight() {
        if (currentTrial == null || currentTrial.Location != TrialLocations.JubblyJive || currentTrial.ToadCount <= 0) {
            return Collections.emptyList();
        }

        var route = getActiveTrialRoute();
        if (route == null || route.ToadOrder == null || route.ToadOrder.isEmpty()) {
            return Collections.emptyList();
        }

        var nextToadIdx = getHighlightedToadFlagIndex(route);
        if (nextToadIdx >= 0 && nextToadIdx < route.ToadOrder.size()) {
            var nextToadColor = route.ToadOrder.get(nextToadIdx);
            var nextToadGameObject = ToadFlagGameObject.getByColor(nextToadColor);
            List<GameObject> cached = getToadFlagGameObjectsForIds(nextToadGameObject.GameObjectIds);
            if (!cached.isEmpty()) {
                return cached;
            }
        }

        return Collections.emptyList();
    }

    public Collection<GameObject> getTrialBoatsToHighlight() {
        var route = getActiveTrialRoute();
        if (route == null || currentTrial == null || trialBoatsById.isEmpty()) {
            return Collections.emptyList();
        }

        if (route.Location == TrialLocations.JubblyJive && !currentTrial.HasToads) {
            return trialBoatsById.values();
        }

        if (route.Location == TrialLocations.TemporTantrum) {
            if (currentTrial.HasRum) {
                var boat = trialBoatsById.get(ObjectID.SAILING_BT_TEMPOR_TANTRUM_NORTH_LOC_PARENT);
                if (boat != null) {
                    return List.of(boat);
                }
            } else {
                var boat = trialBoatsById.get(ObjectID.SAILING_BT_TEMPOR_TANTRUM_SOUTH_LOC_PARENT);
                if (boat != null) {
                    return List.of(boat);
                }
            }
        }

        return Collections.emptyList();
    }

    private void handleHeadingClicks(MenuOptionClicked event) {
        if (event.getMenuAction() != MenuAction.SET_HEADING) {
            return;
        }
        //log.info("[SET HEADING] {}", event);
        requestedHeadingDirection = Directions.values()[event.getId()];
    }

    private void updateCurrentHeading() {
        if (currentHeadingDirection == null) {
            currentHeadingDirection = Directions.South;
        }

        if (requestedHeadingDirection == null) {
            requestedHeadingDirection = currentHeadingDirection;
            return;
        }

        if (currentHeadingDirection == requestedHeadingDirection) {
            return;
        }

        Directions[] all = Directions.values();
        int n = all.length;
        int currentIndex = currentHeadingDirection.ordinal();
        int targetIndex = requestedHeadingDirection.ordinal();

        int forwardSteps = (targetIndex - currentIndex + n) % n;
        int backwardSteps = (currentIndex - targetIndex + n) % n;

        if (forwardSteps == 0) {
            return;
        }

        if (forwardSteps <= backwardSteps) {
            currentIndex = (currentIndex + 1) % n;
        } else {
            currentIndex = (currentIndex - 1 + n) % n;
        }

        currentHeadingDirection = all[currentIndex];
    }

    private void manageHeadingHovers(PostMenuSort event) {
        var entries = client.getMenuEntries();
        var headingEntry = Arrays.stream(entries)
                .filter(e -> e.getOption().equals("Set heading"))
                .findFirst().orElse(null);
        if (headingEntry != null) {
            //log.info("[SET HEADING HOVER] {}", headingEntry);
            hoveredHeadingDirection = Directions.values()[headingEntry.getIdentifier()];
        }
    }

    private void updateFromVarbits() {
        //todo check VarbitID.SAILING_BOAT_TIME_TILL_TRIM and VarbitID.SAILING_BOAT_TIME_TRIM_WINDOW to see if they're working in the future
        boatSpawnedAngle = client.getVarbitValue(VarbitID.SAILING_BOAT_SPAWNED_ANGLE);
        boatSpawnedFineX = client.getVarbitValue(VarbitID.SAILING_BOAT_SPAWNED_FINEX);
        boatSpawnedFineZ = client.getVarbitValue(VarbitID.SAILING_BOAT_SPAWNED_FINEZ);
        boatBaseSpeed = client.getVarbitValue(VarbitID.SAILING_SIDEPANEL_BOAT_BASESPEED);
        boatSpeedCap = client.getVarbitValue(VarbitID.SAILING_SIDEPANEL_BOAT_SPEEDCAP);
        boatSpeedBoostDuration = client.getVarbitValue(VarbitID.SAILING_SIDEPANEL_BOAT_SPEEDBOOST_DURATION);
        boatAcceleration = client.getVarbitValue(VarbitID.SAILING_SIDEPANEL_BOAT_ACCELERATION);
        isInTrial = client.getVarbitValue(VarbitID.SAILING_BT_IN_TRIAL);
        boardedBoat = client.getVarbitValue(VarbitID.SAILING_BOARDED_BOAT);
    }

    private void removeGameObjectFromScene(GameObject gameObject) {
        if (gameObject != null) {
            Renderable renderable = gameObject == null ? null : gameObject.getRenderable();
            if (renderable != null) {
                Model model = renderable instanceof Model ? (Model) renderable : renderable.getModel();
                if (model != null) {
                    Scene scene = client.getTopLevelWorldView().getScene();
                    if (scene != null) {
                        scene.removeGameObject(gameObject);
                    }
                }
            }
        }
    }

    private void updateWindMoteButtonWidget() {
        if (boardedBoat == 0) {
            windMoteButtonWidget = null;
            return;
        }

        if (windMoteButtonWidget != null && !windMoteButtonWidget.isHidden()) {
            return;
        }

        var widget = client.getWidget(SailingSidepanel.FACILITIES_ROWS);
        if (widget == null) {
            //log.info("updateWindMoteButtonWidget: FACILITIES_ROWS widget is null");
            return;
        }

        Widget[] facilityChildren = widget.getChildren();
        Widget button = null;
        if (facilityChildren != null) {
            for (Widget childWidget : facilityChildren) {
                if (childWidget != null && (childWidget.getSpriteId() == WIND_MOTE_INACTIVE_SPRITE_ID || childWidget.getSpriteId() == WIND_MOTE_ACTIVE_SPRITE_ID)) {
                    button = childWidget;
                    break;
                }
            }
        }
        if (button != null) {
            //log.info("updateWindMoteButtonWidget: found wind mote button widget");
            if (windMoteButtonWidget == null) {
                windMoteButtonWidget = button;
            }
        }
    }

    private void trackCratePickups(VarbitChanged event) {
        if (!config.enableCratePickupDebug()) {
            return;
        }

        if (event.getVarbitId() >= VarbitID.SAILING_BT_OBJECTIVE0 && event.getVarbitId() <= VarbitID.SAILING_BT_OBJECTIVE95) {
            if (!config.enableCratePickupDebug()) {
                return;
            }
            var closestCrate = getClosestTrialCrate();
            if (closestCrate != null) {
                var player = client.getLocalPlayer();
                if (player != null) {
                    var playerPoint = BoatLocation.fromLocal(client, player.getLocalLocation());
                    if (playerPoint != null) {
                        var cratePoint = closestCrate.getWorldLocation();
                        lastCratePickupDistance = Math.hypot(Math.abs(playerPoint.getX() - cratePoint.getX()), Math.abs(playerPoint.getY() - cratePoint.getY()));
                        log.info("Picked up crate from distance: {}", lastCratePickupDistance);
                        if (minCratePickupDistance == 0 || lastCratePickupDistance < minCratePickupDistance) {
                            minCratePickupDistance = lastCratePickupDistance;
                        }
                        if (lastCratePickupDistance > maxCratePickupDistance) {
                            maxCratePickupDistance = lastCratePickupDistance;
                        }
                    }
                }
            }
        }
    }

    private GameObject getClosestTrialCrate() {
        if (!config.enableCratePickupDebug()) {
            return null;
        }

        GameObject closest = null;
        double closestDist = Double.MAX_VALUE;

        var player = client.getLocalPlayer();
        if (player == null) {
            return null;
        }
        var playerPoint = BoatLocation.fromLocal(client, player.getLocalLocation());
        if (playerPoint == null) {
            return null;
        }

        for (var crateEntry : trialCratesById.entrySet()) {
            var crate = crateEntry.getValue();
            if (crate == null) {
                continue;
            }
            var cratePoint = crate.getWorldLocation();
            double dist = playerPoint.distanceTo(cratePoint);
            if (dist < closestDist) {
                closestDist = dist;
                closest = crate;
            }
        }
        return closest;
    }

    private void logCrateAndBoostSpawns(GameObjectSpawned event) {
        GameObject gameObject = event.getGameObject();
        if (gameObject == null) {
            return;
        }

        Renderable renderable = gameObject.getRenderable();
        if (!(renderable instanceof net.runelite.api.DynamicObject)) {
            return; // not an animating dynamic object
        }

        net.runelite.api.DynamicObject dyn = (net.runelite.api.DynamicObject) renderable;
        net.runelite.api.Animation anim = dyn.getAnimation();
        if (anim == null) {
            return;
        }

        final int animId = anim.getId();
        final boolean isCrateAnim = TRIAL_CRATE_ANIMS.contains(animId);
        final boolean isSpeedAnim = SPEED_BOOST_ANIMS.contains(animId);

        if (!isCrateAnim && !isSpeedAnim) {
            return; // ignore unrelated animations
        }

        WorldPoint wp = gameObject.getWorldLocation();

        ObjectComposition objectComposition = client.getObjectDefinition(gameObject.getId());
        if (objectComposition.getImpostorIds() == null) {
            String name = objectComposition.getName();
            //log.info("Gameobject (id={}) spawned with name='{}'", gameObject.getId(), name);
            if (Strings.isNullOrEmpty(name) || name.equals("null")) {
                // name has changed?
                return;
            }
        }

        var minLocation = gameObject.getSceneMinLocation();
        var poly = gameObject.getCanvasTilePoly();

        String type = isCrateAnim ? "CRATE" : "SPEED BOOST";
        if (wp != null) {
            if (isCrateAnim) {
                log.info("[SPAWN] {} -> GameObject id={} world={} (hash={}) minLocation={} poly={}", type, animId, gameObject.getId(), wp, gameObject.getHash(), minLocation, poly);
            }

        } else {
            log.info("[SPAWN] {} -> GameObject id={} (no world point available)", type, gameObject.getId());
        }
    }

}

package com.datbear;

import net.runelite.api.Client;
import net.runelite.api.WorldEntity;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;

public class BoatLocation {
    public static WorldPoint fromLocal(Client client, LocalPoint local) {
        if (local == null) {
            return null;
        }

        WorldView wv = client.getLocalPlayer().getWorldView();
        int wvid = wv.getId();
        boolean isOnBoat = wvid != -1;
        if (isOnBoat) {
            WorldEntity we = client.getTopLevelWorldView().worldEntities().byIndex(wvid);
            return WorldPoint.fromLocalInstance(client, we.getLocalLocation());
        }
        return WorldPoint.fromLocalInstance(client, local);
    }
}
package com.datbear.data;

import java.util.List;

import net.runelite.api.gameval.ObjectID;

public class AllSails {
    public static final List<Integer> GAMEOBJECT_IDS = List.of(
            ObjectID.SAILING_BOAT_SAIL_KANDARIN_1X3_WOOD,
            ObjectID.SAILING_BOAT_SAIL_KANDARIN_2X5_WOOD,
            ObjectID.SAILING_BOAT_SAIL_KANDARIN_3X8_WOOD,
            ObjectID.SAILING_BOAT_SAIL_KANDARIN_1X3_OAK,
            ObjectID.SAILING_BOAT_SAIL_KANDARIN_2X5_OAK,
            ObjectID.SAILING_BOAT_SAIL_KANDARIN_3X8_OAK,
            ObjectID.SAILING_BOAT_SAIL_KANDARIN_1X3_TEAK,
            ObjectID.SAILING_BOAT_SAIL_KANDARIN_2X5_TEAK,
            ObjectID.SAILING_BOAT_SAIL_KANDARIN_3X8_TEAK,
            ObjectID.SAILING_BOAT_SAIL_KANDARIN_3X8_MAHOGANY,
            ObjectID.SAILING_BOAT_SAIL_KANDARIN_3X8_MAHOGANY,
            ObjectID.SAILING_BOAT_SAIL_KANDARIN_3X8_MAHOGANY,
            ObjectID.SAILING_BOAT_SAIL_KANDARIN_1X3_CAMPHOR,
            ObjectID.SAILING_BOAT_SAIL_KANDARIN_2X5_CAMPHOR,
            ObjectID.SAILING_BOAT_SAIL_KANDARIN_3X8_CAMPHOR,
            ObjectID.SAILING_BOAT_SAIL_KANDARIN_1X3_IRONWOOD,
            ObjectID.SAILING_BOAT_SAIL_KANDARIN_2X5_IRONWOOD,
            ObjectID.SAILING_BOAT_SAIL_KANDARIN_3X8_IRONWOOD,
            ObjectID.SAILING_BOAT_SAIL_KANDARIN_1X3_ROSEWOOD,
            ObjectID.SAILING_BOAT_SAIL_KANDARIN_2X5_ROSEWOOD,
            ObjectID.SAILING_BOAT_SAIL_KANDARIN_3X8_ROSEWOOD);
}

package com.datbear.data;

import net.runelite.api.coords.WorldPoint;

public class BoostLocation {
    public int GameObjectId;
    public WorldPoint Location;

    public BoostLocation(int gameObjectId, WorldPoint location) {
        GameObjectId = gameObjectId;
        Location = location;
    }
}

package com.datbear.data;

import net.runelite.api.coords.WorldPoint;

public class CrateLocation {
    public int GameObjectId;
    public WorldPoint Location;
    public TrialLocations TrialLocation;
    public TrialRanks MinimumRank;

    public CrateLocation(int gameObjectId, WorldPoint location, TrialLocations trialLocation, TrialRanks minimumRank) {
        GameObjectId = gameObjectId;
        Location = location;
        TrialLocation = trialLocation;
        MinimumRank = minimumRank;
    }
}

package com.datbear.data;

public enum Directions {
    South,
    SouthSouthWest,
    SouthWest,
    WestSouthWest,
    West,
    WestNorthWest,
    NorthWest,
    NorthNorthWest,
    North,
    NorthNorthEast,
    NorthEast,
    EastNorthEast,
    East,
    EastSouthEast,
    SouthEast,
    SouthSouthEast
}

package com.datbear.data;

public class ObjectiveInfo {
    public int Collected;
    public int TotalNeeded;

    public ObjectiveInfo() {
        Collected = 0;
        TotalNeeded = 0;
    }
}
package com.datbear.data;

import java.util.Set;

public class ObstacleTracking {
    public static final Set<Integer> OBSTACLE_GAMEOBJECT_IDS = Set.of(
            //jubbly jive obstacles
            60361,
            60362,
            60363,

            //gwenith glide obstacles
            59109,
            59116,
            59110,
            59108,
            59094,
            59095,
            59098,
            59115,
            60415,
            58978
    //
    );
}

package com.datbear.data;

public enum PortalColors {
    White,
    Blue,
    Green,
    Yellow,
    Red,
    Black,
    Cyan,
    Pink
}

package com.datbear.data;

public class PortalDirection {
    public int Index;
    public PortalColors Color;
    public Directions BoatDirection;
    public Directions FirstMovementDirection;

    public PortalDirection(int index, PortalColors color, Directions boatDirection, Directions firstMovementDirection) {
        Index = index;
        Color = color;
        BoatDirection = boatDirection;
        FirstMovementDirection = firstMovementDirection;
    }

}

package com.datbear.data;

public enum ToadFlagColors {
    Green,
    Yellow,
    Red,
    Blue,
    Orange,
    Teal,
    Pink,
    White
}

package com.datbear.data;

import java.util.List;
import java.util.Set;

public class ToadFlagGameObject {
    public Set<Integer> GameObjectIds;
    public ToadFlagColors Color;

    public ToadFlagGameObject(Set<Integer> gameObjectIds, ToadFlagColors color) {
        GameObjectIds = gameObjectIds;
        Color = color;
    }

    public static ToadFlagGameObject Green = new ToadFlagGameObject(Set.of(59121, 59124), ToadFlagColors.Green);
    public static ToadFlagGameObject Yellow = new ToadFlagGameObject(Set.of(59127, 59130), ToadFlagColors.Yellow);
    public static ToadFlagGameObject Red = new ToadFlagGameObject(Set.of(59133, 59136), ToadFlagColors.Red);
    public static ToadFlagGameObject Blue = new ToadFlagGameObject(Set.of(59139, 59142), ToadFlagColors.Blue);
    public static ToadFlagGameObject Orange = new ToadFlagGameObject(Set.of(59145, 59148), ToadFlagColors.Orange);
    public static ToadFlagGameObject Teal = new ToadFlagGameObject(Set.of(59151, 59154), ToadFlagColors.Teal);
    public static ToadFlagGameObject Pink = new ToadFlagGameObject(Set.of(59157, 59160), ToadFlagColors.Pink);
    public static ToadFlagGameObject White = new ToadFlagGameObject(Set.of(59163, 59166), ToadFlagColors.White);

    public static List<ToadFlagGameObject> All = List.of(
            Green,
            Yellow,
            Red,
            Blue,
            Orange,
            Teal,
            Pink,
            White);

    public static ToadFlagGameObject getByColor(ToadFlagColors color) {
        for (var toadGameObject : All) {
            if (toadGameObject.Color == color) {
                return toadGameObject;
            }
        }
        return null;
    }
}

package com.datbear.data;

import java.util.regex.Pattern;

import com.google.common.base.Strings;

import net.runelite.api.Client;
import net.runelite.api.gameval.InterfaceID.SailingBtHud;

public class TrialInfo {

    public TrialLocations Location;
    public TrialRanks Rank;

    public int CurrentTimeSeconds;
    public int GoalTimeSeconds;

    public String ObjectiveText;
    public int CollectedPrimaryObjectives;
    public int TotalPrimaryObjectivesNeeded;

    public int CollectedCrates;
    public int TotalCratesNeeded;

    public boolean HasRum;
    public boolean HasToads;
    public int ToadCount;

    public static TrialInfo getCurrent(Client client) {
        var trialWidget = client.getWidget(SailingBtHud.BARRACUDA_TRIALS);
        if (trialWidget == null || trialWidget.isHidden()) {
            return null;
        }

        var info = new TrialInfo();
        var locationText = client.getWidget(SailingBtHud.BT_TITLE).getChild(9).getText();
        info.Location = parseLocation(locationText);

        var rankSprite = client.getWidget(SailingBtHud.BT_RANK_GFX).getSpriteId();
        info.Rank = parseRank(rankSprite);

        var currentTimeSecondsString = client.getWidget(SailingBtHud.BT_CURRENT_TIME).getText();
        info.CurrentTimeSeconds = parseTimeSeconds(currentTimeSecondsString);

        var goalTimeSecondsString = client.getWidget(SailingBtHud.BT_RANK_TIME).getText();
        info.GoalTimeSeconds = parseTimeSeconds(goalTimeSecondsString);

        var primaryObjectiveText = client.getWidget(SailingBtHud.BT_TRACKER_PROGRESS).getText();
        var crateText = client.getWidget(SailingBtHud.BT_OPTIONAL_PROGRESS).getText();

        var primaryObjectiveInfo = parseObjectiveText(primaryObjectiveText);
        info.CollectedPrimaryObjectives = primaryObjectiveInfo.Collected;
        info.TotalPrimaryObjectivesNeeded = primaryObjectiveInfo.TotalNeeded;

        var crateInfo = parseObjectiveText(crateText);
        info.CollectedCrates = crateInfo.Collected;
        info.TotalCratesNeeded = crateInfo.TotalNeeded;

        var partialGfxSpriteId = client.getWidget(SailingBtHud.BT_PARTIAL_GFX).getSpriteId();
        info.HasRum = HasRum(info.Location, partialGfxSpriteId);
        info.HasToads = HasToads(info.Location, partialGfxSpriteId);

        var partialText = client.getWidget(SailingBtHud.BT_PARTIAL_TEXT).getText();
        info.ToadCount = ToadCount(info.Location, partialText);

        return info;
    }

    @Override
    public String toString() {
        return String.format("Location=%s, Rank=%s, PrimaryObjectives=%d/%d, Crates=%d/%d, HasRum=%b, HasFrogs=%b", Location.toString(), Rank.toString(), CollectedPrimaryObjectives, TotalPrimaryObjectivesNeeded, CollectedCrates, TotalCratesNeeded, HasRum, HasToads);
    }

    private static int parseTimeSeconds(String timeText) {
        if (Strings.isNullOrEmpty(timeText)) {
            return 0;
        }

        var pattern = Pattern.compile("(\\d+):(\\d+)");
        var matcher = pattern.matcher(timeText);
        if (matcher.find() && matcher.groupCount() == 2) {
            var minutes = Integer.parseInt(matcher.group(1));
            var seconds = Integer.parseInt(matcher.group(2));
            return minutes * 60 + seconds;
        }
        return 0;
    }

    private static boolean HasToads(TrialLocations location, int spriteId) {
        switch (location) {
            case JubblyJive:
                return spriteId == 7024;
            default:
                return false;
        }
    }

    private static int ToadCount(TrialLocations location, String text) {
        switch (location) {
            case JubblyJive:
                var pattern = Pattern.compile("(\\d+)");
                var matcher = pattern.matcher(text);
                if (matcher.find() && matcher.groupCount() == 1) {
                    return Integer.parseInt(matcher.group(1));
                }
                return 0;
            default:
                return 0;
        }
    }

    private static boolean HasRum(TrialLocations location, int spriteId) {
        switch (location) {
            case TemporTantrum:
                return spriteId == 7022;
            default:
                return false;
        }
    }

    private static ObjectiveInfo parseObjectiveText(String text) {
        var info = new ObjectiveInfo();
        if (Strings.isNullOrEmpty(text)) {
            return info;
        }

        var pattern = Pattern.compile("(\\d+) / (\\d+).*?");
        var matcher = pattern.matcher(text);
        if (matcher.find() && matcher.groupCount() == 2) {
            info.Collected = Integer.parseInt(matcher.group(1));
            info.TotalNeeded = Integer.parseInt(matcher.group(2));
        }
        return info;
    }

    private static TrialRanks parseRank(int spriteId) {
        switch (spriteId) {
            case 7026:
                return TrialRanks.Unranked;// todo check
            case 7027:
                return TrialRanks.Swordfish;
            case 7028:
                return TrialRanks.Shark;
            case 7029:
                return TrialRanks.Marlin;
        }
        return TrialRanks.Unknown;
    }

    private static TrialLocations parseLocation(String text) {
        if (Strings.isNullOrEmpty(text)) {
            return TrialLocations.Unknown;
        }

        switch (text) {
            case "Gwenith Glide":
                return TrialLocations.GwenithGlide;
            case "Jubbly Jive":
                return TrialLocations.JubblyJive;
            case "Tempor Tantrum":
                return TrialLocations.TemporTantrum;
        }
        return TrialLocations.Unknown;
    }
}

package com.datbear.data;

public enum TrialLocations {
    TemporTantrum,
    JubblyJive,
    GwenithGlide,

    Unknown
}

package com.datbear.data;

public enum TrialRanks {
    Unranked,
    Swordfish,
    Shark,
    Marlin,

    Unknown,
}

package com.datbear.data;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;

import net.runelite.api.coords.WorldPoint;

public class TrialRoute {
        public TrialLocations Location;
        public TrialRanks Rank;
        public List<WorldPoint> Points;
        public List<ToadFlagColors> ToadOrder;
        public List<Integer> WindMoteIndices;
        public List<PortalDirection> PortalDirections;

        public TrialRoute(TrialLocations location, TrialRanks rank, List<WorldPoint> points) {
                Location = location;
                Rank = rank;
                Points = points == null ? new ArrayList<>() : new ArrayList<>(points); // ensure mutable
                ToadOrder = Collections.emptyList();
                WindMoteIndices = Collections.emptyList();
                PortalDirections = Collections.emptyList();
        }

        // Unified extended constructor to avoid type erasure collision between different generic list overloads.
        public TrialRoute(TrialLocations location, TrialRanks rank, List<WorldPoint> points, List<ToadFlagColors> toadOrder, List<Integer> windMoteIndices, List<PortalDirection> portalDirections) {
                this(location, rank, points);
                ToadOrder = toadOrder == null ? Collections.emptyList() : toadOrder;
                WindMoteIndices = windMoteIndices == null ? Collections.emptyList() : windMoteIndices;
                PortalDirections = portalDirections == null ? Collections.emptyList() : portalDirections;
        }

        @Override
        public boolean equals(Object o) {
                if (this == o)
                        return true;
                if (o == null || getClass() != o.getClass())
                        return false;
                TrialRoute that = (TrialRoute) o;
                return Location == that.Location && Rank == that.Rank;
        }

        @Override
        public int hashCode() {
                return Objects.hash(Location, Rank);
        }

        private static final List<WorldPoint> TemporTantrumSwordfishBestLine = new ArrayList<>(
                        List.of(
                                        new WorldPoint(3035, 2922, 0), // start
                                        new WorldPoint(3025, 2911, 0),
                                        new WorldPoint(3017, 2900, 0),
                                        new WorldPoint(2996, 2896, 0),
                                        new WorldPoint(2994, 2882, 0),
                                        new WorldPoint(2979, 2866, 0),
                                        new WorldPoint(2983, 2839, 0),
                                        new WorldPoint(2979, 2827, 0),
                                        new WorldPoint(2990, 2809, 0),
                                        new WorldPoint(3001, 2787, 0),
                                        new WorldPoint(3013, 2769, 0),
                                        new WorldPoint(3022, 2762, 0),
                                        new WorldPoint(3039, 2760, 0),
                                        new WorldPoint(3056, 2763, 0),
                                        new WorldPoint(3054, 2763, 0),
                                        new WorldPoint(3057, 2792, 0),
                                        new WorldPoint(3065, 2811, 0),
                                        new WorldPoint(3078, 2827, 0),
                                        new WorldPoint(3078, 2864, 0),
                                        new WorldPoint(3084, 2875, 0),
                                        new WorldPoint(3091, 2887, 0),
                                        new WorldPoint(3072, 2916, 0),
                                        new WorldPoint(3052, 2920, 0),
                                        new WorldPoint(3035, 2922, 0) // end
                        ));

        private static final List<WorldPoint> TemporTantrumSharkBestLine = new ArrayList<>(
                        List.of(
                                        new WorldPoint(3035, 2922, 0), // start
                                        new WorldPoint(3017, 2898, 0),
                                        new WorldPoint(3017, 2889, 0),
                                        new WorldPoint(3001, 2869, 0),
                                        new WorldPoint(3002, 2858, 0),
                                        new WorldPoint(3004, 2827, 0),
                                        new WorldPoint(3009, 2816, 0),
                                        new WorldPoint(3019, 2814, 0),
                                        new WorldPoint(3027, 2798, 0),
                                        new WorldPoint(3039, 2778, 0),
                                        new WorldPoint(3045, 2777, 0),
                                        new WorldPoint(3057, 2792, 0),
                                        new WorldPoint(3069, 2814, 0),
                                        new WorldPoint(3076, 2825, 0),
                                        new WorldPoint(3082, 2873, 0),
                                        new WorldPoint(3076, 2883, 0),
                                        new WorldPoint(3077, 2896, 0),
                                        new WorldPoint(3060, 2906, 0),
                                        new WorldPoint(3040, 2921, 0),
                                        new WorldPoint(3027, 2913, 0),
                                        new WorldPoint(3013, 2910, 0),
                                        new WorldPoint(2994, 2896, 0),
                                        new WorldPoint(2994, 2882, 0),
                                        new WorldPoint(2977, 2865, 0),
                                        new WorldPoint(2982, 2847, 0),
                                        new WorldPoint(2979, 2830, 0),
                                        new WorldPoint(2991, 2806, 0),
                                        new WorldPoint(3014, 2763, 0),
                                        new WorldPoint(3038, 2758, 0),
                                        new WorldPoint(3054, 2761, 0),
                                        new WorldPoint(3066, 2768, 0),
                                        new WorldPoint(3075, 2776, 0),
                                        new WorldPoint(3084, 2801, 0),
                                        new WorldPoint(3081, 2813, 0),
                                        new WorldPoint(3094, 2828, 0),
                                        new WorldPoint(3093, 2843, 0),
                                        new WorldPoint(3093, 2864, 0),
                                        new WorldPoint(3100, 2872, 0),
                                        new WorldPoint(3092, 2884, 0),
                                        new WorldPoint(3073, 2916, 0),
                                        new WorldPoint(3053, 2921, 0),
                                        new WorldPoint(3035, 2922, 0) // end
                        ));

        private static final List<WorldPoint> TemporTantrumMarlinBestLine = new ArrayList<>(
                        List.of(
                                        // Trial Route:
                                        /*0*/new WorldPoint(3035, 2922, 0),
                                        /*1*/new WorldPoint(3017, 2898, 0),
                                        /*2*/new WorldPoint(3017, 2889, 0),
                                        /*3*/new WorldPoint(3001, 2869, 0),
                                        /*4*/new WorldPoint(3002, 2858, 0),
                                        /*5*/new WorldPoint(3004, 2827, 0),
                                        /*6*/new WorldPoint(3009, 2816, 0),
                                        /*7*/new WorldPoint(3019, 2814, 0),
                                        /*8*/new WorldPoint(3030, 2815, 0),
                                        /*9*/new WorldPoint(3027, 2798, 0),
                                        /*10*/new WorldPoint(3039, 2778, 0),
                                        /*11*/new WorldPoint(3045, 2777, 0),
                                        /*12*/new WorldPoint(3057, 2792, 0),
                                        /*13*/new WorldPoint(3069, 2814, 0),
                                        /*14*/new WorldPoint(3076, 2825, 0),
                                        /*15*/new WorldPoint(3078, 2863, 0),
                                        /*16*/new WorldPoint(3082, 2873, 0),
                                        /*17*/new WorldPoint(3073, 2875, 0),
                                        /*18*/new WorldPoint(3060, 2882, 0),
                                        /*19*/new WorldPoint(3060, 2906, 0),
                                        /*20*/new WorldPoint(3035, 2917, 0),
                                        /*21*/new WorldPoint(3027, 2913, 0),
                                        /*22*/new WorldPoint(3013, 2910, 0),
                                        /*23*/new WorldPoint(2994, 2896, 0),
                                        /*24*/new WorldPoint(2994, 2882, 0),
                                        /*25*/new WorldPoint(2977, 2865, 0),
                                        /*26*/new WorldPoint(2982, 2847, 0),
                                        /*27*/new WorldPoint(2979, 2830, 0),
                                        /*28*/new WorldPoint(2991, 2806, 0),
                                        /*29*/new WorldPoint(3016, 2776, 0),
                                        /*30*/new WorldPoint(3038, 2771, 0),
                                        /*31*/new WorldPoint(3045, 2776, 0),
                                        /*32*/new WorldPoint(3066, 2768, 0),
                                        /*33*/new WorldPoint(3075, 2776, 0),
                                        /*34*/new WorldPoint(3084, 2801, 0),
                                        /*35*/new WorldPoint(3081, 2813, 0),
                                        /*36*/new WorldPoint(3094, 2828, 0),
                                        /*37*/new WorldPoint(3093, 2843, 0),
                                        /*38*/new WorldPoint(3093, 2864, 0),
                                        /*39*/new WorldPoint(3100, 2872, 0),
                                        /*40*/new WorldPoint(3092, 2884, 0),
                                        /*41*/new WorldPoint(3073, 2916, 0),
                                        /*42*/new WorldPoint(3053, 2921, 0),
                                        /*43*/new WorldPoint(3035, 2922, 0),
                                        /*44*/new WorldPoint(3012, 2910, 0),
                                        /*45*/new WorldPoint(2993, 2895, 0),
                                        /*46*/new WorldPoint(2979, 2883, 0),
                                        /*47*/new WorldPoint(2962, 2882, 0),
                                        /*48*/new WorldPoint(2956, 2872, 0),
                                        /*49*/new WorldPoint(2965, 2865, 0),
                                        /*50*/new WorldPoint(2966, 2851, 0),
                                        /*51*/new WorldPoint(2958, 2840, 0),
                                        /*52*/new WorldPoint(2953, 2810, 0),
                                        /*53*/new WorldPoint(2968, 2794, 0),
                                        /*54*/new WorldPoint(2983, 2787, 0),
                                        /*55*/new WorldPoint(2987, 2777, 0),
                                        /*56*/new WorldPoint(3004, 2768, 0),
                                        /*57*/new WorldPoint(3039, 2758, 0),
                                        /*58*/new WorldPoint(3056, 2761, 0),
                                        /*59*/new WorldPoint(3068, 2766, 0),
                                        /*60*/new WorldPoint(3090, 2764, 0),
                                        /*61*/new WorldPoint(3098, 2774, 0),
                                        /*62*/new WorldPoint(3103, 2797, 0),
                                        /*63*/new WorldPoint(3110, 2825, 0),
                                        /*64*/new WorldPoint(3118, 2836, 0),
                                        /*65*/new WorldPoint(3117, 2850, 0),
                                        /*66*/new WorldPoint(3121, 2864, 0),
                                        /*67*/new WorldPoint(3103, 2878, 0),
                                        /*68*/new WorldPoint(3082, 2900, 0),
                                        /*69*/new WorldPoint(3072, 2917, 0),
                                        /*70*/new WorldPoint(3059, 2921, 0),
                                        /*71*/new WorldPoint(3035, 2922, 0)
                        // End of trial route
                        ));

        private static final List<WorldPoint> JubblySwordfishBestLine = new ArrayList<>(
                        List.of(
                                        new WorldPoint(2436, 3018, 0),
                                        new WorldPoint(2423, 3012, 0),
                                        new WorldPoint(2413, 3015, 0),
                                        new WorldPoint(2396, 3010, 0),
                                        new WorldPoint(2373, 3008, 0),
                                        new WorldPoint(2357, 2991, 0),
                                        new WorldPoint(2353, 2979, 0),
                                        new WorldPoint(2342, 2974, 0),
                                        new WorldPoint(2323, 2976, 0),
                                        new WorldPoint(2309, 2974, 0),
                                        new WorldPoint(2285, 2980, 0),
                                        new WorldPoint(2267, 2990, 0),
                                        new WorldPoint(2251, 2995, 0),
                                        new WorldPoint(2239, 3005, 0),
                                        new WorldPoint(2239, 3016, 0),
                                        new WorldPoint(2252, 3025, 0),
                                        new WorldPoint(2261, 3021, 0),
                                        new WorldPoint(2281, 2999, 0),
                                        new WorldPoint(2298, 3002, 0),
                                        new WorldPoint(2300, 3014, 0),
                                        new WorldPoint(2311, 3021, 0),
                                        new WorldPoint(2352, 3004, 0),
                                        new WorldPoint(2360, 2999, 0),
                                        new WorldPoint(2358, 2969, 0),
                                        new WorldPoint(2358, 2960, 0),
                                        new WorldPoint(2374, 2940, 0),
                                        new WorldPoint(2428, 2939, 0),
                                        new WorldPoint(2435, 2949, 0),
                                        new WorldPoint(2436, 2985, 0),
                                        new WorldPoint(2437, 2990, 0),
                                        new WorldPoint(2433, 3005, 0),
                                        new WorldPoint(2436, 3018, 0)//end
                        ));

        private static final List<ToadFlagColors> JubblySwordfishToadOrder = List.of(
                        ToadFlagColors.Orange,
                        ToadFlagColors.Teal,
                        ToadFlagColors.Pink,
                        ToadFlagColors.White//end
        );

        private static final List<WorldPoint> JubblySharkBestLine = new ArrayList<>(
                        List.of(
                                        new WorldPoint(2436, 3018, 0),
                                        new WorldPoint(2422, 3012, 0),
                                        new WorldPoint(2413, 3016, 0),
                                        new WorldPoint(2402, 3017, 0),
                                        new WorldPoint(2395, 3010, 0),
                                        new WorldPoint(2378, 3008, 0),
                                        new WorldPoint(2362, 2998, 0),
                                        new WorldPoint(2351, 2979, 0),
                                        new WorldPoint(2340, 2973, 0),
                                        new WorldPoint(2330, 2974, 0),
                                        new WorldPoint(2299, 2975, 0),
                                        new WorldPoint(2276, 2984, 0),
                                        new WorldPoint(2263, 2992, 0),
                                        new WorldPoint(2250, 2993, 0),
                                        new WorldPoint(2239, 3007, 0), // collect toad
                                        new WorldPoint(2240, 3016, 0),
                                        new WorldPoint(2250, 3023, 0),
                                        new WorldPoint(2253, 3025, 0),
                                        new WorldPoint(2261, 3021, 0),
                                        new WorldPoint(2278, 3001, 0),
                                        new WorldPoint(2295, 3000, 0), // click yellow outcrop
                                        new WorldPoint(2299, 3007, 0),
                                        new WorldPoint(2302, 3017, 0), // click red outcrop
                                        new WorldPoint(2310, 3021, 0),
                                        new WorldPoint(2329, 3016, 0),
                                        new WorldPoint(2339, 3004, 0),
                                        new WorldPoint(2345, 2990, 0),
                                        new WorldPoint(2359, 2974, 0),
                                        new WorldPoint(2358, 2965, 0),
                                        new WorldPoint(2365, 2948, 0), // click yellow outcrop
                                        new WorldPoint(2373, 2939, 0),
                                        new WorldPoint(2386, 2940, 0),
                                        new WorldPoint(2399, 2939, 0),
                                        new WorldPoint(2420, 2938, 0), // click green outcrop
                                        new WorldPoint(2426, 2936, 0),
                                        new WorldPoint(2434, 2949, 0),
                                        new WorldPoint(2434, 2969, 0),
                                        new WorldPoint(2438, 2989, 0),
                                        new WorldPoint(2438, 2989, 0), // click pink outcrop
                                        new WorldPoint(2434, 2998, 0),
                                        new WorldPoint(2432, 3021, 0),
                                        new WorldPoint(2413, 3026, 0), // click white outcrop
                                        new WorldPoint(2402, 3021, 0),
                                        new WorldPoint(2394, 3020, 0),
                                        new WorldPoint(2382, 3025, 0),
                                        new WorldPoint(2370, 3022, 0),
                                        new WorldPoint(2357, 3025, 0),
                                        new WorldPoint(2340, 3031, 0),
                                        new WorldPoint(2333, 3028, 0),
                                        new WorldPoint(2327, 3016, 0),
                                        new WorldPoint(2339, 3006, 0),
                                        new WorldPoint(2353, 3005, 0), // click blue outcrop
                                        new WorldPoint(2379, 2993, 0),
                                        new WorldPoint(2384, 2985, 0),
                                        new WorldPoint(2379, 2974, 0),
                                        new WorldPoint(2388, 2959, 0), // click orange outcrop
                                        new WorldPoint(2403, 2951, 0),
                                        new WorldPoint(2413, 2955, 0),
                                        new WorldPoint(2420, 2959, 0), // click teal outcrop
                                        new WorldPoint(2424, 2974, 0),
                                        new WorldPoint(2418, 2988, 0), // click pink outcrop
                                        new WorldPoint(2414, 2993, 0),
                                        new WorldPoint(2417, 3003, 0), //click white outcrop
                                        new WorldPoint(2436, 3023, 0) // end
                        ));

        private static final List<ToadFlagColors> JubblySharkToadOrder = List.of(
                        ToadFlagColors.Yellow,
                        ToadFlagColors.Red,
                        ToadFlagColors.Orange,
                        ToadFlagColors.Teal,
                        ToadFlagColors.Pink,
                        ToadFlagColors.White,
                        ToadFlagColors.Blue,
                        ToadFlagColors.Orange,
                        ToadFlagColors.Teal,
                        ToadFlagColors.Pink,
                        ToadFlagColors.White //fin
        );

        private static final List<WorldPoint> JubblyMarlinBestLine = new ArrayList<>(
                        List.of(
                                        /*0*/new WorldPoint(2436, 3018, 0),
                                        /*1*/new WorldPoint(2424, 3025, 0),
                                        /*2*/new WorldPoint(2412, 3026, 0),
                                        /*3*/new WorldPoint(2405, 3023, 0),
                                        /*4*/new WorldPoint(2400, 3011, 0),
                                        /*5*/new WorldPoint(2396, 3009, 0),
                                        /*6*/new WorldPoint(2373, 3009, 0),
                                        /*7*/new WorldPoint(2350, 2977, 0),
                                        /*8*/new WorldPoint(2332, 2974, 0),
                                        /*9*/new WorldPoint(2303, 2975, 0),
                                        /*10*/new WorldPoint(2281, 2980, 0),
                                        /*11*/new WorldPoint(2265, 2991, 0),
                                        /*12*/new WorldPoint(2251, 2994, 0),
                                        /*13*/new WorldPoint(2248, 3000, 0),
                                        /*14*/new WorldPoint(2268, 3013, 0),
                                        /*15*/new WorldPoint(2280, 3000, 0),
                                        /*16*/new WorldPoint(2298, 3001, 0),
                                        /*17*/new WorldPoint(2302, 3017, 0),
                                        /*18*/new WorldPoint(2316, 3023, 0),
                                        /*19*/new WorldPoint(2350, 2981, 0),
                                        /*20*/new WorldPoint(2359, 2958, 0),
                                        /*21*/new WorldPoint(2375, 2936, 0),
                                        /*22*/new WorldPoint(2387, 2940, 0),
                                        /*23*/new WorldPoint(2420, 2939, 0),
                                        /*24*/new WorldPoint(2434, 2942, 0),
                                        /*25*/new WorldPoint(2435, 2967, 0),
                                        /*26*/new WorldPoint(2435, 2986, 0),
                                        /*27*/new WorldPoint(2437, 2991, 0),
                                        /*28*/new WorldPoint(2433, 3004, 0),
                                        /*29*/new WorldPoint(2435, 3010, 0),
                                        /*30*/new WorldPoint(2422, 3012, 0),
                                        /*31*/new WorldPoint(2415, 3000, 0),
                                        /*32*/new WorldPoint(2414, 2990, 0),
                                        /*33*/new WorldPoint(2423, 2978, 0),
                                        /*34*/new WorldPoint(2421, 2964, 0),
                                        /*35*/new WorldPoint(2417, 2957, 0),
                                        /*36*/new WorldPoint(2405, 2950, 0),
                                        /*37*/new WorldPoint(2390, 2957, 0),
                                        /*38*/new WorldPoint(2380, 2974, 0),
                                        /*39*/new WorldPoint(2384, 2985, 0),
                                        /*40*/new WorldPoint(2384, 2989, 0),
                                        /*41*/new WorldPoint(2369, 2997, 0),
                                        /*42*/new WorldPoint(2359, 2991, 0),
                                        /*43*/new WorldPoint(2350, 2977, 0),
                                        /*44*/new WorldPoint(2340, 2974, 0),
                                        /*45*/new WorldPoint(2305, 2974, 0),
                                        /*46*/new WorldPoint(2288, 2980, 0),
                                        /*47*/new WorldPoint(2278, 2981, 0),
                                        /*48*/new WorldPoint(2268, 2990, 0),
                                        /*49*/new WorldPoint(2256, 2992, 0),
                                        /*50*/new WorldPoint(2238, 3006, 0),
                                        /*51*/new WorldPoint(2242, 3020, 0),
                                        /*52*/new WorldPoint(2251, 3025, 0),
                                        /*53*/new WorldPoint(2257, 3024, 0),
                                        /*54*/new WorldPoint(2280, 2999, 0),
                                        /*55*/new WorldPoint(2292, 2997, 0), //wind mote HERE
                                        /*56*/new WorldPoint(2312, 2987, 0),
                                        /*57*/new WorldPoint(2324, 2984, 0),
                                        /*58*/new WorldPoint(2333, 2977, 0),
                                        /*59*/new WorldPoint(2335, 2954, 0),
                                        /*60*/new WorldPoint(2345, 2931, 0),
                                        /*61*/new WorldPoint(2365, 2928, 0),
                                        /*62*/new WorldPoint(2378, 2942, 0),
                                        /*63*/new WorldPoint(2395, 2939, 0),
                                        /*64*/new WorldPoint(2400, 2927, 0),
                                        /*65*/new WorldPoint(2417, 2924, 0),
                                        /*66*/new WorldPoint(2427, 2921, 0),
                                        /*67*/new WorldPoint(2442, 2927, 0),
                                        /*68*/new WorldPoint(2454, 2930, 0),
                                        /*69*/new WorldPoint(2469, 2953, 0),
                                        /*70*/new WorldPoint(2447, 2974, 0),
                                        /*71*/new WorldPoint(2447, 2986, 0), //wind mote HERE
                                        /*72*/new WorldPoint(2445, 3009, 0),
                                        /*73*/new WorldPoint(2437, 3010, 0),
                                        /*74*/new WorldPoint(2434, 3007, 0),
                                        /*75*/new WorldPoint(2403, 3017, 0),
                                        /*76*/new WorldPoint(2395, 3020, 0),
                                        /*77*/new WorldPoint(2387, 3020, 0),
                                        /*78*/new WorldPoint(2378, 3026, 0),
                                        /*79*/new WorldPoint(2371, 3022, 0),
                                        /*80*/new WorldPoint(2355, 3023, 0),
                                        /*81*/new WorldPoint(2343, 3031, 0),
                                        /*82*/new WorldPoint(2329, 3030, 0),
                                        /*83*/new WorldPoint(2313, 3045, 0),
                                        /*84*/new WorldPoint(2304, 3038, 0),
                                        /*85*/new WorldPoint(2313, 3025, 0),
                                        /*86*/new WorldPoint(2341, 3007, 0),
                                        /*87*/new WorldPoint(2355, 3005, 0),
                                        /*88*/new WorldPoint(2361, 3000, 0),
                                        /*89*/new WorldPoint(2390, 2986, 0),
                                        /*90*/new WorldPoint(2418, 2961, 0),
                                        /*91*/new WorldPoint(2430, 2953, 0), //shoot teal
                                        /*92*/new WorldPoint(2435, 2965, 0),
                                        /*93*/new WorldPoint(2433, 3000, 0),
                                        new WorldPoint(2436, 3023, 0) // end
                        ));

        private static final List<ToadFlagColors> JubblyMarlinToadOrder = List.of(
                        ToadFlagColors.Yellow,
                        ToadFlagColors.Red,
                        ToadFlagColors.Orange,
                        ToadFlagColors.Teal,
                        ToadFlagColors.Pink,
                        ToadFlagColors.White,
                        ToadFlagColors.Teal,
                        ToadFlagColors.Orange,
                        ToadFlagColors.Blue,
                        ToadFlagColors.Yellow,
                        ToadFlagColors.Orange,
                        ToadFlagColors.White,
                        ToadFlagColors.Pink,
                        ToadFlagColors.Red,
                        ToadFlagColors.Blue,
                        ToadFlagColors.Teal,
                        ToadFlagColors.Pink,
                        ToadFlagColors.White//end    
        );

        private static final List<Integer> JubblyMarlinWindMoteIndices = List.of(13, 55, 71, 89, 90);

        private static final List<WorldPoint> GwenithGlideSwordfishBestLine = new ArrayList<>(
                        List.of(
                                        new WorldPoint(2257, 3459, 0),
                                        new WorldPoint(2255, 3469, 0),
                                        new WorldPoint(2260, 3474, 0),
                                        new WorldPoint(2271, 3477, 0),
                                        new WorldPoint(2274, 3487, 0),
                                        new WorldPoint(2260, 3494, 0), //white portal
                                        new WorldPoint(2093, 3233, 0), //after portal
                                        new WorldPoint(2103, 3230, 0),
                                        new WorldPoint(2111, 3234, 0),
                                        new WorldPoint(2118, 3231, 0),
                                        new WorldPoint(2128, 3233, 0),
                                        new WorldPoint(2130, 3253, 0),
                                        new WorldPoint(2133, 3263, 0),
                                        new WorldPoint(2127, 3275, 0),
                                        new WorldPoint(2121, 3278, 0),
                                        new WorldPoint(2121, 3289, 0),
                                        new WorldPoint(2131, 3297, 0),
                                        new WorldPoint(2148, 3297, 0),
                                        new WorldPoint(2157, 3293, 0), //white portal
                                        new WorldPoint(2260, 3509, 0),
                                        new WorldPoint(2266, 3518, 0),
                                        new WorldPoint(2263, 3531, 0),
                                        new WorldPoint(2250, 3542, 0),
                                        new WorldPoint(2252, 3558, 0),
                                        new WorldPoint(2254, 3571, 0),
                                        new WorldPoint(2242, 3574, 0), //blue portal
                                        new WorldPoint(2088, 3215, 0),
                                        new WorldPoint(2110, 3214, 0),
                                        new WorldPoint(2115, 3206, 0),
                                        new WorldPoint(2132, 3193, 0),
                                        new WorldPoint(2141, 3220, 0),
                                        new WorldPoint(2139, 3230, 0),
                                        new WorldPoint(2141, 3243, 0),
                                        new WorldPoint(2153, 3246, 0), //blue portal
                                        new WorldPoint(2203, 3574, 0),
                                        new WorldPoint(2191, 3567, 0),
                                        new WorldPoint(2194, 3547, 0),
                                        new WorldPoint(2201, 3535, 0),
                                        new WorldPoint(2198, 3514, 0), //green portal
                                        new WorldPoint(2105, 3140, 0),
                                        new WorldPoint(2092, 3145, 0),
                                        new WorldPoint(2078, 3158, 0),
                                        new WorldPoint(2070, 3161, 0),
                                        new WorldPoint(2069, 3175, 0),
                                        new WorldPoint(2058, 3185, 0),
                                        new WorldPoint(2073, 3210, 0),
                                        new WorldPoint(2100, 3205, 0),
                                        new WorldPoint(2128, 3172, 0)//end
                        ));

        private static final List<PortalDirection> GwenithGlideSwordfishPortalDirections = List.of(
                        new PortalDirection(5, PortalColors.White, Directions.East, Directions.SouthEast),
                        new PortalDirection(18, PortalColors.White, Directions.North, Directions.NorthEast),
                        new PortalDirection(25, PortalColors.Blue, Directions.East, Directions.East),
                        new PortalDirection(33, PortalColors.Blue, Directions.West, Directions.SouthWest),
                        new PortalDirection(38, PortalColors.Green, Directions.West, Directions.NorthWest),
                        new PortalDirection(47, PortalColors.Green, Directions.South, Directions.SouthWest),
                        new PortalDirection(52, PortalColors.Yellow, Directions.West, Directions.West),
                        new PortalDirection(62, PortalColors.Yellow, Directions.West, Directions.West),
                        new PortalDirection(71, PortalColors.Red, Directions.West, Directions.SouthWest)//
        //
        );

        private static final List<WorldPoint> GwenithGlideSharkBestLine = new ArrayList<>(
                        List.of(
                                        new WorldPoint(2257, 3459, 0),
                                        new WorldPoint(2255, 3469, 0),
                                        new WorldPoint(2260, 3474, 0),
                                        new WorldPoint(2271, 3477, 0),
                                        new WorldPoint(2274, 3487, 0),
                                        new WorldPoint(2260, 3494, 0), //white portal
                                        new WorldPoint(2093, 3233, 0), //after portal
                                        new WorldPoint(2103, 3230, 0),
                                        new WorldPoint(2111, 3234, 0),
                                        new WorldPoint(2118, 3231, 0),
                                        new WorldPoint(2128, 3233, 0),
                                        new WorldPoint(2130, 3253, 0),
                                        new WorldPoint(2133, 3263, 0),
                                        new WorldPoint(2127, 3275, 0),
                                        new WorldPoint(2121, 3278, 0),
                                        new WorldPoint(2121, 3289, 0),
                                        new WorldPoint(2131, 3297, 0),
                                        new WorldPoint(2148, 3297, 0),
                                        new WorldPoint(2157, 3293, 0), //white portal
                                        new WorldPoint(2260, 3509, 0),
                                        new WorldPoint(2266, 3518, 0),
                                        new WorldPoint(2263, 3531, 0),
                                        new WorldPoint(2250, 3542, 0),
                                        new WorldPoint(2252, 3558, 0),
                                        new WorldPoint(2254, 3571, 0),
                                        new WorldPoint(2242, 3574, 0), //blue portal
                                        new WorldPoint(2088, 3215, 0),
                                        new WorldPoint(2110, 3214, 0),
                                        new WorldPoint(2115, 3206, 0),
                                        new WorldPoint(2132, 3193, 0),
                                        new WorldPoint(2141, 3220, 0),
                                        new WorldPoint(2139, 3230, 0),
                                        new WorldPoint(2141, 3243, 0),
                                        new WorldPoint(2153, 3246, 0), //blue portal
                                        new WorldPoint(2203, 3574, 0),
                                        new WorldPoint(2191, 3567, 0),
                                        new WorldPoint(2194, 3547, 0),
                                        new WorldPoint(2201, 3535, 0),
                                        new WorldPoint(2198, 3514, 0), //green portal
                                        new WorldPoint(2105, 3140, 0),
                                        new WorldPoint(2092, 3145, 0),
                                        new WorldPoint(2078, 3158, 0),
                                        new WorldPoint(2070, 3161, 0),
                                        new WorldPoint(2069, 3175, 0),
                                        new WorldPoint(2058, 3185, 0),
                                        new WorldPoint(2073, 3210, 0),
                                        new WorldPoint(2100, 3205, 0),
                                        new WorldPoint(2128, 3172, 0), //green portal, end swordfish
                                        new WorldPoint(2198, 3497, 0),
                                        new WorldPoint(2192, 3480, 0),
                                        new WorldPoint(2177, 3474, 0),
                                        new WorldPoint(2171, 3465, 0),
                                        new WorldPoint(2158, 3464, 0), //yellow portal
                                        new WorldPoint(2115, 3373, 0),
                                        new WorldPoint(2100, 3372, 0),
                                        new WorldPoint(2087, 3377, 0),
                                        new WorldPoint(2079, 3389, 0),
                                        new WorldPoint(2094, 3397, 0),
                                        new WorldPoint(2104, 3406, 0),
                                        new WorldPoint(2085, 3413, 0),
                                        new WorldPoint(2078, 3423, 0),
                                        new WorldPoint(2098, 3437, 0),
                                        new WorldPoint(2116, 3439, 0), //yellow portal
                                        new WorldPoint(2143, 3464, 0),
                                        new WorldPoint(2110, 3464, 0),
                                        new WorldPoint(2105, 3481, 0),
                                        new WorldPoint(2106, 3493, 0),
                                        new WorldPoint(2125, 3495, 0),
                                        new WorldPoint(2135, 3480, 0), //secret crate!
                                        new WorldPoint(2151, 3490, 0),
                                        new WorldPoint(2149, 3503, 0),
                                        new WorldPoint(2160, 3508, 0), //red portal
                                        new WorldPoint(2248, 3634, 0),
                                        new WorldPoint(2240, 3628, 0),
                                        new WorldPoint(2231, 3617, 0),
                                        new WorldPoint(2229, 3608, 0),
                                        new WorldPoint(2229, 3599, 0),
                                        new WorldPoint(2216, 3593, 0),
                                        new WorldPoint(2190, 3597, 0),
                                        new WorldPoint(2167, 3589, 0),
                                        new WorldPoint(2141, 3597, 0),
                                        new WorldPoint(2123, 3598, 0),
                                        new WorldPoint(2100, 3583, 0),
                                        new WorldPoint(2100, 3583, 0),
                                        new WorldPoint(2104, 3574, 0),

                                        new WorldPoint(0, 0, 0)//end swordfish
                        ));

        private static final List<PortalDirection> GwenithGlideSharkPortalDirections = List.of(
                        new PortalDirection(5, PortalColors.White, Directions.East, Directions.SouthEast),
                        new PortalDirection(18, PortalColors.White, Directions.North, Directions.NorthEast),
                        new PortalDirection(25, PortalColors.Blue, Directions.East, Directions.East),
                        new PortalDirection(33, PortalColors.Blue, Directions.West, Directions.SouthWest),
                        new PortalDirection(38, PortalColors.Green, Directions.West, Directions.NorthWest),
                        new PortalDirection(47, PortalColors.Green, Directions.South, Directions.SouthWest),
                        new PortalDirection(52, PortalColors.Yellow, Directions.West, Directions.West),
                        new PortalDirection(62, PortalColors.Yellow, Directions.West, Directions.West),
                        new PortalDirection(71, PortalColors.Red, Directions.West, Directions.SouthWest)//
        );

        private static final List<WorldPoint> GwenithGlideMarlinBestLine = new ArrayList<>(
                        List.of(
                                        // Trial Route:
                                        /*0*/new WorldPoint(2257, 3459, 0),
                                        /*1*/new WorldPoint(2259, 3472, 0),
                                        /*2*/new WorldPoint(2269, 3476, 0),
                                        /*3*/new WorldPoint(2272, 3487, 0),
                                        /*4*/new WorldPoint(2260, 3496, 0),
                                        /*5*/new WorldPoint(2093, 3233, 0),
                                        /*6*/new WorldPoint(2097, 3231, 0),
                                        /*7*/new WorldPoint(2104, 3230, 0),
                                        /*8*/new WorldPoint(2117, 3232, 0),
                                        /*9*/new WorldPoint(2130, 3254, 0),
                                        /*10*/new WorldPoint(2132, 3269, 0),
                                        /*11*/new WorldPoint(2143, 3291, 0),
                                        /*12*/new WorldPoint(2157, 3293, 0),
                                        /*13*/new WorldPoint(2260, 3509, 0),
                                        /*14*/new WorldPoint(2267, 3519, 0),
                                        /*15*/new WorldPoint(2263, 3531, 0),
                                        /*16*/new WorldPoint(2250, 3542, 0),
                                        /*17*/new WorldPoint(2251, 3559, 0),
                                        /*19*/new WorldPoint(2242, 3574, 0),
                                        /*20*/new WorldPoint(2084, 3215, 0),
                                        /*21*/new WorldPoint(2107, 3214, 0),
                                        /*22*/new WorldPoint(2110, 3212, 0),
                                        /*23*/new WorldPoint(2136, 3212, 0),
                                        /*24*/new WorldPoint(2140, 3214, 0),
                                        /*25*/new WorldPoint(2138, 3228, 0),
                                        /*26*/new WorldPoint(2133, 3232, 0),
                                        /*27*/new WorldPoint(2138, 3237, 0),
                                        /*28*/new WorldPoint(2143, 3243, 0),
                                        /*29*/new WorldPoint(2153, 3247, 0),
                                        /*30*/new WorldPoint(2203, 3574, 0),
                                        /*31*/new WorldPoint(2192, 3568, 0),
                                        /*32*/new WorldPoint(2192, 3548, 0),
                                        /*33*/new WorldPoint(2202, 3534, 0),
                                        /*34*/new WorldPoint(2198, 3513, 0),
                                        /*35*/new WorldPoint(2105, 3140, 0),
                                        /*36*/new WorldPoint(2092, 3145, 0),
                                        /*37*/new WorldPoint(2078, 3158, 0),
                                        /*38*/new WorldPoint(2070, 3161, 0),
                                        /*39*/new WorldPoint(2069, 3175, 0),
                                        /*40*/new WorldPoint(2058, 3185, 0),
                                        /*41*/new WorldPoint(2073, 3210, 0),
                                        /*42*/new WorldPoint(2100, 3205, 0),
                                        /*44*/new WorldPoint(2115, 3189, 0),
                                        /*45*/new WorldPoint(2133, 3191, 0),
                                        /*43*/new WorldPoint(2128, 3172, 0),
                                        /*46*/new WorldPoint(2197, 3490, 0),
                                        /*47*/new WorldPoint(2192, 3480, 0),
                                        /*48*/new WorldPoint(2176, 3475, 0),
                                        /*49*/new WorldPoint(2170, 3465, 0),
                                        /*50*/new WorldPoint(2158, 3464, 0),
                                        /*51*/new WorldPoint(2117, 3372, 0),
                                        /*52*/new WorldPoint(2089, 3374, 0),
                                        /*53*/new WorldPoint(2079, 3388, 0),
                                        /*54*/new WorldPoint(2083, 3394, 0),
                                        /*55*/new WorldPoint(2097, 3396, 0),
                                        /*56*/new WorldPoint(2105, 3407, 0),
                                        /*57*/new WorldPoint(2108, 3410, 0),
                                        /*58*/new WorldPoint(2113, 3414, 0),
                                        /*59*/new WorldPoint(2115, 3423, 0),
                                        /*60*/new WorldPoint(2110, 3439, 0),
                                        /*61*/new WorldPoint(2117, 3439, 0),
                                        /*62*/new WorldPoint(2146, 3464, 0),
                                        /*63*/new WorldPoint(2111, 3464, 0),
                                        /*64*/new WorldPoint(2105, 3471, 0),
                                        /*65*/new WorldPoint(2107, 3492, 0),
                                        /*66*/new WorldPoint(2115, 3496, 0),
                                        /*67*/new WorldPoint(2126, 3495, 0),
                                        /*68*/new WorldPoint(2134, 3483, 0),
                                        /*69*/new WorldPoint(2144, 3483, 0),
                                        /*70*/new WorldPoint(2149, 3493, 0),
                                        /*71*/new WorldPoint(2149, 3502, 0),
                                        /*72*/new WorldPoint(2160, 3508, 0),
                                        /*73*/new WorldPoint(2250, 3633, 0),
                                        /*74*/new WorldPoint(2241, 3629, 0),
                                        /*75*/new WorldPoint(2232, 3617, 0),
                                        /*76*/new WorldPoint(2230, 3609, 0),
                                        /*77*/new WorldPoint(2228, 3600, 0),
                                        /*78*/new WorldPoint(2220, 3593, 0),
                                        /*79*/new WorldPoint(2192, 3599, 0),
                                        /*80*/new WorldPoint(2166, 3589, 0),
                                        /*81*/new WorldPoint(2151, 3597, 0),
                                        /*82*/new WorldPoint(2125, 3598, 0),
                                        /*83*/new WorldPoint(2109, 3592, 0),
                                        /*84*/new WorldPoint(2099, 3582, 0),
                                        /*85*/new WorldPoint(2104, 3574, 0),
                                        /*86*/new WorldPoint(2174, 3508, 0),
                                        /*87*/new WorldPoint(2189, 3508, 0),
                                        /*88*/new WorldPoint(2208, 3508, 0),
                                        /*89*/new WorldPoint(2220, 3516, 0),
                                        /*90*/new WorldPoint(2220, 3526, 0),
                                        /*91*/new WorldPoint(2216, 3538, 0),
                                        /*92*/new WorldPoint(2222, 3547, 0),
                                        /*93*/new WorldPoint(2224, 3570, 0),
                                        /*94*/new WorldPoint(2218, 3580, 0),
                                        /*95*/new WorldPoint(2208, 3584, 0),
                                        /*96*/new WorldPoint(2108, 3560, 0),
                                        /*97*/new WorldPoint(2097, 3558, 0),
                                        /*98*/new WorldPoint(2080, 3552, 0),
                                        /*99*/new WorldPoint(2072, 3540, 0),
                                        /*100*/new WorldPoint(2083, 3529, 0),
                                        /*101*/new WorldPoint(2083, 3504, 0),
                                        /*102*/new WorldPoint(2085, 3472, 0),
                                        /*103*/new WorldPoint(2095, 3445, 0),
                                        /*104*/new WorldPoint(2095, 3438, 0),
                                        /*105*/new WorldPoint(2103, 3433, 0),
                                        /*106*/new WorldPoint(2105, 3425, 0),
                                        /*107*/new WorldPoint(2193, 3584, 0),
                                        /*108*/new WorldPoint(2177, 3579, 0),
                                        /*109*/new WorldPoint(2175, 3562, 0),
                                        /*110*/new WorldPoint(2179, 3544, 0),
                                        /*111*/new WorldPoint(2174, 3537, 0),
                                        /*112*/new WorldPoint(2162, 3545, 0),
                                        /*113*/new WorldPoint(2153, 3574, 0),
                                        /*114*/new WorldPoint(2143, 3582, 0),
                                        /*115*/new WorldPoint(2137, 3256, 0),
                                        /*116*/new WorldPoint(2130, 3276, 0),
                                        /*117*/new WorldPoint(2130, 3283, 0),
                                        /*118*/new WorldPoint(2124, 3289, 0),
                                        /*119*/new WorldPoint(2127, 3296, 0),
                                        /*120*/new WorldPoint(2131, 3318, 0),
                                        /*121*/new WorldPoint(2141, 3336, 0),
                                        /*122*/new WorldPoint(2151, 3346, 0),
                                        /*123*/new WorldPoint(2146, 3367, 0),
                                        /*124*/new WorldPoint(2128, 3380, 0),
                                        /*125*/new WorldPoint(2121, 3364, 0),
                                        /*126*/new WorldPoint(2126, 3356, 0),
                                        /*127*/new WorldPoint(2129, 3582, 0),
                                        /*128*/new WorldPoint(2122, 3582, 0),
                                        /*129*/new WorldPoint(2119, 3569, 0),
                                        /*130*/new WorldPoint(2124, 3539, 0),
                                        /*131*/new WorldPoint(2121, 3527, 0),
                                        /*132*/new WorldPoint(2119, 3519, 0),
                                        /*133*/new WorldPoint(2130, 3512, 0),
                                        /*134*/new WorldPoint(2140, 3517, 0),
                                        /*135*/new WorldPoint(2162, 3519, 0),
                                        /*136*/new WorldPoint(2171, 3523, 0),
                                        /*137*/new WorldPoint(2104, 3413, 0),
                                        /*138*/new WorldPoint(2094, 3417, 0),
                                        /*139*/new WorldPoint(2085, 3414, 0),
                                        /*140*/new WorldPoint(2080, 3426, 0),
                                        /*141*/new WorldPoint(2081, 3439, 0),
                                        /*142*/new WorldPoint(2083, 3446, 0),
                                        /*143*/new WorldPoint(2082, 3454, 0),
                                        /*144*/new WorldPoint(2082, 3492, 0),
                                        /*145*/new WorldPoint(2095, 3505, 0),
                                        /*146*/new WorldPoint(2105, 3520, 0),
                                        /*147*/new WorldPoint(2095, 3529, 0),
                                        /*148*/new WorldPoint(2091, 3541, 0),
                                        /*149*/new WorldPoint(2106, 3543, 0)
                        // End of trial route

                        ));

        private static final List<PortalDirection> GwenithGlideMarlinPortalDirections = List.of(
                        new PortalDirection(4, PortalColors.White, Directions.East, Directions.EastSouthEast),
                        new PortalDirection(12, PortalColors.White, Directions.North, Directions.NorthNorthEast),
                        new PortalDirection(18, PortalColors.Blue, Directions.East, Directions.East),
                        new PortalDirection(28, PortalColors.Blue, Directions.West, Directions.WestSouthWest),
                        new PortalDirection(33, PortalColors.Green, Directions.West, Directions.WestNorthWest),
                        new PortalDirection(44, PortalColors.Green, Directions.South, Directions.SouthSouthWest),
                        new PortalDirection(49, PortalColors.Yellow, Directions.West, Directions.West),
                        new PortalDirection(60, PortalColors.Yellow, Directions.West, Directions.West),
                        new PortalDirection(71, PortalColors.Red, Directions.West, Directions.SouthWest),
                        new PortalDirection(84, PortalColors.Red, Directions.East, Directions.East),
                        new PortalDirection(86, PortalColors.Green, Directions.East, Directions.NorthEast),
                        new PortalDirection(94, PortalColors.Black, Directions.West, Directions.West),
                        new PortalDirection(105, PortalColors.Black, Directions.West, Directions.West),
                        new PortalDirection(113, PortalColors.Cyan, Directions.North, Directions.NorthNorthWest),
                        new PortalDirection(125, PortalColors.Cyan, Directions.West, Directions.South),
                        new PortalDirection(135, PortalColors.Pink, Directions.West, Directions.North)//
        );

        public static final List<TrialRoute> AllTrialRoutes = new ArrayList<TrialRoute>(
                        List.of(
                                        new TrialRoute(TrialLocations.TemporTantrum, TrialRanks.Swordfish, TemporTantrumSwordfishBestLine),
                                        new TrialRoute(TrialLocations.TemporTantrum, TrialRanks.Shark, TemporTantrumSharkBestLine),
                                        new TrialRoute(TrialLocations.TemporTantrum, TrialRanks.Marlin, TemporTantrumMarlinBestLine),
                                        new TrialRoute(TrialLocations.JubblyJive, TrialRanks.Swordfish, JubblySwordfishBestLine, JubblySwordfishToadOrder, Collections.emptyList(), null),
                                        new TrialRoute(TrialLocations.JubblyJive, TrialRanks.Shark, JubblySharkBestLine, JubblySharkToadOrder, Collections.emptyList(), null),
                                        new TrialRoute(TrialLocations.JubblyJive, TrialRanks.Marlin, JubblyMarlinBestLine, JubblyMarlinToadOrder, JubblyMarlinWindMoteIndices, null),
                                        new TrialRoute(TrialLocations.GwenithGlide, TrialRanks.Swordfish, GwenithGlideSwordfishBestLine, null, null, GwenithGlideSwordfishPortalDirections),
                                        new TrialRoute(TrialLocations.GwenithGlide, TrialRanks.Shark, GwenithGlideSharkBestLine, null, null, GwenithGlideSharkPortalDirections),
                                        new TrialRoute(TrialLocations.GwenithGlide, TrialRanks.Marlin, GwenithGlideMarlinBestLine, null, null, GwenithGlideMarlinPortalDirections)//
                        ));

        public static final void AddGwenithGlideRoutes() {
                AllTrialRoutes.add(new TrialRoute(TrialLocations.GwenithGlide, TrialRanks.Swordfish, GwenithGlideSwordfishBestLine, null, null, GwenithGlideSwordfishPortalDirections));
                AllTrialRoutes.add(new TrialRoute(TrialLocations.GwenithGlide, TrialRanks.Shark, GwenithGlideSharkBestLine, null, null, GwenithGlideSharkPortalDirections));
                AllTrialRoutes.add(new TrialRoute(TrialLocations.GwenithGlide, TrialRanks.Marlin, GwenithGlideMarlinBestLine, null, null, GwenithGlideMarlinPortalDirections));
        }
}

package com.datbear.debug;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import com.datbear.data.Directions;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.coords.WorldPoint;

@Slf4j
public class BoatPathHelper {
    private static final Map<Integer, TickMovementData> tickDataMap = new HashMap<>();

    public static boolean HasTickData(int tick) {
        return tickDataMap.containsKey(tick);
    }

    public static void StartNewTick(int tick, WorldPoint startPosition, Directions startHeading) {
        //log.info("Starting new tick {}: position {}, heading {}", tick, startPosition, startHeading);
        tickDataMap.put(tick, new TickMovementData(tick, startPosition, startHeading, new java.util.HashSet<>(Set.of(startPosition))));
    }

    public static void AddVisitedPoint(int tick, WorldPoint point) {
        TickMovementData data = tickDataMap.get(tick);
        if (data != null) {
            data.PointsVisited.add(point);
        }
    }

    public static TickMovementData GetTickData(int tick) {
        return tickDataMap.get(tick);
    }

}

package com.datbear.debug;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.Rectangle;
import java.awt.Stroke;
import java.util.Set;

import com.datbear.BearycudaTrialsConfig;
import com.datbear.BearycudaTrialsPlugin;
import com.datbear.data.Directions;
import com.datbear.debug.BoatPathHelper;
import com.datbear.debug.TickMovementData;
import com.datbear.overlay.WorldPerspective;
import com.google.inject.Inject;

import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Perspective;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

public class BoatPathOverlay extends Overlay {
    private Client client;
    private BearycudaTrialsPlugin plugin;
    private BearycudaTrialsConfig config;

    @Inject
    public BoatPathOverlay(Client client, BearycudaTrialsPlugin plugin, BearycudaTrialsConfig config) {
        super();
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        this.client = client;
        this.plugin = plugin;
        this.config = config;
    }

    private static final Set<Color> TickColors = Set.of(
            Color.RED,
            Color.GREEN,
            Color.BLUE,
            Color.YELLOW,
            Color.ORANGE,
            Color.CYAN);

    public BoatPathOverlay() {
        super();
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (client == null || graphics == null) {
            return null;
        }

        if (plugin.getBoardedBoat() == 0) {
            return null;
        }
        if (!config.enableBoatPathDebug()) {
            return null;
        }

        if (client.getGameState() != GameState.LOGGED_IN) {
            return null;
        }

        if (client.getTickCount() <= 0) {
            return null;
        }

        var tickColorOrder = TickColors.toArray(new Color[0]);
        if (tickColorOrder.length == 0) {
            return null;
        }

        var currentTick = client.getTickCount();
        var ticksToRender = 6;

        for (var offset = 0; offset < ticksToRender; offset++) {
            var targetTick = currentTick - offset;
            if (targetTick < 0) {
                continue;
            }

            var tickData = BoatPathHelper.GetTickData(targetTick);
            if (tickData == null || tickData.PointsVisited == null || tickData.PointsVisited.isEmpty()) {
                continue;
            }

            var outlineColor = tickColorOrder[offset % tickColorOrder.length];
            var insetEvenTicks = (tickData.Tick % 2) == 0;
            drawVisitedTileOutlines(graphics, tickData, outlineColor, insetEvenTicks);
            renderTickLabel(graphics, tickData, outlineColor);
        }

        return null;
    }

    private void drawVisitedTileOutlines(Graphics2D graphics, TickMovementData tickData, Color outlineColor, boolean insetOutline) {
        if (tickData == null || tickData.PointsVisited == null || tickData.PointsVisited.isEmpty()) {
            return;
        }

        var previousStroke = graphics.getStroke();
        graphics.setStroke(new BasicStroke(2f));
        graphics.setColor(outlineColor);

        for (WorldPoint visitedPoint : tickData.PointsVisited) {
            if (visitedPoint == null) {
                continue;
            }

            var tilePolygon = getCanvasPolygonForWorldPoint(visitedPoint);
            if (tilePolygon != null) {
                if (insetOutline) {
                    var insetPolygon = insetPolygon(tilePolygon, 3);
                    if (insetPolygon != null) {
                        tilePolygon = insetPolygon;
                    }
                }
                graphics.draw(tilePolygon);
            }
        }

        graphics.setStroke(previousStroke);
    }

    private void renderTickLabel(Graphics2D graphics, TickMovementData tickData, Color textColor) {
        if (tickData == null || tickData.StartPosition == null) {
            return;
        }

        var startTile = getCanvasPolygonForWorldPoint(tickData.StartPosition);
        if (startTile == null) {
            return;
        }

        var tileBounds = startTile.getBounds();
        var textX = tileBounds.x + tileBounds.width + 6;
        var textY = tileBounds.y + (tileBounds.height / 2);

        var heading = tickData.StartHeading;
        var headingLabel = heading != null ? heading.name() : "UNKNOWN";
        var label = String.format("tick %d %s", tickData.Tick, headingLabel);

        graphics.setColor(Color.BLACK);
        graphics.drawString(label, textX + 1, textY + 1);
        graphics.setColor(textColor);
        graphics.drawString(label, textX, textY);
    }

    private Polygon getCanvasPolygonForWorldPoint(WorldPoint worldPoint) {
        if (worldPoint == null) {
            return null;
        }

        var localPoints = WorldPerspective.getInstanceLocalPointFromReal(client, worldPoint);
        if (localPoints == null || localPoints.isEmpty()) {
            return null;
        }

        for (LocalPoint localPoint : localPoints) {
            if (localPoint == null) {
                continue;
            }
            var polygon = Perspective.getCanvasTilePoly(client, localPoint);
            if (polygon != null) {
                return polygon;
            }
        }

        return null;
    }

    private Polygon insetPolygon(Polygon polygon, int insetPixels) {
        if (polygon == null || insetPixels <= 0) {
            return polygon;
        }

        double centerX = 0;
        double centerY = 0;
        int nPoints = polygon.npoints;
        if (nPoints == 0) {
            return polygon;
        }

        for (int i = 0; i < nPoints; i++) {
            centerX += polygon.xpoints[i];
            centerY += polygon.ypoints[i];
        }
        centerX /= nPoints;
        centerY /= nPoints;

        var insetPoly = new Polygon();
        for (int i = 0; i < nPoints; i++) {
            double dx = polygon.xpoints[i] - centerX;
            double dy = polygon.ypoints[i] - centerY;
            double distance = Math.hypot(dx, dy);
            if (distance == 0) {
                continue;
            }
            double scale = Math.max((distance - insetPixels) / distance, 0);
            int newX = (int) Math.round(centerX + dx * scale);
            int newY = (int) Math.round(centerY + dy * scale);
            insetPoly.addPoint(newX, newY);
        }

        return insetPoly.npoints > 0 ? insetPoly : polygon;
    }
}

package com.datbear.debug;

import java.util.Set;

import com.datbear.data.Directions;

import net.runelite.api.coords.WorldPoint;

public class TickMovementData {
    public int Tick;
    public WorldPoint StartPosition;
    public Directions StartHeading;
    public Set<WorldPoint> PointsVisited;

    public TickMovementData(int tick, WorldPoint startPosition, Directions startHeading, Set<WorldPoint> pointsVisited) {
        Tick = tick;
        StartPosition = startPosition;
        StartHeading = startHeading;
        PointsVisited = pointsVisited;
    }
}

package com.datbear;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;

import javax.inject.Inject;

import net.runelite.api.Client;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.api.Perspective;

import com.datbear.overlay.WorldPerspective;

public class ObstacleOutlineOverlay extends Overlay {

    private Client client;
    private BearycudaTrialsPlugin plugin;
    private BearycudaTrialsConfig config;

    @Inject
    public ObstacleOutlineOverlay(Client client, BearycudaTrialsPlugin plugin, BearycudaTrialsConfig config) {
        super();
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.UNDER_WIDGETS);
        this.client = client;
        this.plugin = plugin;
        this.config = config;
    }

    @Override
    public Dimension render(Graphics2D graphics) {

        highlightObstacleTiles(graphics);

        return null;
    }

    private void highlightObstacleTiles(Graphics2D graphics) {
        if (!config.showObstacleOutlines()) {
            return;
        }

        var obstacleWorldPoints = plugin.getObstacleWorldPoints();
        if (obstacleWorldPoints == null || obstacleWorldPoints.isEmpty()) {
            return;
        }

        Color obstacleColor = config.obstacleOutlineColor();

        for (WorldPoint obstacleWorldPoint : obstacleWorldPoints) {
            if (obstacleWorldPoint == null) {
                continue;
            }

            var localPoints = WorldPerspective.getInstanceLocalPointFromReal(client, obstacleWorldPoint);
            if (localPoints == null || localPoints.isEmpty()) {
                continue;
            }

            for (LocalPoint localPoint : localPoints) {
                if (localPoint == null) {
                    continue;
                }

                Polygon polygon = Perspective.getCanvasTilePoly(client, localPoint);
                if (polygon != null) {
                    OverlayUtil.renderPolygon(graphics, polygon, obstacleColor);
                }
            }
        }
    }

}

/*
 * Copyright (c) 2021, Zoinkwiz <https://github.com/Zoinkwiz>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.datbear.overlay;

import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Player;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;

import java.awt.*;
import java.awt.geom.AffineTransform;
import java.awt.geom.Line2D;
import java.util.List;

public class DirectionArrow {
    /**
     * @param client the {@link Client}
     * @return the rough number of tiles distance the minimap can draw
     */
    public static int getMaxMinimapDrawDistance(Client client) {
        var minimapZoom = client.getMinimapZoom();
        if (minimapZoom > 0.0) {
            return (int) (64.0 / client.getMinimapZoom());
        }
        return 16;
    }

    public static void renderMinimapArrowFromLocal(Graphics2D graphics, Client client, LocalPoint localPoint,
            Color color) {
        var maxMinimapDrawDistance = getMaxMinimapDrawDistance(client);
        Player player = client.getLocalPlayer();
        if (player == null) {
            return;
        }

        if (localPoint == null) {
            return;
        }

        WorldPoint playerRealLocation = WorldPoint.fromLocalInstance(client, player.getLocalLocation());
        WorldPoint goalRealLocation = WorldPoint.fromLocalInstance(client, localPoint);
        if (playerRealLocation == null)
            return;

        if (goalRealLocation.distanceTo(playerRealLocation) >= maxMinimapDrawDistance) {
            createMinimapDirectionArrow(graphics, client, playerRealLocation, goalRealLocation, color);
            return;
        }

        Point posOnMinimap = Perspective.localToMinimap(client, localPoint);
        if (posOnMinimap == null) {
            return;
        }

        Line2D.Double line = new Line2D.Double(posOnMinimap.getX(), posOnMinimap.getY() - 18, posOnMinimap.getX(),
                posOnMinimap.getY() - 8);

        drawMinimapArrow(graphics, line, color);

    }

    public static void renderMinimapArrow(Graphics2D graphics, Client client, WorldPoint worldPoint, Color color) {
        var maxMinimapDrawDistance = getMaxMinimapDrawDistance(client);
        Player player = client.getLocalPlayer();
        if (player == null) {
            return;
        }

        if (worldPoint == null) {
            return;
        }

        WorldPoint playerRealLocation = WorldPoint.fromLocalInstance(client, player.getLocalLocation());
        if (playerRealLocation == null)
            return;

        if (worldPoint.distanceTo(playerRealLocation) >= maxMinimapDrawDistance) {
            createMinimapDirectionArrow(graphics, client, playerRealLocation, worldPoint, color);
            return;
        }

        List<LocalPoint> localPoints = WorldPerspective.getInstanceLocalPointFromReal(client, worldPoint);

        for (LocalPoint localPoint : localPoints) {
            Point posOnMinimap = Perspective.localToMinimap(client, localPoint);
            if (posOnMinimap == null) {
                continue;
            }

            Line2D.Double line = new Line2D.Double(posOnMinimap.getX(), posOnMinimap.getY() - 18, posOnMinimap.getX(),
                    posOnMinimap.getY() - 8);

            drawMinimapArrow(graphics, line, color);
        }
    }

    protected static void createMinimapDirectionArrow(Graphics2D graphics, Client client, WorldPoint playerRealWp,
            WorldPoint wp, Color color) {
        Player player = client.getLocalPlayer();

        if (player == null) {
            return;
        }

        if (wp == null) {
            return;
        }

        Point playerPosOnMinimap = player.getMinimapLocation();

        Point destinationPosOnMinimap = WorldPerspective.getMinimapPoint(client, playerRealWp, wp);

        if (playerPosOnMinimap == null || destinationPosOnMinimap == null) {
            return;
        }

        double xDiff = playerPosOnMinimap.getX() - destinationPosOnMinimap.getX();
        double yDiff = destinationPosOnMinimap.getY() - playerPosOnMinimap.getY();
        double angle = Math.atan2(yDiff, xDiff);

        int startX = (int) (playerPosOnMinimap.getX() - (Math.cos(angle) * 55));
        int startY = (int) (playerPosOnMinimap.getY() + (Math.sin(angle) * 55));

        int endX = (int) (playerPosOnMinimap.getX() - (Math.cos(angle) * 65));
        int endY = (int) (playerPosOnMinimap.getY() + (Math.sin(angle) * 65));

        Line2D.Double line = new Line2D.Double(startX, startY, endX, endY);

        drawMinimapArrow(graphics, line, color);
    }

    public static void drawWorldArrow(Graphics2D graphics, Color color, int startX, int startY) {
        Line2D.Double line = new Line2D.Double(startX, startY - 13, startX, startY);

        int headWidth = 5;
        int headHeight = 4;
        int lineWidth = 9;

        drawArrow(graphics, line, color, lineWidth, headHeight, headWidth);
    }

    public static void drawMinimapArrow(Graphics2D graphics, Line2D.Double line, Color color) {
        drawArrow(graphics, line, color, 6, 2, 2);
    }

    public static void drawArrow(Graphics2D graphics, Line2D.Double line, Color color, int width, int tipHeight,
            int tipWidth) {
        graphics.setColor(Color.BLACK);
        graphics.setStroke(new BasicStroke(width));
        graphics.draw(line);
        drawWorldArrowHead(graphics, line, tipHeight, tipWidth);

        graphics.setColor(color);
        graphics.setStroke(new BasicStroke(width - 3));
        graphics.draw(line);
        drawWorldArrowHead(graphics, line, tipHeight - 2, tipWidth - 2);
        graphics.setStroke(new BasicStroke(1));
    }

    public static void drawWorldArrowHead(Graphics2D g2d, Line2D.Double line, int extraSizeHeight, int extraSizeWidth) {
        AffineTransform tx = new AffineTransform();

        Polygon arrowHead = new Polygon();
        arrowHead.addPoint(0, 6 + extraSizeHeight);
        arrowHead.addPoint(-6 - extraSizeWidth, -1 - extraSizeHeight);
        arrowHead.addPoint(6 + extraSizeWidth, -1 - extraSizeHeight);

        tx.setToIdentity();
        double angle = Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
        tx.translate(line.x2, line.y2);
        tx.rotate((angle - Math.PI / 2d));

        Graphics2D g = (Graphics2D) g2d.create();
        g.setTransform(tx);
        g.fill(arrowHead);
        g.dispose();
    }

    public static void drawLineArrowHead(Graphics2D g2d, Line2D.Double line) {
        AffineTransform tx = new AffineTransform();
        Polygon arrowHead = new Polygon();
        arrowHead.addPoint(0, 0);
        arrowHead.addPoint(-3, -6);
        arrowHead.addPoint(3, -6);
        tx.setToIdentity();
        double angle = Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
        tx.translate(line.x2, line.y2);
        tx.rotate((angle - Math.PI / 2d));
        Graphics2D graphics2D = (Graphics2D) g2d.create();
        graphics2D.setTransform(tx);
        graphics2D.fill(arrowHead);
        graphics2D.dispose();
    }

    public static void drawLine(Graphics2D graphics, Line2D.Double line, Color color, Rectangle clippingRegion) {
        graphics.setStroke(new BasicStroke(1));
        graphics.setClip(clippingRegion);
        graphics.setColor(color);
        graphics.draw(line);
        drawLineArrowHead(graphics, line);
    }
}
/*
 * Copyright (c) 2021, Zoinkwiz <https://github.com/Zoinkwiz>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 * nucleon <https://github.com/nucleon>
 * Modification: drawLinesOnWorld()
 * Interpolates long lines into shorter segments to bypass RuneLite’s overlay draw distance limit.
 */

package com.datbear.overlay;

import java.util.ArrayList;
import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.coords.WorldPoint;

import java.awt.*;
import java.awt.geom.Line2D;
import java.util.List;

public class WorldLines {
    public static void createWorldMapLines(Graphics2D graphics, Client client, List<WorldPoint> linePoints,
            Color color) {
        Rectangle mapViewArea = WorldPerspective.getWorldMapClipArea(client);

        for (int i = 0; i < linePoints.size() - 1; i++) {
            Point startPoint = WorldPerspective.mapWorldPointToGraphicsPoint(client, linePoints.get(i));
            Point endPoint = WorldPerspective.mapWorldPointToGraphicsPoint(client, linePoints.get(i + 1));

            WorldLines.renderWorldMapLine(graphics, client, mapViewArea, startPoint, endPoint, color);
        }
    }

    public static void renderWorldMapLine(Graphics2D graphics, Client client, Rectangle mapViewArea, Point startPoint,
            Point endPoint, Color color) {
        if (mapViewArea == null || startPoint == null || endPoint == null) {
            return;
        }
        if (!mapViewArea.contains(startPoint.getX(), startPoint.getY())
                && !mapViewArea.contains(endPoint.getX(), endPoint.getY())) {
            return;
        }

        Line2D.Double line = new Line2D.Double(startPoint.getX(), startPoint.getY(), endPoint.getX(), endPoint.getY());
        DirectionArrow.drawLine(graphics, line, color, WorldPerspective.getWorldMapClipArea(client));
    }

    public static void drawLinesOnWorld(Graphics2D graphics, Client client, List<WorldPoint> linePoints, Color color, int z) {
        if (linePoints == null || linePoints.size() < 2) {
            return;
        }

        for (int i = 0; i < linePoints.size() - 1; i++) {
            WorldPoint startWp = linePoints.get(i);
            WorldPoint endWp = linePoints.get(i + 1);

            if (startWp == null || endWp == null)
                continue;
            if (startWp.equals(new WorldPoint(0, 0, 0)))
                continue;
            if (endWp.equals(new WorldPoint(0, 0, 0)))
                continue;
            if (startWp.getPlane() != endWp.getPlane())
                continue;

            List<WorldPoint> interpolated = interpolateLine(startWp, endWp);
            if (interpolated.isEmpty())
                continue;

            for (int j = 0; j < interpolated.size() - 1; j++) {
                WorldPoint wp1 = interpolated.get(j);
                WorldPoint wp2 = interpolated.get(j + 1);

                List<Point> points1 = WorldPerspective.worldToCanvasWithOffset(client, wp1, z);
                List<Point> points2 = WorldPerspective.worldToCanvasWithOffset(client, wp2, z);

                if (points1.isEmpty() || points2.isEmpty()) {
                    continue;
                }

                Point p1 = points1.get(0);
                Point p2 = points2.get(0);

                if (p1 == null || p2 == null) {
                    continue;
                }

                graphics.setColor(color);
                graphics.setStroke(new BasicStroke(2f));
                graphics.drawLine(p1.getX(), p1.getY(), p2.getX(), p2.getY());
            }
        }
    }

    private static Color dimColor(Color color, float factor) {
        factor = Math.min(Math.max(factor, 0f), 1f);
        int r = (int) (color.getRed() * factor);
        int g = (int) (color.getGreen() * factor);
        int b = (int) (color.getBlue() * factor);
        return new Color(r, g, b, color.getAlpha());
    }

    private static List<WorldPoint> interpolateLine(WorldPoint start, WorldPoint end) {
        List<WorldPoint> result = new ArrayList<>();
        int steps = Math.max(start.distanceTo(end), 1);

        for (int i = 0; i <= steps; i++) {
            double t = i / (double) steps;
            int x = (int) Math.round(lerp(start.getX(), end.getX(), t));
            int y = (int) Math.round(lerp(start.getY(), end.getY(), t));
            int plane = start.getPlane();
            result.add(new WorldPoint(x, y, plane));
        }

        return result;
    }

    private static double lerp(int a, int b, double t) {
        return a + (b - a) * t;
    }
}

/*
 * Copyright (c) 2021, Zoinkwiz <https://github.com/Zoinkwiz>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.datbear.overlay;

import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.WorldView;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.Widget;

import java.awt.*;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import static net.runelite.api.Constants.CHUNK_SIZE;

public class WorldPerspective {
    private final static int SW = 0;
    private final static int NW = 3;
    private final static int NE = 2;
    private final static int SE = 1;

    public static Collection<WorldPoint> toLocalInstanceFromReal(Client client, WorldPoint worldPoint) {
        if (!client.isInInstancedRegion()) {
            return Collections.singleton(worldPoint);
        }

        if (worldPoint == null)
            return Collections.singleton(null);

        List<WorldPoint> worldPoints = new ArrayList<>();

        int[][][] instanceTemplateChunks = client.getInstanceTemplateChunks();
        for (int z = 0; z < instanceTemplateChunks.length; ++z) {
            for (int x = 0; x < instanceTemplateChunks[z].length; ++x) {
                for (int y = 0; y < instanceTemplateChunks[z][x].length; ++y) {
                    int chunkData = instanceTemplateChunks[z][x][y];
                    int rotation = chunkData >> 1 & 0x3;
                    int templateChunkY = (chunkData >> 3 & 0x7FF) * CHUNK_SIZE;
                    int templateChunkX = (chunkData >> 14 & 0x3FF) * CHUNK_SIZE;
                    if (worldPoint.getX() >= templateChunkX && worldPoint.getX() < templateChunkX + CHUNK_SIZE
                            && worldPoint.getY() >= templateChunkY && worldPoint.getY() < templateChunkY + CHUNK_SIZE) {
                        WorldPoint p = new WorldPoint(
                                client.getBaseX() + x * CHUNK_SIZE + (worldPoint.getX() & (CHUNK_SIZE - 1)),
                                client.getBaseY() + y * CHUNK_SIZE + (worldPoint.getY() & (CHUNK_SIZE - 1)),
                                z);
                        p = rotate(p, rotation);
                        if (p.isInScene(client)) {
                            worldPoints.add(p);
                        }
                    }
                }
            }
        }
        return worldPoints;
    }

    private static WorldPoint rotate(WorldPoint point, int rotation) {
        int chunkX = point.getX() & -CHUNK_SIZE;
        int chunkY = point.getY() & -CHUNK_SIZE;
        int x = point.getX() & (CHUNK_SIZE - 1);
        int y = point.getY() & (CHUNK_SIZE - 1);
        switch (rotation) {
            case 1:
                return new WorldPoint(chunkX + y, chunkY + (CHUNK_SIZE - 1 - x), point.getPlane());
            case 2:
                return new WorldPoint(chunkX + (CHUNK_SIZE - 1 - x), chunkY + (CHUNK_SIZE - 1 - y), point.getPlane());
            case 3:
                return new WorldPoint(chunkX + (CHUNK_SIZE - 1 - y), chunkY + x, point.getPlane());
        }
        return point;
    }

    public static List<LocalPoint> getInstanceLocalPointFromReal(Client client, WorldPoint wp) {
        List<WorldPoint> instanceWorldPoint = new ArrayList<>(WorldPerspective.toLocalInstanceFromReal(client, wp));

        List<LocalPoint> localPoints = new ArrayList<>();
        for (WorldPoint worldPoint : instanceWorldPoint) {
            LocalPoint lp = LocalPoint.fromWorld(client.getTopLevelWorldView(), worldPoint);
            if (lp != null) {
                localPoints.add(lp);
            }
        }

        return localPoints;
    }

    public static WorldPoint getInstanceWorldPointFromReal(Client client, WorldPoint wp) {
        if (wp == null)
            return null;
        Collection<WorldPoint> points = WorldPerspective.toLocalInstanceFromReal(client, wp);

        if (points.isEmpty())
            return null;

        // If multiple instance candidates are returned, prefer the one that
        // matches the client's current plane. This reduces mismatches where a
        // real-world point could map to multiple instance planes and the
        // overlay ends up rendering a point on a different plane than the
        // player (causing apparent 'missing' points).
        int clientPlane = client.getPlane();
        WorldPoint fallback = null;
        for (WorldPoint point : points) {
            if (point == null)
                continue;

            // Prefer a mapping that is on the same plane as the client
            if (point.getPlane() == clientPlane) {
                if (point.isInScene(client)) {
                    return point;
                }
                // keep as preferred candidate if it's not yet chosen
                fallback = point;
            } else if (fallback == null) {
                // keep any first non-null candidate as a fallback
                fallback = point;
            }
        }

        return fallback;
    }

    /**
     * Like getInstanceWorldPointFromReal(Client, WorldPoint) but prefer a candidate
     * which maps into the supplied WorldView. This mirrors how DevTools renders
     * and allows mapping using the player's worldview for more accurate
     * on-screen coordinates.
     */
    public static WorldPoint getInstanceWorldPointFromReal(Client client, WorldView worldView, WorldPoint wp) {
        if (wp == null)
            return null;

        Collection<WorldPoint> points = WorldPerspective.toLocalInstanceFromReal(client, wp);

        if (points.isEmpty())
            return null;

        WorldPoint fallback = null;

        // First, prefer a mapping that produces a non-null LocalPoint from the
        // provided WorldView (i.e., it maps into the player's visible worldview)
        if (worldView != null) {
            for (WorldPoint point : points) {
                if (point == null) {
                    continue;
                }

                LocalPoint lp = LocalPoint.fromWorld(worldView, point);
                if (lp != null) {
                    // If it maps into that worldview it's a good match
                    return point;
                }
                if (fallback == null) {
                    fallback = point;
                }
            }
        }

        // Fall back to the regular selection logic if worldview-based selection
        // didn't return an immediate result.
        int clientPlane = client.getPlane();
        for (WorldPoint point : points) {
            if (point == null)
                continue;

            if (point.getPlane() == clientPlane) {
                if (point.isInScene(client)) {
                    return point;
                }
                fallback = point;
            } else if (fallback == null) {
                fallback = point;
            }
        }

        return fallback;
    }

    public static WorldPoint getRealWorldPointFromLocal(Client client, WorldPoint wp) {
        LocalPoint lp = LocalPoint.fromWorld(client.getTopLevelWorldView(), wp);
        if (lp == null)
            return null;

        return WorldPoint.fromLocalInstance(client, lp);
    }

    public static Rectangle getWorldMapClipArea(Client client) {
        Widget widget = client.getWidget(InterfaceID.Worldmap.MAP_CONTAINER);
        if (widget == null) {
            return null;
        }

        return widget.getBounds();
    }

    public static Point mapWorldPointToGraphicsPoint(Client client, WorldPoint worldPoint) {
        var worldMap = client.getWorldMap();
        if (worldPoint == null)
            return null;
        if (!worldMap.getWorldMapData().surfaceContainsPosition(worldPoint.getX(), worldPoint.getY())) {
            return null;
        }

        float pixelsPerTile = worldMap.getWorldMapZoom();

        Widget map = client.getWidget(InterfaceID.Worldmap.MAP_CONTAINER);
        if (map != null) {
            Rectangle worldMapRect = map.getBounds();

            int widthInTiles = (int) Math.ceil(worldMapRect.getWidth() / pixelsPerTile);
            int heightInTiles = (int) Math.ceil(worldMapRect.getHeight() / pixelsPerTile);

            var worldMapPosition = worldMap.getWorldMapPosition();

            int yTileMax = worldMapPosition.getY() - heightInTiles / 2;
            int yTileOffset = (yTileMax - worldPoint.getY() - 1) * -1;
            int xTileOffset = worldPoint.getX() + widthInTiles / 2 - worldMapPosition.getX();

            int xGraphDiff = ((int) (xTileOffset * pixelsPerTile));
            int yGraphDiff = (int) (yTileOffset * pixelsPerTile);

            yGraphDiff -= pixelsPerTile - Math.ceil(pixelsPerTile / 2);
            xGraphDiff += pixelsPerTile - Math.ceil(pixelsPerTile / 2);

            yGraphDiff = worldMapRect.height - yGraphDiff;
            yGraphDiff += (int) worldMapRect.getY();
            xGraphDiff += (int) worldMapRect.getX();

            return new Point(xGraphDiff, yGraphDiff);
        }
        return null;
    }

    public static List<Point> worldToCanvasWithOffset(Client client, WorldPoint worldPoint, int zOffset) {
        List<Point> canvasPoints = new ArrayList<>();

        if (worldPoint == null) {
            return canvasPoints;
        }

        Collection<WorldPoint> instances = WorldPerspective.toLocalInstanceFromReal(client, worldPoint);
        for (WorldPoint wp : instances) {
            if (wp == null) {
                continue;
            }

            LocalPoint lp = LocalPoint.fromWorld(client.getTopLevelWorldView(), wp);
            if (lp == null) {
                continue;
            }

            Point canvas = net.runelite.api.Perspective.localToCanvas(client, lp, wp.getPlane(), zOffset);
            if (canvas != null) {
                canvasPoints.add(canvas);
            }
        }

        return canvasPoints;
    }

    public static Point getMinimapPoint(Client client, WorldPoint start, WorldPoint destination) {
        var worldMapData = client.getWorldMap().getWorldMapData();
        if (worldMapData.surfaceContainsPosition(start.getX(), start.getY()) != worldMapData
                .surfaceContainsPosition(destination.getX(), destination.getY())) {
            return null;
        }

        int x = (destination.getX() - start.getX());
        int y = (destination.getY() - start.getY());

        float maxDistance = Math.max(Math.abs(x), Math.abs(y));
        x = x * 100;
        y = y * 100;
        x /= maxDistance;
        y /= maxDistance;

        Widget minimapDrawWidget;
        if (client.isResized()) {
            if (client.getVarbitValue(VarbitID.RESIZABLE_STONE_ARRANGEMENT) == 1) {
                minimapDrawWidget = client.getWidget(InterfaceID.ToplevelPreEoc.MINIMAP);
            } else {
                minimapDrawWidget = client.getWidget(InterfaceID.ToplevelOsrsStretch.MINIMAP);
            }
        } else {
            minimapDrawWidget = client.getWidget(InterfaceID.Toplevel.MINIMAP);
        }

        if (minimapDrawWidget == null) {
            return null;
        }

        final int angle = client.getCameraYawTarget() & 0x7FF;

        final int sin = net.runelite.api.Perspective.SINE[angle];
        final int cos = net.runelite.api.Perspective.COSINE[angle];

        final int xx = y * sin + cos * x >> 16;
        final int yy = sin * x - y * cos >> 16;

        Point loc = minimapDrawWidget.getCanvasLocation();
        int miniMapX = loc.getX() + xx + minimapDrawWidget.getWidth() / 2;
        int miniMapY = minimapDrawWidget.getHeight() / 2 + loc.getY() + yy;
        return new Point(miniMapX, miniMapY);
    }

    public static Polygon getZonePoly(Client client, Zone zone) {
        Polygon areaPoly = new Polygon();
        if (zone == null)
            return areaPoly;

        for (int x = zone.getMinX(); x < zone.getMaxX(); x++) {
            addToPoly(client, areaPoly, new WorldPoint(x, zone.getMaxY(), zone.getMinWorldPoint().getPlane()), NW);
        }

        addToPoly(client, areaPoly, new WorldPoint(zone.getMaxX(), zone.getMaxY(), zone.getMinWorldPoint().getPlane()), NW, NE, SE);

        for (int y = zone.getMaxY() - 1; y > zone.getMinY(); y--) {
            addToPoly(client, areaPoly, new WorldPoint(zone.getMaxX(), y, zone.getMinWorldPoint().getPlane()), SE);
        }

        addToPoly(client, areaPoly, new WorldPoint(zone.getMaxX(), zone.getMinY(), zone.getMinWorldPoint().getPlane()), SE, SW);

        for (int x = zone.getMaxX() - 1; x > zone.getMinX(); x--) {
            addToPoly(client, areaPoly, new WorldPoint(x, zone.getMinY(), zone.getMinWorldPoint().getPlane()), SW);
        }

        addToPoly(client, areaPoly, new WorldPoint(zone.getMinX(), zone.getMinY(), zone.getMinWorldPoint().getPlane()), SW, NW);

        for (int y = zone.getMinY() + 1; y < zone.getMaxY(); y++) {
            addToPoly(client, areaPoly, new WorldPoint(zone.getMinX(), y, zone.getMinWorldPoint().getPlane()), NW);
        }

        return areaPoly;
    }

    private static void addToPoly(Client client, Polygon areaPoly, WorldPoint wp, int... points) {
        LocalPoint localPoint = LocalPoint.fromWorld(client.getTopLevelWorldView(), wp);
        if (localPoint == null)
            return;

        Polygon poly = net.runelite.api.Perspective.getCanvasTilePoly(client, localPoint);
        if (poly != null) {
            for (int point : points) {
                areaPoly.addPoint(poly.xpoints[point], poly.ypoints[point]);
            }
        }
    }
}
/*
 * Copyright (c) 2019, Trevor <https://github.com/Trevor159>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.datbear.overlay;

import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

import static net.runelite.api.Constants.REGION_SIZE;

public class Zone {
    @Getter
    private final int minX;
    @Getter
    private final int maxX;
    @Getter
    private final int minY;
    @Getter
    private final int maxY;
    private int minPlane = 0;
    private int maxPlane = 2;

    // The first plane of the "Overworld"
    public Zone() {
        minX = 1152;
        maxX = 3903;
        minY = 2496;
        maxY = 4159;
        maxPlane = 0;
    }

    public Zone(WorldPoint p1, WorldPoint p2) {
        assert (p1 != null);
        assert (p2 != null);
        minX = Math.min(p1.getX(), p2.getX());
        maxX = Math.max(p1.getX(), p2.getX());
        minY = Math.min(p1.getY(), p2.getY());
        maxY = Math.max(p1.getY(), p2.getY());
        minPlane = Math.min(p1.getPlane(), p2.getPlane());
        maxPlane = Math.max(p1.getPlane(), p2.getPlane());
    }

    public Zone(WorldPoint p) {
        assert (p != null);
        minX = p.getX();
        maxX = p.getX();
        minY = p.getY();
        maxY = p.getY();
        minPlane = p.getPlane();
        maxPlane = p.getPlane();
    }

    public Zone(int regionID) {
        minX = ((regionID >> 8) & 0xFF) << 6;
        maxX = minX + REGION_SIZE;
        minY = (regionID & 0xFF) << 6;
        maxY = minY + REGION_SIZE;
    }

    public Zone(int regionID, int plane) {
        this(regionID);
        minPlane = plane;
        maxPlane = plane;
    }

    public boolean contains(WorldPoint worldPoint) {
        return minX <= worldPoint.getX() && worldPoint.getX() <= maxX && minY <= worldPoint.getY()
                && worldPoint.getY() <= maxY && minPlane <= worldPoint.getPlane()
                && worldPoint.getPlane() <= maxPlane;
    }

    public WorldPoint getMinWorldPoint() {
        return new WorldPoint(minX, minY, minPlane);
    }
}
package com.datbear.ui;

import java.awt.Toolkit;
import java.awt.datatransfer.StringSelection;
import java.util.ArrayList;
import java.util.Arrays;

import com.datbear.data.TrialRoute;

import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.MenuOptionClicked;
// unused import removed

public class RouteModificationHelper {
    private static final String MENU_TOP_LEVEL = "[BT] Route Modification";
    private static final String MENU_ADD_WAYPOINT = "[BT] Add waypoint to route";
    private static final String MENU_INSERT_WAYPOINT = "[BT] Insert waypoint into route";
    private static final String MENU_REMOVE_WAYPOINT = "[BT] Remove this waypoint";
    private static final String MENU_EXPORT_ROUTE_POINTS = "[BT] Export route points to clipboard";

    public static MenuEntry[] addRouteModificationEntries(Client client, MenuEntry[] entries, TrialRoute route) {
        if (client == null || route == null) {
            return entries;
        }

        // Avoid duplicates if already added
        if (entries != null) {
            for (MenuEntry e : entries) {
                if (e != null && MENU_TOP_LEVEL.equals(e.getOption())) {
                    return entries; // already present
                }
            }
        }

        String routeLabel = "";//route.Location + " " + route.Rank;

        // Create a top-level marker entry (non-functional placeholder for grouping)
        var top = client.getMenu().createMenuEntry(-1)
                .setOption(MENU_TOP_LEVEL)
                .setTarget(routeLabel)
                .setType(MenuAction.RUNELITE);

        var subMenu = top.createSubMenu();

        // Create child entries (simulated hierarchy by ordering directly after top-level)
        var export = subMenu.createMenuEntry(-1)
                .setOption(MENU_EXPORT_ROUTE_POINTS)
                .setTarget(routeLabel)
                .setType(MenuAction.RUNELITE);
        var remove = subMenu.createMenuEntry(-1)
                .setOption(MENU_REMOVE_WAYPOINT)
                .setTarget(routeLabel)
                .setType(MenuAction.RUNELITE);
        var insert = subMenu.createMenuEntry(-1)
                .setOption(MENU_INSERT_WAYPOINT)
                .setTarget(routeLabel)
                .setType(MenuAction.RUNELITE);
        var add = subMenu.createMenuEntry(-1)
                .setOption(MENU_ADD_WAYPOINT)
                .setTarget(routeLabel)
                .setType(MenuAction.RUNELITE);

        var entryList = new ArrayList<MenuEntry>();
        entryList.add(top);
        entryList.addAll(Arrays.asList(entries));

        return entryList.toArray(new MenuEntry[0]);
    }

    // Handle clicks; lastVisitedIndex constrains inserts to +/- 5 of recent progress.
    public static boolean handleMenuOptionClicked(MenuOptionClicked event, Client client, TrialRoute route, Point menuOpenedPoint, int lastVisitedIndex) {
        if (event == null || client == null || route == null) {
            return false;
        }
        String option = event.getMenuOption();
        if (option == null) {
            return false;
        }
        boolean isOur = option.equals(MENU_ADD_WAYPOINT) || option.equals(MENU_INSERT_WAYPOINT) || option.equals(MENU_REMOVE_WAYPOINT) || option.equals(MENU_EXPORT_ROUTE_POINTS);
        if (!isOur) {
            return false;
        }

        Point canvasPoint = menuOpenedPoint != null ? menuOpenedPoint : client.getMouseCanvasPosition();
        WorldPoint worldPoint = getWorldPointFromPoint(client, canvasPoint);
        if (worldPoint == null) {
            return true;
        }

        if (option.equals(MENU_ADD_WAYPOINT)) {
            AddWaypoint(worldPoint, route);
        } else if (option.equals(MENU_INSERT_WAYPOINT)) {
            InsertWaypoint(worldPoint, route, lastVisitedIndex);
        } else if (option.equals(MENU_REMOVE_WAYPOINT)) {
            RemoveWaypoint(worldPoint, route, lastVisitedIndex);
        } else if (option.equals(MENU_EXPORT_ROUTE_POINTS)) {
            ExportRoute(route);
        }

        event.consume();
        return true;
    }

    private static void AddWaypoint(WorldPoint worldPoint, TrialRoute route) {
        if (route == null || worldPoint == null) {
            return;
        }
        if (route.Points == null) {
            route.Points = new ArrayList<>();
        }
        route.Points.add(worldPoint);
    }

    private static void InsertWaypoint(WorldPoint worldPoint, TrialRoute route, int lastVisitedIndex) {
        if (route == null || worldPoint == null) {
            return;
        }

        if (route.Points == null || route.Points.isEmpty()) {
            AddWaypoint(worldPoint, route);
            return;
        }
        int nearestIdx = -1;
        int minAllowed = Math.max(0, lastVisitedIndex - 5);
        int maxAllowed = Math.min(route.Points.size() - 1, lastVisitedIndex + 5);
        double nearestDist = Double.MAX_VALUE;
        for (int i = minAllowed; i <= maxAllowed; i++) {
            WorldPoint p = route.Points.get(i);
            if (p == null) {
                continue;
            }
            double d = Math.hypot(p.getX() - worldPoint.getX(), p.getY() - worldPoint.getY());
            if (d < nearestDist) {
                nearestDist = d;
                nearestIdx = i;
            }
        }
        // Insert after nearest to preserve forward ordering feel.
        route.Points.add(nearestIdx + 1, worldPoint);
    }

    private static void RemoveWaypoint(WorldPoint worldPoint, TrialRoute route, int lastVisitedIndex) {
        if (route == null || worldPoint == null) {
            return;
        }

        if (route.Points == null || route.Points.isEmpty()) {
            return;
        }
        int removeIdx = -1;
        double threshold = 5.0; // tiles
        double nearestDist = Double.MAX_VALUE;
        int minAllowed = Math.max(0, lastVisitedIndex - 5);
        int maxAllowed = Math.min(route.Points.size() - 1, lastVisitedIndex + 5);
        for (int i = minAllowed; i <= maxAllowed; i++) {
            WorldPoint p = route.Points.get(i);
            if (p == null) {
                continue;
            }
            double d = Math.hypot(p.getX() - worldPoint.getX(), p.getY() - worldPoint.getY());
            if (d < threshold && d < nearestDist) {
                nearestDist = d;
                removeIdx = i;
            }
        }
        if (removeIdx >= 0) {
            route.Points.remove(removeIdx);
        }
    }

    private static void ExportRoute(TrialRoute route) {
        if (route == null) {
            return;
        }

        StringBuilder sb = new StringBuilder();
        sb.append("\t// Trial Route:\n");
        var idx = 0;
        for (var point : route.Points) {
            sb.append(String.format("/*%d*/new WorldPoint(%d, %d, %d)%s\n", idx++, point.getX(), point.getY(), point.getPlane(), idx < route.Points.size() ? "," : ""));
        }
        sb.append("\t// End of trial route\n");

        var stringSelection = new StringSelection(sb.toString());
        var clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
        clipboard.setContents(stringSelection, null);
    }

    private static WorldPoint getWorldPointFromPoint(Client client, Point point) {
        var worldView = client.getTopLevelWorldView();
        var scene = worldView.getScene();
        var z = worldView.getPlane();
        var tiles = scene.getTiles();

        if (tiles != null && z >= 0 && z < tiles.length) {
            var plane = tiles[z];
            for (var x = 0; x < plane.length; x++) {
                for (var y = 0; y < plane[x].length; y++) {
                    var tile = plane[x][y];
                    if (tile == null)
                        continue;
                    var lp = tile.getLocalLocation();
                    var poly = Perspective.getCanvasTilePoly(client, lp);
                    if (poly == null || point == null)
                        continue;
                    if (poly.contains(point.getX(), point.getY())) {
                        return WorldPoint.fromLocalInstance(client, lp);
                    }
                }
            }
        }
        return null;
    }

}

package com.datbear;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class BearycudaTrialsPluginTest {
    public static void main(String[] args) throws Exception {
        ExternalPluginManager.loadBuiltin(BearycudaTrialsPlugin.class);
        RuneLite.main(args);
    }
}
