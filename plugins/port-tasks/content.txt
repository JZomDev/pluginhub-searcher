/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.Collections;
import java.util.List;

import javax.inject.Inject;

import com.nucleon.porttasks.overlay.WorldLines;
import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;

import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

class PortTasksMapOverlay extends Overlay
{
	private final Client client;
	private final PortTasksPlugin plugin;
	private final PortTasksConfig config;

	@Inject
	private PortTasksMapOverlay(Client client, PortTasksPlugin plugin, PortTasksConfig config)
	{
		this.client = client;
		this.plugin = plugin;
		this.config = config;

		setPosition(OverlayPosition.DYNAMIC);
		setPriority(Overlay.PRIORITY_HIGHEST);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		renderOverlayLines(graphics);
		return null;
	}

	private void renderOverlayLines(Graphics2D g)
	{
		for (PortTask tasks : plugin.currentTasks)
		{
			Color overlayColor = tasks.getOverlayColor();
			List<WorldPoint> journey = tasks.getData().dockMarkers.getFullPath();
			if (tasks.getData().reversePath)
			{
				Collections.reverse(journey);
			}
			if (tasks.isTracking())
			{
				WorldLines.createWorldMapLines(g, client, journey, overlayColor);
			}
		}
	}
}
package com.nucleon.porttasks.gameval;

public enum ItemID
{
	CARGO_CRATE_OF_STEEL_SWORDS(31680, "Steel Swords"),
	CARGO_CRATE_OF_RAW_FISH(31681, "Raw Fish"),
	CARGO_CRATE_OF_BANANAS(31682, "Bananas"),
	CARGO_CRATE_OF_ROTTEN_BANANAS(31683, "Rotten Bananas"),
	CARGO_CRATE_OF_BEER(31684, "Beer"),
	CARGO_CRATE_OF_LOGS(31685, "Logs"),
	CARGO_CRATE_OF_GROG(31686, "Grog"),
	CARGO_CRATE_OF_RUM(31687, "Rum"),
	CARGO_CRATE_OF_SMUGGLED_RUM(31688, "Smuggled Rum"),
	CARGO_CRATE_OF_KEGS(31689, "Kegs"),
	CARGO_CRATE_OF_BAIT(31690, "Bait"),
	CARGO_CRATE_OF_POTATOES(31691, "Potatoes"),
	CARGO_CRATE_OF_COMPOST(31692, "Compost"),
	CARGO_CRATE_OF_RED_SALAMANDERS(31693, "Red Salamanders"),
	CARGO_CRATE_OF_SWAMP_PASTE(31694, "Swamp Paste"),
	CARGO_CRATE_OF_IDENTIFIED_SWORDS(31695, "Identified Swords"),
	CARGO_CRATE_OF_LIVE_LOBSTERS(31696, "Live Lobsters"),
	CARGO_CRATE_OF_RAW_LOBSTERS(31697, "Raw Lobsters"),
	CARGO_CRATE_OF_WAX(31698, "Wax"),
	CARGO_CRATE_OF_COCONUTS(31699, "Coconuts"),
	CARGO_CRATE_OF_VIALS(31700, "Vials"),
	CARGO_CRATE_OF_SILK(31701, "Silk"),
	CARGO_CRATE_OF_PINEAPPLES(31702, "Pineapples"),
	CARGO_CRATE_OF_FRESH_FISH(31703, "Fresh Fish"),
	CARGO_CRATE_OF_CABBAGES(31704, "Cabbages"),
	CARGO_CRATE_OF_STEEL_ARROWTIPS(31705, "Steel Arrowtips"),
	CARGO_CRATE_OF_RAW_KARAMBWAN(31706, "Raw Karambwan"),
	CARGO_CRATE_OF_OAK_PLANKS(31707, "Oak Planks"),
	CARGO_CRATE_OF_GLASS_MAKE_SUPPLIES(31708, "Glass Make Supplies"),
	CARGO_CRATE_OF_COAL(31709, "Coal"),
	CARGO_CRATE_OF_SILVER_JEWELLERY(31710, "Silver Jewellery"),
	CARGO_CRATE_OF_BUCKETS(31711, "Buckets"),
	CARGO_CRATE_OF_TRAWLER_FISH(31712, "Trawler Fish"),
	CARGO_CRATE_OF_GOLD_ORE(31713, "Gold Ore"),
	CARGO_CRATE_OF_MITHRIL_ARMOUR(31714, "Mithril Armour"),
	CARGO_CRATE_OF_SAND(31715, "Sand"),
	CARGO_CRATE_OF_SPICES(31716, "Spices"),
	CARGO_CRATE_OF_SECRET_STUFF(31717, "Secret Stuff"),
	CARGO_CRATE_OF_DRAGON_DAGGERS(31718, "Dragon Daggers"),
	CARGO_CRATE_OF_SHIP_PARTS(31719, "Ship Parts"),
	CARGO_CRATE_OF_DRAGON_EQUIPMENT(31720, "Dragon Equipment"),
	CARGO_CRATE_OF_SPIRIT_ANGLERS_GARB(31721, "Spirit Anglers Garb"),
	CARGO_CRATE_OF_ANGLERS_OUTFIT(31722, "Anglers Outfit"),
	CARGO_CRATE_OF_BRIMHAVEN_PINEAPPLES(31723, "Brimhaven Pineapples"),
	CARGO_CRATE_OF_HIGH_IMPORTANCE(31724, "High Importance"),
	CARGO_CRATE_OF_SALTED_MEAT(31725, "Salted Meat"),
	CARGO_CRATE_OF_DRAGONS_BITTER(31726, "Dragons Bitter"),
	CARGO_CRATE_OF_HOPS(31727, "Hops"),
	CARGO_CRATE_OF_BONES(31728, "Bones"),
	CARGO_CRATE_OF_STEEL_BARS(31729, "Steel Bars"),
	CARGO_CRATE_OF_BARK(31730, "Bark"),
	CARGO_CRATE_OF_RAW_MEAT(31731, "Raw Meat"),
	CARGO_CRATE_OF_LUMBER(31732, "Lumber"),
	CARGO_CRATE_OF_LIVE_RABBITS(31733, "Live Rabbits"),
	CARGO_CRATE_OF_HAMMERS(31734, "Hammers"),
	CARGO_CRATE_OF_MUSHROOMS(31735, "Mushrooms"),
	CARGO_CRATE_OF_FUR(31736, "Fur"),
	CARGO_CRATE_OF_CLOTHING(31737, "Clothing"),
	CARGO_CRATE_OF_FISHING_EQUIPMENT(31738, "Fishing Equipment"),
	CARGO_CRATE_OF_GRANITE(31739, "Granite"),
	CARGO_CRATE_OF_IMPORTANCE(31740, "Importance"),
	CARGO_CRATE_OF_COCKTAILS(31741, "Cocktails"),
	CARGO_CRATE_OF_CACTUS(31742, "Cactus"),
	CARGO_CRATE_OF_CORAL(31743, "Coral"),
	CARGO_CRATE_OF_SANDSTONE(31744, "Sandstone"),
	CARGO_CRATE_OF_CROCODILE_MEAT(31745, "Crocodile Meat"),
	CARGO_CRATE_OF_CACTUS_JUICE(31746, "Cactus Juice"),
	CARGO_CRATE_OF_YAK_HAIR(31747, "Yak Hair"),
	CARGO_CRATE_OF_NAIL_BEAST_FUR(31748, "Nail Beast Fur"),
	CARGO_CRATE_OF_KYATT_FUR(31749, "Kyatt Fur"),
	CARGO_CRATE_OF_KEBBIT_TEETH(31750, "Kebbit Teeth"),
	CARGO_CRATE_OF_REDWOOD(31751, "Redwood"),
	CARGO_CRATE_OF_BRAINDEATH_RUM(31752, "Braindeath Rum"),
	CARGO_CRATE_OF_KYATT_TEETH(31753, "Kyatt Teeth"),
	CARGO_CRATE_OF_SPECIAL_FISH(31754, "Special Fish"),
	CARGO_CRATE_OF_VARROCK_BOOKS(31755, "Varrock Books"),
	CARGO_CRATE_OF_ARCEUUS_BOOKS(31756, "Arceuus Books"),
	CARGO_CRATE_OF_ANTELOPE_MEAT(31757, "Antelope Meat"),
	CARGO_CRATE_OF_ANGLERFISH(31758, "Anglerfish"),
	CARGO_CRATE_OF_VEGETABLES(31759, "Vegetables"),
	CARGO_CRATE_OF_MITHRIL_ORE(31760, "Mithril Ore"),
	CARGO_CRATE_OF_PLANKS(31761, "Planks"),
	CARGO_CRATE_OF_FLOUR(31762, "Flour"),
	CARGO_CRATE_OF_SEAWEED(31763, "Seaweed"),
	CARGO_CRATE_OF_VARROCK_RUNES(31764, "Varrock Runes"),
	CARGO_CRATE_OF_YANILLE_RUNES(31765, "Yanille Runes"),
	CARGO_CRATE_OF_SEEDS(31766, "Seeds"),
	CARGO_CRATE_OF_RELLEKKA_SHARKS(31767, "Rellekka Sharks"),
	CARGO_CRATE_OF_WINE(31768, "Wine"),
	CARGO_CRATE_OF_CHOCOLATE(31769, "Chocolate"),
	CARGO_CRATE_OF_MARBLE(31770, "Marble"),
	CARGO_CRATE_OF_WHEAT(31771, "Wheat"),
	CARGO_CRATE_OF_EXOTIC_FURS(31772, "Exotic Furs"),
	CARGO_CRATE_OF_ALPACA_WOOL(31773, "Alpaca Wool"),
	CARGO_CRATE_OF_PIRATE_LOOTY(31774, "Pirate Looty"),
	CARGO_CRATE_MUSA_POINT_0(31775, "Musa Point 0"),
	CARGO_CRATE_MUSA_POINT_1(31776, "Musa Point 1"),
	CARGO_CRATE_MUSA_POINT_2(31777, "Musa Point 2"),
	CARGO_CRATE_MUSA_POINT_3(31778, "Musa Point 3"),
	CARGO_CRATE_MUSA_POINT_4(31779, "Musa Point 4"),
	CARGO_CRATE_MUSA_POINT_5(31780, "Musa Point 5"),
	CARGO_CRATE_MUSA_POINT_6(31781, "Musa Point 6"),
	CARGO_CRATE_MUSA_POINT_7(31782, "Musa Point 7"),
	CARGO_CRATE_MUSA_POINT_8(31783, "Musa Point 8"),
	CARGO_CRATE_MUSA_POINT_9(31784, "Musa Point 9"),
	CARGO_CRATE_MUSA_POINT_10(31785, "Musa Point 10"),
	CARGO_CRATE_MUSA_POINT_11(31786, "Musa Point 11"),
	CARGO_CRATE_MUSA_POINT_12(31787, "Musa Point 12"),
	CARGO_CRATE_MUSA_POINT_13(31788, "Musa Point 13"),
	CARGO_CRATE_MUSA_POINT_14(31789, "Musa Point 14"),
	SAILING_INTRO_CARGO_CRATE(31790, "Sailing Intro Cargo Crate"),
	BOUNTY_OBJECT_FAMISHED_SHARK_FIN(31791, "Famished Shark Fin"),
	BOUNTY_OBJECT_CRANDOR_SHARK_FIN(31792, "Crandor Shark Fin"),
	BOUNTY_OBJECT_KARAMJAN_SHARK_JAW(31793, "Karamjan Shark Jaw"),
	BOUNTY_OBJECT_LARGE_REEF_SHARK_TEETH(31794, "Large Reef Shark Teeth"),
	BOUNTY_OBJECT_PYGMY_KRAKEN_TENTACLE(31795, "Pygmy Kraken Tentacle"),
	BOUNTY_OBJECT_PRISTINE_CATHERBY_MONODON_HORN(31796, "Pristine Catherby Monodon Horn"),
	BOUNTY_OBJECT_BROKEN_CATHERBY_MONODON_HORN(31797, "Broken Catherby Monodon Horn"),
	BOUNTY_OBJECT_PYGMY_KRAKEN_BUNCH_OF_TENTACLES(31798, "Pygmy Kraken Bunch Of Tentacles"),
	BOUNTY_OBJECT_OGRE_MONODON_HORN(31799, "Ogre Monodon Horn"),
	BOUNTY_OBJECT_BABY_KRAKEN_HEADS(31800, "Baby Kraken Heads"),
	BOUNTY_OBJECT_BROKEN_KHARAZI_MONODON_HORN(31801, "Broken Kharazi Monodon Horn"),
	BOUNTY_OBJECT_LARGE_REEF_SHARK_FIN(31802, "Large Reef Shark Fin"),
	BOUNTY_OBJECT_BROKEN_OGRE_MONODON_HORN(31803, "Broken Ogre Monodon Horn"),
	BOUNTY_OBJECT_BABY_SEA_KRAKEN_TENTACLE(31804, "Baby Sea Kraken Tentacle"),
	BOUNTY_OBJECT_DEEP_SEA_KRAKEN_HEART(31805, "Deep Sea Kraken Heart"),
	BOUNTY_OBJECT_ALBATROSS_FEATHER(31806, "Albatross Feather"),
	BOUNTY_OBJECT_SEA_MONODON_HEART(31807, "Sea Monodon Heart"),
	BOUNTY_OBJECT_GREAT_WHITE_SHARK_HEART(31808, "Great White Shark Heart"),
	BOUNTY_OBJECT_KARAMJAN_TIGER_SHARK_FIN(31809, "Karamjan Tiger Shark Fin"),
	BOUNTY_OBJECT_SEA_HAWK_FEATHER(31810, "Sea Hawk Feather"),
	BOUNTY_OBJECT_SEA_MONODON_HORN(31811, "Sea Monodon Horn"),
	BOUNTY_OBJECT_BABY_SEA_KRAKEN_BLOOD(31812, "Baby Sea Kraken Blood"),
	BOUNTY_OBJECT_DEEP_SEA_KRAKEN_TENTACLE(31813, "Deep Sea Kraken Tentacle"),
	BOUNTY_OBJECT_GREAT_WHITE_SHARK_FIN(31814, "Great White Shark Fin");

	private final int id;
	private final String name;

	ItemID(int id, String name)
	{
		this.id = id;
		this.name = name;
	}

	public int getId()
	{
		return id;
	}

	public static String getNameById(int id)
	{
		for (ItemID item : values())
		{
			if (item.id == id)
			{
				return item.name;
			}
		}
		return "Unknown Item";
	}
}

/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks.gameval;

public final class VarbitID
{
	public static final int CHARGES_HORN_OF_PLENTY_QUANTITY = 16565;
	public static final int SETTINGS_SAILING_OPTIONS = 16566;
	public static final int SAILING_PORT_TASK_CANCEL_WARNING_DISABLED = 16567;
	public static final int SAILING_CURRENT_DUCK_HINTARROW_DISABLED = 16586;
	public static final int SAILING_BARRACUDA_TRIALS_HINTARROW_DISABLED = 16587;
	public static final int SETTINGS_INTERFACE_RESIZING = 16588;
	public static final int SETTINGS_COLOURFUL_FADE_DISABLED = 16589;
	public static final int OPTION_HIDE_ROOFTOPS_OVERRIDE = 16590;
	public static final int SETTINGS_SAILING_CHARTING_POPUP = 16591;
	public static final int SAILING_INTRO = 16592;
	public static final int DREAM_PLANKSPELL_CAMPHOR = 16593;
	public static final int DREAM_PLANKSPELL_IRONWOOD = 16594;
	public static final int DREAM_PLANKSPELL_ROSEWOOD = 16595;
	public static final int TRR = 16596;
	public static final int TRR_START_READY = 16597;
	public static final int FLOOPA_CONCH_VIS = 16598;
	public static final int TRR_DISPLAY_CASE_1 = 16599;
	public static final int TRR_DISPLAY_CASE_2 = 16600;
	public static final int TRR_DISPLAY_CASE_3 = 16601;
	public static final int TRR_DISPLAY_CASE_4 = 16602;
	public static final int TRR_PARROT = 16603;
	public static final int QUEST_PRY = 16604;
	public static final int QUEST_PRY_STEVE_LOG = 16605;
	public static final int QUEST_PRY_THURGO_MET = 16606;
	public static final int CURRENT_AFFAIRS = 16607;
	public static final int ARHEIN_MET = 16608;
	public static final int CURRENT_AFFAIRS_FORM_DIALOGUE = 16609;
	public static final int CURRENT_AFFAIRS_FORM_GIVEN = 16616;
	public static final int CURRENT_AFFAIRS_HARRY_CHAT = 16617;
	public static final int CURRENT_AFFAIRS_KIT_PURCHASED = 16618;
	public static final int CURRENT_AFFAIRS_AUDIT_START = 16619;
	public static final int CURRENT_AFFAIRS_FORM_2_GIVEN = 16620;
	public static final int CURRENT_AFFAIRS_FORM_Q1 = 16621;
	public static final int CURRENT_AFFAIRS_FORM_Q2 = 16622;
	public static final int CURRENT_AFFAIRS_FORM_Q3 = 16623;
	public static final int CURRENT_AFFAIRS_FORM_Q4 = 16624;
	public static final int CURRENT_AFFAIRS_FORM_Q5 = 16629;
	public static final int CURRENT_AFFAIRS_FORM_Q6 = 16630;
	public static final int CURRENT_AFFAIRS_FORM_Q7 = 16631;
	public static final int CURRENT_AFFAIRS_FORM_Q8 = 16632;
	public static final int CURRENT_AFFAIRS_FORM_Q1_CORRECT = 16633;
	public static final int CURRENT_AFFAIRS_FORM_Q2_CORRECT = 16634;
	public static final int CURRENT_AFFAIRS_FORM_Q3_CORRECT = 16635;
	public static final int CURRENT_AFFAIRS_FORM_Q4_CORRECT = 16639;
	public static final int CURRENT_AFFAIRS_FORM_Q5_CORRECT = 16640;
	public static final int CURRENT_AFFAIRS_FORM_Q6_CORRECT = 16641;
	public static final int CURRENT_AFFAIRS_FORM_Q7_CORRECT = 16642;
	public static final int CURRENT_AFFAIRS_FORM_Q8_CORRECT = 16643;
	public static final int FAIRYRINGS_LOG_CJQ = 16644;
	public static final int TT = 16650;
	public static final int TT_HUNTING_TRAIL_1 = 16651;
	public static final int TT_HUNTING_TRAIL_2 = 16652;
	public static final int TT_HUNTING_TRAIL_3 = 16653;
	public static final int TT_HUNTING_TRAIL_4 = 16654;
	public static final int TT_HUNTING_TRAIL_5 = 16655;
	public static final int TT_REPAIR_KRILL_STALL = 16658;
	public static final int TT_REPAIR_KRILL_WALL = 16659;
	public static final int TT_REPAIR_STROM_WALL = 16660;
	public static final int TT_REPAIR_STROM_CRATES = 16661;
	public static final int TT_REPAIR_COCO_STALL = 16662;
	public static final int TT_REPAIR_COCO_CRATES = 16663;
	public static final int TT_FREE_SHIELD = 16664;
	public static final int CONCH_CORAL_PATCHES_UNLOCKED = 16666;
	public static final int COLLECTION_BOSSES_GRYPHON_BOSS_COMPLETED = 16674;
	public static final int SAILING_CHARTING_DRINK_CRATE_WARNING = 16677;
	public static final int CA_TOTAL_TASKS_COMPLETED_GRYPHON_BOSS = 16692;
	public static final int SLAYER_GRYPHON_BOSS_GUARDIAN_MET = 16694;
	public static final int FLETCHING_TABLE_SELECTED_QTY = 16697;
	public static final int FLETCHING_TABLE_OPENED = 16698;
	public static final int FLETCHING_TABLE_REQUESTED_QTY = 16699;
	public static final int CRAB_TRAP_PANDEMONIUM_1 = 16700;
	public static final int CRAB_TRAP_PANDEMONIUM_2 = 16701;
	public static final int CRAB_TRAP_PANDEMONIUM_3 = 16702;
	public static final int CRAB_TRAP_PANDEMONIUM_4 = 16703;
	public static final int CRAB_TRAP_PANDEMONIUM_5 = 16704;
	public static final int CRAB_TRAP_GREAT_CONCH_NORTH_1 = 16706;
	public static final int CRAB_TRAP_GREAT_CONCH_NORTH_2 = 16712;
	public static final int CRAB_TRAP_GREAT_CONCH_NORTH_3 = 16713;
	public static final int CRAB_TRAP_GREAT_CONCH_NORTH_4 = 16714;
	public static final int CRAB_TRAP_GREAT_CONCH_NORTH_5 = 16715;
	public static final int CRAB_TRAP_GREAT_CONCH_EAST_1 = 16716;
	public static final int CRAB_TRAP_GREAT_CONCH_EAST_2 = 16717;
	public static final int CRAB_TRAP_GREAT_CONCH_EAST_3 = 16721;
	public static final int CRAB_TRAP_GREAT_CONCH_EAST_4 = 16722;
	public static final int CRAB_TRAP_GREAT_CONCH_EAST_5 = 16723;
	public static final int CRAB_TRAP_CROWN_JEWEL_1 = 16724;
	public static final int CRAB_TRAP_CROWN_JEWEL_2 = 16726;
	public static final int CRAB_TRAP_CROWN_JEWEL_3 = 16728;
	public static final int CRAB_TRAP_CROWN_JEWEL_4 = 16729;
	public static final int CRAB_TRAP_CROWN_JEWEL_5 = 16730;
	public static final int AMENITY_VARBIT_0 = 16764;
	public static final int AMENITY_VARBIT_1 = 16765;
	public static final int AMENITY_VARBIT_2 = 16766;
	public static final int AMENITY_VARBIT_3 = 16769;
	public static final int AMENITY_VARBIT_4 = 16770;
	public static final int AMENITY_VARBIT_5 = 16771;
	public static final int AMENITY_VARBIT_6 = 16785;
	public static final int AMENITY_VARBIT_7 = 16994;
	public static final int AMENITY_VARBIT_8 = 16995;
	public static final int AMENITY_VARBIT_9 = 16996;
	public static final int AMENITY_VARBIT_10 = 17067;
	public static final int AMENITY_VARBIT_11 = 17068;
	public static final int AMENITY_VARBIT_12 = 17069;
	public static final int AMENITY_VARBIT_13 = 17071;
	public static final int AMENITY_VARBIT_14 = 17072;
	public static final int AMENITY_VARBIT_15 = 17073;
	public static final int AMENITY_VARBIT_16 = 17090;
	public static final int AMENITY_VARBIT_17 = 17147;
	public static final int AMENITY_VARBIT_18 = 17196;
	public static final int AMENITY_VARBIT_19 = 17198;
	public static final int AMENITY_VARBIT_20 = 17210;
	public static final int AMENITY_VARBIT_21 = 17211;
	public static final int AMENITY_VARBIT_22 = 17212;
	public static final int AMENITY_VARBIT_23 = 17213;
	public static final int AMENITY_VARBIT_24 = 17214;
	public static final int AMENITY_VARBIT_25 = 17215;
	public static final int AMENITY_VARBIT_26 = 17218;
	public static final int AMENITY_VARBIT_27 = 17219;
	public static final int AMENITY_VARBIT_28 = 17220;
	public static final int AMENITY_VARBIT_29 = 17222;
	public static final int AMENITY_VARBIT_30 = 17223;
	public static final int AMENITY_VARBIT_31 = 17224;
	public static final int SAILING_BOAT_1_NAME_1 = 17290;
	public static final int SAILING_BOAT_1_NAME_2 = 17291;
	public static final int SAILING_BOAT_1_NAME_3 = 17293;
	public static final int SAILING_BOAT_1_KEEL = 17294;
	public static final int SAILING_BOAT_1_HULL = 17346;
	public static final int SAILING_BOAT_1_MAST = 17347;
	public static final int SAILING_BOAT_1_SAIL = 17348;
	public static final int SAILING_BOAT_1_STEERING = 17351;
	public static final int SAILING_BOAT_1_TELEPORT_FOCUS = 17352;
	public static final int SAILING_BOAT_1_HOTSPOT_0 = 17353;
	public static final int SAILING_BOAT_1_HOTSPOT_1 = 17605;
	public static final int SAILING_BOAT_1_HOTSPOT_2 = 17606;
	public static final int SAILING_BOAT_1_HOTSPOT_3 = 17607;
	public static final int SAILING_BOAT_1_HOTSPOT_4 = 17608;
	public static final int SAILING_BOAT_1_HOTSPOT_5 = 17609;
	public static final int SAILING_BOAT_1_HOTSPOT_6 = 17610;
	public static final int SAILING_BOAT_1_HOTSPOT_7 = 17611;
	public static final int SAILING_BOAT_2_NAME_1 = 17617;
	public static final int SAILING_BOAT_2_NAME_2 = 17618;
	public static final int SAILING_BOAT_2_NAME_3 = 17619;
	public static final int SAILING_BOAT_2_KEEL = 17620;
	public static final int SAILING_BOAT_2_HULL = 17621;
	public static final int SAILING_BOAT_2_MAST = 17622;
	public static final int SAILING_BOAT_2_SAIL = 17623;
	public static final int SAILING_BOAT_2_STEERING = 17624;
	public static final int SAILING_BOAT_2_TELEPORT_FOCUS = 17625;
	public static final int SAILING_BOAT_2_HOTSPOT_0 = 17626;
	public static final int SAILING_BOAT_2_HOTSPOT_1 = 17627;
	public static final int SAILING_BOAT_2_HOTSPOT_2 = 17628;
	public static final int SAILING_BOAT_2_HOTSPOT_3 = 17629;
	public static final int SAILING_BOAT_2_HOTSPOT_4 = 17630;
	public static final int SAILING_BOAT_2_HOTSPOT_5 = 17631;
	public static final int SAILING_BOAT_2_HOTSPOT_6 = 17632;
	public static final int SAILING_BOAT_2_HOTSPOT_7 = 17633;
	public static final int SAILING_BOAT_3_NAME_1 = 17639;
	public static final int SAILING_BOAT_3_NAME_2 = 17640;
	public static final int SAILING_BOAT_3_NAME_3 = 17641;
	public static final int SAILING_BOAT_3_KEEL = 17642;
	public static final int SAILING_BOAT_3_HULL = 17643;
	public static final int SAILING_BOAT_3_MAST = 17644;
	public static final int SAILING_BOAT_3_SAIL = 17645;
	public static final int SAILING_BOAT_3_STEERING = 17646;
	public static final int SAILING_BOAT_3_TELEPORT_FOCUS = 17647;
	public static final int SAILING_BOAT_3_HOTSPOT_0 = 17648;
	public static final int SAILING_BOAT_3_HOTSPOT_1 = 17649;
	public static final int SAILING_BOAT_3_HOTSPOT_2 = 17650;
	public static final int SAILING_BOAT_3_HOTSPOT_3 = 17651;
	public static final int SAILING_BOAT_3_HOTSPOT_4 = 17652;
	public static final int SAILING_BOAT_3_HOTSPOT_5 = 17653;
	public static final int SAILING_BOAT_3_HOTSPOT_6 = 17654;
	public static final int SAILING_BOAT_3_HOTSPOT_7 = 17655;
	public static final int SAILING_BOAT_4_NAME_1 = 17661;
	public static final int SAILING_BOAT_4_NAME_2 = 17662;
	public static final int SAILING_BOAT_4_NAME_3 = 17663;
	public static final int SAILING_BOAT_4_KEEL = 17664;
	public static final int SAILING_BOAT_4_HULL = 17665;
	public static final int SAILING_BOAT_4_MAST = 17666;
	public static final int SAILING_BOAT_4_SAIL = 17667;
	public static final int SAILING_BOAT_4_STEERING = 17668;
	public static final int SAILING_BOAT_4_TELEPORT_FOCUS = 17669;
	public static final int SAILING_BOAT_4_HOTSPOT_0 = 17670;
	public static final int SAILING_BOAT_4_HOTSPOT_1 = 17671;
	public static final int SAILING_BOAT_4_HOTSPOT_2 = 17672;
	public static final int SAILING_BOAT_4_HOTSPOT_3 = 17673;
	public static final int SAILING_BOAT_4_HOTSPOT_4 = 17674;
	public static final int SAILING_BOAT_4_HOTSPOT_5 = 17675;
	public static final int SAILING_BOAT_4_HOTSPOT_6 = 17676;
	public static final int SAILING_BOAT_4_HOTSPOT_7 = 17677;
	public static final int SAILING_BOAT_5_NAME_1 = 17683;
	public static final int SAILING_BOAT_5_NAME_2 = 17684;
	public static final int SAILING_BOAT_5_NAME_3 = 17685;
	public static final int SAILING_BOAT_5_KEEL = 17686;
	public static final int SAILING_BOAT_5_HULL = 17687;
	public static final int SAILING_BOAT_5_MAST = 17688;
	public static final int SAILING_BOAT_5_SAIL = 17689;
	public static final int SAILING_BOAT_5_STEERING = 17690;
	public static final int SAILING_BOAT_5_TELEPORT_FOCUS = 17691;
	public static final int SAILING_BOAT_5_HOTSPOT_0 = 17692;
	public static final int SAILING_BOAT_5_HOTSPOT_1 = 17693;
	public static final int SAILING_BOAT_5_HOTSPOT_2 = 17694;
	public static final int SAILING_BOAT_5_HOTSPOT_3 = 17695;
	public static final int SAILING_BOAT_5_HOTSPOT_4 = 17696;
	public static final int SAILING_BOAT_5_HOTSPOT_5 = 17697;
	public static final int SAILING_BOAT_5_HOTSPOT_6 = 17698;
	public static final int SAILING_BOAT_5_HOTSPOT_7 = 17699;
	public static final int SAILING_PLAYER_IS_ON_BOAT = 17710;
	public static final int SAILING_BOAT_FACILITY_LOCKEDIN = 17711;
	public static final int SAILING_SHIPYARD_ON_BOAT = 17712;
	public static final int SAILING_SIDEPANEL_CREW_ASSIGNATION = 17713;
	public static final int SAILING_IRON_RULES_APPLY = 17714;
	public static final int SAILING_BOAT_TIME_TILL_TRIM = 17715;
	public static final int SAILING_BOAT_TIME_TRIM_WINDOW = 17716;
	public static final int SAILING_BOAT_SPEEDBOOST_DURATION = 17717;
	public static final int SAILING_BOAT_WINDS_TIMER_PAUSED = 17718;
	public static final int SAILING_BOAT_SPAWNED = 17719;
	public static final int SAILING_BOARDED_BOAT_WORLD = 17720;
	public static final int SAILING_BOAT_CARGOHOLD_WARNING_DISMISSED = 17721;
	public static final int SAILING_BOAT_SPAWNED_ANGLE = 17722;
	public static final int SAILING_PREVIOUS_BOAT_DATA_SLOT = 17723;
	public static final int SAILING_FACILITY_SETTING_DO_NOT_WITHDRAW_CHARGE_ON_DEACTIVATE = 17724;
	public static final int SAILING_FACILITY_SETTING_FULLY_CHARGE_ON_ACTIVATE = 17725;
	public static final int SAILING_FACILITY_SETTING_ANTISPAM = 17726;
	public static final int SAILING_CARRYING_CARGO = 17727;
	public static final int SAILING_PORT_TASK_OPENED_SLOT = 17728;
	public static final int SAILING_BOARDED_BOAT = 17729;
	public static final int SAILING_BOARDED_BOAT_TYPE = 17730;
	public static final int SAILING_BOAT_CAPSIZE_TUTORIAL = 17731;
	public static final int TRAWLING_NET_CARGO_WARNING_DISMISSED = 17732;
	public static final int SAILING_BOAT_SPAWNED_FINEX = 17733;
	public static final int SAILING_BOAT_SPAWNED_FINEZ = 17734;
	public static final int SAILING_PREVIOUS_BOAT_TYPE_ID = 17735;
	public static final int SAILING_BOARDED_BOAT_LAST_DOCK = 17736;
	public static final int SAILING_BOARDED_BOAT_LAST_STANDARD_DOCK = 17737;
	public static final int SAILING_BOARDED_BOAT_NAME_1 = 17738;
	public static final int SAILING_BOARDED_BOAT_NAME_2 = 17739;
	public static final int SAILING_BOARDED_BOAT_NAME_3 = 17740;
	public static final int SAILING_BOARDED_BOAT_LAST_MOORING_POINT = 17741;
	public static final int SAILING_SIDEPANEL_VISIBLE = 17742;
	public static final int SAILING_SIDEPANEL_TABS = 17743;
	public static final int SAILING_SIDEPANEL_VISIBLE_FROM_COMBAT_TAB = 17744;
	public static final int SAILING_SIDEPANEL_FACILITY_SAIL = 17745;
	public static final int SAILING_SIDEPANEL_FACILITY_HELM = 17746;
	public static final int SAILING_SIDEPANEL_FACILITY_HOTSPOT0 = 17747;
	public static final int SAILING_SIDEPANEL_FACILITY_HOTSPOT1 = 17748;
	public static final int SAILING_SIDEPANEL_FACILITY_HOTSPOT2 = 17749;
	public static final int SAILING_SIDEPANEL_FACILITY_HOTSPOT3 = 17750;
	public static final int SAILING_SIDEPANEL_FACILITY_HOTSPOT4 = 17751;
	public static final int SAILING_SIDEPANEL_FACILITY_HOTSPOT5 = 17752;
	public static final int SAILING_SIDEPANEL_FACILITY_HOTSPOT6 = 17753;
	public static final int SAILING_SIDEPANEL_FACILITY_HOTSPOT7 = 17754;
	public static final int SAILING_SIDEPANEL_CREW_ASSIGNATION_FACILITY_VIEWED = 17755;
	public static final int SAILING_SIDEPANEL_SAIL_BUTTON_TOGGLED = 17756;
	public static final int SAILING_SIDEPANEL_BOAT_MOVE_MODE = 17757;
	public static final int SAILING_SIDEPANEL_HELM_STATUS = 17758;
	public static final int SAILING_SIDEPANEL_BOAT_HP_MAX = 17759;
	public static final int SAILING_SIDEPANEL_BOAT_WIND_CHARGES = 17760;
	public static final int SAILING_SIDEPANEL_BOAT_WIND_CATCHER_ENABLED = 17761;
	public static final int SAILING_SIDEPANEL_BOAT_HP = 17762;
	public static final int SAILING_SIDEPANEL_BOAT_TRAWLING_NET_LEVEL = 17763;
	public static final int SAILING_SIDEPANEL_AMMUNITION_TIER_0 = 17764;
	public static final int SAILING_SIDEPANEL_AMMUNITION_TIER_1 = 17765;
	public static final int SAILING_SIDEPANEL_AMMUNITION_TIER_2 = 17766;
	public static final int SAILING_SIDEPANEL_AMMUNITION_TIER_3 = 17767;
	public static final int SAILING_SIDEPANEL_AMMUNITION_TIER_4 = 17768;
	public static final int SAILING_SIDEPANEL_AMMUNITION_TIER_5 = 17769;
	public static final int SAILING_SIDEPANEL_AMMUNITION_TIER_6 = 17770;
	public static final int SAILING_SIDEPANEL_AMMUNITION_TIER_7 = 17771;
	public static final int SAILING_SIDEPANEL_PLAYER_ROLE = 17772;
	public static final int SAILING_SIDEPANEL_CREW_PLAYER_VIEW = 17773;
	public static final int SAILING_SIDEPANEL_PLAYERS_ON_BOARD_TOTAL = 17774;
	public static final int SAILING_SIDEPANEL_CREW_SLOT_1_POSITION = 17775;
	public static final int SAILING_SIDEPANEL_CREW_SLOT_2_POSITION = 17776;
	public static final int SAILING_SIDEPANEL_CREW_SLOT_3_POSITION = 17777;
	public static final int SAILING_SIDEPANEL_CREW_SLOT_4_POSITION = 17778;
	public static final int SAILING_SIDEPANEL_CREW_SLOT_5_POSITION = 17779;
	public static final int SAILING_SIDEPANEL_CREW_SLOT_1 = 17780;
	public static final int SAILING_SIDEPANEL_CREW_SLOT_2 = 17781;
	public static final int SAILING_SIDEPANEL_CREW_SLOT_3 = 17782;
	public static final int SAILING_SIDEPANEL_CREW_SLOT_4 = 17783;
	public static final int SAILING_SIDEPANEL_CREW_SLOT_5 = 17784;
	public static final int SAILING_SIDEPANEL_BOAT_STORMRESISTANCE = 17785;
	public static final int SAILING_SIDEPANEL_BOAT_RAPIDRESISTANCE = 17786;
	public static final int SAILING_SIDEPANEL_BOAT_BASESPEED = 17787;
	public static final int SAILING_SIDEPANEL_BOAT_SPEEDCAP = 17788;
	public static final int SAILING_SIDEPANEL_BOAT_CRYSTALFLECKED_RESISTANT = 17789;
	public static final int SAILING_SIDEPANEL_BOAT_SPEEDBOOST_DURATION = 17790;
	public static final int SAILING_COMBAT_PREFERRED_AMMUNITION = 17791;
	public static final int SAILING_COMBAT_LAST_FIRED_AMMUNITION_PLAYER = 17792;
	public static final int SAILING_FACILITY_HOTSPOT_NUMBER = 17793;
	public static final int SAILING_BT_IN_TRIAL = 17794;
	public static final int SAILING_BT_GWENITH_GLIDE_CRYSTAL_ITHELL_DEACTIVATED = 17795;
	public static final int SAILING_BT_GWENITH_GLIDE_CRYSTAL_AMLODD_DEACTIVATED = 17796;
	public static final int SAILING_BT_GWENITH_GLIDE_CRYSTAL_CADARN_DEACTIVATED = 17797;
	public static final int SAILING_BT_GWENITH_GLIDE_CRYSTAL_CRWYS_DEACTIVATED = 17798;
	public static final int SAILING_BT_GWENITH_GLIDE_CRYSTAL_HEFIN_DEACTIVATED = 17799;
	public static final int SAILING_BT_GWENITH_GLIDE_CRYSTAL_IORWERTH_DEACTIVATED = 17800;
	public static final int SAILING_BT_GWENITH_GLIDE_CRYSTAL_MEILYR_DEACTIVATED = 17801;
	public static final int SAILING_BT_GWENITH_GLIDE_CRYSTAL_TRAHAEARN_DEACTIVATED = 17802;
	public static final int SAILING_BT_TEMPOR_TANTRUM_MASTER_STATE = 17803;
	public static final int SAILING_BT_TEMPOR_TANTRUM_PREVIOUS_ATTEMPT = 17804;
	public static final int SAILING_BT_TEMPOR_TANTRUM_SWORDFISH_FIRST = 17805;
	public static final int SAILING_BT_TEMPOR_TANTRUM_SHARK_FIRST = 17806;
	public static final int SAILING_BT_TEMPOR_TANTRUM_MARLIN_FIRST = 17807;
	public static final int SAILING_BT_JUBBLY_JIVE_MASTER_STATE = 17808;
	public static final int SAILING_BT_JUBBLY_JIVE_PREVIOUS_ATTEMPT = 17809;
	public static final int SAILING_BT_JUBBLY_JIVE_SWORDFISH_FIRST = 17810;
	public static final int SAILING_BT_JUBBLY_JIVE_SHARK_FIRST = 17811;
	public static final int SAILING_BT_JUBBLY_JIVE_MARLIN_FIRST = 17812;
	public static final int SAILING_BT_GWENITH_GLIDE_MASTER_STATE = 17813;
	public static final int SAILING_BT_GWENITH_GLIDE_PREVIOUS_ATTEMPT = 17814;
	public static final int SAILING_BT_GWENITH_GLIDE_SWORDFISH_FIRST = 17815;
	public static final int SAILING_BT_GWENITH_GLIDE_SHARK_FIRST = 17816;
	public static final int SAILING_BT_GWENITH_GLIDE_MARLIN_FIRST = 17817;
	public static final int SAILING_BT_GWENITH_GLIDE_COLOURFUL_FADE_PROMPT_DISABLED = 17818;
	public static final int SAILING_BT_OBJECTIVE0 = 17819;
	public static final int SAILING_BT_OBJECTIVE1 = 17820;
	public static final int SAILING_BT_OBJECTIVE2 = 17821;
	public static final int SAILING_BT_OBJECTIVE3 = 17822;
	public static final int SAILING_BT_OBJECTIVE4 = 17823;
	public static final int SAILING_BT_OBJECTIVE5 = 17824;
	public static final int SAILING_BT_OBJECTIVE6 = 17825;
	public static final int SAILING_BT_OBJECTIVE7 = 17826;
	public static final int SAILING_BT_OBJECTIVE8 = 17827;
	public static final int SAILING_BT_OBJECTIVE9 = 17828;
	public static final int SAILING_BT_OBJECTIVE10 = 17829;
	public static final int SAILING_BT_OBJECTIVE11 = 17830;
	public static final int SAILING_BT_OBJECTIVE12 = 17831;
	public static final int SAILING_BT_OBJECTIVE13 = 17832;
	public static final int SAILING_BT_OBJECTIVE14 = 17833;
	public static final int SAILING_BT_OBJECTIVE15 = 17834;
	public static final int SAILING_BT_OBJECTIVE16 = 17835;
	public static final int SAILING_BT_OBJECTIVE17 = 17836;
	public static final int SAILING_BT_OBJECTIVE18 = 17837;
	public static final int SAILING_BT_OBJECTIVE19 = 17838;
	public static final int SAILING_BT_OBJECTIVE20 = 17839;
	public static final int SAILING_BT_OBJECTIVE21 = 17840;
	public static final int SAILING_BT_OBJECTIVE22 = 17841;
	public static final int SAILING_BT_OBJECTIVE23 = 17842;
	public static final int SAILING_BT_OBJECTIVE24 = 17843;
	public static final int SAILING_BT_OBJECTIVE25 = 17844;
	public static final int SAILING_BT_OBJECTIVE26 = 17845;
	public static final int SAILING_BT_OBJECTIVE27 = 17846;
	public static final int SAILING_BT_OBJECTIVE28 = 17847;
	public static final int SAILING_BT_OBJECTIVE29 = 17848;
	public static final int SAILING_BT_OBJECTIVE30 = 17849;
	public static final int SAILING_BT_OBJECTIVE31 = 17850;
	public static final int SAILING_BT_OBJECTIVE32 = 17851;
	public static final int SAILING_BT_OBJECTIVE33 = 17852;
	public static final int SAILING_BT_OBJECTIVE34 = 17853;
	public static final int SAILING_BT_OBJECTIVE35 = 17854;
	public static final int SAILING_BT_OBJECTIVE36 = 17855;
	public static final int SAILING_BT_OBJECTIVE37 = 17856;
	public static final int SAILING_BT_OBJECTIVE38 = 17857;
	public static final int SAILING_BT_OBJECTIVE39 = 17858;
	public static final int SAILING_BT_OBJECTIVE40 = 17859;
	public static final int SAILING_BT_OBJECTIVE41 = 17860;
	public static final int SAILING_BT_OBJECTIVE42 = 17861;
	public static final int SAILING_BT_OBJECTIVE43 = 17862;
	public static final int SAILING_BT_OBJECTIVE44 = 17863;
	public static final int SAILING_BT_OBJECTIVE45 = 17864;
	public static final int SAILING_BT_OBJECTIVE46 = 17865;
	public static final int SAILING_BT_OBJECTIVE47 = 17866;
	public static final int SAILING_BT_OBJECTIVE48 = 17867;
	public static final int SAILING_BT_OBJECTIVE49 = 17868;
	public static final int SAILING_BT_OBJECTIVE50 = 17869;
	public static final int SAILING_BT_OBJECTIVE51 = 17870;
	public static final int SAILING_BT_OBJECTIVE52 = 17871;
	public static final int SAILING_BT_OBJECTIVE53 = 17872;
	public static final int SAILING_BT_OBJECTIVE54 = 17873;
	public static final int SAILING_BT_OBJECTIVE55 = 17874;
	public static final int SAILING_BT_TEMPOR_TANTRUM_PB_SWORDFISH = 17875;
	public static final int SAILING_BT_TEMPOR_TANTRUM_PB_SHARK = 17876;
	public static final int SAILING_BT_TEMPOR_TANTRUM_PB_MARLIN = 17877;
	public static final int SAILING_BT_JUBBLY_JIVE_PB_SWORDFISH = 17878;
	public static final int SAILING_BT_JUBBLY_JIVE_PB_SHARK = 17879;
	public static final int SAILING_BT_JUBBLY_JIVE_PB_MARLIN = 17880;
	public static final int SAILING_BT_GWENITH_GLIDE_PB_SWORDFISH = 17881;
	public static final int SAILING_BT_GWENITH_GLIDE_PB_SHARK = 17882;
	public static final int SAILING_BT_GWENITH_GLIDE_PB_MARLIN = 17883;
	public static final int SAILING_CHARTING_FULL_COMPLETION = 17884;
	public static final int SAILING_CHARTING_FULL_COMPLETION_EVER_COMPLETE = 17885;
	public static final int SAILING_LOG_TAB_OPENED = 17886;
	public static final int SAILING_CHARTING_GENERIC_BOARD_PORT_SARIM_COMPLETE = 17887;
	public static final int SAILING_CHARTING_GENERIC_SALVAGE_STATION_PORT_SARIM_COMPLETE = 17888;
	public static final int SAILING_CHARTING_SPYGLASS_WIZARDS_TOWER_COMPLETE = 17889;
	public static final int SAILING_CHARTING_CURRENT_DUCK_FAIRY_RING_COMPLETE = 17890;
	public static final int SAILING_CHARTING_GENERIC_ROCK_BAY_OF_SARIM_COMPLETE = 17891;
	public static final int SAILING_CHARTING_GENERIC_ROWBOAT_BAY_OF_SARIM_COMPLETE = 17892;
	public static final int SAILING_CHARTING_GENERIC_CRUNCH_POSTER_COMPLETE = 17893;
	public static final int SAILING_CHARTING_GENERIC_GLIDER_KHARIDIAN_SEA_COMPLETE = 17894;
	public static final int SAILING_CHARTING_GENERIC_ROWBOAT_MUDSKIPPER_SOUND_COMPLETE = 17895;
	public static final int SAILING_CHARTING_CURRENT_DUCK_MUSA_POINT_COMPLETE = 17896;
	public static final int SAILING_CHARTING_SPYGLASS_SHIPYARD_COMPLETE = 17897;
	public static final int SAILING_CHARTING_DRINK_CRATE_PRYING_TIMES_COMPLETE = 17898;
	public static final int SAILING_CHARTING_MERMAID_GUIDE_KHARIDIAN_SEA_COMPLETE = 17899;
	public static final int SAILING_CHARTING_CURRENT_DUCK_KHARIDIAN_SEA_COMPLETE = 17900;
	public static final int SAILING_CHARTING_SPYGLASS_THE_PANDEMONIUM_COMPLETE = 17901;
	public static final int SAILING_CHARTING_GENERIC_PANDEMONIUM_2_COMPLETE = 17902;
	public static final int SAILING_CHARTING_GENERIC_PANDEMONIUM_3_COMPLETE = 17903;
	public static final int SAILING_CHARTING_GENERIC_CORPSE_LUMBRIDGE_BASIN_COMPLETE = 17904;
	public static final int SAILING_CHARTING_GENERIC_ROCK_LUMBRIDGE_BASIN_COMPLETE = 17905;
	public static final int SAILING_CHARTING_SPYGLASS_LUMBRIDGE_MINE_COMPLETE = 17906;
	public static final int SAILING_CHARTING_CURRENT_DUCK_LUMBRIDGE_BASIN_COMPLETE = 17907;
	public static final int SAILING_CHARTING_GENERIC_ROCK_RIMMINGTON_STRAIT_COMPLETE = 17908;
	public static final int SAILING_CHARTING_GENERIC_DRAGON_STATUE_RIMMINGTON_STRAIT_COMPLETE = 17909;
	public static final int SAILING_CHARTING_SPYGLASS_KARAMJA_VOLCANO_COMPLETE = 17910;
	public static final int SAILING_CHARTING_CURRENT_DUCK_RIMMINGTON_STRAIT_COMPLETE = 17911;
	public static final int SAILING_CHARTING_GENERIC_THORNS_CATHERBY_BAY_COMPLETE = 17912;
	public static final int SAILING_CHARTING_GENERIC_MEGASHRIMP_CATHERBY_BAY_COMPLETE = 17913;
	public static final int SAILING_CHARTING_SPYGLASS_KEEP_LE_FAYE_COMPLETE = 17914;
	public static final int SAILING_CHARTING_CURRENT_DUCK_CATHERBY_BAY_COMPLETE = 17915;
	public static final int SAILING_SEA_ARDENT_OCEAN_CHARTING_COMPLETE = 17916;
	public static final int SAILING_SEA_BAY_OF_SARIM_CHARTING_COMPLETE = 17917;
	public static final int SAILING_SEA_KHARIDIAN_SEA_CHARTING_COMPLETE = 17918;
	public static final int SAILING_SEA_LUMBRIDGE_BASIN_CHARTING_COMPLETE = 17919;
	public static final int SAILING_SEA_MUDSKIPPER_SOUND_CHARTING_COMPLETE = 17920;
	public static final int SAILING_SEA_RIMMINGTON_STRAIT_CHARTING_COMPLETE = 17921;
	public static final int SAILING_SEA_ARDENT_OCEAN_CHARTING_EVER_COMPLETE = 17922;
	public static final int SAILING_SEA_BAY_OF_SARIM_CHARTING_EVER_COMPLETE = 17923;
	public static final int SAILING_SEA_KHARIDIAN_SEA_CHARTING_EVER_COMPLETE = 17924;
	public static final int SAILING_SEA_LUMBRIDGE_BASIN_CHARTING_EVER_COMPLETE = 17925;
	public static final int SAILING_SEA_MUDSKIPPER_SOUND_CHARTING_EVER_COMPLETE = 17926;
	public static final int SAILING_SEA_RIMMINGTON_STRAIT_CHARTING_EVER_COMPLETE = 17927;
	public static final int PLAYER_DIVING = 17928;
	public static final int SAILING_CREW_SLOT_1 = 17938;
	public static final int SAILING_CREW_SLOT_2 = 17939;
	public static final int SAILING_CREW_SLOT_3 = 17940;
	public static final int SAILING_CREW_SLOT_4 = 17941;
	public static final int SAILING_CREW_SLOT_5 = 17942;
	public static final int SAILING_CREW_HELD_CARGO_0_AMOUNT = 17943;
	public static final int SAILING_CREW_HELD_CARGO_1_AMOUNT = 17944;
	public static final int SAILING_CREW_HELD_CARGO_2_AMOUNT = 17945;
	public static final int SAILING_CREW_HELD_CARGO_3_AMOUNT = 17946;
	public static final int SAILING_CREW_HELD_CARGO_4_AMOUNT = 17947;
	public static final int SAILING_CREW_SLOT_1_POSITION = 17948;
	public static final int SAILING_CREW_SLOT_2_POSITION = 17949;
	public static final int SAILING_CREW_SLOT_3_POSITION = 17950;
	public static final int SAILING_CREW_SLOT_4_POSITION = 17951;
	public static final int SAILING_CREW_SLOT_5_POSITION = 17952;
	public static final int SAILING_CREW_FOLLOW_TARGET_DISABLED = 17953;
	public static final int SAILING_CREW_GENERIC_1_UNLOCKED = 17954;
	public static final int SAILING_CREW_GENERIC_2_UNLOCKED = 17955;
	public static final int SAILING_CREW_GENERIC_3_UNLOCKED = 17956;
	public static final int SAILING_CREW_GENERIC_4_UNLOCKED = 17957;
	public static final int SAILING_CREW_GENERIC_5_UNLOCKED = 17958;
	public static final int SAILING_CREW_WEREWOLF_UNLOCKED = 17959;
	public static final int SAILING_CREW_FREMENNIK_UNLOCKED = 17960;
	public static final int SAILING_CREW_SPIRIT_ANGLER_UNLOCKED = 17961;
	public static final int SAILING_CREW_CAPTAIN_SIAD_UNLOCKED = 17962;
	public static final int SAILING_CREW_GHOST_JENKINS_UNLOCKED = 17963;
	public static final int SAILING_CREW_GENERIC_1_VISIBILITY = 17964;
	public static final int SAILING_CREW_GENERIC_2_VISIBILITY = 17965;
	public static final int SAILING_CREW_GENERIC_3_VISIBILITY = 17966;
	public static final int SAILING_CREW_GENERIC_4_VISIBILITY = 17967;
	public static final int SAILING_CREW_GENERIC_5_VISIBILITY = 17968;
	public static final int SAILING_CREW_WEREWOLF_VISIBILITY = 17969;
	public static final int SAILING_CREW_FREMENNIK_VISIBILITY = 17970;
	public static final int SAILING_CREW_SPIRIT_ANGLER_VISIBILITY = 17971;
	public static final int SAILING_CREW_CAPTAIN_SIAD_VISIBILITY = 17972;
	public static final int SAILING_CREW_GHOST_JENKINS_VISIBILITY = 17973;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_COMPLETEPORTTASKS = 17974;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_COLLECTSALVAGE = 17975;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_IDENTIFYSALVAGE = 17976;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_TUTORIALCOMPLETE = 17977;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_CHARTPOINTS = 17978;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_BARRACUDASWORDFISH = 17979;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_BARRACUDASHARK = 17980;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_BARRACUDAMARLIN = 17981;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_BARRACUDAFIRST = 17982;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_OPENCHARTLOG = 17983;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_CHARTCURRENTDUCK = 17984;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_CHARTSPYGLASS = 17985;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_CHARTMERMAID = 17986;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_CHARTWEATHER = 17987;
	public static final int SAILING_ALPHA_RUNEFEST_PORT_TASK_COUNT = 17988;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_CHARTDRINKCRATE = 17989;
	public static final int SAILING_ALPHA_RUNEFEST_DISCLAIMER_UNDERSTOOD = 17990;
	public static final int SAILING_ALPHA_RUNEFEST_ICON_GLOW = 17991;
	public static final int SAILING_ALPHA_SETUP_RUN = 17992;
	public static final int SAILING_ALPHA_LOGIN_STEP = 17993;
	public static final int SAILING_CAPTCHA_ACCEPTED = 17994;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_PRYINGTIMES = 17995;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_DOGNOSE = 17996;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_ISLEOFBONES = 17997;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_LASTLIGHT = 17998;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_CHARREDISLAND = 17999;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_OAKHULL = 18000;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_OAKMAST = 18001;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_BRONZESALVAGEHOOK = 18002;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_WINDCATCHER = 18003;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_BUYBOAT = 18004;
	public static final int SAILING_ALPHA_RUNEFEST_IF_OPENED = 18005;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_RECRUITCREWMATE = 18006;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_EDITCREW = 18007;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_ASSIGNCREW = 18008;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_BUILDCANNON = 18009;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_KILLSHARK = 18010;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_BOUNTYTASK = 18011;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_CREWDEPOSITCARGO = 18012;
	public static final int SAILING_ALPHA_RUNEFEST_TASK_CREWCANNON = 18013;
	public static final int DRAGON_ISLAND_DUNGEON_ENTRANCE_ROPED = 18016;
	public static final int PORT_TASK_SLOT_0_ID = 18017;
	public static final int PORT_TASK_SLOT_0_CARGO_TAKEN = 18018;
	public static final int PORT_TASK_SLOT_0_CARGO_DELIVERED = 18019;
	public static final int PORT_TASK_SLOT_1_ID = 18020;
	public static final int PORT_TASK_SLOT_1_CARGO_TAKEN = 18021;
	public static final int PORT_TASK_SLOT_1_CARGO_DELIVERED = 18022;
	public static final int PORT_TASK_SLOT_2_ID = 18023;
	public static final int PORT_TASK_SLOT_2_CARGO_TAKEN = 18024;
	public static final int PORT_TASK_SLOT_2_CARGO_DELIVERED = 18025;
	public static final int PORT_TASK_SLOT_3_ID = 18026;
	public static final int PORT_TASK_SLOT_3_CARGO_TAKEN = 18027;
	public static final int PORT_TASK_SLOT_3_CARGO_DELIVERED = 18028;
	public static final int PORT_TASK_SLOT_4_ID = 18029;
	public static final int PORT_TASK_SLOT_4_CARGO_TAKEN = 18030;
	public static final int PORT_TASK_SLOT_4_CARGO_DELIVERED = 18031;
	public static final int PORT_TASK_EXTRA_SLOTS_UNLOCKED = 18032;
	public static final int PORT_TASK_LAST_CARGO_TAKEN = 18033;
	public static final int PORT_TASK_LOADING_BAY_WARNING_DISMISSED = 18034;
	public static final int BLAST_FURNACE_LEAD_ORE = 18036;
	public static final int BLAST_FURNACE_NICKEL_ORE = 18037;
	public static final int BLAST_FURNACE_LEAD_BARS = 18038;
	public static final int BLAST_FURNACE_CUPRONICKEL_BARS = 18039;
}
/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks.gameval;

	public enum LedgerID
	{
		MUSA_POINT(58213, "Musa Point"),
		PORT_SARIM(58212, "Port Sarim"),
		PANDEMONIUM(58214, "The Pandemonium"),
		CATHERBY(58215, "Catherby"),
		ENTRANA(58216, "Entrana"),
		ARDOUGNE(58217, "Ardougne"),
		BRIMHAVEN(58218, "Brimhaven"),
		PORT_KHAZARD(58219, "Port Khazard"),
		CORSAIR_COVE(58220, "Corsair Cove"),
		RUINS_OF_UNKAH(58221, "Ruins of Unkah"),
		PORT_PISCARILIUS(58222, "Port Piscarilius"),
		CIVITAS_ILLA_FORTIS(58223, "Civitas illa Fortis"),
		RELLEKKA(58224, "Rellekka"),
		LANDS_END(58225, "Land's End"),
		HOSIDIUS(58226, "Hosidius"),
		CAIRN_ISLE(58227, "Cairn Isle"),
		SUNSET_COAST(58228, "Sunset Coast"),
		THE_SUMMER_SHORE(58229, "Summer Shore"),
		ALDARIN(58230, "Aldarin"),
		VOID_KNIGHTS_OUTPOST(58231, "Void Knights' Outpost"),
		PORT_ROBERTS(58232, "Port Roberts"),
		RED_ROCK(58233, "Red Rock"),
		BARRACUDA_HQ(58234, "Barracuda HQ"),
		ETCETERIA(58235, "Etceteria"),
		PORT_TYRAS(58236, "Port Tyras"),
		DEEPFIN_POINT(58237, "Deepfin Point"),
		PRIFDDINAS(58238, "Prifddinas"),
		PISCATORIS(58239, "Piscatoris"),
		LUNAR_ISLE(58240, "Lunar Isle");

	private final int objectId;
	private final String name;

	LedgerID(int objectId, String name)
	{
		this.objectId = objectId;
		this.name = name;
	}

	public static Integer getObjectIdByName(String name)
	{
		for (LedgerID ledger : values())
		{
			if (ledger.name.equalsIgnoreCase(name))
			{
				return ledger.objectId;
			}
		}
		return null;
	}

	public static boolean containsName(String name)
	{
		for (LedgerID ledger : values())
		{
			if (ledger.name.equalsIgnoreCase(name))
			{
				return true;
			}
		}
		return false;
	}
}

/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks;

import com.google.gson.Gson;
import com.google.inject.Provides;
import javax.inject.Inject;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import com.nucleon.porttasks.enums.PortTaskData;
import com.nucleon.porttasks.enums.PortTaskTrigger;
import com.nucleon.porttasks.ui.PortTasksPluginPanel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.WorldType;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;

import java.util.List;

@Slf4j
@PluginDescriptor(
	name = "Port Tasks"
)
public class PortTasksPlugin extends Plugin
{
	@Inject
	private PortTasksDelegate delegate;
	@Inject
	private Client client;
	@Inject
	private PortTasksConfig config;
	@Inject
	private OverlayManager overlayManager;
	@Inject
	private ClientToolbar clientToolbar;
	@Inject
	private ConfigManager configManager;
	@Inject
	private Gson gson;
	@Getter
	@Inject
	private ColorPickerManager colorPickerManager;
	@Inject
	private PortTasksMapOverlay sailingHelperMapOverlay;
	@Inject
	private PortTasksWorldOverlay sailingHelperWorldOverlay;
	@Inject
	private PortTasksMiniMapOverlay sailingHelperMiniMapOverlay;
	@Inject
	private PortTasksLedgerOverlay portTasksLedgerOverlay;
	@Getter
	List<PortTask> currentTasks = new ArrayList<>();

	private int[] varPlayers;
	private PortTasksPluginPanel pluginPanel;
	private NavigationButton navigationButton;
	private static final String PLUGIN_NAME = "Port Tasks";
	private static final String ICON_FILE = "icon.png";
	public static final String CONFIG_GROUP = "porttasks";
	private static final String CONFIG_KEY = "porttaskslots";
	private boolean pluginStarted = false;

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		if (event.getGameState() != GameState.LOGGED_IN || client == null)
		{
			return;
		}

		if (event.getGameState() == GameState.LOGGED_IN)
		{
			delegate.isLoggedIn = true;
		}

		boolean isBetaWorld = client.getWorldType().contains(WorldType.BETA_WORLD);

		if (isBetaWorld && !pluginStarted)
		{
			log.info("Starting plugin Port Tasks");
			pluginStarted = true; // this flag is needed, otherwise the load lines trigger a startup
			pluginPanel = new PortTasksPluginPanel(this, config);

			final BufferedImage icon = ImageUtil.loadImageResource(getClass(), ICON_FILE);
			navigationButton = NavigationButton.builder()
					.tooltip(PLUGIN_NAME)
					.icon(icon)
					.priority(5)
					.panel(pluginPanel)
					.build();

			clientToolbar.addNavigation(navigationButton);
			registerOverlays();
			pluginPanel.rebuild();
		}

		if (event.getGameState() == GameState.LOGIN_SCREEN && pluginStarted)
		{
			shutDown();
		}
	}

	@Override
	protected void shutDown()
	{
		log.info("Stopping Port Tasks");
		clientToolbar.removeNavigation(navigationButton);
		pluginPanel = null;
		navigationButton = null;
		pluginStarted = false;
		overlayManager.remove(sailingHelperWorldOverlay);
		overlayManager.remove(sailingHelperMapOverlay);
		overlayManager.remove(portTasksLedgerOverlay);
	}

	@Subscribe
	public void onConfigChanged(final ConfigChanged event)
	{
		if (!event.getGroup().equals(PortTasksConfig.CONFIG_GROUP))
			return;
		if (event.getKey().equals("drawOverlay"))
		{
			overlayManager.remove(sailingHelperWorldOverlay);
			overlayManager.remove(sailingHelperMapOverlay);
			overlayManager.remove(portTasksLedgerOverlay);
			registerOverlays();
		}
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event)
	{
		if (PortTaskTrigger.contains(event.getVarbitId()))
		{
			PortTaskTrigger varbit = PortTaskTrigger.fromId(event.getVarbitId());
			int value = client.getVarbitValue(varbit.getId());
			handlePortTaskTrigger(varbit, value);
		}
	}

	@Provides
	PortTasksConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(PortTasksConfig.class);
	}

	private void handlePortTaskTrigger(PortTaskTrigger trigger, int value)
	{
		if (trigger.getType() == PortTaskTrigger.TaskType.ID)
		{
			log.debug("Changed: {} (value {})", trigger, value);
			PortTaskData data = PortTaskData.fromId(value);
			if (data != null && value != 0)
			{
				currentTasks.add(new PortTask(data, trigger.getSlot(), false, 0, true, true, config.getNavColor(), 0));
				pluginPanel.rebuild();
			}
			if (value == 0)
			{
				currentTasks.removeIf(task -> task.getSlot() == trigger.getSlot());
				pluginPanel.rebuild();
			}
		}

		if (trigger.getType() == PortTaskTrigger.TaskType.TAKEN)
		{
			int slot = trigger.getSlot();

			for (PortTask task : currentTasks)
			{
				if (task.getSlot() == slot)
				{
					task.setCargoTaken(value);
					break;
				}
			}
			pluginPanel.rebuild();
		}

		if (trigger.getType() == PortTaskTrigger.TaskType.DELIVERED)
		{
			int slot = trigger.getSlot();

			for (PortTask task : currentTasks)
			{
				if (task.getSlot() == slot)
				{
					task.setDelivered(value);
					break;
				}
			}
			pluginPanel.rebuild();
		}
	}

	public void readPortDataFromClientVarps()
	{
		assert client.getVarps() != null : "client.getVarps() is null";
		varPlayers = client.getVarps().clone();

		for (PortTaskTrigger varbit : PortTaskTrigger.values())
		{
			if (varbit.getType() == PortTaskTrigger.TaskType.ID)
			{
				int value = client.getVarbitValue(varPlayers, varbit.getId());
				if (value != 0 && currentTasks.stream().noneMatch(task -> task.getSlot() == varbit.getSlot()))
				{
					PortTaskData data = PortTaskData.fromId(value);
					currentTasks.add(new PortTask(data, varbit.getSlot(), false, 0, true, true, config.getNavColor(), 0));
					pluginPanel.rebuild();
				}
				else
				{
					currentTasks.removeIf(task -> task.getSlot() == varbit.getSlot());
					pluginPanel.rebuild();
				}
			}
		}
	}

	private void registerOverlays()
	{
		if (config.getDrawOverlay() == PortTasksConfig.Overlay.BOTH || config.getDrawOverlay() == PortTasksConfig.Overlay.MAP)
		{
			overlayManager.add(sailingHelperMapOverlay);
		}

		if (config.getDrawOverlay() == PortTasksConfig.Overlay.BOTH || config.getDrawOverlay() == PortTasksConfig.Overlay.WORLD)
		{
			overlayManager.add(sailingHelperWorldOverlay);
		}
		overlayManager.add(portTasksLedgerOverlay);
	}

	public void saveSlotSettings()
	{
		if (currentTasks == null || currentTasks.isEmpty())
		{
			configManager.unsetConfiguration(CONFIG_GROUP, CONFIG_KEY);
			return;
		}
		String json = gson.toJson(currentTasks);
		configManager.setConfiguration(CONFIG_GROUP, CONFIG_KEY, json);
	}
}

/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks;


public final class RelativeMove
{
	private final int dx;
	private final int dy;

	public RelativeMove(int dx, int dy)
	{
		this.dx = dx;
		this.dy = dy;
	}

	public int getDx()
	{
		return dx;
	}

	public int getDy()
	{
		return dy;
	}

	@Override
	public String toString()
	{
		return String.format("(%+d, %+d)", dx, dy);
	}

	@Override
	public boolean equals(Object obj)
	{
		if (this == obj) return true;
		if (obj == null || getClass() != obj.getClass()) return false;
		RelativeMove other = (RelativeMove) obj;
		return dx == other.dx && dy == other.dy;
	}

	@Override
	public int hashCode()
	{
		int result = Integer.hashCode(dx);
		result = 31 * result + Integer.hashCode(dy);
		return result;
	}
}

/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks.enums;

import net.runelite.api.coords.WorldPoint;

public enum PortLocation
{
	MUSA_POINT("Musa Point", new WorldPoint(2961, 3146, 0), new WorldPoint(3952, 3150, 0), new WorldPoint(2965, 3146, 0)),
	PORT_SARIM("Port Sarim", new WorldPoint(3051, 3193, 0), new WorldPoint(3030, 3198, 0), new WorldPoint(3056, 3194, 0)),
	PANDEMONIUM("The Pandemonium", new WorldPoint(3070, 2987, 0), new WorldPoint(3058, 2986, 0), new WorldPoint(3078, 2987, 0)),
	ENTRANA("Entrana", new WorldPoint(2879, 3335, 0), new WorldPoint(2874, 3339, 0), new WorldPoint(2883, 3336, 0)),
	RUINS_OF_UNKAH("Ruins of Unkah", new WorldPoint(0, 0, 0), new WorldPoint(3144, 2825, 0), new WorldPoint(3143, 2824, 0)),
	RED_ROCK("Red Rock", new WorldPoint(2809, 2509, 0), new WorldPoint(2805, 2512, 0)),
	ARDOUGNE("Ardougne", new WorldPoint(2683, 3265, 0), new WorldPoint(2674, 3269, 0), new WorldPoint(2670, 3259, 0)),
	BRIMHAVEN("Brimhaven", new WorldPoint(2758, 3230, 0), new WorldPoint(2768, 3225, 0), new WorldPoint(2754, 3231, 0)),
	CATHERBY("Catherby", new WorldPoint(2796, 3412, 0), new WorldPoint(2799, 3413, 0), new WorldPoint(2796, 3408, 0)),
	PORT_KHAZARD("Port Khazard", new WorldPoint(2686, 3162, 0), new WorldPoint(2678, 3162, 0), new WorldPoint(2688, 3162, 0)),
	SHILO_VILLAGE("Shilo Village", new WorldPoint(2750, 2952, 0), new WorldPoint(2756, 2949, 0)),
	CORSAIR_COVE("Corsair Cove", new WorldPoint(2580, 2844, 0), new WorldPoint(2580, 2848, 0), new WorldPoint(2586, 2844, 0)),
	BARRACUDA_HQ("Barracuda HQ", new WorldPoint(2294, 2520, 0), new WorldPoint(2289, 2530, 0)),
	DEEPFIN_POINT("Deepfin Point", new WorldPoint(1932, 2791, 0), new WorldPoint(1926, 2791, 0)),
	SUNSET_COAST("Sunset Coast", new WorldPoint(1511, 2975, 0), new WorldPoint(1514, 2977, 0)),
	ALDARIN("Aldarin", new WorldPoint(1452, 2970, 0), new WorldPoint(1448, 2969, 0)),
	SUMMER_SHORE("Summer Shore", new WorldPoint(0, 0, 0), new WorldPoint(3172, 2370, 0), new WorldPoint(3174, 2367, 0)),
	VOID_KNIGHT("Void Knights' Outpost", new WorldPoint(2651, 2678, 0), new WorldPoint(2651, 2673, 0)),
	PORT_TYRAS("Port Tyras", new WorldPoint(2144, 3120, 0), new WorldPoint(2150, 3123, 0)),
	PORT_ROBERTS("Port Roberts", new WorldPoint(1871, 3300, 0), new WorldPoint(1863, 3297, 0)),
	LANDS_END("Land's End", new WorldPoint(1506, 3402, 0), new WorldPoint(1505, 3407, 0)),
	HOSIDIUS("Hosidius", new WorldPoint(1726, 3452, 0), new WorldPoint(1724, 3461, 0)),
	CIVITAS_ILLA_FORTIS("Civitas illa Fortis", new WorldPoint(1775, 3142, 0), new WorldPoint(1780, 3147, 0)),
	EMPTY("Default", new WorldPoint(0, 0, 0), new WorldPoint(0, 0, 0));

	private final String name;
	private final WorldPoint worldPoint;
	private final WorldPoint cargoLocation;
	private final WorldPoint navigationLocation;

	// temp constructor until navigation location is added for all ports
	PortLocation(String name, WorldPoint worldPoint, WorldPoint cargoLocation)
	{
		this(name, worldPoint, cargoLocation, null);
	}
	PortLocation(String name, WorldPoint worldPoint, WorldPoint cargoLocation, WorldPoint navigationLocation)
	{
		this.name = name;
		this.worldPoint = worldPoint;
		this.cargoLocation = cargoLocation;
		this.navigationLocation = navigationLocation;
	}
	public String getName()
	{
		return name;
	}

	public WorldPoint getWorldPoint()
	{
		return worldPoint;
	}

	public WorldPoint getCargoLocation()
	{
		return cargoLocation;
	}

	public WorldPoint getNavigationLocation()
	{
		return navigationLocation;
	}

}
/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks.enums;

// todo: replace with net.runelite.api.gameval.ItemID when released
import com.nucleon.porttasks.gameval.ItemID;

public enum PortTaskData
{
	COURIER_WANTED(1, PortLocation.PORT_SARIM, PortLocation.PORT_SARIM, PortLocation.PANDEMONIUM, PortPaths.PORT_SARIM_PANDEMONIUM, false, "Courier wanted", ItemID.CARGO_CRATE_OF_STEEL_SWORDS.getId(), 1),
	LONELY_CRATE_LOOKING_FOR_LOCAL_COURIER(2, PortLocation.PORT_SARIM, PortLocation.PORT_SARIM, PortLocation.MUSA_POINT, PortPaths.MUSA_POINT_PORT_SARIM, true, "Lonely crate looking for local courier", ItemID.CARGO_CRATE_OF_RAW_FISH.getId(), 1),
	BANANA_DELIVERY(3, PortLocation.PORT_SARIM, PortLocation.MUSA_POINT, PortLocation.PORT_SARIM, PortPaths.MUSA_POINT_PORT_SARIM, false, "Banana delivery", ItemID.CARGO_CRATE_OF_BANANAS.getId(), 1),
	BANANA_COMPENSATION(4, PortLocation.PORT_SARIM, PortLocation.PORT_SARIM, PortLocation.MUSA_POINT, PortPaths.MUSA_POINT_PORT_SARIM, true, "Banana compensation", ItemID.CARGO_CRATE_OF_ROTTEN_BANANAS.getId(), 1),
	A_BARTENDERS_PROBLEM(5, PortLocation.PORT_SARIM, PortLocation.PORT_SARIM, PortLocation.PANDEMONIUM, PortPaths.PORT_SARIM_PANDEMONIUM, false, "A bartender's problem", ItemID.CARGO_CRATE_OF_BEER.getId(), 3),
	LOGS_ASTRAY(6, PortLocation.PORT_SARIM, PortLocation.MUSA_POINT, PortLocation.PORT_SARIM, PortPaths.MUSA_POINT_PORT_SARIM, false, "Logs astray", ItemID.CARGO_CRATE_OF_LOGS.getId(), 2),
	RUM_RUN(7, PortLocation.PORT_SARIM, PortLocation.PORT_SARIM, PortLocation.MUSA_POINT, PortPaths.MUSA_POINT_PORT_SARIM, true, "Rum run", ItemID.CARGO_CRATE_OF_RUM.getId(), 1),
	LEGAL_COURIER_SERVICES_REQUESTED(8, PortLocation.PORT_SARIM, PortLocation.MUSA_POINT, PortLocation.PORT_SARIM, PortPaths.MUSA_POINT_PORT_SARIM, false, "Legal' courier services requested", ItemID.CARGO_CRATE_OF_SMUGGLED_RUM.getId(), 1),
	KEG_REMOVAL_SERVICES_REQUIRED(9, PortLocation.PORT_SARIM, PortLocation.PANDEMONIUM, PortLocation.PORT_SARIM, PortPaths.PORT_SARIM_PANDEMONIUM, true, "Keg removal services required", ItemID.CARGO_CRATE_OF_KEGS.getId(), 2),
	BAIT_TO_CATHERBY(10, PortLocation.PORT_SARIM, PortLocation.PORT_SARIM, PortLocation.CATHERBY, PortPaths.CATHERBY_PORT_SARIM, true, "Bait to catherby", ItemID.CARGO_CRATE_OF_BAIT.getId(), 2),
	SARAHS_POTATOES(11, PortLocation.PORT_SARIM, PortLocation.PORT_SARIM, PortLocation.CATHERBY, PortPaths.CATHERBY_PORT_SARIM, true, "Sarah's potatoes", ItemID.CARGO_CRATE_OF_POTATOES.getId(), 3),
	A_MISLAID_PORT_ORDER(12, PortLocation.PORT_SARIM, PortLocation.CATHERBY, PortLocation.BRIMHAVEN, PortPaths.CATHERBY_BRIMHAVEN, false, "A mislaid port order", ItemID.CARGO_CRATE_OF_COMPOST.getId(), 4),
	SALAMANDER_PROTECTION(13, PortLocation.PORT_SARIM, PortLocation.PORT_SARIM, PortLocation.ARDOUGNE, PortPaths.PORT_SARIM_ARDOUGNE, false, "Salamander protection", ItemID.CARGO_CRATE_OF_RED_SALAMANDERS.getId(), 2),
	TAR_EXPORT_REQUIRED(14, PortLocation.PORT_SARIM, PortLocation.PORT_SARIM, PortLocation.PORT_KHAZARD, PortPaths.PORT_KHAZARD_PORT_SARIM, true, "Tar export required", ItemID.CARGO_CRATE_OF_SWAMP_PASTE.getId(), 3),
	SWORD_IDENTIFICATION(15, PortLocation.PORT_SARIM, PortLocation.PORT_KHAZARD, PortLocation.PORT_SARIM, PortPaths.PORT_KHAZARD_PORT_SARIM, false, "Sword identification", ItemID.CARGO_CRATE_OF_IDENTIFIED_SWORDS.getId(), 4),
	ARMOUR_COURIER(16, PortLocation.PORT_SARIM, PortLocation.PORT_SARIM, PortLocation.PANDEMONIUM, PortPaths.PORT_SARIM_PANDEMONIUM, false, "Armour courier", ItemID.CARGO_CRATE_OF_MITHRIL_ARMOUR.getId(), 1),
	SPICES_NEEDED(17, PortLocation.PORT_SARIM, PortLocation.PANDEMONIUM, PortLocation.PORT_SARIM, PortPaths.PORT_SARIM_PANDEMONIUM, true, "Spices needed", ItemID.CARGO_CRATE_OF_SPICES.getId(), 1),
	FRESH_LOBSTER_DELIVERY(18, PortLocation.CATHERBY, PortLocation.CATHERBY, PortLocation.MUSA_POINT, PortPaths.CATHERBY_MUSA_POINT, false, "Fresh lobster delivery", ItemID.CARGO_CRATE_OF_LIVE_LOBSTERS.getId(), 3),
	WAX_WAX_AND_MORE_WAX(19, PortLocation.CATHERBY, PortLocation.CATHERBY, PortLocation.PANDEMONIUM, PortPaths.CATHERBY_PANDEMONIUM, false, "Wax, wax and more wax", ItemID.CARGO_CRATE_OF_WAX.getId(), 2),
	CALEBS_COCONUTS(20, PortLocation.CATHERBY, PortLocation.PANDEMONIUM, PortLocation.CATHERBY, PortPaths.CATHERBY_PANDEMONIUM, true, "Caleb's coconuts", ItemID.CARGO_CRATE_OF_COCONUTS.getId(), 2),
	VIALS_TO_THE_HOLY_ISLAND(21, PortLocation.CATHERBY, PortLocation.CATHERBY, PortLocation.ENTRANA, PortPaths.CATHERBY_ENTRANA, false, "Vials to the holy island", ItemID.CARGO_CRATE_OF_VIALS.getId(), 8),
	MISPLACED_SILK(22, PortLocation.CATHERBY, PortLocation.CATHERBY, PortLocation.ARDOUGNE, PortPaths.CATHERBY_ARDOUGNE, false, "Misplaced silk", ItemID.CARGO_CRATE_OF_SILK.getId(), 5),
	PINEAPPLE_MADNESS(23, PortLocation.CATHERBY, PortLocation.BRIMHAVEN, PortLocation.CATHERBY, PortPaths.CATHERBY_BRIMHAVEN, true, "Pineapple madness", ItemID.CARGO_CRATE_OF_PINEAPPLES.getId(), 3),
	SHRIMP_FOR_THE_SHRIMP_AND_PARROT(24, PortLocation.CATHERBY, PortLocation.CATHERBY, PortLocation.BRIMHAVEN, PortPaths.CATHERBY_BRIMHAVEN, false, "Shrimp for the shrimp and parrot", ItemID.CARGO_CRATE_OF_FRESH_FISH.getId(), 3),
	CABBAGE_CRAZY(25, PortLocation.CATHERBY, PortLocation.CATHERBY, PortLocation.ARDOUGNE, PortPaths.CATHERBY_ARDOUGNE, false, "Cabbage crazy", ItemID.CARGO_CRATE_OF_CABBAGES.getId(), 5),
	GPDT_FASTTRACK_REQUIRED(26, PortLocation.CATHERBY, PortLocation.ARDOUGNE, PortLocation.CATHERBY, PortPaths.CATHERBY_ARDOUGNE, true, "Gpdt fast-track required", ItemID.CARGO_CRATE_OF_STEEL_ARROWTIPS.getId(), 2),
	NEED_HELP_WITH_A_KARAMBWAN_DELIVERY(27, PortLocation.CATHERBY, PortLocation.BRIMHAVEN, PortLocation.CATHERBY, PortPaths.CATHERBY_BRIMHAVEN, true, "Need help with a karambwan delivery", ItemID.CARGO_CRATE_OF_RAW_KARAMBWAN.getId(), 1),
	KHAZARD_RENNOVATIONS(28, PortLocation.CATHERBY, PortLocation.CATHERBY, PortLocation.PORT_KHAZARD, PortPaths.CATHERBY_PORT_KHAZARD, false, "Khazard rennovations", ItemID.CARGO_CRATE_OF_OAK_PLANKS.getId(), 4),
	CHARTER_STOCK_REDISTRIBUTION(29, PortLocation.CATHERBY, PortLocation.PORT_KHAZARD, PortLocation.CATHERBY, PortPaths.CATHERBY_PORT_KHAZARD, true, "Charter stock redistribution", ItemID.CARGO_CRATE_OF_GLASS_MAKE_SUPPLIES.getId(), 4),
	GOT_SOME_COAL_THAT_NEEDS_EXPORTING(30, PortLocation.CATHERBY, PortLocation.CATHERBY, PortLocation.PORT_KHAZARD, PortPaths.CATHERBY_PORT_KHAZARD, false, "Got some coal that needs exporting", ItemID.CARGO_CRATE_OF_COAL.getId(), 5),
	SILVER_FOR_ARDOUGNE(31, PortLocation.CATHERBY, PortLocation.CATHERBY, PortLocation.ARDOUGNE, PortPaths.CATHERBY_ARDOUGNE, false, "Silver for ardougne", ItemID.CARGO_CRATE_OF_SILVER_JEWELLERY.getId(), 6),
	URGENT_REQUEST_FOR_THE_SPIRIT_ANGLERS_OF_UNKAH(32, PortLocation.CATHERBY, PortLocation.CATHERBY, PortLocation.RUINS_OF_UNKAH, PortPaths.CATHERBY_RUINS_OF_UNKAH, false, "Urgent request for the spirit anglers of unkah!", ItemID.CARGO_CRATE_OF_BUCKETS.getId(), 8),
	MURPHYS_CATCH_OF_THE_DAY(33, PortLocation.PORT_KHAZARD, PortLocation.PORT_KHAZARD, PortLocation.ARDOUGNE, PortPaths.ARDOUGNE_PORT_KHAZARD, true, "Murphy's catch of the day", ItemID.CARGO_CRATE_OF_TRAWLER_FISH.getId(), 6),
	GOLD_RUSH(34, PortLocation.PORT_KHAZARD, PortLocation.BRIMHAVEN, PortLocation.ARDOUGNE, PortPaths.BRIMHAVEN_ARDOUGNE, false, "Gold rush", ItemID.CARGO_CRATE_OF_GOLD_ORE.getId(), 5),
	MITHRIL_FOR_OUR_FLEET(35, PortLocation.PORT_KHAZARD, PortLocation.ARDOUGNE, PortLocation.PORT_KHAZARD, PortPaths.ARDOUGNE_PORT_KHAZARD, false, "Mithril for our fleet", ItemID.CARGO_CRATE_OF_MITHRIL_ARMOUR.getId(), 5),
	BERTS_SAND_DELIVERY(36, PortLocation.PORT_KHAZARD, PortLocation.PORT_KHAZARD, PortLocation.ENTRANA, PortPaths.PORT_KHAZARD_ENTRANA, false, "Bert's sand delivery", ItemID.CARGO_CRATE_OF_SAND.getId(), 6),
	DISCRETION_REQUIRED(37, PortLocation.PORT_KHAZARD, PortLocation.CATHERBY, PortLocation.PORT_KHAZARD, PortPaths.CATHERBY_PORT_KHAZARD, false, "Discretion required", ItemID.CARGO_CRATE_OF_SECRET_STUFF.getId(), 3),
	DRAGON_EQUIPMENT_TO_MYTHS_GUILD(38, PortLocation.PORT_KHAZARD, PortLocation.PORT_KHAZARD, PortLocation.CORSAIR_COVE, PortPaths.PORT_KHAZARD_CORSAIR_COVE, false, "Dragon equipment to myths' guild", ItemID.CARGO_CRATE_OF_DRAGON_DAGGERS.getId(), 3),
	EMERGENCY_BEER_SUPPLY_REQUEST(39, PortLocation.PORT_KHAZARD, PortLocation.MUSA_POINT, PortLocation.PORT_KHAZARD, PortPaths.MUSA_POINT_PORT_KHAZARD, false, "Emergency beer supply request", ItemID.CARGO_CRATE_OF_BEER.getId(), 5),
	SPIRIT_ANGLER_SUPPLY_ORDER(40, PortLocation.PORT_KHAZARD, PortLocation.PORT_KHAZARD, PortLocation.RUINS_OF_UNKAH, PortPaths.PORT_KHAZARD_RUINS_OF_UNKAH, false, "Spirit angler supply order", ItemID.CARGO_CRATE_OF_SHIP_PARTS.getId(), 5),
	NEED_HELP_WITH_CARGO_RECOVERY(41, PortLocation.PORT_KHAZARD, PortLocation.RUINS_OF_UNKAH, PortLocation.PORT_KHAZARD, PortPaths.PORT_KHAZARD_RUINS_OF_UNKAH, true, "Need help with cargo recovery", ItemID.CARGO_CRATE_OF_DRAGON_EQUIPMENT.getId(), 3),
	OUTFITTING_THE_ANGLERS(42, PortLocation.PORT_KHAZARD, PortLocation.ARDOUGNE, PortLocation.RUINS_OF_UNKAH, PortPaths.ARDOUGNE_RUINS_OF_UNKAH, false, "Outfitting the anglers", ItemID.CARGO_CRATE_OF_SPIRIT_ANGLERS_GARB.getId(), 6),
	ANGLERS_OUTFIT_RECOVERY(43, PortLocation.PORT_KHAZARD, PortLocation.RUINS_OF_UNKAH, PortLocation.PORT_KHAZARD, PortPaths.PORT_KHAZARD_RUINS_OF_UNKAH, true, "Angler's outfit recovery", ItemID.CARGO_CRATE_OF_ANGLERS_OUTFIT.getId(), 5),
	BANANA_COLLECTION(44, PortLocation.RUINS_OF_UNKAH, PortLocation.MUSA_POINT, PortLocation.RUINS_OF_UNKAH, PortPaths.MUSA_POINT_RUINS_OF_UNKAH, false, "Banana collection", ItemID.CARGO_CRATE_OF_BANANAS.getId(), 5),
	EQUIPMENT_REQUISITION(45, PortLocation.RUINS_OF_UNKAH, PortLocation.ARDOUGNE, PortLocation.RUINS_OF_UNKAH, PortPaths.ARDOUGNE_RUINS_OF_UNKAH, false, "Equipment requisition", ItemID.CARGO_CRATE_OF_FISHING_EQUIPMENT.getId(), 2),
	GOT_SOME_GRANITE_THAT_NEEDS_DELIVERING(46, PortLocation.RUINS_OF_UNKAH, PortLocation.RUINS_OF_UNKAH, PortLocation.BRIMHAVEN, PortPaths.RUINS_OF_UNKAH_BRIMHAVEN, false, "Got some granite that needs delivering", ItemID.CARGO_CRATE_OF_GRANITE.getId(), 4),
	SILK_REQUEST(47, PortLocation.RUINS_OF_UNKAH, PortLocation.RUINS_OF_UNKAH, PortLocation.CATHERBY, PortPaths.CATHERBY_RUINS_OF_UNKAH, true, "Silk request", ItemID.CARGO_CRATE_OF_SILK.getId(), 6),
	IMPORTANT_CARGO(48, PortLocation.RUINS_OF_UNKAH, PortLocation.RUINS_OF_UNKAH, PortLocation.PORT_KHAZARD, PortPaths.PORT_KHAZARD_RUINS_OF_UNKAH, true, "Important cargo", ItemID.CARGO_CRATE_OF_IMPORTANCE.getId(), 1),
	IN_NEED_OF_A_SILK_RESUPPLY(49, PortLocation.RUINS_OF_UNKAH, PortLocation.RUINS_OF_UNKAH, PortLocation.ARDOUGNE, PortPaths.ARDOUGNE_RUINS_OF_UNKAH, true, "In need of a silk resupply", ItemID.CARGO_CRATE_OF_SILK.getId(), 8),
	COCKTAIL_EXPRESS(50, PortLocation.RUINS_OF_UNKAH, PortLocation.PANDEMONIUM, PortLocation.RUINS_OF_UNKAH, PortPaths.PANDEMONIUM_RUINS_OF_UNKAH, false, "Cocktail express", ItemID.CARGO_CRATE_OF_COCKTAILS.getId(), 2),
	CACTUS_EXPERIMENTS(51, PortLocation.RUINS_OF_UNKAH, PortLocation.RUINS_OF_UNKAH, PortLocation.PORT_SARIM, PortPaths.RUINS_OF_UNKAH_PORT_SARIM, false, "Cactus experiments", ItemID.CARGO_CRATE_OF_CACTUS.getId(), 2),
	FOOD_STORAGE_RESUPPLY(52, PortLocation.RUINS_OF_UNKAH, PortLocation.RUINS_OF_UNKAH, PortLocation.CORSAIR_COVE, PortPaths.RUINS_OF_UNKAH_CORSAIR_COVE, false, "Food storage resupply", ItemID.CARGO_CRATE_OF_FRESH_FISH.getId(), 4),
	CORAL_EXPERIMENTS(53, PortLocation.RUINS_OF_UNKAH, PortLocation.SUMMER_SHORE, PortLocation.RUINS_OF_UNKAH, PortPaths.RUINS_OF_UNKAH_SUMMER_SHORE, true, "Coral experiments", ItemID.CARGO_CRATE_OF_CORAL.getId(), 4),
	CONSTRUCTION_SUPPLIES(54, PortLocation.RUINS_OF_UNKAH, PortLocation.RUINS_OF_UNKAH, PortLocation.SUMMER_SHORE, PortPaths.RUINS_OF_UNKAH_SUMMER_SHORE, false, "Construction supplies", ItemID.CARGO_CRATE_OF_SANDSTONE.getId(), 7),
	FISH_DELIVERY(81, PortLocation.PANDEMONIUM, PortLocation.PANDEMONIUM, PortLocation.PORT_SARIM, PortPaths.PORT_SARIM_PANDEMONIUM, true, "Fish delivery", ItemID.CARGO_CRATE_OF_RAW_FISH.getId(), 1),
	FISH_FOR_THE_FACE(82, PortLocation.PANDEMONIUM, PortLocation.PANDEMONIUM, PortLocation.PORT_SARIM, PortPaths.PORT_SARIM_PANDEMONIUM, true, "Fish for 'the face'", ItemID.CARGO_CRATE_OF_FRESH_FISH.getId(), 1),
	BILLYNOSHIPPARTS(83, PortLocation.PANDEMONIUM, PortLocation.PANDEMONIUM, PortLocation.MUSA_POINT, PortPaths.MUSA_POINT_PANDEMONIUM, true, "Billy-no-ship-parts", ItemID.CARGO_CRATE_OF_SHIP_PARTS.getId(), 1),
	SECRET_PIRATE_BUISNESS(84, PortLocation.PANDEMONIUM, PortLocation.PANDEMONIUM, PortLocation.MUSA_POINT, PortPaths.MUSA_POINT_PANDEMONIUM, true, "Secret pirate buisness", ItemID.CARGO_CRATE_OF_SECRET_STUFF.getId(), 1),
	WE_NEED_MORE_RUM(85, PortLocation.PANDEMONIUM, PortLocation.MUSA_POINT, PortLocation.PANDEMONIUM, PortPaths.MUSA_POINT_PANDEMONIUM, false, "We need more rum!", ItemID.CARGO_CRATE_OF_RUM.getId(), 1),
	STEEL_COLLECTION(86, PortLocation.PANDEMONIUM, PortLocation.PORT_SARIM, PortLocation.PANDEMONIUM, PortPaths.PORT_SARIM_PANDEMONIUM, false, "Steel collection", ItemID.CARGO_CRATE_OF_STEEL_BARS.getId(), 1),
	JEWELLERY_DELIVERY(87, PortLocation.PANDEMONIUM, PortLocation.PANDEMONIUM, PortLocation.PORT_SARIM, PortPaths.PORT_SARIM_PANDEMONIUM, true, "Jewellery delivery", ItemID.CARGO_CRATE_OF_SILVER_JEWELLERY.getId(), 2),
	RETURN_TO_SENDER(88, PortLocation.PANDEMONIUM, PortLocation.PANDEMONIUM, PortLocation.MUSA_POINT, PortPaths.MUSA_POINT_PANDEMONIUM, true, "Return to sender", ItemID.CARGO_CRATE_OF_ROTTEN_BANANAS.getId(), 3),
	PIRATE_GROG_DELIVERY(89, PortLocation.PANDEMONIUM, PortLocation.PANDEMONIUM, PortLocation.CATHERBY, PortPaths.CATHERBY_PANDEMONIUM, true, "Pirate grog delivery", ItemID.CARGO_CRATE_OF_GROG.getId(), 2),
	IN_NEED_OF_ARROWTIPS(90, PortLocation.PANDEMONIUM, PortLocation.CATHERBY, PortLocation.PANDEMONIUM, PortPaths.CATHERBY_PANDEMONIUM, false, "In need of arrowtips", ItemID.CARGO_CRATE_OF_STEEL_ARROWTIPS.getId(), 2),
	PINEAPPLE_COLLECTION(91, PortLocation.PANDEMONIUM, PortLocation.BRIMHAVEN, PortLocation.PANDEMONIUM, PortPaths.BRIMHAVEN_PANDEMONIUM, false, "Pineapple collection", ItemID.CARGO_CRATE_OF_BRIMHAVEN_PINEAPPLES.getId(), 3),
	SENDING_SAND(92, PortLocation.PANDEMONIUM, PortLocation.PANDEMONIUM, PortLocation.ARDOUGNE, PortPaths.PANDEMONIUM_ARDOUGNE, false, "Sending sand", ItemID.CARGO_CRATE_OF_SAND.getId(), 4),
	COCKTAILS_FOR_ALL(93, PortLocation.PANDEMONIUM, PortLocation.PANDEMONIUM, PortLocation.RUINS_OF_UNKAH, PortPaths.PANDEMONIUM_RUINS_OF_UNKAH, false, "Cocktails for all", ItemID.CARGO_CRATE_OF_COCKTAILS.getId(), 2),
	URGENT_DELIVERY(94, PortLocation.PANDEMONIUM, PortLocation.PANDEMONIUM, PortLocation.PORT_KHAZARD, PortPaths.PANDEMONIUM_PORT_KHAZARD, false, "Urgent delivery", ItemID.CARGO_CRATE_OF_KYATT_TEETH.getId(), 3),
	TAR_NEEDED(95, PortLocation.PANDEMONIUM, PortLocation.PORT_KHAZARD, PortLocation.PANDEMONIUM, PortPaths.PANDEMONIUM_PORT_KHAZARD, true, "Tar needed", ItemID.CARGO_CRATE_OF_SWAMP_PASTE.getId(), 3),
	/*
	removed due to not having a noticeboard location in the sailing beta
	SECRET_PIRATE_LOOTY(55, null, PortLocation.PORT_SARIM, PortLocation.PANDEMONIUM, PortPaths.DEFAULT, false, "Secret pirate looty", ItemID.CARGO_CRATE_OF_PIRATE_LOOTY.getId(), 1),
	 */
	CARGO_RECLAIMS(102, PortLocation.MUSA_POINT, PortLocation.PORT_SARIM, PortLocation.MUSA_POINT, PortPaths.MUSA_POINT_PORT_SARIM, true, "Cargo reclaims", ItemID.CARGO_CRATE_MUSA_POINT_0.getId(), 1),
	PATCH_NOTE(103, PortLocation.MUSA_POINT, PortLocation.PANDEMONIUM, PortLocation.MUSA_POINT, PortPaths.MUSA_POINT_PANDEMONIUM, true, "Patch note", ItemID.CARGO_CRATE_MUSA_POINT_1.getId(), 1),
	PRECIOUS_DELIVERY(104, PortLocation.MUSA_POINT, PortLocation.MUSA_POINT, PortLocation.PORT_SARIM, PortPaths.MUSA_POINT_PORT_SARIM, false, "Precious delivery", ItemID.CARGO_CRATE_MUSA_POINT_2.getId(), 2),
	PINING_FOR_PINEAPPLES(105, PortLocation.MUSA_POINT, PortLocation.MUSA_POINT, PortLocation.PANDEMONIUM, PortPaths.MUSA_POINT_PANDEMONIUM, false, "Pining for pineapples", ItemID.CARGO_CRATE_MUSA_POINT_3.getId(), 2),
	STOP_YOUR_WINING(106, PortLocation.MUSA_POINT, PortLocation.PANDEMONIUM, PortLocation.MUSA_POINT, PortPaths.MUSA_POINT_PANDEMONIUM, true, "Stop your wining!", ItemID.CARGO_CRATE_MUSA_POINT_4.getId(), 2),
	NO_LEG_TO_STAND_ON(107, PortLocation.MUSA_POINT, PortLocation.PORT_SARIM, PortLocation.MUSA_POINT, PortPaths.MUSA_POINT_PORT_SARIM, true, "No leg to stand on", ItemID.CARGO_CRATE_MUSA_POINT_5.getId(), 3),
	SMOOTH_SAILING(108, PortLocation.MUSA_POINT, PortLocation.MUSA_POINT, PortLocation.PANDEMONIUM, PortPaths.MUSA_POINT_PANDEMONIUM, false, "Smooth sailing", ItemID.CARGO_CRATE_MUSA_POINT_6.getId(), 3),
	GENERAL_SUPPLIES(109, PortLocation.MUSA_POINT, PortLocation.CATHERBY, PortLocation.MUSA_POINT, PortPaths.CATHERBY_MUSA_POINT, false, "General supplies", ItemID.CARGO_CRATE_MUSA_POINT_7.getId(), 3),
	GOING_BANANAS(110, PortLocation.MUSA_POINT, PortLocation.MUSA_POINT, PortLocation.CATHERBY, PortPaths.CATHERBY_MUSA_POINT, true, "Going bananas", ItemID.CARGO_CRATE_MUSA_POINT_8.getId(), 1),
	CONTAIN_THE_BEER(111, PortLocation.MUSA_POINT, PortLocation.ENTRANA, PortLocation.MUSA_POINT, PortPaths.ENTRANA_MUSA_POINT, false, "Contain the beer", ItemID.CARGO_CRATE_MUSA_POINT_9.getId(), 4),
	A_MONKS_BEST_FRIEND(112, PortLocation.MUSA_POINT, PortLocation.MUSA_POINT, PortLocation.ENTRANA, PortPaths.ENTRANA_MUSA_POINT, true, "A monk's best friend", ItemID.CARGO_CRATE_MUSA_POINT_10.getId(), 4),
	SECRET_INGREDIENT(113, PortLocation.MUSA_POINT, PortLocation.BRIMHAVEN, PortLocation.MUSA_POINT, PortPaths.BRIMHAVEN_MUSA_POINT, false, "Secret ingredient", ItemID.CARGO_CRATE_MUSA_POINT_11.getId(), 2),
	THE_LONG_CON(114, PortLocation.MUSA_POINT, PortLocation.MUSA_POINT, PortLocation.BRIMHAVEN, PortPaths.BRIMHAVEN_MUSA_POINT, true, "The long con", ItemID.CARGO_CRATE_MUSA_POINT_12.getId(), 1),
	LETS_TEAK_BUSINESS(115, PortLocation.MUSA_POINT, PortLocation.MUSA_POINT, PortLocation.ARDOUGNE, PortPaths.MUSA_POINT_ARDOUGNE, false, "Let's teak business", ItemID.CARGO_CRATE_MUSA_POINT_13.getId(), 3),
	GNOME_DELIVERY(116, PortLocation.MUSA_POINT, PortLocation.MUSA_POINT, PortLocation.ARDOUGNE, PortPaths.MUSA_POINT_ARDOUGNE, false, "Gnome delivery", ItemID.CARGO_CRATE_MUSA_POINT_14.getId(), 5);

	private final int id;
	private final PortLocation noticeBoard;
	private final PortLocation cargoLocation;
	private final PortLocation deliveryLocation;
	public final PortPaths dockMarkers;
	public final boolean reversePath;
	public final String taskName;
	public final int cargo;
	public final int cargoAmount;

	PortTaskData(Integer id, PortLocation noticeBoard, PortLocation cargoLocation, PortLocation deliveryLocation, PortPaths dockMarkers, boolean reversePath, String taskName, int cargo, int cargoAmount)
	{
		this.id = id;
		this.noticeBoard = noticeBoard;
		this.cargoLocation = cargoLocation;
		this.deliveryLocation = deliveryLocation;
		this.dockMarkers = dockMarkers;
		this.reversePath = reversePath;
		this.taskName = taskName;
		this.cargo = cargo;
		this.cargoAmount = cargoAmount;
	}

	public PortLocation getCargoLocation()
	{
		return cargoLocation;
	}

	public PortLocation getDeliveryLocation()
	{
		return deliveryLocation;
	}

	public PortLocation getNoticeBoard()
	{
		return noticeBoard;
	}

	public static PortTaskData fromId(int id)
	{
		for (PortTaskData task : values())
		{
			if (task.id == id)
				return task;
		}
		return null;
	}

	public int getCargoAmount()
	{
		return this.cargoAmount;
	}

}


/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks.enums;

import java.util.HashMap;
import java.util.Map;
// todo: replace with net.runelite.api.gameval.VarbitID when released
import com.nucleon.porttasks.gameval.VarbitID;

public enum PortTaskTrigger
{
	TASK_SLOT_0_ID(VarbitID.PORT_TASK_SLOT_0_ID, TaskType.ID, 0),
	TASK_SLOT_0_TAKEN(VarbitID.PORT_TASK_SLOT_0_CARGO_TAKEN,  TaskType.TAKEN, 0),
	TASK_SLOT_0_DELIVERED(VarbitID.PORT_TASK_SLOT_0_CARGO_DELIVERED, TaskType.DELIVERED, 0),
	TASK_SLOT_1_ID(VarbitID.PORT_TASK_SLOT_1_ID, TaskType.ID, 1),
	TASK_SLOT_1_TAKEN(VarbitID.PORT_TASK_SLOT_1_CARGO_TAKEN,  TaskType.TAKEN, 1),
	TASK_SLOT_1_DELIVERED(VarbitID.PORT_TASK_SLOT_1_CARGO_DELIVERED, TaskType.DELIVERED, 1),
	TASK_SLOT_2_ID(VarbitID.PORT_TASK_SLOT_2_ID,  TaskType.ID, 2),
	TASK_SLOT_2_TAKEN(VarbitID.PORT_TASK_SLOT_2_CARGO_TAKEN, TaskType.TAKEN, 2),
	TASK_SLOT_2_DELIVERED(VarbitID.PORT_TASK_SLOT_2_CARGO_DELIVERED, TaskType.DELIVERED, 2),
	TASK_SLOT_3_ID(VarbitID.PORT_TASK_SLOT_3_ID, TaskType.ID, 3),
	TASK_SLOT_3_TAKEN(VarbitID.PORT_TASK_SLOT_3_CARGO_TAKEN,  TaskType.TAKEN, 3),
	TASK_SLOT_3_DELIVERED(VarbitID.PORT_TASK_SLOT_3_CARGO_DELIVERED,  TaskType.DELIVERED, 3),
	TASK_SLOT_4_ID(VarbitID.PORT_TASK_SLOT_4_ID, TaskType.ID, 4),
	TASK_SLOT_4_TAKEN(VarbitID.PORT_TASK_SLOT_4_CARGO_TAKEN, TaskType.TAKEN, 4),
	TASK_SLOT_4_DELIVERED(VarbitID.PORT_TASK_SLOT_4_CARGO_DELIVERED, TaskType.DELIVERED, 4),
	LAST_CARGO_TAKEN(VarbitID.PORT_TASK_LAST_CARGO_TAKEN, TaskType.OTHER, -1);

	private final int id;
	private final TaskType type;
	private final int slot;

	public enum TaskType
	{
		ID, TAKEN, DELIVERED, OTHER
	}

	PortTaskTrigger(int id, TaskType type, int slot)
	{
		this.id = id;
		this.type = type;
		this.slot = slot;
	}

	public int getId()
	{
		return id;
	}

	public TaskType getType()
	{
		return type;
	}

	public int getSlot()
	{
		return slot;
	}

	private static final Map<Integer, PortTaskTrigger> lookup = new HashMap<>();
	static
	{
		for (PortTaskTrigger v : values())
		{
			lookup.put(v.id, v);
		}
	}

	public static PortTaskTrigger fromId(int id)
	{
		return lookup.get(id);
	}

	public static boolean contains(int id)
	{
		return lookup.containsKey(id);
	}

	@Override
	public String toString()
	{
		return String.format("%s (Type: %s, Slot: %d)", name(), type, slot);
	}

}
package com.nucleon.porttasks.enums;

import com.nucleon.porttasks.RelativeMove;
import java.util.ArrayList;
import java.util.List;
import net.runelite.api.coords.WorldPoint;


public enum PortPaths
{
	DEFAULT(
		PortLocation.EMPTY,
		PortLocation.EMPTY
	),
	CATHERBY_BRIMHAVEN(
		PortLocation.CATHERBY,
		PortLocation.BRIMHAVEN,
		new RelativeMove(-42, -42)
	),
	BRIMHAVEN_MUSA_POINT(
		PortLocation.BRIMHAVEN,
		PortLocation.MUSA_POINT,
		new RelativeMove(0, 8),
		new RelativeMove(7, 7),
		new RelativeMove(33, 0),
		new RelativeMove(30, -30),
		new RelativeMove(76, 0),
		new RelativeMove(47, -47),
		new RelativeMove(13, 0),
		new RelativeMove(5, -5)
	),

	BRIMHAVEN_PANDEMONIUM(
		PortLocation.BRIMHAVEN,
		PortLocation.PANDEMONIUM,
		new RelativeMove(0, 8),
		new RelativeMove(7, 7),
		new RelativeMove(33, 0),
		new RelativeMove(30, -30),
		new RelativeMove(76, 0),
		new RelativeMove(47, -47),
		new RelativeMove(13, 0),
		new RelativeMove(14, -14),
		new RelativeMove(0, -63),
		new RelativeMove(59, -59),
		new RelativeMove(37, 0),
		new RelativeMove(8, -8)

	),

	BRIMHAVEN_PORT_KHAZARD(
		PortLocation.BRIMHAVEN,
		PortLocation.PORT_KHAZARD,
		new RelativeMove(0, 15),
		new RelativeMove(-7, 7),
		new RelativeMove(-26, 0),
		new RelativeMove(-33, -33)
	),

	CATHERBY_ARDOUGNE(
		PortLocation.CATHERBY,
		PortLocation.ARDOUGNE,
		new RelativeMove(-42, -42),
		new RelativeMove(0, -91),
		new RelativeMove(-16, -16)
	),

	CATHERBY_MUSA_POINT(
		PortLocation.CATHERBY,
		PortLocation.MUSA_POINT,
		new RelativeMove(62, 0),
		new RelativeMove(20, -20),
		new RelativeMove(0, -42),
		new RelativeMove(4, -4),
		new RelativeMove(0, -105),
		new RelativeMove(60, -60),
		new RelativeMove(18, 0),
		new RelativeMove(5, -5)
	),

	CATHERBY_PANDEMONIUM(
		PortLocation.CATHERBY,
		PortLocation.PANDEMONIUM,
		new RelativeMove(62, 0),
		new RelativeMove(20, -20),
		new RelativeMove(0, -42),
		new RelativeMove(4, -4),
		new RelativeMove(0, -105),
		new RelativeMove(60, -60),
		new RelativeMove(18, 0),
		new RelativeMove(13, -13),
		new RelativeMove(0, -67),
		new RelativeMove(75, -75),
		new RelativeMove(25, 0),
		new RelativeMove(5, -5)
	),

	CATHERBY_PORT_KHAZARD(
		PortLocation.CATHERBY,
		PortLocation.PORT_KHAZARD,
		new RelativeMove(-42, -42),
		new RelativeMove(0, -91),
		new RelativeMove(-50, -50),
		new RelativeMove(-13, 0),
		new RelativeMove(-3, -3)
	),

	CATHERBY_PORT_SARIM(
		PortLocation.CATHERBY,
		PortLocation.PORT_SARIM,
		new RelativeMove(62, 0),
		new RelativeMove(20, -20),
		new RelativeMove(0, -42),
		new RelativeMove(4, -4),
		new RelativeMove(0, -105),
		new RelativeMove(60, -60),
		new RelativeMove(18, 0),
		new RelativeMove(10, -10),
		new RelativeMove(0, -51),
		new RelativeMove(13, -13),
		new RelativeMove(24, 0),
		new RelativeMove(49, 49)
	),

	ARDOUGNE_PORT_KHAZARD(
		PortLocation.ARDOUGNE,
		PortLocation.PORT_KHAZARD,
		new RelativeMove(5, 0),
		new RelativeMove(7, -7),
		new RelativeMove(0, -60),
		new RelativeMove(6, -6)
	),

	ARDOUGNE_RUINS_OF_UNKAH(
		PortLocation.ARDOUGNE,
		PortLocation.RUINS_OF_UNKAH,
		new RelativeMove(90, 0),
		new RelativeMove(34, -34),
		new RelativeMove(17, 0),
		new RelativeMove(12, -12),
		new RelativeMove(85, 0),
		new RelativeMove(55, -55),
		new RelativeMove(0, -42),
		new RelativeMove(121, -121),
		new RelativeMove(0, -20),
		new RelativeMove(43, -43),
		new RelativeMove(0, -108)
	),

	ENTRANA_MUSA_POINT(
		PortLocation.ENTRANA,
		PortLocation.MUSA_POINT,
		new RelativeMove(0, -118),
		new RelativeMove(20, -20),
		new RelativeMove(20, 0),
		new RelativeMove(20, -20),
		new RelativeMove(17, 0),
		new RelativeMove(5, -5)
	),

	MUSA_POINT_PANDEMONIUM(
		PortLocation.MUSA_POINT,
		PortLocation.PANDEMONIUM,
		new RelativeMove(5, 0),
		new RelativeMove(5, -5),
		new RelativeMove(0, -35),
		new RelativeMove(103, -103),
		new RelativeMove(0, -20)
	),

	MUSA_POINT_PORT_KHAZARD(
		PortLocation.MUSA_POINT,
		PortLocation.PORT_KHAZARD,
		new RelativeMove(5, 0),
		new RelativeMove(0, 10),
		new RelativeMove(-35, 35),
		new RelativeMove(-20, 0),
		new RelativeMove(-25, 25),
		new RelativeMove(-85, 0),
		new RelativeMove(-41, 41),
		new RelativeMove(-40, 0),
		new RelativeMove(-40, -40),
		new RelativeMove(0, -15),
		new RelativeMove(5, -5)
	),

	MUSA_POINT_PORT_SARIM(
		PortLocation.MUSA_POINT,
		PortLocation.PORT_SARIM,
		new RelativeMove(5, 0),
		new RelativeMove(5, -5),
		new RelativeMove(0, -35),
		new RelativeMove(14, -14),
		new RelativeMove(11, 0),
		new RelativeMove(56, 56)
	),

	MUSA_POINT_RUINS_OF_UNKAH(
		PortLocation.MUSA_POINT,
		PortLocation.RUINS_OF_UNKAH,
		new RelativeMove(5, 0),
		new RelativeMove(5, -5),
		new RelativeMove(0, -35),
		new RelativeMove(103, -103),
		new RelativeMove(0, -20),
		new RelativeMove(45, -45),
		new RelativeMove(0, -117),
		new RelativeMove(20, 0)
	),

	PANDEMONIUM_PORT_KHAZARD(
		PortLocation.PANDEMONIUM,
		PortLocation.PORT_KHAZARD,
		new RelativeMove(0, 20),
		new RelativeMove(-103, 103),
		new RelativeMove(0, 35),
		new RelativeMove(-5, 5),
		new RelativeMove(0, 10),
		new RelativeMove(-35, 35),
		new RelativeMove(-20, 0),
		new RelativeMove(-25, 25),
		new RelativeMove(-85, 0),
		new RelativeMove(-41, 41),
		new RelativeMove(-40, 0),
		new RelativeMove(-40, -40),
		new RelativeMove(0, -15),
		new RelativeMove(5, -5)
	),

	PANDEMONIUM_RUINS_OF_UNKAH(
		PortLocation.PANDEMONIUM,
		PortLocation.RUINS_OF_UNKAH,
		new RelativeMove(0, -20),
		new RelativeMove(45, -45),
		new RelativeMove(0, -98),
		new RelativeMove(20, 0)
	),

	PORT_KHAZARD_PORT_SARIM(
		PortLocation.PORT_KHAZARD,
		PortLocation.PORT_SARIM,
		new RelativeMove(0, 60),
		new RelativeMove(35, 35),
		new RelativeMove(45, 0),
		new RelativeMove(41, -41),
		new RelativeMove(85, 0),
		new RelativeMove(25, -25),
		new RelativeMove(20, 0),
		new RelativeMove(35, -35),
		new RelativeMove(0, -44),
		new RelativeMove(12, -12),
		new RelativeMove(22, 0),
		new RelativeMove(48, 48)
	),

	PORT_KHAZARD_RUINS_OF_UNKAH(
		PortLocation.PORT_KHAZARD,
		PortLocation.RUINS_OF_UNKAH,
		new RelativeMove(0, 25),
		new RelativeMove(-20, 20),
		new RelativeMove(50, 50),
		new RelativeMove(45, 0),
		new RelativeMove(41, -41),
		new RelativeMove(85, 0),
		new RelativeMove(25, -25),
		new RelativeMove(20, 0),
		new RelativeMove(35, -35),
		new RelativeMove(0, -10),
		new RelativeMove(5, -5),
		new RelativeMove(0, -35),
		new RelativeMove(103, -103),
		new RelativeMove(0, -20),
		new RelativeMove(0, -20),
		new RelativeMove(45, -45),
		new RelativeMove(0, -98),
		new RelativeMove(20, 0)
	),

	RUINS_OF_UNKAH_SUMMER_SHORE(
		PortLocation.RUINS_OF_UNKAH,
		PortLocation.SUMMER_SHORE,
			new RelativeMove(-7, 0),
			new RelativeMove(0, -31),
			new RelativeMove(-43, -43),
			new RelativeMove(0, -110),
			new RelativeMove(-22, -22),
			new RelativeMove(0, -207),
			new RelativeMove(44, -44)
	),
	PORT_SARIM_PANDEMONIUM(
		PortLocation.PORT_SARIM,
		PortLocation.PANDEMONIUM,
		new RelativeMove(0, -43),
		new RelativeMove(-22, -22),
		new RelativeMove(0, -75),
		new RelativeMove(44, -44)
	),
	PORT_SARIM_ARDOUGNE(
		PortLocation.PORT_SARIM,
		PortLocation.ARDOUGNE,
		new RelativeMove(0, -43),
		new RelativeMove(-50, -50),
		new RelativeMove(-22, 0),
		new RelativeMove(-8, 8),
		new RelativeMove(0, 40),
		new RelativeMove(-50, 50),
		new RelativeMove(-48, 0),
		new RelativeMove(-10, 10),
		new RelativeMove(-40, 0),
		new RelativeMove(-50, 50)
	),
	CATHERBY_ENTRANA(
		PortLocation.CATHERBY,
		PortLocation.ENTRANA,
		new RelativeMove(60, 0),
		new RelativeMove(16, -16),
		new RelativeMove(0, -40),
		new RelativeMove(11, -11)
	),
	CATHERBY_RUINS_OF_UNKAH(
		PortLocation.CATHERBY,
		PortLocation.RUINS_OF_UNKAH,
		new RelativeMove(62, 0),
		new RelativeMove(20, -20),
		new RelativeMove(0, -42),
		new RelativeMove(4, -4),
		new RelativeMove(0, -105),
		new RelativeMove(60, -60),
		new RelativeMove(18, 0),
		new RelativeMove(14, -14),
		new RelativeMove(0, -51),
		new RelativeMove(153, -153),
		new RelativeMove(0, -131),
		new RelativeMove(5, -5),
		new RelativeMove(10, 0)
	),
	BRIMHAVEN_ARDOUGNE(
		PortLocation.BRIMHAVEN,
		PortLocation.ARDOUGNE,
		new RelativeMove(0, 16),
		new RelativeMove(-12, 12)
	),
	PORT_KHAZARD_ENTRANA(
		PortLocation.PORT_KHAZARD,
		PortLocation.ENTRANA,
		new RelativeMove(0, 59),
		new RelativeMove(38, 38),
		new RelativeMove(66, 0),
		new RelativeMove(9, 9),
		new RelativeMove(0, 41),
		new RelativeMove(14, 14),
		new RelativeMove(63, 0),
		new RelativeMove(5, 5)
	),
	PORT_KHAZARD_CORSAIR_COVE(
		PortLocation.PORT_KHAZARD,
		PortLocation.CORSAIR_COVE,
		new RelativeMove(0, -20),
		new RelativeMove(24, -24),
		new RelativeMove(0, -175),
		new RelativeMove(-99, -99)
	),
	RUINS_OF_UNKAH_BRIMHAVEN(
		PortLocation.RUINS_OF_UNKAH,
		PortLocation.BRIMHAVEN,
		new RelativeMove(-20, 0),
		new RelativeMove(0, 98),
		new RelativeMove(-45, 45),
		new RelativeMove(0, 25),
		new RelativeMove(-110, 110),
		new RelativeMove(0, 60),
		new RelativeMove(-35, 35),
		new RelativeMove(-20, 0),
		new RelativeMove(-25, 25),
		new RelativeMove(-85, 0),
		new RelativeMove(-20, 20),
		new RelativeMove(-24, 0),
		new RelativeMove(-5, -5)
	),
	RUINS_OF_UNKAH_PORT_SARIM(
		PortLocation.RUINS_OF_UNKAH,
		PortLocation.PORT_SARIM,
		new RelativeMove(-20, 0),
		new RelativeMove(0, 98),
		new RelativeMove(-45, 45),
		new RelativeMove(0, 25),
		new RelativeMove(-44, 44),
		new RelativeMove(0, 80),
		new RelativeMove(22, 22)
	),
	RUINS_OF_UNKAH_CORSAIR_COVE(
		PortLocation.RUINS_OF_UNKAH,
		PortLocation.CORSAIR_COVE,
		new RelativeMove(-7, 0),
		new RelativeMove(0, -31),
		new RelativeMove(-43, -43),
		new RelativeMove(-208, 0),
		new RelativeMove(-94, 94)
	),
	PANDEMONIUM_ARDOUGNE(
		PortLocation.PANDEMONIUM,
		PortLocation.ARDOUGNE,
		new RelativeMove(0, 22),
		new RelativeMove(-105, 105),
		new RelativeMove(0, 42),
		new RelativeMove(-28, 28),
		new RelativeMove(-23, 0),
		new RelativeMove(-27, 27),
		new RelativeMove(-76, 0),
		new RelativeMove(-48, 48)
	),
	MUSA_POINT_ARDOUGNE(
		PortLocation.MUSA_POINT,
		PortLocation.ARDOUGNE,
		new RelativeMove(0, 16),
		new RelativeMove(-28, 28),
		new RelativeMove(-23, 0),
		new RelativeMove(-27, 27),
		new RelativeMove(-76, 0),
		new RelativeMove(-48, 48)
	);

	private final PortLocation start;
	private final PortLocation end;
	private final List<RelativeMove> pathPoints;

	PortPaths(PortLocation start, PortLocation end, RelativeMove... pathPoints)
	{
		this.start = start;
		this.end = end;
		this.pathPoints = List.of(pathPoints);
	}

	public PortLocation getStart()
	{
		return start;
	}

	public PortLocation getEnd()
	{
		return end;
	}

	public List<WorldPoint> getFullPath()
	{
		List<WorldPoint> fullPath = new ArrayList<>();
		WorldPoint current = start.getNavigationLocation();
		fullPath.add(current);
		for (RelativeMove delta : pathPoints)
		{
			current = new WorldPoint(current.getX() + delta.getDx(), current.getY() + delta.getDy(), current.getPlane());
			fullPath.add(current);
		}
		fullPath.add(end.getNavigationLocation());
		return fullPath;
	}

	@Override
	public String toString()
	{
		return String.format("%s -> %s (%d points)", start.name(), end.name(), pathPoints.size());
	}

}
/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.Collections;
import java.util.List;

import javax.inject.Inject;

import com.nucleon.porttasks.overlay.WorldLines;

import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;

import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

class PortTasksWorldOverlay extends Overlay
{
	private final Client client;
	private final PortTasksPlugin plugin;
	private final PortTasksConfig config;

	@Inject
	private PortTasksWorldOverlay(Client client, PortTasksPlugin plugin, PortTasksConfig config)
	{
		this.client = client;
		this.plugin = plugin;
		this.config = config;

		setPosition(OverlayPosition.DYNAMIC);
		setPriority(Overlay.PRIORITY_HIGHEST);
		setLayer(OverlayLayer.UNDER_WIDGETS);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		renderOverlayLines(graphics);
		return null;
	}

	private void renderOverlayLines(Graphics2D g)
	{
		for (PortTask tasks : plugin.currentTasks)
		{
			Color overlayColor = tasks.getOverlayColor();
			List<WorldPoint> journey = tasks.getData().dockMarkers.getFullPath();
			if (tasks.getData().reversePath)
			{
				Collections.reverse(journey);
			}
			if (tasks.isTracking())
			{
				WorldLines.drawLinesOnWorld(g, client, journey, overlayColor);
			}
		}
	}
}
/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks;

public class PortTasksDelegate
{
	public boolean isLoggedIn;
}

/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks;

import com.nucleon.porttasks.enums.PortTaskData;

import lombok.Getter;
import lombok.Setter;
import lombok.AllArgsConstructor;

import java.awt.Color;

@Getter
@Setter
@AllArgsConstructor
public class PortTask
{
	private PortTaskData data;
	private int slot;
	private boolean taken;
	private int delivered;
	private boolean tracking;
	private boolean active;
	private Color overlayColor;
	private int cargoTaken;
}

/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.inject.Inject;

import com.nucleon.porttasks.gameval.LedgerID;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.ObjectComposition;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.Tile;

import net.runelite.client.ui.overlay.Overlay;

import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

class PortTasksLedgerOverlay extends Overlay
{
	private final Client client;
	private final PortTasksPlugin plugin;
	private final PortTasksConfig config;

	@Inject
	private PortTasksLedgerOverlay(Client client, PortTasksPlugin plugin, PortTasksConfig config)
	{
		this.client = client;
		this.plugin = plugin;
		this.config = config;

		setPosition(OverlayPosition.DYNAMIC);
		setPriority(PRIORITY_HIGHEST);
		setLayer(OverlayLayer.UNDER_WIDGETS);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		renderOverlay(graphics);
		return null;
	}

	private void renderOverlay(Graphics2D g)
	{
		// we need to track if a port courier task is sharing a ledger for delivery or cargo
		Map<Integer, List<PortTask>> ledgerUsageMap = new HashMap<>();
		// we need to store a reference to an objectid and an overlay
		Map<Integer, Integer> overlayCount = new HashMap<>();

		//  looping through all the port tasks currently assigned
		for (PortTask task : plugin.currentTasks)
		{	// get the port locations and check them against the ledger port locations in our LedgerID enum
			String cargoPickupLocation = task.getData().getCargoLocation().getName();
			String cargoDeliveryLocation = task.getData().getDeliveryLocation().getName();

			Integer pickupLedgerObjectID = LedgerID.containsName(cargoPickupLocation)
					? LedgerID.getObjectIdByName(cargoPickupLocation)
					: null;

			Integer deliveryLedgerObjectID = LedgerID.containsName(cargoDeliveryLocation)
					? LedgerID.getObjectIdByName(cargoDeliveryLocation)
					: null;
			// store a reference to them in the map, so we can render
			// multicolored overlays for shared ledgers in port tasks
			if (pickupLedgerObjectID != null)
			{
				ledgerUsageMap.computeIfAbsent(pickupLedgerObjectID, k -> new ArrayList<>()).add(task);
			}
			if (deliveryLedgerObjectID != null)
			{
				ledgerUsageMap.computeIfAbsent(deliveryLedgerObjectID, k -> new ArrayList<>()).add(task);
			}
		}

		// loop through the scene, find the ledger object
		Tile[][][] sceneTiles = client.getTopLevelWorldView().getScene().getTiles();
		for (Tile[][] sceneTile : sceneTiles)
		{
			for (Tile[] tiles : sceneTile)
			{
				for (Tile tile : tiles)
				{
					if (tile == null)
					{
						continue;
					}

					for (GameObject object : tile.getGameObjects())
					{
						if (object == null)
						{
							continue;
						}
						// if the ledger in this scene isn't a ledger with a port task, escape
						int objectId = object.getId();
						List<PortTask> tasksAtLedger = ledgerUsageMap.get(objectId);
						if (tasksAtLedger == null || tasksAtLedger.isEmpty())
						{
							continue;
						}

						ObjectComposition comp = client.getObjectDefinition(objectId);
						int size = comp.getSizeX();

						Polygon poly = Perspective.getCanvasTileAreaPoly(client, object.getLocalLocation(), size);
						if (poly != null)
						{	// we stored the tasks that are using this ledger,
							// so we can draw a dynamic tile
							Color[] colors = getOverlayColors(tasksAtLedger);
							renderMultiColoredSquare(g, poly, colors);
						}
						// loop through the tasks at this ledger object, get the cargo information and render a text overlay
						// for more than one task, store them in a overlayCount map and stack the text
						int offsetIndex = overlayCount.getOrDefault(objectId, 0);
						for (PortTask task : tasksAtLedger)
						{
							String cargoPickupLocation = task.getData().getCargoLocation().getName();
							String cargoDeliveryLocation = task.getData().getDeliveryLocation().getName();
							int cargoTakenFromLedger = task.getCargoTaken();
							int cargoDeliveredToLedger = task.getDelivered();
							int cargoRequired = task.getData().getCargoAmount();

							Integer pickupId = LedgerID.getObjectIdByName(cargoPickupLocation);
							Integer deliveryId = LedgerID.getObjectIdByName(cargoDeliveryLocation);
							boolean isPickup = pickupId != null && objectId == pickupId && cargoTakenFromLedger < cargoRequired;
							boolean isDelivery = deliveryId != null && objectId == deliveryId && cargoDeliveredToLedger < cargoRequired;

							if (!isPickup && !isDelivery)
							{
								continue;
							}
							// so we know it's either a pickup or delivery, display the data of either
							String label = isPickup
									? String.format("Cargo: %d/%d", cargoTakenFromLedger, cargoRequired)
									: String.format("Delivered: %d/%d", cargoDeliveredToLedger, cargoRequired);

							Point textLocation = Perspective.getCanvasTextLocation(client, g, object.getLocalLocation(), label, 0);
							if (textLocation != null)
							{
								int yOffset = 15 * offsetIndex;
								Point raisedLocation = new Point(textLocation.getX(), textLocation.getY() - yOffset);
								OverlayUtil.renderTextLocation(g, raisedLocation, label, Color.WHITE);
								offsetIndex++;
							}
						}
						// +1 overlay on this ledger object
						overlayCount.put(objectId, offsetIndex);
					}
				}
			}
		}
	}

	private void renderMultiColoredSquare(Graphics2D g, Polygon poly, Color... colors)
	{
		if (poly == null || poly.npoints < 2 || colors.length == 0)
		{
			return;
		}

		g.setColor(new Color(0, 0, 0, 50));
		g.fillPolygon(poly);

		int nPoints = poly.npoints;
		int edgesPerColor = nPoints / colors.length;
		int remainder = nPoints % colors.length;

		int edgeIndex = 0;
		for (int colorIndex = 0; colorIndex < colors.length; colorIndex++)
		{
			int count = edgesPerColor + (colorIndex < remainder ? 1 : 0);
			g.setColor(colors[colorIndex]);
			g.setStroke(new BasicStroke(2));

			for (int i = 0; i < count; i++, edgeIndex++)
			{
				int p1 = edgeIndex % nPoints;
				int p2 = (edgeIndex + 1) % nPoints;

				int x1 = poly.xpoints[p1];
				int y1 = poly.ypoints[p1];
				int x2 = poly.xpoints[p2];
				int y2 = poly.ypoints[p2];

				g.drawLine(x1, y1, x2, y2);
			}
		}
	}

	private Color[] getOverlayColors(List<PortTask> tasks)
	{
		Color[] colors = new Color[tasks.size()];
		for (int i = 0; i < tasks.size(); i++)
		{
			colors[i] = tasks.get(i).getOverlayColor();
		}
		return colors;
	}
}
/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks.ui;

import com.nucleon.porttasks.gameval.ItemID;
import com.nucleon.porttasks.ui.adapters.HidePortTaskSlotOverlay;
import com.nucleon.porttasks.ui.adapters.PortTaskSlotOverlayColor;
import com.nucleon.porttasks.PortTask;
import com.nucleon.porttasks.PortTasksPlugin;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.colorpicker.RuneliteColorPicker;
import net.runelite.client.util.ImageUtil;

import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;
import javax.swing.border.Border;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.image.BufferedImage;

public class PortTaskPanel extends JPanel
{
	public final PortTasksPlugin plugin;

	private static final Border NAME_BOTTOM_BORDER = new CompoundBorder(
			BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.DARK_GRAY_COLOR),
			BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_COLOR));

	private static final ImageIcon
			BORDER_COLOR_ICON,
			VISIBLE_ICON,
			INVISIBLE_ICON,
			ANCHOR,
			BOAT,
			DESTINATION,
			NOTICE,
			PACKAGE;

	public final JLabel
			PortTaskOverlayColor = new JLabel(),
			hidePortTaskSlotOverlay = new JLabel(),
			cargoRemainingText = new JLabel(),
			cargoLabel = new JLabel(),
			destinationLabel = new JLabel(),
			noticeLabel = new JLabel(),
			anchorLabel = new JLabel(),
			boatLabel = new JLabel(),
			taskName = new JLabel();

	private final JLabel
			save   = new JLabel("Save"),
			cancel = new JLabel("Cancel"),
			rename = new JLabel("Rename");

	public final JPanel PortTaskSlotContainer = new JPanel(new BorderLayout());
	private final PortTask portTask;

	static
	{
		final BufferedImage borderImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "border_color_icon.png");
		BORDER_COLOR_ICON = new ImageIcon(ImageUtil.alphaOffset(borderImg, -100));

		final BufferedImage visibleImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "visible_icon.png");
		VISIBLE_ICON = new ImageIcon(visibleImg);

		final BufferedImage invisibleImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "invisible_icon.png");
		INVISIBLE_ICON = new ImageIcon(invisibleImg);

		final BufferedImage boatImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "boat.png");
		BOAT = new ImageIcon(boatImg);

		final BufferedImage anchorImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "anchor.png");
		ANCHOR = new ImageIcon(anchorImg);

		final BufferedImage destImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "destination.png");
		DESTINATION = new ImageIcon(ImageUtil.alphaOffset(destImg, -100));

		final BufferedImage noticeImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "notice.png");
		NOTICE = new ImageIcon(ImageUtil.alphaOffset(noticeImg, -100));

		final BufferedImage cargoImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "package.png");
		PACKAGE = new ImageIcon(ImageUtil.alphaOffset(cargoImg, -100));
	}

	public PortTaskPanel(PortTasksPlugin plugin, PortTask portTask, int slot)
	{
		this.plugin = plugin;
		this.portTask = portTask;

		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARKER_GRAY_COLOR);
		setBorder(new EmptyBorder(0, 0, 0, 0));

		JPanel nameWrapper = new JPanel(new BorderLayout());
		nameWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		nameWrapper.setBorder(NAME_BOTTOM_BORDER);

		JPanel noticeWrapper = new JPanel(new BorderLayout());
		noticeWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel cargoWrapper = new JPanel(new BorderLayout());
		cargoWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel destinationWrapper = new JPanel(new BorderLayout());
		destinationWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel hideOverlay = new JPanel(new FlowLayout(FlowLayout.RIGHT, 3, 3));
		hideOverlay.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		PortTaskSlotContainer.setBorder(new EmptyBorder(0, 0, 0, 0));
		PortTaskSlotContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel PortTaskActionsLeftSide = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
		PortTaskActionsLeftSide.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel PortTaskInformationCenter = new JPanel();
		PortTaskInformationCenter.setBackground(ColorScheme.DARKER_GRAY_COLOR);


		PortTaskOverlayColor.setToolTipText("edit portTask color");
		PortTaskOverlayColor.setForeground(portTask.getOverlayColor() == null ? Color.red : portTask.getOverlayColor());
		PortTaskOverlayColor.addMouseListener(new PortTaskSlotOverlayColor(PortTaskOverlayColor, this));
		PortTaskActionsLeftSide.add(PortTaskOverlayColor);

		int cargoTaken = portTask.getCargoTaken();
		int delivered = portTask.getDelivered();
		int required = portTask.getData().getCargoAmount();

		cargoRemainingText.setText("Cargo: " + cargoTaken + "/" + required);
		cargoRemainingText.setToolTipText("Remaining cargo");

		if (cargoTaken < required)
		{
			cargoRemainingText.setForeground(Color.RED);
		}

		if (cargoTaken == required)
		{
			cargoRemainingText.setText("Delivered: " + delivered + "/" + required);
		}
		if (delivered == required)
		{
			cargoRemainingText.setText("Claim Rewards!");
		}

		PortTaskInformationCenter.add(cargoRemainingText);

		hidePortTaskSlotOverlay.setToolTipText((portTask.isTracking() ? "Hide" : "Show") + " portTask");
		hidePortTaskSlotOverlay.addMouseListener(new HidePortTaskSlotOverlay(hidePortTaskSlotOverlay, portTask, this, plugin));

		hideOverlay.add(hidePortTaskSlotOverlay);
		taskName.setText(portTask.getData().taskName);
		taskName.setHorizontalAlignment(SwingConstants.CENTER);


		nameWrapper.add(taskName, BorderLayout.CENTER);
		nameWrapper.add(hideOverlay, BorderLayout.EAST);
		nameWrapper.add(anchorLabel, BorderLayout.WEST);

		JPanel portSlotWrapper = new JPanel();
		portSlotWrapper.setLayout(new BoxLayout(portSlotWrapper, BoxLayout.Y_AXIS));
		portSlotWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		portSlotWrapper.add(nameWrapper);
		portSlotWrapper.add(PortTaskSlotContainer);

		noticeWrapper.add(noticeLabel, BorderLayout.WEST);
		noticeWrapper.setBorder(NAME_BOTTOM_BORDER);
		cargoWrapper.add(cargoLabel, BorderLayout.WEST);
		cargoWrapper.setBorder(NAME_BOTTOM_BORDER);
		destinationWrapper.add(destinationLabel, BorderLayout.WEST);
		destinationWrapper.setBorder(NAME_BOTTOM_BORDER);

		portSlotWrapper.add(noticeWrapper);
		portSlotWrapper.add(cargoWrapper);
		portSlotWrapper.add(destinationWrapper);

		PortTaskSlotContainer.setLayout(new BorderLayout());
		PortTaskSlotContainer.add(PortTaskActionsLeftSide, BorderLayout.WEST);
		PortTaskSlotContainer.add(PortTaskInformationCenter, BorderLayout.CENTER);
		PortTaskSlotContainer.setBorder(NAME_BOTTOM_BORDER);

		add(portSlotWrapper);

		updateVisibility();
		updateColorIndicators();
		updateImages(portTask);

	}

	public void openPortTaskColorPicker()
	{
		Color color = portTask.getOverlayColor() == null ? Color.red : portTask.getOverlayColor();
		RuneliteColorPicker colourPicker = getColorPicker(color);
		colourPicker.setOnColorChange(c ->
		{
			portTask.setOverlayColor(c);
			PortTaskOverlayColor.setBorder(new MatteBorder(0, 0, 3, 0, portTask.getOverlayColor()));
			PortTaskOverlayColor.setIcon(BORDER_COLOR_ICON);
			updateColorIndicators();
		});
		colourPicker.setVisible(true);
	}

	private RuneliteColorPicker getColorPicker(Color color)
	{
		RuneliteColorPicker colorPicker = plugin.getColorPickerManager().create(
				SwingUtilities.windowForComponent(this),
				color,
				portTask.getData().taskName + " - overlay color",
				false);
		colorPicker.setLocationRelativeTo(this);
		colorPicker.setOnClose(c -> plugin.saveSlotSettings());
		return colorPicker;
	}


	private void updateColorIndicators()
	{
		PortTaskOverlayColor.setBorder(new MatteBorder(0, 0, 3, 0, portTask.getOverlayColor()));
		PortTaskOverlayColor.setIcon(BORDER_COLOR_ICON);
	}

	public void updateVisibility()
	{
		hidePortTaskSlotOverlay.setIcon(portTask.isTracking() ? VISIBLE_ICON : INVISIBLE_ICON);
	}

	private void updateImages(PortTask portTask)
	{
		cargoLabel.setIcon(PACKAGE);
		destinationLabel.setIcon(DESTINATION);
		noticeLabel.setIcon(NOTICE);
		anchorLabel.setIcon(ANCHOR);
		boatLabel.setIcon(BOAT);

		cargoLabel.setText(portTask.getData().getCargoLocation().getName());
		destinationLabel.setText(portTask.getData().getDeliveryLocation().getName());
		noticeLabel.setText(portTask.getData().getCargoAmount() + "x " + ItemID.getNameById(portTask.getData().cargo));


		cargoLabel.setToolTipText("Cargo Location");
		destinationLabel.setToolTipText("Delivery Location");
		noticeLabel.setToolTipText("Cargo Item Needed");
	}



}

/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks.ui;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;

import com.nucleon.porttasks.PortTask;
import com.nucleon.porttasks.PortTasksConfig;
import com.nucleon.porttasks.PortTasksPlugin;
import com.nucleon.porttasks.ui.adapters.ReloadPortTasks;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.client.util.ImageUtil;

import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import javax.swing.border.EmptyBorder;

import java.awt.image.BufferedImage;
import java.util.List;


public class PortTasksPluginPanel extends PluginPanel
{
		private static final ImageIcon RELOAD_ICON;
		private final PluginErrorPanel errorPanel = new PluginErrorPanel();
		public final PortTasksPlugin plugin;
		private final PortTasksConfig config;
		private final JPanel markerView = new JPanel();

		static
		{
			final BufferedImage addIcon = ImageUtil.loadImageResource(PortTasksPlugin.class, "reload.png");
			RELOAD_ICON = new ImageIcon(addIcon);
		}

		public PortTasksPluginPanel(PortTasksPlugin plugin, PortTasksConfig config)
		{
			this.plugin = plugin;
			this.config = config;

			setLayout(new BorderLayout());
			setBorder(new EmptyBorder(10, 10, 10, 10));
			setupErrorPanel(true);

			// title panel
			JPanel northPanel = new JPanel(new BorderLayout());
			northPanel.setBorder(new EmptyBorder(1, 0, 10, 0));

			JPanel titlePanel = new JPanel(new BorderLayout());
			titlePanel.setBorder(new EmptyBorder(1, 3, 10, 7));

			JLabel title = new JLabel("Port Tasks", SwingConstants.CENTER);
			title.setHorizontalAlignment(SwingConstants.CENTER);
			title.setForeground(Color.WHITE);

			JLabel markerAdd = new JLabel(RELOAD_ICON);
			markerAdd.setToolTipText("reload");
			markerAdd.addMouseListener(new ReloadPortTasks(markerAdd, plugin, this::addMarker));

			JPanel markerButtons = new JPanel(new FlowLayout(FlowLayout.RIGHT, 7, 3));
			markerButtons.add(markerAdd);

			titlePanel.add(title, BorderLayout.WEST);
			titlePanel.add(markerButtons, BorderLayout.EAST);
			northPanel.add(titlePanel, BorderLayout.NORTH);

			// marker view panels, these are dynamically added in rebuild()
			JPanel centerPanel = new JPanel(new BorderLayout());
			centerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

			markerView.setLayout(new BoxLayout(markerView, BoxLayout.Y_AXIS));
			markerView.setBackground(ColorScheme.DARK_GRAY_COLOR);
			markerView.add(errorPanel);

			centerPanel.add(markerView, BorderLayout.NORTH);

			// setup panels border layout
			add(northPanel, BorderLayout.NORTH);
			add(centerPanel, BorderLayout.CENTER);
		}

		public void rebuild()
		{
			markerView.removeAll();
			List<PortTask> currentTasks = plugin.getCurrentTasks();
			for (PortTask task : currentTasks)
			{
				markerView.add(new PortTaskPanel(plugin, task, task.getSlot()));
				markerView.add(Box.createRigidArea(new Dimension(0, 10)));
			}
			if (currentTasks.isEmpty())
			{
				setupErrorPanel(true);
			}
			repaint();
			revalidate();
		}

		private void addMarker()
		{
			setupErrorPanel(false);
		}

		private void setupErrorPanel(boolean enabled)
		{
			PluginErrorPanel errorPanel = this.errorPanel;
			errorPanel.setVisible(enabled);
			if (enabled)
			{
				errorPanel.setContent("Port Tasks", "Click the 'reload' button to read the Port Task client data.");
				markerView.removeAll();
				markerView.setLayout(new BoxLayout(markerView, BoxLayout.Y_AXIS));
				markerView.setBackground(ColorScheme.DARK_GRAY_COLOR);
				markerView.add(errorPanel);
			}
		}
}
/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks.ui.adapters;

import javax.swing.ImageIcon;
import javax.swing.JLabel;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

import com.nucleon.porttasks.PortTask;
import com.nucleon.porttasks.PortTasksPlugin;
import com.nucleon.porttasks.ui.PortTaskPanel;
import net.runelite.client.util.ImageUtil;

public class HidePortTaskSlotOverlay extends MouseAdapter
{
private final JLabel hideMarker;
private final PortTask portTask;
private final PortTaskPanel panel;
private final PortTasksPlugin plugin;
private static final ImageIcon VISIBLE_HOVER_ICON;
private static final ImageIcon INVISIBLE_HOVER_ICON;

static
{
	final BufferedImage visibleImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "visible_icon.png");
	VISIBLE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(visibleImg, -100));

	final BufferedImage invisibleImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "invisible_icon.png");
	INVISIBLE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(invisibleImg, -100));
}

public HidePortTaskSlotOverlay(JLabel hideMarker, PortTask portTask, PortTaskPanel panel, PortTasksPlugin plugin)
{
	this.hideMarker = hideMarker;
	this.portTask = portTask;
	this.panel = panel;
	this.plugin = plugin;
}

@Override
public void mousePressed(MouseEvent mouseEvent)
{
	portTask.setTracking(!portTask.isTracking());
	panel.updateVisibility();
	plugin.saveSlotSettings();
}

@Override
public void mouseEntered(MouseEvent mouseEvent)
{
	hideMarker.setIcon(portTask.isTracking() ? VISIBLE_HOVER_ICON : INVISIBLE_HOVER_ICON);
}

@Override
public void mouseExited(MouseEvent mouseEvent)
{
	panel.updateVisibility();
}
}

/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks.ui.adapters;


import javax.swing.ImageIcon;
import javax.swing.JLabel;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

import com.nucleon.porttasks.PortTasksPlugin;
import com.nucleon.porttasks.ui.PortTaskPanel;

import net.runelite.client.util.ImageUtil;

public class PortTaskSlotOverlayColor extends MouseAdapter
{
private final JLabel portSlotOverlay;
private final PortTaskPanel panel;
private static final ImageIcon BORDER_COLOR_ICON;
private static final ImageIcon BORDER_COLOR_HOVER_ICON;

static
{
	BufferedImage borderImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "border_color_icon.png");
	BufferedImage borderImgHover = ImageUtil.luminanceOffset(borderImg, -150);

	BORDER_COLOR_ICON = new ImageIcon(borderImg);
	BORDER_COLOR_HOVER_ICON = new ImageIcon(borderImgHover);
}
public PortTaskSlotOverlayColor(JLabel prayerMarkerColorLabel, PortTaskPanel panel)
{
	this.portSlotOverlay = prayerMarkerColorLabel;
	this.panel = panel;
}

@Override
public void mousePressed(MouseEvent mouseEvent)
{
	panel.openPortTaskColorPicker();
}

@Override
public void mouseEntered(MouseEvent mouseEvent)
{
	portSlotOverlay.setIcon(BORDER_COLOR_HOVER_ICON);
}

@Override
public void mouseExited(MouseEvent mouseEvent)
{
	portSlotOverlay.setIcon(BORDER_COLOR_ICON);
}
}

/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks.ui.adapters;

import com.nucleon.porttasks.PortTasksPlugin;

import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

public class ReloadPortTasks extends MouseAdapter
{
	private static final BufferedImage RELOAD_ICON = ImageUtil.loadImageResource(PortTasksPlugin.class, "reload.png");
	private static final ImageIcon RELOAD = new ImageIcon(RELOAD_ICON);
	private static final ImageIcon ADD_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(RELOAD_ICON, 0.53f));
	private final PortTasksPlugin plugin;
	private final JLabel markerAdd;
	private final Runnable onClick;

	public ReloadPortTasks(JLabel markerAdd, PortTasksPlugin plugin, Runnable onClick)
	{
		this.markerAdd = markerAdd;
		this.plugin = plugin;
		this.onClick = onClick;
	}

	@Override
	public void mousePressed(MouseEvent e)
	{
		//clientThread.invoke(plugin::readPortDataFromClientVarps); //todo:actually call from ct thats passed in
		onClick.run();
	}

	@Override
	public void mouseEntered(MouseEvent e)
	{
		markerAdd.setIcon(ADD_HOVER_ICON);
	}

	@Override
	public void mouseExited(MouseEvent e)
	{
		markerAdd.setIcon(RELOAD);
	}
}

/*
 * Copyright (c) 2019, Trevor <https://github.com/Trevor159>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks.overlay;

import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

import static net.runelite.api.Constants.REGION_SIZE;

public class Zone
{
	@Getter
	private final int minX;
	@Getter
	private final int maxX;
	@Getter
	private final int minY;
	@Getter
	private final int maxY;
	private int minPlane = 0;
	private int maxPlane = 2;

	//The first plane of the "Overworld"
	public Zone()
	{
		minX = 1152;
		maxX = 3903;
		minY = 2496;
		maxY = 4159;
		maxPlane = 0;
	}

	public Zone(WorldPoint p1, WorldPoint p2)
	{
		assert (p1 != null);
		assert (p2 != null);
		minX = Math.min(p1.getX(), p2.getX());
		maxX = Math.max(p1.getX(), p2.getX());
		minY = Math.min(p1.getY(), p2.getY());
		maxY = Math.max(p1.getY(), p2.getY());
		minPlane = Math.min(p1.getPlane(), p2.getPlane());
		maxPlane = Math.max(p1.getPlane(), p2.getPlane());
	}

	public Zone(WorldPoint p)
	{
		assert (p != null);
		minX = p.getX();
		maxX = p.getX();
		minY = p.getY();
		maxY = p.getY();
		minPlane = p.getPlane();
		maxPlane = p.getPlane();
	}

	public Zone(int regionID)
	{
		minX = ((regionID >> 8) & 0xFF) << 6;
		maxX = minX + REGION_SIZE;
		minY = (regionID & 0xFF) << 6;
		maxY = minY + REGION_SIZE;
	}

	public Zone(int regionID, int plane)
	{
		this(regionID);
		minPlane = plane;
		maxPlane = plane;
	}

	public boolean contains(WorldPoint worldPoint)
	{
		return minX <= worldPoint.getX()
				&& worldPoint.getX() <= maxX
				&& minY <= worldPoint.getY()
				&& worldPoint.getY() <= maxY
				&& minPlane <= worldPoint.getPlane()
				&& worldPoint.getPlane() <= maxPlane;
	}

	public WorldPoint getMinWorldPoint()
	{
		return new WorldPoint(minX, minY, minPlane);
	}
}

/*
 * Copyright (c) 2021, Zoinkwiz <https://github.com/Zoinkwiz>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 * nucleon <https://github.com/nucleon>
 * Modification: drawLinesOnWorld()
 * Interpolates long lines into shorter segments to bypass RuneLites overlay draw distance limit.
 */

package com.nucleon.porttasks.overlay;

import java.util.ArrayList;
import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.annotation.Nonnull;
import java.awt.*;
import java.awt.geom.Line2D;
import java.util.List;

public class WorldLines
{
	public static void createWorldMapLines(Graphics2D graphics, Client client, List<WorldPoint> linePoints, Color color)
	{
		Rectangle mapViewArea = WorldPerspective.getWorldMapClipArea(client);

		for (int i = 0; i < linePoints.size() - 1; i++)
		{
			Point startPoint = WorldPerspective.mapWorldPointToGraphicsPoint(client, linePoints.get(i));
			Point endPoint = WorldPerspective.mapWorldPointToGraphicsPoint(client, linePoints.get(i + 1));

			WorldLines.renderWorldMapLine(graphics, client, mapViewArea, startPoint, endPoint, color);
		}
	}

	public static void createMinimapLines(Graphics2D graphics, Client client, List<WorldPoint> linePoints, Color color)
	{
		if (linePoints == null || linePoints.size() < 2)
		{
			return;
		}
		for (int i = 0; i < linePoints.size() - 1; i++)
		{
			WorldPoint dontRenderPoint = new WorldPoint(0, 0, 0);
			WorldPoint currentPoint = linePoints.get(i);
			WorldPoint nextPoint = linePoints.get(i + 1);

			if (currentPoint == null || currentPoint.equals(dontRenderPoint) || nextPoint == null || nextPoint.equals(dontRenderPoint))
			{
			continue;
			}

			List<LocalPoint> startPoints = WorldPerspective.getInstanceLocalPointFromReal(client, currentPoint);
			List<LocalPoint> destinationPoints = WorldPerspective.getInstanceLocalPointFromReal(client, nextPoint);
			if (startPoints.isEmpty() || destinationPoints.isEmpty()) continue;
			LocalPoint startPoint = startPoints.get(0);
			LocalPoint destinationPoint = destinationPoints.get(0);

			Point startPosOnMinimap = net.runelite.api.Perspective.localToMinimap(client, startPoint, 10000000);
			Point destinationPosOnMinimap = net.runelite.api.Perspective.localToMinimap(client, destinationPoint, 10000000);

			if (destinationPosOnMinimap == null || startPosOnMinimap == null)
			{
				continue;
			}

			Line2D.Double line = new Line2D.Double(startPosOnMinimap.getX(), startPosOnMinimap.getY(), destinationPosOnMinimap.getX(), destinationPosOnMinimap.getY());

			Rectangle bounds = new Rectangle(0, 0, client.getCanvasWidth(), client.getCanvasHeight());
			Widget minimapWidget = client.getWidget(InterfaceID.ToplevelOsrsStretch.MINIMAP);

			if (minimapWidget == null)
			{
				minimapWidget = client.getWidget(InterfaceID.ToplevelPreEoc.MINIMAP);
			}
			if (minimapWidget == null)
			{
				minimapWidget = client.getWidget(InterfaceID.Toplevel.MINIMAP);
			}

			if (minimapWidget != null)
			{
				bounds = minimapWidget.getBounds();
			}

			DirectionArrow.drawLine(graphics, line, color, bounds);
		}
	}

	public static void renderWorldMapLine(Graphics2D graphics, Client client, Rectangle mapViewArea, Point startPoint, Point endPoint, Color color)
	{
		if (mapViewArea == null || startPoint == null || endPoint == null)
		{
			return;
		}
		if (!mapViewArea.contains(startPoint.getX(), startPoint.getY()) && !mapViewArea.contains(endPoint.getX(), endPoint.getY()))
		{
			return;
		}

		Line2D.Double line = new Line2D.Double(startPoint.getX(), startPoint.getY(), endPoint.getX(), endPoint.getY());
		DirectionArrow.drawLine(graphics, line, color, WorldPerspective.getWorldMapClipArea(client));
	}

	public static Line2D.Double getWorldLines(@Nonnull Client client, @Nonnull LocalPoint startLocation, LocalPoint endLocation)
	{
		final int plane = client.getPlane();

		final int startX = startLocation.getX();
		final int startY = startLocation.getY();
		final int endX = endLocation.getX();
		final int endY = endLocation.getY();

		final int sceneX = startLocation.getSceneX();
		final int sceneY = startLocation.getSceneY();

		if (sceneX < 0 || sceneY < 0 || sceneX >= Constants.SCENE_SIZE || sceneY >= Constants.SCENE_SIZE)
		{
			return null;
		}

		final int startHeight = net.runelite.api.Perspective.getTileHeight(client, startLocation, plane);
		final int endHeight = net.runelite.api.Perspective.getTileHeight(client, endLocation, plane);

		Point p1 = net.runelite.api.Perspective.localToCanvas(client, startX, startY, startHeight);
		Point p2 = net.runelite.api.Perspective.localToCanvas(client, endX, endY, endHeight);

		if (p1 == null || p2 == null)
		{
			return null;
		}

		return new Line2D.Double(p1.getX(), p1.getY(), p2.getX(), p2.getY());
	}

	public static void drawLinesOnWorld(Graphics2D graphics, Client client, List<WorldPoint> linePoints, Color color)
	{
		for (int i = 0; i < linePoints.size() - 1; i++)
		{
			WorldPoint startWp = linePoints.get(i);
			WorldPoint endWp = linePoints.get(i + 1);

			if (startWp == null || endWp == null) continue;
			if (startWp.equals(new WorldPoint(0, 0, 0))) continue;
			if (endWp.equals(new WorldPoint(0, 0, 0))) continue;
			if (startWp.getPlane() != endWp.getPlane()) continue;

			List<WorldPoint> interpolated = interpolateLine(startWp, endWp);

			for (int j = 0; j < interpolated.size() - 1; j++)
			{
				WorldPoint wp1 = interpolated.get(j);
				WorldPoint wp2 = interpolated.get(j + 1);

				List<LocalPoint> points1 = WorldPerspective.getInstanceLocalPointFromReal(client, wp1);
				List<LocalPoint> points2 = WorldPerspective.getInstanceLocalPointFromReal(client, wp2);

				if (points1.isEmpty() || points2.isEmpty()) continue;

				LocalPoint lp1 = points1.get(0);
				LocalPoint lp2 = points2.get(0);

				Line2D.Double newLine = getWorldLines(client, lp1, lp2);
				if (newLine != null)
				{
						OverlayUtil.renderPolygon(graphics, newLine, color);
				}
			}
		}
	}

	private static List<WorldPoint> interpolateLine(WorldPoint start, WorldPoint end)
	{
		List<WorldPoint> result = new ArrayList<>();
		int steps = Math.max(start.distanceTo(end), 1);

		for (int i = 0; i <= steps; i++)
		{
			double t = i / (double) steps;
			int x = (int) Math.round(lerp(start.getX(), end.getX(), t));
			int y = (int) Math.round(lerp(start.getY(), end.getY(), t));
			int plane = start.getPlane();
			result.add(new WorldPoint(x, y, plane));
		}

		return result;
	}

	private static double lerp(int a, int b, double t)
	{
		return a + (b - a) * t;
	}
}

/*
 * Copyright (c) 2021, Zoinkwiz <https://github.com/Zoinkwiz>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks.overlay;

import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.Widget;

import java.awt.*;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import static net.runelite.api.Constants.CHUNK_SIZE;

public class WorldPerspective
{
// Order of poly corners from getCanvasTilePoly
private final static int SW = 0;
private final static int NW = 3;
private final static int NE = 2;
private final static int SE = 1;

	public static Collection<WorldPoint> toLocalInstanceFromReal(Client client, WorldPoint worldPoint)
	{
		if (!client.isInInstancedRegion())
		{
			return Collections.singleton(worldPoint);
		}

		if (worldPoint == null) return Collections.singleton(null);

		// find instance chunks using the template point. there might be more than one.
		List<WorldPoint> worldPoints = new ArrayList<>();

		int[][][] instanceTemplateChunks = client.getInstanceTemplateChunks();
		for (int z = 0; z < instanceTemplateChunks.length; ++z)
		{
			for (int x = 0; x < instanceTemplateChunks[z].length; ++x)
			{
				for (int y = 0; y < instanceTemplateChunks[z][x].length; ++y)
				{
					int chunkData = instanceTemplateChunks[z][x][y];
					int rotation = chunkData >> 1 & 0x3;
					int templateChunkY = (chunkData >> 3 & 0x7FF) * CHUNK_SIZE;
					int templateChunkX = (chunkData >> 14 & 0x3FF) * CHUNK_SIZE;
					if (worldPoint.getX() >= templateChunkX && worldPoint.getX() < templateChunkX + CHUNK_SIZE
							&& worldPoint.getY() >= templateChunkY && worldPoint.getY() < templateChunkY + CHUNK_SIZE)
					{
						WorldPoint p =
								new WorldPoint(client.getBaseX() + x * CHUNK_SIZE + (worldPoint.getX() & (CHUNK_SIZE - 1)),
										client.getBaseY() + y * CHUNK_SIZE + (worldPoint.getY() & (CHUNK_SIZE - 1)),
										z);
						p = rotate(p, rotation);
						if (p.isInScene(client))
						{
							worldPoints.add(p);
						}
					}
				}
			}
		}
		return worldPoints;
	}

	private static WorldPoint rotate(WorldPoint point, int rotation)
	{
		int chunkX = point.getX() & -CHUNK_SIZE;
		int chunkY = point.getY() & -CHUNK_SIZE;
		int x = point.getX() & (CHUNK_SIZE - 1);
		int y = point.getY() & (CHUNK_SIZE - 1);
		switch (rotation)
		{
			case 1:
				return new WorldPoint(chunkX + y, chunkY + (CHUNK_SIZE - 1 - x), point.getPlane());
			case 2:
				return new WorldPoint(chunkX + (CHUNK_SIZE - 1 - x), chunkY + (CHUNK_SIZE - 1 - y), point.getPlane());
			case 3:
				return new WorldPoint(chunkX + (CHUNK_SIZE - 1 - y), chunkY + x, point.getPlane());
		}
		return point;
	}

	public static List<LocalPoint> getInstanceLocalPointFromReal(Client client, WorldPoint wp)
	{
		List<WorldPoint> instanceWorldPoint = new ArrayList<>(WorldPerspective.toLocalInstanceFromReal(client, wp));

		List<LocalPoint> localPoints = new ArrayList<>();
		for (WorldPoint worldPoint : instanceWorldPoint)
		{
			LocalPoint lp = LocalPoint.fromWorld(client.getTopLevelWorldView(), worldPoint);
			if (lp != null)
			{
				localPoints.add(lp);
			}
		}

		return localPoints;
	}

	public static WorldPoint getInstanceWorldPointFromReal(Client client, WorldPoint wp)
	{
		if (wp == null) return null;
		Collection<WorldPoint> points = WorldPerspective.toLocalInstanceFromReal(client, wp);

		if (points.isEmpty()) return null;

		WorldPoint p = null;
		for (WorldPoint point : points)
		{
			if (point != null)
			{
				p = point;
			}
		}
		return p;
	}

	public static WorldPoint getRealWorldPointFromLocal(Client client, WorldPoint wp)
	{
		LocalPoint lp = LocalPoint.fromWorld(client.getTopLevelWorldView(), wp);
		if (lp == null) return null;

		return WorldPoint.fromLocalInstance(client, lp);
	}

	public static Rectangle getWorldMapClipArea(Client client)
	{
		Widget widget = client.getWidget(InterfaceID.Worldmap.MAP_CONTAINER);
		if (widget == null)
		{
			return null;
		}

		return widget.getBounds();
	}

	public static Point mapWorldPointToGraphicsPoint(Client client, WorldPoint worldPoint)
	{
		var worldMap = client.getWorldMap();
		if (worldPoint == null) return null;
		if (!worldMap.getWorldMapData().surfaceContainsPosition(worldPoint.getX(), worldPoint.getY()))
		{
			return null;
		}

		float pixelsPerTile = worldMap.getWorldMapZoom();

		Widget map = client.getWidget(InterfaceID.Worldmap.MAP_CONTAINER);
		if (map != null)
		{
			Rectangle worldMapRect = map.getBounds();

			int widthInTiles = (int) Math.ceil(worldMapRect.getWidth() / pixelsPerTile);
			int heightInTiles = (int) Math.ceil(worldMapRect.getHeight() / pixelsPerTile);

			var worldMapPosition = worldMap.getWorldMapPosition();

			//Offset in tiles from anchor sides
			int yTileMax = worldMapPosition.getY() - heightInTiles / 2;
			int yTileOffset = (yTileMax - worldPoint.getY() - 1) * -1;
			int xTileOffset = worldPoint.getX() + widthInTiles / 2 - worldMapPosition.getX();

			int xGraphDiff = ((int) (xTileOffset * pixelsPerTile));
			int yGraphDiff = (int) (yTileOffset * pixelsPerTile);

			//Center on tile.
			yGraphDiff -= pixelsPerTile - Math.ceil(pixelsPerTile / 2);
			xGraphDiff += pixelsPerTile - Math.ceil(pixelsPerTile / 2);

			yGraphDiff = worldMapRect.height - yGraphDiff;
			yGraphDiff += (int) worldMapRect.getY();
			xGraphDiff += (int) worldMapRect.getX();

			return new Point(xGraphDiff, yGraphDiff);
		}
		return null;
	}

	public static Point getMinimapPoint(Client client, WorldPoint start, WorldPoint destination)
	{
		var worldMapData = client.getWorldMap().getWorldMapData();
		if (worldMapData.surfaceContainsPosition(start.getX(), start.getY()) !=
				worldMapData.surfaceContainsPosition(destination.getX(), destination.getY()))
		{
			return null;
		}

		int x = (destination.getX() - start.getX());
		int y = (destination.getY() - start.getY());

		float maxDistance = Math.max(Math.abs(x), Math.abs(y));
		x = x * 100;
		y = y * 100;
		x /= maxDistance;
		y /= maxDistance;

		Widget minimapDrawWidget;
		if (client.isResized())
		{
			if (client.getVarbitValue(VarbitID.RESIZABLE_STONE_ARRANGEMENT) == 1)
			{
				minimapDrawWidget = client.getWidget(InterfaceID.ToplevelPreEoc.MINIMAP);
			}
			else
			{
				minimapDrawWidget = client.getWidget(InterfaceID.ToplevelOsrsStretch.MINIMAP);
			}
		}
		else
		{
			minimapDrawWidget = client.getWidget(InterfaceID.Toplevel.MINIMAP);
		}

		if (minimapDrawWidget == null)
		{
			return null;
		}

		final int angle = client.getCameraYawTarget() & 0x7FF;

		final int sin = net.runelite.api.Perspective.SINE[angle];
		final int cos = net.runelite.api.Perspective.COSINE[angle];

		final int xx = y * sin + cos * x >> 16;
		final int yy = sin * x - y * cos >> 16;

		Point loc = minimapDrawWidget.getCanvasLocation();
		int miniMapX = loc.getX() + xx + minimapDrawWidget.getWidth() / 2;
		int miniMapY = minimapDrawWidget.getHeight() / 2 + loc.getY() + yy;
		return new Point(miniMapX, miniMapY);
	}

	public static Polygon getZonePoly(Client client, Zone zone)
	{
		Polygon areaPoly = new Polygon();
		if (zone == null) return areaPoly;

		for (int x = zone.getMinX(); x < zone.getMaxX(); x++)
		{
			addToPoly(client, areaPoly, new WorldPoint(x, zone.getMaxY(), zone.getMinWorldPoint().getPlane()), NW);
		}

		// NE corner
		addToPoly(client, areaPoly, new WorldPoint(zone.getMaxX(), zone.getMaxY(), zone.getMinWorldPoint().getPlane()), NW, NE, SE);

		// West side
		for (int y = zone.getMaxY() - 1; y > zone.getMinY(); y--)
		{
			addToPoly(client, areaPoly, new WorldPoint(zone.getMaxX(), y, zone.getMinWorldPoint().getPlane()), SE);
		}

		// SE corner
		addToPoly(client, areaPoly, new WorldPoint(zone.getMaxX(), zone.getMinY(), zone.getMinWorldPoint().getPlane()), SE, SW);

		// South side
		for (int x = zone.getMaxX() - 1; x > zone.getMinX(); x--)
		{
			addToPoly(client, areaPoly, new WorldPoint(x, zone.getMinY(), zone.getMinWorldPoint().getPlane()), SW);
		}

		// SW corner
		addToPoly(client, areaPoly, new WorldPoint(zone.getMinX(), zone.getMinY(), zone.getMinWorldPoint().getPlane()), SW, NW);

		for (int y = zone.getMinY() + 1; y < zone.getMaxY(); y++)
		{
			addToPoly(client, areaPoly, new WorldPoint(zone.getMinX(), y, zone.getMinWorldPoint().getPlane()), NW);
		}


		return areaPoly;
	}

	private static void addToPoly(Client client, Polygon areaPoly, WorldPoint wp, int... points)
	{
		LocalPoint localPoint = LocalPoint.fromWorld(client.getTopLevelWorldView(), wp);
		if (localPoint == null) return;

		Polygon poly = net.runelite.api.Perspective.getCanvasTilePoly(client, localPoint);
		if (poly != null)
		{
			for (int point : points)
			{
				areaPoly.addPoint(poly.xpoints[point], poly.ypoints[point]);
			}
		}
	}
}
/*
 * Copyright (c) 2021, Zoinkwiz <https://github.com/Zoinkwiz>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks.overlay;


import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Player;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;

import java.awt.*;
import java.awt.geom.AffineTransform;
import java.awt.geom.Line2D;
import java.util.List;

public class DirectionArrow
{
	/**
	 * @param client the {@link Client}
	 * @return the rough number of tiles distance the minimap can draw
	 */
	public static int getMaxMinimapDrawDistance(Client client)
	{
		var minimapZoom = client.getMinimapZoom();
		if (minimapZoom > 0.0)
		{
			return (int) (64.0 / client.getMinimapZoom());
		}
		return 16;
	}

	public static void renderMinimapArrowFromLocal(Graphics2D graphics, Client client, LocalPoint localPoint, Color color)
	{
		var maxMinimapDrawDistance = getMaxMinimapDrawDistance(client);
		Player player = client.getLocalPlayer();
		if (player == null)
		{
			return;
		}

		if (localPoint == null)
		{
			return;
		}

		WorldPoint playerRealLocation = WorldPoint.fromLocalInstance(client, player.getLocalLocation());
		WorldPoint goalRealLocation = WorldPoint.fromLocalInstance(client, localPoint);
		if (playerRealLocation == null) return;

		if (goalRealLocation.distanceTo(playerRealLocation) >= maxMinimapDrawDistance)
		{
			createMinimapDirectionArrow(graphics, client, playerRealLocation, goalRealLocation, color);
			return;
		}

		Point posOnMinimap = Perspective.localToMinimap(client, localPoint);
		if (posOnMinimap == null)
		{
			return;
		}

		Line2D.Double line = new Line2D.Double(posOnMinimap.getX(), posOnMinimap.getY() - 18, posOnMinimap.getX(),
				posOnMinimap.getY() - 8);

		drawMinimapArrow(graphics, line, color);

	}

	public static void renderMinimapArrow(Graphics2D graphics, Client client, WorldPoint worldPoint, Color color)
	{
		var maxMinimapDrawDistance = getMaxMinimapDrawDistance(client);
		Player player = client.getLocalPlayer();
		if (player == null)
		{
			return;
		}

		if (worldPoint == null)
		{
			return;
		}

		WorldPoint playerRealLocation = WorldPoint.fromLocalInstance(client, player.getLocalLocation());
		if (playerRealLocation == null) return;

		if (worldPoint.distanceTo(playerRealLocation) >= maxMinimapDrawDistance)
		{
			createMinimapDirectionArrow(graphics, client, playerRealLocation, worldPoint, color);
			return;
		}

		List<LocalPoint> localPoints = WorldPerspective.getInstanceLocalPointFromReal(client, worldPoint);

		for (LocalPoint localPoint : localPoints)
		{
			Point posOnMinimap = Perspective.localToMinimap(client, localPoint);
			if (posOnMinimap == null)
			{
				continue;
			}

			Line2D.Double line = new Line2D.Double(posOnMinimap.getX(), posOnMinimap.getY() - 18, posOnMinimap.getX(),
					posOnMinimap.getY() - 8);

			drawMinimapArrow(graphics, line, color);
		}
	}

	protected static void createMinimapDirectionArrow(Graphics2D graphics, Client client, WorldPoint playerRealWp, WorldPoint wp, Color color)
	{
		Player player = client.getLocalPlayer();

		if (player == null)
		{
			return;
		}

		if (wp == null)
		{
			return;
		}

		Point playerPosOnMinimap = player.getMinimapLocation();

		Point destinationPosOnMinimap = WorldPerspective.getMinimapPoint(client, playerRealWp, wp);

		if (playerPosOnMinimap == null || destinationPosOnMinimap == null)
		{
			return;
		}

		double xDiff = playerPosOnMinimap.getX() - destinationPosOnMinimap.getX();
		double yDiff = destinationPosOnMinimap.getY() - playerPosOnMinimap.getY();
		double angle = Math.atan2(yDiff, xDiff);

		int startX = (int) (playerPosOnMinimap.getX() - (Math.cos(angle) * 55));
		int startY = (int) (playerPosOnMinimap.getY() + (Math.sin(angle) * 55));

		int endX = (int) (playerPosOnMinimap.getX() - (Math.cos(angle) * 65));
		int endY = (int) (playerPosOnMinimap.getY() + (Math.sin(angle) * 65));

		Line2D.Double line = new Line2D.Double(startX, startY, endX, endY);

		drawMinimapArrow(graphics, line, color);
	}

	public static void drawWorldArrow(Graphics2D graphics, Color color, int startX, int startY)
	{
		Line2D.Double line = new Line2D.Double(startX, startY - 13, startX, startY);

		int headWidth = 5;
		int headHeight = 4;
		int lineWidth = 9;

		drawArrow(graphics, line, color, lineWidth, headHeight, headWidth);
	}

	public static void drawMinimapArrow(Graphics2D graphics, Line2D.Double line, Color color)
	{
		drawArrow(graphics, line, color, 6, 2, 2);
	}

	public static void drawArrow(Graphics2D graphics, Line2D.Double line, Color color, int width, int tipHeight, int tipWidth)
	{
		graphics.setColor(Color.BLACK);
		graphics.setStroke(new BasicStroke(width));
		graphics.draw(line);
		drawWorldArrowHead(graphics, line, tipHeight, tipWidth);

		graphics.setColor(color);
		graphics.setStroke(new BasicStroke(width - 3));
		graphics.draw(line);
		drawWorldArrowHead(graphics, line, tipHeight - 2, tipWidth - 2);
		graphics.setStroke(new BasicStroke(1));
	}


	public static void drawWorldArrowHead(Graphics2D g2d, Line2D.Double line, int extraSizeHeight, int extraSizeWidth)
	{
		AffineTransform tx = new AffineTransform();

		Polygon arrowHead = new Polygon();
		arrowHead.addPoint(0, 6 + extraSizeHeight);
		arrowHead.addPoint(-6 - extraSizeWidth, -1 - extraSizeHeight);
		arrowHead.addPoint(6 + extraSizeWidth, -1 - extraSizeHeight);

		tx.setToIdentity();
		double angle = Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
		tx.translate(line.x2, line.y2);
		tx.rotate((angle - Math.PI / 2d));

		Graphics2D g = (Graphics2D) g2d.create();
		g.setTransform(tx);
		g.fill(arrowHead);
		g.dispose();
	}

	public static void drawLineArrowHead(Graphics2D g2d, Line2D.Double line)
	{
		AffineTransform tx = new AffineTransform();
		Polygon arrowHead = new Polygon();
		arrowHead.addPoint(0, 0);
		arrowHead.addPoint(-3, -6);
		arrowHead.addPoint(3, -6);
		tx.setToIdentity();
		double angle = Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
		tx.translate(line.x2, line.y2);
		tx.rotate((angle - Math.PI / 2d));
		Graphics2D graphics2D = (Graphics2D) g2d.create();
		graphics2D.setTransform(tx);
		graphics2D.fill(arrowHead);
		graphics2D.dispose();
	}

	public static void drawLine(Graphics2D graphics, Line2D.Double line, Color color, Rectangle clippingRegion)
	{
		graphics.setStroke(new BasicStroke(1));
		graphics.setClip(clippingRegion);
		graphics.setColor(color);
		graphics.draw(line);
		drawLineArrowHead(graphics, line);
	}
}

/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.List;

import javax.inject.Inject;

import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;

import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

class PortTasksMiniMapOverlay extends Overlay
{
	private final Client client;
	private final PortTasksPlugin plugin;
	private final PortTasksConfig config;

	@Inject
	private PortTasksMiniMapOverlay(Client client, PortTasksPlugin plugin, PortTasksConfig config)
	{
		this.client = client;
		this.plugin = plugin;
		this.config = config;

		setPosition(OverlayPosition.DYNAMIC);
		setPriority(Overlay.PRIORITY_HIGHEST);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		renderOverlayLines(graphics);
		return null;
	}

	private void renderOverlayLines(Graphics2D g)
	{
		for (PortTask tasks : plugin.currentTasks)
		{
			Color overlayColor = tasks.getOverlayColor();
			List<WorldPoint> navigationPoints = tasks.getData().dockMarkers.getFullPath();
			if (tasks.isTracking())
			{
				//Getting inside a boat, seems to load a different minimap (?) - nucleon
				//WorldLines.createMinimapLines(g, client, navigationPoints, overlayColor);
			}
		}
	}
}
/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks;

import java.awt.Color;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup(PortTasksConfig.CONFIG_GROUP)
public interface PortTasksConfig extends Config
{
	String CONFIG_GROUP = "porttasks";
	@ConfigItem(
		keyName = "navColor",
		name = "Navigation Line Color",
		description = "The color of the navigation line"
	)
	default Color getNavColor()
	{
		return Color.GREEN;
	}
	enum Overlay
	{
		NONE,
		MAP,
		WORLD,
		BOTH
	}
	@ConfigItem(
		keyName = "drawOverlay",
		name = "Draw path",
		description = "Draw path for port task"
	)
	default Overlay getDrawOverlay()
	{
		return Overlay.BOTH;
	}
}

/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PortTasksPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(PortTasksPlugin.class);
		RuneLite.main(args);
	}
}
