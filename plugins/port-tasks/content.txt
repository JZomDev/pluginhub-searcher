/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks;

import com.nucleon.porttasks.enums.BountyTaskData;

import lombok.Getter;
import lombok.Setter;
import lombok.AllArgsConstructor;

import java.awt.Color;

@Getter
@Setter
@AllArgsConstructor
public class BountyTask implements Task
{
	private BountyTaskData data;
	private int slot;
	private boolean taken; // accepted?
	private int delivered;
	private boolean tracking;
	private boolean active;
	private Color overlayColor;
	public int itemsCollected;
}

/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks;


import lombok.Getter;
import lombok.Setter;
import lombok.AllArgsConstructor;

import java.awt.Color;

@Getter
@Setter
@AllArgsConstructor
public class CourierTask implements Task
{
	private CourierTaskData data;
	private int slot;
	private boolean taken;
	private int delivered;
	private boolean tracking;
	private boolean active;
	private Color overlayColor;
	private int cargoTaken;
}

/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks;

import com.nucleon.porttasks.enums.PortLocation;
import com.nucleon.porttasks.enums.PortPaths;
import com.nucleon.porttasks.enums.TaskReward;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.gameval.DBTableID;

@Getter
public final class CourierTaskData
{
	private final int dbrow;
	private final int id;
	private final PortLocation noticeBoard;
	private final PortLocation cargoLocation;
	private final PortLocation deliveryLocation;
	public final PortPaths dockMarkers;
	public final boolean reversePath;
	public final String taskName;
	public final int cargo;
	public final int cargoAmount;
	private final double xpPerTile;

	private static final Set<Integer> VARBIT_VALUES = new HashSet<>();
	private static final Map<Integer, CourierTaskData> BY_DBROW = new HashMap<>();
	private static final Map<Integer, CourierTaskData> BY_ID = new HashMap<>();

	private static double MAX_XP_PER_TILE;

	private CourierTaskData(int dbrow, int id, PortLocation noticeBoard, PortLocation cargoLocation, PortLocation deliveryLocation, PortPaths dockMarkers, boolean reversePath, String taskName, int cargo, int cargoAmount, double xpPerTile)
	{
		this.dbrow = dbrow;
		this.id = id;
		this.noticeBoard = noticeBoard;
		this.cargoLocation = cargoLocation;
		this.deliveryLocation = deliveryLocation;
		this.dockMarkers = dockMarkers;
		this.reversePath = reversePath;
		this.taskName = taskName;
		this.cargo = cargo;
		this.cargoAmount = cargoAmount;
		this.xpPerTile = xpPerTile;
	}

	public static void loadFromCache(Client client)
	{
		BY_DBROW.clear();
		BY_ID.clear();
		VARBIT_VALUES.clear();
		MAX_XP_PER_TILE = 0.0;

		for (int rowId : client.getDBTableRows(DBTableID.PortTask.ID))
		{
			CourierTaskData data = fromRow(client, rowId);

			if (data == null)
			{
				continue;
			}

			BY_DBROW.put(data.dbrow, data);
			BY_ID.put(data.id, data);
			VARBIT_VALUES.add(data.id);

			if (data.xpPerTile > MAX_XP_PER_TILE)
			{
				MAX_XP_PER_TILE = data.xpPerTile;
			}
		}
	}

	private static CourierTaskData fromRow(Client client, int dbrow)
	{
		Integer id = getIntField(client, dbrow, DBTableID.PortTask.COL_TASK_ID, 0);
		if (id == null)
		{
			return null;
		}

		Integer noticeBoardDbRow = getIntField(client, dbrow, DBTableID.PortTask.COL_STARTING_PORT, 0);
		if (noticeBoardDbRow == null)
		{
			return null;
		}
		PortLocation noticeBoard = PortLocation.fromDbRow(noticeBoardDbRow);

		Integer cargoLocationDbRow = getIntField(client, dbrow, DBTableID.PortTask.COL_CARGO_PORT, 0);
		if (cargoLocationDbRow == null)
		{
			return null;
		}
		PortLocation cargoLocation = PortLocation.fromDbRow(cargoLocationDbRow);

		Integer deliveryLocationDbRow = getIntField(client, dbrow, DBTableID.PortTask.COL_ENDING_PORT, 0);
		if (deliveryLocationDbRow == null)
		{
			return null;
		}
		PortLocation deliveryLocation = PortLocation.fromDbRow(deliveryLocationDbRow);

		if (cargoLocationDbRow.equals(deliveryLocationDbRow))
		{
			// This is a bounty task
			return null;
		}

		if (cargoLocation == PortLocation.EMPTY || deliveryLocation == PortLocation.EMPTY)
		{
			// Used for quests
			return null;
		}

		PortPathMatch match = PortPaths.findPath(cargoLocation, deliveryLocation);
		PortPaths dockMarkers = match.getPath();
		boolean reversePath = match.isReversed();

		String taskName = (String) client.getDBTableField(dbrow, DBTableID.PortTask.COL_NAME, 0)[0];


		Integer cargo = getIntField(client, dbrow, DBTableID.PortTask.COL_CARGO, 0);
		Integer cargoAmount = getIntField(client, dbrow, DBTableID.PortTask.COL_CARGO, 1);

		int reward = TaskReward.getIntRewardForTask(dbrow);
		double distance = dockMarkers.getDistance();
		double xpPerTile = distance > 0 ? ( reward / distance) : 0.0;

		return new CourierTaskData(dbrow, id, noticeBoard, cargoLocation, deliveryLocation, dockMarkers, reversePath, taskName, cargo, cargoAmount, xpPerTile);
	}

	private static Integer getIntField(Client client, int rowId, int col, int tupleIndex, int objectIndex)
	{
		Object[] field = client.getDBTableField(rowId, col, tupleIndex);
		if (field == null || field.length == 0)
		{
			return null;
		}
		return (int) field[objectIndex];
	}

	private static Integer getIntField(Client client, int rowId, int col, int tupleIndex)
	{
		return getIntField(client, rowId, col, tupleIndex, 0);
	}

	public static CourierTaskData getByDbrow(int dbrow)
	{
		return BY_DBROW.get(dbrow);
	}

	public static boolean isCargoTask(int varbitValue)
	{
		return VARBIT_VALUES.contains(varbitValue);
	}

	public static CourierTaskData fromId(int id)
	{
		return BY_ID.get(id);
	}

	public double getXpPerTileRatio()
	{
		return MAX_XP_PER_TILE > 0.0 ? (xpPerTile / MAX_XP_PER_TILE) : 0.0;
	}

}


/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks.enums;

import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import lombok.Getter;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.NpcID;

@Getter
public enum BountyTaskData
{
	PORT_SARIM_TERN_BOUNTY_438(9101, 438, PortLocation.PORT_SARIM, "Port Sarim tern bounty", ItemID.SAILING_TERN_FEATHER, NpcID.SAILING_TERN, NpcID.SAILING_TERN_DEAD, 3, 3),
	PORT_SARIM_MOGRE_BOUNTY_439(9102, 439, PortLocation.PORT_SARIM, "Port Sarim mogre bounty", ItemID.SAILING_SEA_MOGRE_MACE, NpcID.SAILING_SEA_MOGRE, NpcID.SAILING_SEA_MOGRE_DEAD, 3, 3),
	PORT_SARIM_BULL_SHARK_BOUNTY_440(9103, 440, PortLocation.PORT_SARIM, "Port Sarim bull shark bounty", ItemID.SAILING_BULL_SHARK_JAW, NpcID.SAILING_BULL_SHARK, NpcID.SAILING_BULL_SHARK_DEAD, 3, 3),
	PORT_SARIM_TIGER_SHARK_BOUNTY_441(9104, 441, PortLocation.PORT_SARIM, "Port Sarim tiger shark bounty", ItemID.SAILING_TIGER_SHARK_JAW, NpcID.SAILING_TIGER_SHARK, NpcID.SAILING_TIGER_SHARK_DEAD, 5, 2),
	PORT_SARIM_OSPREY_BOUNTY_442(9105, 442, PortLocation.PORT_SARIM, "Port Sarim osprey bounty", ItemID.SAILING_OSPREY_BEAK, NpcID.SAILING_OSPREY, NpcID.SAILING_OSPREY_DEAD, 1, 10),
	PORT_SARIM_BULL_SHARK_BOUNTY_443(9106, 443, PortLocation.PORT_SARIM, "Port Sarim bull shark bounty", ItemID.SAILING_BULL_SHARK_LIVER, NpcID.SAILING_BULL_SHARK, NpcID.SAILING_BULL_SHARK_DEAD, 1, 10),
	PORT_SARIM_PYGMY_KRAKEN_BOUNTY_444(9107, 444, PortLocation.PORT_SARIM, "Port Sarim pygmy kraken bounty", ItemID.SAILING_PYGMY_KRAKEN_INK_SAC, NpcID.SAILING_PYGMY_KRAKEN, NpcID.SAILING_PYGMY_KRAKEN_DEAD, 1, 10),
	PANDEMONIUM_BULL_SHARK_BOUNTY_445(9108, 445, PortLocation.PANDEMONIUM, "Pandemonium bull shark bounty", ItemID.SAILING_BULL_SHARK_JAW, NpcID.SAILING_BULL_SHARK, NpcID.SAILING_BULL_SHARK_DEAD, 3, 3),
	PANDEMONIUM_MOGRE_BOUNTY_446(9109, 446, PortLocation.PANDEMONIUM, "Pandemonium mogre bounty", ItemID.SAILING_SEA_MOGRE_MACE, NpcID.SAILING_SEA_MOGRE, NpcID.SAILING_SEA_MOGRE_DEAD, 3, 3),
	PANDEMONIUM_OSPREY_BOUNTY_447(9110, 447, PortLocation.PANDEMONIUM, "Pandemonium osprey bounty", ItemID.SAILING_OSPREY_FEATHER, NpcID.SAILING_OSPREY, NpcID.SAILING_OSPREY_DEAD, 3, 3),
	PANDEMONIUM_BUTTERFLY_RAY_BOUNTY_448(9111, 448, PortLocation.PANDEMONIUM, "Pandemonium butterfly ray bounty", ItemID.SAILING_BUTTERFLY_RAY_FIN, NpcID.SAILING_BUTTERFLY_RAY, NpcID.SAILING_BUTTERFLY_RAY_DEAD, 3, 3),
	PANDEMONIUM_TERN_BOUNTY_449(9112, 449, PortLocation.PANDEMONIUM, "Pandemonium tern bounty", ItemID.SAILING_TERN_BEAK, NpcID.SAILING_TERN, NpcID.SAILING_TERN_DEAD, 1, 10),
	PANDEMONIUM_HAMMERHEAD_SHARK_BOUNTY_450(9113, 450, PortLocation.PANDEMONIUM, "Pandemonium hammerhead shark bounty", ItemID.SAILING_HAMMERHEAD_SHARK_LIVER, NpcID.SAILING_HAMMERHEAD_SHARK, NpcID.SAILING_HAMMERHEAD_SHARK_DEAD, 1, 10),
	PANDEMONIUM_FRIGATEBIRD_BOUNTY_451(9114, 451, PortLocation.PANDEMONIUM, "Pandemonium frigatebird bounty", ItemID.SAILING_FRIGATEBIRD_BEAK, NpcID.SAILING_FRIGATEBIRD, NpcID.SAILING_FRIGATEBIRD_DEAD, 1, 10),
	MUSA_POINT_BULL_SHARK_BOUNTY_452(9115, 452, PortLocation.MUSA_POINT, "Musa Point bull shark bounty", ItemID.SAILING_BULL_SHARK_JAW, NpcID.SAILING_BULL_SHARK, NpcID.SAILING_BULL_SHARK_DEAD, 3, 3),
	MUSA_POINT_MOGRE_BOUNTY_453(9116, 453, PortLocation.MUSA_POINT, "Musa Point mogre bounty", ItemID.SAILING_SEA_MOGRE_MACE, NpcID.SAILING_SEA_MOGRE, NpcID.SAILING_SEA_MOGRE_DEAD, 3, 3),
	MUSA_POINT_TERN_BOUNTY_454(9117, 454, PortLocation.MUSA_POINT, "Musa Point tern bounty", ItemID.SAILING_TERN_FEATHER, NpcID.SAILING_TERN, NpcID.SAILING_TERN_DEAD, 3, 3),
	MUSA_POINT_BUTTERFLY_RAY_BOUNTY_455(9118, 455, PortLocation.MUSA_POINT, "Musa Point butterfly ray bounty", ItemID.SAILING_BUTTERFLY_RAY_FIN, NpcID.SAILING_BUTTERFLY_RAY, NpcID.SAILING_BUTTERFLY_RAY_DEAD, 3, 3),
	MUSA_POINT_EAGLE_RAY_BOUNTY_456(9119, 456, PortLocation.MUSA_POINT, "Musa Point eagle ray bounty", ItemID.SAILING_EAGLE_RAY_SKIN, NpcID.SAILING_EAGLE_RAY, NpcID.SAILING_EAGLE_RAY_DEAD, 1, 10),
	MUSA_POINT_BULL_SHARK_BOUNTY_457(9120, 457, PortLocation.MUSA_POINT, "Musa Point bull shark bounty", ItemID.SAILING_BULL_SHARK_LIVER, NpcID.SAILING_BULL_SHARK, NpcID.SAILING_BULL_SHARK_DEAD, 1, 10),
	MUSA_POINT_HAMMERHEAD_SHARK_BOUNTY_458(9121, 458, PortLocation.MUSA_POINT, "Musa Point hammerhead shark bounty", ItemID.SAILING_HAMMERHEAD_SHARK_LIVER, NpcID.SAILING_HAMMERHEAD_SHARK, NpcID.SAILING_HAMMERHEAD_SHARK_DEAD, 1, 10),
	CATHERBY_TERN_BOUNTY_459(9122, 459, PortLocation.CATHERBY, "Catherby tern bounty", ItemID.SAILING_TERN_FEATHER, NpcID.SAILING_TERN, NpcID.SAILING_TERN_DEAD, 3, 3),
	CATHERBY_OSPREY_BOUNTY_460(9123, 460, PortLocation.CATHERBY, "Catherby osprey bounty", ItemID.SAILING_OSPREY_FEATHER, NpcID.SAILING_OSPREY, NpcID.SAILING_OSPREY_DEAD, 3, 3),
	CATHERBY_BULL_SHARK_BOUNTY_461(9124, 461, PortLocation.CATHERBY, "Catherby bull shark bounty", ItemID.SAILING_BULL_SHARK_JAW, NpcID.SAILING_BULL_SHARK, NpcID.SAILING_BULL_SHARK_DEAD, 3, 3),
	CATHERBY_PYGMY_KRAKEN_BOUNTY_462(9125, 462, PortLocation.CATHERBY, "Catherby pygmy kraken bounty", ItemID.SAILING_PYGMY_KRAKEN_TENTACLE, NpcID.SAILING_PYGMY_KRAKEN, NpcID.SAILING_PYGMY_KRAKEN_DEAD, 6, 2),
	CATHERBY_MOGRE_BOUNTY_463(9126, 463, PortLocation.CATHERBY, "Catherby mogre bounty", ItemID.SAILING_SEA_MOGRE_HEAD, NpcID.SAILING_SEA_MOGRE, NpcID.SAILING_SEA_MOGRE_DEAD, 1, 10),
	CATHERBY_FRIGATEBIRD_BOUNTY_464(9127, 464, PortLocation.CATHERBY, "Catherby frigatebird bounty", ItemID.SAILING_FRIGATEBIRD_BEAK, NpcID.SAILING_FRIGATEBIRD, NpcID.SAILING_FRIGATEBIRD_DEAD, 1, 10),
	CATHERBY_ALBATROSS_BOUNTY_465(9128, 465, PortLocation.CATHERBY, "Catherby albatross bounty", ItemID.SAILING_ALBATROSS_BEAK, NpcID.SAILING_ALBATROSS, NpcID.SAILING_ALBATROSS_DEAD, 1, 10),
	BRIMHAVEN_OSPREY_BOUNTY_466(9129, 466, PortLocation.BRIMHAVEN, "Brimhaven osprey bounty", ItemID.SAILING_OSPREY_FEATHER, NpcID.SAILING_OSPREY, NpcID.SAILING_OSPREY_DEAD, 3, 3),
	BRIMHAVEN_TERN_BOUNTY_467(9130, 467, PortLocation.BRIMHAVEN, "Brimhaven tern bounty", ItemID.SAILING_TERN_FEATHER, NpcID.SAILING_TERN, NpcID.SAILING_TERN_DEAD, 3, 3),
	BRIMHAVEN_BULL_SHARK_BOUNTY_468(9131, 468, PortLocation.BRIMHAVEN, "Brimhaven bull shark bounty", ItemID.SAILING_BULL_SHARK_JAW, NpcID.SAILING_BULL_SHARK, NpcID.SAILING_BULL_SHARK_DEAD, 3, 3),
	BRIMHAVEN_ALBATROSS_BOUNTY_469(9132, 469, PortLocation.BRIMHAVEN, "Brimhaven albatross bounty", ItemID.SAILING_ALBATROSS_FEATHER, NpcID.SAILING_ALBATROSS, NpcID.SAILING_ALBATROSS_DEAD, 4, 2),
	BRIMHAVEN_HAMMERHEAD_SHARK_BOUNTY_470(9133, 470, PortLocation.BRIMHAVEN, "Brimhaven hammerhead shark bounty", ItemID.SAILING_HAMMERHEAD_SHARK_LIVER, NpcID.SAILING_HAMMERHEAD_SHARK, NpcID.SAILING_HAMMERHEAD_SHARK_DEAD, 1, 10),
	BRIMHAVEN_TIGER_SHARK_BOUNTY_471(9134, 471, PortLocation.BRIMHAVEN, "Brimhaven tiger shark bounty", ItemID.SAILING_TIGER_SHARK_LIVER, NpcID.SAILING_TIGER_SHARK, NpcID.SAILING_TIGER_SHARK_DEAD, 1, 10),
	BRIMHAVEN_MOGRE_BOUNTY_472(9135, 472, PortLocation.BRIMHAVEN, "Brimhaven mogre bounty", ItemID.SAILING_SEA_MOGRE_HEAD, NpcID.SAILING_SEA_MOGRE, NpcID.SAILING_SEA_MOGRE_DEAD, 1, 10),
	ARDOUGNE_MOGRE_BOUNTY_473(9136, 473, PortLocation.ARDOUGNE, "Ardougne mogre bounty", ItemID.SAILING_SEA_MOGRE_MACE, NpcID.SAILING_SEA_MOGRE, NpcID.SAILING_SEA_MOGRE_DEAD, 3, 3),
	ARDOUGNE_OSPREY_BOUNTY_474(9137, 474, PortLocation.ARDOUGNE, "Ardougne osprey bounty", ItemID.SAILING_OSPREY_FEATHER, NpcID.SAILING_OSPREY, NpcID.SAILING_OSPREY_DEAD, 3, 3),
	ARDOUGNE_BULL_SHARK_BOUNTY_475(9138, 475, PortLocation.ARDOUGNE, "Ardougne bull shark bounty", ItemID.SAILING_BULL_SHARK_JAW, NpcID.SAILING_BULL_SHARK, NpcID.SAILING_BULL_SHARK_DEAD, 3, 3),
	ARDOUGNE_PYGMY_KRAKEN_BOUNTY_476(9139, 476, PortLocation.ARDOUGNE, "Ardougne pygmy kraken bounty", ItemID.SAILING_PYGMY_KRAKEN_TENTACLE, NpcID.SAILING_PYGMY_KRAKEN, NpcID.SAILING_PYGMY_KRAKEN_DEAD, 6, 2),
	ARDOUGNE_HAMMERHEAD_SHARK_BOUNTY_477(9140, 477, PortLocation.ARDOUGNE, "Ardougne hammerhead shark bounty", ItemID.SAILING_HAMMERHEAD_SHARK_LIVER, NpcID.SAILING_HAMMERHEAD_SHARK, NpcID.SAILING_HAMMERHEAD_SHARK_DEAD, 1, 10),
	ARDOUGNE_STINGRAY_BOUNTY_478(9141, 478, PortLocation.ARDOUGNE, "Ardougne stingray bounty", ItemID.SAILING_STINGRAY_SKIN, NpcID.SAILING_STINGRAY, NpcID.SAILING_STINGRAY_DEAD, 1, 10),
	ARDOUGNE_SPINED_KRAKEN_BOUNTY_479(9142, 479, PortLocation.ARDOUGNE, "Ardougne spined kraken bounty", ItemID.SAILING_SPINED_KRAKEN_INK_SAC, NpcID.SAILING_SPINED_KRAKEN, NpcID.SAILING_SPINED_KRAKEN_DEAD, 1, 10),
	PORT_KHAZARD_MOGRE_BOUNTY_480(9143, 480, PortLocation.PORT_KHAZARD, "Port Khazard mogre bounty", ItemID.SAILING_SEA_MOGRE_MACE, NpcID.SAILING_SEA_MOGRE, NpcID.SAILING_SEA_MOGRE_DEAD, 3, 3),
	PORT_KHAZARD_BULL_SHARK_BOUNTY_481(9144, 481, PortLocation.PORT_KHAZARD, "Port Khazard bull shark bounty", ItemID.SAILING_BULL_SHARK_JAW, NpcID.SAILING_BULL_SHARK, NpcID.SAILING_BULL_SHARK_DEAD, 3, 3),
	PORT_KHAZARD_HAMMERHEAD_SHARK_BOUNTY_482(9145, 482, PortLocation.PORT_KHAZARD, "Port Khazard hammerhead shark bounty", ItemID.SAILING_HAMMERHEAD_SHARK_JAW, NpcID.SAILING_HAMMERHEAD_SHARK, NpcID.SAILING_HAMMERHEAD_SHARK_DEAD, 3, 3),
	PORT_KHAZARD_GREAT_WHITE_SHARK_BOUNTY_483(9146, 483, PortLocation.PORT_KHAZARD, "Port Khazard great white shark bounty", ItemID.SAILING_GREAT_WHITE_SHARK_JAW, NpcID.SAILING_GREAT_WHITE_SHARK, NpcID.SAILING_GREAT_WHITE_SHARK_DEAD, 5, 2),
	PORT_KHAZARD_MOGRE_BOUNTY_484(9147, 484, PortLocation.PORT_KHAZARD, "Port Khazard mogre bounty", ItemID.SAILING_SEA_MOGRE_HEAD, NpcID.SAILING_SEA_MOGRE, NpcID.SAILING_SEA_MOGRE_DEAD, 1, 10),
	PORT_KHAZARD_EAGLE_RAY_BOUNTY_485(9148, 485, PortLocation.PORT_KHAZARD, "Port Khazard eagle ray bounty", ItemID.SAILING_EAGLE_RAY_SKIN, NpcID.SAILING_EAGLE_RAY, NpcID.SAILING_EAGLE_RAY_DEAD, 1, 10),
	PORT_KHAZARD_ALBATROSS_BOUNTY_486(9149, 486, PortLocation.PORT_KHAZARD, "Port Khazard albatross bounty", ItemID.SAILING_ALBATROSS_BEAK, NpcID.SAILING_ALBATROSS, NpcID.SAILING_ALBATROSS_DEAD, 1, 10),
	CORSAIR_COVE_HAMMERHEAD_SHARK_BOUNTY_487(9150, 487, PortLocation.CORSAIR_COVE, "Corsair Cove hammerhead shark bounty", ItemID.SAILING_HAMMERHEAD_SHARK_JAW, NpcID.SAILING_HAMMERHEAD_SHARK, NpcID.SAILING_HAMMERHEAD_SHARK_DEAD, 3, 3),
	CORSAIR_COVE_PYGMY_KRAKEN_BOUNTY_488(9151, 488, PortLocation.CORSAIR_COVE, "Corsair Cove pygmy kraken bounty", ItemID.SAILING_PYGMY_KRAKEN_TENTACLE, NpcID.SAILING_PYGMY_KRAKEN, NpcID.SAILING_PYGMY_KRAKEN_DEAD, 3, 3),
	CORSAIR_COVE_MOGRE_BOUNTY_489(9152, 489, PortLocation.CORSAIR_COVE, "Corsair Cove mogre bounty", ItemID.SAILING_SEA_MOGRE_MACE, NpcID.SAILING_SEA_MOGRE, NpcID.SAILING_SEA_MOGRE_DEAD, 3, 3),
	CORSAIR_COVE_STINGRAY_BOUNTY_490(9153, 490, PortLocation.CORSAIR_COVE, "Corsair Cove stingray bounty", ItemID.SAILING_STINGRAY_FIN, NpcID.SAILING_STINGRAY, NpcID.SAILING_STINGRAY_DEAD, 5, 2),
	CORSAIR_COVE_OSPREY_BOUNTY_491(9154, 491, PortLocation.CORSAIR_COVE, "Corsair Cove osprey bounty", ItemID.SAILING_OSPREY_BEAK, NpcID.SAILING_OSPREY, NpcID.SAILING_OSPREY_DEAD, 1, 10),
	CORSAIR_COVE_TIGER_SHARK_BOUNTY_492(9155, 492, PortLocation.CORSAIR_COVE, "Corsair Cove tiger shark bounty", ItemID.SAILING_TIGER_SHARK_LIVER, NpcID.SAILING_TIGER_SHARK, NpcID.SAILING_TIGER_SHARK_DEAD, 1, 10),
	CORSAIR_COVE_GREAT_WHITE_SHARK_BOUNTY_493(9156, 493, PortLocation.CORSAIR_COVE, "Corsair Cove great white shark bounty", ItemID.SAILING_GREAT_WHITE_SHARK_LIVER, NpcID.SAILING_GREAT_WHITE_SHARK, NpcID.SAILING_GREAT_WHITE_SHARK_DEAD, 1, 10),
	RUINS_OF_UNKAH_BULL_SHARK_BOUNTY_494(9157, 494, PortLocation.RUINS_OF_UNKAH, "Ruins of Unkah bull shark bounty", ItemID.SAILING_BULL_SHARK_JAW, NpcID.SAILING_BULL_SHARK, NpcID.SAILING_BULL_SHARK_DEAD, 3, 3),
	RUINS_OF_UNKAH_HAMMERHEAD_SHARK_BOUNTY_495(9158, 495, PortLocation.RUINS_OF_UNKAH, "Ruins of Unkah hammerhead shark bounty", ItemID.SAILING_HAMMERHEAD_SHARK_JAW, NpcID.SAILING_HAMMERHEAD_SHARK, NpcID.SAILING_HAMMERHEAD_SHARK_DEAD, 5, 2),
	RUINS_OF_UNKAH_TIGER_SHARK_BOUNTY_496(9159, 496, PortLocation.RUINS_OF_UNKAH, "Ruins of Unkah tiger shark bounty", ItemID.SAILING_TIGER_SHARK_JAW, NpcID.SAILING_TIGER_SHARK, NpcID.SAILING_TIGER_SHARK_DEAD, 4, 2),
	RUINS_OF_UNKAH_BUTTERFLY_RAY_BOUNTY_497(9160, 497, PortLocation.RUINS_OF_UNKAH, "Ruins of Unkah butterfly ray bounty", ItemID.SAILING_BUTTERFLY_RAY_FIN, NpcID.SAILING_BUTTERFLY_RAY, NpcID.SAILING_BUTTERFLY_RAY_DEAD, 4, 2),
	RUINS_OF_UNKAH_EAGLE_RAY_BOUNTY_498(9161, 498, PortLocation.RUINS_OF_UNKAH, "Ruins of Unkah eagle ray bounty", ItemID.SAILING_EAGLE_RAY_SKIN, NpcID.SAILING_EAGLE_RAY, NpcID.SAILING_EAGLE_RAY_DEAD, 1, 10),
	RUINS_OF_UNKAH_ALBATROSS_BOUNTY_499(9162, 499, PortLocation.RUINS_OF_UNKAH, "Ruins of Unkah albatross bounty", ItemID.SAILING_ALBATROSS_BEAK, NpcID.SAILING_ALBATROSS, NpcID.SAILING_ALBATROSS_DEAD, 1, 10),
	RUINS_OF_UNKAH_GREAT_WHITE_SHARK_BOUNTY_500(9163, 500, PortLocation.RUINS_OF_UNKAH, "Ruins of Unkah great white shark bounty", ItemID.SAILING_GREAT_WHITE_SHARK_LIVER, NpcID.SAILING_GREAT_WHITE_SHARK, NpcID.SAILING_GREAT_WHITE_SHARK_DEAD, 1, 10),
	VOID_KNIGHTS_OUTPOST_STINGRAY_BOUNTY_501(9164, 501, PortLocation.VOID_KNIGHTS_OUTPOST, "Void Knights' Outpost stingray bounty", ItemID.SAILING_STINGRAY_FIN, NpcID.SAILING_STINGRAY, NpcID.SAILING_STINGRAY_DEAD, 4, 2),
	VOID_KNIGHTS_OUTPOST_OSPREY_BOUNTY_502(9165, 502, PortLocation.VOID_KNIGHTS_OUTPOST, "Void Knights' Outpost osprey bounty", ItemID.SAILING_OSPREY_FEATHER, NpcID.SAILING_OSPREY, NpcID.SAILING_OSPREY_DEAD, 5, 2),
	VOID_KNIGHTS_OUTPOST_FRIGATEBIRD_BOUNTY_503(9166, 503, PortLocation.VOID_KNIGHTS_OUTPOST, "Void Knights' Outpost frigatebird bounty", ItemID.SAILING_FRIGATEBIRD_FEATHER, NpcID.SAILING_FRIGATEBIRD, NpcID.SAILING_FRIGATEBIRD_DEAD, 3, 3),
	VOID_KNIGHTS_OUTPOST_PYGMY_KRAKEN_BOUNTY_504(9167, 504, PortLocation.VOID_KNIGHTS_OUTPOST, "Void Knights' Outpost pygmy kraken bounty", ItemID.SAILING_PYGMY_KRAKEN_TENTACLE, NpcID.SAILING_PYGMY_KRAKEN, NpcID.SAILING_PYGMY_KRAKEN_DEAD, 6, 2),
	VOID_KNIGHTS_OUTPOST_EAGLE_RAY_BOUNTY_505(9168, 505, PortLocation.VOID_KNIGHTS_OUTPOST, "Void Knights' Outpost eagle ray bounty", ItemID.SAILING_EAGLE_RAY_SKIN, NpcID.SAILING_EAGLE_RAY, NpcID.SAILING_EAGLE_RAY_DEAD, 1, 10),
	VOID_KNIGHTS_OUTPOST_GREAT_WHITE_SHARK_BOUNTY_506(9169, 506, PortLocation.VOID_KNIGHTS_OUTPOST, "Void Knights' Outpost great white shark bounty", ItemID.SAILING_GREAT_WHITE_SHARK_LIVER, NpcID.SAILING_GREAT_WHITE_SHARK, NpcID.SAILING_GREAT_WHITE_SHARK_DEAD, 1, 10),
	VOID_KNIGHTS_OUTPOST_MANTA_RAY_BOUNTY_507(9170, 507, PortLocation.VOID_KNIGHTS_OUTPOST, "Void Knights' Outpost manta ray bounty", ItemID.SAILING_MANTA_RAY_SKIN, NpcID.SAILING_MANTA_RAY, NpcID.SAILING_MANTA_RAY_DEAD, 1, 10),
	SUMMER_SHORE_BUTTERFLY_RAY_BOUNTY_508(9171, 508, PortLocation.SUMMER_SHORE, "Summer Shore butterfly ray bounty", ItemID.SAILING_BUTTERFLY_RAY_FIN, NpcID.SAILING_BUTTERFLY_RAY, NpcID.SAILING_BUTTERFLY_RAY_DEAD, 5, 2),
	SUMMER_SHORE_EAGLE_RAY_BOUNTY_509(9172, 509, PortLocation.SUMMER_SHORE, "Summer Shore eagle ray bounty", ItemID.SAILING_EAGLE_RAY_FIN, NpcID.SAILING_EAGLE_RAY, NpcID.SAILING_EAGLE_RAY_DEAD, 5, 2),
	SUMMER_SHORE_FRIGATEBIRD_BOUNTY_510(9173, 510, PortLocation.SUMMER_SHORE, "Summer Shore frigatebird bounty", ItemID.SAILING_FRIGATEBIRD_FEATHER, NpcID.SAILING_FRIGATEBIRD, NpcID.SAILING_FRIGATEBIRD_DEAD, 3, 3),
	SUMMER_SHORE_GREAT_WHITE_SHARK_BOUNTY_511(9174, 511, PortLocation.SUMMER_SHORE, "Summer Shore great white shark bounty", ItemID.SAILING_GREAT_WHITE_SHARK_JAW, NpcID.SAILING_GREAT_WHITE_SHARK, NpcID.SAILING_GREAT_WHITE_SHARK_DEAD, 5, 2),
	SUMMER_SHORE_ALBATROSS_BOUNTY_512(9175, 512, PortLocation.SUMMER_SHORE, "Summer Shore albatross bounty", ItemID.SAILING_ALBATROSS_BEAK, NpcID.SAILING_ALBATROSS, NpcID.SAILING_ALBATROSS_DEAD, 1, 10),
	SUMMER_SHORE_TIGER_SHARK_BOUNTY_513(9176, 513, PortLocation.SUMMER_SHORE, "Summer Shore tiger shark bounty", ItemID.SAILING_TIGER_SHARK_LIVER, NpcID.SAILING_TIGER_SHARK, NpcID.SAILING_TIGER_SHARK_DEAD, 1, 10),
	SUMMER_SHORE_STINGRAY_BOUNTY_514(9177, 514, PortLocation.SUMMER_SHORE, "Summer Shore stingray bounty", ItemID.SAILING_STINGRAY_SKIN, NpcID.SAILING_STINGRAY, NpcID.SAILING_STINGRAY_DEAD, 1, 10),
	RED_ROCK_TIGER_SHARK_BOUNTY_515(9178, 515, PortLocation.RED_ROCK, "Red Rock tiger shark bounty", ItemID.SAILING_TIGER_SHARK_JAW, NpcID.SAILING_TIGER_SHARK, NpcID.SAILING_TIGER_SHARK_DEAD, 4, 2),
	RED_ROCK_FRIGATEBIRD_BOUNTY_516(9179, 516, PortLocation.RED_ROCK, "Red Rock frigatebird bounty", ItemID.SAILING_FRIGATEBIRD_FEATHER, NpcID.SAILING_FRIGATEBIRD, NpcID.SAILING_FRIGATEBIRD_DEAD, 3, 3),
	RED_ROCK_EAGLE_RAY_BOUNTY_517(9180, 517, PortLocation.RED_ROCK, "Red Rock eagle ray bounty", ItemID.SAILING_EAGLE_RAY_FIN, NpcID.SAILING_EAGLE_RAY, NpcID.SAILING_EAGLE_RAY_DEAD, 5, 2),
	RED_ROCK_GREAT_WHITE_SHARK_BOUNTY_518(9181, 518, PortLocation.RED_ROCK, "Red Rock great white shark bounty", ItemID.SAILING_GREAT_WHITE_SHARK_JAW, NpcID.SAILING_GREAT_WHITE_SHARK, NpcID.SAILING_GREAT_WHITE_SHARK_DEAD, 6, 2),
	RED_ROCK_STINGRAY_BOUNTY_519(9182, 519, PortLocation.RED_ROCK, "Red Rock stingray bounty", ItemID.SAILING_STINGRAY_SKIN, NpcID.SAILING_STINGRAY, NpcID.SAILING_STINGRAY_DEAD, 1, 10),
	RED_ROCK_TIGER_SHARK_BOUNTY_520(9183, 520, PortLocation.RED_ROCK, "Red Rock tiger shark bounty", ItemID.SAILING_TIGER_SHARK_LIVER, NpcID.SAILING_TIGER_SHARK, NpcID.SAILING_TIGER_SHARK_DEAD, 1, 10),
	RED_ROCK_SPINED_KRAKEN_BOUNTY_521(9184, 521, PortLocation.RED_ROCK, "Red Rock spined kraken bounty", ItemID.SAILING_SPINED_KRAKEN_INK_SAC, NpcID.SAILING_SPINED_KRAKEN, NpcID.SAILING_SPINED_KRAKEN_DEAD, 1, 10),
	LANDS_END_BULL_SHARK_BOUNTY_522(9185, 522, PortLocation.LANDS_END, "Land's End bull shark bounty", ItemID.SAILING_BULL_SHARK_JAW, NpcID.SAILING_BULL_SHARK, NpcID.SAILING_BULL_SHARK_DEAD, 3, 3),
	LANDS_END_OSPREY_BOUNTY_523(9186, 523, PortLocation.LANDS_END, "Land's End osprey bounty", ItemID.SAILING_OSPREY_FEATHER, NpcID.SAILING_OSPREY, NpcID.SAILING_OSPREY_DEAD, 3, 3),
	LANDS_END_TERN_BOUNTY_524(9187, 524, PortLocation.LANDS_END, "Land's End tern bounty", ItemID.SAILING_TERN_FEATHER, NpcID.SAILING_TERN, NpcID.SAILING_TERN_DEAD, 3, 3),
	LANDS_END_PYGMY_KRAKEN_BOUNTY_525(9188, 525, PortLocation.LANDS_END, "Land's End pygmy kraken bounty", ItemID.SAILING_PYGMY_KRAKEN_TENTACLE, NpcID.SAILING_PYGMY_KRAKEN, NpcID.SAILING_PYGMY_KRAKEN_DEAD, 3, 3),
	LANDS_END_HAMMERHEAD_SHARK_BOUNTY_526(9189, 526, PortLocation.LANDS_END, "Land's End hammerhead shark bounty", ItemID.SAILING_HAMMERHEAD_SHARK_LIVER, NpcID.SAILING_HAMMERHEAD_SHARK, NpcID.SAILING_HAMMERHEAD_SHARK_DEAD, 1, 10),
	LANDS_END_GREAT_WHITE_SHARK_BOUNTY_527(9190, 527, PortLocation.LANDS_END, "Land's End great white shark bounty", ItemID.SAILING_GREAT_WHITE_SHARK_LIVER, NpcID.SAILING_GREAT_WHITE_SHARK, NpcID.SAILING_GREAT_WHITE_SHARK_DEAD, 1, 10),
	LANDS_END_BUTTERFLY_RAY_BOUNTY_528(9191, 528, PortLocation.LANDS_END, "Land's End butterfly ray bounty", ItemID.SAILING_BUTTERFLY_RAY_SKIN, NpcID.SAILING_BUTTERFLY_RAY, NpcID.SAILING_BUTTERFLY_RAY_DEAD, 1, 10),
	PORT_PISCARILIUS_OSPREY_BOUNTY_529(9192, 529, PortLocation.PORT_PISCARILIUS, "Port Piscarilius osprey bounty", ItemID.SAILING_OSPREY_FEATHER, NpcID.SAILING_OSPREY, NpcID.SAILING_OSPREY_DEAD, 3, 3),
	PORT_PISCARILIUS_BULL_SHARK_BOUNTY_530(9193, 530, PortLocation.PORT_PISCARILIUS, "Port Piscarilius bull shark bounty", ItemID.SAILING_BULL_SHARK_JAW, NpcID.SAILING_BULL_SHARK, NpcID.SAILING_BULL_SHARK_DEAD, 3, 3),
	PORT_PISCARILIUS_TERN_BOUNTY_531(9194, 531, PortLocation.PORT_PISCARILIUS, "Port Piscarilius tern bounty", ItemID.SAILING_TERN_FEATHER, NpcID.SAILING_TERN, NpcID.SAILING_TERN_DEAD, 3, 3),
	PORT_PISCARILIUS_SPINED_KRAKEN_BOUNTY_532(9195, 532, PortLocation.PORT_PISCARILIUS, "Port Piscarilius spined kraken bounty", ItemID.SAILING_SPINED_KRAKEN_TENTACLE, NpcID.SAILING_SPINED_KRAKEN, NpcID.SAILING_SPINED_KRAKEN_DEAD, 4, 2),
	PORT_PISCARILIUS_TIGER_SHARK_BOUNTY_533(9196, 533, PortLocation.PORT_PISCARILIUS, "Port Piscarilius tiger shark bounty", ItemID.SAILING_TIGER_SHARK_LIVER, NpcID.SAILING_TIGER_SHARK, NpcID.SAILING_TIGER_SHARK_DEAD, 1, 10),
	PORT_PISCARILIUS_BUTTERFLY_RAY_BOUNTY_534(9197, 534, PortLocation.PORT_PISCARILIUS, "Port Piscarilius butterfly ray bounty", ItemID.SAILING_BUTTERFLY_RAY_SKIN, NpcID.SAILING_BUTTERFLY_RAY, NpcID.SAILING_BUTTERFLY_RAY_DEAD, 1, 10),
	PORT_PISCARILIUS_ARMOURED_KRAKEN_BOUNTY_535(9198, 535, PortLocation.PORT_PISCARILIUS, "Port Piscarilius armoured kraken bounty", ItemID.SAILING_ARMOURED_KRAKEN_INK_SAC, NpcID.SAILING_ARMOURED_KRAKEN, NpcID.SAILING_ARMOURED_KRAKEN_DEAD, 1, 10),
	CIVITAS_ILLA_FORTIS_OSPREY_BOUNTY_536(9199, 536, PortLocation.CIVITAS_ILLA_FORTIS, "Civitas illa Fortis osprey bounty", ItemID.SAILING_OSPREY_FEATHER, NpcID.SAILING_OSPREY, NpcID.SAILING_OSPREY_DEAD, 3, 3),
	CIVITAS_ILLA_FORTIS_HAMMERHEAD_SHARK_BOUNTY_537(9200, 537, PortLocation.CIVITAS_ILLA_FORTIS, "Civitas illa Fortis hammerhead shark bounty", ItemID.SAILING_HAMMERHEAD_SHARK_JAW, NpcID.SAILING_HAMMERHEAD_SHARK, NpcID.SAILING_HAMMERHEAD_SHARK_DEAD, 4, 2),
	CIVITAS_ILLA_FORTIS_BULL_SHARK_BOUNTY_538(9201, 538, PortLocation.CIVITAS_ILLA_FORTIS, "Civitas illa Fortis bull shark bounty", ItemID.SAILING_BULL_SHARK_JAW, NpcID.SAILING_BULL_SHARK, NpcID.SAILING_BULL_SHARK_DEAD, 4, 2),
	CIVITAS_ILLA_FORTIS_ARMOURED_KRAKEN_BOUNTY_539(9202, 539, PortLocation.CIVITAS_ILLA_FORTIS, "Civitas illa Fortis armoured kraken bounty", ItemID.SAILING_ARMOURED_KRAKEN_TENTACLE, NpcID.SAILING_ARMOURED_KRAKEN, NpcID.SAILING_ARMOURED_KRAKEN_DEAD, 5, 2),
	CIVITAS_ILLA_FORTIS_TERN_BOUNTY_540(9203, 540, PortLocation.CIVITAS_ILLA_FORTIS, "Civitas illa Fortis tern bounty", ItemID.SAILING_TERN_BEAK, NpcID.SAILING_TERN, NpcID.SAILING_TERN_DEAD, 1, 10),
	CIVITAS_ILLA_FORTIS_FRIGATEBIRD_BOUNTY_541(9204, 541, PortLocation.CIVITAS_ILLA_FORTIS, "Civitas illa Fortis frigatebird bounty", ItemID.SAILING_FRIGATEBIRD_BEAK, NpcID.SAILING_FRIGATEBIRD, NpcID.SAILING_FRIGATEBIRD_DEAD, 1, 10),
	CIVITAS_ILLA_FORTIS_EAGLE_RAY_BOUNTY_542(9205, 542, PortLocation.CIVITAS_ILLA_FORTIS, "Civitas illa Fortis eagle ray bounty", ItemID.SAILING_EAGLE_RAY_SKIN, NpcID.SAILING_EAGLE_RAY, NpcID.SAILING_EAGLE_RAY_DEAD, 1, 10),
	ALDARIN_STINGRAY_BOUNTY_543(9206, 543, PortLocation.ALDARIN, "Aldarin stingray bounty", ItemID.SAILING_STINGRAY_FIN, NpcID.SAILING_STINGRAY, NpcID.SAILING_STINGRAY_DEAD, 4, 2),
	ALDARIN_OSPREY_BOUNTY_544(9207, 544, PortLocation.ALDARIN, "Aldarin osprey bounty", ItemID.SAILING_OSPREY_FEATHER, NpcID.SAILING_OSPREY, NpcID.SAILING_OSPREY_DEAD, 4, 2),
	ALDARIN_BUTTERFLY_RAY_BOUNTY_545(9208, 545, PortLocation.ALDARIN, "Aldarin butterfly ray bounty", ItemID.SAILING_BUTTERFLY_RAY_FIN, NpcID.SAILING_BUTTERFLY_RAY, NpcID.SAILING_BUTTERFLY_RAY_DEAD, 5, 2),
	ALDARIN_GREAT_WHITE_SHARK_BOUNTY_546(9209, 546, PortLocation.ALDARIN, "Aldarin great white shark bounty", ItemID.SAILING_GREAT_WHITE_SHARK_JAW, NpcID.SAILING_GREAT_WHITE_SHARK, NpcID.SAILING_GREAT_WHITE_SHARK_DEAD, 6, 2),
	ALDARIN_HAMMERHEAD_SHARK_BOUNTY_547(9210, 547, PortLocation.ALDARIN, "Aldarin hammerhead shark bounty", ItemID.SAILING_HAMMERHEAD_SHARK_LIVER, NpcID.SAILING_HAMMERHEAD_SHARK, NpcID.SAILING_HAMMERHEAD_SHARK_DEAD, 1, 10),
	ALDARIN_SPINED_KRAKEN_BOUNTY_548(9211, 548, PortLocation.ALDARIN, "Aldarin spined kraken bounty", ItemID.SAILING_SPINED_KRAKEN_INK_SAC, NpcID.SAILING_SPINED_KRAKEN, NpcID.SAILING_SPINED_KRAKEN_DEAD, 1, 10),
	ALDARIN_FRIGATEBIRD_BOUNTY_549(9212, 549, PortLocation.ALDARIN, "Aldarin frigatebird bounty", ItemID.SAILING_FRIGATEBIRD_BEAK, NpcID.SAILING_FRIGATEBIRD, NpcID.SAILING_FRIGATEBIRD_DEAD, 1, 10),
	PORT_ROBERTS_HAMMERHEAD_SHARK_BOUNTY_550(9213, 550, PortLocation.PORT_ROBERTS, "Port Roberts hammerhead shark bounty", ItemID.SAILING_HAMMERHEAD_SHARK_JAW, NpcID.SAILING_HAMMERHEAD_SHARK, NpcID.SAILING_HAMMERHEAD_SHARK_DEAD, 3, 3),
	PORT_ROBERTS_OSPREY_BOUNTY_551(9214, 551, PortLocation.PORT_ROBERTS, "Port Roberts osprey bounty", ItemID.SAILING_OSPREY_FEATHER, NpcID.SAILING_OSPREY, NpcID.SAILING_OSPREY_DEAD, 3, 3),
	PORT_ROBERTS_ARMOURED_KRAKEN_BOUNTY_552(9215, 552, PortLocation.PORT_ROBERTS, "Port Roberts armoured kraken bounty", ItemID.SAILING_ARMOURED_KRAKEN_TENTACLE, NpcID.SAILING_ARMOURED_KRAKEN, NpcID.SAILING_ARMOURED_KRAKEN_DEAD, 4, 2),
	PORT_ROBERTS_GREAT_WHITE_SHARK_BOUNTY_553(9216, 553, PortLocation.PORT_ROBERTS, "Port Roberts great white shark bounty", ItemID.SAILING_GREAT_WHITE_SHARK_JAW, NpcID.SAILING_GREAT_WHITE_SHARK, NpcID.SAILING_GREAT_WHITE_SHARK_DEAD, 5, 2),
	PORT_ROBERTS_TERN_BOUNTY_554(9217, 554, PortLocation.PORT_ROBERTS, "Port Roberts tern bounty", ItemID.SAILING_TERN_BEAK, NpcID.SAILING_TERN, NpcID.SAILING_TERN_DEAD, 1, 10),
	PORT_ROBERTS_ORCA_BOUNTY_555(9218, 555, PortLocation.PORT_ROBERTS, "Port Roberts orca bounty", ItemID.SAILING_ORCA_TEETH, NpcID.SAILING_ORCA, NpcID.SAILING_ORCA_DEAD, 1, 10),
	PORT_ROBERTS_ALBATROSS_BOUNTY_556(9219, 556, PortLocation.PORT_ROBERTS, "Port Roberts albatross bounty", ItemID.SAILING_ALBATROSS_BEAK, NpcID.SAILING_ALBATROSS, NpcID.SAILING_ALBATROSS_DEAD, 1, 10),
	DEEPFIN_POINT_FRIGATEBIRD_BOUNTY_557(9220, 557, PortLocation.DEEPFIN_POINT, "Deepfin Point frigatebird bounty", ItemID.SAILING_FRIGATEBIRD_FEATHER, NpcID.SAILING_FRIGATEBIRD, NpcID.SAILING_FRIGATEBIRD_DEAD, 4, 2),
	DEEPFIN_POINT_EAGLE_RAY_BOUNTY_558(9221, 558, PortLocation.DEEPFIN_POINT, "Deepfin Point eagle ray bounty", ItemID.SAILING_EAGLE_RAY_FIN, NpcID.SAILING_EAGLE_RAY, NpcID.SAILING_EAGLE_RAY_DEAD, 5, 2),
	DEEPFIN_POINT_SPINED_KRAKEN_BOUNTY_559(9222, 559, PortLocation.DEEPFIN_POINT, "Deepfin Point spined kraken bounty", ItemID.SAILING_SPINED_KRAKEN_TENTACLE, NpcID.SAILING_SPINED_KRAKEN, NpcID.SAILING_SPINED_KRAKEN_DEAD, 5, 2),
	DEEPFIN_POINT_OSPREY_BOUNTY_560(9223, 560, PortLocation.DEEPFIN_POINT, "Deepfin Point osprey bounty", ItemID.SAILING_OSPREY_FEATHER, NpcID.SAILING_OSPREY, NpcID.SAILING_OSPREY_DEAD, 4, 2),
	DEEPFIN_POINT_STINGRAY_BOUNTY_561(9224, 561, PortLocation.DEEPFIN_POINT, "Deepfin Point stingray bounty", ItemID.SAILING_STINGRAY_SKIN, NpcID.SAILING_STINGRAY, NpcID.SAILING_STINGRAY_DEAD, 1, 10),
	DEEPFIN_POINT_TIGER_SHARK_BOUNTY_562(9225, 562, PortLocation.DEEPFIN_POINT, "Deepfin Point tiger shark bounty", ItemID.SAILING_TIGER_SHARK_LIVER, NpcID.SAILING_TIGER_SHARK, NpcID.SAILING_TIGER_SHARK_DEAD, 1, 10),
	DEEPFIN_POINT_HAMMERHEAD_SHARK_BOUNTY_563(9226, 563, PortLocation.DEEPFIN_POINT, "Deepfin Point hammerhead shark bounty", ItemID.SAILING_HAMMERHEAD_SHARK_LIVER, NpcID.SAILING_HAMMERHEAD_SHARK, NpcID.SAILING_HAMMERHEAD_SHARK_DEAD, 1, 10),
	PORT_TYRAS_BUTTERFLY_RAY_BOUNTY_564(9227, 564, PortLocation.PORT_TYRAS, "Port Tyras butterfly ray bounty", ItemID.SAILING_BUTTERFLY_RAY_FIN, NpcID.SAILING_BUTTERFLY_RAY, NpcID.SAILING_BUTTERFLY_RAY_DEAD, 6, 2),
	PORT_TYRAS_HAMMERHEAD_SHARK_BOUNTY_565(9228, 565, PortLocation.PORT_TYRAS, "Port Tyras hammerhead shark bounty", ItemID.SAILING_HAMMERHEAD_SHARK_JAW, NpcID.SAILING_HAMMERHEAD_SHARK, NpcID.SAILING_HAMMERHEAD_SHARK_DEAD, 6, 2),
	PORT_TYRAS_BULL_SHARK_BOUNTY_566(9229, 566, PortLocation.PORT_TYRAS, "Port Tyras bull shark bounty", ItemID.SAILING_BULL_SHARK_JAW, NpcID.SAILING_BULL_SHARK, NpcID.SAILING_BULL_SHARK_DEAD, 5, 2),
	PORT_TYRAS_ARMOURED_KRAKEN_BOUNTY_567(9230, 567, PortLocation.PORT_TYRAS, "Port Tyras armoured kraken bounty", ItemID.SAILING_ARMOURED_KRAKEN_TENTACLE, NpcID.SAILING_ARMOURED_KRAKEN, NpcID.SAILING_ARMOURED_KRAKEN_DEAD, 6, 2),
	PORT_TYRAS_PYGMY_KRAKEN_BOUNTY_568(9231, 568, PortLocation.PORT_TYRAS, "Port Tyras pygmy kraken bounty", ItemID.SAILING_PYGMY_KRAKEN_INK_SAC, NpcID.SAILING_PYGMY_KRAKEN, NpcID.SAILING_PYGMY_KRAKEN_DEAD, 1, 10),
	PORT_TYRAS_GREAT_WHITE_SHARK_BOUNTY_569(9232, 569, PortLocation.PORT_TYRAS, "Port Tyras great white shark bounty", ItemID.SAILING_GREAT_WHITE_SHARK_LIVER, NpcID.SAILING_GREAT_WHITE_SHARK, NpcID.SAILING_GREAT_WHITE_SHARK_DEAD, 1, 10),
	PORT_TYRAS_MANTA_RAY_BOUNTY_570(9233, 570, PortLocation.PORT_TYRAS, "Port Tyras manta ray bounty", ItemID.SAILING_MANTA_RAY_SKIN, NpcID.SAILING_MANTA_RAY, NpcID.SAILING_MANTA_RAY_DEAD, 1, 10),
	PRIFDDINAS_HAMMERHEAD_SHARK_BOUNTY_571(9234, 571, PortLocation.PRIFDDINAS, "Prifddinas hammerhead shark bounty", ItemID.SAILING_HAMMERHEAD_SHARK_JAW, NpcID.SAILING_HAMMERHEAD_SHARK, NpcID.SAILING_HAMMERHEAD_SHARK_DEAD, 6, 2),
	PRIFDDINAS_PYGMY_KRAKEN_BOUNTY_572(9235, 572, PortLocation.PRIFDDINAS, "Prifddinas pygmy kraken bounty", ItemID.SAILING_PYGMY_KRAKEN_TENTACLE, NpcID.SAILING_PYGMY_KRAKEN, NpcID.SAILING_PYGMY_KRAKEN_DEAD, 6, 2),
	PRIFDDINAS_ARMOURED_KRAKEN_BOUNTY_573(9236, 573, PortLocation.PRIFDDINAS, "Prifddinas armoured kraken bounty", ItemID.SAILING_ARMOURED_KRAKEN_TENTACLE, NpcID.SAILING_ARMOURED_KRAKEN, NpcID.SAILING_ARMOURED_KRAKEN_DEAD, 6, 2),
	PRIFDDINAS_OSPREY_BOUNTY_574(9237, 574, PortLocation.PRIFDDINAS, "Prifddinas osprey bounty", ItemID.SAILING_OSPREY_FEATHER, NpcID.SAILING_OSPREY, NpcID.SAILING_OSPREY_DEAD, 6, 2),
	PRIFDDINAS_GREAT_WHITE_SHARK_BOUNTY_575(9238, 575, PortLocation.PRIFDDINAS, "Prifddinas great white shark bounty", ItemID.SAILING_GREAT_WHITE_SHARK_LIVER, NpcID.SAILING_GREAT_WHITE_SHARK, NpcID.SAILING_GREAT_WHITE_SHARK_DEAD, 1, 10),
	PRIFDDINAS_MANTA_RAY_BOUNTY_576(9239, 576, PortLocation.PRIFDDINAS, "Prifddinas manta ray bounty", ItemID.SAILING_MANTA_RAY_SKIN, NpcID.SAILING_MANTA_RAY, NpcID.SAILING_MANTA_RAY_DEAD, 1, 10),
	PRIFDDINAS_HAMMERHEAD_SHARK_BOUNTY_577(9240, 577, PortLocation.PRIFDDINAS, "Prifddinas hammerhead shark bounty", ItemID.SAILING_HAMMERHEAD_SHARK_LIVER, NpcID.SAILING_HAMMERHEAD_SHARK, NpcID.SAILING_HAMMERHEAD_SHARK_DEAD, 1, 10),
	RELLEKKA_ALBATROSS_BOUNTY_578(9241, 578, PortLocation.RELLEKKA, "Rellekka albatross bounty", ItemID.SAILING_ALBATROSS_FEATHER, NpcID.SAILING_ALBATROSS, NpcID.SAILING_ALBATROSS_DEAD, 5, 2),
	RELLEKKA_HAMMERHEAD_SHARK_BOUNTY_579(9242, 579, PortLocation.RELLEKKA, "Rellekka hammerhead shark bounty", ItemID.SAILING_HAMMERHEAD_SHARK_JAW, NpcID.SAILING_HAMMERHEAD_SHARK, NpcID.SAILING_HAMMERHEAD_SHARK_DEAD, 4, 2),
	RELLEKKA_NARWHAL_BOUNTY_580(9243, 580, PortLocation.RELLEKKA, "Rellekka narwhal bounty", ItemID.SAILING_NARWHAL_BLUBBER, NpcID.SAILING_NARWHAL, NpcID.SAILING_NARWHAL_DEAD, 6, 2),
	RELLEKKA_ARMOURED_KRAKEN_BOUNTY_581(9244, 581, PortLocation.RELLEKKA, "Rellekka armoured kraken bounty", ItemID.SAILING_ARMOURED_KRAKEN_TENTACLE, NpcID.SAILING_ARMOURED_KRAKEN, NpcID.SAILING_ARMOURED_KRAKEN_DEAD, 5, 2),
	RELLEKKA_ORCA_BOUNTY_582(9245, 582, PortLocation.RELLEKKA, "Rellekka orca bounty", ItemID.SAILING_ORCA_TEETH, NpcID.SAILING_ORCA, NpcID.SAILING_ORCA_DEAD, 1, 10),
	RELLEKKA_VAMPYRE_KRAKEN_BOUNTY_583(9246, 583, PortLocation.RELLEKKA, "Rellekka vampyre kraken bounty", ItemID.SAILING_VAMPYRE_KRAKEN_INK_SAC, NpcID.SAILING_VAMPYRE_KRAKEN, NpcID.SAILING_VAMPYRE_KRAKEN_DEAD, 1, 10),
	RELLEKKA_SPINED_KRAKEN_BOUNTY_584(9247, 584, PortLocation.RELLEKKA, "Rellekka spined kraken bounty", ItemID.SAILING_SPINED_KRAKEN_INK_SAC, NpcID.SAILING_SPINED_KRAKEN, NpcID.SAILING_SPINED_KRAKEN_DEAD, 1, 10),
	ETCETERIA_ALBATROSS_BOUNTY_585(9248, 585, PortLocation.ETCETERIA, "Etceteria albatross bounty", ItemID.SAILING_ALBATROSS_FEATHER, NpcID.SAILING_ALBATROSS, NpcID.SAILING_ALBATROSS_DEAD, 6, 2),
	ETCETERIA_ORCA_BOUNTY_586(9249, 586, PortLocation.ETCETERIA, "Etceteria orca bounty", ItemID.SAILING_ORCA_BLUBBER, NpcID.SAILING_ORCA, NpcID.SAILING_ORCA_DEAD, 6, 2),
	ETCETERIA_VAMPYRE_KRAKEN_BOUNTY_587(9250, 587, PortLocation.ETCETERIA, "Etceteria vampyre kraken bounty", ItemID.SAILING_VAMPYRE_KRAKEN_TENTACLE, NpcID.SAILING_VAMPYRE_KRAKEN, NpcID.SAILING_VAMPYRE_KRAKEN_DEAD, 4, 2),
	ETCETERIA_NARWHAL_BOUNTY_588(9251, 588, PortLocation.ETCETERIA, "Etceteria narwhal bounty", ItemID.SAILING_NARWHAL_BLUBBER, NpcID.SAILING_NARWHAL, NpcID.SAILING_NARWHAL_DEAD, 6, 2),
	ETCETERIA_SPINED_KRAKEN_BOUNTY_589(9252, 589, PortLocation.ETCETERIA, "Etceteria spined kraken bounty", ItemID.SAILING_SPINED_KRAKEN_INK_SAC, NpcID.SAILING_SPINED_KRAKEN, NpcID.SAILING_SPINED_KRAKEN_DEAD, 1, 10),
	ETCETERIA_ORCA_BOUNTY_590(9253, 590, PortLocation.ETCETERIA, "Etceteria orca bounty", ItemID.SAILING_ORCA_TEETH, NpcID.SAILING_ORCA, NpcID.SAILING_ORCA_DEAD, 1, 10),
	ETCETERIA_ARMOURED_KRAKEN_BOUNTY_591(9254, 591, PortLocation.ETCETERIA, "Etceteria armoured kraken bounty", ItemID.SAILING_ARMOURED_KRAKEN_INK_SAC, NpcID.SAILING_ARMOURED_KRAKEN, NpcID.SAILING_ARMOURED_KRAKEN_DEAD, 1, 10),
	LUNAR_ISLE_ARMOURED_KRAKEN_BOUNTY_592(9255, 592, PortLocation.LUNAR_ISLE, "Lunar Isle armoured kraken bounty", ItemID.SAILING_ARMOURED_KRAKEN_TENTACLE, NpcID.SAILING_ARMOURED_KRAKEN, NpcID.SAILING_ARMOURED_KRAKEN_DEAD, 4, 2),
	LUNAR_ISLE_VAMPYRE_KRAKEN_BOUNTY_593(9256, 593, PortLocation.LUNAR_ISLE, "Lunar Isle vampyre kraken bounty", ItemID.SAILING_VAMPYRE_KRAKEN_TENTACLE, NpcID.SAILING_VAMPYRE_KRAKEN, NpcID.SAILING_VAMPYRE_KRAKEN_DEAD, 6, 2),
	LUNAR_ISLE_NARWHAL_BOUNTY_594(9257, 594, PortLocation.LUNAR_ISLE, "Lunar Isle narwhal bounty", ItemID.SAILING_NARWHAL_BLUBBER, NpcID.SAILING_NARWHAL, NpcID.SAILING_NARWHAL_DEAD, 5, 2),
	LUNAR_ISLE_ORCA_BOUNTY_595(9258, 595, PortLocation.LUNAR_ISLE, "Lunar Isle orca bounty", ItemID.SAILING_ORCA_BLUBBER, NpcID.SAILING_ORCA, NpcID.SAILING_ORCA_DEAD, 6, 2),
	LUNAR_ISLE_ALBATROSS_BOUNTY_596(9259, 596, PortLocation.LUNAR_ISLE, "Lunar Isle albatross bounty", ItemID.SAILING_ALBATROSS_BEAK, NpcID.SAILING_ALBATROSS, NpcID.SAILING_ALBATROSS_DEAD, 1, 10),
	LUNAR_ISLE_VAMPYRE_KRAKEN_BOUNTY_597(9260, 597, PortLocation.LUNAR_ISLE, "Lunar Isle vampyre kraken bounty", ItemID.SAILING_VAMPYRE_KRAKEN_INK_SAC, NpcID.SAILING_VAMPYRE_KRAKEN, NpcID.SAILING_VAMPYRE_KRAKEN_DEAD, 1, 10),
	LUNAR_ISLE_NARWHAL_BOUNTY_598(9261, 598, PortLocation.LUNAR_ISLE, "Lunar Isle narwhal bounty", ItemID.SAILING_NARWHAL_TUSK, NpcID.SAILING_NARWHAL, NpcID.SAILING_NARWHAL_DEAD, 1, 10),
	;
	private final int dbrow;
	private final int id;
	private final PortLocation bountyLocation;
	public final String taskName;
	public final int itemId;
	public final int npcId;
	private final int deadNpcId;
	public final int itemQuantity;
	public final int itemRarity;

	private static final Set<Integer> VARBIT_VALUES;

	private static final Map<Integer, BountyTaskData> BY_DBROW = new HashMap<>();

	BountyTaskData(int dbrow, int id, PortLocation bountyLocation, String taskName, int itemId, int npcId, int deadNpcId, int itemQuantity, int itemRarity)
	{
		this.dbrow = dbrow;
		this.id = id;
		this.bountyLocation = bountyLocation;
		this.taskName = taskName;
		this.itemId = itemId;
		this.npcId = npcId;
		this.deadNpcId = deadNpcId;
		this.itemQuantity = itemQuantity;
		this.itemRarity = itemRarity;
	}

	static
	{
		Set<Integer> varbitValues = new HashSet<>();
		for (BountyTaskData b : values())
		{
			varbitValues.add(b.id);
		}
		VARBIT_VALUES = Collections.unmodifiableSet(varbitValues);
	}

	static
	{
		for (BountyTaskData task : values())
		{
			BY_DBROW.put(task.dbrow, task);
		}
	}

	public static BountyTaskData getByDbrow(int dbrow)
	{
		return BY_DBROW.get(dbrow);
	}

	public static BountyTaskData fromId(int id)
	{
		for (BountyTaskData task : values())
		{
			if (task.id == id)
				return task;
		}
		return null;
	}

	public static boolean isBountyTask(int id)
	{
		return VARBIT_VALUES.contains(id);
	}
}

/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks.enums;

import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import lombok.Getter;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.ObjectID;

@Getter
public enum PortLocation
{
	MUSA_POINT(8590, "Musa Point", 10, ObjectID.SAILING_GANGPLANK_MUSA_POINT, ObjectID.PORT_TASK_BOARD_MUSA_POINT, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_MUSA_POINT, new WorldPoint(2965, 3146, 0)),
	PORT_SARIM(8587, "Port Sarim", 1, ObjectID.SAILING_GANGPLANK_PORT_SARIM, ObjectID.PORT_TASK_BOARD_PORT_SARIM, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_PORT_SARIM, new WorldPoint(3056, 3194, 0)),
	PANDEMONIUM(8588, "The Pandemonium", 1, ObjectID.SAILING_GANGPLANK_THE_PANDEMONIUM, ObjectID.PORT_TASK_BOARD_PANDEMONIUM, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_PANDEMONIUM, new WorldPoint(3078, 2987, 0)),
	ENTRANA(8599, "Entrana", 36, ObjectID.SAILING_GANGPLANK_ENTRANA, -1, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_ENTRANA, new WorldPoint(2883, 3336, 0)),
	RUINS_OF_UNKAH(8606, "Ruins of Unkah", 48, ObjectID.SAILING_GANGPLANK_RUINS_OF_UNKAH, ObjectID.PORT_TASK_BOARD_RUINS_OF_UNKAH, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_RUINS_OF_UNKAH, new WorldPoint(3143, 2824, 0)),
	RED_ROCK(8609, "Red Rock", null, ObjectID.SAILING_GANGPLANK_RED_ROCK, ObjectID.PORT_TASK_BOARD_RED_ROCK, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_RED_ROCK, new WorldPoint(2814, 2510, 0)),
	ARDOUGNE(8596, "Ardougne", 28, ObjectID.SAILING_GANGPLANK_ARDOUGNE, ObjectID.PORT_TASK_BOARD_ARDOUGNE, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_ARDOUGNE, new WorldPoint(2670, 3259, 0)),
	BRIMHAVEN(8595, "Brimhaven", 25, ObjectID.SAILING_GANGPLANK_BRIMHAVEN, ObjectID.PORT_TASK_BOARD_BRIMHAVEN, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_BRIMHAVEN, new WorldPoint(2754, 3231, 0)),
	CATHERBY(8593, "Catherby", 20, ObjectID.SAILING_GANGPLANK_CATHERBY, ObjectID.PORT_TASK_BOARD_CATHERBY, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_CATHERBY, new WorldPoint(2796, 3408, 0)),
	PORT_KHAZARD(8597, "Port Khazard", 30, ObjectID.SAILING_GANGPLANK_PORT_KHAZARD, ObjectID.PORT_TASK_BOARD_PORT_KHAZARD, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_PORT_KHAZARD, new WorldPoint(2688, 3162, 0)),
	CORSAIR_COVE(8601, "Corsair Cove", 40, ObjectID.SAILING_GANGPLANK_CORSAIR_COVE, ObjectID.PORT_TASK_BOARD_CORSAIR_COVE, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_CORSAIR_COVE, new WorldPoint(2586, 2844, 0)),
	DEEPFIN_POINT(8613, "Deepfin Point", 67, ObjectID.SAILING_GANGPLANK_DEEPFIN_POINT, ObjectID.PORT_TASK_BOARD_DEEPFIN_POINT, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_DEEPFIN_POINT, new WorldPoint(1923, 2752, 0)),
	SUNSET_COAST(8603, "Sunset Coast", 44, ObjectID.SAILING_GANGPLANK_SUNSET_COAST, -1, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_SUNSET_COAST, new WorldPoint(1506, 2971, 0)),
	ALDARIN(8605, "Aldarin", 46, ObjectID.SAILING_GANGPLANK_ALDARIN, ObjectID.PORT_TASK_BOARD_ALDARIN, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_ALDARIN, new WorldPoint(1454, 2977, 0)),
	SUMMER_SHORE(8604, "The Summer Shore", 45, ObjectID.SAILING_GANGPLANK_THE_SUMMER_SHORE, ObjectID.PORT_TASK_BOARD_THE_SUMMER_SHORE, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_THE_SUMMER_SHORE, new WorldPoint(3174, 2367, 0)),
	VOID_KNIGHTS_OUTPOST(8607, "Void Knights' Outpost", 50, ObjectID.SAILING_GANGPLANK_VOID_KNIGHTS_OUTPOST, ObjectID.PORT_TASK_BOARD_VOID_KNIGHTS_OUTPOST, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_VOID_KNIGHTS_OUTPOST, new WorldPoint(2651, 2683, 0)),
	PORT_TYRAS(8612, "Port Tyras", 66, ObjectID.SAILING_GANGPLANK_PORT_TYRAS, ObjectID.PORT_TASK_BOARD_PORT_TYRAS, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_PORT_TYRAS, new WorldPoint(2141, 3115, 0)),
	PORT_ROBERTS(8608, "Port Roberts", 50, ObjectID.SAILING_GANGPLANK_PORT_ROBERTS, ObjectID.PORT_TASK_BOARD_PORT_ROBERTS, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_PORT_ROBERTS, new WorldPoint(1858, 3307, 0)),
	LANDS_END(8589, "Land's End", 5, ObjectID.SAILING_GANGPLANK_LANDS_END, ObjectID.PORT_TASK_BOARD_LANDS_END, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_LANDS_END, new WorldPoint(1511, 3405, 0)),
	HOSIDIUS(8591, "Hosidius", 5, ObjectID.SAILING_GANGPLANK_HOSIDIUS, -1, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_HOSIDIUS, new WorldPoint(1726, 3447, 0)),
	CIVITAS_ILLA_FORTIS(8600, "Civitas illa Fortis", 38, ObjectID.SAILING_GANGPLANK_CIVITAS_ILLA_FORTIS, ObjectID.PORT_TASK_BOARD_CIVITAS_ILLA_FORTIS, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_CIVITAS_ILLA_FORTIS, new WorldPoint(1769, 3144, 0)),
	PORT_PISCARILIUS(8594, "Port Piscarilius", 15, ObjectID.SAILING_GANGPLANK_PORT_PISCARILIUS, ObjectID.PORT_TASK_BOARD_PORT_PISCARILIUS, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_PORT_PISCARILIUS, new WorldPoint(1845, 3681, 0)),
	CAIRN_ISLE(8602, "Cairn Isle", 42, ObjectID.SAILING_GANGPLANK_CAIRN_ISLE, -1, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_CAIRN_ISLE, new WorldPoint(2745, 2952, 0)),
	PRIFDDINAS(8616, "Prifddinas", 70, ObjectID.SAILING_GANGPLANK_PRIFDDINAS, ObjectID.PORT_TASK_BOARD_PRIFDDINAS, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_PRIFDDINAS, new WorldPoint(2158, 3319, 0)),
	PISCATORIS(8617, "Piscatoris", 75, ObjectID.SAILING_GANGPLANK_PISCATORIS, -1, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_PISCATORIS, new WorldPoint(2300, 3689, 0)),
	LUNAR_ISLE(8618, "Lunar Isle", 76, ObjectID.SAILING_GANGPLANK_LUNAR_ISLE, ObjectID.PORT_TASK_BOARD_LUNAR_ISLE, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_LUNAR_ISLE, new WorldPoint(2157, 3881, 0)),
	RELLEKKA(8610, "Rellekka", 62, ObjectID.SAILING_GANGPLANK_RELLEKKA, ObjectID.PORT_TASK_BOARD_RELLEKKA, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_RELLEKKA, new WorldPoint(2630, 3709, 0)),
	JATIZSO(8614, "Jatizso", 68, ObjectID.SAILING_GANGPLANK_JATIZSO, -1, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_JATIZSO, new WorldPoint(2412, 3776, 0)),
	ETCETERIA(8611, "Etceteria", 65, ObjectID.SAILING_GANGPLANK_ETCETERIA, ObjectID.PORT_TASK_BOARD_ETCETERIA, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_ETCETERIA, new WorldPoint(2612, 3836, 0)),
	NEITIZNOT(8615, "Neitiznot", 68, ObjectID.SAILING_GANGPLANK_NEITIZNOT, -1, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_NEITIZNOT, new WorldPoint(2302, 3782, 0)),
	EMPTY(0, "Default", null, -1, -1, -1, new WorldPoint(0, 0, 0)),
	;

	private final int dbrow;
	private final String name;
	private final Integer sailingLevelRequired;
	private final int gangplankObject;
	private final int noticeboardObject;
	private final int ledgerObject;
	private final WorldPoint navigationLocation;

	private static final Set<Integer> GANGPLANK_IDS;
	private static final Set<Integer> NOTICEBOARD_IDS;
	private static final Set<Integer> LEDGER_IDS;
	private static final Map<Integer, PortLocation> BY_DBROW = new HashMap<>();



	PortLocation(int dbrow, String name, Integer sailingLevelRequired, int gangplankObject, int noticeboardObject, int ledgerObject, WorldPoint navigationLocation)
	{
		this.dbrow = dbrow;
		this.name = name;
		this.sailingLevelRequired = sailingLevelRequired;
		this.gangplankObject = gangplankObject;
		this.noticeboardObject = noticeboardObject;
		this.ledgerObject = ledgerObject;
		this.navigationLocation = navigationLocation;
	}

	static
	{
		Set<Integer> gangplanks = new HashSet<>();
		Set<Integer> noticeboards = new HashSet<>();
		Set <Integer> ledgers = new HashSet<>();
		for (PortLocation p : values())
		{
			BY_DBROW.put(p.dbrow, p);
			gangplanks.add(p.gangplankObject);
			ledgers.add(p.ledgerObject);
			if (p.noticeboardObject != -1)
			{
				noticeboards.add(p.noticeboardObject);
			}
		}
		GANGPLANK_IDS = Collections.unmodifiableSet(gangplanks);
		NOTICEBOARD_IDS = Collections.unmodifiableSet(noticeboards);
		LEDGER_IDS = Collections.unmodifiableSet(ledgers);
	}

	public static boolean isGangplank(int objectId)
	{
		return GANGPLANK_IDS.contains(objectId);
	}

	public static boolean isNoticeboard(int objectId)
	{
		return NOTICEBOARD_IDS.contains(objectId);
	}

	public static boolean isLedger(int objectId)
	{
		return LEDGER_IDS.contains(objectId);
	}

	public static PortLocation fromDbRow(int dbrow)
	{
		return BY_DBROW.getOrDefault(dbrow, EMPTY);
	}

	@Override
	public String toString()
	{
		return name;
	}

}
package com.nucleon.porttasks.enums;

import com.nucleon.porttasks.PortPathMatch;
import com.nucleon.porttasks.RelativeMove;
import java.util.ArrayList;
import java.util.List;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.coords.WorldPoint;


@Getter
@Slf4j
public enum PortPaths
{
	DEFAULT(
		PortLocation.EMPTY,
		PortLocation.EMPTY
		// Sailing >= 0, used in 0 tasks
	),
	CATHERBY_BRIMHAVEN(
		PortLocation.CATHERBY,
		PortLocation.BRIMHAVEN,
		// Sailing >= 25, used in 4 tasks
		new RelativeMove(0, -22),
		new RelativeMove(-42, -42)
	),
	BRIMHAVEN_MUSA_POINT(
		PortLocation.BRIMHAVEN,
		PortLocation.MUSA_POINT,
		// Sailing >= 25, used in 6 tasks
		new RelativeMove(0, 8),
		new RelativeMove(7, 7),
		new RelativeMove(33, 0),
		new RelativeMove(30, -30),
		new RelativeMove(76, 0),
		new RelativeMove(47, -47),
		new RelativeMove(13, 0),
		new RelativeMove(5, -5)
	),

	BRIMHAVEN_PANDEMONIUM(
		PortLocation.BRIMHAVEN,
		PortLocation.PANDEMONIUM,
		// Sailing >= 25, used in 5 tasks
		new RelativeMove(0, 8),
		new RelativeMove(7, 7),
		new RelativeMove(33, 0),
		new RelativeMove(30, -30),
		new RelativeMove(76, 0),
		new RelativeMove(47, -47),
		new RelativeMove(13, 0),
		new RelativeMove(14, -14),
		new RelativeMove(0, -63),
		new RelativeMove(59, -59),
		new RelativeMove(37, 0),
		new RelativeMove(8, -8)
	),

	BRIMHAVEN_PORT_KHAZARD(
		PortLocation.BRIMHAVEN,
		PortLocation.PORT_KHAZARD,
		// Sailing >= 30, used in 4 tasks
		new RelativeMove(0, 15),
		new RelativeMove(-7, 7),
		new RelativeMove(-26, 0),
		new RelativeMove(-33, -33)
	),

	CATHERBY_ARDOUGNE(
		PortLocation.CATHERBY,
		PortLocation.ARDOUGNE,
		// Sailing >= 28, used in 6 tasks
		new RelativeMove(0, -27),
		new RelativeMove(-41, -41),
		new RelativeMove(0, -62),
		new RelativeMove(-19, -19)
	),

	CATHERBY_MUSA_POINT(
		PortLocation.CATHERBY,
		PortLocation.MUSA_POINT,
		// Sailing >= 20, used in 4 tasks
		new RelativeMove(62, 0),
		new RelativeMove(20, -20),
		new RelativeMove(0, -42),
		new RelativeMove(4, -4),
		new RelativeMove(0, -105),
		new RelativeMove(60, -60),
		new RelativeMove(18, 0),
		new RelativeMove(5, -5)
	),

	CATHERBY_PANDEMONIUM(
		PortLocation.CATHERBY,
		PortLocation.PANDEMONIUM,
		// Sailing >= 20, used in 4 tasks
		new RelativeMove(62, 0),
		new RelativeMove(20, -20),
		new RelativeMove(0, -42),
		new RelativeMove(4, -4),
		new RelativeMove(0, -105),
		new RelativeMove(60, -60),
		new RelativeMove(18, 0),
		new RelativeMove(13, -13),
		new RelativeMove(0, -67),
		new RelativeMove(75, -75),
		new RelativeMove(25, 0),
		new RelativeMove(5, -5)
	),

	CATHERBY_PORT_KHAZARD(
		PortLocation.CATHERBY,
		PortLocation.PORT_KHAZARD,
		// Sailing >= 30, used in 5 tasks
		new RelativeMove(0, -28),
		new RelativeMove(-40, -40),
		new RelativeMove(0, -53),
		new RelativeMove(-68, -68)
	),

	CATHERBY_PORT_SARIM(
		PortLocation.CATHERBY,
		PortLocation.PORT_SARIM,
		// Sailing >= 20, used in 6 tasks
		new RelativeMove(62, 0),
		new RelativeMove(20, -20),
		new RelativeMove(0, -42),
		new RelativeMove(4, -4),
		new RelativeMove(0, -105),
		new RelativeMove(60, -60),
		new RelativeMove(18, 0),
		new RelativeMove(10, -10),
		new RelativeMove(0, -51),
		new RelativeMove(13, -13),
		new RelativeMove(24, 0),
		new RelativeMove(49, 49)
	),

	ARDOUGNE_PORT_KHAZARD(
		PortLocation.ARDOUGNE,
		PortLocation.PORT_KHAZARD,
		// Sailing >= 30, used in 5 tasks
		new RelativeMove(5, 0),
		new RelativeMove(7, -7),
		new RelativeMove(0, -60),
		new RelativeMove(6, -6)
	),

	ARDOUGNE_RUINS_OF_UNKAH(
		PortLocation.ARDOUGNE,
		PortLocation.RUINS_OF_UNKAH,
		// Sailing >= 48, used in 2 tasks
		new RelativeMove(90, 0),
		new RelativeMove(34, -34),
		new RelativeMove(17, 0),
		new RelativeMove(12, -12),
		new RelativeMove(85, 0),
		new RelativeMove(55, -55),
		new RelativeMove(0, -42),
		new RelativeMove(121, -121),
		new RelativeMove(0, -20),
		new RelativeMove(43, -43),
		new RelativeMove(0, -108)
	),

	ENTRANA_MUSA_POINT(
		PortLocation.ENTRANA,
		PortLocation.MUSA_POINT,
		// Sailing >= 36, used in 2 tasks
		new RelativeMove(0, -118),
		new RelativeMove(20, -20),
		new RelativeMove(20, 0),
		new RelativeMove(20, -20),
		new RelativeMove(17, 0),
		new RelativeMove(5, -5)
	),

	MUSA_POINT_PANDEMONIUM(
		PortLocation.MUSA_POINT,
		PortLocation.PANDEMONIUM,
		// Sailing >= 10, used in 6 tasks
		new RelativeMove(5, 0),
		new RelativeMove(5, -5),
		new RelativeMove(0, -35),
		new RelativeMove(103, -103)
	),

	MUSA_POINT_PORT_KHAZARD(
		PortLocation.MUSA_POINT,
		PortLocation.PORT_KHAZARD,
		// Sailing >= 30, used in 1 task
		new RelativeMove(0, 11),
		new RelativeMove(-57, 57),
		new RelativeMove(-93, 0),
		new RelativeMove(-36, 36),
		new RelativeMove(-62, 0),
		new RelativeMove(-29, -29)
	),

	MUSA_POINT_PORT_SARIM(
		PortLocation.MUSA_POINT,
		PortLocation.PORT_SARIM,
		// Sailing >= 10, used in 6 tasks
		new RelativeMove(5, 0),
		new RelativeMove(5, -5),
		new RelativeMove(0, -35),
		new RelativeMove(14, -14),
		new RelativeMove(11, 0),
		new RelativeMove(56, 56)
	),

	MUSA_POINT_RUINS_OF_UNKAH(
		PortLocation.MUSA_POINT,
		PortLocation.RUINS_OF_UNKAH,
		// Sailing >= 48, used in 0 tasks
		new RelativeMove(5, 0),
		new RelativeMove(5, -5),
		new RelativeMove(0, -35),
		new RelativeMove(103, -103),
		new RelativeMove(0, -20),
		new RelativeMove(45, -45),
		new RelativeMove(0, -117),
		new RelativeMove(20, 0)
	),

	PANDEMONIUM_PORT_KHAZARD(
		PortLocation.PANDEMONIUM,
		PortLocation.PORT_KHAZARD,
		// Sailing >= 30, used in 2 tasks
		new RelativeMove(0, 20),
		new RelativeMove(-103, 103),
		new RelativeMove(0, 35),
		new RelativeMove(-5, 5),
		new RelativeMove(0, 10),
		new RelativeMove(-35, 35),
		new RelativeMove(-20, 0),
		new RelativeMove(-25, 25),
		new RelativeMove(-85, 0),
		new RelativeMove(-41, 41),
		new RelativeMove(-40, 0),
		new RelativeMove(-36, -36)
	),

	PANDEMONIUM_RUINS_OF_UNKAH(
		PortLocation.PANDEMONIUM,
		PortLocation.RUINS_OF_UNKAH,
		// Sailing >= 48, used in 4 tasks
		new RelativeMove(0, -20),
		new RelativeMove(45, -45),
		new RelativeMove(0, -98),
		new RelativeMove(20, 0)
	),

	PORT_KHAZARD_PORT_SARIM(
		PortLocation.PORT_KHAZARD,
		PortLocation.PORT_SARIM,
		// Sailing >= 30, used in 5 tasks
		new RelativeMove(0, 60),
		new RelativeMove(35, 35),
		new RelativeMove(45, 0),
		new RelativeMove(41, -41),
		new RelativeMove(85, 0),
		new RelativeMove(25, -25),
		new RelativeMove(20, 0),
		new RelativeMove(35, -35),
		new RelativeMove(0, -44),
		new RelativeMove(12, -12),
		new RelativeMove(22, 0),
		new RelativeMove(48, 48)
	),

	PORT_KHAZARD_RUINS_OF_UNKAH(
		PortLocation.PORT_KHAZARD,
		PortLocation.RUINS_OF_UNKAH,
		// Sailing >= 48, used in 3 tasks
		new RelativeMove(0, 62),
		new RelativeMove(34, 34),
		new RelativeMove(56, 0),
		new RelativeMove(40, -40),
		new RelativeMove(86, 0),
		new RelativeMove(71, -71),
		new RelativeMove(0, -43),
		new RelativeMove(148, -148),
		new RelativeMove(0, -125),
		new RelativeMove(7, -7)
	),

	RUINS_OF_UNKAH_SUMMER_SHORE(
		PortLocation.RUINS_OF_UNKAH,
		PortLocation.SUMMER_SHORE,
		// Sailing >= 48, used in 3 tasks
		new RelativeMove(-6, -6),
		new RelativeMove(0, -108),
		new RelativeMove(15, -15),
		new RelativeMove(0, -46),
		new RelativeMove(-85, -85),
		new RelativeMove(0, -166),
		new RelativeMove(31, -31)
	),
	PORT_SARIM_PANDEMONIUM(
		PortLocation.PORT_SARIM,
		PortLocation.PANDEMONIUM,
		// Sailing >= 1, used in 6 tasks
		new RelativeMove(0, -43),
		new RelativeMove(-22, -22),
		new RelativeMove(0, -75),
		new RelativeMove(44, -44)
	),
	PORT_SARIM_ARDOUGNE(
		PortLocation.PORT_SARIM,
		PortLocation.ARDOUGNE,
		// Sailing >= 28, used in 3 tasks
		new RelativeMove(0, -43),
		new RelativeMove(-50, -50),
		new RelativeMove(-22, 0),
		new RelativeMove(-8, 8),
		new RelativeMove(0, 40),
		new RelativeMove(-50, 50),
		new RelativeMove(-48, 0),
		new RelativeMove(-17, 17),
		new RelativeMove(-46, 0),
		new RelativeMove(-43, 43)
	),
	CATHERBY_ENTRANA(
		PortLocation.CATHERBY,
		PortLocation.ENTRANA,
		// Sailing >= 36, used in 2 tasks
		new RelativeMove(60, 0),
		new RelativeMove(16, -16),
		new RelativeMove(0, -40),
		new RelativeMove(11, -11)
	),
	CATHERBY_RUINS_OF_UNKAH(
		PortLocation.CATHERBY,
		PortLocation.RUINS_OF_UNKAH,
		// Sailing >= 48, used in 1 task
		new RelativeMove(62, 0),
		new RelativeMove(20, -20),
		new RelativeMove(0, -42),
		new RelativeMove(4, -4),
		new RelativeMove(0, -105),
		new RelativeMove(60, -60),
		new RelativeMove(18, 0),
		new RelativeMove(14, -14),
		new RelativeMove(0, -51),
		new RelativeMove(153, -153),
		new RelativeMove(0, -131),
		new RelativeMove(5, -5),
		new RelativeMove(10, 0)
	),
	BRIMHAVEN_ARDOUGNE(
		PortLocation.BRIMHAVEN,
		PortLocation.ARDOUGNE,
		// Sailing >= 28, used in 4 tasks
		new RelativeMove(0, 16),
		new RelativeMove(-12, 12)
	),
	PORT_KHAZARD_ENTRANA(
		PortLocation.PORT_KHAZARD,
		PortLocation.ENTRANA,
		// Sailing >= 36, used in 1 task
		new RelativeMove(0, 59),
		new RelativeMove(38, 38),
		new RelativeMove(66, 0),
		new RelativeMove(9, 9),
		new RelativeMove(0, 41),
		new RelativeMove(14, 14),
		new RelativeMove(63, 0),
		new RelativeMove(5, 5)
	),
	PORT_KHAZARD_CORSAIR_COVE(
		PortLocation.PORT_KHAZARD,
		PortLocation.CORSAIR_COVE,
		// Sailing >= 40, used in 6 tasks
		new RelativeMove(0, -15),
		new RelativeMove(43, -43),
		new RelativeMove(0, -212),
		new RelativeMove(-48, -48)
	),
	RUINS_OF_UNKAH_BRIMHAVEN(
		PortLocation.RUINS_OF_UNKAH,
		PortLocation.BRIMHAVEN,
		// Sailing >= 48, used in 1 task
		new RelativeMove(-14, 0),
		new RelativeMove(-6, 6),
		new RelativeMove(0, 132),
		new RelativeMove(-149, 149),
		new RelativeMove(0, 42),
		new RelativeMove(-47, 47),
		new RelativeMove(-39, 0),
		new RelativeMove(-18, 18),
		new RelativeMove(-61, 0),
		new RelativeMove(-29, 29),
		new RelativeMove(-20, 0),
		new RelativeMove(-6, -6)
	),
	RUINS_OF_UNKAH_CORSAIR_COVE(
		PortLocation.RUINS_OF_UNKAH,
		PortLocation.CORSAIR_COVE,
		// Sailing >= 48, used in 0 tasks
		new RelativeMove(-72, 0),
		new RelativeMove(-15, -15),
		new RelativeMove(-78, 0),
		new RelativeMove(-28, 28),
		new RelativeMove(0, 11),
		new RelativeMove(-14, 14),
		new RelativeMove(-80, 0),
		new RelativeMove(-12, -12)
	),
	PANDEMONIUM_ARDOUGNE(
		PortLocation.PANDEMONIUM,
		PortLocation.ARDOUGNE,
		// Sailing >= 28, used in 1 task
		new RelativeMove(0, 22),
		new RelativeMove(-105, 105),
		new RelativeMove(0, 42),
		new RelativeMove(-28, 28),
		new RelativeMove(-23, 0),
		new RelativeMove(-27, 27),
		new RelativeMove(-76, 0),
		new RelativeMove(-48, 48)
	),
	MUSA_POINT_ARDOUGNE(
		PortLocation.MUSA_POINT,
		PortLocation.ARDOUGNE,
		// Sailing >= 28, used in 2 tasks
		new RelativeMove(0, 16),
		new RelativeMove(-28, 28),
		new RelativeMove(-23, 0),
		new RelativeMove(-27, 27),
		new RelativeMove(-76, 0),
		new RelativeMove(-42, 42)
	),
	BRIMHAVEN_PORT_SARIM(
		PortLocation.BRIMHAVEN,
		PortLocation.PORT_SARIM,
		// Sailing >= 25, used in 3 tasks
		new RelativeMove(0, 7),
		new RelativeMove(8, 8),
		new RelativeMove(24, 0),
		new RelativeMove(26, -26),
		new RelativeMove(88, 0),
		new RelativeMove(65, -65),
		new RelativeMove(0, -40),
		new RelativeMove(18, -18),
		new RelativeMove(39, 0),
		new RelativeMove(34, 34)
	),
	PORT_SARIM_RUINS_OF_UNKAH(
		PortLocation.PORT_SARIM,
		PortLocation.RUINS_OF_UNKAH,
		// Sailing >= 48, used in 4 tasks
		new RelativeMove(0, -50),
		new RelativeMove(-25, -25),
		new RelativeMove(0, -68),
		new RelativeMove(95, -95),
		new RelativeMove(0, -127),
		new RelativeMove(5, -5)
	),
	PORT_PISCARILIUS_PORT_SARIM(
		PortLocation.PORT_PISCARILIUS,
		PortLocation.PORT_SARIM,
		// Sailing >= 15, used in 3 tasks
		// Slightly longer route to avoid aggressive NPCs
		new RelativeMove(108, -108),
		new RelativeMove(0, -423),
		new RelativeMove(-87, -87),
		new RelativeMove(0, -218),
		new RelativeMove(27, -27),
		new RelativeMove(77, 0),
		new RelativeMove(51, -51),
		new RelativeMove(70, 0),
		new RelativeMove(25, -25),
		new RelativeMove(0, -40),
		new RelativeMove(44, -44),
		new RelativeMove(253, 0),
		new RelativeMove(24, 24),
		new RelativeMove(138, 0),
		new RelativeMove(196, 196),
		new RelativeMove(217, 0),
		new RelativeMove(92, 92),
		new RelativeMove(0, 36),
		new RelativeMove(-52, 52),
		new RelativeMove(0, 60),
		new RelativeMove(28, 28)
	),
	PORT_SARIM_VOID_KNIGHTS_OUTPOST(
		PortLocation.PORT_SARIM,
		PortLocation.VOID_KNIGHTS_OUTPOST,
		// Sailing >= 50, used in 1 task
		new RelativeMove(0, -38),
		new RelativeMove(-40, -40),
		new RelativeMove(0, -99),
		new RelativeMove(-10, -10),
		new RelativeMove(0, -103),
		new RelativeMove(-26, -26),
		new RelativeMove(-230, 0),
		new RelativeMove(-99, -99)
	),
	CORSAIR_COVE_PANDEMONIUM(
		PortLocation.CORSAIR_COVE,
		PortLocation.PANDEMONIUM,
		// Sailing >= 40, used in 4 tasks
		new RelativeMove(276, 0),
		new RelativeMove(35, 35),
		new RelativeMove(78, 0),
		new RelativeMove(59, 59),
		new RelativeMove(22, 0),
		new RelativeMove(22, 22)
	),
	CATHERBY_VOID_KNIGHTS_OUTPOST(
		PortLocation.CATHERBY,
		PortLocation.VOID_KNIGHTS_OUTPOST,
		// Sailing >= 50, used in 1 task
		new RelativeMove(0, -29),
		new RelativeMove(-44, -44),
		new RelativeMove(0, -53),
		new RelativeMove(-64, -64),
		new RelativeMove(0, -73),
		new RelativeMove(43, -43),
		new RelativeMove(0, -217),
		new RelativeMove(-80, -80)
	),
	BRIMHAVEN_CORSAIR_COVE(
		PortLocation.BRIMHAVEN,
		PortLocation.CORSAIR_COVE,
		// Sailing >= 40, used in 5 tasks
		new RelativeMove(0, 17),
		new RelativeMove(-5, 5),
		new RelativeMove(-30, 0),
		new RelativeMove(-31, -31),
		new RelativeMove(0, -80),
		new RelativeMove(37, -37),
		new RelativeMove(0, -216),
		new RelativeMove(-45, -45)
	),
	BRIMHAVEN_RED_ROCK(
		PortLocation.BRIMHAVEN,
		PortLocation.RED_ROCK,
		// Sailing >= 25, used in 2 tasks
		new RelativeMove(0, 15),
		new RelativeMove(-8, 8),
		new RelativeMove(-31, 0),
		new RelativeMove(-28, -28),
		new RelativeMove(0, -83),
		new RelativeMove(33, -33),
		new RelativeMove(0, -259),
		new RelativeMove(-70, -70),
		new RelativeMove(0, -55),
		new RelativeMove(177, -177),
		new RelativeMove(0, -16),
		new RelativeMove(-13, -13)
	),
	BRIMHAVEN_SUMMER_SHORE(
		PortLocation.BRIMHAVEN,
		PortLocation.SUMMER_SHORE,
		// Sailing >= 45, used in 1 task
		new RelativeMove(0, 17),
		new RelativeMove(-6, 6),
		new RelativeMove(-29, 0),
		new RelativeMove(-30, -30),
		new RelativeMove(0, -80),
		new RelativeMove(37, -37),
		new RelativeMove(0, -202),
		new RelativeMove(106, -106),
		new RelativeMove(0, -49),
		new RelativeMove(76, -76),
		new RelativeMove(0, -73),
		new RelativeMove(164, -164),
		new RelativeMove(0, -32),
		new RelativeMove(38, -38)
	),
	ARDOUGNE_PORT_TYRAS(
		PortLocation.ARDOUGNE,
		PortLocation.PORT_TYRAS,
		// Sailing >= 66, used in 5 tasks
		new RelativeMove(7, 0),
		new RelativeMove(10, -10),
		new RelativeMove(0, -101),
		new RelativeMove(41, -41),
		new RelativeMove(0, -234),
		new RelativeMove(-84, -84),
		new RelativeMove(0, -59),
		new RelativeMove(-47, -47),
		new RelativeMove(-240, 0),
		new RelativeMove(-24, -24),
		new RelativeMove(-144, 0),
		new RelativeMove(-105, 105),
		new RelativeMove(-69, 0),
		new RelativeMove(-33, 33),
		new RelativeMove(0, 107),
		new RelativeMove(138, 138),
		new RelativeMove(0, 65),
		new RelativeMove(8, 8)
	),
	ARDOUGNE_PORT_PISCARILIUS(
		PortLocation.ARDOUGNE,
		PortLocation.PORT_PISCARILIUS,
		// Sailing >= 28, used in 2 tasks
		new RelativeMove(8, 0),
		new RelativeMove(10, -10),
		new RelativeMove(0, -106),
		new RelativeMove(39, -39),
		new RelativeMove(0, -234),
		new RelativeMove(-81, -81),
		new RelativeMove(0, -47),
		new RelativeMove(-138, -138),
		new RelativeMove(-267, 0),
		new RelativeMove(-155, 155),
		new RelativeMove(-70, 0),
		new RelativeMove(-35, 35),
		new RelativeMove(0, 82),
		new RelativeMove(-73, 73),
		new RelativeMove(0, 148),
		new RelativeMove(48, 48),
		new RelativeMove(0, 396),
		new RelativeMove(-111, 111)
	),
	ARDOUGNE_RED_ROCK(
		PortLocation.ARDOUGNE,
		PortLocation.RED_ROCK,
		// Sailing >= 28, used in 2 tasks
		new RelativeMove(18, -18),
		new RelativeMove(0, -93),
		new RelativeMove(34, -34),
		new RelativeMove(0, -211),
		new RelativeMove(101, -101),
		new RelativeMove(0, -106),
		new RelativeMove(-41, -41),
		new RelativeMove(0, -75),
		new RelativeMove(43, -43),
		new RelativeMove(0, -7),
		new RelativeMove(-11, -11)
	),
	CIVITAS_ILLA_FORTIS_PORT_KHAZARD(
		PortLocation.CIVITAS_ILLA_FORTIS,
		PortLocation.PORT_KHAZARD,
		// Sailing >= 38, used in 2 tasks
		new RelativeMove(-8, 8),
		new RelativeMove(0, 94),
		new RelativeMove(20, 20),
		new RelativeMove(132, 0),
		new RelativeMove(42, -42),
		new RelativeMove(0, -72),
		new RelativeMove(70, -70),
		new RelativeMove(0, -136),
		new RelativeMove(-45, -45),
		new RelativeMove(0, -102),
		new RelativeMove(38, -38),
		new RelativeMove(74, 0),
		new RelativeMove(20, -20),
		new RelativeMove(0, -76),
		new RelativeMove(43, -43),
		new RelativeMove(359, 0),
		new RelativeMove(215, 215),
		new RelativeMove(0, 273),
		new RelativeMove(-41, 41)
	),
	CORSAIR_COVE_VOID_KNIGHTS_OUTPOST(
		PortLocation.CORSAIR_COVE,
		PortLocation.VOID_KNIGHTS_OUTPOST,
		// Sailing >= 50, used in 3 tasks
		new RelativeMove(32, 0),
		new RelativeMove(33, -33)
	),
	CORSAIR_COVE_PORT_TYRAS(
		PortLocation.CORSAIR_COVE,
		PortLocation.PORT_TYRAS,
		// Sailing >= 66, used in 3 tasks
		new RelativeMove(24, 0),
		new RelativeMove(34, -34),
		new RelativeMove(0, -77),
		new RelativeMove(-49, -49),
		new RelativeMove(-419, 0),
		new RelativeMove(-68, 68),
		new RelativeMove(-75, 0),
		new RelativeMove(-54, 54),
		new RelativeMove(0, 82),
		new RelativeMove(142, 142),
		new RelativeMove(0, 75),
		new RelativeMove(10, 10)
	),
	CORSAIR_COVE_PORT_PISCARILIUS(
		PortLocation.CORSAIR_COVE,
		PortLocation.PORT_PISCARILIUS,
		// Sailing >= 40, used in 2 tasks
		new RelativeMove(24, 0),
		new RelativeMove(34, -34),
		new RelativeMove(0, -77),
		new RelativeMove(-49, -49),
		new RelativeMove(-419, 0),
		new RelativeMove(-68, 68),
		new RelativeMove(-75, 0),
		new RelativeMove(-54, 54),
		new RelativeMove(0, 82),
		new RelativeMove(142, 142),
		new RelativeMove(0, 75),
		new RelativeMove(10, 10)
	),
	CAIRN_ISLE_CORSAIR_COVE(
		PortLocation.CAIRN_ISLE,
		PortLocation.CORSAIR_COVE,
		// Sailing >= 42, used in 2 tasks
		new RelativeMove(0, -42),
		new RelativeMove(-66, -66)
	),
	RED_ROCK_RUINS_OF_UNKAH(
		PortLocation.RED_ROCK,
		PortLocation.RUINS_OF_UNKAH,
		// Sailing >= 48, used in 3 tasks
		new RelativeMove(19, 19),
		new RelativeMove(70, 0),
		new RelativeMove(10, -10),
		new RelativeMove(118, 0),
		new RelativeMove(118, 118),
		new RelativeMove(0, 57),
		new RelativeMove(-12, 12),
		new RelativeMove(0, 102),
		new RelativeMove(6, 6)
	),
	RUINS_OF_UNKAH_VOID_KNIGHTS_OUTPOST(
		PortLocation.RUINS_OF_UNKAH,
		PortLocation.VOID_KNIGHTS_OUTPOST,
		// Sailing >= 50, used in 2 tasks
		new RelativeMove(-8, -8),
		new RelativeMove(0, -103),
		new RelativeMove(17, -17),
		new RelativeMove(0, -52),
		new RelativeMove(-48, -48),
		new RelativeMove(-290, 0),
		new RelativeMove(-87, 87)
	),
	RED_ROCK_VOID_KNIGHTS_OUTPOST(
		PortLocation.RED_ROCK,
		PortLocation.VOID_KNIGHTS_OUTPOST,
		// Sailing >= 50, used in 2 tasks
		new RelativeMove(14, 14),
		new RelativeMove(0, 69),
		new RelativeMove(-90, 90)
	),
	SUMMER_SHORE_VOID_KNIGHTS_OUTPOST(
		PortLocation.SUMMER_SHORE,
		PortLocation.VOID_KNIGHTS_OUTPOST,
		// Sailing >= 50, used in 2 tasks
		new RelativeMove(-160, 0),
		new RelativeMove(-316, 316)
	),
	DEEPFIN_POINT_VOID_KNIGHTS_OUTPOST(
		PortLocation.DEEPFIN_POINT,
		PortLocation.VOID_KNIGHTS_OUTPOST,
		// Sailing >= 67, used in 2 tasks
		new RelativeMove(68, -68),
		new RelativeMove(110, 0),
		new RelativeMove(64, -64),
		new RelativeMove(356, 0),
		new RelativeMove(63, 63)
	),
	LANDS_END_PRIFDDINAS(
		PortLocation.LANDS_END,
		PortLocation.PRIFDDINAS,
		// Sailing >= 70, used in 1 task
		new RelativeMove(12, -12),
		new RelativeMove(373, 0),
		new RelativeMove(36, -36),
		new RelativeMove(156, 0),
		new RelativeMove(38, -38)
	),
	LANDS_END_PISCATORIS(
		PortLocation.LANDS_END,
		PortLocation.PISCATORIS,
		// Sailing >= 75, used in 2 tasks
		new RelativeMove(6, -6),
		new RelativeMove(392, 0),
		new RelativeMove(95, 95),
		new RelativeMove(38, 0),
		new RelativeMove(20, 20),
		new RelativeMove(0, 42),
		new RelativeMove(48, 48),
		new RelativeMove(78, 0),
		new RelativeMove(68, 68),
		new RelativeMove(36, 0),
		new RelativeMove(8, 8)
	),
	CORSAIR_COVE_LANDS_END(
		PortLocation.CORSAIR_COVE,
		PortLocation.LANDS_END,
		// Sailing >= 40, used in 1 task
		new RelativeMove(55, -55),
		new RelativeMove(0, -48),
		new RelativeMove(-129, -129),
		new RelativeMove(-275, 0),
		new RelativeMove(-144, 144),
		new RelativeMove(-93, 0),
		new RelativeMove(-22, 22),
		new RelativeMove(0, 99),
		new RelativeMove(-71, 71),
		new RelativeMove(0, 180),
		new RelativeMove(-245, 245),
		new RelativeMove(-139, 0),
		new RelativeMove(-12, 12)
	),
	LANDS_END_PORT_PISCARILIUS(
		PortLocation.LANDS_END,
		PortLocation.PORT_PISCARILIUS,
		// Sailing >= 15, used in 3 tasks
		new RelativeMove(9, -9),
		new RelativeMove(294, 0),
		new RelativeMove(74, 74),
		new RelativeMove(0, 139),
		new RelativeMove(-43, 43)
	),
	PORT_PISCARILIUS_PORT_ROBERTS(
		PortLocation.PORT_PISCARILIUS,
		PortLocation.PORT_ROBERTS,
		// Sailing >= 50, used in 3 tasks
		new RelativeMove(0, -18),
		new RelativeMove(69, -69),
		new RelativeMove(0, -214),
		new RelativeMove(-56, -56)
	),
	PISCATORIS_PORT_PISCARILIUS(
		PortLocation.PISCATORIS,
		PortLocation.PORT_PISCARILIUS,
		// Sailing >= 75, used in 3 tasks
		new RelativeMove(-22, -22),
		new RelativeMove(-39, 0),
		new RelativeMove(-63, -63),
		new RelativeMove(-148, 0),
		new RelativeMove(-19, -19),
		new RelativeMove(-68, 0)
	),
	HOSIDIUS_PORT_PISCARILIUS(
		PortLocation.HOSIDIUS,
		PortLocation.PORT_PISCARILIUS,
		// Sailing >= 15, used in 2 tasks
		new RelativeMove(0, -25),
		new RelativeMove(21, -21),
		new RelativeMove(131, 0),
		new RelativeMove(22, 22),
		new RelativeMove(0, 174),
		new RelativeMove(-55, 55)
	),
	LUNAR_ISLE_PORT_PISCARILIUS(
		PortLocation.LUNAR_ISLE,
		PortLocation.PORT_PISCARILIUS,
		// Sailing >= 76, used in 5 tasks
		new RelativeMove(12, 0),
		new RelativeMove(3, -3),
		new RelativeMove(0, -21),
		new RelativeMove(-13, -13),
		new RelativeMove(-6, 0),
		new RelativeMove(-6, -6),
		new RelativeMove(-213, 0),
		new RelativeMove(-69, -69),
		new RelativeMove(0, -75),
		new RelativeMove(-13, -13)
	),
	PORT_PISCARILIUS_PORT_TYRAS(
		PortLocation.PORT_PISCARILIUS,
		PortLocation.PORT_TYRAS,
		// Sailing >= 66, used in 3 tasks
		new RelativeMove(47, -47),
		new RelativeMove(0, -182),
		new RelativeMove(61, -61),
		new RelativeMove(0, -211),
		new RelativeMove(35, -35),
		new RelativeMove(90, 0),
		new RelativeMove(30, -30)
	),
	PORT_PISCARILIUS_RELLEKKA(
		PortLocation.PORT_PISCARILIUS,
		PortLocation.RELLEKKA,
		// Sailing >= 62, used in 3 tasks
		new RelativeMove(113, 0),
		new RelativeMove(42, 42),
		new RelativeMove(195, 0),
		new RelativeMove(33, 33),
		new RelativeMove(236, 0),
		new RelativeMove(47, -47)
	),
	PORT_PISCARILIUS_PRIFDDINAS(
		PortLocation.PORT_PISCARILIUS,
		PortLocation.PRIFDDINAS,
		// Sailing >= 70, used in 2 tasks
		new RelativeMove(62, -62),
		new RelativeMove(0, -236),
		new RelativeMove(29, -29),
		new RelativeMove(155, 0),
		new RelativeMove(35, -35)
	),
	ALDARIN_CIVITAS_ILLA_FORTIS(
		PortLocation.ALDARIN,
		PortLocation.CIVITAS_ILLA_FORTIS,
		// Sailing >= 46, used in 3 tasks
		new RelativeMove(18, 0),
		new RelativeMove(97, -97),
		new RelativeMove(170, 0),
		new RelativeMove(74, 74),
		new RelativeMove(0, 67),
		new RelativeMove(76, 76),
		new RelativeMove(0, 48),
		new RelativeMove(-62, 62),
		new RelativeMove(-57, 0),
		new RelativeMove(-9, -9),
		new RelativeMove(0, -48),
		new RelativeMove(6, -6)
	),
	CIVITAS_ILLA_FORTIS_PORT_PISCARILIUS(
		PortLocation.CIVITAS_ILLA_FORTIS,
		PortLocation.PORT_PISCARILIUS,
		// Sailing >= 38, used in 3 tasks
		new RelativeMove(-7, 7),
		new RelativeMove(0, 84),
		new RelativeMove(135, 135),
		new RelativeMove(0, 239),
		new RelativeMove(-52, 52)
	),
	CIVITAS_ILLA_FORTIS_PORT_ROBERTS(
		PortLocation.CIVITAS_ILLA_FORTIS,
		PortLocation.PORT_ROBERTS,
		// Sailing >= 50, used in 3 tasks
		new RelativeMove(-8, 8),
		new RelativeMove(0, 103),
		new RelativeMove(53, 53)
	),
	CIVITAS_ILLA_FORTIS_DEEPFIN_POINT(
		PortLocation.CIVITAS_ILLA_FORTIS,
		PortLocation.DEEPFIN_POINT,
		// Sailing >= 67, used in 2 tasks
		new RelativeMove(-8, 8),
		new RelativeMove(0, 41),
		new RelativeMove(9, 9),
		new RelativeMove(63, 0),
		new RelativeMove(83, -83),
		new RelativeMove(0, -179),
		new RelativeMove(-20, -20),
		new RelativeMove(0, -143),
		new RelativeMove(25, -25)
	),
	CIVITAS_ILLA_FORTIS_PRIFDDINAS(
		PortLocation.CIVITAS_ILLA_FORTIS,
		PortLocation.PRIFDDINAS,
		// Sailing >= 70, used in 4 tasks
		new RelativeMove(-9, 9),
		new RelativeMove(0, 83),
		new RelativeMove(125, 125),
		new RelativeMove(198, 0),
		new RelativeMove(42, -42)
	),
	CIVITAS_ILLA_FORTIS_SUNSET_COAST(
		PortLocation.CIVITAS_ILLA_FORTIS,
		PortLocation.SUNSET_COAST,
		// Sailing >= 44, used in 2 tasks
		new RelativeMove(-8, 8),
		new RelativeMove(0, 41),
		new RelativeMove(10, 10),
		new RelativeMove(62, 0),
		new RelativeMove(59, -59),
		new RelativeMove(0, -62),
		new RelativeMove(-78, -78),
		new RelativeMove(0, -53),
		new RelativeMove(-72, -72),
		new RelativeMove(-171, 0),
		new RelativeMove(-65, 65)
	),
	PORT_ROBERTS_PORT_TYRAS(
		PortLocation.PORT_ROBERTS,
		PortLocation.PORT_TYRAS,
		// Sailing >= 66, used in 2 tasks
		new RelativeMove(0, -27),
		new RelativeMove(11, -11),
		new RelativeMove(53, 0),
		new RelativeMove(34, -34),
		new RelativeMove(0, -63),
		new RelativeMove(33, -33),
		new RelativeMove(84, 0),
		new RelativeMove(24, -24)
	),
	DEEPFIN_POINT_PORT_TYRAS(
		PortLocation.DEEPFIN_POINT,
		PortLocation.PORT_TYRAS,
		// Sailing >= 67, used in 3 tasks
		new RelativeMove(-27, 27),
		new RelativeMove(0, 48),
		new RelativeMove(145, 145),
		new RelativeMove(25, 0),
		new RelativeMove(67, 67),
		new RelativeMove(0, 54),
		new RelativeMove(8, 8)
	),
	PORT_TYRAS_PRIFDDINAS(
		PortLocation.PORT_TYRAS,
		PortLocation.PRIFDDINAS,
		// Sailing >= 70, used in 4 tasks
		new RelativeMove(-8, 8),
		new RelativeMove(0, 12),
		new RelativeMove(18, 18),
		new RelativeMove(0, 158)
	),
	LANDS_END_PORT_TYRAS(
		PortLocation.LANDS_END,
		PortLocation.PORT_TYRAS,
		// Sailing >= 66, used in 2 tasks
		new RelativeMove(0, -14),
		new RelativeMove(25, -25),
		new RelativeMove(135, 0),
		new RelativeMove(98, -98),
		new RelativeMove(145, 0),
		new RelativeMove(44, -44),
		new RelativeMove(0, -56),
		new RelativeMove(30, -30),
		new RelativeMove(84, 0),
		new RelativeMove(23, -23)
	),
	ALDARIN_PORT_TYRAS(
		PortLocation.ALDARIN,
		PortLocation.PORT_TYRAS,
		// Sailing >= 66, used in 1 task
		new RelativeMove(11, 0),
		new RelativeMove(98, -98),
		new RelativeMove(161, 0),
		new RelativeMove(56, 56),
		new RelativeMove(231, 0),
		new RelativeMove(109, 109),
		new RelativeMove(0, 62),
		new RelativeMove(9, 9)
	),
	PORT_ROBERTS_PRIFDDINAS(
		PortLocation.PORT_ROBERTS,
		PortLocation.PRIFDDINAS,
		// Sailing >= 70, used in 3 tasks
		new RelativeMove(0, 16),
		new RelativeMove(38, 38),
		new RelativeMove(161, 0),
		new RelativeMove(42, -42)
	),
	ARDOUGNE_PRIFDDINAS(
		PortLocation.ARDOUGNE,
		PortLocation.PRIFDDINAS,
		// Sailing >= 70, used in 3 tasks
		new RelativeMove(8, 0),
		new RelativeMove(10, -10),
		new RelativeMove(0, -106),
		new RelativeMove(31, -31),
		new RelativeMove(0, -236),
		new RelativeMove(-69, -69),
		new RelativeMove(0, -75),
		new RelativeMove(-49, -49),
		new RelativeMove(-239, 0),
		new RelativeMove(-12, 12),
		new RelativeMove(-98, 0),
		new RelativeMove(-14, -14),
		new RelativeMove(-58, 0),
		new RelativeMove(-85, 85),
		new RelativeMove(-88, 0),
		new RelativeMove(-26, 26),
		new RelativeMove(0, 101),
		new RelativeMove(142, 142),
		new RelativeMove(0, 86),
		new RelativeMove(25, 25),
		new RelativeMove(0, 148),
		new RelativeMove(10, 10)
	),
	DEEPFIN_POINT_PRIFDDINAS(
		PortLocation.DEEPFIN_POINT,
		PortLocation.PRIFDDINAS,
		// Sailing >= 70, used in 2 tasks
		new RelativeMove(-37, 37),
		new RelativeMove(0, 27),
		new RelativeMove(168, 168),
		new RelativeMove(0, 189),
		new RelativeMove(99, 99),
		new RelativeMove(0, 28),
		new RelativeMove(5, 5)
	),
	ALDARIN_PRIFDDINAS(
		PortLocation.ALDARIN,
		PortLocation.PRIFDDINAS,
		// Sailing >= 70, used in 2 tasks
		new RelativeMove(17, 0),
		new RelativeMove(97, -97),
		new RelativeMove(173, 0),
		new RelativeMove(38, 38),
		new RelativeMove(221, 0),
		new RelativeMove(127, 127),
		new RelativeMove(0, 86),
		new RelativeMove(26, 26),
		new RelativeMove(0, 139),
		new RelativeMove(5, 5)
	),
	LUNAR_ISLE_PRIFDDINAS(
		PortLocation.LUNAR_ISLE,
		PortLocation.PRIFDDINAS,
		// Sailing >= 76, used in 4 tasks
		new RelativeMove(8, 0),
		new RelativeMove(8, -8),
		new RelativeMove(0, -74),
		new RelativeMove(34, -34),
		new RelativeMove(0, -128),
		new RelativeMove(-24, -24),
		new RelativeMove(-78, 0),
		new RelativeMove(-43, -43),
		new RelativeMove(0, -67),
		new RelativeMove(11, -11),
		new RelativeMove(0, -119),
		new RelativeMove(54, -54)
	),
	ETCETERIA_RELLEKKA(
		PortLocation.ETCETERIA,
		PortLocation.RELLEKKA,
		// Sailing >= 65, used in 6 tasks
		new RelativeMove(0, -10),
		new RelativeMove(18, -18)
	),
	NEITIZNOT_RELLEKKA(
		PortLocation.NEITIZNOT,
		PortLocation.RELLEKKA,
		// Sailing >= 68, used in 3 tasks
		new RelativeMove(0, -15),
		new RelativeMove(13, -13),
		new RelativeMove(152, 0),
		new RelativeMove(45, -45)
	),
	RELLEKKA_SUNSET_COAST(
		PortLocation.RELLEKKA,
		PortLocation.SUNSET_COAST,
		// Sailing >= 62, used in 3 tasks
		new RelativeMove(-116, 0),
		new RelativeMove(-45, 45),
		new RelativeMove(-219, 0),
		new RelativeMove(-34, -34),
		new RelativeMove(0, -83),
		new RelativeMove(-24, -24),
		new RelativeMove(-186, 0),
		new RelativeMove(-46, -46),
		new RelativeMove(0, -398),
		new RelativeMove(-166, -166),
		new RelativeMove(0, -56),
		new RelativeMove(-67, -67),
		new RelativeMove(-160, 0),
		new RelativeMove(-61, 61)
	),
	PORT_ROBERTS_RELLEKKA(
		PortLocation.PORT_ROBERTS,
		PortLocation.RELLEKKA,
		// Sailing >= 62, used in 2 tasks
		new RelativeMove(-4, 19),
		new RelativeMove(193, 193),
		new RelativeMove(0, 24),
		new RelativeMove(64, 64),
		new RelativeMove(74, 0),
		new RelativeMove(45, 45),
		new RelativeMove(0, 87),
		new RelativeMove(15, 15),
		new RelativeMove(220, 0),
		new RelativeMove(45, -45)
	),
	PISCATORIS_RELLEKKA(
		PortLocation.PISCATORIS,
		PortLocation.RELLEKKA,
		// Sailing >= 75, used in 2 tasks
		new RelativeMove(0, 15),
		new RelativeMove(17, 17),
		new RelativeMove(182, 0),
		new RelativeMove(12, -12)
	),
	JATIZSO_RELLEKKA(
		PortLocation.JATIZSO,
		PortLocation.RELLEKKA,
		// Sailing >= 68, used in 2 tasks
		new RelativeMove(34, 0),
		new RelativeMove(67, -67)
	),
	PORT_TYRAS_RELLEKKA(
		PortLocation.PORT_TYRAS,
		PortLocation.RELLEKKA,
		// Sailing >= 66, used in 1 task
		new RelativeMove(0, 55),
		new RelativeMove(-118, 118),
		new RelativeMove(0, 87),
		new RelativeMove(42, 42),
		new RelativeMove(0, 142),
		new RelativeMove(48, 48),
		new RelativeMove(72, 0),
		new RelativeMove(44, 44),
		new RelativeMove(0, 89),
		new RelativeMove(14, 14),
		new RelativeMove(224, 0),
		new RelativeMove(45, -45)
	),
	ETCETERIA_JATIZSO(
		PortLocation.ETCETERIA,
		PortLocation.JATIZSO,
		// Sailing >= 68, used in 3 tasks
		new RelativeMove(0, -12),
		new RelativeMove(-29, -29),
		new RelativeMove(-86, 0),
		new RelativeMove(-19, -19)
	),
	ETCETERIA_PORT_ROBERTS(
		PortLocation.ETCETERIA,
		PortLocation.PORT_ROBERTS,
		// Sailing >= 65, used in 3 tasks
		new RelativeMove(0, -11),
		new RelativeMove(-32, -32),
		new RelativeMove(-94, 0),
		new RelativeMove(-33, -33),
		new RelativeMove(-200, 0),
		new RelativeMove(-47, -47),
		new RelativeMove(-120, 0),
		new RelativeMove(-13, 13),
		new RelativeMove(-69, 0),
		new RelativeMove(-108, -108),
		new RelativeMove(0, -252),
		new RelativeMove(-38, -38)
	),
	ETCETERIA_PORT_PISCARILIUS(
		PortLocation.ETCETERIA,
		PortLocation.PORT_PISCARILIUS,
		// Sailing >= 65, used in 2 tasks
		new RelativeMove(0, -18),
		new RelativeMove(-26, -26),
		new RelativeMove(-101, 0),
		new RelativeMove(-34, -34),
		new RelativeMove(-198, 0),
		new RelativeMove(-45, -45),
		new RelativeMove(-133, 0),
		new RelativeMove(-19, 19),
		new RelativeMove(-45, 0),
		new RelativeMove(-51, -51)
	),
	ETCETERIA_NEITIZNOT(
		PortLocation.ETCETERIA,
		PortLocation.NEITIZNOT,
		// Sailing >= 68, used in 2 tasks
		new RelativeMove(0, -22),
		new RelativeMove(-22, -22),
		new RelativeMove(-122, 0),
		new RelativeMove(-27, -27),
		new RelativeMove(-133, 0),
		new RelativeMove(-6, 6)
	),
	ETCETERIA_SUNSET_COAST(
		PortLocation.ETCETERIA,
		PortLocation.SUNSET_COAST,
		// Sailing >= 65, used in 2 tasks
		new RelativeMove(-63, -63),
		new RelativeMove(-100, 0),
		new RelativeMove(-20, -20),
		new RelativeMove(-184, 0),
		new RelativeMove(-31, -31),
		new RelativeMove(0, -87),
		new RelativeMove(-31, -31),
		new RelativeMove(-191, 0),
		new RelativeMove(-34, -34),
		new RelativeMove(0, -402),
		new RelativeMove(-118, -118),
		new RelativeMove(-31, 0),
		new RelativeMove(-15, -15),
		new RelativeMove(0, -84),
		new RelativeMove(-71, -71),
		new RelativeMove(-126, 0),
		new RelativeMove(-22, 22),
		new RelativeMove(0, 25),
		new RelativeMove(-9, 9),
		new RelativeMove(-33, 0),
		new RelativeMove(-27, 27)
	),
	ETCETERIA_PISCATORIS(
		PortLocation.ETCETERIA,
		PortLocation.PISCATORIS,
		// Sailing >= 75, used in 2 tasks
		new RelativeMove(0, -20),
		new RelativeMove(-26, -26),
		new RelativeMove(-100, 0),
		new RelativeMove(-51, -51),
		new RelativeMove(-103, 0),
		new RelativeMove(-32, -32)
	),
	ETCETERIA_HOSIDIUS(
		PortLocation.ETCETERIA,
		PortLocation.HOSIDIUS,
		// Sailing >= 65, used in 1 task
		new RelativeMove(0, -16),
		new RelativeMove(-27, -27),
		new RelativeMove(-99, 0),
		new RelativeMove(-30, -30),
		new RelativeMove(-198, 0),
		new RelativeMove(-43, -43),
		new RelativeMove(0, -88),
		new RelativeMove(-30, -30),
		new RelativeMove(-195, 0),
		new RelativeMove(-81, -81),
		new RelativeMove(-15, -15),
		new RelativeMove(0, -44),
		new RelativeMove(-32, -32),
		new RelativeMove(-62, 0),
		new RelativeMove(-21, 21),
		new RelativeMove(-21, 0),
		new RelativeMove(-4, -4)
	),
	LUNAR_ISLE_PISCATORIS(
		PortLocation.LUNAR_ISLE,
		PortLocation.PISCATORIS,
		// Sailing >= 76, used in 3 tasks
		new RelativeMove(3, 0),
		new RelativeMove(30, -30),
		new RelativeMove(29, 0),
		new RelativeMove(81, -81)
	),
	DEEPFIN_POINT_LUNAR_ISLE(
		PortLocation.DEEPFIN_POINT,
		PortLocation.LUNAR_ISLE,
		// Sailing >= 76, used in 2 tasks
		new RelativeMove(-31, 31),
		new RelativeMove(0, 134),
		new RelativeMove(0, 45),
		new RelativeMove(44, 44),
		new RelativeMove(0, 132),
		new RelativeMove(21, 21),
		new RelativeMove(0, 405),
		new RelativeMove(42, 42),
		new RelativeMove(180, 0),
		new RelativeMove(29, 29),
		new RelativeMove(0, 128),
		new RelativeMove(-41, 41),
		new RelativeMove(0, 48),
		new RelativeMove(5, 5),
		new RelativeMove(0, 11),
		new RelativeMove(-13, 13)
	),
	LUNAR_ISLE_PORT_ROBERTS(
		PortLocation.LUNAR_ISLE,
		PortLocation.PORT_ROBERTS,
		// Sailing >= 76, used in 2 tasks
		new RelativeMove(3, 0),
		new RelativeMove(14, -14),
		new RelativeMove(0, -8),
		new RelativeMove(-15, -15),
		new RelativeMove(-22, 0),
		new RelativeMove(-6, -6),
		new RelativeMove(-68, 0),
		new RelativeMove(-38, -38),
		new RelativeMove(0, -52),
		new RelativeMove(-117, -117),
		new RelativeMove(0, -242),
		new RelativeMove(-50, -50)
	),
	CIVITAS_ILLA_FORTIS_LUNAR_ISLE(
		PortLocation.CIVITAS_ILLA_FORTIS,
		PortLocation.LUNAR_ISLE,
		// Sailing >= 76, used in 2 tasks
		new RelativeMove(-9, 9),
		new RelativeMove(0, 73),
		new RelativeMove(285, 285),
		new RelativeMove(0, 32),
		new RelativeMove(67, 67),
		new RelativeMove(79, 0),
		new RelativeMove(14, 14),
		new RelativeMove(0, 144),
		new RelativeMove(-33, 33),
		new RelativeMove(0, 67),
		new RelativeMove(-13, 13)
	),
	LUNAR_ISLE_RED_ROCK(
		PortLocation.LUNAR_ISLE,
		PortLocation.RED_ROCK,
		// Sailing >= 76, used in 2 tasks
		new RelativeMove(3, 0),
		new RelativeMove(12, -12),
		new RelativeMove(0, -72),
		new RelativeMove(36, -36),
		new RelativeMove(0, -132),
		new RelativeMove(-27, -27),
		new RelativeMove(-76, 0),
		new RelativeMove(-41, -41),
		new RelativeMove(0, -164),
		new RelativeMove(-102, -102),
		new RelativeMove(0, -163),
		new RelativeMove(40, -40),
		new RelativeMove(0, -167),
		new RelativeMove(-25, -25),
		new RelativeMove(0, -96),
		new RelativeMove(55, -55),
		new RelativeMove(68, 0),
		new RelativeMove(167, -167),
		new RelativeMove(270, 0),
		new RelativeMove(92, -92),
		new RelativeMove(181, 0),
		new RelativeMove(4, 4)
	),
	ALDARIN_LUNAR_ISLE(
		PortLocation.ALDARIN,
		PortLocation.LUNAR_ISLE,
		// Sailing >= 76, used in 1 task
		new RelativeMove(29, 0),
		new RelativeMove(41, -41),
		new RelativeMove(42, 0),
		new RelativeMove(10, -10),
		new RelativeMove(0, -25),
		new RelativeMove(21, -21),
		new RelativeMove(142, 0),
		new RelativeMove(92, 92),
		new RelativeMove(0, 72),
		new RelativeMove(126, 126),
		new RelativeMove(0, 235),
		new RelativeMove(-48, 48),
		new RelativeMove(0, 183),
		new RelativeMove(156, 156),
		new RelativeMove(0, 8),
		new RelativeMove(41, 41),
		new RelativeMove(43, 0),
		new RelativeMove(10, 10),
		new RelativeMove(7, 0),
		new RelativeMove(6, 6),
		new RelativeMove(0, 11),
		new RelativeMove(-13, 13)
	),
	PORT_SARIM_RELLEKKA(
		PortLocation.PORT_SARIM,
		PortLocation.RELLEKKA,
		// Sailing >= 62, used in 1 task
		new RelativeMove(0, -45),
		new RelativeMove(-47, -47),
		new RelativeMove(-29, 0),
		new RelativeMove(-12, 12),
		new RelativeMove(0, 40),
		new RelativeMove(-62, 62),
		new RelativeMove(-89, 0),
		new RelativeMove(-36, 36),
		new RelativeMove(-61, 0),
		new RelativeMove(-32, -32),
		new RelativeMove(0, -72),
		new RelativeMove(38, -38),
		new RelativeMove(0, -276),
		new RelativeMove(-148, -148),
		new RelativeMove(-410, 0),
		new RelativeMove(-73, 73),
		new RelativeMove(-66, 0),
		new RelativeMove(-44, 44),
		new RelativeMove(0, 78),
		new RelativeMove(-51, 51),
		new RelativeMove(0, 200),
		new RelativeMove(26, 26),
		new RelativeMove(0, 292),
		new RelativeMove(156, 156),
		new RelativeMove(73, 0),
		new RelativeMove(40, 40),
		new RelativeMove(0, 90),
		new RelativeMove(19, 19),
		new RelativeMove(218, 0),
		new RelativeMove(46, -46)
	),
	PANDEMONIUM_CAIRN_ISLE(
		PortLocation.PANDEMONIUM,
		PortLocation.CAIRN_ISLE,
		// Sailing >= 42, used in 1 task
		new RelativeMove(0, -21),
		new RelativeMove(-58, -58),
		new RelativeMove(-20, 0),
		new RelativeMove(-30, -30),
		new RelativeMove(-200, 0),
		new RelativeMove(-25, 25)
	),
	MUSA_POINT_CORSAIR_COVE(
		PortLocation.MUSA_POINT,
		PortLocation.CORSAIR_COVE,
		// Sailing >= 40, used in 1 task
		new RelativeMove(0, 8),
		new RelativeMove(-61, 61),
		new RelativeMove(-85, 0),
		new RelativeMove(-41, 41),
		new RelativeMove(-59, 0),
		new RelativeMove(-30, -30),
		new RelativeMove(0, -82),
		new RelativeMove(36, -36),
		new RelativeMove(0, -209),
		new RelativeMove(-55, -55)
	),
	MUSA_POINT_SUMMER_SHORE(
		PortLocation.MUSA_POINT,
		PortLocation.SUMMER_SHORE,
		// Sailing >= 45, used in 1 task
		new RelativeMove(0, -27),
		new RelativeMove(42, -42),
		new RelativeMove(0, -48),
		new RelativeMove(-3, -3),
		new RelativeMove(0, -135),
		new RelativeMove(-22, -22),
		new RelativeMove(0, -46),
		new RelativeMove(40, -40),
		new RelativeMove(0, -69),
		new RelativeMove(49, -49),
		new RelativeMove(0, -252),
		new RelativeMove(15, -15),
		new RelativeMove(10, 0),
		new RelativeMove(5, -5),
		new RelativeMove(3, 0),
		new RelativeMove(5, -5),
		new RelativeMove(6, 0),
		new RelativeMove(21, -21)
	),
	MUSA_POINT_PORT_TYRAS(
		PortLocation.MUSA_POINT,
		PortLocation.PORT_TYRAS,
		// Sailing >= 66, used in 1 task
		new RelativeMove(0, -27),
		new RelativeMove(42, -42),
		new RelativeMove(0, -48),
		new RelativeMove(-3, -3),
		new RelativeMove(0, -128),
		new RelativeMove(-21, -21),
		new RelativeMove(-260, 0),
		new RelativeMove(-75, -75),
		new RelativeMove(0, -77),
		new RelativeMove(-40, -40),
		new RelativeMove(-450, 0),
		new RelativeMove(-75, 75),
		new RelativeMove(-53, 0),
		new RelativeMove(-40, 40),
		new RelativeMove(0, 94),
		new RelativeMove(151, 151)
	),
	CATHERBY_PORT_PISCARILIUS(
		PortLocation.CATHERBY,
		PortLocation.PORT_PISCARILIUS,
		// Sailing >= 20, used in 1 task
		new RelativeMove(0, -16),
		new RelativeMove(-41, -41),
		new RelativeMove(0, -64),
		new RelativeMove(-67, -67),
		new RelativeMove(0, -82),
		new RelativeMove(31, -31),
		new RelativeMove(0, -280),
		new RelativeMove(-140, -140),
		new RelativeMove(-421, 0),
		new RelativeMove(-74, 74),
		new RelativeMove(-66, 0),
		new RelativeMove(-38, 38),
		new RelativeMove(0, 85),
		new RelativeMove(-57, 57),
		new RelativeMove(0, 173),
		new RelativeMove(34, 34),
		new RelativeMove(0, 387),
		new RelativeMove(-112, 112)
	),
	BRIMHAVEN_CIVITAS_ILLA_FORTIS(
		PortLocation.BRIMHAVEN,
		PortLocation.CIVITAS_ILLA_FORTIS,
		// Sailing >= 38, used in 1 task
		new RelativeMove(0, 18),
		new RelativeMove(-5, 5),
		new RelativeMove(-34, 0),
		new RelativeMove(-27, -27),
		new RelativeMove(0, -83),
		new RelativeMove(32, -32),
		new RelativeMove(0, -283),
		new RelativeMove(-145, -145),
		new RelativeMove(-411, 0),
		new RelativeMove(-92, 92),
		new RelativeMove(-68, 0),
		new RelativeMove(-24, 24),
		new RelativeMove(0, 82),
		new RelativeMove(-51, 51),
		new RelativeMove(0, 172),
		new RelativeMove(-97, 97),
		new RelativeMove(-61, 0),
		new RelativeMove(-10, -10),
		new RelativeMove(0, -44),
		new RelativeMove(4, -4)
	),
	ARDOUGNE_SUMMER_SHORE(
		PortLocation.ARDOUGNE,
		PortLocation.SUMMER_SHORE,
		// Sailing >= 45, used in 1 task
		new RelativeMove(8, 0),
		new RelativeMove(10, -10),
		new RelativeMove(0, -111),
		new RelativeMove(32, -32),
		new RelativeMove(0, -202),
		new RelativeMove(104, -104),
		new RelativeMove(0, -72),
		new RelativeMove(120, -120),
		new RelativeMove(0, -36),
		new RelativeMove(141, -141),
		new RelativeMove(0, -31),
		new RelativeMove(33, -33)
	),
	ARDOUGNE_CIVITAS_ILLA_FORTIS(
		PortLocation.ARDOUGNE,
		PortLocation.CIVITAS_ILLA_FORTIS,
		// Sailing >= 38, used in 1 task
		new RelativeMove(7, 0),
		new RelativeMove(12, -12),
		new RelativeMove(0, -101),
		new RelativeMove(33, -33),
		new RelativeMove(0, -290),
		new RelativeMove(-138, -138),
		new RelativeMove(-415, 0),
		new RelativeMove(-82, 82),
		new RelativeMove(-78, 0),
		new RelativeMove(-27, 27),
		new RelativeMove(0, 91),
		new RelativeMove(-61, 61),
		new RelativeMove(0, 165),
		new RelativeMove(-93, 93),
		new RelativeMove(-54, 0),
		new RelativeMove(-13, -13),
		new RelativeMove(0, -43),
		new RelativeMove(4, -4)
	),
	ARDOUGNE_VOID_KNIGHTS_OUTPOST(
		PortLocation.ARDOUGNE,
		PortLocation.VOID_KNIGHTS_OUTPOST,
		// Sailing >= 50, used in 1 task
		new RelativeMove(7, 0),
		new RelativeMove(11, -11),
		new RelativeMove(0, -109),
		new RelativeMove(33, -33),
		new RelativeMove(0, -255),
		new RelativeMove(-70, -70)
	),
	PORT_KHAZARD_RELLEKKA(
		PortLocation.PORT_KHAZARD,
		PortLocation.RELLEKKA,
		// Sailing >= 62, used in 1 task
		new RelativeMove(0, -19),
		new RelativeMove(37, -37),
		new RelativeMove(0, -270),
		new RelativeMove(-151, -151),
		new RelativeMove(-403, 0),
		new RelativeMove(-96, 96),
		new RelativeMove(-60, 0),
		new RelativeMove(-34, 34),
		new RelativeMove(0, 109),
		new RelativeMove(35, 35),
		new RelativeMove(0, 142),
		new RelativeMove(-56, 56),
		new RelativeMove(0, 411),
		new RelativeMove(41, 41),
		new RelativeMove(177, 0),
		new RelativeMove(53, 53),
		new RelativeMove(0, 75),
		new RelativeMove(19, 19),
		new RelativeMove(216, 0),
		new RelativeMove(47, -47)
	),
	PORT_KHAZARD_PORT_PISCARILIUS(
		PortLocation.PORT_KHAZARD,
		PortLocation.PORT_PISCARILIUS,
		// Sailing >= 30, used in 1 task
		new RelativeMove(0, -18),
		new RelativeMove(37, -37),
		new RelativeMove(0, -268),
		new RelativeMove(-155, -155),
		new RelativeMove(-401, 0),
		new RelativeMove(-78, 78),
		new RelativeMove(-68, 0),
		new RelativeMove(-44, 44),
		new RelativeMove(0, 73),
		new RelativeMove(-48, 48),
		new RelativeMove(0, 199),
		new RelativeMove(23, 23),
		new RelativeMove(0, 400),
		new RelativeMove(-109, 109)
	),
	CORSAIR_COVE_CIVITAS_ILLA_FOTRIS(
		PortLocation.CORSAIR_COVE,
		PortLocation.CIVITAS_ILLA_FORTIS,
		// Sailing >= 40, used in 1 task
		new RelativeMove(48, -48),
		new RelativeMove(0, -54),
		new RelativeMove(-57, -57),
		new RelativeMove(-410, 0),
		new RelativeMove(-65, 65),
		new RelativeMove(-84, 0),
		new RelativeMove(-37, 37),
		new RelativeMove(0, 95),
		new RelativeMove(-72, 72),
		new RelativeMove(0, 171),
		new RelativeMove(-78, 78),
		new RelativeMove(-59, 0),
		new RelativeMove(-11, -11),
		new RelativeMove(0, -43),
		new RelativeMove(5, -5)
	),
	CORSAIR_COVE_ALDARIN(
		PortLocation.CORSAIR_COVE,
		PortLocation.ALDARIN,
		// Sailing >= 46, used in 1 task
		new RelativeMove(45, -45),
		new RelativeMove(0, -54),
		new RelativeMove(-60, -60),
		new RelativeMove(-410, 0),
		new RelativeMove(-76, 76),
		new RelativeMove(-33, 0),
		new RelativeMove(-90, 90),
		new RelativeMove(-191, 0),
		new RelativeMove(-10, -10),
		new RelativeMove(-49, 0),
		new RelativeMove(-39, 39),
		new RelativeMove(-77, 0),
		new RelativeMove(-21, 21),
		new RelativeMove(0, 26),
		new RelativeMove(-10, 10),
		new RelativeMove(-47, 0),
		new RelativeMove(-40, 40)
	),
	DEEPFIN_POINT_RUINS_OF_UNKAH(
		PortLocation.DEEPFIN_POINT,
		PortLocation.RUINS_OF_UNKAH,
		// Sailing >= 67, used in 1 task
		new RelativeMove(5, -5),
		new RelativeMove(172, 0),
		new RelativeMove(61, -61),
		new RelativeMove(587, 0),
		new RelativeMove(89, -89),
		new RelativeMove(249, 0),
		new RelativeMove(59, 59),
		new RelativeMove(0, 82),
		new RelativeMove(-9, 9),
		new RelativeMove(0, 65),
		new RelativeMove(7, 7)
	),
	DEEPFIN_POINT_LANDS_END(
		PortLocation.DEEPFIN_POINT,
		PortLocation.LANDS_END,
		// Sailing >= 67, used in 1 task
		new RelativeMove(-34, 34),
		new RelativeMove(0, 156),
		new RelativeMove(37, 37),
		new RelativeMove(0, 145),
		new RelativeMove(29, 29),
		new RelativeMove(0, 191),
		new RelativeMove(-55, 55),
		new RelativeMove(-371, 0),
		new RelativeMove(-6, 6)
	),
	LANDS_END_PORT_KHAZARD(
		PortLocation.LANDS_END,
		PortLocation.PORT_KHAZARD,
		// Sailing >= 30, used in 1 task
		new RelativeMove(0, -10),
		new RelativeMove(12, -12),
		new RelativeMove(134, 0),
		new RelativeMove(116, -116),
		new RelativeMove(150, 0),
		new RelativeMove(31, -31),
		new RelativeMove(0, -91),
		new RelativeMove(68, -68),
		new RelativeMove(0, -152),
		new RelativeMove(-42, -42),
		new RelativeMove(0, -77),
		new RelativeMove(50, -50),
		new RelativeMove(65, 0),
		new RelativeMove(132, -132),
		new RelativeMove(283, 0),
		new RelativeMove(215, 215),
		new RelativeMove(0, 272),
		new RelativeMove(-37, 37)
	),
	LANDS_END_LUNAR_ISLE(
		PortLocation.LANDS_END,
		PortLocation.LUNAR_ISLE,
		// Sailing >= 76, used in 2 tasks
		new RelativeMove(8, -8),
		new RelativeMove(291, 0),
		new RelativeMove(113, 113),
		new RelativeMove(0, 140),
		new RelativeMove(143, 143),
		new RelativeMove(0, 6),
		new RelativeMove(43, 43),
		new RelativeMove(41, 0),
		new RelativeMove(6, 6),
		new RelativeMove(7, 0),
		new RelativeMove(9, 9),
		new RelativeMove(0, 11),
		new RelativeMove(-13, 13)
	),
	MUSA_POINT_PORT_PISCARILIUS(
		PortLocation.MUSA_POINT,
		PortLocation.PORT_PISCARILIUS,
		// Sailing >= 15, used in 1 task
		new RelativeMove(0, -26),
		new RelativeMove(42, -42),
		new RelativeMove(0, -161),
		new RelativeMove(-38, -38),
		new RelativeMove(-201, 0),
		new RelativeMove(-192, -192),
		new RelativeMove(-418, 0),
		new RelativeMove(-85, 85),
		new RelativeMove(-60, 0),
		new RelativeMove(-32, 32),
		new RelativeMove(0, 78),
		new RelativeMove(-50, 50),
		new RelativeMove(0, 197),
		new RelativeMove(27, 27),
		new RelativeMove(0, 383),
		new RelativeMove(-113, 113)
	),
	CIVITAS_ILLA_FORTIS_PORT_SARIM(
		PortLocation.CIVITAS_ILLA_FORTIS,
		PortLocation.PORT_SARIM,
		// Sailing >= 38, used in 1 task
		new RelativeMove(-8, 8),
		new RelativeMove(0, 39),
		new RelativeMove(15, 15),
		new RelativeMove(51, 0),
		new RelativeMove(92, -92),
		new RelativeMove(0, -177),
		new RelativeMove(63, -63),
		new RelativeMove(0, -59),
		new RelativeMove(62, -62),
		new RelativeMove(55, 0),
		new RelativeMove(69, -69),
		new RelativeMove(412, 0),
		new RelativeMove(196, 196),
		new RelativeMove(203, 0),
		new RelativeMove(27, 27),
		new RelativeMove(0, 183),
		new RelativeMove(50, 50)
	),
	BRIMHAVEN_PORT_TYRAS(
		PortLocation.BRIMHAVEN,
		PortLocation.PORT_TYRAS,
		// Sailing >= 66, used in 1 task
		new RelativeMove(0, 15),
		new RelativeMove(-8, 8),
		new RelativeMove(-27, 0),
		new RelativeMove(-31, -31),
		new RelativeMove(0, -80),
		new RelativeMove(38, -38),
		new RelativeMove(0, -209),
		new RelativeMove(-85, -85),
		new RelativeMove(0, -72),
		new RelativeMove(-55, -55),
		new RelativeMove(-420, 0),
		new RelativeMove(-74, 74),
		new RelativeMove(-65, 0),
		new RelativeMove(-40, 40),
		new RelativeMove(0, 110),
		new RelativeMove(154, 154)
	),
	LUNAR_ISLE_PORT_TYRAS(
		PortLocation.LUNAR_ISLE,
		PortLocation.PORT_TYRAS,
		// Sailing >= 76, used in 1 task
		new RelativeMove(2, 0),
		new RelativeMove(14, -14),
		new RelativeMove(0, -9),
		new RelativeMove(-5, -5),
		new RelativeMove(0, -52),
		new RelativeMove(41, -41),
		new RelativeMove(0, -129),
		new RelativeMove(-26, -26),
		new RelativeMove(-78, 0),
		new RelativeMove(-41, -41),
		new RelativeMove(0, -192),
		new RelativeMove(80, -80),
		new RelativeMove(0, -144),
		new RelativeMove(-13, -13),
		new RelativeMove(0, -14),
		new RelativeMove(6, -6)
	),
	PORT_TYRAS_RED_ROCK(
		PortLocation.PORT_TYRAS,
		PortLocation.RED_ROCK,
		// Sailing >= 66, used in 1 task
		new RelativeMove(-21, -21),
		new RelativeMove(0, -67),
		new RelativeMove(-141, -141),
		new RelativeMove(0, -76),
		new RelativeMove(57, -57),
		new RelativeMove(68, 0),
		new RelativeMove(69, -69),
		new RelativeMove(311, 0),
		new RelativeMove(192, -192),
		new RelativeMove(136, 0),
		new RelativeMove(2, 2)
	),
	PRIFDDINAS_RELLEKKA(
		PortLocation.PRIFDDINAS,
		PortLocation.RELLEKKA,
		// Sailing >= 70, used in 1 task
		new RelativeMove(-43, 0),
		new RelativeMove(-50, 50),
		new RelativeMove(0, 193),
		new RelativeMove(42, 42),
		new RelativeMove(78, 0),
		new RelativeMove(44, 44),
		new RelativeMove(0, 85),
		new RelativeMove(24, 24),
		new RelativeMove(211, 0),
		new RelativeMove(48, -48)
	),
	PRIFDDINAS_VOID_KNIGHTS_OUTPOST(
		PortLocation.PRIFDDINAS,
		PortLocation.VOID_KNIGHTS_OUTPOST,
		// Sailing >= 70, used in 1 task
		new RelativeMove(-46, 0),
		new RelativeMove(-32, 32),
		new RelativeMove(-50, 0),
		new RelativeMove(-72, -72),
		new RelativeMove(0, -134),
		new RelativeMove(51, -51),
		new RelativeMove(0, -180),
		new RelativeMove(-27, -27),
		new RelativeMove(0, -78),
		new RelativeMove(47, -47),
		new RelativeMove(66, 0),
		new RelativeMove(79, -79)
	),
	DEEPFIN_POINT_RELLEKKA(
		PortLocation.DEEPFIN_POINT,
		PortLocation.RELLEKKA,
		// Sailing >= 67, used in 1 task
		new RelativeMove(-24, 24),
		new RelativeMove(0, 182),
		new RelativeMove(33, 33),
		new RelativeMove(0, 138),
		new RelativeMove(26, 26),
		new RelativeMove(0, 404),
		new RelativeMove(49, 49),
		new RelativeMove(175, 0),
		new RelativeMove(58, 58),
		new RelativeMove(0, 78),
		new RelativeMove(14, 14),
		new RelativeMove(210, 0),
		new RelativeMove(49, -49)
	),
	DEEPFIN_POINT_ETCETERIA(
		PortLocation.DEEPFIN_POINT,
		PortLocation.ETCETERIA,
		// Sailing >= 67, used in 1 task
		new RelativeMove(-24, 24),
		new RelativeMove(0, 182),
		new RelativeMove(33, 33),
		new RelativeMove(0, 138),
		new RelativeMove(26, 26),
		new RelativeMove(0, 404),
		new RelativeMove(49, 49),
		new RelativeMove(175, 0),
		new RelativeMove(58, 58),
		new RelativeMove(0, 78),
		new RelativeMove(14, 14),
		new RelativeMove(196, 0),
		new RelativeMove(39, 39),
		new RelativeMove(91, 0),
		new RelativeMove(32, 32)
	),
	DEEPFIN_POINT_HOSIDIUS(
		PortLocation.DEEPFIN_POINT,
		PortLocation.HOSIDIUS,
		new RelativeMove(-32, 32),
		new RelativeMove(0, 152),
		new RelativeMove(33, 33),
		new RelativeMove(0, 149),
		new RelativeMove(33, 33),
		new RelativeMove(0, 183),
		new RelativeMove(-66, 66),
		new RelativeMove(-142, 0),
		new RelativeMove(-23, 23)
	),
	RED_ROCK_DEEPFIN_POINT(
		PortLocation.RED_ROCK,
		PortLocation.DEEPFIN_POINT,
		new RelativeMove(0, -16),
		new RelativeMove(-9, -9),
		new RelativeMove(-330, 0),
		new RelativeMove(-122, 122),
		new RelativeMove(-49, 0),
		new RelativeMove(-80, 80),
		new RelativeMove(-249, 0),
		new RelativeMove(-52, 52)
	),
	PORT_PISCARILIUS_DEEPFIN_POINT(
		PortLocation.PORT_PISCARILIUS,
		PortLocation.DEEPFIN_POINT,
		new RelativeMove(0, -23),
		new RelativeMove(106, -106),
		new RelativeMove(0, -414),
		new RelativeMove(-22, -22),
		new RelativeMove(0, -214),
		new RelativeMove(-16, -16),
		new RelativeMove(0, -126),
		new RelativeMove(8, -8)
		),
	DEEPFIN_POINT_PORT_ROBERTS(
		PortLocation.DEEPFIN_POINT,
		PortLocation.PORT_ROBERTS,
		new RelativeMove(-44, 44),
		new RelativeMove(0, 103),
		new RelativeMove(42, 42),
		new RelativeMove(0, 176),
		new RelativeMove(32, 32),
		new RelativeMove(0, 83),
		new RelativeMove(-33, 33),
		new RelativeMove(-49, 0),
		new RelativeMove(-13, 13)
	),
	ARDOUGNE_PORT_ROBERTS(
		PortLocation.ARDOUGNE,
		PortLocation.PORT_ROBERTS,
		new RelativeMove(19, -19),
		new RelativeMove(0, -93),
		new RelativeMove(36, -36),
		new RelativeMove(0, -273),
		new RelativeMove(-153, -153),
		new RelativeMove(-403, 0),
		new RelativeMove(-74, 74),
		new RelativeMove(-83, 0),
		new RelativeMove(-33, 33),
		new RelativeMove(0, 107),
		new RelativeMove(-47, 47),
		new RelativeMove(0, 177),
		new RelativeMove(24, 24),
		new RelativeMove(0, 80),
		new RelativeMove(-41, 41),
		new RelativeMove(-45, 0),
		new RelativeMove(-12, 12)
	),
	PORT_ROBERTS_RED_ROCK(
		PortLocation.PORT_ROBERTS,
		PortLocation.RED_ROCK,
		new RelativeMove(0, -25),
		new RelativeMove(13, -13),
		new RelativeMove(48, 0),
		new RelativeMove(45, -45),
		new RelativeMove(0, -91),
		new RelativeMove(43, -43),
		new RelativeMove(0, -174),
		new RelativeMove(-29, -29),
		new RelativeMove(0, -79),
		new RelativeMove(54, -54),
		new RelativeMove(66, 0),
		new RelativeMove(66, -66),
		new RelativeMove(506, 0),
		new RelativeMove(72, -72),
		new RelativeMove(0, -85),
		new RelativeMove(39, -39),
		new RelativeMove(29, 0),
		new RelativeMove(4, 4)
	),
	PORT_ROBERTS_PORT_SARIM(
		PortLocation.PORT_ROBERTS,
		PortLocation.PORT_SARIM,
		new RelativeMove(0, -22),
		new RelativeMove(17, -17),
		new RelativeMove(54, 0),
		new RelativeMove(28, -28),
		new RelativeMove(0, -100),
		new RelativeMove(44, -44),
		new RelativeMove(0, -183),
		new RelativeMove(-20, -20),
		new RelativeMove(0, -75),
		new RelativeMove(64, -64),
		new RelativeMove(49, 0),
		new RelativeMove(66, -66),
		new RelativeMove(422, 0),
		new RelativeMove(192, 192),
		new RelativeMove(200, 0),
		new RelativeMove(33, 33),
		new RelativeMove(0, 194),
		new RelativeMove(49, 49)
	),
	PORT_ROBERTS_CATHERBY(
		PortLocation.PORT_ROBERTS,
		PortLocation.CATHERBY,
		new RelativeMove(0, -22),
		new RelativeMove(17, -17),
		new RelativeMove(40, 0),
		new RelativeMove(44, -44),
		new RelativeMove(0, -87),
		new RelativeMove(47, -47),
		new RelativeMove(0, -166),
		new RelativeMove(-26, -26),
		new RelativeMove(0, -95),
		new RelativeMove(50, -50),
		new RelativeMove(70, 0),
		new RelativeMove(68, -68),
		new RelativeMove(413, 0),
		new RelativeMove(144, 144),
		new RelativeMove(0, 280),
		new RelativeMove(-36, 36),
		new RelativeMove(0, 74),
		new RelativeMove(68, 68),
		new RelativeMove(0, 67),
		new RelativeMove(39, 39)
	),
	PORT_ROBERTS_LANDS_END(
		PortLocation.PORT_ROBERTS,
		PortLocation.LANDS_END,
		new RelativeMove(-121, 0),
		new RelativeMove(-98, 98)
	),
	ALDARIN_PISCATORIS(
		PortLocation.ALDARIN,
		PortLocation.PISCATORIS,
		new RelativeMove(20, 0),
		new RelativeMove(40, -40),
		new RelativeMove(51, 0),
		new RelativeMove(11, -11),
		new RelativeMove(0, -25),
		new RelativeMove(21, -21),
		new RelativeMove(137, 0),
		new RelativeMove(87, 87),
		new RelativeMove(0, 64),
		new RelativeMove(137, 137),
		new RelativeMove(0, 401),
		new RelativeMove(36, 36),
		new RelativeMove(193, 0),
		new RelativeMove(59, 59),
		new RelativeMove(38, 0),
		new RelativeMove(16, 16)
	),
	ALDARIN_RELLEKKA(
		PortLocation.ALDARIN,
		PortLocation.RELLEKKA,
		new RelativeMove(20, 0),
		new RelativeMove(40, -40),
		new RelativeMove(51, 0),
		new RelativeMove(11, -11),
		new RelativeMove(0, -25),
		new RelativeMove(21, -21),
		new RelativeMove(137, 0),
		new RelativeMove(87, 87),
		new RelativeMove(0, 64),
		new RelativeMove(137, 137),
		new RelativeMove(0, 401),
		new RelativeMove(36, 36),
		new RelativeMove(193, 0),
		new RelativeMove(35, 35),
		new RelativeMove(0, 100),
		new RelativeMove(16, 16),
		new RelativeMove(227, 0),
		new RelativeMove(47, -47)
	),
	ALDARIN_BRIMHAVEN(
		PortLocation.ALDARIN,
		PortLocation.BRIMHAVEN,
		new RelativeMove(20, 0),
		new RelativeMove(40, -40),
		new RelativeMove(51, 0),
		new RelativeMove(11, -11),
		new RelativeMove(0, -25),
		new RelativeMove(21, -21),
		new RelativeMove(117, 0),
		new RelativeMove(195, -195),
		new RelativeMove(668, 0),
		new RelativeMove(148, 148),
		new RelativeMove(0, 284),
		new RelativeMove(-36, 36),
		new RelativeMove(0, 74),
		new RelativeMove(28, 28),
		new RelativeMove(33, 0),
		new RelativeMove(4, -4)
	),
	ALDARIN_VOID_KNIGHTS_OUTPOST(
		PortLocation.ALDARIN,
		PortLocation.VOID_KNIGHTS_OUTPOST,
		new RelativeMove(20, 0),
		new RelativeMove(40, -40),
		new RelativeMove(51, 0),
		new RelativeMove(11, -11),
		new RelativeMove(0, -25),
		new RelativeMove(21, -21),
		new RelativeMove(117, 0),
		new RelativeMove(197, -197)
	),
	ALDARIN_PORT_ROBERTS(
		PortLocation.ALDARIN,
		PortLocation.PORT_ROBERTS,
		new RelativeMove(20, 0),
		new RelativeMove(40, -40),
		new RelativeMove(51, 0),
		new RelativeMove(11, -11),
		new RelativeMove(0, -25),
		new RelativeMove(21, -21),
		new RelativeMove(134, 0),
		new RelativeMove(88, 88),
		new RelativeMove(0, 62),
		new RelativeMove(72, 72),
		new RelativeMove(0, 42),
		new RelativeMove(-33, 33)
	),
	ALDARIN_SUNSET_COAST(
		PortLocation.ALDARIN,
		PortLocation.SUNSET_COAST,
		new RelativeMove(22, 0),
		new RelativeMove(6, -6)
	),
	ALDARIN_DEEPFIN_POINT(
		PortLocation.ALDARIN,
		PortLocation.DEEPFIN_POINT,
		new RelativeMove(20, 0),
		new RelativeMove(40, -40),
		new RelativeMove(51, 0),
		new RelativeMove(11, -11),
		new RelativeMove(0, -25),
		new RelativeMove(21, -21),
		new RelativeMove(115, 0),
		new RelativeMove(128, -128)
	),
	RED_ROCK_CIVITAS_ILLA_FORTIS(
		PortLocation.RED_ROCK,
		PortLocation.CIVITAS_ILLA_FORTIS,
		new RelativeMove(0, -16),
		new RelativeMove(-9, -9),
		new RelativeMove(-336, 0),
		new RelativeMove(-124, 124),
		new RelativeMove(-95, 0),
		new RelativeMove(-172, 172),
		new RelativeMove(-62, 0),
		new RelativeMove(-36, 36),
		new RelativeMove(0, 60),
		new RelativeMove(-68, 68),
		new RelativeMove(0, 177),
		new RelativeMove(-82, 82),
		new RelativeMove(-58, 0),
		new RelativeMove(-11, -11),
		new RelativeMove(0, -45),
		new RelativeMove(4, -4)
	),
	CIVITAS_ILLA_FORTIS_SUMMER_SHORE(
		PortLocation.CIVITAS_ILLA_FORTIS,
		PortLocation.SUMMER_SHORE,
		new RelativeMove(-9, 9),
		new RelativeMove(0, 40),
		new RelativeMove(17, 17),
		new RelativeMove(48, 0),
		new RelativeMove(107, -107),
		new RelativeMove(0, -166),
		new RelativeMove(51, -51),
		new RelativeMove(0, -68),
		new RelativeMove(61, -61),
		new RelativeMove(72, 0),
		new RelativeMove(24, -24),
		new RelativeMove(0, -26),
		new RelativeMove(21, -21),
		new RelativeMove(706, 0),
		new RelativeMove(69, -69),
		new RelativeMove(0, -43),
		new RelativeMove(148, -148),
		new RelativeMove(0, -25),
		new RelativeMove(34, -34)
	),
	CIVITAS_ILLA_FORTIS_VOID_KNIGHTS_OUTPOST(
		PortLocation.CIVITAS_ILLA_FORTIS,
		PortLocation.VOID_KNIGHTS_OUTPOST,
		new RelativeMove(-9, 9),
		new RelativeMove(0, 40),
		new RelativeMove(17, 17),
		new RelativeMove(48, 0),
		new RelativeMove(107, -107),
		new RelativeMove(0, -166),
		new RelativeMove(51, -51),
		new RelativeMove(0, -68),
		new RelativeMove(61, -61),
		new RelativeMove(72, 0),
		new RelativeMove(24, -24),
		new RelativeMove(0, -26),
		new RelativeMove(24, -24)
	),
	PORT_ROBERTS_VOID_KNIGHTS_OUTPOST(
		PortLocation.PORT_ROBERTS,
		PortLocation.VOID_KNIGHTS_OUTPOST,
		new RelativeMove(0, -24),
		new RelativeMove(15, -15),
		new RelativeMove(48, 0),
		new RelativeMove(38, -38),
		new RelativeMove(0, -83),
		new RelativeMove(49, -49),
		new RelativeMove(0, -165),
		new RelativeMove(-24, -24),
		new RelativeMove(0, -105),
		new RelativeMove(47, -47),
		new RelativeMove(63, 0),
		new RelativeMove(74, -74)
	),
	VOID_KNIGHTS_OUTPOST_PORT_KHAZARD(
		PortLocation.VOID_KNIGHTS_OUTPOST,
		PortLocation.PORT_KHAZARD,
		new RelativeMove(0, 114),
		new RelativeMove(74, 74),
		new RelativeMove(0, 237),
		new RelativeMove(-37, 37)
	),
	VOID_KNIGHTS_OUTPOST_PORT_TYRAS(
		PortLocation.VOID_KNIGHTS_OUTPOST,
		PortLocation.PORT_TYRAS,
		new RelativeMove(-478, 0),
		new RelativeMove(-78, 78),
		new RelativeMove(-54, 0),
		new RelativeMove(-58, 58),
		new RelativeMove(0, 69),
		new RelativeMove(158, 158)
	),
	SUMMER_SHORE_PANDEMONIUM(
		PortLocation.SUMMER_SHORE,
		PortLocation.PANDEMONIUM,
		new RelativeMove(-64, 0),
		new RelativeMove(-42, 42),
		new RelativeMove(0, 261),
		new RelativeMove(-33, 33),
		new RelativeMove(0, 67),
		new RelativeMove(30, 30),
		new RelativeMove(0, 139),
		new RelativeMove(13, 13)
	),
	SUMMER_SHORE_PORT_SARIM(
		PortLocation.SUMMER_SHORE,
		PortLocation.PORT_SARIM,
		new RelativeMove(-64, 0),
		new RelativeMove(-42, 42),
		new RelativeMove(0, 261),
		new RelativeMove(-47, 47),
		new RelativeMove(0, 53),
		new RelativeMove(-52, 52),
		new RelativeMove(0, 35),
		new RelativeMove(38, 38),
		new RelativeMove(0, 193),
		new RelativeMove(49, 49)
	),
	SUMMER_SHORE_ALDARIN(
		PortLocation.SUMMER_SHORE,
		PortLocation.ALDARIN,
		new RelativeMove(-158, 0),
		new RelativeMove(-117, 117),
		new RelativeMove(-255, 0),
		new RelativeMove(-131, 131),
		new RelativeMove(-91, 0),
		new RelativeMove(-71, 71),
		new RelativeMove(-465, 0),
		new RelativeMove(-194, 194),
		new RelativeMove(-95, 0),
		new RelativeMove(-22, 22),
		new RelativeMove(0, 26),
		new RelativeMove(-8, 8),
		new RelativeMove(-49, 0),
		new RelativeMove(-41, 41)
	),
	SUMMER_SHORE_PORT_ROBERTS(
		PortLocation.SUMMER_SHORE,
		PortLocation.PORT_ROBERTS,
		new RelativeMove(-158, 0),
		new RelativeMove(-117, 117),
		new RelativeMove(-255, 0),
		new RelativeMove(-131, 131),
		new RelativeMove(-91, 0),
		new RelativeMove(-74, 74),
		new RelativeMove(-189, 0),
		new RelativeMove(-93, 93),
		new RelativeMove(-51, 0),
		new RelativeMove(-38, 38),
		new RelativeMove(0, 99),
		new RelativeMove(28, 28),
		new RelativeMove(0, 170),
		new RelativeMove(-46, 46),
		new RelativeMove(0, 77),
		new RelativeMove(-27, 27),
		new RelativeMove(-65, 0),
		new RelativeMove(-9, 9)
	),
	SUMMER_SHORE_DEEPFIN_POINT(
		PortLocation.SUMMER_SHORE,
		PortLocation.DEEPFIN_POINT,
		new RelativeMove(-158, 0),
		new RelativeMove(-117, 117),
		new RelativeMove(-255, 0),
		new RelativeMove(-131, 131),
		new RelativeMove(-91, 0),
		new RelativeMove(-72, 72),
		new RelativeMove(-371, 0),
		new RelativeMove(-56, 56)
	),
	SUMMER_SHORE_PORT_KHAZARD(
		PortLocation.SUMMER_SHORE,
		PortLocation.PORT_KHAZARD,
		new RelativeMove(-64, 0),
		new RelativeMove(-38, 38),
		new RelativeMove(-155, 0),
		new RelativeMove(-96, 96),
		new RelativeMove(0, 122),
		new RelativeMove(-2, 2),
		new RelativeMove(0, 185),
		new RelativeMove(-94, 94),
		new RelativeMove(0, 207),
		new RelativeMove(-37, 37)
	),
	RED_ROCK_PORT_KHAZARD(
		PortLocation.RED_ROCK,
		PortLocation.PORT_KHAZARD,
		new RelativeMove(17, 17),
		new RelativeMove(0, 71),
		new RelativeMove(-77, 77),
		new RelativeMove(-64, 0),
		new RelativeMove(-46, 46),
		new RelativeMove(0, 55),
		new RelativeMove(81, 81),
		new RelativeMove(0, 251),
		new RelativeMove(-37, 37)
	),
	RED_ROCK_PORT_SARIM(
		PortLocation.RED_ROCK,
		PortLocation.PORT_SARIM,
		new RelativeMove(7, 7),
		new RelativeMove(0, 93),
		new RelativeMove(-2, 2),
		new RelativeMove(0, 227),
		new RelativeMove(41, 41),
		new RelativeMove(112, 0),
		new RelativeMove(34, 34),
		new RelativeMove(0, 193),
		new RelativeMove(50, 50)
	),
	RED_ROCK_PORT_PISCARILIUS(
		PortLocation.RED_ROCK,
		PortLocation.PORT_PISCARILIUS,
		new RelativeMove(0, -17),
		new RelativeMove(-6, -6),
		new RelativeMove(-361, 0),
		new RelativeMove(-197, 197),
		new RelativeMove(-274, 0),
		new RelativeMove(-75, 75),
		new RelativeMove(0, 198),
		new RelativeMove(11, 11),
		new RelativeMove(0, 156),
		new RelativeMove(-56, 56),
		new RelativeMove(0, 143),
		new RelativeMove(52, 52),
		new RelativeMove(0, 216),
		new RelativeMove(-63, 63)
	),
	RED_ROCK_LANDS_END(
		PortLocation.RED_ROCK,
		PortLocation.LANDS_END,
		new RelativeMove(0, -17),
		new RelativeMove(-6, -6),
		new RelativeMove(-361, 0),
		new RelativeMove(-197, 197),
		new RelativeMove(-274, 0),
		new RelativeMove(-75, 75),
		new RelativeMove(0, 198),
		new RelativeMove(11, 11),
		new RelativeMove(0, 156),
		new RelativeMove(-281, 281)
	),
	RED_ROCK_CATHERBY(
		PortLocation.RED_ROCK,
		PortLocation.CATHERBY,
		new RelativeMove(7, 7),
		new RelativeMove(0, 103),
		new RelativeMove(-2, 2),
		new RelativeMove(0, 206),
		new RelativeMove(-94, 94),
		new RelativeMove(0, 203),
		new RelativeMove(-36, 36),
		new RelativeMove(0, 59),
		new RelativeMove(66, 66),
		new RelativeMove(0, 67),
		new RelativeMove(41, 41)
	),
	LANDS_END_HOSIDIUS(
		PortLocation.LANDS_END,
		PortLocation.HOSIDIUS,
		new RelativeMove(9, -9),
		new RelativeMove(167, 0),
		new RelativeMove(39, 39)
	),
	RELLEKKA_VOID_KNIGHTS_OUTPOST(
		PortLocation.RELLEKKA,
		PortLocation.VOID_KNIGHTS_OUTPOST,
		new RelativeMove(-118, 0),
		new RelativeMove(-47, 47),
		new RelativeMove(-220, 0),
		new RelativeMove(-28, -28),
		new RelativeMove(0, -85),
		new RelativeMove(-37, -37),
		new RelativeMove(-81, 0),
		new RelativeMove(-37, -37),
		new RelativeMove(0, -51),
		new RelativeMove(-108, -108),
		new RelativeMove(0, -262),
		new RelativeMove(61, -61),
		new RelativeMove(0, -162),
		new RelativeMove(-32, -32),
		new RelativeMove(0, -88),
		new RelativeMove(46, -46),
		new RelativeMove(67, 0),
		new RelativeMove(76, -76)
	)
	;

	private final PortLocation start;
	private final PortLocation end;
	private final List<RelativeMove> pathPoints;
	private final double distance;

	PortPaths(PortLocation start, PortLocation end, RelativeMove... pathPoints)
	{
		this.start = start;
		this.end = end;
		this.pathPoints = List.of(pathPoints);
		this.distance = computeDistance();
	}
	public static PortPathMatch findPath(PortLocation a, PortLocation b)
	{
		for (PortPaths p : values())
		{
			if (p.start == a && p.end == b)
			{
				return new PortPathMatch(p, false);
			}
			if (p.start == b && p.end == a)
			{
				return new PortPathMatch(p, true);
			}
		}
		log.info("Failed to find route between {} and {}", a, b);
		return new PortPathMatch(DEFAULT, false);
	}

	public List<WorldPoint> getFullPath()
	{
		List<WorldPoint> fullPath = new ArrayList<>();
		WorldPoint current = start.getNavigationLocation();
		fullPath.add(current);
		for (RelativeMove delta : pathPoints)
		{
			List<RelativeMove> moves = splitMove(delta, 50); // List<RelativeMove> moves = List.of(delta); to remove segmentation
			for (RelativeMove m : moves)
			{
				current = new WorldPoint(current.getX() + m.getDx(), current.getY() + m.getDy(), current.getPlane());
				fullPath.add(current);
			}
		}
		fullPath.add(end.getNavigationLocation());
		return fullPath;
	}
	private List<RelativeMove> splitMove(RelativeMove delta, int segmentLength)
	{
		int dx = delta.getDx();
		int dy = delta.getDy();
		int steps = Math.max(
				Math.abs(dx) / segmentLength + (Math.abs(dx) % segmentLength != 0 ? 1 : 0),
				Math.abs(dy) / segmentLength + (Math.abs(dy) % segmentLength != 0 ? 1 : 0)
		);

		if (steps <= 1)
			return List.of(delta);

		List<RelativeMove> result = new ArrayList<>(steps);

		int baseDx = dx / steps;
		int baseDy = dy / steps;

		int usedAbsDx = Math.abs(baseDx) * steps;
		int usedAbsDy = Math.abs(baseDy) * steps;

		int remDx = Math.abs(dx) - usedAbsDx;
		int remDy = Math.abs(dy) - usedAbsDy;

		int signDx = Integer.signum(dx);
		int signDy = Integer.signum(dy);

		for (int i = 0; i < steps; i++)
		{
			int extraDx = i < remDx ? signDx : 0;
			int extraDy = i < remDy ? signDy : 0;

			int addX = baseDx + extraDx;
			int addY = baseDy + extraDy;

			result.add(new RelativeMove(addX, addY));
		}
		return result;
	}

	private double computeDistance()
	{
		double total = 0;

		WorldPoint current = start.getNavigationLocation();
		for (RelativeMove delta : pathPoints)
		{
			WorldPoint next = new WorldPoint(
				current.getX() + delta.getDx(),
				current.getY() + delta.getDy(),
				current.getPlane()
			);

			total += distanceBetween(current, next);
			current = next;
		}
		WorldPoint endPoint = end.getNavigationLocation();
		if (!current.equals(endPoint))
		{
			total += distanceBetween(current, endPoint);
		}
		return total;
	}

	private static double distanceBetween(WorldPoint a, WorldPoint b)
	{
		int dx = b.getX() - a.getX();
		int dy = b.getY() - a.getY();
		return Math.hypot(dx, dy);
	}
	@Override
	public String toString()
	{
		return String.format("%s -> %s (%d points)", start.name(), end.name(), pathPoints.size());
	}

}
/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks.enums;

import java.util.HashMap;
import java.util.Map;
import net.runelite.api.gameval.VarbitID;

public enum PortTaskTrigger
{
	TASK_SLOT_0_ID(VarbitID.PORT_TASK_SLOT_0_ID, TaskType.ID, 0),
	TASK_SLOT_0_TAKEN(VarbitID.PORT_TASK_SLOT_0_CARGO_TAKEN,  TaskType.TAKEN, 0),
	TASK_SLOT_0_DELIVERED(VarbitID.PORT_TASK_SLOT_0_CARGO_DELIVERED, TaskType.DELIVERED, 0),
	TASK_SLOT_1_ID(VarbitID.PORT_TASK_SLOT_1_ID, TaskType.ID, 1),
	TASK_SLOT_1_TAKEN(VarbitID.PORT_TASK_SLOT_1_CARGO_TAKEN,  TaskType.TAKEN, 1),
	TASK_SLOT_1_DELIVERED(VarbitID.PORT_TASK_SLOT_1_CARGO_DELIVERED, TaskType.DELIVERED, 1),
	TASK_SLOT_2_ID(VarbitID.PORT_TASK_SLOT_2_ID,  TaskType.ID, 2),
	TASK_SLOT_2_TAKEN(VarbitID.PORT_TASK_SLOT_2_CARGO_TAKEN, TaskType.TAKEN, 2),
	TASK_SLOT_2_DELIVERED(VarbitID.PORT_TASK_SLOT_2_CARGO_DELIVERED, TaskType.DELIVERED, 2),
	TASK_SLOT_3_ID(VarbitID.PORT_TASK_SLOT_3_ID, TaskType.ID, 3),
	TASK_SLOT_3_TAKEN(VarbitID.PORT_TASK_SLOT_3_CARGO_TAKEN,  TaskType.TAKEN, 3),
	TASK_SLOT_3_DELIVERED(VarbitID.PORT_TASK_SLOT_3_CARGO_DELIVERED,  TaskType.DELIVERED, 3),
	TASK_SLOT_4_ID(VarbitID.PORT_TASK_SLOT_4_ID, TaskType.ID, 4),
	TASK_SLOT_4_TAKEN(VarbitID.PORT_TASK_SLOT_4_CARGO_TAKEN, TaskType.TAKEN, 4),
	TASK_SLOT_4_DELIVERED(VarbitID.PORT_TASK_SLOT_4_CARGO_DELIVERED, TaskType.DELIVERED, 4),
	LAST_CARGO_TAKEN(VarbitID.PORT_TASK_LAST_CARGO_TAKEN, TaskType.OTHER, -1);

	private final int id;
	private final TaskType type;
	private final int slot;

	public enum TaskType
	{
		ID, TAKEN, DELIVERED, OTHER
	}

	PortTaskTrigger(int id, TaskType type, int slot)
	{
		this.id = id;
		this.type = type;
		this.slot = slot;
	}

	public int getId()
	{
		return id;
	}

	public TaskType getType()
	{
		return type;
	}

	public int getSlot()
	{
		return slot;
	}

	private static final Map<Integer, PortTaskTrigger> lookup = new HashMap<>();
	static
	{
		for (PortTaskTrigger v : values())
		{
			lookup.put(v.id, v);
		}
	}

	public static PortTaskTrigger fromId(int id)
	{
		return lookup.get(id);
	}

	public static boolean contains(int id)
	{
		return lookup.containsKey(id);
	}

	@Override
	public String toString()
	{
		return String.format("%s (Type: %s, Slot: %d)", name(), type, slot);
	}

}
package com.nucleon.porttasks.enums;

import java.util.Arrays;
import java.util.Map;
import java.util.stream.Collectors;

public enum TaskReward
{
	TASK_4966(4966, 4474), // Void Knights' Outpost clothes delivery
	TASK_4967(4967, 8947), // Rellekka arrowtip delivery
	TASK_8664(8664, 71), // Pandemonium platebody delivery
	TASK_8665(8665, 141), // Port Sarim spice delivery
	TASK_8666(8666, 72), // Musa Point logs delivery
	TASK_8667(8667, 80), // Port Sarim logs delivery
	TASK_8668(8668, 263), // Catherby bait delivery
	TASK_8669(8669, 525), // Port Sarim honey delivery
	TASK_8670(8670, 71), // Pandemonium battleaxe delivery
	TASK_8671(8671, 90), // Musa Point fish delivery
	TASK_8672(8672, 294), // Catherby potato delivery
	TASK_8673(8673, 273), // Ardougne salamander delivery
	TASK_8674(8674, 546), // Port Sarim seed delivery
	TASK_8675(8675, 321), // Port Khazard swamp paste delivery
	TASK_8676(8676, 336), // Port Sarim sword delivery
	TASK_8677(8677, 238), // Brimhaven vodka delivery
	TASK_8678(8678, 504), // Port Sarim delivery of nothing sinister
	TASK_8679(8679, 919), // Port Piscarilius book delivery
	TASK_8680(8680, 595), // Ruin of Unkah rune delivery
	TASK_8681(8681, 5932), // Rellekka pie delivery
	TASK_8682(8682, 2273), // Port Sarim pest remains delivery
	TASK_8683(8683, 71), // Port Sarim jewellery delivery
	TASK_8684(8684, 141), // Pandemonium steel delivery
	TASK_8685(8685, 81), // Musa Point rotten banana delivery
	TASK_8686(8686, 100), // Pandemonium rum delivery
	TASK_8687(8687, 273), // Brimhaven jewellery delivery
	TASK_8688(8688, 546), // Pandemonium pineapple delivery
	TASK_8689(8689, 71), // Port Sarim fish delivery
	TASK_8690(8690, 90), // Musa Point ship part delivery
	TASK_8691(8691, 276), // Brimhaven cacti delivery
	TASK_8692(8692, 269), // Catherby grog delivery
	TASK_8693(8693, 538), // Pandemonium arrowtip delivery
	TASK_8694(8694, 595), // Corsair Cove scimitar delivery
	TASK_8695(8695, 1190), // Pandemonium gold delivery
	TASK_8696(8696, 343), // Port Khazard kyatt teeth delivery
	TASK_8697(8697, 686), // Pandemonium swamp paste delivery
	TASK_8698(8698, 243), // Ruin of Unkah cocktail delivery
	TASK_8699(8699, 548), // Pandemonium granite delivery
	TASK_8700(8700, 538), // Cairn Isle secret delivery
	TASK_8701(8701, 118), // Ardougne sand delivery
	TASK_8702(8702, 72), // Port Sarim coconut delivery
	TASK_8703(8703, 144), // Musa Point banana delivery
	TASK_8704(8704, 81), // Pandemonium banana delivery
	TASK_8705(8705, 162), // Musa Point eye patch delivery
	TASK_8706(8706, 154), // Brimhaven rum delivery
	TASK_8707(8707, 308), // Musa Point mahogany delivery
	TASK_8708(8708, 144), // Port Sarim logs delivery
	TASK_8709(8709, 162), // Pandemonium rum delivery
	TASK_8710(8710, 179), // Brimhaven silver delivery
	TASK_8711(8711, 175), // Catherby coconut delivery
	TASK_8712(8712, 375), // Musa Point honey delivery
	TASK_8713(8713, 168), // Entrana banana delivery
	TASK_8714(8714, 337), // Musa Point beer glass delivery
	TASK_8715(8715, 203), // Ardougne banana delivery
	TASK_8716(8716, 378), // Musa Point silk delivery
	TASK_8717(8717, 751), // Corsair Cove peg leg delivery
	TASK_8718(8718, 791), // Summer Shore banana delivery
	TASK_8719(8719, 3313), // Port Tyras snakeskin delivery
	TASK_8720(8720, 492), // Musa Point secret delivery
	TASK_8721(8721, 263), // Port Sarim flax delivery
	TASK_8722(8722, 525), // Catherby bait delivery
	TASK_8723(8723, 63), // Ardougne fish delivery
	TASK_8724(8724, 280), // Catherby arrowtip delivery
	TASK_8725(8725, 179), // Port Khazard bow delivery
	TASK_8726(8726, 358), // Catherby glassmaking supplies delivery
	TASK_8727(8727, 294), // Port Sarim beer delivery
	TASK_8728(8728, 134), // Ardougne poison delivery
	TASK_8729(8729, 219), // Port Khazard coal delivery
	TASK_8730(8730, 118), // Entrana barley delivery
	TASK_8731(8731, 236), // Catherby vial delivery
	TASK_8732(8732, 269), // Pandemonium wax delivery
	TASK_8733(8733, 538), // Catherby coconut delivery
	TASK_8734(8734, 105), // Brimhaven fish delivery
	TASK_8735(8735, 210), // Catherby karambwan delivery
	TASK_8736(8736, 188), // Musa Point lobster delivery
	TASK_8737(8737, 375), // Catherby banana delivery
	TASK_8738(8738, 980), // Port Piscarilius honey delivery
	TASK_8739(8739, 2488), // Catherby javelin delivery
	TASK_8740(8740, 168), // Musa Point cocktail delivery
	TASK_8741(8741, 308), // Brimhaven fish delivery
	TASK_8742(8742, 97), // Port Khazard spear delivery
	TASK_8743(8743, 224), // Brimhaven iron delivery
	TASK_8744(8744, 595), // Corsair Cove sword delivery
	TASK_8745(8745, 1133), // Brimhaven gem delivery
	TASK_8746(8746, 164), // Musa Point meat delivery
	TASK_8747(8747, 143), // Port Khazard fruit delivery
	TASK_8748(8748, 639), // Corsair Cove beer delivery
	TASK_8749(8749, 259), // Pandemonium meat delivery
	TASK_8750(8750, 546), // Brimhaven spice delivery
	TASK_8751(8751, 119), // Catherby pineapple delivery
	TASK_8752(8752, 210), // Brimhaven compost delivery
	TASK_8753(8753, -1), // Red Rock karambwan delivery
	TASK_8754(8754, -1), // Brimhaven machinery delivery
	TASK_8755(8755, 252), // Port Sarim amulet delivery
	TASK_8756(8756, 63), // Ardougne fish delivery
	TASK_8757(8757, 976), // Civitas illa Fortis pineapple delivery
	TASK_8758(8758, 2768), // Brimhaven camphor delivery
	TASK_8759(8759, 63), // Brimhaven spice delivery
	TASK_8760(8760, 126), // Ardougne gold delivery
	TASK_8761(8761, 126), // Catherby fur delivery
	TASK_8762(8762, 252), // Ardougne arrowtip delivery
	TASK_8763(8763, 2802), // Port Tyras platebody delivery
	TASK_8764(8764, 6465), // Ardougne meat delivery
	TASK_8765(8765, 109), // Brimhaven beer delivery
	TASK_8766(8766, 149), // Catherby seed delivery
	TASK_8767(8767, 1836), // Port Tyras sword delivery
	TASK_8768(8768, 955), // Port Piscarilius wine delivery
	TASK_8769(8769, 1880), // Ardougne fur delivery
	TASK_8770(8770, -1), // Red Rock protective clothing delivery
	TASK_8771(8771, -1), // Ardougne red coral delivery
	TASK_8772(8772, 90), // Port Khazard bread delivery
	TASK_8773(8773, 149), // Ardougne fish delivery
	TASK_8774(8774, 1698), // Summer Shore jewellery delivery
	TASK_8775(8775, 951), // Civitas illa Fortis artefact delivery
	TASK_8776(8776, 1094), // Void Knights' Outpost platebody delivery
	TASK_8777(8777, 574), // Ardougne rune delivery
	TASK_8778(8778, 140), // Ardougne fish delivery
	TASK_8779(8779, 149), // Port Khazard platebody delivery
	TASK_8780(8780, 468), // Corsair Cove dagger delivery
	TASK_8781(8781, 873), // Port Khazard vodka delivery
	TASK_8782(8782, 336), // Port Sarim sword delivery
	TASK_8783(8783, 671), // Port Khazard swamp paste delivery
	TASK_8784(8784, 301), // Ardougne sand delivery
	TASK_8785(8785, 525), // Corsair Cove khali brew delivery
	TASK_8786(8786, 379), // Port Sarim fish delivery
	TASK_8787(8787, 164), // Catherby gold delivery
	TASK_8788(8788, 328), // Port Khazard secret delivery
	TASK_8789(8789, 859), // Civitas illa Fortis pineapple delivery
	TASK_8790(8790, 1751), // Port Khazard huasca delivery
	TASK_8791(8791, 893), // Ruin of Unkah ship part delivery
	TASK_8792(8792, 1785), // Port Khazard angler outfit delivery
	TASK_8793(8793, 5025), // Rellekka dragon bitter delivery
	TASK_8794(8794, 888), // Port Piscarilius platebody delivery
	TASK_8795(8795, 236), // Entrana sand delivery
	TASK_8796(8796, 224), // Port Khazard herb delivery
	TASK_8797(8797, 468), // Port Khazard scimitar delivery
	TASK_8798(8798, 873), // Corsair Cove platebody delivery
	TASK_8799(8799, 463), // Void Knights' Outpost dragonhide delivery
	TASK_8800(8800, 842), // Corsair Cove arrowtip delivery
	TASK_8801(8801, 2047), // Port Tyras herb delivery
	TASK_8802(8802, 3438), // Corsair Cove meat delivery
	TASK_8803(8803, 525), // Port Khazard gunpowder delivery
	TASK_8804(8804, 608), // Void Knights' Outpost rune delivery
	TASK_8805(8805, 6609), // Port Tyras sword delivery
	TASK_8806(8806, 1065), // Port Piscarilius jewellery delivery
	TASK_8807(8807, 2961), // Corsair Cove fish delivery
	TASK_8808(8808, 312), // Cairn Isle gold delivery
	TASK_8809(8809, 686), // Corsair Cove gem delivery
	TASK_8810(8810, 655), // Brimhaven jewellery delivery
	TASK_8811(8811, 1309), // Corsair Cove rum delivery
	TASK_8812(8812, 655), // Pandemonium spice delivery
	TASK_8813(8813, 1309), // Corsair Cove ship part delivery
	TASK_8814(8814, 1216), // Civitas illa Fortis book delivery
	TASK_8815(8815, 1593), // Aldarin dagger delivery
	TASK_8816(8816, 630), // Port Sarim cacti delivery
	TASK_8817(8817, 1260), // Ruin of Unkah rune delivery
	TASK_8818(8818, 718), // Summer Shore sandstone delivery
	TASK_8819(8819, 1505), // Ruin of Unkah coral delivery
	TASK_8820(8820, -1), // Red Rock granite delivery
	TASK_8821(8821, -1), // Ruin of Unkah plank delivery
	TASK_8822(8822, 800), // Port Sarim kebab delivery
	TASK_8823(8823, 1369), // Summer Shore cacti delivery
	TASK_8824(8824, -1), // Red Rock fish delivery
	TASK_8825(8825, 315), // Pandemonium cacti delivery
	TASK_8826(8826, 560), // Ruin of Unkah cocktail delivery
	TASK_8827(8827, 989), // Void Knights' Outpost granite delivery
	TASK_8828(8828, 1978), // Ruin of Unkah javelin delivery
	TASK_8829(8829, 1015), // Ardougne silk delivery
	TASK_8830(8830, 1960), // Ruin of Unkah fishing supplies delivery
	TASK_8831(8831, 1178), // Brimhaven sandstone delivery
	TASK_8832(8832, 1015), // Catherby silk delivery
	TASK_8833(8833, 3556), // Deepfin Point granite delivery
	TASK_8834(8834, 893), // Ruin of Unkah ship part delivery
	TASK_8835(8835, -1), // Red Rock rune delivery
	TASK_8836(8836, -1), // Void Knights' Outpost herb delivery
	TASK_8837(8837, 1073), // Summer Shore pest remains delivery
	TASK_8838(8838, 2230), // Void Knights' Outpost logs delivery
	TASK_8839(8839, 2406), // Deepfin Point javelin delivery
	TASK_8840(8840, 4669), // Void Knights' Outpost ore delivery
	TASK_8841(8841, -1), // Red Rock fish delivery
	TASK_8842(8842, 2146), // Summer Shore javelin delivery
	TASK_8843(8843, 2479), // Deepfin Point pest remains delivery
	TASK_8844(8844, 1178), // Port Sarim rune delivery
	TASK_8845(8845, 1976), // Void Knights' Outpost potion delivery
	TASK_8846(8846, 2544), // Civitas illa Fortis rune delivery
	TASK_8847(8847, 4982), // Void Knights' Outpost mace delivery
	TASK_8848(8848, 1280), // Port Roberts fish delivery
	TASK_8849(8849, 3366), // Void Knights' Outpost seed delivery
	TASK_8850(8850, 805), // Port Khazard arrowtip delivery
	TASK_8851(8851, 2000), // Port Tyras arrowtip delivery
	TASK_8852(8852, 1244), // Catherby arrowtip delivery
	TASK_8853(8853, 926), // Void Knights' Outpost potion delivery
	TASK_8854(8854, 718), // Ruin of Unkah calquat delivery
	TASK_8855(8855, 1435), // Summer Shore rope delivery
	TASK_8856(8856, 1115), // Void Knights' Outpost coral delivery
	TASK_8857(8857, 1551), // Summer Shore javelin delivery
	TASK_8858(8858, 910), // Pandemonium coral delivery
	TASK_8859(8859, 1820), // Summer Shore gem delivery
	TASK_8860(8860, 947), // Ruin of Unkah fish delivery
	TASK_8861(8861, 1551), // Void Knights' Outpost spear delivery
	TASK_8862(8862, 1136), // Pandemonium sea shell delivery
	TASK_8863(8863, 1225), // Port Sarim camphor delivery
	TASK_8864(8864, 2380), // Summer Shore shield delivery
	TASK_8865(8865, 2468), // Aldarin crab paste delivery
	TASK_8866(8866, 4865), // Summer Shore potion delivery
	TASK_8867(8867, 2799), // Port Roberts coral delivery
	TASK_8868(8868, 5597), // Summer Shore meat delivery
	TASK_8869(8869, 3843), // Deepfin Point camphor delivery
	TASK_8870(8870, 1330), // Port Khazard crab paste delivery
	TASK_8871(8871, 2988), // Civitas illa Fortis coral delivery
	TASK_8872(8872, 1820), // Summer Shore pineapple delivery
	TASK_8873(8873, -1), // Port Khazard red coral delivery
	TASK_8874(8874, -1), // Red Rock fish delivery
	TASK_8875(8875, -1), // Deepfin Point plank delivery
	TASK_8876(8876, -1), // Red Rock ore delivery
	TASK_8877(8877, -1), // Port Sarim red coral delivery
	TASK_8878(8878, -1), // Red Rock battleaxe delivery
	TASK_8879(8879, -1), // Port Khazard plank delivery
	TASK_8880(8880, -1), // Deepfin Point logs delivery
	TASK_8881(8881, -1), // Port Sarim fish delivery
	TASK_8882(8882, -1), // Port Roberts red coral delivery
	TASK_8883(8883, -1), // Red Rock spice delivery
	TASK_8884(8884, 4669), // Void Knights' Outpost ore delivery
	TASK_8885(8885, -1), // Red Rock rune delivery
	TASK_8886(8886, -1), // Port Piscarilius red coral delivery
	TASK_8887(8887, -1), // Red Rock fish delivery
	TASK_8888(8888, -1), // Land's End fish delivery
	TASK_8889(8889, -1), // Ardougne red coral delivery
	TASK_8890(8890, -1), // Catherby jewellery delivery
	TASK_8891(8891, -1), // Red Rock fur delivery
	TASK_8892(8892, 83), // Hosidius rope delivery
	TASK_8893(8893, 166), // Land's End vegetable delivery
	TASK_8894(8894, 230), // Port Piscarilius plank delivery
	TASK_8895(8895, 460), // Land's End fish delivery
	TASK_8896(8896, 736), // Port Roberts berry delivery
	TASK_8897(8897, 1389), // Land's End wine delivery
	TASK_8898(8898, 83), // Hosidius fabric delivery
	TASK_8899(8899, 288), // Port Piscarilius fur delivery
	TASK_8900(8900, 1065), // Port Roberts meat delivery
	TASK_8901(8901, 2263), // Port Tyras chinchompa delivery
	TASK_8902(8902, 300), // Land's End meat delivery
	TASK_8903(8903, 2294), // Prifddinas fabric delivery
	TASK_8904(8904, 3977), // Land's End gem delivery
	TASK_8905(8905, 1759), // Piscatoris fur delivery
	TASK_8906(8906, 2191), // Land's End fur delivery
	TASK_8907(8907, 1776), // Deepfin Point logs delivery
	TASK_8908(8908, 873), // Port Khazard chainbody delivery
	TASK_8909(8909, 3478), // Lunar Isle berry delivery
	TASK_8910(8910, 2691), // Land's End sword delivery
	TASK_8911(8911, 240), // Land's End fish delivery
	TASK_8912(8912, 460), // Port Piscarilius plank delivery
	TASK_8913(8913, 736), // Port Roberts fish delivery
	TASK_8914(8914, 1473), // Port Piscarilius gin delivery
	TASK_8915(8915, 2046), // Piscatoris fish delivery
	TASK_8916(8916, 4092), // Port Piscarilius fur delivery
	TASK_8917(8917, 300), // Land's End meat delivery
	TASK_8918(8918, 1065), // Port Roberts jewellery delivery
	TASK_8919(8919, -1), // Piscatoris vodka delivery
	TASK_8920(8920, 175), // Hosidius fish delivery
	TASK_8921(8921, 350), // Port Piscarilius seed delivery
	TASK_8922(8922, 1841), // Lunar Isle fish delivery
	TASK_8923(8923, 3846), // Port Piscarilius book delivery
	TASK_8924(8924, 906), // Port Sarim book delivery
	TASK_8925(8925, 1838), // Port Piscarilius book delivery
	TASK_8926(8926, 2047), // Port Tyras fur delivery
	TASK_8927(8927, 900), // Musa Point important delivery
	TASK_8928(8928, 2107), // Rellekka beer delivery
	TASK_8929(8929, 3774), // Port Piscarilius gem delivery
	TASK_8930(8930, 1155), // Aldarin platebody delivery
	TASK_8931(8931, 2240), // Civitas illa Fortis orange delivery
	TASK_8932(8932, 412), // Port Piscarilius meat delivery
	TASK_8933(8933, 825), // Civitas illa Fortis vegetable delivery
	TASK_8934(8934, 442), // Port Roberts gem delivery
	TASK_8935(8935, 968), // Civitas illa Fortis token delivery
	TASK_8936(8936, 1389), // Aldarin fur delivery
	TASK_8937(8937, 396), // Port Piscarilius jewellery delivery
	TASK_8938(8938, 700), // Port Roberts silk delivery
	TASK_8939(8939, 1975), // Deepfin Point wool delivery
	TASK_8940(8940, 3807), // Civitas illa Fortis ore delivery
	TASK_8941(8941, 1887), // Prifddinas clothes delivery
	TASK_8942(8942, 3774), // Civitas illa Fortis seed delivery
	TASK_8943(8943, 997), // Sunset Coast mace delivery
	TASK_8944(8944, 1932), // Civitas illa Fortis fish delivery
	TASK_8945(8945, 2026), // Port Sarim sunbeam ale delivery
	TASK_8946(8946, 1761), // Ardougne spice delivery
	TASK_8947(8947, 2415), // Summer Shore leather delivery
	TASK_8948(8948, -1), // Civitas illa Fortis red coral delivery
	TASK_8949(8949, 193), // Sunset Coast beer delivery
	TASK_8950(8950, 335), // Aldarin fur delivery
	TASK_8951(8951, 1120), // Civitas illa Fortis fruit delivery
	TASK_8952(8952, 2240), // Aldarin spear delivery
	TASK_8953(8953, 1724), // Deepfin Point pickaxe delivery
	TASK_8954(8954, 3448), // Aldarin nickel delivery
	TASK_8955(8955, 316), // Sunset Coast wine delivery
	TASK_8956(8956, 1431), // Civitas illa Fortis gem delivery
	TASK_8957(8957, 1850), // Deepfin Point machinery delivery
	TASK_8958(8958, 1389), // Port Roberts wine delivery
	TASK_8959(8959, 2778), // Aldarin jewellery delivery
	TASK_8960(8960, 3219), // Prifddinas potion delivery
	TASK_8961(8961, 6438), // Aldarin dye delivery
	TASK_8962(8962, 926), // Void Knights' Outpost potion delivery
	TASK_8963(8963, 4250), // Aldarin pest remains delivery
	TASK_8964(8964, 2442), // Port Tyras shield delivery
	TASK_8965(8965, 2188), // Brimhaven wine delivery
	TASK_8966(8966, 4279), // Rellekka wine delivery
	TASK_8967(8967, 9493), // Aldarin monkfish delivery
	TASK_8968(8968, 779), // Port Piscarilius cannonball delivery
	TASK_8969(8969, 1978), // Port Roberts fish delivery
	TASK_8970(8970, 442), // Civitas illa Fortis spice delivery
	TASK_8971(8971, 968), // Port Roberts fur delivery
	TASK_8972(8972, 736), // Land's End ore delivery
	TASK_8973(8973, 1389), // Port Roberts seed delivery
	TASK_8974(8974, 1480), // Port Piscarilius jewellery delivery
	TASK_8975(8975, 639), // Civitas illa Fortis ship part delivery
	TASK_8976(8976, 1065), // Land's End secret delivery
	TASK_8977(8977, 1832), // Deepfin Point plank delivery
	TASK_8978(8978, 3664), // Port Roberts ore delivery
	TASK_8979(8979, 2741), // Lunar Isle fur delivery
	TASK_8980(8980, -1), // Port Roberts rune delivery
	TASK_8981(8981, 4506), // Catherby silver delivery
	TASK_8982(8982, 9012), // Port Roberts honey delivery
	TASK_8983(8983, 4603), // Port Sarim seed delivery
	TASK_8984(8984, 2399), // Rellekka ship part delivery
	TASK_8985(8985, -1), // Red Rock herb delivery
	TASK_8986(8986, 7361), // Port Roberts silk delivery
	TASK_8987(8987, 1904), // Port Roberts nickel delivery
	TASK_8988(8988, 3664), // Deepfin Point fabric delivery
	TASK_8989(8989, 1652), // Port Tyras mithril delivery
	TASK_8990(8990, 2658), // Deepfin Point logs delivery
	TASK_8991(8991, 1652), // Aldarin adamantite delivery
	TASK_8992(8992, 3448), // Deepfin Point fruit delivery
	TASK_8993(8993, 1961), // Port Roberts silver delivery
	TASK_8994(8994, 1702), // Port Tyras coal delivery
	TASK_8995(8995, 1776), // Aldarin lead delivery
	TASK_8996(8996, 1904), // Civitas illa Fortis nickel delivery
	TASK_8997(8997, 3951), // Deepfin Point wool delivery
	TASK_8998(8998, 2837), // Port Piscarilius coal delivery
	TASK_8999(8999, 2220), // Deepfin Point plank delivery
	TASK_9000(9000, -1), // Red Rock coal delivery
	TASK_9001(9001, 3664), // Deepfin Point fabric delivery
	TASK_9002(9002, 4440), // Rellekka lead delivery
	TASK_9003(9003, 8732), // Deepfin Point warhammer delivery
	TASK_9004(9004, 2590), // Hosidius lead delivery
	TASK_9005(9005, -1), // Summer Shore nickel delivery
	TASK_9006(9006, 1110), // Prifddinas logs delivery
	TASK_9007(9007, 2220), // Port Tyras vegetable delivery
	TASK_9008(9008, 1401), // Port Roberts fur delivery
	TASK_9009(9009, 3304), // Port Tyras platebody delivery
	TASK_9010(9010, 1832), // Deepfin Point plank delivery
	TASK_9011(9011, 1309), // Port Tyras ore delivery
	TASK_9012(9012, 1036), // Prifddinas halberd delivery
	TASK_9013(9013, 1473), // Port Roberts bow delivery
	TASK_9014(9014, 3304), // Deepfin Point logs delivery
	TASK_9015(9015, 3233), // Ardougne halberd delivery
	TASK_9016(9016, 3404), // Port Tyras sword delivery
	TASK_9017(9017, 2191), // Land's End fur delivery
	TASK_9018(9018, 4382), // Port Tyras seed delivery
	TASK_9019(9019, 2119), // Port Piscarilius plank delivery
	TASK_9020(9020, 4095), // Port Tyras fish delivery
	TASK_9021(9021, 3340), // Brimhaven meat delivery
	TASK_9022(9022, 2987), // Lunar Isle logs delivery
	TASK_9023(9023, -1), // Red Rock ship part delivery
	TASK_9024(9024, 5028), // Port Tyras fruit delivery
	TASK_9025(9025, 1036), // Port Tyras fabric delivery
	TASK_9026(9026, 2072), // Prifddinas logs delivery
	TASK_9027(9027, 1517), // Port Roberts logs delivery
	TASK_9028(9028, 2886), // Prifddinas fish delivery
	TASK_9029(9029, 4070), // Ardougne crystal seed delivery
	TASK_9030(9030, 7992), // Prifddinas silk delivery
	TASK_9031(9031, 3161), // Port Tyras ore delivery
	TASK_9032(9032, 1678), // Port Roberts staff delivery
	TASK_9033(9033, -1), // Ardougne jewellery delivery
	TASK_9034(9034, 5675), // Deepfin Point plank delivery
	TASK_9035(9035, 4292), // Prifddinas ore delivery
	TASK_9036(9036, 3219), // Aldarin crystal seed delivery
	TASK_9037(9037, 6438), // Prifddinas potion delivery
	TASK_9038(9038, 1813), // Civitas illa Fortis staff delivery
	TASK_9039(9039, 3774), // Prifddinas spice delivery
	TASK_9040(9040, 2496), // Lunar Isle crystal seed delivery
	TASK_9041(9041, 4798), // Rellekka plank delivery
	TASK_9042(9042, 2960), // Void Knights' Outpost rune delivery
	TASK_9043(9043, 3922), // Prifddinas book delivery
	TASK_9044(9044, 790), // Etceteria fish delivery
	TASK_9045(9045, 888), // Rellekka teak delivery
	TASK_9046(9046, 1149), // Neitiznot coal delivery
	TASK_9047(9047, 2299), // Rellekka rope delivery
	TASK_9048(9048, 4344), // Sunset Coast warhammer delivery
	TASK_9049(9049, 8688), // Rellekka fabric delivery
	TASK_9050(9050, 888), // Etceteria warhammer delivery
	TASK_9051(9051, 1258), // Neitiznot sand delivery
	TASK_9052(9052, 4885), // Sunset Coast fish delivery
	TASK_9053(9053, 2464), // Port Roberts fish delivery
	TASK_9054(9054, 2489), // Rellekka plank delivery
	TASK_9055(9055, 1759), // Piscatoris fur delivery
	TASK_9056(9056, 3355), // Rellekka monkfish delivery
	TASK_9057(9057, 2042), // Port Piscarilius fur delivery
	TASK_9058(9058, 4085), // Rellekka redwood delivery
	TASK_9059(9059, 1006), // Jatizso logs delivery
	TASK_9060(9060, 2155), // Rellekka adamantite delivery
	TASK_9061(9061, 4166), // Deepfin Point fur delivery
	TASK_9062(9062, 6321), // Rellekka halberd delivery
	TASK_9063(9063, 790), // Rellekka fish delivery
	TASK_9064(9064, 1437), // Etceteria iron delivery
	TASK_9065(9065, 898), // Jatizso fish delivery
	TASK_9066(9066, 1940), // Etceteria adamantite delivery
	TASK_9067(9067, 2730), // Port Roberts teak delivery
	TASK_9068(9068, 5459), // Etceteria fruit delivery
	TASK_9069(9069, 1580), // Rellekka teak delivery
	TASK_9070(9070, 1073), // Jatizso flax delivery
	TASK_9071(9071, 2886), // Port Roberts flax delivery
	TASK_9072(9072, 2335), // Port Piscarilius mahogany delivery
	TASK_9073(9073, 4813), // Etceteria plank delivery
	TASK_9074(9074, 1293), // Neitiznot mahogany delivery
	TASK_9075(9075, 2442), // Etceteria yak hair delivery
	TASK_9076(9076, 4813), // Sunset Coast fabric delivery
	TASK_9077(9077, 9626), // Etceteria sword delivery
	TASK_9078(9078, -1), // Piscatoris flax delivery
	TASK_9079(9079, -1), // Etceteria monkfish delivery
	TASK_9080(9080, 4238), // Deepfin Point mahogany delivery
	TASK_9081(9081, 6034), // Etceteria onion delivery
	TASK_9082(9082, 1841), // Port Piscarilius fabric delivery
	TASK_9083(9083, 3846), // Lunar Isle fish delivery
	TASK_9084(9084, 1432), // Piscatoris fabric delivery
	TASK_9085(9085, 2864), // Lunar Isle fur delivery
	TASK_9086(9086, 2496), // Prifddinas herb delivery
	TASK_9087(9087, 4992), // Lunar Isle potion delivery
	TASK_9088(9088, 2240), // Port Piscarilius rune delivery
	TASK_9089(9089, 1600), // Piscatoris potion delivery
	TASK_9090(9090, 2880), // Prifddinas rune delivery
	TASK_9091(9091, 4214), // Deepfin Point suqah hide delivery
	TASK_9092(9092, 8265), // Lunar Isle coal delivery
	TASK_9093(9093, 2660), // Port Roberts fabric delivery
	TASK_9094(9094, 5319), // Lunar Isle fish delivery
	TASK_9095(9095, 3437), // Civitas illa Fortis rune delivery
	TASK_9096(9096, 6710), // Lunar Isle fur delivery
	TASK_9097(9097, -1), // Red Rock rune delivery
	TASK_9098(9098, -1), // Lunar Isle red coral delivery
	TASK_9099(9099, -1), // Land's End gem delivery
	TASK_9100(9100, 11519), // Lunar Isle potion delivery
	TASK_9101(9101, 1790), // Port Sarim tern bounty
	TASK_9102(9102, 1790), // Port Sarim mogre bounty
	TASK_9103(9103, 1790), // Port Sarim bull shark bounty
	TASK_9104(9104, 6760), // Port Sarim tiger shark bounty
	TASK_9105(9105, 1790), // Port Sarim osprey bounty
	TASK_9106(9106, 1790), // Port Sarim bull shark bounty
	TASK_9107(9107, 6360), // Port Sarim pygmy kraken bounty
	TASK_9108(9108, 1790), // Pandemonium bull shark bounty
	TASK_9109(9109, 1790), // Pandemonium mogre bounty
	TASK_9110(9110, 1790), // Pandemonium osprey bounty
	TASK_9111(9111, 3400), // Pandemonium butterfly ray bounty
	TASK_9112(9112, 1790), // Pandemonium tern bounty
	TASK_9113(9113, 3400), // Pandemonium hammerhead shark bounty
	TASK_9114(9114, 4390), // Pandemonium frigatebird bounty
	TASK_9115(9115, 1790), // Musa Point bull shark bounty
	TASK_9116(9116, 1790), // Musa Point mogre bounty
	TASK_9117(9117, 1790), // Musa Point tern bounty
	TASK_9118(9118, 3400), // Musa Point butterfly ray bounty
	TASK_9119(9119, 1790), // Musa Point eagle ray bounty
	TASK_9120(9120, 1790), // Musa Point bull shark bounty
	TASK_9121(9121, 3400), // Musa Point hammerhead shark bounty
	TASK_9122(9122, 1790), // Catherby tern bounty
	TASK_9123(9123, 1790), // Catherby osprey bounty
	TASK_9124(9124, 1790), // Catherby bull shark bounty
	TASK_9125(9125, 6360), // Catherby pygmy kraken bounty
	TASK_9126(9126, 1790), // Catherby mogre bounty
	TASK_9127(9127, 4390), // Catherby frigatebird bounty
	TASK_9128(9128, 6360), // Catherby albatross bounty
	TASK_9129(9129, 1790), // Brimhaven osprey bounty
	TASK_9130(9130, 1790), // Brimhaven tern bounty
	TASK_9131(9131, 1790), // Brimhaven bull shark bounty
	TASK_9132(9132, 6360), // Brimhaven albatross bounty
	TASK_9133(9133, 3400), // Brimhaven hammerhead shark bounty
	TASK_9134(9134, 6760), // Brimhaven tiger shark bounty
	TASK_9135(9135, 1790), // Brimhaven mogre bounty
	TASK_9136(9136, 1790), // Ardougne mogre bounty
	TASK_9137(9137, 1790), // Ardougne osprey bounty
	TASK_9138(9138, 1790), // Ardougne bull shark bounty
	TASK_9139(9139, 6360), // Ardougne pygmy kraken bounty
	TASK_9140(9140, 3400), // Ardougne hammerhead shark bounty
	TASK_9141(9141, 4390), // Ardougne stingray bounty
	TASK_9142(9142, 7730), // Ardougne spined kraken bounty
	TASK_9143(9143, 1790), // Port Khazard mogre bounty
	TASK_9144(9144, 1790), // Port Khazard bull shark bounty
	TASK_9145(9145, 3400), // Port Khazard hammerhead shark bounty
	TASK_9146(9146, 8540), // Port Khazard great white shark bounty
	TASK_9147(9147, 1790), // Port Khazard mogre bounty
	TASK_9148(9148, 1790), // Port Khazard eagle ray bounty
	TASK_9149(9149, 6360), // Port Khazard albatross bounty
	TASK_9150(9150, 3400), // Corsair Cove hammerhead shark bounty
	TASK_9151(9151, 6360), // Corsair Cove pygmy kraken bounty
	TASK_9152(9152, 3400), // Corsair Cove mogre bounty
	TASK_9153(9153, 4390), // Corsair Cove stingray bounty
	TASK_9154(9154, 3400), // Corsair Cove osprey bounty
	TASK_9155(9155, 6760), // Corsair Cove tiger shark bounty
	TASK_9156(9156, 8540), // Corsair Cove great white shark bounty
	TASK_9157(9157, 3650), // Ruins of Unkah bull shark bounty
	TASK_9158(9158, 3650), // Ruins of Unkah hammerhead shark bounty
	TASK_9159(9159, 6760), // Ruins of Unkah tiger shark bounty
	TASK_9160(9160, 3650), // Ruins of Unkah butterfly ray bounty
	TASK_9161(9161, 3650), // Ruins of Unkah eagle ray bounty
	TASK_9162(9162, 6360), // Ruins of Unkah albatross bounty
	TASK_9163(9163, 8540), // Ruins of Unkah great white shark bounty
	TASK_9164(9164, 4390), // Void Knights' Outpost stingray bounty
	TASK_9165(9165, 4390), // Void Knights' Outpost osprey bounty
	TASK_9166(9166, 4390), // Void Knights' Outpost frigatebird bounty
	TASK_9167(9167, 6360), // Void Knights' Outpost pygmy kraken bounty
	TASK_9168(9168, 4390), // Void Knights' Outpost eagle ray bounty
	TASK_9169(9169, 8540), // Void Knights' Outpost great white shark bounty
	TASK_9170(9170, 7500), // Void Knights' Outpost manta ray bounty
	TASK_9171(9171, 3650), // Summer Shore butterfly ray bounty
	TASK_9172(9172, 3650), // Summer Shore eagle ray bounty
	TASK_9173(9173, 4390), // Summer Shore frigatebird bounty
	TASK_9174(9174, 8540), // Summer Shore great white shark bounty
	TASK_9175(9175, 6360), // Summer Shore albatross bounty
	TASK_9176(9176, 6760), // Summer Shore tiger shark bounty
	TASK_9177(9177, 4390), // Summer Shore stingray bounty
	TASK_9178(9178, -1), // Red Rock tiger shark bounty
	TASK_9179(9179, -1), // Red Rock frigatebird bounty
	TASK_9180(9180, -1), // Red Rock eagle ray bounty
	TASK_9181(9181, -1), // Red Rock great white shark bounty
	TASK_9182(9182, -1), // Red Rock stingray bounty
	TASK_9183(9183, -1), // Red Rock tiger shark bounty
	TASK_9184(9184, -1), // Red Rock spined kraken bounty
	TASK_9185(9185, 1790), // Land's End bull shark bounty
	TASK_9186(9186, 1790), // Land's End osprey bounty
	TASK_9187(9187, 1790), // Land's End tern bounty
	TASK_9188(9188, 6360), // Land's End pygmy kraken bounty
	TASK_9189(9189, 3400), // Land's End hammerhead shark bounty
	TASK_9190(9190, 8540), // Land's End great white shark bounty
	TASK_9191(9191, 3400), // Land's End butterfly ray bounty
	TASK_9192(9192, 1790), // Port Piscarilius osprey bounty
	TASK_9193(9193, 1790), // Port Piscarilius bull shark bounty
	TASK_9194(9194, 1790), // Port Piscarilius tern bounty
	TASK_9195(9195, 7730), // Port Piscarilius spined kraken bounty
	TASK_9196(9196, 6760), // Port Piscarilius tiger shark bounty
	TASK_9197(9197, 3400), // Port Piscarilius butterfly ray bounty
	TASK_9198(9198, 9540), // Port Piscarilius armoured kraken bounty
	TASK_9199(9199, 2020), // Civitas illa Fortis osprey bounty
	TASK_9200(9200, 3400), // Civitas illa Fortis hammerhead shark bounty
	TASK_9201(9201, 2020), // Civitas illa Fortis bull shark bounty
	TASK_9202(9202, 9540), // Civitas illa Fortis armoured kraken bounty
	TASK_9203(9203, 2020), // Civitas illa Fortis tern bounty
	TASK_9204(9204, 4390), // Civitas illa Fortis frigatebird bounty
	TASK_9205(9205, 2020), // Civitas illa Fortis eagle ray bounty
	TASK_9206(9206, 4390), // Aldarin stingray bounty
	TASK_9207(9207, 3650), // Aldarin osprey bounty
	TASK_9208(9208, 3650), // Aldarin butterfly ray bounty
	TASK_9209(9209, 8540), // Aldarin great white shark bounty
	TASK_9210(9210, 3650), // Aldarin hammerhead shark bounty
	TASK_9211(9211, 7730), // Aldarin spined kraken bounty
	TASK_9212(9212, 4390), // Aldarin frigatebird bounty
	TASK_9213(9213, 4390), // Port Roberts hammerhead shark bounty
	TASK_9214(9214, 4390), // Port Roberts osprey bounty
	TASK_9215(9215, 9540), // Port Roberts armoured kraken bounty
	TASK_9216(9216, 8540), // Port Roberts great white shark bounty
	TASK_9217(9217, 4390), // Port Roberts tern bounty
	TASK_9218(9218, 9540), // Port Roberts orca bounty
	TASK_9219(9219, 6360), // Port Roberts albatross bounty
	TASK_9220(9220, 7500), // Deepfin Point frigatebird bounty
	TASK_9221(9221, 7500), // Deepfin Point eagle ray bounty
	TASK_9222(9222, 7730), // Deepfin Point spined kraken bounty
	TASK_9223(9223, 7500), // Deepfin Point osprey bounty
	TASK_9224(9224, 7500), // Deepfin Point stingray bounty
	TASK_9225(9225, 7500), // Deepfin Point tiger shark bounty
	TASK_9226(9226, 7500), // Deepfin Point hammerhead shark bounty
	TASK_9227(9227, 7500), // Port Tyras butterfly ray bounty
	TASK_9228(9228, 7500), // Port Tyras hammerhead shark bounty
	TASK_9229(9229, 7500), // Port Tyras bull shark bounty
	TASK_9230(9230, 9540), // Port Tyras armoured kraken bounty
	TASK_9231(9231, 7500), // Port Tyras pygmy kraken bounty
	TASK_9232(9232, 8540), // Port Tyras great white shark bounty
	TASK_9233(9233, 7500), // Port Tyras manta ray bounty
	TASK_9234(9234, 7730), // Prifddinas hammerhead shark bounty
	TASK_9235(9235, 7730), // Prifddinas pygmy kraken bounty
	TASK_9236(9236, 9540), // Prifddinas armoured kraken bounty
	TASK_9237(9237, 7730), // Prifddinas osprey bounty
	TASK_9238(9238, 8540), // Prifddinas great white shark bounty
	TASK_9239(9239, 7730), // Prifddinas manta ray bounty
	TASK_9240(9240, 7730), // Prifddinas hammerhead shark bounty
	TASK_9241(9241, 6760), // Rellekka albatross bounty
	TASK_9242(9242, 6760), // Rellekka hammerhead shark bounty
	TASK_9243(9243, 6760), // Rellekka narwhal bounty
	TASK_9244(9244, 9540), // Rellekka armoured kraken bounty
	TASK_9245(9245, 9540), // Rellekka orca bounty
	TASK_9246(9246, 9540), // Rellekka vampyre kraken bounty
	TASK_9247(9247, 7730), // Rellekka spined kraken bounty
	TASK_9248(9248, 7500), // Etceteria albatross bounty
	TASK_9249(9249, 9540), // Etceteria orca bounty
	TASK_9250(9250, 9540), // Etceteria vampyre kraken bounty
	TASK_9251(9251, 7500), // Etceteria narwhal bounty
	TASK_9252(9252, 7730), // Etceteria spined kraken bounty
	TASK_9253(9253, 9540), // Etceteria orca bounty
	TASK_9254(9254, 9540), // Etceteria armoured kraken bounty
	TASK_9255(9255, 9540), // Lunar Isle armoured kraken bounty
	TASK_9256(9256, 9540), // Lunar Isle vampyre kraken bounty
	TASK_9257(9257, 8450), // Lunar Isle narwhal bounty
	TASK_9258(9258, 9540), // Lunar Isle orca bounty
	TASK_9259(9259, 8450), // Lunar Isle albatross bounty
	TASK_9260(9260, 9540), // Lunar Isle vampyre kraken bounty
	TASK_9261(9261, 8450), // Lunar Isle narwhal bounty
	;

	private final int dbow;
	private final int reward;

	private static final Map<Integer, TaskReward> BY_DBROW =
		Arrays.stream(values())
			.collect(Collectors.toMap(tr -> tr.dbow, tr -> tr));

	TaskReward(int dbrow, int reward)
	{
		this.dbow = dbrow;
		this.reward = reward;
	}

	public static int getIntRewardForTask(int dbrow)
	{
		TaskReward tr = BY_DBROW.get(dbrow);
		if (tr == null || tr.reward < 0)
		{
			return 0;
		}
		return tr.reward;
	}

	public static String getRewardForTask(int dbrow)
	{
		TaskReward tr = BY_DBROW.get(dbrow);
		if (tr == null || tr.reward < 0)
		{
			return "Unknown";
		}
		return String.valueOf(tr.reward);
	}
}

package com.nucleon.porttasks;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.widgets.Widget;

@Getter
@AllArgsConstructor
public class OfferedTaskData
{
	private final Widget taskWidget;
	private final int levelRequired;
}

/*
 * Copyright (c) 2021, Zoinkwiz <https://github.com/Zoinkwiz>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks.overlay;


import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Player;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;

import java.awt.*;
import java.awt.geom.AffineTransform;
import java.awt.geom.Line2D;
import java.util.List;

public class DirectionArrow
{
	/**
	 * @param client the {@link Client}
	 * @return the rough number of tiles distance the minimap can draw
	 */
	public static int getMaxMinimapDrawDistance(Client client)
	{
		var minimapZoom = client.getMinimapZoom();
		if (minimapZoom > 0.0)
		{
			return (int) (64.0 / client.getMinimapZoom());
		}
		return 16;
	}

	public static void renderMinimapArrowFromLocal(Graphics2D graphics, Client client, LocalPoint localPoint, Color color)
	{
		var maxMinimapDrawDistance = getMaxMinimapDrawDistance(client);
		Player player = client.getLocalPlayer();
		if (player == null)
		{
			return;
		}

		if (localPoint == null)
		{
			return;
		}

		WorldPoint playerRealLocation = WorldPoint.fromLocalInstance(client, player.getLocalLocation());
		WorldPoint goalRealLocation = WorldPoint.fromLocalInstance(client, localPoint);
		if (playerRealLocation == null) return;

		if (goalRealLocation.distanceTo(playerRealLocation) >= maxMinimapDrawDistance)
		{
			createMinimapDirectionArrow(graphics, client, playerRealLocation, goalRealLocation, color);
			return;
		}

		Point posOnMinimap = Perspective.localToMinimap(client, localPoint);
		if (posOnMinimap == null)
		{
			return;
		}

		Line2D.Double line = new Line2D.Double(posOnMinimap.getX(), posOnMinimap.getY() - 18, posOnMinimap.getX(),
				posOnMinimap.getY() - 8);

		drawMinimapArrow(graphics, line, color);

	}

	public static void renderMinimapArrow(Graphics2D graphics, Client client, WorldPoint worldPoint, Color color)
	{
		var maxMinimapDrawDistance = getMaxMinimapDrawDistance(client);
		Player player = client.getLocalPlayer();
		if (player == null)
		{
			return;
		}

		if (worldPoint == null)
		{
			return;
		}

		WorldPoint playerRealLocation = WorldPoint.fromLocalInstance(client, player.getLocalLocation());
		if (playerRealLocation == null) return;

		if (worldPoint.distanceTo(playerRealLocation) >= maxMinimapDrawDistance)
		{
			createMinimapDirectionArrow(graphics, client, playerRealLocation, worldPoint, color);
			return;
		}

		List<LocalPoint> localPoints = WorldPerspective.getInstanceLocalPointFromReal(client, worldPoint);

		for (LocalPoint localPoint : localPoints)
		{
			Point posOnMinimap = Perspective.localToMinimap(client, localPoint);
			if (posOnMinimap == null)
			{
				continue;
			}

			Line2D.Double line = new Line2D.Double(posOnMinimap.getX(), posOnMinimap.getY() - 18, posOnMinimap.getX(),
					posOnMinimap.getY() - 8);

			drawMinimapArrow(graphics, line, color);
		}
	}

	protected static void createMinimapDirectionArrow(Graphics2D graphics, Client client, WorldPoint playerRealWp, WorldPoint wp, Color color)
	{
		Player player = client.getLocalPlayer();

		if (player == null)
		{
			return;
		}

		if (wp == null)
		{
			return;
		}

		Point playerPosOnMinimap = player.getMinimapLocation();

		Point destinationPosOnMinimap = WorldPerspective.getMinimapPoint(client, playerRealWp, wp);

		if (playerPosOnMinimap == null || destinationPosOnMinimap == null)
		{
			return;
		}

		double xDiff = playerPosOnMinimap.getX() - destinationPosOnMinimap.getX();
		double yDiff = destinationPosOnMinimap.getY() - playerPosOnMinimap.getY();
		double angle = Math.atan2(yDiff, xDiff);

		int startX = (int) (playerPosOnMinimap.getX() - (Math.cos(angle) * 55));
		int startY = (int) (playerPosOnMinimap.getY() + (Math.sin(angle) * 55));

		int endX = (int) (playerPosOnMinimap.getX() - (Math.cos(angle) * 65));
		int endY = (int) (playerPosOnMinimap.getY() + (Math.sin(angle) * 65));

		Line2D.Double line = new Line2D.Double(startX, startY, endX, endY);

		drawMinimapArrow(graphics, line, color);
	}

	public static void drawWorldArrow(Graphics2D graphics, Color color, int startX, int startY)
	{
		Line2D.Double line = new Line2D.Double(startX, startY - 13, startX, startY);

		int headWidth = 5;
		int headHeight = 4;
		int lineWidth = 9;

		drawArrow(graphics, line, color, lineWidth, headHeight, headWidth);
	}

	public static void drawMinimapArrow(Graphics2D graphics, Line2D.Double line, Color color)
	{
		drawArrow(graphics, line, color, 6, 2, 2);
	}

	public static void drawArrow(Graphics2D graphics, Line2D.Double line, Color color, int width, int tipHeight, int tipWidth)
	{
		graphics.setColor(Color.BLACK);
		graphics.setStroke(new BasicStroke(width));
		graphics.draw(line);
		drawWorldArrowHead(graphics, line, tipHeight, tipWidth);

		graphics.setColor(color);
		graphics.setStroke(new BasicStroke(width - 3));
		graphics.draw(line);
		drawWorldArrowHead(graphics, line, tipHeight - 2, tipWidth - 2);
		graphics.setStroke(new BasicStroke(1));
	}


	public static void drawWorldArrowHead(Graphics2D g2d, Line2D.Double line, int extraSizeHeight, int extraSizeWidth)
	{
		AffineTransform tx = new AffineTransform();

		Polygon arrowHead = new Polygon();
		arrowHead.addPoint(0, 6 + extraSizeHeight);
		arrowHead.addPoint(-6 - extraSizeWidth, -1 - extraSizeHeight);
		arrowHead.addPoint(6 + extraSizeWidth, -1 - extraSizeHeight);

		tx.setToIdentity();
		double angle = Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
		tx.translate(line.x2, line.y2);
		tx.rotate((angle - Math.PI / 2d));

		Graphics2D g = (Graphics2D) g2d.create();
		g.setTransform(tx);
		g.fill(arrowHead);
		g.dispose();
	}

	public static void drawLineArrowHead(Graphics2D g2d, Line2D.Double line)
	{
		AffineTransform tx = new AffineTransform();
		Polygon arrowHead = new Polygon();
		arrowHead.addPoint(0, 0);
		arrowHead.addPoint(-3, -6);
		arrowHead.addPoint(3, -6);
		tx.setToIdentity();
		double angle = Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
		tx.translate(line.x2, line.y2);
		tx.rotate((angle - Math.PI / 2d));
		Graphics2D graphics2D = (Graphics2D) g2d.create();
		graphics2D.setTransform(tx);
		graphics2D.fill(arrowHead);
		graphics2D.dispose();
	}

	public static void drawLine(Graphics2D graphics, Line2D.Double line, Color color, Rectangle clippingRegion)
	{
		graphics.setStroke(new BasicStroke(1));
		graphics.setClip(clippingRegion);
		graphics.setColor(color);
		graphics.draw(line);
		drawLineArrowHead(graphics, line);
	}
}

package com.nucleon.porttasks.overlay;

import com.nucleon.porttasks.CourierTaskData;
import com.nucleon.porttasks.OfferedTaskData;
import com.nucleon.porttasks.PortTasksPlugin;
import com.nucleon.porttasks.enums.BountyTaskData;
import com.nucleon.porttasks.enums.TaskReward;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.util.Map;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;

@Slf4j
public class NoticeBoardTooltip extends Overlay
{
	private final TooltipManager tooltipManager;
	private final Client client;
	private final PortTasksPlugin plugin;


	@Inject
	NoticeBoardTooltip(Client client, TooltipManager tooltipManager, PortTasksPlugin plugin)
	{
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
		drawAfterInterface(InterfaceID.TOPLEVEL_DISPLAY);
		this.client = client;
		this.tooltipManager = tooltipManager;
		this.plugin = plugin;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		Widget widget = client.getWidget(InterfaceID.PortTaskBoard.CONTAINER);
		if (widget == null || widget.isHidden())
		{
			return null;
		}

		// The world map obscures the notice board. Hide tooltips when world map is open
		Widget worldMap = client.getWidget(InterfaceID.Worldmap.CONTENT);
		if (worldMap != null && !worldMap.isHidden())
		{
			return null;
		}

		Widget taskInfo = client.getWidget(InterfaceID.PortTaskInfo.WINDOW);
		if (taskInfo != null && !taskInfo.isHidden())
		{
			return null;
		}

		Integer dbrow = getHoveredTask();
		if (dbrow == null)
		{
			return null;
		}
		Object task = getTask(dbrow);

		if (task instanceof CourierTaskData)
		{
			CourierTaskData data = (CourierTaskData) task;
			Color isAtCurLocation = data.getNoticeBoard() == data.getCargoLocation() ? Color.WHITE : Color.RED;
			String sourceColorTag = toColTag(isAtCurLocation);
			String endTag = "</col>";
			int distance = (int) Math.round(data.getDockMarkers().getDistance());

			double xpPerTileRatio = data.getXpPerTileRatio();
			int xpPerTilePercent = (int) Math.round(xpPerTileRatio * 100.0);
			Color xpColor = interpolateColor(plugin.getMinColor(), plugin.getMaxColor(), xpPerTileRatio);
			String xpColorTag = toColTag(xpColor);

			String tooltip = String.format(
				"Source: %s%s%s<br>" +
				"Destination: %s<br>" +
				"Experience: %s xp<br>" +
				"Distance: %d tiles<br>" +
				"XP/Tile: %s%d%%%s<br>" +
				"Amount of cargo: %d",
				sourceColorTag,
				data.getCargoLocation(),
				endTag,
				data.getDeliveryLocation(),
				TaskReward.getRewardForTask(data.getDbrow()),
				distance,
				xpColorTag,
				xpPerTilePercent,
				endTag,
				data.getCargoAmount()
			);
			tooltipManager.add(new Tooltip(tooltip));
		}
		if (task instanceof BountyTaskData)
		{
			BountyTaskData data = (BountyTaskData) task;
			String tooltip = String.format(
				"Experience: %s<br>" +
				"Items required: %d<br>" +
				"Item rarity: 1 in %d",
				TaskReward.getRewardForTask(data.getDbrow()),
				data.getItemQuantity(),
				data.getItemRarity()
			);
			tooltipManager.add(new Tooltip(tooltip));
		}
		return null;
	}

	private static String toColTag(Color c)
	{
		return String.format("<col=%02x%02x%02x>", c.getRed(), c.getGreen(), c.getBlue());
	}

	private Integer getHoveredTask()
	{
		Point mouse = client.getMouseCanvasPosition();
		for (Map.Entry<Integer, OfferedTaskData> entry : plugin.getOfferedTasks().entrySet())
		{
			Integer dbrow = entry.getKey();
			OfferedTaskData data = entry.getValue();
			Widget w = data.getTaskWidget();

			Rectangle bounds = w.getBounds();
			if (bounds != null & bounds.contains(mouse.getX(), mouse.getY()))
			{
				return dbrow;
			}
		}
		return null;
	}

	private Object getTask(int dbrow)
	{
		CourierTaskData courier = CourierTaskData.getByDbrow(dbrow);
		if (courier != null)
		{
			return courier;
		}

		BountyTaskData bounty = BountyTaskData.getByDbrow(dbrow);
		if (bounty != null)
		{
			return bounty;
		}
		return null;
	}

	private Color interpolateColor (Color min, Color max, double t)
	{
		t = Math.max(0.0, Math.min(1.0, t));

		int r = (int) Math.round(min.getRed()   + (max.getRed()   - min.getRed())   * t);
		int g = (int) Math.round(min.getGreen() + (max.getGreen() - min.getGreen()) * t);
		int b = (int) Math.round(min.getBlue()  + (max.getBlue()  - min.getBlue())  * t);

		return new Color(r, g, b);
	}
}

package com.nucleon.porttasks.overlay;

import com.nucleon.porttasks.CourierTaskData;
import com.nucleon.porttasks.OfferedTaskData;
import com.nucleon.porttasks.PortTasksPlugin;
import com.nucleon.porttasks.WidgetTag;
import com.nucleon.porttasks.enums.BountyTaskData;
import net.runelite.api.Client;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.inject.Inject;
import java.awt.*;
import java.util.HashMap;
import java.util.Map;

public class TaskHighlight extends Overlay
{
	private final Client client;
	private final PortTasksPlugin plugin;

	@Inject
	private TaskHighlight(Client client, PortTasksPlugin plugin)
	{
		this.client = client;
		this.plugin = plugin;

		setPosition(OverlayPosition.DYNAMIC);
		setPriority(PRIORITY_HIGHEST);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
	}

	@Override
	public Dimension render (Graphics2D graphics)
	{
		Widget taskBoard = client.getWidget(InterfaceID.PortTaskBoard.CONTAINER);
		if (taskBoard == null  || taskBoard.isHidden())
		{
			return null;
		}

		Widget worldMap = client.getWidget(InterfaceID.Worldmap.CONTENT);
		if (worldMap != null && !worldMap.isHidden())
		{
			return null;
		}

		Widget taskInfo = client.getWidget(InterfaceID.PortTaskInfo.WINDOW);
		if (taskInfo != null && !taskInfo.isHidden())
		{
			return null;
		}

		Map<Integer, OfferedTaskData> offered = plugin.getOfferedTasks();
		if (offered.isEmpty())
		{
			return null;
		}

		Map<Integer, Color> tagColors = new HashMap<>();
		for (WidgetTag tag : plugin.getWidgetTags())
		{
			if (tag != null)
			{
				tagColors.put(tag.getDbrow(), tag.getColor());
			}
		}


		for (Map.Entry<Integer, OfferedTaskData> entry : offered.entrySet())
		{
			int dbrow = entry.getKey();
			OfferedTaskData data = entry.getValue();
			Widget widget = data.getTaskWidget();
			if (widget == null || widget.isHidden())
			{
				continue;
			}
			BountyTaskData bounty = BountyTaskData.getByDbrow(dbrow);
			boolean isBounty = bounty != null;

			CourierTaskData courier = CourierTaskData.getByDbrow(dbrow);
			boolean isCourier = courier != null;

			// You are prevented from taking two courier tasks of the same cargo
			boolean conflicts = isCourier ? plugin.getCourierTasks().stream()
				.anyMatch(task -> task.getData().getCargo() == courier.getCargo()) : false;

			Color tagColor = tagColors.get(dbrow);
			// Always draw a border if the task is tagged
			if (tagColor != null)
			{
				renderWidgetTag(graphics, widget, tagColor, 2);
			}
			// In order to inadvertently make the tint darker than intended
			// the first time the widget is hidden we should continue to the next widget
			else if (plugin.isNoticeBoardHideUntagged())
			{
				renderWidgetHider(graphics, widget, Color.BLACK, plugin.getNoticeBoardHideOpactity());
				continue;
			}
			if (plugin.isNoticeBoardHideIncompletable() && plugin.getSailingLevel() < data.getLevelRequired())
			{
				renderWidgetHider(graphics, widget, Color.BLACK, plugin.getNoticeBoardHideOpactity());
				continue;
			}
			if (plugin.isNoticeBoardHideBounty() && isBounty)
			{
				renderWidgetHider(graphics, widget, Color.BLACK, plugin.getNoticeBoardHideOpactity());
				continue;
			}
			if (plugin.isNoticeBoardHideCourier() && isCourier)
			{
				renderWidgetHider(graphics, widget, Color.BLACK, plugin.getNoticeBoardHideOpactity());
				continue;
			}
			if (plugin.isHighlightTaskConflicts() && conflicts)
			{
				renderWidgetHider(graphics, widget, plugin.getTaskConflictColor(), plugin.getNoticeBoardHideOpactity());
				continue;
			}
		}

		return null;
	}

	private static Rectangle renderWidgetTag(Graphics2D graphics, Widget widget, Color color, float borderWidth)
	{
		Rectangle widgetBounds = widget.getBounds();
		Stroke stroke = new BasicStroke(borderWidth);
		Color clear = new Color(0, 0, 0, 0);
		OverlayUtil.renderPolygon(graphics, rectangleToPolygon(widgetBounds), color, clear, stroke);
		return widgetBounds;
	}

	private static Rectangle renderWidgetHider(Graphics2D graphics, Widget widget, Color color, int opacity)
	{
		Rectangle widgetBounds = widget.getBounds();
		Stroke stroke = new BasicStroke(0);
		Color overlay = new Color(color.getRed(), color.getGreen(), color.getBlue(), opacity);
		// No stroke, just fill
		Color transparent = new Color(0, 0, 0, 0);
		OverlayUtil.renderPolygon(graphics, rectangleToPolygon(widgetBounds), transparent, overlay, stroke);
		return widgetBounds;
	}

	private static Polygon rectangleToPolygon(Rectangle rectangle)
	{
		int[] x_points = {rectangle.x, rectangle.x + rectangle.width, rectangle.x + rectangle.width, rectangle.x};
		int[] y_points = {rectangle.y, rectangle.y, rectangle.y + rectangle.height, rectangle.y + rectangle.height};
		return new Polygon(x_points, y_points, 4);
	}
}

package com.nucleon.porttasks.overlay;

import com.nucleon.porttasks.PortTasksConfig;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.events.BeforeRender;
import net.runelite.client.eventbus.Subscribe;
import javax.inject.Inject;
import javax.inject.Singleton;

public class TracerConfig
{
	@Getter
	private int frameTick = 0;
	@Getter
	@Setter
	private int tracerSpeed = 30;
	@Getter
	@Setter
	private float tracerIntensity = 0.6f;
	@Getter
	@Setter
	private boolean tracerEnabled;
	private long lastUpdateNanos = 0;
	private final PortTasksConfig config;

	@Inject
	@Singleton
	public TracerConfig(PortTasksConfig config)
	{
		this.config = config;
	}

	@SuppressWarnings("unused")
	@Subscribe
	public void onBeforeRender(BeforeRender event)
	{
		if (!tracerEnabled)
		{
			return;
		}

		long FRAME_INTERVAL_NANOS = tracerSpeed == 0 ? Long.MAX_VALUE : 1_000_000_000L / tracerSpeed;
		long now = System.nanoTime();
		if (now - lastUpdateNanos >= FRAME_INTERVAL_NANOS)
		{
			frameTick = (frameTick + 1) % 1000;
			lastUpdateNanos = now;
		}
	}
	public void loadConfigs(PortTasksConfig config)
	{
		this.tracerEnabled = config.enableTracer();
		this.tracerIntensity = 1f - (config.tracerIntensity() / 100f);
		this.tracerSpeed = config.tracerSpeed();
	}
}

/*
 * Copyright (c) 2021, Zoinkwiz <https://github.com/Zoinkwiz>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 * nucleon <https://github.com/nucleon>
 * Modification: drawLinesOnWorld()
 * Interpolates long lines into shorter segments to bypass RuneLites overlay draw distance limit.
 */

package com.nucleon.porttasks.overlay;

import java.util.ArrayList;

import com.nucleon.porttasks.CourierTask;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.WorldEntity;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.annotation.Nonnull;
import java.awt.*;
import java.awt.geom.Line2D;
import java.util.Collections;
import java.util.List;

public class WorldLines
{
	public static void createWorldMapLines(Graphics2D graphics, Client client, List<WorldPoint> linePoints, Color color)
	{
		Rectangle mapViewArea = WorldPerspective.getWorldMapClipArea(client);

		for (int i = 0; i < linePoints.size() - 1; i++)
		{
			Point startPoint = WorldPerspective.mapWorldPointToGraphicsPoint(client, linePoints.get(i));
			Point endPoint = WorldPerspective.mapWorldPointToGraphicsPoint(client, linePoints.get(i + 1));

			WorldLines.renderWorldMapLine(graphics, client, mapViewArea, startPoint, endPoint, color);
		}
	}

	public static void renderWorldMapLine(Graphics2D graphics, Client client, Rectangle mapViewArea, Point startPoint, Point endPoint, Color color)
	{
		if (mapViewArea == null || startPoint == null || endPoint == null)
		{
			return;
		}
		if (!mapViewArea.contains(startPoint.getX(), startPoint.getY()) && !mapViewArea.contains(endPoint.getX(), endPoint.getY()))
		{
			return;
		}

		Line2D.Double line = new Line2D.Double(startPoint.getX(), startPoint.getY(), endPoint.getX(), endPoint.getY());
		DirectionArrow.drawLine(graphics, line, color, WorldPerspective.getWorldMapClipArea(client));
	}

	public static void drawPortTaskLinesOnWorld(Graphics2D graphics, Client client, CourierTask task, TracerConfig tracerConfig, boolean offset, int clip, int drawDistance)
	{
		if (tracerConfig.isTracerEnabled())
		{
			renderTaskLinesTracer(graphics, client, task, clip, offset, tracerConfig, drawDistance);
		}
		else
		{
			renderTaskLines(graphics, client, task, clip, offset, drawDistance);
		}
	}

	private static void renderTaskLines(Graphics2D g, Client client, CourierTask task, int clip, boolean offset, int drawDistance)
	{
		int heightOffset = offset ? (task.getSlot() * 100) : 0;
		clip += (clip * 128);
		WorldView playerWorldView = client.getLocalPlayer().getWorldView();
		WorldPoint playerWorldPoint = client.getLocalPlayer().getWorldLocation();
		if (playerWorldView == null || playerWorldPoint == null)
		{
			return;
		}

		WorldPoint boatMainWorldPoint = null;
		if (!playerWorldView.isTopLevel() && playerWorldView.getId() != -1)
		{
			WorldEntity playerWorldEntity = client.getTopLevelWorldView().worldEntities().byIndex(playerWorldView.getId());
			if (playerWorldEntity != null)
			{
				boatMainWorldPoint = WorldPoint.fromLocalInstance(client, playerWorldEntity.getLocalLocation());
			}

			if (boatMainWorldPoint != null)
			{
				List<WorldPoint> journey = task.getData().dockMarkers.getFullPath();
				Color overlayColor = task.getOverlayColor();
				LocalPoint boatMainLocalPoint = WorldPerspective.worldToLocal(client, boatMainWorldPoint);

				if (task.getData().reversePath)
				{
					Collections.reverse(journey);
				}

				for (int i = 0; i < journey.size() - 1; i++)
				{
					if (boatMainWorldPoint.distanceTo(journey.get(i)) > drawDistance)
					{
						continue;
					}
					renderLineWorld(g, client, boatMainWorldPoint, boatMainLocalPoint, journey.get(i), heightOffset, journey.get(i + 1), heightOffset, overlayColor, 2, (float) clip);
				}
			}
		}
	}
	private static void renderTaskLinesTracer(Graphics2D g, Client client, CourierTask task, int clip, boolean offset, TracerConfig tracerConfig, int drawDistance)
	{
		int heightOffset = offset ? (task.getSlot() * 100) : 0;
		clip += (clip * 128);
		WorldView playerWorldView = client.getLocalPlayer().getWorldView();
		WorldPoint playerWorldPoint = client.getLocalPlayer().getWorldLocation();
		if (playerWorldView == null || playerWorldPoint == null)
		{
			return;
		}

		WorldPoint boatMainWorldPoint = null;
		if (!playerWorldView.isTopLevel() && playerWorldView.getId() != -1)
		{
			WorldEntity playerWorldEntity = client.getTopLevelWorldView().worldEntities().byIndex(playerWorldView.getId());
			if (playerWorldEntity != null)
			{
				boatMainWorldPoint = WorldPoint.fromLocalInstance(client, playerWorldEntity.getLocalLocation());
			}

			if (boatMainWorldPoint != null)
			{
				List<WorldPoint> journey = task.getData().dockMarkers.getFullPath();
				Color overlayColor = task.getOverlayColor();
				LocalPoint boatMainLocalPoint = WorldPerspective.worldToLocal(client, boatMainWorldPoint);

				if (task.getData().reversePath)
				{
					Collections.reverse(journey);
				}

				for (int i = 0; i < journey.size() - 1; i++)
				{
					if (boatMainWorldPoint.distanceTo(journey.get(i)) > drawDistance)
					{
						continue;
					}

					renderLineWorld(g, client, boatMainWorldPoint, boatMainLocalPoint, journey.get(i), heightOffset, journey.get(i + 1), heightOffset, overlayColor, 2, (float) clip, tracerConfig);
				}
			}
		}
	}

	private static Color dimColor(Color color, float factor)
	{
		factor = Math.min(Math.max(factor, 0f), 1f);
		int r = (int)(color.getRed() * factor);
		int g = (int)(color.getGreen() * factor);
		int b = (int)(color.getBlue() * factor);
		int a = (int)(color.getAlpha() * factor);
		return new Color(r, g, b, a);
	}

	private static List<WorldPoint> interpolateLine(WorldPoint start, WorldPoint end)
		{
			List<WorldPoint> result = new ArrayList<>();
			int steps = Math.max(start.distanceTo(end), 1);

			for (int i = 0; i <= steps; i++)
			{
				double t = i / (double) steps;
				int x = (int) Math.round(lerp(start.getX(), end.getX(), t));
				int y = (int) Math.round(lerp(start.getY(), end.getY(), t));
				int plane = start.getPlane();
				result.add(new WorldPoint(x, y, plane));
			}

			return result;
		}

	private static double lerp(int a, int b, double t)
	{
		return a + (b - a) * t;
	}

	private static void renderLineWorld(final Graphics2D graphics, Client client, final WorldPoint refWp, final LocalPoint refLp, final WorldPoint startWp, int startHeight, final WorldPoint endWp, int endHeight, final Color c, final float lineWidth, final float distanceClip)
	{
		// Now convert the start and end into local points based on an offset
		LocalPoint startLp = new LocalPoint(refLp.getX() + (startWp.getX() - refWp.getX()) * Perspective.LOCAL_TILE_SIZE, refLp.getY() + (startWp.getY() - refWp.getY()) * Perspective.LOCAL_TILE_SIZE, -1);
		LocalPoint endLp   = new LocalPoint(refLp.getX() + (  endWp.getX() - refWp.getX()) * Perspective.LOCAL_TILE_SIZE, refLp.getY() + (  endWp.getY() - refWp.getY()) * Perspective.LOCAL_TILE_SIZE, -1);

		renderLineLocal(graphics, client, startLp, startHeight, endLp, endHeight, c, lineWidth, distanceClip);
	}

private static void renderLineWorld(Graphics2D graphics, Client client, WorldPoint refWp, LocalPoint refLp, WorldPoint startWp, int startHeight, WorldPoint endWp, int endHeight, Color c, float lineWidth, float distanceClip, TracerConfig tracerConfig)
{
	List<WorldPoint> fullInterp = interpolateLine(startWp, endWp);
	if (fullInterp.isEmpty())
	{
		return;
	}

	final int CHUNK_SIZE = 50;
	int totalPoints = fullInterp.size();
	int totalSegments = totalPoints - 1;
	if (totalSegments <= 0)
	{
		return;
	}

	int pulse = tracerConfig.getFrameTick() % CHUNK_SIZE;

	for (int i = 0; i < totalSegments; i++)
	{
		int chunkIndex = i / CHUNK_SIZE;
		int segmentInChunk = i % CHUNK_SIZE;
		int segmentsRemaining = totalSegments - chunkIndex * CHUNK_SIZE;
		int segmentsInChunk = Math.min(CHUNK_SIZE, segmentsRemaining);

		boolean isPulse;
		if (segmentsInChunk == CHUNK_SIZE)
		{
			isPulse = segmentInChunk == pulse;
		}
		else
		{
			int scaledPulse = (pulse * segmentsInChunk) / CHUNK_SIZE;
			isPulse = segmentInChunk == scaledPulse;
		}

		WorldPoint wp1 = fullInterp.get(i);
		WorldPoint wp2 = fullInterp.get(i + 1);

		LocalPoint lp1 = new LocalPoint(
				refLp.getX() + (wp1.getX() - refWp.getX()) * Perspective.LOCAL_TILE_SIZE,
				refLp.getY() + (wp1.getY() - refWp.getY()) * Perspective.LOCAL_TILE_SIZE,
				-1
		);

		LocalPoint lp2 = new LocalPoint(
				refLp.getX() + (wp2.getX() - refWp.getX()) * Perspective.LOCAL_TILE_SIZE,
				refLp.getY() + (wp2.getY() - refWp.getY()) * Perspective.LOCAL_TILE_SIZE,
				-1
		);

		Color col = isPulse
				? c
				: dimColor(c, tracerConfig.getTracerIntensity());

		renderLineLocal(graphics, client, lp1, startHeight, lp2, endHeight, col, lineWidth, distanceClip);
	}
}




private static void renderLineLocal(final Graphics2D graphics, Client client, final LocalPoint start, int startHeight, final LocalPoint end, int endHeight, final Color c, final float lineWidth, final float distanceClip)
	{
		Polygon poly = getLinePoly(client, start, startHeight, end, endHeight, distanceClip);

		if (poly != null)
		{
			OverlayUtil.renderPolygon(graphics, poly, c, c, new BasicStroke(lineWidth));
		}
	}

	public static Point cameraToCanvas(@Nonnull Client client, float x, float y, float z)
	{
		final float viewportXMiddle = client.getViewportWidth() / 2f;
		final float viewportYMiddle = client.getViewportHeight() / 2f;
		final float viewportXOffset = client.getViewportXOffset();
		final float viewportYOffset = client.getViewportYOffset();

		final float zoom3d = client.getScale();

		int viewX, viewY;
		float sX, sY;

		if (z < 0)
		{
			// Never happens since we clip to the near plane, but a failsafe just in case
			return null;
		}
		else
		{
			sX = (viewportXMiddle + (x * zoom3d) / z);
			sY = (viewportYMiddle + (y * zoom3d) / z);
		}

		viewX = Math.round(sX + viewportXOffset);
		viewY = Math.round(sY + viewportYOffset);

		return new Point(viewX, viewY);
	}

	public static float[] localToCamera(@Nonnull Client client, float x, float y, float z)
	{
		final double cameraPitch = client.getCameraFpPitch();
		final double cameraYaw = client.getCameraFpYaw();

		final float pitchSin = (float) Math.sin(cameraPitch);
		final float pitchCos = (float) Math.cos(cameraPitch);
		final float yawSin = (float) Math.sin(cameraYaw);
		final float yawCos = (float) Math.cos(cameraYaw);

		final float cx = (float) client.getCameraFpX();
		final float cy = (float) client.getCameraFpY();
		final float cz = (float) client.getCameraFpZ();

		x -= cx;
		y -= cy;
		z -= cz;

		float x1 = x * yawCos + y * yawSin;
		float y1 = y * yawCos - x * yawSin;
		float y2 = z * pitchCos - y1 * pitchSin;
		float z1 = y1 * pitchCos + z * pitchSin;

		return new float[] { x1, y2, z1 };
	}

	private static void lerpPos(float[] srcDst, float[] target, float amount)
	{
		srcDst[0] = srcDst[0] + (target[0] - srcDst[0]) * amount;
		srcDst[1] = srcDst[1] + (target[1] - srcDst[1]) * amount;
		srcDst[2] = srcDst[2] + (target[2] - srcDst[2]) * amount;
	}

	private static Polygon getLinePoly(@Nonnull Client client, @Nonnull LocalPoint localLocation1, int z1, @Nonnull LocalPoint localLocation2, int z2, float distanceClip)
	{
		final int x1 = localLocation1.getX();
		final int y1 = localLocation1.getY();

		final int x2 = localLocation2.getX();
		final int y2 = localLocation2.getY();

		// First turn it into cameraspace so we can clip to the near plane, before turning it into screenspace
		float[] p1Cam = localToCamera(client, x1, y1, z1);
		float[] p2Cam = localToCamera(client, x2, y2, z2);

		final float near = 50; // arbitrary near plane

		if (p1Cam[2] < near && p2Cam[2] < near)
		{
			// both points behind cam, skip this line entirely
			return null;
		}

		if (distanceClip > 0)
		{
			// find points along the line that are x distance away
			final float cx = (float)client.getCameraFpX();
			final float cy = (float)client.getCameraFpY();

			final double rayX = x2 - x1;
			final double rayY = y2 - y1;

			final double camToAX = x1 - (int)cx;
			final double camToAY = y1 - (int)cy;

			// so we dont have to sqrt
			final double distanceClipSquared = distanceClip * distanceClip;
			final double p1DistanceSquared = Math.pow(cx - x1, 2) + Math.pow(cy - y1, 2);
			final double p2DistanceSquared = Math.pow(cx - x2, 2) + Math.pow(cy - y2, 2);

			// Stop calculating if they're both in bounds
			if (p1DistanceSquared > distanceClipSquared || p2DistanceSquared > distanceClipSquared)
			{
				// do some math to figure out the proportions along the line where the distance would be equal to the clip distance
				// sorry this math is messy but at least it works
				final double rayDistSquared = Math.pow(rayX, 2) + Math.pow(rayY, 2);

				final double camDotRay = 2f * ((camToAX * rayX) + (camToAY * rayY));
				final double p1DistanceDifferenceSquared = p1DistanceSquared - distanceClipSquared;

				final double discriminantSquared = Math.pow(camDotRay, 2) - 4.0 * rayDistSquared * p1DistanceDifferenceSquared;

				// If discriminant <= 0, no intersections, discard the line
				if (discriminantSquared <= 0)
				{
					return null;
				}

				final double discriminant = Math.sqrt(discriminantSquared);

				// two possible intersection ratios
				final double tIntersection1 = (-camDotRay - discriminant) / (2 * rayDistSquared);
				final double tIntersection2 = (-camDotRay + discriminant) / (2 * rayDistSquared);

				// intersection happens exactly on a tangent, or both are past either endpoint, discard this line
				if (tIntersection1 == tIntersection2 || (tIntersection1 <= 0 && tIntersection2 <= 0) || (tIntersection1 >= 1 && tIntersection2 >= 1))
				{
					return null;
				}

				final float tIntersectionClosestToA = (float)Math.min(tIntersection1, tIntersection2);
				final float tIntersectionClosestToB = (float)Math.max(tIntersection1, tIntersection2);

				// keep p1 original just so when we lerp it we're not lerping to the lerped point
				float[] p1CamOriginal = p1Cam.clone();

				if (p1DistanceSquared > distanceClipSquared && tIntersectionClosestToA > 0 && tIntersectionClosestToA < 1)
				{
					lerpPos(p1Cam, p2Cam, tIntersectionClosestToA);
				}

				if (p2DistanceSquared > distanceClipSquared && tIntersectionClosestToB > 0 && tIntersectionClosestToB < 1)
				{
					lerpPos(p2Cam, p1CamOriginal, 1 - tIntersectionClosestToB);
				}
			}
		}

		// If point is behind the cam, lerp the point between itself and p1 proportionally until it hits the intersection
		if (p1Cam[2] < near)
		{
			lerpPos(p1Cam, p2Cam, 1 - ((near - p2Cam[2]) / (p1Cam[2] - p2Cam[2])));
			p1Cam[2] = near;
		}

		if (p2Cam[2] < near)
		{
			lerpPos(p2Cam, p1Cam, 1 - ((near - p1Cam[2]) / (p2Cam[2] - p1Cam[2])));
			p2Cam[2] = near;
		}

		Point p1 = cameraToCanvas(client, p1Cam[0], p1Cam[1], p1Cam[2]);
		Point p2 = cameraToCanvas(client, p2Cam[0], p2Cam[1], p2Cam[2]);

		if (p1 == null || p2 == null)
		{
			return null;
		}

		Polygon poly = new Polygon();
		poly.addPoint(p1.getX(), p1.getY());
		poly.addPoint(p2.getX(), p2.getY());

		return poly;
	}
}

/*
 * Copyright (c) 2021, Zoinkwiz <https://github.com/Zoinkwiz>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks.overlay;

import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.Widget;

import java.awt.*;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import static net.runelite.api.Constants.CHUNK_SIZE;

public class WorldPerspective
{
private final static int SW = 0;
private final static int NW = 3;
private final static int NE = 2;
private final static int SE = 1;

	public static Collection<WorldPoint> toLocalInstanceFromReal(Client client, WorldPoint worldPoint)
	{
		if (!client.isInInstancedRegion())
		{
			return Collections.singleton(worldPoint);
		}

		if (worldPoint == null) return Collections.singleton(null);

		List<WorldPoint> worldPoints = new ArrayList<>();

		int[][][] instanceTemplateChunks = client.getInstanceTemplateChunks();
		for (int z = 0; z < instanceTemplateChunks.length; ++z)
		{
			for (int x = 0; x < instanceTemplateChunks[z].length; ++x)
			{
				for (int y = 0; y < instanceTemplateChunks[z][x].length; ++y)
				{
					int chunkData = instanceTemplateChunks[z][x][y];
					int rotation = chunkData >> 1 & 0x3;
					int templateChunkY = (chunkData >> 3 & 0x7FF) * CHUNK_SIZE;
					int templateChunkX = (chunkData >> 14 & 0x3FF) * CHUNK_SIZE;
					if (worldPoint.getX() >= templateChunkX && worldPoint.getX() < templateChunkX + CHUNK_SIZE
							&& worldPoint.getY() >= templateChunkY && worldPoint.getY() < templateChunkY + CHUNK_SIZE)
					{
						WorldPoint p =
								new WorldPoint(client.getBaseX() + x * CHUNK_SIZE + (worldPoint.getX() & (CHUNK_SIZE - 1)),
										client.getBaseY() + y * CHUNK_SIZE + (worldPoint.getY() & (CHUNK_SIZE - 1)),
										z);
						p = rotate(p, rotation);
						if (p.isInScene(client))
						{
							worldPoints.add(p);
						}
					}
				}
			}
		}
		return worldPoints;
	}

	private static WorldPoint rotate(WorldPoint point, int rotation)
	{
		int chunkX = point.getX() & -CHUNK_SIZE;
		int chunkY = point.getY() & -CHUNK_SIZE;
		int x = point.getX() & (CHUNK_SIZE - 1);
		int y = point.getY() & (CHUNK_SIZE - 1);
		switch (rotation)
		{
			case 1:
				return new WorldPoint(chunkX + y, chunkY + (CHUNK_SIZE - 1 - x), point.getPlane());
			case 2:
				return new WorldPoint(chunkX + (CHUNK_SIZE - 1 - x), chunkY + (CHUNK_SIZE - 1 - y), point.getPlane());
			case 3:
				return new WorldPoint(chunkX + (CHUNK_SIZE - 1 - y), chunkY + x, point.getPlane());
		}
		return point;
	}

	public static List<LocalPoint> getInstanceLocalPointFromReal(Client client, WorldPoint wp)
	{
		List<WorldPoint> instanceWorldPoint = new ArrayList<>(WorldPerspective.toLocalInstanceFromReal(client, wp));

		List<LocalPoint> localPoints = new ArrayList<>();
		for (WorldPoint worldPoint : instanceWorldPoint)
		{
			LocalPoint lp = LocalPoint.fromWorld(client.getTopLevelWorldView(), worldPoint);
			if (lp != null)
			{
				localPoints.add(lp);
			}
		}

		return localPoints;
	}

	public static LocalPoint worldToLocal(Client client, WorldPoint worldPoint)
	{
		if (worldPoint == null)
		{
			return null;
		}

		Collection<WorldPoint> instances = WorldPerspective.toLocalInstanceFromReal(client, worldPoint);
		for (WorldPoint wp : instances)
		{
			if (wp == null)
			{
				continue;
			}

			LocalPoint lp = LocalPoint.fromWorld(client.getTopLevelWorldView(), wp);
			if (lp != null)
			{
				return lp;
			}
		}

		return null;
	}

	public static WorldPoint getInstanceWorldPointFromReal(Client client, WorldPoint wp)
	{
		if (wp == null) return null;
		Collection<WorldPoint> points = WorldPerspective.toLocalInstanceFromReal(client, wp);

		if (points.isEmpty()) return null;

		WorldPoint p = null;
		for (WorldPoint point : points)
		{
			if (point != null)
			{
				p = point;
			}
		}
		return p;
	}

	public static WorldPoint getRealWorldPointFromLocal(Client client, WorldPoint wp)
	{
		LocalPoint lp = LocalPoint.fromWorld(client.getTopLevelWorldView(), wp);
		if (lp == null) return null;

		return WorldPoint.fromLocalInstance(client, lp);
	}

	public static Rectangle getWorldMapClipArea(Client client)
	{
		Widget widget = client.getWidget(InterfaceID.Worldmap.MAP_CONTAINER);
		if (widget == null)
		{
			return null;
		}

		return widget.getBounds();
	}

	public static Point mapWorldPointToGraphicsPoint(Client client, WorldPoint worldPoint)
	{
		var worldMap = client.getWorldMap();
		if (worldPoint == null) return null;
		if (!worldMap.getWorldMapData().surfaceContainsPosition(worldPoint.getX(), worldPoint.getY()))
		{
			return null;
		}

		float pixelsPerTile = worldMap.getWorldMapZoom();

		Widget map = client.getWidget(InterfaceID.Worldmap.MAP_CONTAINER);
		if (map != null)
		{
			Rectangle worldMapRect = map.getBounds();

			int widthInTiles = (int) Math.ceil(worldMapRect.getWidth() / pixelsPerTile);
			int heightInTiles = (int) Math.ceil(worldMapRect.getHeight() / pixelsPerTile);

			var worldMapPosition = worldMap.getWorldMapPosition();

			int yTileMax = worldMapPosition.getY() - heightInTiles / 2;
			int yTileOffset = (yTileMax - worldPoint.getY() - 1) * -1;
			int xTileOffset = worldPoint.getX() + widthInTiles / 2 - worldMapPosition.getX();

			int xGraphDiff = ((int) (xTileOffset * pixelsPerTile));
			int yGraphDiff = (int) (yTileOffset * pixelsPerTile);

			yGraphDiff -= pixelsPerTile - Math.ceil(pixelsPerTile / 2);
			xGraphDiff += pixelsPerTile - Math.ceil(pixelsPerTile / 2);

			yGraphDiff = worldMapRect.height - yGraphDiff;
			yGraphDiff += (int) worldMapRect.getY();
			xGraphDiff += (int) worldMapRect.getX();

			return new Point(xGraphDiff, yGraphDiff);
		}
		return null;
	}

	public static List<Point> worldToCanvasWithOffset(Client client, WorldPoint worldPoint, int zOffset)
	{
		List<Point> canvasPoints = new ArrayList<>();

		if (worldPoint == null)
		{
			return canvasPoints;
		}

		Collection<WorldPoint> instances = WorldPerspective.toLocalInstanceFromReal(client, worldPoint);
		for (WorldPoint wp : instances)
		{
			if (wp == null)
			{
				continue;
			}

			LocalPoint lp = LocalPoint.fromWorld(client.getTopLevelWorldView(), wp);
			if (lp == null)
			{
				continue;
			}

			Point canvas = net.runelite.api.Perspective.localToCanvas(client, lp, wp.getPlane(), zOffset);
			if (canvas != null)
			{
				canvasPoints.add(canvas);
			}
		}

		return canvasPoints;
	}




public static Point getMinimapPoint(Client client, WorldPoint start, WorldPoint destination)
	{
		var worldMapData = client.getWorldMap().getWorldMapData();
		if (worldMapData.surfaceContainsPosition(start.getX(), start.getY()) !=
				worldMapData.surfaceContainsPosition(destination.getX(), destination.getY()))
		{
			return null;
		}

		int x = (destination.getX() - start.getX());
		int y = (destination.getY() - start.getY());

		float maxDistance = Math.max(Math.abs(x), Math.abs(y));
		x = x * 100;
		y = y * 100;
		x /= maxDistance;
		y /= maxDistance;

		Widget minimapDrawWidget;
		if (client.isResized())
		{
			if (client.getVarbitValue(VarbitID.RESIZABLE_STONE_ARRANGEMENT) == 1)
			{
				minimapDrawWidget = client.getWidget(InterfaceID.ToplevelPreEoc.MINIMAP);
			}
			else
			{
				minimapDrawWidget = client.getWidget(InterfaceID.ToplevelOsrsStretch.MINIMAP);
			}
		}
		else
		{
			minimapDrawWidget = client.getWidget(InterfaceID.Toplevel.MINIMAP);
		}

		if (minimapDrawWidget == null)
		{
			return null;
		}

		final int angle = client.getCameraYawTarget() & 0x7FF;

		final int sin = net.runelite.api.Perspective.SINE[angle];
		final int cos = net.runelite.api.Perspective.COSINE[angle];

		final int xx = y * sin + cos * x >> 16;
		final int yy = sin * x - y * cos >> 16;

		Point loc = minimapDrawWidget.getCanvasLocation();
		int miniMapX = loc.getX() + xx + minimapDrawWidget.getWidth() / 2;
		int miniMapY = minimapDrawWidget.getHeight() / 2 + loc.getY() + yy;
		return new Point(miniMapX, miniMapY);
	}

	public static Polygon getZonePoly(Client client, Zone zone)
	{
		Polygon areaPoly = new Polygon();
		if (zone == null) return areaPoly;

		for (int x = zone.getMinX(); x < zone.getMaxX(); x++)
		{
			addToPoly(client, areaPoly, new WorldPoint(x, zone.getMaxY(), zone.getMinWorldPoint().getPlane()), NW);
		}

		addToPoly(client, areaPoly, new WorldPoint(zone.getMaxX(), zone.getMaxY(), zone.getMinWorldPoint().getPlane()), NW, NE, SE);

		for (int y = zone.getMaxY() - 1; y > zone.getMinY(); y--)
		{
			addToPoly(client, areaPoly, new WorldPoint(zone.getMaxX(), y, zone.getMinWorldPoint().getPlane()), SE);
		}

		addToPoly(client, areaPoly, new WorldPoint(zone.getMaxX(), zone.getMinY(), zone.getMinWorldPoint().getPlane()), SE, SW);

		for (int x = zone.getMaxX() - 1; x > zone.getMinX(); x--)
		{
			addToPoly(client, areaPoly, new WorldPoint(x, zone.getMinY(), zone.getMinWorldPoint().getPlane()), SW);
		}

		addToPoly(client, areaPoly, new WorldPoint(zone.getMinX(), zone.getMinY(), zone.getMinWorldPoint().getPlane()), SW, NW);

		for (int y = zone.getMinY() + 1; y < zone.getMaxY(); y++)
		{
			addToPoly(client, areaPoly, new WorldPoint(zone.getMinX(), y, zone.getMinWorldPoint().getPlane()), NW);
		}


		return areaPoly;
	}

	private static void addToPoly(Client client, Polygon areaPoly, WorldPoint wp, int... points)
	{
		LocalPoint localPoint = LocalPoint.fromWorld(client.getTopLevelWorldView(), wp);
		if (localPoint == null) return;

		Polygon poly = net.runelite.api.Perspective.getCanvasTilePoly(client, localPoint);
		if (poly != null)
		{
			for (int point : points)
			{
				areaPoly.addPoint(poly.xpoints[point], poly.ypoints[point]);
			}
		}
	}
}
/*
 * Copyright (c) 2019, Trevor <https://github.com/Trevor159>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks.overlay;

import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

import static net.runelite.api.Constants.REGION_SIZE;

public class Zone
{
	@Getter
	private final int minX;
	@Getter
	private final int maxX;
	@Getter
	private final int minY;
	@Getter
	private final int maxY;
	private int minPlane = 0;
	private int maxPlane = 2;

	//The first plane of the "Overworld"
	public Zone()
	{
		minX = 1152;
		maxX = 3903;
		minY = 2496;
		maxY = 4159;
		maxPlane = 0;
	}

	public Zone(WorldPoint p1, WorldPoint p2)
	{
		assert (p1 != null);
		assert (p2 != null);
		minX = Math.min(p1.getX(), p2.getX());
		maxX = Math.max(p1.getX(), p2.getX());
		minY = Math.min(p1.getY(), p2.getY());
		maxY = Math.max(p1.getY(), p2.getY());
		minPlane = Math.min(p1.getPlane(), p2.getPlane());
		maxPlane = Math.max(p1.getPlane(), p2.getPlane());
	}

	public Zone(WorldPoint p)
	{
		assert (p != null);
		minX = p.getX();
		maxX = p.getX();
		minY = p.getY();
		maxY = p.getY();
		minPlane = p.getPlane();
		maxPlane = p.getPlane();
	}

	public Zone(int regionID)
	{
		minX = ((regionID >> 8) & 0xFF) << 6;
		maxX = minX + REGION_SIZE;
		minY = (regionID & 0xFF) << 6;
		maxY = minY + REGION_SIZE;
	}

	public Zone(int regionID, int plane)
	{
		this(regionID);
		minPlane = plane;
		maxPlane = plane;
	}

	public boolean contains(WorldPoint worldPoint)
	{
		return minX <= worldPoint.getX()
				&& worldPoint.getX() <= maxX
				&& minY <= worldPoint.getY()
				&& worldPoint.getY() <= maxY
				&& minPlane <= worldPoint.getPlane()
				&& worldPoint.getPlane() <= maxPlane;
	}

	public WorldPoint getMinWorldPoint()
	{
		return new WorldPoint(minX, minY, minPlane);
	}
}

package com.nucleon.porttasks;

import com.nucleon.porttasks.enums.PortPaths;

public final class PortPathMatch
{
	private final PortPaths path;
	private final boolean reversed;

	public PortPathMatch(PortPaths path, boolean reversed)
	{
		this.path = path;
		this.reversed = reversed;
	}

	public PortPaths getPath()
	{
		return path;
	}

	public boolean isReversed()
	{
		return reversed;
	}
}

/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;

import javax.inject.Inject;

import net.runelite.api.Client;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.client.game.ItemManager;

import net.runelite.client.ui.overlay.WidgetItemOverlay;

class PortTaskCargoOverlay extends WidgetItemOverlay
{
	private final Client client;
	private final PortTasksPlugin plugin;
	private final PortTasksConfig config;
	private final ItemManager itemManager;

	@Inject
	private PortTaskCargoOverlay(Client client, PortTasksPlugin plugin, PortTasksConfig config, ItemManager itemManager)
	{
		this.client = client;
		this.plugin = plugin;
		this.config = config;
		this.itemManager = itemManager;

		showOnInterfaces(InterfaceID.SAILING_BOAT_CARGOHOLD);
		showOnInventory();
	}

	@Override
	public void renderItemOverlay(Graphics2D graphics, int itemId, WidgetItem widgetItem)
	{
		final Color color = getMatchingTaskColor(itemId);
		if (color == null)
		{
			return;
		}
		Rectangle bounds = widgetItem.getCanvasBounds();
		final BufferedImage outline = itemManager.getItemOutline(itemId, widgetItem.getQuantity(), color);
		graphics.drawImage(outline, (int) bounds.getX(), (int) bounds.getY(), null);
	}

	private Color getMatchingTaskColor(int itemId)
	{
		for (CourierTask task : plugin.courierTasks)
		{
			if (task.getData().cargo == itemId)
			{
				return task.getOverlayColor();
			}
		}
		for (BountyTask task : plugin.bountyTasks)
		{
			if (task.getData().itemId == itemId)
			{
				return task.getOverlayColor();
			}
		}
		return null;
	}
}
package com.nucleon.porttasks;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.Stroke;
import java.util.Set;
import javax.inject.Inject;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.GroundObject;
import net.runelite.api.ObjectComposition;
import net.runelite.api.Point;
import net.runelite.api.Scene;
import net.runelite.api.Tile;
import net.runelite.api.TileObject;
import net.runelite.api.WorldView;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;
@Slf4j
public class PortTaskModelRenderer extends Overlay
{
	private final Client client;
	private final PortTasksPlugin plugin;
	private final ModelOutlineRenderer modelOutlineRenderer;

	@Inject
	private PortTaskModelRenderer(final Client client, final PortTasksPlugin plugin, final ModelOutlineRenderer modelOutlineRenderer)
	{
		this.client = client;
		this.plugin = plugin;
		this.modelOutlineRenderer = modelOutlineRenderer;

		setPosition(OverlayPosition.DYNAMIC);
		setPriority(PRIORITY_DEFAULT);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (plugin.isHighlightGangplanks())
		{
			highlightGangplanks(graphics);
		}
		if (plugin.isHighlightNoticeboards())
		{
			highlightNoticeboards(graphics);
		}
		if (plugin.isHighlightHelmMissingCargo())
		{
			for (CourierTask courierTask : plugin.courierTasks)
			{
				if (courierTask.getCargoTaken() > 0 && courierTask.getCargoTaken() < courierTask.getData().cargoAmount)
				{
					highlightLocalPlayerBoatHelm(graphics, (courierTask.getData().cargoAmount - courierTask.getCargoTaken()), courierTask.getOverlayColor());
				}
			}
		}
		if (plugin.isHighlightCargoHolds() && !plugin.isLockedIn())
		{
			highlightLocalPlayerCargoHold(graphics, plugin.getHighlightCargoHoldsColor());
		}
		return null;
	}

	private void highlightGangplanks(Graphics2D graphics)
	{
		final Set<GameObject> objects = plugin.getGangplanks();
		final Color color = plugin.getHighlightGangplanksColor();
		final Stroke stroke = new BasicStroke(1f);

		if (objects.isEmpty())
		{
			return;
		}
		for (GameObject object : objects)
		{
			WorldView wv = object.getWorldView();
			if (wv == null || object.getPlane() != wv.getPlane())
			{
				continue;
			}
			Scene scene = wv.getScene();
			Tile[][][] tiles = scene.getTiles();
			Tile tile = tiles[0][object.getLocalLocation().getSceneX()][object.getLocalLocation().getSceneY()];
			GroundObject groundObject = tile.getGroundObject();
			if (groundObject == null)
			{
				continue;
			}
			final Shape polygon = groundObject.getConvexHull();
			if (polygon == null)
			{
				continue;
			}
			OverlayUtil.renderPolygon(graphics, polygon, color, stroke);
		}
	}

	public void highlightLocalPlayerBoatHelm(Graphics2D graphics, int cargoMissing, Color color)
	{
		for (GameObject helm : plugin.getHelms())
		{
			if (helm.getWorldView().getId() == client.getLocalPlayer().getWorldView().getId())
			{
				modelOutlineRenderer.drawOutline(helm, 2, color, 250);
				drawObjectLabel(graphics, helm, cargoMissing);
			}
		}
	}
	public void highlightLocalPlayerCargoHold(Graphics2D graphics, Color color)
	{
		for (GameObject cargoHold : plugin.getCargoHolds())
		{
			if (cargoHold.getWorldView().getId() == client.getLocalPlayer().getWorldView().getId())
			{
			modelOutlineRenderer.drawOutline(cargoHold, 2, color, 250);
			}
		}
	}

	private void drawObjectLabel(Graphics2D g, TileObject obj, int cargoMissing)
	{
		if (obj != null)
		{
			ObjectComposition composition = client.getObjectDefinition(obj.getId());
			Point loc = obj.getCanvasTextLocation(g, composition.getName(), 0);
			if (loc == null)
			{
				return;
			}
			String text = "missing " + cargoMissing + " cargo";
			OverlayUtil.renderTextLocation(g, loc, text, Color.WHITE);
		}
	}

	private void highlightNoticeboards(Graphics2D graphics)
	{
		final Set<GameObject> objects = plugin.getNoticeboards();
		final Color color = plugin.getHighlightNoticeboardsColor();
		final Stroke stroke = new BasicStroke(1f);
		if (objects.isEmpty())
		{
			return;
		}
		for (GameObject object : objects)
		{
			WorldView wv = object.getWorldView();
			if (wv == null || object.getPlane() != wv.getPlane())
			{
				continue;
			}
			final Shape polygon = object.getConvexHull();
			if (polygon == null)
			{
				continue;
			}
			OverlayUtil.renderPolygon(graphics, polygon, color, stroke);
		}
	}
}

/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks;

import java.awt.Color;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;

@ConfigGroup(PortTasksConfig.CONFIG_GROUP)
public interface PortTasksConfig extends Config
{
	String CONFIG_GROUP = "porttasks";

	@ConfigSection(
			name = "Path Settings",
			description = "Configure animation and visual settings for tracers",
			position = 1
	)
	String pathSection = "pathSection";
	@ConfigItem(
			keyName = "navColor",
			name = "Task 1 Color",
			description = "The color of the navigation line",
			section = pathSection
	)
	default Color getNavColor()
	{
		return new Color(201, 51, 255);
	}
	@ConfigItem(
			keyName = "navColor2",
			name = "Task 2 Color",
			description = "The color of the navigation line",
			section = pathSection
	)
	default Color getNavColor2()
	{
		return new Color(255, 51, 105);
	}
	@ConfigItem(
			keyName = "navColor3",
			name = "Task 3 Color",
			description = "The color of the navigation line",
			section = pathSection
	)
	default Color getNavColor3()
	{
		return new Color(255, 201, 51);
	}
	@ConfigItem(
			keyName = "navColor4",
			name = "Task 4 Color",
			description = "The color of the navigation line",
			section = pathSection
	)
	default Color getNavColor4()
	{
		return new Color(105, 255, 51);
	}
	@ConfigItem(
			keyName = "navColor5",
			name = "Task 5 Color",
			description = "The color of the navigation line",
			section = pathSection
	)
	default Color getNavColor5()
	{
		return new Color(51, 255, 201);
	}

	@ConfigItem(
			keyName = "drawOverlay",
			name = "Draw Path",
			description = "Draw path for port task",
			section = pathSection
	)
	default Overlay getDrawOverlay()
	{
		return Overlay.BOTH;
	}

	@ConfigItem(
			keyName = "pathOffset",
			name = "Offset Height Per Task",
			description = "each path will be drawn at a different height",
			section = pathSection
	)
	default boolean enableHeightOffset()
	{
		return false;
	}

	@Range(min = 100, max = 250)
	@ConfigItem(
			keyName = "pathDrawDistance",
			name = "Draw Distance",
			description = "Path Draw Distance",
			section = pathSection
	)
	default int pathDrawDistance()
	{
		return 150;
	}
	@ConfigSection(
			name = "Tracer Settings",
			description = "Configure animation and visual settings for overlay direction tracers",
			position = 1
	)
	String tracerSection = "tracerSection";

	@ConfigItem(
			keyName = "enableTracer",
			name = "Enable Tracer Overlay",
			description = "Toggle tracer animation on path lines",
			section = tracerSection
	)
	default boolean enableTracer()
	{
		return false;
	}

	@Range(min = 0, max = 60)
	@ConfigItem(
			keyName = "tracerSpeed",
			name = "Tracer Speed",
			description = "Adjust how fast the tracer animation moves (lower = slower)",
			section = tracerSection
	)
	default int tracerSpeed()
	{
		return 30;
	}

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "tracerIntensity",
			name = "Tracer Intensity",
			description = "Control brightness or visibility of the tracer (0100%)",
			section = tracerSection
	)
	default int tracerIntensity()
	{
		return 50;
	}

	@ConfigSection(
		name = "Overlay Settings",
		description = "Configuration for overlays",
		position = 2
	)
	String overlaySection = "overlaySection";

	@ConfigItem(
		keyName = "highlightGangplanks",
		name = "Highlight Gangplanks",
		description = "Outline gangplanks in the world",
		position = 1,
		section = overlaySection
	)
	default boolean highlightGangplanks()
	{
		return true;
	}

	@ConfigItem(
		keyName = "highlightGangplanksColor",
		name = "Color",
		description = "Color used to outline gangplanks in the world",
		position = 2,
		section = overlaySection
	)
	default Color highlightGangplanksColor()
	{
		return Color.YELLOW;
	}

	@ConfigItem(
		keyName = "highlightNoticeboards",
		name = "Highlight Noticeboards",
		description = "Outline noticeboards in the world",
		position = 3,
		section = overlaySection
	)
	default boolean highlightNoticeboards()
	{
		return true;
	}

	@ConfigItem(
		keyName = "highlightNoticeboardsColor",
		name = "Color",
		description = "Color used to outline noticeboards in the world",
		position = 4,
		section = overlaySection
	)
	default Color highlightNoticeboardsColor()
	{
		return Color.RED;
	}
	@ConfigItem(
			keyName = "highlightCargoHolds",
			name = "Highlight Cargo Holds",
			description = "Outline cargo holds in your boat",
			position = 5,
			section = overlaySection
	)
	default boolean highlightCargoHolds()
	{
		return true;
	}

	@ConfigItem(
			keyName = "highlightCargoHoldsColor",
			name = "Color",
			description = "Color used to outline cargo holds in your boat",
			position = 6,
			section = overlaySection
	)
	default Color highlightCargoHoldsColor()
	{
		return Color.green;
	}

	@ConfigItem(
			keyName = "highlightHelmMissingCargo",
			name = "Highlight Helm Missing Cargo",
			description = "Outline helm on your boat",
			position = 7,
			section = overlaySection
	)
	default boolean highlightHelmMissingCargo()
	{
		return true;
	}

	@ConfigItem(
		keyName = "noticeBoardTooltip",
		name = "Noticeboard tooltip",
		description = "Task information in a tooltip",
		position = 8,
		section = overlaySection
	)
	default boolean noticeBoardTooltip()
	{
		return true;
	}

	@ConfigItem(
		keyName = "minColor",
		name = "Tooltip minimum color",
		description = "Color to use for the minimum range",
		position = 9,
		section = overlaySection
	)
	default Color minColor()
	{
		return Color.RED;
	}

	@ConfigItem(
		keyName = "maxColor",
		name = "Tooltip maximum color",
		description = "Color to use for the maximum range",
		position = 10,
		section = overlaySection
	)
	default Color maxColor()
	{
		return Color.GREEN;
	}

	@Range(min = 0, max = 100)
	@ConfigItem(
		keyName = "noticeBoardHideOpacity",
		name = "Notice board hider opacity",
		description = "Opacity to obscure notice board tasks. 0-100%",
		position = 11,
		section = overlaySection
	)
	default int noticeBoardHideOpacity()
	{
		return 70;
	}

	@ConfigItem(
		keyName = "noticeBoardHideIncompletable",
		name = "Hide incompletable tasks",
		description = "Hide tasks you do not have the level to complete.",
		position = 12,
		section = overlaySection
	)
	default boolean noticeBoardHideIncompletable()
	{
		return true;
	}

	@ConfigItem(
		keyName = "noticeBoardHideBounty",
		name = "Hide bounty tasks",
		description = "Hide bounty tasks.",
		position = 13,
		section = overlaySection
	)
	default boolean noticeBoardHideBounty()
	{
		return false;
	}

	@ConfigItem(
		keyName = "noticeBoardHideCourier",
		name = "Hide courier tasks",
		description = "Hide courier tasks.",
		position = 14,
		section = overlaySection
	)
	default boolean noticeBoardHideCourier()
	{
		return false;
	}

	@ConfigItem(
		keyName = "noticeBoardHideUntagged",
		name = "Hide untagged tasks",
		description = "Hide tasks you have not tagged. (Shift right-click a task to tag)",
		position = 15,
		section = overlaySection
	)
	default boolean noticeBoardHideUntagged()
	{
		return false;
	}

	@ConfigItem(
		keyName = "highlightTaskConflicts",
		name = "Highlight conflicting tasks",
		description = "Highlight tasks you are prevented from taking due to conflicting cargo.",
		position = 16,
		section = overlaySection
	)
	default boolean highlightTaskConflicts()
	{
		return false;
	}

	@ConfigItem(
		keyName = "taskConflictColor",
		name = "Task conflict color",
		description = "Color to highlight conflicting tasks.",
		position = 17,
		section = overlaySection
	)
	default Color taskConflictColor()
	{
		return Color.RED;
	}

	@ConfigSection(
		name = "Notice Board Tracker",
		description = "Configuration for notice board reset tracking.",
		position = 3
	)
	String noticeBoardTracker = "noticeBoardTrackerSection";

	@ConfigItem(
		keyName = "noticeBoardResetTracker",
		name = "Board reset tracker",
		description = "(Experimental) Adds a chat message indicating how soon until the notice board resets.",
		position = 1,
		section = noticeBoardTracker
	)
	default boolean noticeBoardResetTracker()
	{
		return false;
	}

	@Range(min = 0, max = 7)
	@ConfigItem(
		keyName = "noticeBoardState",
		name = "Tasks since reset",
		description = "Number of tasks completed since board reset (0-7)",
		position = 1,
		section = noticeBoardTracker
	)
	default int noticeBoardState()
	{
		return 0;
	}

	enum Overlay
	{
		NONE,
		MAP,
		WORLD,
		BOTH
	}

}

/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.inject.Inject;

import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.ObjectComposition;
import net.runelite.api.Perspective;
import net.runelite.api.Point;

import net.runelite.client.ui.overlay.Overlay;

import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

class PortTasksLedgerOverlay extends Overlay
{
	private final Client client;
	private final PortTasksPlugin plugin;
	private final PortTasksConfig config;

	@Inject
	private PortTasksLedgerOverlay(Client client, PortTasksPlugin plugin, PortTasksConfig config)
	{
		this.client = client;
		this.plugin = plugin;
		this.config = config;

		setPosition(OverlayPosition.DYNAMIC);
		setPriority(PRIORITY_HIGHEST);
		setLayer(OverlayLayer.UNDER_WIDGETS);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		renderOverlay(graphics);
		return null;
	}

	private void renderOverlay(Graphics2D g)
	{
		// we need to track if a port courier task is sharing a ledger for delivery or cargo
		Map<Integer, List<CourierTask>> ledgerUsageMap = new HashMap<>();
		// we need to store a reference to an objectid and an overlay
		Map<Integer, Integer> overlayCount = new HashMap<>();

		//  looping through all the port tasks currently assigned
		for (CourierTask task : plugin.courierTasks)
		{	// ledger object from the port data enum
			int pickupLedgerObjectID = task.getData().getCargoLocation().getLedgerObject();
			int deliveryLedgerObjectID = task.getData().getDeliveryLocation().getLedgerObject();
			// store a reference to them in the map, so we can render
			// multicolored overlays for shared ledgers in port tasks
			ledgerUsageMap.computeIfAbsent(pickupLedgerObjectID, k -> new ArrayList<>()).add(task);
			ledgerUsageMap.computeIfAbsent(deliveryLedgerObjectID, k -> new ArrayList<>()).add(task);
		}

		for (GameObject ledger : plugin.getLedgers())
		{
			int objectId = ledger.getId();
			List<CourierTask> tasksAtLedger = ledgerUsageMap.get(objectId);
			if (tasksAtLedger == null || tasksAtLedger.isEmpty())
			{
				continue;
			}

			ObjectComposition comp = client.getObjectDefinition(objectId);
			int size = comp.getSizeX();

			Polygon poly = Perspective.getCanvasTileAreaPoly(client, ledger.getLocalLocation(), size);
			if (poly != null)
			{	// we stored the tasks that are using this ledger,
				// so we can draw a dynamic tile
				// TODO: fix this later (pickup ledgers still overlay 1/1)
				Color[] colors = getOverlayColors(tasksAtLedger);
				renderMultiColoredSquare(g, poly, colors);
			}
			// loop through the tasks at this ledger object, get the cargo information and render a text overlay
			// for more than one task, store them in a overlayCount map and stack the text
			int offsetIndex = overlayCount.getOrDefault(objectId, 0);
			for (CourierTask task : tasksAtLedger)
			{
				int cargoTakenFromLedger = task.getCargoTaken();
				int cargoDeliveredToLedger = task.getDelivered();
				int cargoRequired = task.getData().getCargoAmount();

				int pickupId = task.getData().getCargoLocation().getLedgerObject();
				int deliveryId = task.getData().getDeliveryLocation().getLedgerObject();
				boolean isPickup = objectId == pickupId && cargoTakenFromLedger < cargoRequired;
				boolean isDelivery = objectId == deliveryId && cargoDeliveredToLedger < cargoRequired;

				if (!isPickup && !isDelivery)
				{
					continue;
				}
				// so we know it's either a pickup or delivery, display the data of either
				String label = isPickup
						? String.format("Cargo: %d/%d", cargoTakenFromLedger, cargoRequired)
						: String.format("Delivered: %d/%d", cargoDeliveredToLedger, cargoRequired);

				Point textLocation = Perspective.getCanvasTextLocation(client, g, ledger.getLocalLocation(), label, 0);
				if (textLocation != null)
				{
					int yOffset = 15 * offsetIndex;
					Point raisedLocation = new Point(textLocation.getX(), textLocation.getY() - yOffset);
					OverlayUtil.renderTextLocation(g, raisedLocation, label, Color.WHITE);
					offsetIndex++;
				}
			}
			// +1 overlay on this ledger object
			overlayCount.put(objectId, offsetIndex);
		}
	}

	private void renderMultiColoredSquare(Graphics2D g, Polygon poly, Color... colors)
	{
		if (poly == null || poly.npoints < 2 || colors.length == 0)
		{
			return;
		}

		g.setColor(new Color(0, 0, 0, 50));
		g.fillPolygon(poly);

		int nPoints = poly.npoints;
		int edgesPerColor = nPoints / colors.length;
		int remainder = nPoints % colors.length;

		int edgeIndex = 0;
		for (int colorIndex = 0; colorIndex < colors.length; colorIndex++)
		{
			int count = edgesPerColor + (colorIndex < remainder ? 1 : 0);
			g.setColor(colors[colorIndex]);
			g.setStroke(new BasicStroke(2));

			for (int i = 0; i < count; i++, edgeIndex++)
			{
				int p1 = edgeIndex % nPoints;
				int p2 = (edgeIndex + 1) % nPoints;

				int x1 = poly.xpoints[p1];
				int y1 = poly.ypoints[p1];
				int x2 = poly.xpoints[p2];
				int y2 = poly.ypoints[p2];

				g.drawLine(x1, y1, x2, y2);
			}
		}
	}

	private Color[] getOverlayColors(List<CourierTask> tasks)
	{
		Color[] colors = new Color[tasks.size()];
		for (int i = 0; i < tasks.size(); i++)
		{
			colors[i] = tasks.get(i).getOverlayColor();
		}
		return colors;
	}
}
/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.Collections;
import java.util.List;

import javax.inject.Inject;

import com.nucleon.porttasks.overlay.WorldLines;
import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;

import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

class PortTasksMapOverlay extends Overlay
{
	private final Client client;
	private final PortTasksPlugin plugin;
	private final PortTasksConfig config;

	@Inject
	private PortTasksMapOverlay(Client client, PortTasksPlugin plugin, PortTasksConfig config)
	{
		this.client = client;
		this.plugin = plugin;
		this.config = config;

		setPosition(OverlayPosition.DYNAMIC);
		setPriority(Overlay.PRIORITY_HIGHEST);
		setLayer(OverlayLayer.ALWAYS_ON_TOP);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		renderOverlayLines(graphics);
		renderOverlayLinesDeveloper(graphics);
		return null;
	}

	private void renderOverlayLines(Graphics2D g)
	{
		for (CourierTask tasks : plugin.courierTasks)
		{
			Color overlayColor = tasks.getOverlayColor();
			List<WorldPoint> journey = tasks.getData().dockMarkers.getFullPath();
			if (tasks.getData().reversePath)
			{
				Collections.reverse(journey);
			}
			if (tasks.isTracking())
			{
				WorldLines.createWorldMapLines(g, client, journey, overlayColor);
			}
		}
	}

	private void renderOverlayLinesDeveloper(Graphics2D g)
	{
		if (plugin.developerMode)
		{
			if (plugin.developerPathSelected != null)
			{
				WorldLines.createWorldMapLines(g, client, plugin.getDeveloperPathSelected().getFullPath(), Color.CYAN);
			}
		}
	}
}
/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.List;

import javax.inject.Inject;

import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;

import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

class PortTasksMiniMapOverlay extends Overlay
{
	private final Client client;
	private final PortTasksPlugin plugin;
	private final PortTasksConfig config;

	@Inject
	private PortTasksMiniMapOverlay(Client client, PortTasksPlugin plugin, PortTasksConfig config)
	{
		this.client = client;
		this.plugin = plugin;
		this.config = config;

		setPosition(OverlayPosition.DYNAMIC);
		setPriority(Overlay.PRIORITY_HIGHEST);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		renderOverlayLines(graphics);
		return null;
	}

	private void renderOverlayLines(Graphics2D g)
	{
		for (CourierTask tasks : plugin.courierTasks)
		{
			Color overlayColor = tasks.getOverlayColor();
			List<WorldPoint> navigationPoints = tasks.getData().dockMarkers.getFullPath();
			if (tasks.isTracking())
			{
				//Getting inside a boat, seems to load a different minimap (?) - nucleon
				//WorldLines.createMinimapLines(g, client, navigationPoints, overlayColor);
			}
		}
	}
}
/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks;

import com.google.common.base.MoreObjects;
import com.google.common.reflect.TypeToken;
import com.google.gson.Gson;
import com.google.inject.Provides;
import com.nucleon.porttasks.enums.BountyTaskData;
import com.nucleon.porttasks.enums.PortLocation;
import com.nucleon.porttasks.overlay.NoticeBoardTooltip;
import java.awt.Color;
import java.lang.reflect.Type;
import java.time.Instant;
import java.time.LocalDate;
import java.time.ZoneOffset;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Named;
import javax.swing.*;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import com.nucleon.porttasks.enums.PortPaths;
import com.nucleon.porttasks.enums.PortTaskTrigger;
import com.nucleon.porttasks.overlay.TaskHighlight;
import com.nucleon.porttasks.overlay.TracerConfig;
import com.nucleon.porttasks.ui.PortTasksPluginPanel;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.GameState;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.KeyCode;
import net.runelite.api.Menu;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.Skill;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.StatChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.events.WorldViewUnloaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.ObjectID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;
import net.runelite.client.ui.components.colorpicker.RuneliteColorPicker;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;
import java.util.List;
import java.util.stream.Collectors;

@Slf4j
@PluginDescriptor(
	name = "Port Tasks",
	description = "Provides navigation and overlays for sailing cargo and bounty tasks",
	tags = {"sailing", "port", "bounty", "cargo", "tasks"}
)
public class PortTasksPlugin extends Plugin
{
	@Inject
	private Client client;
	@Inject
	private PortTasksConfig config;
	@Inject
	private OverlayManager overlayManager;
	@Inject
	private ClientToolbar clientToolbar;
	@Inject
	private ConfigManager configManager;
	@Inject
	private Gson gson;
	@Getter
	@Inject
	private ColorPickerManager colorPickerManager;
	@Inject
	ChatMessageManager chatMessageManager;
	@Inject
	private PortTasksMapOverlay sailingHelperMapOverlay;
	@Inject
	private PortTasksWorldOverlay sailingHelperWorldOverlay;
	@Inject
	private PortTasksMiniMapOverlay sailingHelperMiniMapOverlay;
	@Inject
	private PortTasksLedgerOverlay portTasksLedgerOverlay;
	@Inject
	private PortTaskModelRenderer portTaskModelRenderer;
	@Inject
	private PortTaskCargoOverlay portTaskCargoOverlay;
	@Inject
	private TaskHighlight taskHighlight;
	@Inject
	NoticeBoardTooltip noticeBoardTooltip;
	@Getter
	List<CourierTask> courierTasks = new ArrayList<>();
	@Getter
	List<BountyTask> bountyTasks = new ArrayList<>();
	@Getter
	Set<GameObject> gangplanks = new HashSet<>();
	@Getter
	Set<GameObject> noticeboards = new HashSet<>();
	@Getter
	Set<GameObject> ledgers = new HashSet<>();
	@Getter
	private final Set<GameObject> helms = new HashSet<>();
	@Getter
	private final Set<GameObject> cargoHolds = new HashSet<>();
	@Getter
	Map<Integer, OfferedTaskData> offeredTasks = new HashMap<>();
	@Getter
	private final Set<WidgetTag> widgetTags = new HashSet<>();
	@Getter
	private boolean lockedIn = false;
	@Getter
	private int sailingLevel;
	@Getter
	private boolean noticeBoardHideIncompletable;
	@Getter
	private boolean noticeBoardHideBounty;
	@Getter
	private boolean noticeBoardHideCourier;
	@Getter
	private boolean noticeBoardHideUntagged;
	@Getter
	private boolean highlightGangplanks;
	@Getter
	private Color highlightGangplanksColor;
	@Getter
	private boolean highlightNoticeboards;
	@Getter
	private boolean highlightCargoHolds;
	@Getter
	private Color highlightCargoHoldsColor;
	@Getter
	private boolean highlightHelmMissingCargo;
	@Getter
	private Color highlightNoticeboardsColor;
	@Getter
	private boolean taskHeightOffset;
	@Getter
	private int pathDrawDistance;
	@Getter
	private int noticeBoardHideOpactity;
	@Getter
	private Color minColor;
	@Getter
	private Color maxColor;
	@Getter
	private boolean highlightTaskConflicts;
	@Getter
	private Color taskConflictColor;
	@Inject
	private ClientThread clientThread;
	@Inject
	private ItemManager itemManager;
	@Inject
	public TracerConfig tracerConfig;
	@Inject
	private EventBus eventBus;
	@Inject
	@Named("developerMode")
	public boolean developerMode;
	private int[] varPlayers;
	private PortTasksPluginPanel pluginPanel;
	private NavigationButton navigationButton;
	private Item[] previousInventory;
	private static final String PLUGIN_NAME = "Port Tasks";
	private static final String ICON_FILE = "icon.png";
	public static final String CONFIG_GROUP = "porttasks";
	private static final String CONFIG_KEY = "porttaskslots";
	private static final String CONFIG_KEY_TAGS = "task_tags";
	private static final String CONFIG_KEY_TASKS_COMPLETED = "tasks_completed";
	private static final String CONFIG_KEY_LAST_TASK_COMPLETED = "last_task_completed";

	private static final String MARK = "Mark task";
	private static final String UNMARK = "Unmark task";
	@Getter
	@Setter
	public PortPaths developerPathSelected;

	@Override
	protected void startUp()
	{
		log.info("Starting plugin Port Tasks");

		clientThread.invokeLater(() ->
		{
			if (client.getGameState().getState() < GameState.LOGIN_SCREEN.getState())
			{
				return false;
			}

			CourierTaskData.loadFromCache(client);
			return true;
		});

		pluginPanel = new PortTasksPluginPanel(this, clientThread, itemManager, client, config);

		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), ICON_FILE);
		navigationButton = NavigationButton.builder()
				.tooltip(PLUGIN_NAME)
				.icon(icon)
				.priority(5)
				.panel(pluginPanel)
				.build();

		clientToolbar.addNavigation(navigationButton);
		registerOverlays();
		pluginPanel.rebuild();
		eventBus.register(tracerConfig);

		loadWidgetTags();
		overlayManager.add(taskHighlight);

		migrateConfiguration();
		tracerConfig.loadConfigs(config);
		highlightGangplanks = config.highlightGangplanks();
		highlightGangplanksColor = config.highlightGangplanksColor();
		highlightCargoHolds = config.highlightCargoHolds();
		highlightCargoHoldsColor = config.highlightCargoHoldsColor();
		highlightNoticeboards = config.highlightNoticeboards();
		highlightNoticeboardsColor = config.highlightNoticeboardsColor();
		highlightHelmMissingCargo = config.highlightHelmMissingCargo();
		taskHeightOffset = config.enableHeightOffset();
		pathDrawDistance = config.pathDrawDistance();
		noticeBoardHideOpactity = mapOpacity(config.noticeBoardHideOpacity());
		noticeBoardHideIncompletable = config.noticeBoardHideIncompletable();
		noticeBoardHideBounty = config.noticeBoardHideBounty();
		noticeBoardHideCourier = config.noticeBoardHideCourier();
		noticeBoardHideUntagged = config.noticeBoardHideUntagged();
		minColor = config.minColor();
		maxColor = config.maxColor();
		highlightTaskConflicts = config.highlightTaskConflicts();
		taskConflictColor = config.taskConflictColor();
	}

	@Override
	protected void shutDown()
	{
		log.info("Stopping Port Tasks");
		clientToolbar.removeNavigation(navigationButton);
		pluginPanel = null;
		navigationButton = null;
		gangplanks.clear();
		noticeboards.clear();
		ledgers.clear();
		helms.clear();
		cargoHolds.clear();

		eventBus.unregister(tracerConfig);

		overlayManager.remove(sailingHelperWorldOverlay);
		overlayManager.remove(sailingHelperMapOverlay);
		overlayManager.remove(portTasksLedgerOverlay);
		overlayManager.remove(portTaskModelRenderer);
		overlayManager.remove(portTaskCargoOverlay);
		overlayManager.remove(noticeBoardTooltip);
		overlayManager.remove(taskHighlight);
	}

	@SuppressWarnings("unused")
	@Subscribe
	private void onConfigChanged(final ConfigChanged event)
	{
		if (!event.getGroup().equals(PortTasksConfig.CONFIG_GROUP))
			return;
		switch (event.getKey())
		{
			case "drawOverlay":
				overlayManager.remove(sailingHelperWorldOverlay);
				overlayManager.remove(sailingHelperMapOverlay);
				overlayManager.remove(portTasksLedgerOverlay);
				registerOverlays();
				return;
			case "noticeBoardTooltip":
				if (event.getNewValue().contains("true"))
				{
					overlayManager.add(noticeBoardTooltip);
				}
				if (event.getNewValue().contains("false"))
				{
					overlayManager.remove(noticeBoardTooltip);
				}
				return;
			case "highlightGangplanks":
				highlightGangplanks = config.highlightGangplanks();
				return;
			case "highlightGangplanksColor":
				highlightGangplanksColor = config.highlightGangplanksColor();
				return;
			case "highlightNoticeboards":
				highlightNoticeboards = config.highlightNoticeboards();
				return;
			case "highlightNoticeboardsColor":
				highlightNoticeboardsColor = config.highlightNoticeboardsColor();
				return;
			case "highlightHelmMissingCargo":
				highlightHelmMissingCargo = config.highlightHelmMissingCargo();
				return;
			case "highlightCargoHolds":
				highlightCargoHolds = config.highlightCargoHolds();
				return;
			case "highlightCargoHoldsColor":
				highlightCargoHoldsColor = config.highlightCargoHoldsColor();
				return;
			case "enableTracer":
				tracerConfig.setTracerEnabled(config.enableTracer());
				return;
			case "tracerSpeed":
				tracerConfig.setTracerSpeed(config.tracerSpeed());
				return;
			case "tracerIntensity":
				tracerConfig.setTracerIntensity(1f - (config.tracerIntensity() / 100f));
				return;
			case "pathOffset":
				taskHeightOffset = config.enableHeightOffset();
				return;
			case "pathDrawDistance":
				pathDrawDistance = config.pathDrawDistance();
				return;
			case "noticeBoardHideOpacity":
				noticeBoardHideOpactity = mapOpacity(config.noticeBoardHideOpacity());
				return;
			case "noticeBoardHideIncompletable":
				noticeBoardHideIncompletable = config.noticeBoardHideIncompletable();
				return;
			case "noticeBoardHideBounty":
				noticeBoardHideBounty = config.noticeBoardHideBounty();
				return;
			case "noticeBoardHideCourier":
				noticeBoardHideCourier = config.noticeBoardHideCourier();
				return;
			case "noticeBoardHideUntagged":
				noticeBoardHideUntagged = config.noticeBoardHideUntagged();
				return;
			case "minColor":
				minColor = config.minColor();
				return;
			case "maxColor":
				maxColor = config.maxColor();
				return;
			case "highlightTaskConflicts":
				highlightTaskConflicts = config.highlightTaskConflicts();
				return;
			case "taskConflictColor":
				taskConflictColor = config.taskConflictColor();
				return;
			case "noticeBoardState":
				configManager.setConfiguration(CONFIG_GROUP, CONFIG_KEY_TASKS_COMPLETED, config.noticeBoardState());
				configManager.setConfiguration(CONFIG_GROUP, CONFIG_KEY_LAST_TASK_COMPLETED, Instant.now().getEpochSecond());
				return;
		}
	}

	@SuppressWarnings("unused")
	@Subscribe
	private void onVarbitChanged(final VarbitChanged event)
	{
		final int varbitId = event.getVarbitId();
		if (PortTaskTrigger.contains(varbitId))
		{
			PortTaskTrigger varbit = PortTaskTrigger.fromId(event.getVarbitId());
			int value = client.getVarbitValue(varbit.getId());
			handlePortTaskTrigger(varbit, value);
		}
		else if (varbitId == VarbitID.SAILING_BOAT_FACILITY_LOCKEDIN)
		{
			lockedIn = event.getValue() != 0;
		}
	}

	@SuppressWarnings("unused")
	@Subscribe
	private void onGameObjectSpawned(final GameObjectSpawned event)
	{
		final GameObject gameObject = event.getGameObject();
		final int id = gameObject.getId();

		if (id == ObjectID.SAILING_GANGPLANK_PROXY || PortLocation.isGangplank(id))
		{
			gangplanks.add(gameObject);
		}
		else if (PortLocation.isNoticeboard(id))
		{
			noticeboards.add(gameObject);
		}
		else if (PortLocation.isLedger(id))
		{
			ledgers.add(gameObject);
		}
		else if (isInHelmRange(id))
		{
			helms.add(gameObject);
		}
		else if (isInCargoHoldRange(id))
		{
			cargoHolds.add(gameObject);
		}
	}

	@SuppressWarnings("unused")
	@Subscribe
	public void onGameObjectDespawned(final GameObjectDespawned event)
	{
		final GameObject gameObject = event.getGameObject();
		final int id = gameObject.getId();
		final int worldViewId = gameObject.getWorldView().getId();

		if (id == ObjectID.SAILING_GANGPLANK_PROXY || PortLocation.isGangplank(id))
		{
			gangplanks.remove(gameObject);
		}
		else if (PortLocation.isNoticeboard(id))
		{
			noticeboards.remove(gameObject);
		}
		else if (PortLocation.isLedger(id))
		{
			ledgers.remove(gameObject);
		}
		else if (isInCargoHoldRange(id))
		{
			cargoHolds.remove(gameObject);
		}
		else if (isInHelmRange(id))
		{
			helms.remove(gameObject);
		}
	}

	@SuppressWarnings("unused")
	@Subscribe
	public void onWorldViewUnloaded(WorldViewUnloaded event)
	{
		helms.removeIf(o -> o.getWorldView() == event.getWorldView());
		cargoHolds.removeIf(o -> o.getWorldView() == event.getWorldView());
	}

	@SuppressWarnings("unused")
	@Subscribe
	public void onGameStateChanged(final GameStateChanged event)
	{
		switch (event.getGameState())
		{
			case HOPPING:
			case LOADING:
			case LOGGING_IN:
				gangplanks.clear();
				noticeboards.clear();
				ledgers.clear();
				break;
		}
	}
	@Subscribe
	@SuppressWarnings("unused")
	public void onItemContainerChanged(ItemContainerChanged event)
	{
		if (bountyTasks.size() > 0)
		{
			if (event.getContainerId() != InventoryID.INV)
			{
				return;
			}

			ItemContainer inv = event.getItemContainer();
			Item[] current = inv.getItems();
			if (previousInventory == null)
			{
				previousInventory = Arrays.copyOf(current, current.length);
				for (BountyTask task : bountyTasks)
				{
					int itemId = task.getData().itemId;
					int count = getCount(current, itemId);
					task.setItemsCollected(Math.max(0, count));
					pluginPanel.updateBountyPanel(task);
				}
				return;
			}

			for (BountyTask task : bountyTasks)
			{
				int itemId = task.getData().itemId;
				int before = getCount(previousInventory, itemId);
				int after = getCount(current, itemId);
				if (after != before)
				{
					int newValue = Math.max(0, task.getItemsCollected() + (after - before));
					task.setItemsCollected(newValue);
					pluginPanel.updateBountyPanel(task);
				}
			}

			previousInventory = Arrays.copyOf(current, current.length);
		}
	}

	@SuppressWarnings("unused")
	@Subscribe
	private void onWidgetLoaded(final WidgetLoaded event)
	{
		if (event.getGroupId() != InterfaceID.PORT_TASK_BOARD)
		{
			return;
		}
		offeredTasks.clear();
		clientThread.invokeLater(this::scanPortTaskBoard);
	}

	@SuppressWarnings("unused")
	@Subscribe
	private void onMenuEntryAdded(final MenuEntryAdded event)
	{
		if (event.getType() != MenuAction.CC_OP.getId() || !client.isKeyPressed(KeyCode.KC_SHIFT))
		{
			return;
		}
		MenuEntry baseEntry = event.getMenuEntry();
		Widget widget = baseEntry.getWidget();
		if (widget == null)
		{
			return;
		}
		if (widget.getId() != InterfaceID.PortTaskBoard.CONTAINER)
		{
			return;
		}
		Integer dbrow = getDbrowFromWidget(widget);
		if (dbrow == null)
		{
			return;
		}
		WidgetTag existing = getTagForDbrow(dbrow);

		client.createMenuEntry(-1)
			.setOption(existing == null ? MARK : UNMARK)
			.setTarget(event.getTarget())
			.setParam0(event.getActionParam0())
			.setParam1(event.getActionParam1())
			.setIdentifier(event.getIdentifier())
			.setType(MenuAction.RUNELITE_WIDGET)
			.onClick(this::markTask);

		if (existing != null)
		{
			createTaskColorMenu(baseEntry.getTarget(), widget, existing);
		}
	}

	@SuppressWarnings("unused")
	@Subscribe
	private void onStatChanged(final StatChanged event)
	{
		if (event.getSkill() != Skill.SAILING)
		{
			return;
		}
		final int sailingLevel = client.getRealSkillLevel(Skill.SAILING);
		if (sailingLevel != this.sailingLevel)
		{
			this.sailingLevel = sailingLevel;
		}
	}

	@SuppressWarnings("unused")
	@Subscribe
	private void onChatMessage(final ChatMessage event)
	{
		if (event.getType() != ChatMessageType.SPAM && event.getType() != ChatMessageType.GAMEMESSAGE)
		{
			return;
		}

		if (event.getMessage().contains("You have finished the "))
		{
			handleTaskCompleted();
			return;
		}
	}

	private void handleTaskCompleted()
	{
		String lastStr = configManager.getConfiguration(CONFIG_GROUP, CONFIG_KEY_LAST_TASK_COMPLETED);
		String countStr = configManager.getConfiguration(CONFIG_GROUP, CONFIG_KEY_TASKS_COMPLETED);

		long lastTaskCompleted = lastStr != null ? Long.parseLong(lastStr) : 0L;
		int tasksCompleted = countStr != null ? Integer.parseInt(countStr) : 0;

		long now = Instant.now().getEpochSecond();
		long midnightTodayUtc = LocalDate.now(ZoneOffset.UTC).atStartOfDay().toEpochSecond(ZoneOffset.UTC);
		if (lastTaskCompleted < midnightTodayUtc)
		{
			tasksCompleted = 1;
		}
		else
		{
			tasksCompleted = (tasksCompleted + 1) % 8;
		}
		configManager.setConfiguration(CONFIG_GROUP, CONFIG_KEY_TASKS_COMPLETED, tasksCompleted);
		configManager.setConfiguration(CONFIG_GROUP, CONFIG_KEY_LAST_TASK_COMPLETED, now);
		if (config.noticeBoardResetTracker())
		{
			final String message;
			if (tasksCompleted == 0)
			{
				message = "Notice boards have reset.";
			}
			else
			{
				message = String.format(
					"You have completed %d task%s with %d more task%s until board reset.",
					tasksCompleted,
					tasksCompleted == 1 ? "" : "s",
					8 - tasksCompleted,
					(8 - tasksCompleted) == 1 ? "" : "s"
				);
			}
			sendMessage(message);
		}
	}

	private void sendMessage(String message)
	{
		chatMessageManager.queue(QueuedMessage.builder()
			.type(ChatMessageType.GAMEMESSAGE)
				.runeLiteFormattedMessage(new ChatMessageBuilder().append(message).build())
			.build());
	}

	private void markTask(MenuEntry entry)
	{
		Widget taskToTag = entry.getWidget();
		Integer dbrow = getDbrowFromWidget(taskToTag);
		if (dbrow == null)
		{
			return;
		}

		WidgetTag existing = getTagForDbrow(dbrow);

		if (existing != null)
		{
			widgetTags.remove(existing);
		}
		else
		{
			WidgetTag tag = new WidgetTag(dbrow, Color.YELLOW);
			widgetTags.add(tag);
		}
		saveWidgetTags();
	}

	private void createTaskColorMenu(String target, Widget widget, WidgetTag tag)
	{
		List<Color> colors = getUsedTagColors();

		for (Color defaultColor : new Color[]{
			Color.YELLOW, Color.RED, Color.GREEN, Color.ORANGE, Color.BLUE
		})
		{
			if (colors.size() < 5 && ! colors.contains(defaultColor))
			{
				colors.add(defaultColor);
			}
		}
		MenuEntry parent = client.createMenuEntry(-2)
			.setOption("Task color")
			.setTarget(target)
			.setType(MenuAction.RUNELITE);

		Menu subMenu = parent.createSubMenu();

		for (final Color c : colors)
		{
			subMenu.createMenuEntry(0)
				.setOption(ColorUtil.prependColorTag("Set color", c))
				.setType(MenuAction.RUNELITE)
				.onClick(
					e -> clientThread.invokeLater(() -> updateWidgetTagColor(tag.getDbrow(), c))
				);
		}

		subMenu.createMenuEntry(0)
			.setOption("Pick color")
			.setType(MenuAction.RUNELITE)
			.onClick(e -> SwingUtilities.invokeLater(() ->
			{
				Color initial = MoreObjects.firstNonNull(tag.getColor(), Color.YELLOW);
				RuneliteColorPicker colorPicker = colorPickerManager.create(
					client,
					initial,
					"Task tag color",
					false
				);

				colorPicker.setOnClose(c ->
					clientThread.invokeLater(() -> updateWidgetTagColor(tag.getDbrow(), c))
				);

				colorPicker.setVisible(true);
			}));
	}

	private WidgetTag getTagForDbrow(int dbrow)
	{
		return widgetTags.stream()
			.filter(t -> t.getDbrow() == dbrow)
			.findFirst()
			.orElse(null);
	}

	private void updateWidgetTagColor(int dbrow, Color color)
	{
		WidgetTag tag = getTagForDbrow(dbrow);
		if (tag != null)
		{
			tag.setColor(color);
		}
		else
		{
			tag = new WidgetTag(dbrow, color);
			widgetTags.add(tag);
		}
		saveWidgetTags();
	}

	private List<Color> getUsedTagColors()
	{
		return widgetTags.stream()
			.map(WidgetTag::getColor)
			.filter(Objects::nonNull)
			.distinct()
			.collect(Collectors.toList());
	}

	private void saveWidgetTags()
	{
		if (widgetTags.isEmpty())
		{
			configManager.unsetConfiguration(CONFIG_GROUP, CONFIG_KEY_TAGS);
		}
		else
		{
			final String json = gson.toJson(widgetTags);
			configManager.setConfiguration(CONFIG_GROUP, CONFIG_KEY_TAGS, json);
		}
	}

	private void loadWidgetTags()
	{
		final String json = configManager.getConfiguration(CONFIG_GROUP, CONFIG_KEY_TAGS);
		if (json == null || json.isEmpty())
		{
			return;
		}

		//CHECKSTYLE:OFF
		Type type = new TypeToken<Set<WidgetTag>>() {}.getType();
		//CHECKSTYLE:ON

		try
		{
			Set<WidgetTag> loaded = gson.fromJson(json, type);
			if (loaded != null)
			{
				widgetTags.clear();
				widgetTags.addAll(loaded);
			}
		}
		catch (Exception e)
		{
			log.info("Failed to load widget tags");
		}
	}

	private void scanPortTaskBoard()
	{
		final Widget widget = client.getWidget(InterfaceID.PortTaskBoard.CONTAINER);
		if (widget == null)
		{
			return;
		}
		Widget[] children = widget.getDynamicChildren();
		if (children == null)
		{
			return;
		}

		for (int i = 0; i < children.length; i++)
		{
			Widget child = children[i];
			Integer dbrow = getDbrowFromWidget(child);
			if (dbrow == null)
			{
				continue;
			}
			int levelRequired = -1;
			if (i + 2 < children.length)
			{
				Widget lvlWidget = children[i + 2];
				String text = lvlWidget.getText();
				if (text != null && !text.isEmpty())
				{
					try
					{
						levelRequired = Integer.parseInt(text);
					}
					catch (NumberFormatException ex)
					{
						log.warn("Port-Tasks: Could not parse level from '{}'", text);
					}
				}
			}
			offeredTasks.put(dbrow, new OfferedTaskData(child, levelRequired));
		}
	}

	public Integer getDbrowFromWidget(Widget widget)
	{
		if (widget == null)
		{
			return null;
		}
		Object[] ops = widget.getOnOpListener();
		if (ops == null || ops.length < 4)
		{
			return null;
		}
		return (Integer) ops[3];

	}

	private boolean isInHelmRange(int id)
	{
		return id >= ObjectID.SAILING_BOAT_STEERING_KANDARIN_1X3_WOOD && id <= ObjectID.SAILING_INTRO_HELM_NOT_IN_USE;
	}

	private boolean isInCargoHoldRange(int id)
	{
		// TODO: Refactor to a set since this contains some removed Christmas 2025 event objects
		return (id >= ObjectID.SAILING_BOAT_CARGO_HOLD_REGULAR_RAFT && id <= ObjectID.SAILING_BOAT_CARGO_HOLD_ROSEWOOD_LARGE) ||
			(id >= ObjectID.SAILING_BOAT_CARGO_HOLD_TEAK_2X5_CARGO && id <= ObjectID.SAILING_BOAT_CARGO_HOLD_ROSEWOOD_LARGE_CARGO) ||
			(id >= ObjectID.SAILING_BOAT_CARGO_HOLD_REGULAR_RAFT_NO_CARGO && id <= ObjectID.SAILING_BOAT_CARGO_HOLD_TEAK_2X5_NO_CARGO);
	}

	private void checkInventoryForBountyItems()
	{
		if (bountyTasks.size() > 0)
		{
			ItemContainer inv = client.getItemContainer(InventoryID.INV);
			assert inv != null;
			Item[] current = inv.getItems();
			if (previousInventory == null)
			{
				previousInventory = Arrays.copyOf(current, current.length);
				for (BountyTask task : bountyTasks)
				{
					int itemId = task.getData().itemId;
					int count = getCount(current, itemId);
					task.setItemsCollected(Math.max(0, count));
					pluginPanel.updateBountyPanel(task);
				}
				return;
			}

			for (BountyTask task : bountyTasks)
			{
				int itemId = task.getData().itemId;
				int before = getCount(previousInventory, itemId);
				int after = getCount(current, itemId);
				if (after != before)
				{
					int newValue = Math.max(0, task.getItemsCollected() + (after - before));
					task.setItemsCollected(newValue);
					pluginPanel.updateBountyPanel(task);
				}
				else // satisfies reloading data
				{
					task.setItemsCollected(before);
					pluginPanel.updateBountyPanel(task);
				}
			}
			previousInventory = Arrays.copyOf(current, current.length);
		}
	}

	@SuppressWarnings("unused")
	@Provides
	PortTasksConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(PortTasksConfig.class);
	}

	private void handlePortTaskTrigger(PortTaskTrigger trigger, int value)
	{
		if (!BountyTaskData.isBountyTask(value))
		{
			if (trigger.getType() == PortTaskTrigger.TaskType.ID)
			{
				log.debug("Changed: {} (value {})", trigger, value);
				CourierTaskData data = CourierTaskData.fromId(value);
				if (data != null && value != 0)
				{
					courierTasks.add(new CourierTask(data, trigger.getSlot(), false, 0, true, true, getNavColorForSlot(trigger.getSlot()), 0));
					pluginPanel.rebuild();
				}
			}

			if (trigger.getType() == PortTaskTrigger.TaskType.TAKEN)
			{
				int slot = trigger.getSlot();

				for (CourierTask task : courierTasks)
				{
					if (task.getSlot() == slot)
					{
						task.setCargoTaken(value);
						pluginPanel.rebuild();
						break;
					}
				}
			}

			if (trigger.getType() == PortTaskTrigger.TaskType.DELIVERED)
			{
				int slot = trigger.getSlot();

				for (CourierTask task : courierTasks)
				{
					if (task.getSlot() == slot)
					{
						task.setDelivered(value);
						pluginPanel.rebuild();
						break;
					}
				}
			}
		}
		else
		{
			if (trigger.getType() == PortTaskTrigger.TaskType.ID)
			{
				log.debug("Changed: {} (value {})", trigger, value);
				BountyTaskData data = BountyTaskData.fromId(value);
				if (data != null && value != 0)
				{
					bountyTasks.add(new BountyTask(data, trigger.getSlot(), false, 0, true, true, getNavColorForSlot(trigger.getSlot()), 0));
					pluginPanel.rebuild();
				}
			}
		}

		if (trigger.getType() == PortTaskTrigger.TaskType.ID && value == 0)
		{
			removeTasksForSlot(trigger.getSlot());
			pluginPanel.rebuild();
		}
	}

	private void removeTasksForSlot(int slot)
	{
		courierTasks.removeIf(t -> t.getSlot() == slot);
		bountyTasks.removeIf(t -> t.getSlot() == slot);
	}
	public void readPortDataFromClientVarps()
	{
		assert client.getVarps() != null : "client.getVarps() is null";
		varPlayers = client.getVarps().clone();
		clearTasksForReload();
		for (PortTaskTrigger varbit : PortTaskTrigger.values())
		{
			int value = client.getVarbitValue(varPlayers, varbit.getId());
			handlePortTaskTrigger(varbit, value);
		}
		checkInventoryForBountyItems();
	}
	private void clearTasksForReload()
	{
		courierTasks.clear();
		bountyTasks.clear();
	}
	private void registerOverlays()
	{
		if (config.getDrawOverlay() == PortTasksConfig.Overlay.BOTH || config.getDrawOverlay() == PortTasksConfig.Overlay.MAP)
		{
			overlayManager.add(sailingHelperMapOverlay);
		}

		if (config.getDrawOverlay() == PortTasksConfig.Overlay.BOTH || config.getDrawOverlay() == PortTasksConfig.Overlay.WORLD)
		{
			overlayManager.add(sailingHelperWorldOverlay);
		}
		if (config.noticeBoardTooltip())
		{
			overlayManager.add(noticeBoardTooltip);
		}
		overlayManager.add(portTasksLedgerOverlay);
		overlayManager.add(portTaskModelRenderer);
		overlayManager.add(portTaskCargoOverlay);
	}

	public void saveSlotSettings()
	{
		if (courierTasks == null || courierTasks.isEmpty())
		{
			configManager.unsetConfiguration(CONFIG_GROUP, CONFIG_KEY);
			return;
		}
		String json = gson.toJson(courierTasks);
		configManager.setConfiguration(CONFIG_GROUP, CONFIG_KEY, json);
	}

	private Color getNavColorForSlot(int slot)
	{
		switch (slot)
		{
			case 0: return config.getNavColor();
			case 1: return config.getNavColor2();
			case 2: return config.getNavColor3();
			case 3: return config.getNavColor4();
			case 4: return config.getNavColor5();
			default: return Color.GREEN;
		}
	}
	int getInventoryItemCount(int itemId)
	{
		ItemContainer inv = client.getItemContainer(InventoryID.INV);
		if (inv == null)
		{
			return 0;
		}
		int total = 0;
		for (Item item : inv.getItems())
		{
			if (item.getId() == itemId)
			{
				total += item.getQuantity();
			}
		}
		return total;
	}

	private int getCount(Item[] items, int itemId)
	{
		int amt = 0;
		for (Item item : items)
		{
			if (item.getId() == itemId)
			{
				amt += item.getQuantity();
			}
		}
		return amt;
	}


	private void migrateConfiguration()
	{	// min 5 max 25 <- version 1.4.0 -> min 100 max 250
		if (config.pathDrawDistance() < 100)
		{
			configManager.setConfiguration(
					config.CONFIG_GROUP,
					"pathDrawDistance",
					150
			);
		}
	}

	private int mapOpacity(int configValue)
	{
		return 0 + (configValue - 0) * (255 - 0) / (100 - 0);
	}
}

/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks;

import java.awt.Dimension;
import java.awt.Graphics2D;

import javax.inject.Inject;

import com.nucleon.porttasks.overlay.WorldLines;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;


class PortTasksWorldOverlay extends Overlay
{
	private final Client client;
	private final PortTasksPlugin plugin;
	private final PortTasksConfig config;

	@Inject
	private PortTasksWorldOverlay(Client client, PortTasksPlugin plugin, PortTasksConfig config)
	{
		this.client = client;
		this.plugin = plugin;
		this.config = config;

		setPosition(OverlayPosition.DYNAMIC);
		setPriority(Overlay.PRIORITY_HIGHEST);
		setLayer(OverlayLayer.UNDER_WIDGETS);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		renderOverlayLines(graphics);
		return null;
	}

	private void renderOverlayLines(Graphics2D g)
	{
		for (CourierTask task : plugin.courierTasks)
		{
			if (task.isTracking())
			{
				WorldLines.drawPortTaskLinesOnWorld(g, client, task, plugin.tracerConfig, plugin.isTaskHeightOffset(), plugin.getPathDrawDistance(), plugin.getPathDrawDistance());
			}
		}
	}
}
/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks;


public final class RelativeMove
{
	private final int dx;
	private final int dy;

	public RelativeMove(int dx, int dy)
	{
		this.dx = dx;
		this.dy = dy;
	}

	public int getDx()
	{
		return dx;
	}

	public int getDy()
	{
		return dy;
	}

	@Override
	public String toString()
	{
		return String.format("(%+d, %+d)", dx, dy);
	}

	@Override
	public boolean equals(Object obj)
	{
		if (this == obj) return true;
		if (obj == null || getClass() != obj.getClass()) return false;
		RelativeMove other = (RelativeMove) obj;
		return dx == other.dx && dy == other.dy;
	}

	@Override
	public int hashCode()
	{
		int result = Integer.hashCode(dx);
		result = 31 * result + Integer.hashCode(dy);
		return result;
	}
}

package com.nucleon.porttasks;

public interface Task
{
	int getSlot();
	boolean isTracking();
	void setTracking(boolean tracking);
}

/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks.ui.adapters;

import javax.swing.ImageIcon;
import javax.swing.JLabel;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

import com.nucleon.porttasks.PortTasksPlugin;
import com.nucleon.porttasks.Task;
import com.nucleon.porttasks.ui.TaskPanel;
import net.runelite.client.util.ImageUtil;

public class HidePortTaskSlotOverlay extends MouseAdapter
{
private final JLabel hideMarker;
private final Task task;
private final TaskPanel panel;
private final PortTasksPlugin plugin;
private static final ImageIcon VISIBLE_HOVER_ICON;
private static final ImageIcon INVISIBLE_HOVER_ICON;

static
{
	final BufferedImage visibleImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "visible_icon.png");
	VISIBLE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(visibleImg, -100));

	final BufferedImage invisibleImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "invisible_icon.png");
	INVISIBLE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(invisibleImg, -100));
}

public HidePortTaskSlotOverlay(JLabel hideMarker, Task task, TaskPanel panel, PortTasksPlugin plugin)
{
	this.hideMarker = hideMarker;
	this.task = task;
	this.panel = panel;
	this.plugin = plugin;
}

@Override
public void mousePressed(MouseEvent mouseEvent)
{
	task.setTracking(!task.isTracking());
	panel.updateVisibility();
	plugin.saveSlotSettings();
}

@Override
public void mouseEntered(MouseEvent mouseEvent)
{
	hideMarker.setIcon(task.isTracking() ? VISIBLE_HOVER_ICON : INVISIBLE_HOVER_ICON);
}

@Override
public void mouseExited(MouseEvent mouseEvent)
{
	panel.updateVisibility();
}
}

/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks.ui.adapters;


import javax.swing.ImageIcon;
import javax.swing.JLabel;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

import com.nucleon.porttasks.PortTasksPlugin;

import com.nucleon.porttasks.ui.TaskPanel;
import net.runelite.client.util.ImageUtil;

public class PortTaskSlotOverlayColor extends MouseAdapter
{
private final JLabel portSlotOverlay;
private final TaskPanel panel;
private static final ImageIcon BORDER_COLOR_ICON;
private static final ImageIcon BORDER_COLOR_HOVER_ICON;

static
{
	BufferedImage borderImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "border_color_icon.png");
	BufferedImage borderImgHover = ImageUtil.luminanceOffset(borderImg, -150);

	BORDER_COLOR_ICON = new ImageIcon(borderImg);
	BORDER_COLOR_HOVER_ICON = new ImageIcon(borderImgHover);
}
public PortTaskSlotOverlayColor(JLabel prayerMarkerColorLabel, TaskPanel panel)
{
	this.portSlotOverlay = prayerMarkerColorLabel;
	this.panel = panel;
}


@Override
public void mousePressed(MouseEvent mouseEvent)
{
	panel.openPortTaskColorPicker();
}

@Override
public void mouseEntered(MouseEvent mouseEvent)
{
	portSlotOverlay.setIcon(BORDER_COLOR_HOVER_ICON);
}

@Override
public void mouseExited(MouseEvent mouseEvent)
{
	portSlotOverlay.setIcon(BORDER_COLOR_ICON);
}
}

/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks.ui.adapters;

import com.nucleon.porttasks.PortTasksPlugin;

import net.runelite.client.callback.ClientThread;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

public class ReloadPortTasks extends MouseAdapter
{
	private static final BufferedImage RELOAD_ICON = ImageUtil.loadImageResource(PortTasksPlugin.class, "reload.png");
	private static final ImageIcon RELOAD = new ImageIcon(RELOAD_ICON);
	private static final ImageIcon ADD_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(RELOAD_ICON, 0.53f));
	private final PortTasksPlugin plugin;
	private final ClientThread clientThread;
	private final JLabel markerAdd;
	private final Runnable onClick;

	public ReloadPortTasks(JLabel markerAdd, PortTasksPlugin plugin, ClientThread clientThread, Runnable onClick)
	{
		this.markerAdd = markerAdd;
		this.plugin = plugin;
		this.clientThread = clientThread;
		this.onClick = onClick;
	}

	@Override
	public void mousePressed(MouseEvent e)
	{
		clientThread.invoke(plugin::readPortDataFromClientVarps);
		onClick.run();
	}

	@Override
	public void mouseEntered(MouseEvent e)
	{
		markerAdd.setIcon(ADD_HOVER_ICON);
	}

	@Override
	public void mouseExited(MouseEvent e)
	{
		markerAdd.setIcon(RELOAD);
	}
}

/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks.ui;

import com.nucleon.porttasks.BountyTask;
import com.nucleon.porttasks.ui.adapters.HidePortTaskSlotOverlay;
import com.nucleon.porttasks.ui.adapters.PortTaskSlotOverlayColor;
import com.nucleon.porttasks.PortTasksPlugin;
import com.nucleon.porttasks.enums.TaskReward;

import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.api.NPCComposition;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.colorpicker.RuneliteColorPicker;
import net.runelite.client.util.ImageUtil;

import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;
import javax.swing.border.Border;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.image.BufferedImage;

public class BountyTaskPanel extends JPanel implements TaskPanel
{
public final PortTasksPlugin plugin;
private final ClientThread clientThread;
private final ItemManager itemManager;
private final Client client;
private static final Border NAME_BOTTOM_BORDER = new CompoundBorder(
		BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.DARK_GRAY_COLOR),
		BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_COLOR));

private static final ImageIcon
		BORDER_COLOR_ICON,
		VISIBLE_ICON,
		INVISIBLE_ICON,
		ANCHOR,
		BOAT,
		DESTINATION,
		NOTICE,
		PACKAGE,
		LIGHTBULB;

public final JLabel
		PortTaskOverlayColor = new JLabel(),
		hidePortTaskSlotOverlay = new JLabel(),
		cargoRemainingText = new JLabel(),
		npcLabel = new JLabel(),
		destinationLabel = new JLabel(),
		noticeLabel = new JLabel(),
		xpLabel = new JLabel(),
		anchorLabel = new JLabel(),
		boatLabel = new JLabel(),
		taskName = new JLabel();

private final JLabel
		save   = new JLabel("Save"),
		cancel = new JLabel("Cancel"),
		rename = new JLabel("Rename");

public final JPanel PortTaskSlotContainer = new JPanel(new BorderLayout());
private final BountyTask bountyTask;

static
{
	final BufferedImage borderImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "border_color_icon.png");
	BORDER_COLOR_ICON = new ImageIcon(ImageUtil.alphaOffset(borderImg, -100));

	final BufferedImage visibleImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "visible_icon.png");
	VISIBLE_ICON = new ImageIcon(visibleImg);

	final BufferedImage invisibleImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "invisible_icon.png");
	INVISIBLE_ICON = new ImageIcon(invisibleImg);

	final BufferedImage boatImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "boat.png");
	BOAT = new ImageIcon(boatImg);

	final BufferedImage anchorImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "anchor.png");
	ANCHOR = new ImageIcon(anchorImg);

	final BufferedImage destImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "destination.png");
	DESTINATION = new ImageIcon(ImageUtil.alphaOffset(destImg, -100));

	final BufferedImage noticeImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "notice.png");
	NOTICE = new ImageIcon(ImageUtil.alphaOffset(noticeImg, -100));

	final BufferedImage cargoImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "package.png");
	PACKAGE = new ImageIcon(ImageUtil.alphaOffset(cargoImg, -100));

	final BufferedImage lightbulbImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "lightbulb.png");
	LIGHTBULB = new ImageIcon(ImageUtil.alphaOffset(lightbulbImg, -100));
}

public BountyTaskPanel(PortTasksPlugin plugin, BountyTask bountyTask, ClientThread clientThread, ItemManager itemManager, Client client, int slot)
{
	this.plugin = plugin;
	this.bountyTask = bountyTask;
	this.clientThread = clientThread;
	this.itemManager = itemManager;
	this.client = client;
	setLayout(new BorderLayout());
	setBackground(ColorScheme.DARKER_GRAY_COLOR);
	setBorder(new EmptyBorder(0, 0, 0, 0));

	JPanel nameWrapper = new JPanel(new BorderLayout());
	nameWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
	nameWrapper.setBorder(NAME_BOTTOM_BORDER);

	JPanel noticeWrapper = new JPanel(new BorderLayout());
	noticeWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);

	JPanel cargoWrapper = new JPanel(new BorderLayout());
	cargoWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);

	JPanel destinationWrapper = new JPanel(new BorderLayout());
	destinationWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);

	JPanel xpWrapper = new JPanel(new BorderLayout());
	xpWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);

	JPanel hideOverlay = new JPanel(new FlowLayout(FlowLayout.RIGHT, 3, 3));
	hideOverlay.setBackground(ColorScheme.DARKER_GRAY_COLOR);

	PortTaskSlotContainer.setBorder(new EmptyBorder(0, 0, 0, 0));
	PortTaskSlotContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

	JPanel PortTaskActionsLeftSide = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
	PortTaskActionsLeftSide.setBackground(ColorScheme.DARKER_GRAY_COLOR);

	JPanel PortTaskInformationCenter = new JPanel();
	PortTaskInformationCenter.setBackground(ColorScheme.DARKER_GRAY_COLOR);


	PortTaskOverlayColor.setToolTipText("edit Bounty Task color");
	PortTaskOverlayColor.setForeground(bountyTask.getOverlayColor() == null ? Color.red : bountyTask.getOverlayColor());
	PortTaskOverlayColor.addMouseListener(new PortTaskSlotOverlayColor(PortTaskOverlayColor, this));
	PortTaskActionsLeftSide.add(PortTaskOverlayColor);

	int itemsLooted = bountyTask.getItemsCollected();
	int lootRequirement = bountyTask.getData().itemQuantity;

	cargoRemainingText.setText("Items: " + itemsLooted + "/" + lootRequirement);
	cargoRemainingText.setToolTipText("Remaining items");

	if (itemsLooted < lootRequirement)
	{
		cargoRemainingText.setForeground(Color.RED);
	}

	if (itemsLooted == lootRequirement)
	{
		cargoRemainingText.setText("Items: " + itemsLooted + "/" + lootRequirement);
	}

	PortTaskInformationCenter.add(cargoRemainingText);

	hidePortTaskSlotOverlay.setToolTipText((bountyTask.isTracking() ? "Hide" : "Show") + " Bounty Task");
	hidePortTaskSlotOverlay.addMouseListener(new HidePortTaskSlotOverlay(hidePortTaskSlotOverlay, bountyTask, this, plugin));

	hideOverlay.add(hidePortTaskSlotOverlay);
	taskName.setText(bountyTask.getData().taskName);
	taskName.setHorizontalAlignment(SwingConstants.CENTER);


	nameWrapper.add(taskName, BorderLayout.CENTER);
	nameWrapper.add(hideOverlay, BorderLayout.EAST);
	nameWrapper.add(anchorLabel, BorderLayout.WEST);

	JPanel portSlotWrapper = new JPanel();
	portSlotWrapper.setLayout(new BoxLayout(portSlotWrapper, BoxLayout.Y_AXIS));
	portSlotWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
	portSlotWrapper.add(nameWrapper);
	portSlotWrapper.add(PortTaskSlotContainer);

	noticeWrapper.add(noticeLabel, BorderLayout.WEST);
	noticeWrapper.setBorder(NAME_BOTTOM_BORDER);
	cargoWrapper.add(npcLabel, BorderLayout.WEST);
	cargoWrapper.setBorder(NAME_BOTTOM_BORDER);
	destinationWrapper.add(destinationLabel, BorderLayout.WEST);
	destinationWrapper.setBorder(NAME_BOTTOM_BORDER);
	xpWrapper.add(xpLabel, BorderLayout.WEST);
	xpWrapper.setBorder(NAME_BOTTOM_BORDER);

	portSlotWrapper.add(noticeWrapper);
	portSlotWrapper.add(cargoWrapper);
	portSlotWrapper.add(destinationWrapper);
	portSlotWrapper.add(xpWrapper);

	PortTaskSlotContainer.setLayout(new BorderLayout());
	PortTaskSlotContainer.add(PortTaskActionsLeftSide, BorderLayout.WEST);
	PortTaskSlotContainer.add(PortTaskInformationCenter, BorderLayout.CENTER);
	PortTaskSlotContainer.setBorder(NAME_BOTTOM_BORDER);

	add(portSlotWrapper);

	updateVisibility();
	updateColorIndicators();
	updateImages(bountyTask);

}

	public void openPortTaskColorPicker()
	{
		Color color = bountyTask.getOverlayColor() == null ? Color.red : bountyTask.getOverlayColor();
		RuneliteColorPicker colourPicker = getColorPicker(color);
		colourPicker.setOnColorChange(c ->
		{
			bountyTask.setOverlayColor(c);
			PortTaskOverlayColor.setBorder(new MatteBorder(0, 0, 3, 0, bountyTask.getOverlayColor()));
			PortTaskOverlayColor.setIcon(BORDER_COLOR_ICON);
			updateColorIndicators();
		});
		colourPicker.setVisible(true);
	}

	private RuneliteColorPicker getColorPicker(Color color)
	{
		RuneliteColorPicker colorPicker = plugin.getColorPickerManager().create(
				SwingUtilities.windowForComponent(this),
				color,
				bountyTask.getData().taskName + " - overlay color",
				false);
		colorPicker.setLocationRelativeTo(this);
		colorPicker.setOnClose(c -> plugin.saveSlotSettings());
		return colorPicker;
	}

	private void updateColorIndicators()
	{
		PortTaskOverlayColor.setBorder(new MatteBorder(0, 0, 3, 0, bountyTask.getOverlayColor()));
		PortTaskOverlayColor.setIcon(BORDER_COLOR_ICON);
}

	public void updateVisibility()
	{
		hidePortTaskSlotOverlay.setIcon(bountyTask.isTracking() ? VISIBLE_ICON : INVISIBLE_ICON);
	}

	private void updateImages(BountyTask bountyTask)
	{
		npcLabel.setIcon(PACKAGE);
		destinationLabel.setIcon(DESTINATION);
		noticeLabel.setIcon(NOTICE);
		anchorLabel.setIcon(ANCHOR);
		boatLabel.setIcon(BOAT);
		destinationLabel.setText("overlays coming soon!");
		npcLabel.setToolTipText("Bounty Item");
		destinationLabel.setToolTipText("Bounty Location");
		noticeLabel.setToolTipText("Bounty Target");

		String xp = TaskReward.getRewardForTask(bountyTask.getData().getDbrow());
		xpLabel.setIcon(LIGHTBULB);
		xpLabel.setText(xp + " XP");
		xpLabel.setToolTipText("Bounty XP reward");

		clientThread.invokeLater(() ->
		{
			final ItemComposition itemComposition = itemManager.getItemComposition(bountyTask.getData().itemId);
			final NPCComposition npcComposition = client.getNpcDefinition(bountyTask.getData().npcId);
			npcLabel.setText(bountyTask.getData().itemQuantity + "x " + itemComposition.getMembersName());
			noticeLabel.setText(npcComposition.getName());
		});
	}

	public void refresh()
	{
		int itemsLooted = bountyTask.getItemsCollected();
		int lootRequirement = bountyTask.getData().itemQuantity;

		cargoRemainingText.setText("Items: " + itemsLooted + "/" + lootRequirement);
		cargoRemainingText.setToolTipText("Remaining items");

		if (itemsLooted < lootRequirement)
		{
			cargoRemainingText.setForeground(Color.RED);
		}

		if (itemsLooted == lootRequirement)
		{
			cargoRemainingText.setText("Items: " + itemsLooted + "/" + lootRequirement);
		}
		revalidate();
		repaint();
	}
}

/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks.ui;

import com.nucleon.porttasks.CourierTask;
import com.nucleon.porttasks.ui.adapters.HidePortTaskSlotOverlay;
import com.nucleon.porttasks.ui.adapters.PortTaskSlotOverlayColor;
import com.nucleon.porttasks.PortTasksPlugin;
import com.nucleon.porttasks.enums.TaskReward;

import net.runelite.api.ItemComposition;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.colorpicker.RuneliteColorPicker;
import net.runelite.client.util.ImageUtil;

import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;
import javax.swing.border.Border;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.image.BufferedImage;

public class CourierTaskPanel extends JPanel implements TaskPanel
{
	public final PortTasksPlugin plugin;
	private final ClientThread clientThread;
	private final ItemManager itemManager;

	private static final Border NAME_BOTTOM_BORDER = new CompoundBorder(
			BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.DARK_GRAY_COLOR),
			BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_COLOR));

	private static final ImageIcon
			BORDER_COLOR_ICON,
			VISIBLE_ICON,
			INVISIBLE_ICON,
			ANCHOR,
			BOAT,
			DESTINATION,
			NOTICE,
			PACKAGE,
			LIGHTBULB;

	public final JLabel
			PortTaskOverlayColor = new JLabel(),
			hidePortTaskSlotOverlay = new JLabel(),
			cargoRemainingText = new JLabel(),
			cargoLabel = new JLabel(),
			destinationLabel = new JLabel(),
			noticeLabel = new JLabel(),
			xpLabel = new JLabel(),
			anchorLabel = new JLabel(),
			boatLabel = new JLabel(),
			taskName = new JLabel();

	private final JLabel
			save   = new JLabel("Save"),
			cancel = new JLabel("Cancel"),
			rename = new JLabel("Rename");

	public final JPanel PortTaskSlotContainer = new JPanel(new BorderLayout());
	private final CourierTask courierTask;

	static
	{
		final BufferedImage borderImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "border_color_icon.png");
		BORDER_COLOR_ICON = new ImageIcon(ImageUtil.alphaOffset(borderImg, -100));

		final BufferedImage visibleImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "visible_icon.png");
		VISIBLE_ICON = new ImageIcon(visibleImg);

		final BufferedImage invisibleImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "invisible_icon.png");
		INVISIBLE_ICON = new ImageIcon(invisibleImg);

		final BufferedImage boatImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "boat.png");
		BOAT = new ImageIcon(boatImg);

		final BufferedImage anchorImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "anchor.png");
		ANCHOR = new ImageIcon(anchorImg);

		final BufferedImage destImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "destination.png");
		DESTINATION = new ImageIcon(ImageUtil.alphaOffset(destImg, -100));

		final BufferedImage noticeImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "notice.png");
		NOTICE = new ImageIcon(ImageUtil.alphaOffset(noticeImg, -100));

		final BufferedImage cargoImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "package.png");
		PACKAGE = new ImageIcon(ImageUtil.alphaOffset(cargoImg, -100));

		final BufferedImage lightbulbImg = ImageUtil.loadImageResource(PortTasksPlugin.class, "lightbulb.png");
		LIGHTBULB = new ImageIcon(ImageUtil.alphaOffset(lightbulbImg, -100));
	}

	public CourierTaskPanel(PortTasksPlugin plugin, CourierTask courierTask, ClientThread clientThread, ItemManager itemManager, int slot)
	{
		this.plugin = plugin;
		this.courierTask = courierTask;
		this.clientThread = clientThread;
		this.itemManager = itemManager;
		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARKER_GRAY_COLOR);
		setBorder(new EmptyBorder(0, 0, 0, 0));

		JPanel nameWrapper = new JPanel(new BorderLayout());
		nameWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		nameWrapper.setBorder(NAME_BOTTOM_BORDER);

		JPanel noticeWrapper = new JPanel(new BorderLayout());
		noticeWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel cargoWrapper = new JPanel(new BorderLayout());
		cargoWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel destinationWrapper = new JPanel(new BorderLayout());
		destinationWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel xpWrapper = new JPanel(new BorderLayout());
		xpWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel hideOverlay = new JPanel(new FlowLayout(FlowLayout.RIGHT, 3, 3));
		hideOverlay.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		PortTaskSlotContainer.setBorder(new EmptyBorder(0, 0, 0, 0));
		PortTaskSlotContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel PortTaskActionsLeftSide = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
		PortTaskActionsLeftSide.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel PortTaskInformationCenter = new JPanel();
		PortTaskInformationCenter.setBackground(ColorScheme.DARKER_GRAY_COLOR);


		PortTaskOverlayColor.setToolTipText("edit Courier Task color");
		PortTaskOverlayColor.setForeground(courierTask.getOverlayColor() == null ? Color.red : courierTask.getOverlayColor());
		PortTaskOverlayColor.addMouseListener(new PortTaskSlotOverlayColor(PortTaskOverlayColor, this));
		PortTaskActionsLeftSide.add(PortTaskOverlayColor);

		int cargoTaken = courierTask.getCargoTaken();
		int delivered = courierTask.getDelivered();
		int required = courierTask.getData().getCargoAmount();

		cargoRemainingText.setText("Cargo: " + cargoTaken + "/" + required);
		cargoRemainingText.setToolTipText("Remaining cargo");

		if (cargoTaken < required)
		{
			cargoRemainingText.setForeground(Color.RED);
		}

		if (cargoTaken == required)
		{
			cargoRemainingText.setText("Delivered: " + delivered + "/" + required);
		}
		if (delivered == required)
		{
			cargoRemainingText.setText("Claim Rewards!");
		}

		PortTaskInformationCenter.add(cargoRemainingText);

		hidePortTaskSlotOverlay.setToolTipText((courierTask.isTracking() ? "Hide" : "Show") + " Courier Task");
		hidePortTaskSlotOverlay.addMouseListener(new HidePortTaskSlotOverlay(hidePortTaskSlotOverlay, courierTask, this, plugin));

		hideOverlay.add(hidePortTaskSlotOverlay);
		taskName.setText(courierTask.getData().taskName);
		taskName.setHorizontalAlignment(SwingConstants.CENTER);


		nameWrapper.add(taskName, BorderLayout.CENTER);
		nameWrapper.add(hideOverlay, BorderLayout.EAST);
		nameWrapper.add(anchorLabel, BorderLayout.WEST);

		JPanel portSlotWrapper = new JPanel();
		portSlotWrapper.setLayout(new BoxLayout(portSlotWrapper, BoxLayout.Y_AXIS));
		portSlotWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		portSlotWrapper.add(nameWrapper);
		portSlotWrapper.add(PortTaskSlotContainer);

		noticeWrapper.add(noticeLabel, BorderLayout.WEST);
		noticeWrapper.setBorder(NAME_BOTTOM_BORDER);
		cargoWrapper.add(cargoLabel, BorderLayout.WEST);
		cargoWrapper.setBorder(NAME_BOTTOM_BORDER);
		destinationWrapper.add(destinationLabel, BorderLayout.WEST);
		destinationWrapper.setBorder(NAME_BOTTOM_BORDER);
		xpWrapper.add(xpLabel, BorderLayout.WEST);
		xpWrapper.setBorder(NAME_BOTTOM_BORDER);

		portSlotWrapper.add(noticeWrapper);
		portSlotWrapper.add(cargoWrapper);
		portSlotWrapper.add(destinationWrapper);
		portSlotWrapper.add(xpWrapper);

		PortTaskSlotContainer.setLayout(new BorderLayout());
		PortTaskSlotContainer.add(PortTaskActionsLeftSide, BorderLayout.WEST);
		PortTaskSlotContainer.add(PortTaskInformationCenter, BorderLayout.CENTER);
		PortTaskSlotContainer.setBorder(NAME_BOTTOM_BORDER);

		add(portSlotWrapper);

		updateVisibility();
		updateColorIndicators();
		updateImages(courierTask);

	}

	public void openPortTaskColorPicker()
	{
		Color color = courierTask.getOverlayColor() == null ? Color.red : courierTask.getOverlayColor();
		RuneliteColorPicker colourPicker = getColorPicker(color);
		colourPicker.setOnColorChange(c ->
		{
			courierTask.setOverlayColor(c);
			PortTaskOverlayColor.setBorder(new MatteBorder(0, 0, 3, 0, courierTask.getOverlayColor()));
			PortTaskOverlayColor.setIcon(BORDER_COLOR_ICON);
			updateColorIndicators();
		});
		colourPicker.setVisible(true);
	}

	private RuneliteColorPicker getColorPicker(Color color)
	{
		RuneliteColorPicker colorPicker = plugin.getColorPickerManager().create(
				SwingUtilities.windowForComponent(this),
				color,
				courierTask.getData().taskName + " - overlay color",
				false);
		colorPicker.setLocationRelativeTo(this);
		colorPicker.setOnClose(c -> plugin.saveSlotSettings());
		return colorPicker;
	}


	private void updateColorIndicators()
	{
		PortTaskOverlayColor.setBorder(new MatteBorder(0, 0, 3, 0, courierTask.getOverlayColor()));
		PortTaskOverlayColor.setIcon(BORDER_COLOR_ICON);
	}

	public void updateVisibility()
	{
		hidePortTaskSlotOverlay.setIcon(courierTask.isTracking() ? VISIBLE_ICON : INVISIBLE_ICON);
	}

	private void updateImages(CourierTask courierTask)
	{
		cargoLabel.setIcon(PACKAGE);
		destinationLabel.setIcon(DESTINATION);
		noticeLabel.setIcon(NOTICE);
		anchorLabel.setIcon(ANCHOR);
		boatLabel.setIcon(BOAT);

		cargoLabel.setText(courierTask.getData().getCargoLocation().getName());
		destinationLabel.setText(courierTask.getData().getDeliveryLocation().getName());
		cargoLabel.setToolTipText("Cargo Location");
		destinationLabel.setToolTipText("Delivery Location");
		noticeLabel.setToolTipText("Cargo Item Needed");

		String xp = TaskReward.getRewardForTask(courierTask.getData().getDbrow());
		xpLabel.setIcon(LIGHTBULB);
		xpLabel.setText(xp + " XP");
		xpLabel.setToolTipText("Delivery XP reward");

		clientThread.invokeLater(() ->
		{
			final ItemComposition cargoComposition = itemManager.getItemComposition(courierTask.getData().cargo);
			noticeLabel.setText(courierTask.getData().getCargoAmount() + "x " + cargoComposition.getMembersName());
		});
	}

}

/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks.ui;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;

import com.nucleon.porttasks.BountyTask;
import com.nucleon.porttasks.CourierTask;
import com.nucleon.porttasks.PortTasksConfig;
import com.nucleon.porttasks.PortTasksPlugin;
import com.nucleon.porttasks.Task;
import com.nucleon.porttasks.enums.PortPaths;
import com.nucleon.porttasks.ui.adapters.ReloadPortTasks;

import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.client.util.ImageUtil;

import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import javax.swing.border.EmptyBorder;

import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;


public class PortTasksPluginPanel extends PluginPanel
{
		private static final ImageIcon RELOAD_ICON;
		private final PluginErrorPanel errorPanel = new PluginErrorPanel();
		public final PortTasksPlugin plugin;
		private final PortTasksConfig config;
		private final JPanel markerView = new JPanel();
		private ClientThread clientThread;
		private ItemManager itemManager;
		private Client client;

		static
		{
			final BufferedImage addIcon = ImageUtil.loadImageResource(PortTasksPlugin.class, "reload.png");
			RELOAD_ICON = new ImageIcon(addIcon);
		}

		public PortTasksPluginPanel(PortTasksPlugin plugin, ClientThread clientThread, ItemManager itemManager, Client client, PortTasksConfig config)
		{
			this.plugin = plugin;
			this.config = config;
			this.clientThread = clientThread;
			this.itemManager = itemManager;
			this.client = client;
			setLayout(new BorderLayout());
			setBorder(new EmptyBorder(10, 10, 10, 10));
			setupErrorPanel(true);

			// title panel
			JPanel northPanel = new JPanel(new BorderLayout());
			northPanel.setBorder(new EmptyBorder(1, 0, 10, 0));

			JPanel titlePanel = new JPanel(new BorderLayout());
			titlePanel.setBorder(new EmptyBorder(1, 3, 10, 7));

			JLabel title = new JLabel("Port Tasks", SwingConstants.CENTER);
			title.setHorizontalAlignment(SwingConstants.CENTER);
			title.setForeground(Color.WHITE);

			JLabel markerAdd = new JLabel(RELOAD_ICON);
			markerAdd.setToolTipText("reload");
			markerAdd.addMouseListener(new ReloadPortTasks(markerAdd, plugin, clientThread, this::addMarker));

			JPanel markerButtons = new JPanel(new FlowLayout(FlowLayout.RIGHT, 7, 3));
			markerButtons.add(markerAdd);

			titlePanel.add(title, BorderLayout.WEST);
			titlePanel.add(markerButtons, BorderLayout.EAST);
			northPanel.add(titlePanel, BorderLayout.NORTH);

			// marker view panels, these are dynamically added in rebuild()
			JPanel centerPanel = new JPanel(new BorderLayout());
			centerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

			markerView.setLayout(new BoxLayout(markerView, BoxLayout.Y_AXIS));
			markerView.setBackground(ColorScheme.DARK_GRAY_COLOR);
			markerView.add(errorPanel);

			centerPanel.add(markerView, BorderLayout.NORTH);

			// setup panels border layout
			add(northPanel, BorderLayout.NORTH);
			add(centerPanel, BorderLayout.CENTER);

			if (plugin.developerMode)
			{
				addDeveloperPanel();
			}
		}

//		public void rebuild()
//		{
//			markerView.removeAll();
//			List<CourierTask> courierTasks = plugin.getCourierTasks();
//			for (CourierTask courierTask : courierTasks)
//			{
//				markerView.add(new CourierTaskPanel(plugin, courierTask, clientThread, itemManager, courierTask.getSlot()));
//				markerView.add(Box.createRigidArea(new Dimension(0, 10)));
//			}
//			List<BountyTask> bountyTasks = plugin.getBountyTasks();
//
//			for (BountyTask bountyTask : bountyTasks)
//			{
//				markerView.add(new BountyTaskPanel(plugin, bountyTask, clientThread, itemManager, bountyTask.getSlot()));
//				markerView.add(Box.createRigidArea(new Dimension(0, 10)));
//			}
//
//			if (courierTasks.isEmpty() || bountyTasks.isEmpty())
//			{
//				setupErrorPanel(true);
//			}
//			repaint();
//			revalidate();
//		}

		public void rebuild()
		{
			markerView.removeAll();
			List<Task> allTasks = new ArrayList<>();
			allTasks.addAll(plugin.getCourierTasks());
			allTasks.addAll(plugin.getBountyTasks());
			allTasks.sort(Comparator.comparingInt(Task::getSlot));
			for (Task task : allTasks)
			{
				if (task instanceof CourierTask)
				{
					CourierTask courier = (CourierTask) task;
					markerView.add(new CourierTaskPanel(plugin, courier, clientThread, itemManager, courier.getSlot()));
				}
				else if (task instanceof BountyTask)
				{
					BountyTask bounty = (BountyTask) task;
					markerView.add(new BountyTaskPanel(plugin, bounty, clientThread, itemManager, client, bounty.getSlot()));
				}
				markerView.add(Box.createRigidArea(new Dimension(0, 10)));
			}
			if (allTasks.isEmpty())
			{
				setupErrorPanel(true);
			}
			repaint();
			revalidate();
		}

		public void updateBountyPanel(BountyTask task) // avoid rebuilding the entire JPanel lol
		{
			BountyTaskPanel panel = (BountyTaskPanel) markerView.getComponent(task.getSlot());
			if (panel != null)
			{
				panel.refresh();
			}
		}



	private void addMarker()
		{
			setupErrorPanel(false);
		}

		private void setupErrorPanel(boolean enabled)
		{
			PluginErrorPanel errorPanel = this.errorPanel;
			errorPanel.setVisible(enabled);
			if (enabled)
			{
				errorPanel.setContent("Port Tasks", "Click the 'reload' button to read the Port Task client data.");
				markerView.removeAll();
				markerView.setLayout(new BoxLayout(markerView, BoxLayout.Y_AXIS));
				markerView.setBackground(ColorScheme.DARK_GRAY_COLOR);
				markerView.add(errorPanel);
			}
		}

		private void addDeveloperPanel()
		{
			JPanel developerPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 5));
			developerPanel.setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
			developerPanel.setBorder(new EmptyBorder(2, 2, 2, 2));

			JComboBox<String> portPathDropdown = new JComboBox<>();
			PortPaths[] paths = PortPaths.values();
			Arrays.sort(paths, Comparator.comparing(Enum::name));

			for (PortPaths path : paths)
			{
				portPathDropdown.addItem(path.name());
			}
			portPathDropdown.setFocusable(false);
			portPathDropdown.setToolTipText("Developer actions");

			portPathDropdown.addActionListener(e ->
			{
				String selected = (String) portPathDropdown.getSelectedItem();
				plugin.setDeveloperPathSelected(PortPaths.valueOf(selected));
			});

			developerPanel.add(portPathDropdown);
			add(developerPanel, BorderLayout.SOUTH);
		}
}
/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks.ui;

public interface TaskPanel
{
	void openPortTaskColorPicker();
	void updateVisibility();
}

package com.nucleon.porttasks;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

import java.awt.Color;

@Data
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class WidgetTag
{
	@EqualsAndHashCode.Include
	private int dbrow;
	private Color color;
}

/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.nucleon.porttasks;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PortTasksPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(PortTasksPlugin.class);
		RuneLite.main(args);
	}
}
