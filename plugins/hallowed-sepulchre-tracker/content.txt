package com.hallowedsep;

import lombok.Data;

import java.time.LocalDate;
import java.util.HashMap;
import java.util.Map;

@Data
public class DailyStats
{
	private String date; // YYYY-MM-DD format
	private int runs;
	private int totalXp;
	private long totalTimeMs;
	private Map<Integer, Integer> floorCompletions = new HashMap<>();
	private int chestsLooted;
	private int grandCoffinsLooted;
	
	public DailyStats()
	{
		this.date = LocalDate.now().toString();
		for (int i = 1; i <= 5; i++)
		{
			floorCompletions.put(i, 0);
		}
	}
	
	public DailyStats(String date)
	{
		this.date = date;
		for (int i = 1; i <= 5; i++)
		{
			floorCompletions.put(i, 0);
		}
	}
	
	public void addRun(int xp, long timeMs)
	{
		this.runs++;
		this.totalXp += xp;
		this.totalTimeMs += timeMs;
	}
	
	public void incrementFloor(int floor)
	{
		floorCompletions.merge(floor, 1, Integer::sum);
	}
	
	public int getFloorCompletions(int floor)
	{
		return floorCompletions.getOrDefault(floor, 0);
	}
	
	public double getHoursPlayed()
	{
		return totalTimeMs / 3_600_000.0;
	}
	
	public double getXpPerHour()
	{
		if (totalTimeMs == 0) return 0;
		return totalXp / (totalTimeMs / 3_600_000.0);
	}
	
	public double getAverageXpPerRun()
	{
		if (runs == 0) return 0;
		return (double) totalXp / runs;
	}
}

package com.hallowedsep;

import com.google.gson.*;

import java.lang.reflect.Type;
import java.time.Duration;

public class DurationTypeAdapter implements JsonSerializer<Duration>, JsonDeserializer<Duration>
{
	@Override
	public JsonElement serialize(Duration src, Type typeOfSrc, JsonSerializationContext context)
	{
		return new JsonPrimitive(src.toMillis());
	}
	
	@Override
	public Duration deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException
	{
		return Duration.ofMillis(json.getAsLong());
	}
}

package com.hallowedsep;

import net.runelite.client.config.*;

import java.awt.Color;

@ConfigGroup("hallowedsep")
public interface HallowedSepulchreConfig extends Config
{
	@ConfigSection(
		name = "Display",
		description = "Display settings",
		position = 0
	)
	String displaySection = "display";
	
	@ConfigSection(
		name = "Tracking",
		description = "What to track",
		position = 1
	)
	String trackingSection = "tracking";
	
	@ConfigSection(
		name = "Goals",
		description = "Goal settings",
		position = 2
	)
	String goalsSection = "goals";
	
	@ConfigSection(
		name = "XP Estimates",
		description = "XP estimation values",
		position = 3
	)
	String xpSection = "xp";
	
	// Display Section
	@ConfigItem(
		keyName = "showOverlay",
		name = "Show Overlay",
		description = "Show the in-game overlay during runs",
		section = displaySection,
		position = 0
	)
	default boolean showOverlay()
	{
		return true;
	}
	
	@ConfigItem(
		keyName = "showInfoBox",
		name = "Show Info Box",
		description = "Show the info box with XP/hr",
		section = displaySection,
		position = 1
	)
	default boolean showInfoBox()
	{
		return true;
	}
	
	@ConfigItem(
		keyName = "overlayColor",
		name = "Overlay Color",
		description = "Color of the overlay background",
		section = displaySection,
		position = 2
	)
	default Color overlayColor()
	{
		return new Color(45, 45, 45, 200);
	}
	
	@ConfigItem(
		keyName = "showFloorTimer",
		name = "Show Floor Timer",
		description = "Show time spent on current floor",
		section = displaySection,
		position = 3
	)
	default boolean showFloorTimer()
	{
		return true;
	}
	
	@ConfigItem(
		keyName = "showRunTimer",
		name = "Show Run Timer",
		description = "Show total run time",
		section = displaySection,
		position = 4
	)
	default boolean showRunTimer()
	{
		return true;
	}
	
	@ConfigItem(
		keyName = "showXpGained",
		name = "Show XP Gained",
		description = "Show XP gained during current run",
		section = displaySection,
		position = 5
	)
	default boolean showXpGained()
	{
		return true;
	}
	
	// Tracking Section
	@ConfigItem(
		keyName = "trackChests",
		name = "Track Chest Looting",
		description = "Track coffin/chest looting per floor",
		section = trackingSection,
		position = 0
	)
	default boolean trackChests()
	{
		return true;
	}
	
	@ConfigItem(
		keyName = "trackDeaths",
		name = "Track Deaths",
		description = "Track deaths per floor (coming soon)",
		section = trackingSection,
		position = 1
	)
	default boolean trackDeaths()
	{
		return false;
	}
	
	// Goals Section
	@ConfigItem(
		keyName = "targetLevel",
		name = "Target Level",
		description = "Your target Agility level (for projection calculations)",
		section = goalsSection,
		position = 0
	)
	@Range(min = 1, max = 99)
	default int targetLevel()
	{
		return 99;
	}
	
	@ConfigItem(
		keyName = "runsPerDay",
		name = "Runs Per Day",
		description = "Estimated runs per day (for time projection)",
		section = goalsSection,
		position = 1
	)
	@Range(min = 1, max = 200)
	default int runsPerDay()
	{
		return 25;
	}
	
	@ConfigItem(
		keyName = "milestoneLevel",
		name = "Milestone Level",
		description = "Intermediate milestone level (e.g., 92 for floor 5 access)",
		section = goalsSection,
		position = 2
	)
	@Range(min = 1, max = 99)
	default int milestoneLevel()
	{
		return 92;
	}
	
	// XP Estimates Section
	@ConfigItem(
		keyName = "estimatedXpPerRun",
		name = "Estimated XP/Run",
		description = "Estimated XP per run (used before you have data)",
		section = xpSection,
		position = 0
	)
	@Range(min = 1000, max = 20000)
	default int estimatedXpPerRun()
	{
		return 5850;
	}
	
	@ConfigItem(
		keyName = "floor1Xp",
		name = "Floor 1 XP",
		description = "Base XP for completing Floor 1",
		section = xpSection,
		position = 1
	)
	default int floor1Xp()
	{
		return 575;
	}
	
	@ConfigItem(
		keyName = "floor2Xp",
		name = "Floor 2 XP",
		description = "Base XP for completing Floor 2",
		section = xpSection,
		position = 2
	)
	default int floor2Xp()
	{
		return 925;
	}
	
	@ConfigItem(
		keyName = "floor3Xp",
		name = "Floor 3 XP",
		description = "Base XP for completing Floor 3",
		section = xpSection,
		position = 3
	)
	default int floor3Xp()
	{
		return 1500;
	}
	
	@ConfigItem(
		keyName = "floor4Xp",
		name = "Floor 4 XP",
		description = "Base XP for completing Floor 4",
		section = xpSection,
		position = 4
	)
	default int floor4Xp()
	{
		return 2700;
	}
	
	@ConfigItem(
		keyName = "floor5Xp",
		name = "Floor 5 XP",
		description = "Base XP for completing Floor 5",
		section = xpSection,
		position = 5
	)
	default int floor5Xp()
	{
		return 6000;
	}
	
	@ConfigItem(
		keyName = "floor4LootXp",
		name = "Floor 4 Loot XP",
		description = "Extra XP from looting 1 chest on Floor 4",
		section = xpSection,
		position = 6
	)
	default int floor4LootXp()
	{
		return 150;
	}
	
	@ConfigItem(
		keyName = "floor5LootXp",
		name = "Floor 5 Loot XP",
		description = "Extra XP from looting chests + Grand Coffin on Floor 5",
		section = xpSection,
		position = 7
	)
	default int floor5LootXp()
	{
		return 580;
	}
}

package com.hallowedsep;

import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

import javax.inject.Inject;
import java.awt.*;

public class HallowedSepulchreInfoBox extends OverlayPanel
{
	private final HallowedSepulchrePlugin plugin;
	private final HallowedSepulchreConfig config;
	
	@Inject
	public HallowedSepulchreInfoBox(HallowedSepulchrePlugin plugin, HallowedSepulchreConfig config)
	{
		super(plugin);
		this.plugin = plugin;
		this.config = config;
		
		setPosition(OverlayPosition.BOTTOM_LEFT);
		setPriority(OverlayPriority.LOW);
		panelComponent.setPreferredSize(new Dimension(180, 0));
	}
	
	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!config.showInfoBox())
		{
			return null;
		}
		
		// Only show in Hallowed Sepulchre (lobby or floors)
		// Use strict real-time region check to avoid showing in other areas
		if (!plugin.isCurrentlyInSepulchreRegion())
		{
			return null;
		}
		
		PersistentStats stats = plugin.getPersistentStats();
		HallowedSepulchreSession session = plugin.getSession();
		
		// Title
		panelComponent.getChildren().add(TitleComponent.builder()
			.text("Hallowed Sepulchre")
			.color(new Color(170, 130, 255))
			.build());
		
		// Status based on current run (more reliable than region detection)
		SepulchreRun currentRun = plugin.getCurrentRun();
		boolean hasActiveRun = currentRun != null;
		int floor = plugin.getCurrentFloor();
		
		String statusText = hasActiveRun ? "FLOOR " + floor : "IDLE";
		Color statusColor = hasActiveRun ? Color.GREEN : Color.GRAY;
		
		panelComponent.getChildren().add(LineComponent.builder()
			.left("Status:")
			.right(statusText)
			.rightColor(statusColor)
			.build());
		
		// Separator
		panelComponent.getChildren().add(LineComponent.builder()
			.left("-------------")
			.right("")
			.leftColor(new Color(80, 80, 90))
			.build());
		
		// Get today's stats
		DailyStats today = stats.getToday();
		int todayRuns = today != null ? today.getRuns() : 0;
		int todayXp = today != null ? today.getTotalXp() : 0;
		double todayHours = today != null ? today.getHoursPlayed() : 0;
		
		// Get session stats (live during run)
		int sessionRuns = session != null ? session.getTotalRuns() : 0;
		int sessionXp = session != null ? session.getTotalXp() : 0;
		
		// Add current run XP if in a run
		int currentRunXp = currentRun != null ? currentRun.getTotalXp() : 0;
		
		// Total XP = today's completed + session's completed + current run
		int totalXpDisplay = todayXp + currentRunXp;
		
		// Runs Today (+ current if in run)
		String runsDisplay = currentRun != null ? 
			todayRuns + " (+1)" : String.valueOf(todayRuns);
		panelComponent.getChildren().add(LineComponent.builder()
			.left("Runs Today:")
			.right(runsDisplay)
			.rightColor(Color.WHITE)
			.build());
		
		// Runs Session
		String sessionDisplay = currentRun != null ?
			sessionRuns + " (+1)" : String.valueOf(sessionRuns);
		panelComponent.getChildren().add(LineComponent.builder()
			.left("Runs Session:")
			.right(sessionDisplay)
			.rightColor(Color.CYAN)
			.build());
		
		// Hours in Sep (today) - include current run time
		double currentRunHours = 0;
		if (currentRun != null)
		{
			currentRunHours = currentRun.getDuration().toMillis() / 3_600_000.0;
		}
		panelComponent.getChildren().add(LineComponent.builder()
			.left("Time in Sep:")
			.right(formatHoursMinutes(todayHours + currentRunHours))
			.rightColor(new Color(100, 180, 255))
			.build());
		
		// XP Gained (today + current run)
		panelComponent.getChildren().add(LineComponent.builder()
			.left("XP Gained:")
			.right(HallowedSepulchrePlugin.formatNumber(totalXpDisplay))
			.rightColor(Color.GREEN)
			.build());
		
		// XP/hr - live calculation including current run
		double xpHrDisplay = plugin.getXpPerHour();
		panelComponent.getChildren().add(LineComponent.builder()
			.left("XP/hr:")
			.right(HallowedSepulchrePlugin.formatNumber((int) xpHrDisplay))
			.rightColor(getXpHrColor(xpHrDisplay))
			.build());
		
		// Runs to next level
		int currentLevel = plugin.getCurrentAgilityLevel();
		if (currentLevel < 99)
		{
			int nextLevel = plugin.getNextLevel();
			int runsToNext = plugin.getRunsToNextLevel();
			panelComponent.getChildren().add(LineComponent.builder()
				.left("Runs to " + nextLevel + ":")
				.right(String.valueOf(runsToNext))
				.rightColor(new Color(255, 200, 100))
				.build());
		}
		
		return super.render(graphics);
	}
	
	private Color getXpHrColor(double xpPerHour)
	{
		if (xpPerHour >= 100000)
		{
			return new Color(0, 255, 0);
		}
		else if (xpPerHour >= 80000)
		{
			return new Color(100, 255, 100);
		}
		else if (xpPerHour >= 60000)
		{
			return Color.YELLOW;
		}
		else
		{
			return new Color(255, 150, 100);
		}
	}
	
	private String formatHoursMinutes(double hours)
	{
		int totalMinutes = (int) (hours * 60);
		int h = totalMinutes / 60;
		int m = totalMinutes % 60;
		
		if (h > 0)
		{
			return String.format("%dh %dm", h, m);
		}
		else
		{
			return String.format("%dm", m);
		}
	}
}

package com.hallowedsep;

import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

import javax.inject.Inject;
import java.awt.*;
import java.time.Duration;
import java.time.Instant;

public class HallowedSepulchreOverlay extends OverlayPanel
{
	private final HallowedSepulchrePlugin plugin;
	private final HallowedSepulchreConfig config;
	
	@Inject
	public HallowedSepulchreOverlay(HallowedSepulchrePlugin plugin, HallowedSepulchreConfig config)
	{
		super(plugin);
		this.plugin = plugin;
		this.config = config;
		
		setPosition(OverlayPosition.TOP_LEFT);
		setPriority(OverlayPriority.LOW);
	}
	
	@Override
	public Dimension render(Graphics2D graphics)
	{
		// Only show in Hallowed Sepulchre using strict real-time region check
		if (!config.showOverlay() || !plugin.isCurrentlyInSepulchreRegion())
		{
			return null;
		}
		
		SepulchreRun currentRun = plugin.getCurrentRun();
		if (currentRun == null)
		{
			return null;
		}
		
		// Title
		panelComponent.getChildren().add(TitleComponent.builder()
			.text("Hallowed Sepulchre")
			.color(new Color(170, 130, 255))
			.build());
		
		// Current floor
		int currentFloor = plugin.getCurrentFloor();
		if (currentFloor > 0)
		{
			panelComponent.getChildren().add(LineComponent.builder()
				.left("Floor:")
				.right(String.valueOf(currentFloor))
				.rightColor(getFloorColor(currentFloor))
				.build());
		}
		
		// Run timer
		if (config.showRunTimer())
		{
			Duration runTime = currentRun.getDuration();
			panelComponent.getChildren().add(LineComponent.builder()
				.left("Run Time:")
				.right(HallowedSepulchrePlugin.formatDuration(runTime))
				.rightColor(Color.WHITE)
				.build());
		}
		
		// Floor timer
		if (config.showFloorTimer() && currentFloor > 0 && plugin.getFloorStartTime() != null)
		{
			Duration floorTime = Duration.between(plugin.getFloorStartTime(), Instant.now());
			panelComponent.getChildren().add(LineComponent.builder()
				.left("Floor Time:")
				.right(HallowedSepulchrePlugin.formatDuration(floorTime))
				.rightColor(Color.YELLOW)
				.build());
		}
		
		// XP gained this run
		if (config.showXpGained())
		{
			panelComponent.getChildren().add(LineComponent.builder()
				.left("XP Gained:")
				.right(HallowedSepulchrePlugin.formatNumber(currentRun.getTotalXp()))
				.rightColor(Color.GREEN)
				.build());
		}
		
		// Chests looted
		if (config.trackChests())
		{
			int chestsLooted = currentRun.getTotalChestsLooted();
			if (chestsLooted > 0 || currentRun.isLootedGrandCoffin())
			{
				String chestText = String.valueOf(chestsLooted);
				if (currentRun.isLootedGrandCoffin())
				{
					chestText += " + GC";
				}
				panelComponent.getChildren().add(LineComponent.builder()
					.left("Chests:")
					.right(chestText)
					.rightColor(new Color(255, 215, 0))
					.build());
			}
		}
		
		// Floors completed this run
		int floorsCompleted = currentRun.getFloorsCompleted();
		if (floorsCompleted > 0)
		{
			panelComponent.getChildren().add(LineComponent.builder()
				.left("Floors Done:")
				.right(String.valueOf(floorsCompleted))
				.rightColor(Color.CYAN)
				.build());
		}
		
		return super.render(graphics);
	}
	
	private Color getFloorColor(int floor)
	{
		switch (floor)
		{
			case 1:
				return new Color(144, 238, 144); // Light green
			case 2:
				return new Color(135, 206, 235); // Sky blue
			case 3:
				return new Color(255, 255, 150); // Light yellow
			case 4:
				return new Color(255, 165, 0);   // Orange
			case 5:
				return new Color(255, 100, 100); // Light red
			default:
				return Color.WHITE;
		}
	}
}

package com.hallowedsep;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import java.awt.*;
import java.time.Duration;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.Map;

public class HallowedSepulchrePanel extends PluginPanel
{
	// Color palette
	private static final Color BG_DARK = new Color(30, 30, 35);
	private static final Color BG_CARD = new Color(45, 47, 55);
	private static final Color PURPLE_ACCENT = new Color(170, 130, 255);
	private static final Color BLUE_ACCENT = new Color(100, 180, 255);
	private static final Color GOLD_ACCENT = new Color(255, 215, 0);
	private static final Color GREEN_SUCCESS = new Color(80, 200, 120);
	private static final Color ORANGE_WARN = new Color(255, 165, 80);
	private static final Color RED_DANGER = new Color(255, 100, 100);
	private static final Color TEXT_PRIMARY = new Color(255, 255, 255);
	private static final Color TEXT_SECONDARY = new Color(200, 200, 210);
	private static final Color TEXT_MUTED = new Color(140, 140, 150);
	
	// Floor colors
	private static final Color[] FLOOR_COLORS = {
		new Color(144, 238, 144), // Floor 1 - Light green
		new Color(135, 206, 235), // Floor 2 - Sky blue
		new Color(255, 255, 150), // Floor 3 - Yellow
		new Color(255, 165, 0),   // Floor 4 - Orange
		new Color(255, 100, 100)  // Floor 5 - Red
	};
	
	// Larger fonts for readability
	private static final Font TITLE_FONT = new Font("SansSerif", Font.BOLD, 18);
	private static final Font HEADER_FONT = new Font("SansSerif", Font.BOLD, 14);
	private static final Font LABEL_FONT = new Font("SansSerif", Font.PLAIN, 13);
	private static final Font VALUE_FONT = new Font("SansSerif", Font.BOLD, 13);
	private static final Font SMALL_FONT = new Font("SansSerif", Font.PLAIN, 12);
	
	private final HallowedSepulchrePlugin plugin;
	private final HallowedSepulchreConfig config;
	
	private JPanel mainContent;
	private JScrollPane scrollPane;
	private boolean historyExpanded = false;
	
	public HallowedSepulchrePanel(HallowedSepulchrePlugin plugin, HallowedSepulchreConfig config)
	{
		super(false);
		this.plugin = plugin;
		this.config = config;
		
		setBackground(BG_DARK);
		setLayout(new BorderLayout());
		
		mainContent = new JPanel();
		mainContent.setBackground(BG_DARK);
		mainContent.setLayout(new BoxLayout(mainContent, BoxLayout.Y_AXIS));
		mainContent.setBorder(new EmptyBorder(10, 8, 20, 8));
		
		scrollPane = new JScrollPane(mainContent);
		scrollPane.setBackground(BG_DARK);
		scrollPane.setBorder(null);
		scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		scrollPane.getVerticalScrollBar().setUnitIncrement(16);
		
		add(scrollPane, BorderLayout.CENTER);
		
		buildPanel();
	}
	
	private void buildPanel()
	{
		mainContent.removeAll();
		
		// === HEADER ===
		mainContent.add(createHeader());
		mainContent.add(Box.createVerticalStrut(12));
		
		PersistentStats stats = plugin.getPersistentStats();
		HallowedSepulchreSession session = plugin.getSession();
		
		// === TODAY'S STATS ===
		mainContent.add(createTodayCard(stats));
		mainContent.add(Box.createVerticalStrut(10));
		
		// === ALL-TIME STATS ===
		mainContent.add(createAllTimeCard(stats));
		mainContent.add(Box.createVerticalStrut(10));
		
		// === PROGRESS CARD ===
		mainContent.add(createProgressCard());
		mainContent.add(Box.createVerticalStrut(10));
		
		// === FLOOR COMPLETIONS ===
		mainContent.add(createFloorCard(stats, session));
		mainContent.add(Box.createVerticalStrut(10));
		
		// === BEST TIMES ===
		mainContent.add(createBestTimesCard(session));
		mainContent.add(Box.createVerticalStrut(10));
		
		// === DAILY HISTORY ===
		mainContent.add(createHistoryCard(stats));
		mainContent.add(Box.createVerticalStrut(15));
		
		// === RESET BUTTONS ===
		mainContent.add(createResetSessionButton());
		mainContent.add(Box.createVerticalStrut(8));
		mainContent.add(createResetAllTimeButton());
		
		mainContent.revalidate();
		mainContent.repaint();
	}
	
	private JPanel createHeader()
	{
		JPanel header = new JPanel();
		header.setLayout(new BoxLayout(header, BoxLayout.Y_AXIS));
		header.setBackground(BG_DARK);
		header.setBorder(new EmptyBorder(5, 5, 5, 5));
		header.setMaximumSize(new Dimension(Integer.MAX_VALUE, 60));
		
		JLabel title = new JLabel("Hallowed Sepulchre");
		title.setFont(TITLE_FONT);
		title.setForeground(PURPLE_ACCENT);
		title.setAlignmentX(Component.CENTER_ALIGNMENT);
		header.add(title);
		
		header.add(Box.createVerticalStrut(2));
		
		JLabel subtitle = new JLabel("Progress Tracker");
		subtitle.setFont(SMALL_FONT);
		subtitle.setForeground(TEXT_MUTED);
		subtitle.setAlignmentX(Component.CENTER_ALIGNMENT);
		header.add(subtitle);
		
		return header;
	}
	
	private JPanel createTodayCard(PersistentStats stats)
	{
		JPanel card = createCard("Today", BLUE_ACCENT);
		JPanel content = (JPanel) card.getComponent(1);
		
		DailyStats today = stats != null ? stats.getToday() : null;
		
		if (today == null || today.getRuns() == 0)
		{
			addStatRow(content, "No runs today", "--", TEXT_MUTED, TEXT_MUTED);
		}
		else
		{
			addStatRow(content, "Runs", String.valueOf(today.getRuns()), TEXT_SECONDARY, TEXT_PRIMARY);
			addStatRow(content, "XP", formatNumber(today.getTotalXp()), TEXT_SECONDARY, GREEN_SUCCESS);
			addStatRow(content, "Time", formatHoursMinutes(today.getHoursPlayed()), TEXT_SECONDARY, BLUE_ACCENT);
			
			// Live XP/hr including current run
			double xpHr = plugin.getXpPerHour();
			addStatRow(content, "XP/hr", formatNumber((int) xpHr), TEXT_SECONDARY, getXpHrColor(xpHr));
			
			if (today.getRuns() > 0)
			{
				int avgXp = today.getTotalXp() / today.getRuns();
				addStatRow(content, "Avg/Run", formatNumber(avgXp), TEXT_SECONDARY, TEXT_PRIMARY);
			}
		}
		
		return card;
	}
	
	private JPanel createAllTimeCard(PersistentStats stats)
	{
		JPanel card = createCard("All Time", GOLD_ACCENT);
		JPanel content = (JPanel) card.getComponent(1);
		
		if (stats == null || stats.getAllTimeRuns() == 0)
		{
			addStatRow(content, "No data yet", "--", TEXT_MUTED, TEXT_MUTED);
		}
		else
		{
			addStatRow(content, "Runs", String.valueOf(stats.getAllTimeRuns()), TEXT_SECONDARY, TEXT_PRIMARY);
			addStatRow(content, "XP", formatNumber(stats.getAllTimeXp()), TEXT_SECONDARY, GREEN_SUCCESS);
			addStatRow(content, "Time", formatHoursMinutes(stats.getAllTimeHours()), TEXT_SECONDARY, BLUE_ACCENT);
			addStatRow(content, "Days", String.valueOf(stats.getDaysTracked()), TEXT_SECONDARY, PURPLE_ACCENT);
			addStatRow(content, "Runs/Day", String.format("%.1f", stats.getAverageRunsPerDay()), TEXT_SECONDARY, TEXT_PRIMARY);
			addStatRow(content, "XP/hr", formatNumber((int) stats.getAllTimeXpPerHour()), TEXT_SECONDARY, getXpHrColor(stats.getAllTimeXpPerHour()));
		}
		
		return card;
	}
	
	private JPanel createProgressCard()
	{
		JPanel card = createCard("Progress to 99", GREEN_SUCCESS);
		JPanel content = (JPanel) card.getComponent(1);
		
		int level = plugin.getCurrentAgilityLevel();
		int xpTo99 = plugin.getXpToLevel(99);
		int runsTo99 = plugin.getRunsRemaining(99);
		
		// Level with colored indicator
		Color levelColor = level >= 99 ? GOLD_ACCENT : (level >= 92 ? GREEN_SUCCESS : TEXT_PRIMARY);
		addStatRow(content, "Level", String.valueOf(level), TEXT_SECONDARY, levelColor);
		
		// Progress
		if (level < 99)
		{
			PersistentStats stats = plugin.getPersistentStats();
			double avgRunsPerDay = stats != null ? stats.getAverageRunsPerDay() : 0;
			
			// XP to 92 if not there yet
			if (level < 92)
			{
				int xpTo92 = plugin.getXpToLevel(92);
				int runsTo92 = plugin.getRunsRemaining(92);
				addStatRow(content, "XP to 92", formatNumber(xpTo92), TEXT_SECONDARY, ORANGE_WARN);
				addStatRow(content, "Runs to 92", String.valueOf(runsTo92), TEXT_SECONDARY, BLUE_ACCENT);
				
				if (avgRunsPerDay > 0)
				{
					int daysTo92 = (int) Math.ceil(runsTo92 / avgRunsPerDay);
					addStatRow(content, "Days to 92", String.valueOf(daysTo92), TEXT_SECONDARY, PURPLE_ACCENT);
				}
			}
			
			// Always show 99 stats
			addStatRow(content, "XP to 99", formatNumber(xpTo99), TEXT_SECONDARY, ORANGE_WARN);
			addStatRow(content, "Runs to 99", String.valueOf(runsTo99), TEXT_SECONDARY, GOLD_ACCENT);
			
			if (avgRunsPerDay > 0)
			{
				int daysTo99 = (int) Math.ceil(runsTo99 / avgRunsPerDay);
				addStatRow(content, "Days to 99", String.valueOf(daysTo99), TEXT_SECONDARY, GOLD_ACCENT);
			}
		}
		else
		{
			content.add(Box.createVerticalStrut(10));
			JLabel congrats = new JLabel("99 AGILITY!");
			congrats.setFont(HEADER_FONT);
			congrats.setForeground(GOLD_ACCENT);
			congrats.setAlignmentX(Component.CENTER_ALIGNMENT);
			content.add(congrats);
			content.add(Box.createVerticalStrut(10));
		}
		
		return card;
	}
	
	private JPanel createFloorCard(PersistentStats stats, HallowedSepulchreSession session)
	{
		JPanel card = createCard("Floor Completions", PURPLE_ACCENT);
		JPanel content = (JPanel) card.getComponent(1);
		
		// Simple vertical list - no width issues
		for (int i = 1; i <= 5; i++)
		{
			int allTime = stats != null ? stats.getFloorCompletions(i) : 0;
			addStatRow(content, "Floor " + i, String.valueOf(allTime), TEXT_SECONDARY, FLOOR_COLORS[i-1]);
		}
		
		return card;
	}
	
	private JPanel createBestTimesCard(HallowedSepulchreSession session)
	{
		JPanel card = createCard("Personal Best Times", ORANGE_WARN);
		JPanel content = (JPanel) card.getComponent(1);
		
		PersistentStats stats = plugin.getPersistentStats();
		boolean hasTimes = false;
		
		// Show personal best times from game data
		for (int i = 1; i <= 5; i++)
		{
			long pbMs = stats != null ? stats.getBestFloorTimeMs(i) : 0;
			String timeStr = pbMs > 0 ? formatDurationMs(pbMs) : "--";
			if (pbMs > 0) hasTimes = true;
			addStatRow(content, "Floor " + i, timeStr, TEXT_SECONDARY, FLOOR_COLORS[i-1]);
		}
		
		if (!hasTimes)
		{
			// Show message if no PBs yet
			addStatRow(content, "Complete floors to see PBs", "", TEXT_MUTED, TEXT_MUTED);
		}
		
		return card;
	}
	
	private String formatDurationMs(long ms)
	{
		long totalSeconds = ms / 1000;
		long minutes = totalSeconds / 60;
		long seconds = totalSeconds % 60;
		return String.format("%d:%02d", minutes, seconds);
	}
	
	private JPanel createHistoryCard(PersistentStats stats)
	{
		JPanel card = new JPanel();
		card.setLayout(new BoxLayout(card, BoxLayout.Y_AXIS));
		card.setBackground(BG_CARD);
		card.setBorder(BorderFactory.createCompoundBorder(
			new LineBorder(BLUE_ACCENT.darker(), 1),
			new EmptyBorder(0, 0, 0, 0)
		));
		card.setMaximumSize(new Dimension(Integer.MAX_VALUE, 800));
		card.setAlignmentX(Component.CENTER_ALIGNMENT);
		
		// Clickable header
		JPanel header = new JPanel(new BorderLayout());
		header.setBackground(new Color(25, 45, 64));
		header.setBorder(new EmptyBorder(10, 14, 10, 14));
		header.setCursor(new Cursor(Cursor.HAND_CURSOR));
		
		int totalDays = stats != null ? stats.getDailyHistory().size() : 0;
		String arrow = historyExpanded ? "v" : ">";
		JLabel titleLabel = new JLabel(arrow + " Daily History (" + totalDays + " days)");
		titleLabel.setFont(HEADER_FONT);
		titleLabel.setForeground(BLUE_ACCENT);
		header.add(titleLabel, BorderLayout.WEST);
		
		// Click to toggle
		header.addMouseListener(new java.awt.event.MouseAdapter() {
			@Override
			public void mouseClicked(java.awt.event.MouseEvent e) {
				historyExpanded = !historyExpanded;
				updateStats();
			}
			@Override
			public void mouseEntered(java.awt.event.MouseEvent e) {
				header.setBackground(new Color(35, 55, 75));
			}
			@Override
			public void mouseExited(java.awt.event.MouseEvent e) {
				header.setBackground(new Color(25, 45, 64));
			}
		});
		
		card.add(header);
		
		// Content area (only visible when expanded)
		if (historyExpanded)
		{
			JPanel content = new JPanel();
			content.setLayout(new BorderLayout());
			content.setBackground(BG_CARD);
			content.setBorder(new EmptyBorder(12, 14, 12, 14));
			
			// Inner panel for rows, left-aligned
			JPanel rowsPanel = new JPanel();
			rowsPanel.setLayout(new BoxLayout(rowsPanel, BoxLayout.Y_AXIS));
			rowsPanel.setBackground(BG_CARD);
			rowsPanel.setAlignmentX(Component.LEFT_ALIGNMENT);
			
			if (stats == null || stats.getDailyHistory().isEmpty())
			{
				addStatRow(rowsPanel, "No history yet", "--", TEXT_MUTED, TEXT_MUTED);
			}
			else
			{
				// Show ALL days when expanded
				Map<String, DailyStats> history = stats.getDailyHistory();
				DateTimeFormatter fmt = DateTimeFormatter.ofPattern("MMM dd");
				
				int count = 0;
				for (int daysAgo = 0; daysAgo < 365 && count < 100; daysAgo++)
				{
					String dateKey = LocalDate.now().minusDays(daysAgo).toString();
					DailyStats day = history.get(dateKey);
					
					if (day != null && day.getRuns() > 0)
					{
						String dateLabel = daysAgo == 0 ? "Today" : 
							daysAgo == 1 ? "Yesterday" : 
							LocalDate.parse(dateKey).format(fmt);
						
						String runsText = day.getRuns() == 1 ? "1 run" : day.getRuns() + " runs";
						String stats_str = runsText + " / " + formatNumber(day.getTotalXp()) + " / " + formatHoursMinutes(day.getHoursPlayed());
						addHistoryRow(rowsPanel, dateLabel, stats_str);
						count++;
					}
				}
				
				if (count == 0)
				{
					addStatRow(rowsPanel, "No recent activity", "--", TEXT_MUTED, TEXT_MUTED);
				}
			}
			
			content.add(rowsPanel, BorderLayout.WEST);
			card.add(content);
		}
		
		return card;
	}
	
	private void addHistoryRow(JPanel panel, String date, String stats)
	{
		// Use BorderLayout for proper left alignment
		JPanel row = new JPanel(new BorderLayout());
		row.setBackground(BG_CARD);
		row.setBorder(new EmptyBorder(4, 0, 4, 0));
		row.setMaximumSize(new Dimension(Integer.MAX_VALUE, 50));
		row.setAlignmentX(Component.LEFT_ALIGNMENT);
		
		// Left side: date and stats stacked
		JPanel leftContent = new JPanel();
		leftContent.setLayout(new BoxLayout(leftContent, BoxLayout.Y_AXIS));
		leftContent.setBackground(BG_CARD);
		leftContent.setAlignmentX(Component.LEFT_ALIGNMENT);
		
		JLabel dateLabel = new JLabel(date);
		dateLabel.setFont(VALUE_FONT);
		dateLabel.setForeground(PURPLE_ACCENT);
		
		JLabel statsLabel = new JLabel(stats);
		statsLabel.setFont(SMALL_FONT);
		statsLabel.setForeground(TEXT_SECONDARY);
		
		leftContent.add(dateLabel);
		leftContent.add(statsLabel);
		
		row.add(leftContent, BorderLayout.WEST);
		
		panel.add(row);
	}
	
	private JPanel createCard(String title, Color accentColor)
	{
		JPanel card = new JPanel();
		card.setLayout(new BoxLayout(card, BoxLayout.Y_AXIS));
		card.setBackground(BG_CARD);
		card.setBorder(BorderFactory.createCompoundBorder(
			new LineBorder(accentColor.darker(), 1),
			new EmptyBorder(0, 0, 0, 0)
		));
		card.setMaximumSize(new Dimension(Integer.MAX_VALUE, 500));
		card.setAlignmentX(Component.CENTER_ALIGNMENT);
		
		// Header bar
		JPanel header = new JPanel(new BorderLayout());
		header.setBackground(new Color(
			Math.max(0, accentColor.getRed() / 4),
			Math.max(0, accentColor.getGreen() / 4),
			Math.max(0, accentColor.getBlue() / 4)
		));
		header.setBorder(new EmptyBorder(10, 14, 10, 14));
		header.setMaximumSize(new Dimension(Integer.MAX_VALUE, 40));
		
		JLabel titleLabel = new JLabel(title);
		titleLabel.setFont(HEADER_FONT);
		titleLabel.setForeground(accentColor);
		header.add(titleLabel, BorderLayout.WEST);
		
		// Content area
		JPanel content = new JPanel();
		content.setLayout(new BoxLayout(content, BoxLayout.Y_AXIS));
		content.setBackground(BG_CARD);
		content.setBorder(new EmptyBorder(8, 8, 8, 8));
		
		card.add(header);
		card.add(content);
		
		return card;
	}
	
	private void addStatRow(JPanel panel, String label, String value, Color labelColor, Color valueColor)
	{
		JPanel row = new JPanel(new BorderLayout());
		row.setBackground(BG_CARD);
		row.setMaximumSize(new Dimension(Integer.MAX_VALUE, 24));
		row.setBorder(new EmptyBorder(1, 0, 1, 0));
		
		JLabel labelComp = new JLabel(label + ":");
		labelComp.setFont(LABEL_FONT);
		labelComp.setForeground(labelColor);
		labelComp.setPreferredSize(new Dimension(90, 20));
		
		JLabel valueComp = new JLabel(value);
		valueComp.setFont(VALUE_FONT);
		valueComp.setForeground(valueColor);
		
		row.add(labelComp, BorderLayout.WEST);
		row.add(valueComp, BorderLayout.CENTER);
		
		panel.add(row);
	}
	
	private JButton createResetSessionButton()
	{
		JButton btn = new JButton("Reset Session");
		btn.setFont(LABEL_FONT);
		btn.setBackground(new Color(50, 50, 60));
		btn.setForeground(new Color(200, 200, 210));
		btn.setFocusPainted(false);
		btn.setBorderPainted(false);
		btn.setCursor(new Cursor(Cursor.HAND_CURSOR));
		btn.setAlignmentX(Component.CENTER_ALIGNMENT);
		btn.setMaximumSize(new Dimension(200, 32));
		btn.setPreferredSize(new Dimension(200, 32));
		
		btn.addMouseListener(new java.awt.event.MouseAdapter() {
			public void mouseEntered(java.awt.event.MouseEvent e) {
				btn.setBackground(new Color(70, 70, 80));
			}
			public void mouseExited(java.awt.event.MouseEvent e) {
				btn.setBackground(new Color(50, 50, 60));
			}
		});
		
		btn.addActionListener(e -> {
			int result = JOptionPane.showConfirmDialog(
				this,
				"Reset current session data?\n(All-time stats will be kept)",
				"Reset Session",
				JOptionPane.YES_NO_OPTION,
				JOptionPane.WARNING_MESSAGE
			);
			
			if (result == JOptionPane.YES_OPTION)
			{
				plugin.resetSession();
				updateStats();
			}
		});
		
		return btn;
	}
	
	private JButton createResetAllTimeButton()
	{
		JButton btn = new JButton("Reset ALL Stats");
		btn.setFont(LABEL_FONT);
		btn.setBackground(new Color(70, 35, 35));
		btn.setForeground(RED_DANGER);
		btn.setFocusPainted(false);
		btn.setBorderPainted(false);
		btn.setCursor(new Cursor(Cursor.HAND_CURSOR));
		btn.setAlignmentX(Component.CENTER_ALIGNMENT);
		btn.setMaximumSize(new Dimension(200, 32));
		btn.setPreferredSize(new Dimension(200, 32));
		
		btn.addMouseListener(new java.awt.event.MouseAdapter() {
			public void mouseEntered(java.awt.event.MouseEvent e) {
				btn.setBackground(new Color(100, 40, 40));
			}
			public void mouseExited(java.awt.event.MouseEvent e) {
				btn.setBackground(new Color(70, 35, 35));
			}
		});
		
		btn.addActionListener(e -> {
			int result = JOptionPane.showConfirmDialog(
				this,
				"WARNING!\n\nThis will permanently delete:\n" +
				"- All-time runs, XP, and time\n" +
				"- All daily history\n" +
				"- All floor completions\n" +
				"- All best times\n\n" +
				"This cannot be undone!\n\n" +
				"Are you sure?",
				"Reset ALL Stats",
				JOptionPane.YES_NO_OPTION,
				JOptionPane.WARNING_MESSAGE
			);
			
			if (result == JOptionPane.YES_OPTION)
			{
				// Double confirm for safety
				int confirm = JOptionPane.showConfirmDialog(
					this,
					"Are you REALLY sure?\nAll your progress will be lost forever.",
					"Final Confirmation",
					JOptionPane.YES_NO_OPTION,
					JOptionPane.ERROR_MESSAGE
				);
				
				if (confirm == JOptionPane.YES_OPTION)
				{
					plugin.resetAllStats();
					updateStats();
				}
			}
		});
		
		return btn;
	}
	
	public void updateStats()
	{
		if (!SwingUtilities.isEventDispatchThread())
		{
			SwingUtilities.invokeLater(this::updateStats);
			return;
		}
		
		buildPanel();
	}
	
	// Utility methods
	private String formatNumber(int num)
	{
		if (num >= 1000000)
		{
			return String.format("%.2fM", num / 1000000.0);
		}
		else if (num >= 1000)
		{
			return String.format("%.1fK", num / 1000.0);
		}
		return String.valueOf(num);
	}
	
	// Even more compact format for tight spaces (floor completions)
	private String formatCompact(int num)
	{
		if (num >= 1000000)
		{
			return String.format("%.0fM", num / 1000000.0);
		}
		else if (num >= 10000)
		{
			return String.format("%.0fK", num / 1000.0);
		}
		else if (num >= 1000)
		{
			return String.format("%.1fK", num / 1000.0);
		}
		return String.valueOf(num);
	}
	
	private String formatDuration(Duration duration)
	{
		if (duration == null) return "--";
		long totalSeconds = duration.getSeconds();
		long minutes = totalSeconds / 60;
		long seconds = totalSeconds % 60;
		return String.format("%d:%02d", minutes, seconds);
	}
	
	private String formatHoursMinutes(double hours)
	{
		int totalMinutes = (int) (hours * 60);
		int h = totalMinutes / 60;
		int m = totalMinutes % 60;
		
		if (h > 0)
		{
			return String.format("%dh %dm", h, m);
		}
		return String.format("%dm", m);
	}
	
	private Color getXpHrColor(double xpPerHour)
	{
		if (xpPerHour >= 100000) return new Color(0, 255, 0);
		if (xpPerHour >= 80000) return GREEN_SUCCESS;
		if (xpPerHour >= 60000) return GOLD_ACCENT;
		return ORANGE_WARN;
	}
}

package com.hallowedsep;

import com.google.gson.Gson;
import com.google.inject.Provides;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.awt.image.BufferedImage;
import java.time.Duration;
import java.time.Instant;

@Slf4j
@PluginDescriptor(
	name = "Hallowed Sepulchre Tracker",
	description = "Track your Hallowed Sepulchre runs, XP, floor completions, and progress to 99 Agility",
	tags = {"agility", "hallowed", "sepulchre", "xp", "tracker", "darkmeyer"}
)
public class HallowedSepulchrePlugin extends Plugin
{
	// Hallowed Sepulchre Region IDs
	private static final int LOBBY_REGION = 9565;
	
	// Floor regions (used to detect if player is still in Sepulchre area)
	// These are checked via getMapRegions() which returns all loaded regions
	private static final int[] SEPULCHRE_REGIONS = {
		9565,  // Lobby
		9309, 8797, 9052, 9054,  // Floor 1 variations
		9053, 9310, 10077,       // Floor 2 variations  
		9311, 9567, 9563,        // Floor 3 variations
		9823, 10079, 10075,      // Floor 4 variations
		10335, 10591             // Floor 5 variations
	};
	
	// Object IDs
	private static final int STAIRS_DOWN = 39526;
	private static final int STAIRS_UP = 39527;
	private static final int COFFIN = 39545;
	private static final int GRAND_HALLOWED_COFFIN = 39546;
	private static final int MAGICAL_OBELISK = 39558;
	
	@Inject
	private Client client;
	
	@Inject
	private ClientThread clientThread;
	
	@Inject
	private HallowedSepulchreConfig config;
	
	@Inject
	private OverlayManager overlayManager;
	
	@Inject
	private HallowedSepulchreOverlay overlay;
	
	@Inject
	private HallowedSepulchreInfoBox infoBox;
	
	@Inject
	private ClientToolbar clientToolbar;
	
	@Inject
	private ConfigManager configManager;
	
	@Inject
	private Gson gson;
	
	private Gson configuredGson;
	
	@Getter
	private HallowedSepulchreSession session;
	
	@Getter
	private PersistentStats persistentStats;
	
	@Getter
	private SepulchreRun currentRun;
	
	@Getter
	private boolean inSepulchre;
	
	@Getter
	private int currentFloor;
	
	@Getter
	private Instant floorStartTime;
	
	private NavigationButton navButton;
	private HallowedSepulchrePanel panel;
	private int lastAgilityXp;
	private int lastRegionId;
	
	@Override
	protected void startUp() throws Exception
	{
		log.info("Hallowed Sepulchre Tracker started!");
		
		// Configure Gson with custom type adapters using the injected Gson
		configuredGson = gson.newBuilder()
			.registerTypeAdapter(Instant.class, new InstantTypeAdapter())
			.registerTypeAdapter(Duration.class, new DurationTypeAdapter())
			.create();
		
		session = loadSession();
		persistentStats = loadPersistentStats();
		currentRun = null;
		inSepulchre = false;
		currentFloor = 0;
		lastAgilityXp = -1;
		lastRegionId = -1;
		
		overlayManager.add(overlay);
		overlayManager.add(infoBox);
		
		panel = new HallowedSepulchrePanel(this, config);
		
		// Use RuneLite's built-in agility skill icon
		BufferedImage icon;
		try
		{
			icon = ImageUtil.loadImageResource(getClass(), "/skill_icons/agility.png");
		}
		catch (Exception e)
		{
			// Fallback to a simple colored icon if skill icon not available
			icon = new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB);
			java.awt.Graphics2D g = icon.createGraphics();
			g.setColor(new java.awt.Color(170, 130, 255));
			g.fillOval(2, 2, 12, 12);
			g.dispose();
		}
		
		navButton = NavigationButton.builder()
			.tooltip("Hallowed Sepulchre")
			.icon(icon)
			.priority(6)
			.panel(panel)
			.build();
		
		clientToolbar.addNavigation(navButton);
	}
	
	@Override
	protected void shutDown() throws Exception
	{
		log.info("Hallowed Sepulchre Tracker stopped!");
		
		overlayManager.remove(overlay);
		overlayManager.remove(infoBox);
		clientToolbar.removeNavigation(navButton);
		
		saveSession();
	}
	
	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		if (event.getGameState() == GameState.LOGGED_IN)
		{
			clientThread.invokeLater(() -> {
				if (lastAgilityXp == -1)
				{
					lastAgilityXp = client.getSkillExperience(Skill.AGILITY);
				}
			});
		}
		else if (event.getGameState() == GameState.LOGIN_SCREEN || event.getGameState() == GameState.HOPPING)
		{
			// Reset state on logout/hop to prevent stale inSepulchre flag
			if (currentRun != null)
			{
				endRun(false);
			}
			inSepulchre = false;
			currentFloor = 0;
			lastRegionId = -1;
		}
	}
	
	@Subscribe
	public void onGameTick(GameTick event)
	{
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}
		
		int regionId = getCurrentRegionId();
		
		
		if (regionId != lastRegionId)
		{
			handleRegionChange(regionId);
			lastRegionId = regionId;
		}
		
		// Update panel periodically
		if (panel != null)
		{
			panel.updateStats();
		}
	}
	
	@Subscribe
	public void onStatChanged(StatChanged event)
	{
		if (event.getSkill() != Skill.AGILITY)
		{
			return;
		}
		
		int currentXp = event.getXp();
		
		if (lastAgilityXp > 0 && currentXp > lastAgilityXp && inSepulchre && currentRun != null)
		{
			int xpGained = currentXp - lastAgilityXp;
			currentRun.addXp(xpGained);
			session.addXp(xpGained);
			
			log.debug("Agility XP gained in Sepulchre: {} (total run: {})", xpGained, currentRun.getTotalXp());
		}
		
		lastAgilityXp = currentXp;
	}
	
	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (event.getType() != ChatMessageType.GAMEMESSAGE && event.getType() != ChatMessageType.SPAM)
		{
			return;
		}
		
		String message = event.getMessage();
		
		// Detect entering Floor 1
		if (message.contains("You venture down into the Hallowed Sepulchre") && !message.contains("further"))
		{
			log.info("Detected entry to Floor 1 via chat message!");
			inSepulchre = true;
			
			if (currentRun == null)
			{
				startRun();
				currentFloor = 1;
				floorStartTime = Instant.now();
				currentRun.startFloor(1);
				log.info("Started run from chat message trigger");
			}
		}
		// Detect moving to next floor (Floor 2-5)
		else if (message.contains("You venture further down into the Hallowed Sepulchre"))
		{
			int nextFloor = currentFloor + 1;
			if (nextFloor < 2) nextFloor = 2; // Safety: at least floor 2 if we missed floor 1
			
			log.info("Moving to floor {} via chat message", nextFloor);
			
			// If run was ended by region change, restart it
			if (currentRun == null)
			{
				log.info("Run was null, restarting for floor {}", nextFloor);
				startRun();
			}
			else if (currentFloor > 0)
			{
				completeFloor(currentFloor);
			}
			
			inSepulchre = true;
			currentFloor = nextFloor;
			floorStartTime = Instant.now();
			currentRun.startFloor(nextFloor);
		}
		// Detect floor completions - "You have completed Floor 4 of the Hallowed Sepulchre! Total completions: 113."
		else if (message.contains("You have completed Floor") && message.contains("Total completions:"))
		{
			// Extract floor number
			for (int f = 1; f <= 5; f++)
			{
				if (message.contains("Floor " + f))
				{
					log.info("Completed floor {} via chat message", f);
					if (currentRun != null && currentFloor == f)
					{
						completeFloor(f);
					}
					
					// Extract total completions from "Total completions: XXX"
					try
					{
						String totalStr = message.substring(message.indexOf("Total completions:") + 18);
						totalStr = totalStr.replaceAll("[^0-9]", "").trim();
						if (!totalStr.isEmpty())
						{
							int totalCompletions = Integer.parseInt(totalStr);
							persistentStats.setFloorCompletionsFromGame(f, totalCompletions);
							log.info("Floor {} total completions from game: {}", f, totalCompletions);
							savePersistentStats();
						}
					}
					catch (Exception e)
					{
						log.warn("Failed to parse total completions from: {}", message);
					}
					break;
				}
			}
		}
		// Detect floor time - "Floor 4 time: 2:05. Personal best: 1:38"
		else if (message.contains("Floor") && message.contains("time:") && message.contains("Personal best:"))
		{
			try
			{
				// Extract floor number
				int floorNum = 0;
				for (int f = 1; f <= 5; f++)
				{
					if (message.contains("Floor " + f + " time:"))
					{
						floorNum = f;
						break;
					}
				}
				
				if (floorNum > 0)
				{
					// Extract personal best time - "Personal best: 1:38"
					String pbStr = message.substring(message.indexOf("Personal best:") + 14).trim();
					pbStr = pbStr.replaceAll("[^0-9:]", "");
					String[] pbParts = pbStr.split(":");
					if (pbParts.length == 2)
					{
						long pbMs = (Long.parseLong(pbParts[0]) * 60 + Long.parseLong(pbParts[1])) * 1000;
						persistentStats.setPersonalBestFromGame(floorNum, pbMs);
						log.info("Floor {} personal best from game: {}:{}", floorNum, pbParts[0], pbParts[1]);
						savePersistentStats();
					}
				}
			}
			catch (Exception e)
			{
				log.warn("Failed to parse floor time from: {}", message);
			}
		}
		// Detect returning to lobby
		else if (message.contains("teleports you back to the lobby"))
		{
			log.info("Detected return to lobby via chat message");
			if (currentRun != null)
			{
				endRun(true);
				currentFloor = 0;
			}
		}
	}
	
	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event)
	{
		if (!inSepulchre)
		{
			return;
		}
		
		int objectId = event.getId();
		String option = event.getMenuOption();
		
		if (objectId == COFFIN && "Search".equals(option))
		{
			handleCoffinLoot(currentFloor);
		}
		else if (objectId == GRAND_HALLOWED_COFFIN && "Search".equals(option))
		{
			handleGrandCoffinLoot();
		}
		else if (objectId == MAGICAL_OBELISK && "Activate".equals(option))
		{
			// Player is exiting via obelisk
			log.debug("Player activating magical obelisk to exit");
		}
	}
	
	private void handleRegionChange(int regionId)
	{
		boolean isInLobby = regionId == LOBBY_REGION;
		boolean stillInSepulchreArea = isInAnySepulchreRegion();
		
		// Track if we're in the lobby for overlay visibility
		if (isInLobby)
		{
			inSepulchre = true;
			
			// If we returned to lobby with an active run, end it
			// (backup for when obelisk chat message is missed)
			if (currentRun != null && currentFloor > 0)
			{
				log.info("Returned to lobby - ending run");
				endRun(true);
				currentFloor = 0;
			}
		}
		// Check if player teleported out of Sepulchre entirely
		else if (currentRun != null && !stillInSepulchreArea)
		{
			log.info("Teleported out of Sepulchre - ending run");
			endRun(false);
			inSepulchre = false;
			currentFloor = 0;
		}
		
		// All run start/floor change logic is handled via chat messages
		// See onChatMessage() for reliable detection
	}
	
	/**
	 * Check if any of the currently loaded map regions are Sepulchre regions.
	 * Uses getMapRegions() which returns all loaded regions (not just player's exact region).
	 */
	private boolean isInAnySepulchreRegion()
	{
		int[] loadedRegions = client.getMapRegions();
		if (loadedRegions == null)
		{
			return false;
		}
		
		for (int loaded : loadedRegions)
		{
			for (int sepRegion : SEPULCHRE_REGIONS)
			{
				if (loaded == sepRegion)
				{
					return true;
				}
			}
		}
		return false;
	}
	
	
	private int getCurrentRegionId()
	{
		Player player = client.getLocalPlayer();
		if (player == null)
		{
			return -1;
		}
		
		// Use simple world location - lobby region works with this
		return player.getWorldLocation().getRegionID();
	}
	
	private void startRun()
	{
		currentRun = new SepulchreRun();
		currentRun.setStartTime(Instant.now());
		currentRun.setStartXp(client.getSkillExperience(Skill.AGILITY));
		floorStartTime = Instant.now();
		
		log.debug("Started new Sepulchre run");
	}
	
	private void completeFloor(int floor)
	{
		if (currentRun == null)
		{
			return;
		}
		
		Duration floorTime = Duration.between(floorStartTime, Instant.now());
		currentRun.completeFloor(floor, floorTime);
		session.incrementFloorCompletion(floor);
		
		log.debug("Completed floor {} in {}", floor, formatDuration(floorTime));
	}
	
	private void endRun(boolean completed)
	{
		if (currentRun == null)
		{
			return;
		}
		
		// Complete the current floor if we're on one
		if (currentFloor > 0)
		{
			completeFloor(currentFloor);
		}
		
		currentRun.setEndTime(Instant.now());
		currentRun.setCompleted(completed);
		currentRun.setHighestFloor(currentFloor);
		
		// Add to session stats
		session.addRun(currentRun);
		
		// Add to persistent stats (saved across sessions)
		persistentStats.recordRun(currentRun);
		
		log.info("=== RUN RECORDED ===");
		log.info("  Floors reached: {}", currentRun.getHighestFloor());
		log.info("  XP gained: {}", currentRun.getTotalXp());
		log.info("  Duration: {}", formatDuration(currentRun.getDuration()));
		log.info("  Session runs: {}", session.getTotalRuns());
		log.info("  Today runs: {}", persistentStats.getToday().getRuns());
		log.info("  Today XP: {}", persistentStats.getToday().getTotalXp());
		log.info("===================");
		
		saveSession();
		savePersistentStats();
		currentRun = null;
	}
	
	private void handleCoffinLoot(int floor)
	{
		if (currentRun != null)
		{
			currentRun.incrementChestsLooted(floor);
			session.incrementChestsLooted(floor);
			log.debug("Looted coffin on floor {}", floor);
		}
	}
	
	private void handleGrandCoffinLoot()
	{
		if (currentRun != null)
		{
			currentRun.setLootedGrandCoffin(true);
			session.incrementGrandCoffinLooted();
			log.debug("Looted Grand Hallowed Coffin");
		}
	}
	
	private HallowedSepulchreSession loadSession()
	{
		String json = configManager.getConfiguration("hallowedsep", "session");
		if (json != null && !json.isEmpty())
		{
			try
			{
				HallowedSepulchreSession loaded = configuredGson.fromJson(json, HallowedSepulchreSession.class);
				if (loaded != null)
				{
					loaded.initializeAfterLoad();
					return loaded;
				}
			}
			catch (Exception e)
			{
				log.warn("Failed to load session data", e);
			}
		}
		return new HallowedSepulchreSession();
	}
	
	private void saveSession()
	{
		if (session != null)
		{
			String json = configuredGson.toJson(session);
			configManager.setConfiguration("hallowedsep", "session", json);
		}
	}
	
	private PersistentStats loadPersistentStats()
	{
		String json = configManager.getConfiguration("hallowedsep", "persistent");
		if (json != null && !json.isEmpty())
		{
			try
			{
				PersistentStats loaded = configuredGson.fromJson(json, PersistentStats.class);
				if (loaded != null)
				{
					loaded.initializeAfterLoad();
					return loaded;
				}
			}
			catch (Exception e)
			{
				log.warn("Failed to load persistent stats", e);
			}
		}
		return new PersistentStats();
	}
	
	private void savePersistentStats()
	{
		if (persistentStats != null)
		{
			String json = configuredGson.toJson(persistentStats);
			configManager.setConfiguration("hallowedsep", "persistent", json);
		}
	}
	
	public void resetSession()
	{
		session = new HallowedSepulchreSession();
		saveSession();
		if (panel != null)
		{
			panel.updateStats();
		}
	}
	
	public void resetAllStats()
	{
		// Reset session
		session = new HallowedSepulchreSession();
		saveSession();
		
		// Reset all persistent stats
		persistentStats = new PersistentStats();
		savePersistentStats();
		
		log.info("All stats have been reset");
		
		if (panel != null)
		{
			panel.updateStats();
		}
	}
	
	public boolean isInSepulchre()
	{
		return inSepulchre;
	}
	
	/**
	 * Check if currently in the Sepulchre (for overlay visibility)
	 */
	public boolean isCurrentlyInSepulchreRegion()
	{
		// Show overlay if in any Sepulchre region OR if we have an active run
		return isInAnySepulchreRegion() || currentRun != null;
	}
	
	public SepulchreRun getCurrentRun()
	{
		return currentRun;
	}
	
	public int getCurrentFloor()
	{
		return currentFloor;
	}
	
	public int getLastRegionId()
	{
		return lastRegionId;
	}
	
	public HallowedSepulchreSession getSession()
	{
		return session;
	}
	
	public PersistentStats getPersistentStats()
	{
		return persistentStats;
	}
	
	public int getCurrentAgilityLevel()
	{
		return client.getRealSkillLevel(Skill.AGILITY);
	}
	
	public int getCurrentAgilityXp()
	{
		return client.getSkillExperience(Skill.AGILITY);
	}
	
	public int getXpToLevel(int targetLevel)
	{
		int currentXp = getCurrentAgilityXp();
		int targetXp = Experience.getXpForLevel(targetLevel);
		return Math.max(0, targetXp - currentXp);
	}
	
	public int getNextLevel()
	{
		int currentLevel = getCurrentAgilityLevel();
		return Math.min(currentLevel + 1, 99);
	}
	
	public int getRunsToNextLevel()
	{
		int nextLevel = getNextLevel();
		if (getCurrentAgilityLevel() >= 99)
		{
			return 0;
		}
		return getRunsRemaining(nextLevel);
	}
	
	public int getRunsRemaining(int targetLevel)
	{
		int xpRemaining = getXpToLevel(targetLevel);
		
		// Use actual average XP per run from all-time stats first, then session, then config
		double xpPerRun = 0;
		
		if (persistentStats != null && persistentStats.getAllTimeRuns() > 0)
		{
			xpPerRun = persistentStats.getAllTimeAvgXpPerRun();
		}
		else if (session.getTotalRuns() > 0)
		{
			xpPerRun = session.getAverageXpPerRun();
		}
		
		if (xpPerRun <= 0)
		{
			// Fallback to config estimate
			xpPerRun = config.estimatedXpPerRun();
		}
		
		return (int) Math.ceil(xpRemaining / xpPerRun);
	}
	
	/**
	 * Get live XP per hour including current run time and XP
	 */
	public double getXpPerHour()
	{
		// Get completed session XP and time
		int completedXp = session.getTotalXp();
		long completedTimeMs = session.getTotalTimeMs();
		
		// Add current run XP and time if in a run
		int currentXp = 0;
		long currentTimeMs = 0;
		if (currentRun != null)
		{
			currentXp = currentRun.getTotalXp();
			currentTimeMs = currentRun.getDuration().toMillis();
		}
		
		int totalXp = completedXp + currentXp;
		long totalTimeMs = completedTimeMs + currentTimeMs;
		
		if (totalTimeMs == 0)
		{
			return 0;
		}
		
		double hours = totalTimeMs / 3_600_000.0;
		return totalXp / hours;
	}
	
	public static String formatDuration(Duration duration)
	{
		if (duration == null)
		{
			return "0:00";
		}
		
		long seconds = duration.getSeconds();
		long minutes = seconds / 60;
		long hours = minutes / 60;
		
		seconds %= 60;
		minutes %= 60;
		
		if (hours > 0)
		{
			return String.format("%d:%02d:%02d", hours, minutes, seconds);
		}
		return String.format("%d:%02d", minutes, seconds);
	}
	
	public static String formatNumber(int number)
	{
		if (number >= 1_000_000)
		{
			return String.format("%.1fM", number / 1_000_000.0);
		}
		else if (number >= 1_000)
		{
			return String.format("%.1fK", number / 1_000.0);
		}
		return String.valueOf(number);
	}
	
	@Provides
	HallowedSepulchreConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(HallowedSepulchreConfig.class);
	}
}

package com.hallowedsep;

import lombok.Data;

import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Data
public class HallowedSepulchreSession
{
	private Instant sessionStartTime;
	private int totalRuns;
	private int totalXp;
	private long totalTimeMs;
	
	// Floor completion counts
	private Map<Integer, Integer> floorCompletions = new HashMap<>();
	
	// Chest loot counts per floor
	private Map<Integer, Integer> chestsLootedPerFloor = new HashMap<>();
	
	// Grand coffin loot count
	private int grandCoffinLooted;
	
	// Best times per floor (in milliseconds)
	private Map<Integer, Long> bestFloorTimes = new HashMap<>();
	
	// Best full run time (in milliseconds)
	private long bestRunTimeMs;
	
	// Recent runs for averaging (limited to last 50)
	private List<RunSummary> recentRuns = new ArrayList<>();
	
	// XP at session start for calculating session XP
	private int sessionStartXp;
	
	public HallowedSepulchreSession()
	{
		this.sessionStartTime = Instant.now();
		for (int i = 1; i <= 5; i++)
		{
			floorCompletions.put(i, 0);
			chestsLootedPerFloor.put(i, 0);
			bestFloorTimes.put(i, Long.MAX_VALUE);
		}
	}
	
	public void addRun(SepulchreRun run)
	{
		totalRuns++;
		totalXp += run.getTotalXp();
		totalTimeMs += run.getDuration().toMillis();
		
		// Update best run time if this was a full run
		if (run.isCompleted() && run.getDuration().toMillis() < bestRunTimeMs || bestRunTimeMs == 0)
		{
			bestRunTimeMs = run.getDuration().toMillis();
		}
		
		// Update best floor times
		for (Map.Entry<Integer, SepulchreRun.FloorData> entry : run.getFloorData().entrySet())
		{
			int floor = entry.getKey();
			SepulchreRun.FloorData floorData = entry.getValue();
			
			if (floorData.isCompleted() && floorData.getDuration() != null)
			{
				long floorTime = floorData.getDuration().toMillis();
				Long currentBest = bestFloorTimes.get(floor);
				
				if (currentBest == null || floorTime < currentBest)
				{
					bestFloorTimes.put(floor, floorTime);
				}
			}
		}
		
		// Add to recent runs (keep last 50)
		RunSummary summary = new RunSummary();
		summary.setXp(run.getTotalXp());
		summary.setDurationMs(run.getDuration().toMillis());
		summary.setHighestFloor(run.getHighestFloor());
		summary.setCompleted(run.isCompleted());
		summary.setTimestamp(Instant.now().toEpochMilli());
		
		recentRuns.add(summary);
		if (recentRuns.size() > 50)
		{
			recentRuns.remove(0);
		}
	}
	
	public void addXp(int xp)
	{
		// This is called per XP drop, but we track via addRun for totals
	}
	
	public void incrementFloorCompletion(int floor)
	{
		floorCompletions.merge(floor, 1, Integer::sum);
	}
	
	public void incrementChestsLooted(int floor)
	{
		chestsLootedPerFloor.merge(floor, 1, Integer::sum);
	}
	
	public void incrementGrandCoffinLooted()
	{
		grandCoffinLooted++;
	}
	
	public int getFloorCompletions(int floor)
	{
		return floorCompletions.getOrDefault(floor, 0);
	}
	
	public int getChestsLooted(int floor)
	{
		return chestsLootedPerFloor.getOrDefault(floor, 0);
	}
	
	public int getTotalChestsLooted()
	{
		return chestsLootedPerFloor.values().stream().mapToInt(Integer::intValue).sum();
	}
	
	public Duration getBestFloorTime(int floor)
	{
		Long timeMs = bestFloorTimes.get(floor);
		if (timeMs == null || timeMs == Long.MAX_VALUE)
		{
			return null;
		}
		return Duration.ofMillis(timeMs);
	}
	
	public Duration getBestRunTime()
	{
		if (bestRunTimeMs == 0)
		{
			return null;
		}
		return Duration.ofMillis(bestRunTimeMs);
	}
	
	public Duration getTotalTime()
	{
		return Duration.ofMillis(totalTimeMs);
	}
	
	public Duration getSessionDuration()
	{
		return Duration.between(sessionStartTime, Instant.now());
	}
	
	public double getAverageXpPerRun()
	{
		if (totalRuns == 0)
		{
			return 0;
		}
		return (double) totalXp / totalRuns;
	}
	
	public double getAverageTimePerRun()
	{
		if (totalRuns == 0)
		{
			return 0;
		}
		return (double) totalTimeMs / totalRuns;
	}
	
	public double getXpPerHour()
	{
		if (totalTimeMs == 0)
		{
			return 0;
		}
		
		double hours = totalTimeMs / 3_600_000.0;
		return totalXp / hours;
	}
	
	public double getRunsPerHour()
	{
		if (totalTimeMs == 0)
		{
			return 0;
		}
		
		double hours = totalTimeMs / 3_600_000.0;
		return totalRuns / hours;
	}
	
	public int getRecentAverageXp(int count)
	{
		if (recentRuns.isEmpty())
		{
			return 0;
		}
		
		int limit = Math.min(count, recentRuns.size());
		int startIndex = recentRuns.size() - limit;
		
		int sum = 0;
		for (int i = startIndex; i < recentRuns.size(); i++)
		{
			sum += recentRuns.get(i).getXp();
		}
		
		return sum / limit;
	}
	
	/**
	 * Initialize maps after deserialization
	 */
	public void initializeAfterLoad()
	{
		if (floorCompletions == null)
		{
			floorCompletions = new HashMap<>();
		}
		if (chestsLootedPerFloor == null)
		{
			chestsLootedPerFloor = new HashMap<>();
		}
		if (bestFloorTimes == null)
		{
			bestFloorTimes = new HashMap<>();
		}
		if (recentRuns == null)
		{
			recentRuns = new ArrayList<>();
		}
		
		// Ensure all floors have entries
		for (int i = 1; i <= 5; i++)
		{
			floorCompletions.putIfAbsent(i, 0);
			chestsLootedPerFloor.putIfAbsent(i, 0);
			bestFloorTimes.putIfAbsent(i, Long.MAX_VALUE);
		}
	}
	
	@Data
	public static class RunSummary
	{
		private int xp;
		private long durationMs;
		private int highestFloor;
		private boolean completed;
		private long timestamp;
	}
}

package com.hallowedsep;

import com.google.gson.*;

import java.lang.reflect.Type;
import java.time.Instant;

public class InstantTypeAdapter implements JsonSerializer<Instant>, JsonDeserializer<Instant>
{
	@Override
	public JsonElement serialize(Instant src, Type typeOfSrc, JsonSerializationContext context)
	{
		return new JsonPrimitive(src.toEpochMilli());
	}
	
	@Override
	public Instant deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException
	{
		return Instant.ofEpochMilli(json.getAsLong());
	}
}

package com.hallowedsep;

import lombok.Data;

import java.time.LocalDate;
import java.util.*;

@Data
public class PersistentStats
{
	// All-time stats
	private int allTimeRuns;
	private int allTimeXp;
	private long allTimeMs;
	private Map<Integer, Integer> allTimeFloorCompletions = new HashMap<>();
	private int allTimeChestsLooted;
	private int allTimeGrandCoffins;
	
	// Best times (in milliseconds)
	private long bestRunTimeMs;
	private Map<Integer, Long> bestFloorTimes = new HashMap<>();
	
	// Daily stats - keyed by date string (YYYY-MM-DD)
	private Map<String, DailyStats> dailyHistory = new LinkedHashMap<>();
	
	// Starting XP when we first started tracking
	private int startingXp;
	private String startDate;
	
	public PersistentStats()
	{
		for (int i = 1; i <= 5; i++)
		{
			allTimeFloorCompletions.put(i, 0);
			bestFloorTimes.put(i, Long.MAX_VALUE);
		}
		this.startDate = LocalDate.now().toString();
	}
	
	public DailyStats getToday()
	{
		String today = LocalDate.now().toString();
		return dailyHistory.computeIfAbsent(today, DailyStats::new);
	}
	
	public void recordRun(SepulchreRun run)
	{
		if (run == null) return;
		
		int xp = run.getTotalXp();
		long timeMs = run.getDuration().toMillis();
		
		// Update all-time stats
		allTimeRuns++;
		allTimeXp += xp;
		allTimeMs += timeMs;
		
		// Update best run time
		if (run.isCompleted() && (bestRunTimeMs == 0 || timeMs < bestRunTimeMs))
		{
			bestRunTimeMs = timeMs;
		}
		
		// Update best times only (floor completions come from game chat via setFloorCompletionsFromGame)
		for (Map.Entry<Integer, SepulchreRun.FloorData> entry : run.getFloorData().entrySet())
		{
			int floor = entry.getKey();
			SepulchreRun.FloorData floorData = entry.getValue();
			
			if (floorData.isCompleted() && floorData.getDuration() != null)
			{
				long floorTime = floorData.getDuration().toMillis();
				Long currentBest = bestFloorTimes.get(floor);
				if (currentBest == null || floorTime < currentBest)
				{
					bestFloorTimes.put(floor, floorTime);
				}
			}
		}
		
		// Update chest counts
		allTimeChestsLooted += run.getTotalChestsLooted();
		if (run.isLootedGrandCoffin())
		{
			allTimeGrandCoffins++;
		}
		
		// Update daily stats
		DailyStats today = getToday();
		today.addRun(xp, timeMs);
		today.setChestsLooted(today.getChestsLooted() + run.getTotalChestsLooted());
		if (run.isLootedGrandCoffin())
		{
			today.setGrandCoffinsLooted(today.getGrandCoffinsLooted() + 1);
		}
		
		// Update floor completions for today
		for (Map.Entry<Integer, SepulchreRun.FloorData> entry : run.getFloorData().entrySet())
		{
			if (entry.getValue().isCompleted())
			{
				today.incrementFloor(entry.getKey());
			}
		}
	}
	
	public double getAllTimeHours()
	{
		return allTimeMs / 3_600_000.0;
	}
	
	public double getAllTimeXpPerHour()
	{
		if (allTimeMs == 0) return 0;
		return allTimeXp / (allTimeMs / 3_600_000.0);
	}
	
	public double getAllTimeAvgXpPerRun()
	{
		if (allTimeRuns == 0) return 0;
		return (double) allTimeXp / allTimeRuns;
	}
	
	public int getAllTimeFloorCompletions(int floor)
	{
		return allTimeFloorCompletions.getOrDefault(floor, 0);
	}
	
	public int getFloorCompletions(int floor)
	{
		return getAllTimeFloorCompletions(floor);
	}
	
	public long getBestFloorTimeMs(int floor)
	{
		Long time = bestFloorTimes.get(floor);
		return (time == null || time == Long.MAX_VALUE) ? 0 : time;
	}
	
	/**
	 * Set floor completions directly from the game's chat message.
	 * This uses the game's own tracking which is more accurate.
	 */
	public void setFloorCompletionsFromGame(int floor, int totalCompletions)
	{
		if (floor >= 1 && floor <= 5 && totalCompletions >= 0)
		{
			allTimeFloorCompletions.put(floor, totalCompletions);
		}
	}
	
	/**
	 * Set personal best time directly from the game's chat message.
	 */
	public void setPersonalBestFromGame(int floor, long timeMs)
	{
		if (floor >= 1 && floor <= 5 && timeMs > 0)
		{
			bestFloorTimes.put(floor, timeMs);
		}
	}
	
	public List<DailyStats> getRecentDays(int count)
	{
		List<DailyStats> days = new ArrayList<>(dailyHistory.values());
		Collections.reverse(days);
		return days.subList(0, Math.min(count, days.size()));
	}
	
	public int getDaysTracked()
	{
		return dailyHistory.size();
	}
	
	public double getAverageRunsPerDay()
	{
		if (dailyHistory.isEmpty()) return 0;
		return (double) allTimeRuns / dailyHistory.size();
	}
	
	public double getAverageHoursPerDay()
	{
		if (dailyHistory.isEmpty()) return 0;
		return getAllTimeHours() / dailyHistory.size();
	}

	/**
	 * Initialize maps after deserialization
	 */
	public void initializeAfterLoad()
	{
		if (allTimeFloorCompletions == null)
		{
			allTimeFloorCompletions = new HashMap<>();
		}
		if (bestFloorTimes == null)
		{
			bestFloorTimes = new HashMap<>();
		}
		if (dailyHistory == null)
		{
			dailyHistory = new LinkedHashMap<>();
		}
		
		// Ensure all floors have entries
		for (int i = 1; i <= 5; i++)
		{
			allTimeFloorCompletions.putIfAbsent(i, 0);
			bestFloorTimes.putIfAbsent(i, Long.MAX_VALUE);
		}
	}
}

package com.hallowedsep;

import lombok.Data;

import java.time.Duration;
import java.time.Instant;
import java.util.HashMap;
import java.util.Map;

@Data
public class SepulchreRun
{
	private Instant startTime;
	private Instant endTime;
	private int startXp;
	private int totalXp;
	private int highestFloor;
	private boolean completed;
	private boolean lootedGrandCoffin;
	
	private Map<Integer, FloorData> floorData = new HashMap<>();
	private Map<Integer, Integer> chestsLootedPerFloor = new HashMap<>();
	
	public void startFloor(int floor)
	{
		FloorData data = new FloorData();
		data.setFloorNumber(floor);
		data.setStartTime(Instant.now());
		floorData.put(floor, data);
	}
	
	public void completeFloor(int floor, Duration duration)
	{
		FloorData data = floorData.get(floor);
		if (data != null)
		{
			data.setEndTime(Instant.now());
			data.setDuration(duration);
			data.setCompleted(true);
		}
		else
		{
			data = new FloorData();
			data.setFloorNumber(floor);
			data.setDuration(duration);
			data.setCompleted(true);
			floorData.put(floor, data);
		}
	}
	
	public void addXp(int xp)
	{
		this.totalXp += xp;
	}
	
	public void incrementChestsLooted(int floor)
	{
		chestsLootedPerFloor.merge(floor, 1, Integer::sum);
	}
	
	public int getChestsLooted(int floor)
	{
		return chestsLootedPerFloor.getOrDefault(floor, 0);
	}
	
	public int getTotalChestsLooted()
	{
		return chestsLootedPerFloor.values().stream().mapToInt(Integer::intValue).sum();
	}
	
	public Duration getDuration()
	{
		if (startTime == null)
		{
			return Duration.ZERO;
		}
		
		Instant end = endTime != null ? endTime : Instant.now();
		return Duration.between(startTime, end);
	}
	
	public Duration getFloorDuration(int floor)
	{
		FloorData data = floorData.get(floor);
		if (data != null && data.getDuration() != null)
		{
			return data.getDuration();
		}
		return Duration.ZERO;
	}
	
	public int getFloorsCompleted()
	{
		return (int) floorData.values().stream().filter(FloorData::isCompleted).count();
	}
	
	@Data
	public static class FloorData
	{
		private int floorNumber;
		private Instant startTime;
		private Instant endTime;
		private Duration duration;
		private boolean completed;
		private int xpGained;
		private int chestsLooted;
		private int deaths;
	}
}

package com.hallowedsep;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class HallowedSepulchrePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(HallowedSepulchrePlugin.class);
		RuneLite.main(args);
	}
}

