package com.ondrad.nekos;

import com.google.inject.Provides;
import javax.inject.Inject;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.GameTick;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.Deque;
import java.util.ArrayDeque;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;

@Slf4j
@PluginDescriptor(
		name = "Nekos",
		description = "Displays a cute neko on the screen",
		tags = {"anime", "neko", "overlay", "catgirl", "kitsune", "cat"}
)
public class nekoPlugin extends Plugin {

	@Inject
	private nekoConfig config;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private GetRequest getRequest;

	@Inject
	private nekoOverlay overlay;

	private ScheduledExecutorService fetcherService;
	private ScheduledExecutorService displayExecutor;
	private ExecutorService fetchPool;
	private static final int BUFFER_SIZE = 5;
	private static final int HISTORY_SIZE = 1;
	private final Deque<BufferedImage> imageBuffer = new ArrayDeque<>(BUFFER_SIZE);
	private final List<BufferedImage> imageHistory = new LinkedList<>();
	private final AtomicBoolean running = new AtomicBoolean(false);
	private BufferedImage lastImage = null;


	@Override
	protected void startUp() {
		overlayManager.add(overlay);
		fetcherService = Executors.newSingleThreadScheduledExecutor();
		fetchPool = Executors.newFixedThreadPool(2);
		running.set(true);

		fetcherService.submit(this::imageFetcherLoop);

		if (!config.everyTick()) {
			startDisplayExecutor(0);
		}
	}

	private List<BufferedImage> fetchNekoImages() {
		try {
			return getRequest.GETRequest(getApiEndpoint());
		} catch (IOException e) {
			return null;
		}
	}

	private String getApiEndpoint() {
		switch (config.type()) {
			case NEKOS:
				return "https://nekos.life/api/v2/img/neko";
			case CATS:
				return "https://nekos.life/api/v2/img/meow";
			case KITSUNE:
				return "https://nekos.life/api/v2/img/fox_girl";
			default:
				return "https://nekos.life/api/v2/img/neko";
		}
	}

	private void imageFetcherLoop() {
		while (running.get()) {
			try {
				int space;
				synchronized (imageBuffer) {
					space = BUFFER_SIZE - imageBuffer.size();
				}
				if (space > 0) {
					int fetchCount = Math.min(space, 2);
					List<Future<List<BufferedImage>>> futures = new ArrayList<>();
					for (int i = 0; i < fetchCount; i++) {
						futures.add(fetchPool.submit(this::fetchNekoImages));
					}
					for (Future<List<BufferedImage>> f : futures) {
						try {
							List<BufferedImage> imgs = f.get(5, TimeUnit.SECONDS);
							if (imgs != null && !imgs.isEmpty()) {
								synchronized (imageBuffer) {
									for (BufferedImage image : imgs) {
										if (imageBuffer.size() >= BUFFER_SIZE) break;
										imageBuffer.addLast(image);
									}
								}
							}
						} catch (Exception e) {
							log.warn("Failed to fetch image batch", e);
						}
					}
				}
				Thread.sleep(300);
			} catch (Exception ex) {
				log.warn("Error in image fetcher loop", ex);
			}
		}
	}

	@Override
	protected void shutDown() {
		overlayManager.remove(overlay);
		running.set(false);
		if (fetcherService != null) {
			fetcherService.shutdownNow();
		}
		if (fetchPool != null) {
			fetchPool.shutdownNow();
		}
		if (displayExecutor != null) {
			displayExecutor.shutdownNow();
		}
	}

	@Subscribe
	public void onGameTick(GameTick tick) {
		if (config.everyTick()) {
			displayNextImage();
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event) {
		if (!event.getGroup().equals("nekoconfig")) {
			return;
		}

		boolean typeChanged = "type".equals(event.getKey());
		if (typeChanged) {
			synchronized (imageBuffer) {
				imageBuffer.clear();
			}
		}

		if (displayExecutor != null) {
			displayExecutor.shutdownNow();
			displayExecutor = null;
		}

		if (!config.everyTick()) {
			long delayMillis = typeChanged ? 1000 : 0;
			startDisplayExecutor(delayMillis);
		}
	}

	private void startDisplayExecutor(long initialDelayMillis) {
		displayExecutor = Executors.newSingleThreadScheduledExecutor();
		long delayMillis = Math.max(1L, (long) config.delaySeconds() * 1000);
		displayExecutor.scheduleAtFixedRate(this::displayNextImage, initialDelayMillis, delayMillis, TimeUnit.MILLISECONDS);
	}

	private void displayNextImage() {
		BufferedImage next = null;
		boolean bufferWasEmpty = false;
		synchronized (imageBuffer) {
			if (!imageBuffer.isEmpty()) {
				next = imageBuffer.pollFirst();
				synchronized (imageHistory) {
					if (next != null && (imageHistory.isEmpty() || imageHistory.get(imageHistory.size() - 1) != next)) {
						imageHistory.add(next);
						if (imageHistory.size() > HISTORY_SIZE) {
							imageHistory.remove(0);
						}
					}
				}
			} else {
				bufferWasEmpty = true;
			}
		}
		if (bufferWasEmpty) {
			BufferedImage alt = null;
			synchronized (imageHistory) {
				for (BufferedImage img : imageHistory) {
					if (img != lastImage) {
						alt = img;
						break;
					}
				}
			}
			if (alt != null) {
				overlay.updateImage(alt);
				return;
			}
		}
		if (next != null) {
			lastImage = next;
		}
		if (lastImage != null) {
			overlay.updateImage(lastImage);
		}
	}

	@Provides
	nekoConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(nekoConfig.class);
	}
}

package com.ondrad.nekos;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.Range;

import java.awt.*;

@ConfigGroup("nekoconfig")
public interface nekoConfig extends Config
{

	enum ImageType {
		NEKOS,
		CATS,
		KITSUNE
	}
	@ConfigItem(
			position = 1,
			keyName = "type",
			name = "Type:",
			description = "Choose the type of image to display"
	)
	default ImageType type() {
		return ImageType.NEKOS;
	}


	@ConfigItem(
		position = 2,
		keyName = "delaySeconds",
		name = "Delay in seconds",
		description = "The delay between images in seconds"
	)
	@Range(min = 1)
	default int delaySeconds()
	{
		return 10;
	}

	@ConfigItem(
		position = 3,
		keyName = "everyTick",
		name = "Update every game tick",
		description = "If enabled, the image will update every RuneScape game tick (0.6s), ignoring the delay setting."
	)
	default boolean everyTick() {
		return false;
	}

	@ConfigItem(
		position = 4,
		keyName = "opacity",
		name = "Opacity",
		description = "Opacity of the image in %"
	)
	default int opacity()
	{
		return 100;
	}

	@ConfigItem(
		position = 5,
		keyName = "Dimensions",
		name = "Dimensions",
		description = "Width and height of the image"
	)
	default Dimension dimension()
	{
		return new Dimension(200, 300);
	}

	@ConfigItem(
		position = 6,
		keyName = "xpos",
		name = "X Position",
		description = "X position of the image"
	)
	default int xpos() { return 9; }

	@ConfigItem(
		position = 7,
		keyName = "ypos",
		name = "Y position",
		description = "Y position of the image"
	)
	default int ypos()
	{
		return 147;
	}

}

package com.ondrad.nekos;

import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import javax.inject.Inject;
import java.awt.*;
import java.awt.image.BufferedImage;

public class nekoOverlay extends Overlay {
    private static class ImageState {
        final BufferedImage image;
        final boolean loaded;

        ImageState(BufferedImage image, boolean loaded) {
            this.image = image;
            this.loaded = loaded;
        }
    }

    private volatile ImageState imageState = new ImageState(null, false);

    @Inject
    private nekoConfig config;

    @Inject
    nekoOverlay() {
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ALWAYS_ON_TOP);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        final ImageState currentState = imageState;
        if (currentState.loaded && currentState.image != null) {
            graphics.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, (float) config.opacity() / 100));
            graphics.drawImage(
                    currentState.image,
                    config.xpos(),
                    config.ypos(),
                    config.dimension().width,
                    config.dimension().height,
                    null
            );
        }
        return null;
    }

    public void updateImage(BufferedImage newImage) {
        imageState = new ImageState(newImage, newImage != null);
    }
}
package com.ondrad.nekos;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import lombok.extern.slf4j.Slf4j;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import okhttp3.ResponseBody;

import javax.imageio.ImageIO;
import javax.inject.Inject;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;

@Slf4j
public class GetRequest {
    private final OkHttpClient client;
    private final Gson gson;

    @Inject
    public GetRequest(OkHttpClient client, Gson gson) {
        this.client = client;
        this.gson = gson;
    }

    public List<BufferedImage> GETRequest(String endpoint) throws IOException {
        List<BufferedImage> images = new ArrayList<>();
        Request apiRequest = new Request.Builder()
                .url(endpoint)
                .get()
                .build();

        try (Response apiResponse = client.newCall(apiRequest).execute()) {
            if (!apiResponse.isSuccessful()) {
                log.warn("API request failed: {}", apiResponse);
                return images;
            }

            ResponseBody body = apiResponse.body();
            if (body == null) {
                return images;
            }

            String jsonResponse = body.string();
            jsonResponse = jsonResponse.trim();

            try {
                JsonObject obj = gson.fromJson(jsonResponse, JsonObject.class);
                String imageUrl = obj.has("url") ? obj.get("url").getAsString() : null;
                if (imageUrl != null && !imageUrl.isEmpty()) {
                    BufferedImage img = fetchImage(imageUrl);
                    if (img != null) {
                        images.add(img);
                    }
                }
            } catch (Exception e) {
                log.warn("Could not parse JSON or extract image URL: {}", jsonResponse, e);
            }
        }
        return images;
    }

    private BufferedImage fetchImage(String imageUrl) throws IOException {
        Request imageRequest = new Request.Builder()
                .url(imageUrl)
                .build();
        try (Response imageResponse = client.newCall(imageRequest).execute()) {
            if (!imageResponse.isSuccessful()) {
                log.debug("Image request failed: {}", imageResponse);
                return null;
            }

            ResponseBody body = imageResponse.body();
            if (body == null) {
                return null;
            }

            try (InputStream inputStream = body.byteStream()) {
                try {
                    return ImageIO.read(inputStream);
                } catch (Exception e) {
                    log.debug("Failed to decode image: {} -> {}", imageUrl, e.getMessage());
                    return null;
                }
            }
        }
    }
}
package com.ondrad.nekos;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class nekoPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(nekoPlugin.class);
		RuneLite.main(args);
	}
}
