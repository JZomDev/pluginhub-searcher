package net.reldo.taskstracker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class TasksTrackerPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(TasksTrackerPlugin.class);
		RuneLite.main(args);
	}
}
package net.reldo.taskstracker.bosses;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public enum Boss
{
	ABYSSAL_SIRE("Abyssal Sire"),
	AGILITY_ARENA("Agility Arena"),
	AGILITY_PYRAMID("Agility Pyramid"),
	AL_KHARID_ROOFTOP("Al-Kharid Rooftop"),
	ALCHEMICAL_HYDRA("Alchemical Hydra"),
	APE_ATOLL_AGILITY("Ape Atoll Agility"),
	ARDOUGNE_ROOFTOP("Ardougne Rooftop"),
	BARBARIAN_OUTPOST("Barbarian Outpost"),
	BARROWS_CHESTS("Barrows Chests"),
	BRYOPHYTA("Bryophyta"),
	CANIFIS_ROOFTOP("Canifis Rooftop"),
	CALLISTO("Callisto"),
	CERBERUS("Cerberus"),
	CHAMBERS_OF_XERIC_CHALLENGE_MODE("Chambers of Xeric Challenge Mode"),
	CHAMBERS_OF_XERIC("Chambers of Xeric"),
	CHAOS_ELEMENTAL("Chaos Elemental"),
	CHAOS_FANATIC("Chaos Fanatic"),
	COMMANDER_ZILYANA("Commander Zilyana"),
	CORPOREAL_BEAST("Corporeal Beast"),
	CRAZY_ARCHAEOLOGIST("Crazy Archaeologist"),
	DAGANNOTH_PRIME("Dagannoth Prime"),
	DAGANNOTH_REX("Dagannoth Rex"),
	DAGANNOTH_SUPREME("Dagannoth Supreme"),
	DERANGED_ARCHAEOLOGIST("Deranged Archaeologist"),
	DORGESH_KAAN_AGILITY("Dorgesh-Kaan Agility"),
	DRAYNOR_VILLAGE_ROOFTOP("Draynor Village Rooftop"),
	FALADOR_ROOFTOP("Falador Rooftop"),
	GENERAL_GRAARDOR("General Graardor"),
	GIANT_MOLE("Giant Mole"),
	GNOME_STRONGHOLD_AGILITY("Gnome Stronghold Agility"),
	GROTESQUE_GUARDIANS("Grotesque Guardians"),
	HALLOWED_SEPULCHRE_FLOOR_1("Hallowed Sepulchre Floor 1"),
	HALLOWED_SEPULCHRE_FLOOR_2("Hallowed Sepulchre Floor 2"),
	HALLOWED_SEPULCHRE_FLOOR_3("Hallowed Sepulchre Floor 3"),
	HALLOWED_SEPULCHRE_FLOOR_4("Hallowed Sepulchre Floor 4"),
	HALLOWED_SEPULCHRE_FLOOR_5("Hallowed Sepulchre Floor 5"),
	HALLOWED_SEPULCHRE("Hallowed Sepulchre"),
	HERBIBOAR("Herbiboar"),
	HESPORI("Hespori"),
	K_RIL_TSUTSAROTH("K'ril Tsutsaroth"),
	KALPHITE_QUEEN("Kalphite Queen"),
	KING_BLACK_DRAGON("King Black Dragon"),
	KRAKEN("Kraken"),
	KREE_ARRA("Kree'arra"),
	MIMIC("Mimic"),
	NEX("Nex"),
	OBOR("Obor"),
	PENGUIN_AGILITY("Penguin Agility"),
	PHOSANI_S_NIGHTMARE("Phosani's Nightmare"),
	POLLNIVNEACH_ROOFTOP("Pollnivneach Rooftop"),
	PRIFDDINAS_AGILITY_COURSE("Prifddinas Agility Course"),
	RELLEKKA_ROOFTOP("Rellekka Rooftop"),
	SARACHNIS("Sarachnis"),
	SCORPIA("Scorpia"),
	SEERS__VILLAGE_ROOFTOP("Seers' Village Rooftop"),
	SKOTIZO("Skotizo"),
	TEMPOROSS("Tempoross"),
	THE_CORRUPTED_GAUNTLET("The Corrupted Gauntlet"),
	THE_GAUNTLET("The Gauntlet"),
	THE_NIGHTMARE("Nightmare"),
	THEATRE_OF_BLOOD_ENTRY_MODE("Theatre of Blood Entry Mode"),
	THEATRE_OF_BLOOD_HARD_MODE("Theatre of Blood Hard Mode"),
	THEATRE_OF_BLOOD("Theatre of Blood"),
	THERMONUCLEAR_SMOKE_DEVIL("Thermonuclear Smoke Devil"),
	TZHAAR_KET_RAK_S_FIFTH_CHALLENGE("TzHaar-Ket-Rak's Fifth Challenge"),
	TZHAAR_KET_RAK_S_FIRST_CHALLENGE("TzHaar-Ket-Rak's First Challenge"),
	TZHAAR_KET_RAK_S_FOURTH_CHALLENGE("TzHaar-Ket-Rak's Fourth Challenge"),
	TZHAAR_KET_RAK_S_SECOND_CHALLENGE("TzHaar-Ket-Rak's Second Challenge"),
	TZHAAR_KET_RAK_S_SIXTH_CHALLENGE("TzHaar-Ket-Rak's Sixth Challenge"),
	TZHAAR_KET_RAK_S_THIRD_CHALLENGE("TzHaar-Ket-Rak's Third Challenge"),
	TZKAL_ZUK("TzKal-Zuk"),
	TZTOK_JAD("TzTok-Jad"),
	VARROCK_ROOFTOP("Varrock Rooftop"),
	VENENATIS("Venenatis"),
	VET_ION("Vet'ion"),
	VORKATH("Vorkath"),
	WEREWOLF_AGILITY("Werewolf Agility"),
	WEREWOLF_SKULLBALL("Werewolf Skullball"),
	WILDERNESS_AGILITY("Wilderness Agility"),
	WINTERTODT("Wintertodt"),
	ZALCANO("ZALCANO"),
	ZULRAH("Zulrah");


	public String displayName;
}

package net.reldo.taskstracker.bosses;

import java.util.HashMap;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.plugins.PluginManager;

public class BossData extends HashMap<String, Integer>
{
	private static final String CHAT_COMMANDS_GROUP_NAME = "killcount";

	public BossData(PluginManager pluginManager, ConfigManager configManager)
	{
		if (pluginManager.getPlugins().stream().noneMatch(p -> p.getName().equals("Chat Commands")))
		{
			return;
		}

		for (Boss boss : Boss.values())
		{
			Integer killCount = configManager.getRSProfileConfiguration(CHAT_COMMANDS_GROUP_NAME, boss.getDisplayName().toLowerCase(), int.class);
			this.put(boss.getDisplayName(), killCount);
		}
	}
}

package net.reldo.taskstracker.data;

import com.google.gson.annotations.Expose;
import java.time.Instant;
import java.util.HashMap;
import java.util.List;
import lombok.Getter;
import lombok.Setter;
import net.reldo.taskstracker.bosses.BossData;
import net.reldo.taskstracker.quests.DiaryData;
import net.reldo.taskstracker.quests.QuestData;
import net.reldo.taskstracker.tasktypes.Task;
import net.reldo.taskstracker.tasktypes.TaskType;
import net.reldo.taskstracker.tasktypes.league3.League3TaskVarps;
import net.reldo.taskstracker.tasktypes.league3.League3Varbits;
import net.reldo.taskstracker.tasktypes.league3.League3Varps;
import net.reldo.taskstracker.tasktypes.league4.League4Varbits;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.plugins.PluginManager;

@Getter
public class Export
{
	private final Client client;

	@Expose	private final QuestData quests;
	@Expose	private final DiaryData diaries;
	@Expose	private final BossData bosses;
	@Expose	private String displayName;
	@Expose	private final int runescapeVersion;
	@Expose	private final String runeliteVersion;
	@Expose	private final long timestamp;
	@Expose	private final String taskType;
	@Expose	private final HashMap<Integer, Integer> varbits;
	@Expose	private final HashMap<Integer, Integer> varps;
	// TODO: Setter until property is ready to deprecate when web accepts varbits
	@Setter @Expose	private HashMap<String, Task> tasks;

	public Export(TaskType taskType, String runeliteVersion, Client client, PluginManager pluginManager, ConfigManager configManager)
	{
		this.client = client;
		Actor localPlayer = client.getLocalPlayer();
		if (localPlayer != null)
		{
			this.displayName = localPlayer.getName();
		}
		quests = new QuestData(client);
		diaries = new DiaryData(client);
		bosses = new BossData(pluginManager, configManager);
		runescapeVersion = client.getRevision();
		this.runeliteVersion = runeliteVersion;
		timestamp = Instant.now().toEpochMilli();
		this.taskType = taskType.name();
		varbits = getVarbits(taskType);
		varps = getVarps(taskType);
	}

	private HashMap<Integer, Integer> getVarbits(TaskType taskType)
	{
		assert client.isClientThread();

		List<Integer> varbitIds = null;
		if (taskType == TaskType.LEAGUE_3)
		{
			varbitIds = League3Varbits.getAllVarbitIds();
		}
		if (taskType == TaskType.LEAGUE_4)
		{
			varbitIds = League4Varbits.getAllVarbitIds();
		}

		if (varbitIds == null)
		{
			return null;
		}

		HashMap<Integer, Integer> varbitValueMap = new HashMap<>();
		for (int varbitId : varbitIds)
		{
			varbitValueMap.put(varbitId, client.getVarbitValue(varbitId));
		}

		return varbitValueMap;
	}

	public HashMap<Integer, Integer> getVarps(TaskType taskType)
	{
		assert client.isClientThread();

		List<Integer> varpIds = null;
		if (taskType == TaskType.LEAGUE_3)
		{
			varpIds = League3Varps.getAllVarpIds();
			varpIds.addAll(League3TaskVarps.getAllVarpIds());
		}
		if (taskType == TaskType.COMBAT)
		{
			varpIds = League3Varps.getAllVarpIds();
		}

		if (varpIds == null)
		{
			return null;
		}

		HashMap<Integer, Integer> varpValueMap = new HashMap<>();
		for (int varpId : varpIds)
		{
			varpValueMap.put(varpId, client.getVarpValue(varpId));
		}

		return varpValueMap;
	}
}

package net.reldo.taskstracker.data;

public interface CallbackCommand<T>
{
	void execute(T result);
}

package net.reldo.taskstracker.data;

import com.google.gson.Gson;
import com.google.gson.JsonParseException;
import com.google.gson.reflect.TypeToken;
import java.lang.reflect.Type;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.reldo.taskstracker.TasksTrackerPlugin;
import net.reldo.taskstracker.tasktypes.Task;
import net.reldo.taskstracker.tasktypes.TaskType;
import net.runelite.client.config.ConfigManager;

@Slf4j
public class TrackerDataStore
{
	public static final String CONFIG_TASKS_PREFIX = "tasks";
	public static final String CONFIG_GROUP_PREFIX_SEPARATOR = "-";
	public static final String CONFIG_GROUP_NAME = TasksTrackerPlugin.CONFIG_GROUP_NAME;

	private Gson gson;
	private final ConfigManager configManager;


	@Inject
	public TrackerDataStore(ConfigManager configManager, Gson gson)
	{
		this.configManager = configManager;
		this.gson = gson.newBuilder()
			.excludeFieldsWithoutExposeAnnotation()
			.registerTypeAdapter(float.class, new LongSerializer())
			.create();
	}

	public HashMap<Integer, Task> loadTaskTypeFromConfig(TaskType taskType)
	{
		log.debug("loadTaskTypeFromConfig {}", taskType.getDisplayString());
		String key = CONFIG_TASKS_PREFIX + CONFIG_GROUP_PREFIX_SEPARATOR + taskType.name();
		String jsonString = configManager.getRSProfileConfiguration(CONFIG_GROUP_NAME, key);
		if (jsonString == null)
		{
			log.debug("No save information for task type {}, returning empty", taskType.getDisplayString());
			return new HashMap<>();
		}

		Type taskClassType = taskType.getClassType();
		Type deserializeType = TypeToken.getParameterized(HashMap.class, Integer.class, taskClassType).getType();
		try
		{
			return this.gson.fromJson(jsonString, deserializeType);
		}
		catch (JsonParseException ex)
		{
			log.error("{} {} json invalid. All is lost", CONFIG_GROUP_NAME, key, ex);
			configManager.unsetRSProfileConfiguration(CONFIG_GROUP_NAME, key);
			return new HashMap<>();
		}
	}

	public void saveTaskTypeToConfig(TaskType taskType, Collection<Task> tasks)
	{
		log.debug("saveTaskTypeToConfig");
		Map<Integer, Task> tasksWithData = tasks.stream()
			.filter(task -> task.getCompletedOn() != 0 || task.getIgnoredOn() != 0 || task.getTrackedOn() != 0)
			.collect(Collectors.<Task, Integer, Task>toMap(Task::getId, task -> task));

		String configValue = this.gson.toJson(tasksWithData);
		configManager.setRSProfileConfiguration(CONFIG_GROUP_NAME, CONFIG_TASKS_PREFIX + CONFIG_GROUP_PREFIX_SEPARATOR + taskType.name(), configValue);
	}
}

package net.reldo.taskstracker.data;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Type;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.reldo.taskstracker.tasktypes.Task;
import net.reldo.taskstracker.tasktypes.TaskType;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

@Singleton
@Slf4j
public class TaskDataClient
{
	@Inject	private OkHttpClient okHttpClient;
	@Inject private Gson gson;

	private static final String BASE_URL = "https://raw.githubusercontent.com/osrs-reldo/task-json-store/main/";
	private static final String JSON_MIN_PATH = BASE_URL + "json/min/";

	public void loadTaskSourceData(TaskType taskType, CallbackCommand<ArrayList<Task>> callback)
	{
		Type classType = taskType.getClassType();
		Type listType = TypeToken.getParameterized(ArrayList.class, classType).getType();

		getTaskJson(taskType.getDataFileName(), jsonResponse -> {
			ArrayList<Task> result = this.gson.fromJson(new InputStreamReader(jsonResponse, StandardCharsets.UTF_8), listType);
			callback.execute(result);
		});
	}

	private void getTaskJson(String jsonName, CallbackCommand<InputStream> command)
	{
		try
		{
			String url = JSON_MIN_PATH + jsonName;
			log.debug("Fetching task json {} from {}...", jsonName, url);
			Request request = new Request.Builder()
				.url(url)
				.build();
			okHttpClient.newCall(request).enqueue(new Callback()
			{
				@Override
				public void onFailure(@NonNull Call call, @NonNull IOException e)
				{
					log.error("Error retrieving task json {}", jsonName, e);
				}

				@Override
				public void onResponse(@NonNull Call call,@NonNull Response response)
				{
					if (response.isSuccessful())
					{
						if (response.body() == null)
						{
							log.error("Task json request returned no body");
							response.close();
							return;
						}

						log.debug("Task json {} fetched successfully, executing callback", jsonName);
						command.execute(response.body().byteStream());
					} else {
						String unsuccessful = "Task json request unsuccessful with status {}" + response.code();
						if (response.body() != null)
						{
							unsuccessful += " and body \n" + response.body();
						}
						log.error(unsuccessful);
					}
					response.close();
				}
			});
		}
		catch (IllegalArgumentException e)
		{
			log.error("Failed to get task json: {}", e.getLocalizedMessage());
		}
	}
}
package net.reldo.taskstracker.data;

import com.google.gson.JsonElement;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import java.lang.reflect.Type;
import java.text.DecimalFormat;

public class LongSerializer implements JsonSerializer<Long>
{
	@Override
	public JsonElement serialize(Long value, Type type, JsonSerializationContext jsonSerializationContext)
	{
		return new JsonPrimitive(new DecimalFormat("#").format(value));
	}
}

package net.reldo.taskstracker.data.reldo;

import java.util.HashMap;
import lombok.Data;

@Data
public class ReldoImport
{
	public int version;
	public String rsn;
	private HashMap<Integer, ReldoTaskSave> tasks;
}

package net.reldo.taskstracker.data.reldo;

import lombok.Data;

@Data
public class ReldoTaskSave
{
	long completed;
	long todo;
	long ignored;
	int order;
	String notes;
	long lastUpdated;
}

package net.reldo.taskstracker;

import java.awt.Color;
import java.net.URL;

public class Util
{
	public static String HTML_LINE_BREAK = "<br>";

	public static String wrapWithHtml(String text)
	{
		return "<html>" + text + "</html>";
	}

	public static String wrapWithWrappingParagraph(String text, int width)
	{
		return "<p width=\"" + width + "\">" + text + "</p>";
	}

	public static String wrapWithBold(String text)
	{
		return "<b>" + text + "</b>";
	}

	public static String imageTag(URL url)
	{
		return "<img src=\"" + url + "\">";
	}

	public static String colorTag(String color, String text)
	{
		return "<span style=\"color: " + color + "\">" + text + "</span>";
	}

	public static String colorTag(Color color, String text)
	{
		String buf = Integer.toHexString(color.getRGB());
		String hex = "#" + buf.substring(buf.length() - 6);
		return colorTag(hex, text);
	}
}

package net.reldo.taskstracker.config;


public class ConfigValues {

    public enum CompletedFilterValues
    {
        COMPLETE_AND_INCOMPLETE,
        COMPLETE,
        INCOMPLETE;
    }

    public enum TrackedFilterValues
    {
        TRACKED_AND_UNTRACKED,
        TRACKED,
        UNTRACKED;
    }

    public enum IgnoredFilterValues
    {
        NOT_IGNORED,
        IGNORED_AND_NOT_IGNORED,
        IGNORED;
    }

    public enum TaskListTabs
    {
        TRACKED,
        ALL,
        CUSTOM;
    }

}

package net.reldo.taskstracker;

import net.reldo.taskstracker.config.ConfigValues;
import net.reldo.taskstracker.tasktypes.TaskType;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup(TasksTrackerPlugin.CONFIG_GROUP_NAME)
public interface TasksTrackerConfig extends Config
{
	@ConfigItem(
		position = 10,
		keyName = "untrackUponCompletion",
		name = "Untrack Tasks Upon Completion",
		description = "Configures whether completed tasks should also automatically untracked when the task is completed."
	)
	default boolean untrackUponCompletion()
	{
		return false;
	}

    @ConfigItem(
            position = 11,
            keyName = "filterPanelCollapsible",
            name = "Filter Panels Collapsible",
            description = "Shows button that allows filter panels to be hidden."
    )
    default boolean filterPanelCollapsible()
    {
        return true;
    }

    @ConfigItem(
            position = 12,
            keyName = "saveAreaFilterState", //@todo generalise this to all sub-filters
            name = "Save Area Filter State",
            description = "Configures whether the state of area filters should be saved and recalled when switching task type or restarting the plugin."
    )
    default boolean saveAreaFilterState()
    {
        return true;
    }

    @ConfigItem(
            position = 100,
            keyName = "completedFilter",
            name = "Completed Tasks Filter",
            description = "Configures whether completed tasks should be displayed.",
            hidden = true
    )
    default ConfigValues.CompletedFilterValues completedFilter()
    {
        return ConfigValues.CompletedFilterValues.COMPLETE_AND_INCOMPLETE;
    }

    @ConfigItem(
            position = 101,
            keyName = "trackedFilter",
            name = "Tracked Tasks Filter",
            description = "Configures whether tracked tasks should be displayed.",
            hidden = true
    )
    default ConfigValues.TrackedFilterValues trackedFilter()
    {
        return ConfigValues.TrackedFilterValues.TRACKED_AND_UNTRACKED;
    }

    @ConfigItem(
            position = 102,
            keyName = "ignoredFilter",
            name = "Ignored Tasks Filter",
            description = "Configures whether ignored tasks should be displayed.",
            hidden = true
    )
    default ConfigValues.IgnoredFilterValues ignoredFilter()
    {
        return ConfigValues.IgnoredFilterValues.NOT_IGNORED;
    }

    @ConfigItem(
            position = 103,
            keyName = "taskListTab",
            name = "Selected Task List Tab",
            description = "Configures the currently selected tab on the task list.",
            hidden = true
    )
    default ConfigValues.TaskListTabs taskListTab()
    {
        return ConfigValues.TaskListTabs.ALL;
    }

    @ConfigItem(
            position = 104,
            keyName = "skillFilter",
            name = "Skills Filter",
            description = "Configures the skills to filter tasks on.",
            hidden = true
    )
    default String skillFilter()
    {
        return "";
    }

    @ConfigItem(
            position = 105,
            keyName = "tierFilter",
            name = "Tier Filter",
            description = "Configures the tiers to filter tasks on.",
            hidden = true
    )
    default String tierFilter()
    {
        return "";
    }

	@ConfigItem(
		position = 106,
		keyName = "taskType",
		name = "Task Type",
		description = "Configures the task type which is displayed in the panel.",
		hidden = true
	)
	default TaskType taskType()
	{
		return TaskType.COMBAT;
	}

    @ConfigItem(
            position = 107,
            keyName = "areaFilter",
            name = "Area Filter",
            description = "Configures the areas to filter tasks on.",
            hidden = true
    )
    default String areaFilter()
    {
        return "";
    }

    @ConfigItem(
            position = 108,
            keyName = "categoryFilter",
            name = "Category Filter",
            description = "Configures the category to filter tasks on.",
            hidden = true
    )
    default String categoryFilter()
    {
        return "";
    }
}

package net.reldo.taskstracker;

import com.google.gson.Gson;
import com.google.inject.Provides;
import java.awt.Color;
import java.awt.Toolkit;
import java.awt.datatransfer.StringSelection;
import java.awt.image.BufferedImage;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Named;
import javax.swing.JDialog;
import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.reldo.taskstracker.data.CallbackCommand;
import net.reldo.taskstracker.data.Export;
import net.reldo.taskstracker.data.LongSerializer;
import net.reldo.taskstracker.data.TaskDataClient;
import net.reldo.taskstracker.data.TrackerDataStore;
import net.reldo.taskstracker.data.reldo.ReldoImport;
import net.reldo.taskstracker.panel.TasksTrackerPluginPanel;
import net.reldo.taskstracker.tasktypes.Task;
import net.reldo.taskstracker.tasktypes.TaskManager;
import net.reldo.taskstracker.tasktypes.TaskType;
import net.reldo.taskstracker.tasktypes.TasksSummary;
import net.reldo.taskstracker.tasktypes.combattask.CombatTaskVarps;
import net.reldo.taskstracker.tasktypes.league3.League3TaskVarps;
import net.reldo.taskstracker.tasktypes.league4.League4TaskVarps;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneScapeProfileType;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

@Slf4j
@PluginDescriptor(
	name = "Tasks Tracker"
)
public class TasksTrackerPlugin extends Plugin
{
	public static final String CONFIG_GROUP_NAME = "tasks-tracker";

	public int[] playerSkills;
	public HashMap<TaskType, TaskManager> taskManagers = new HashMap<>();

	public String taskTextFilter;

	public TasksTrackerPluginPanel pluginPanel;

	private static final long VARP_UPDATE_THROTTLE_DELAY_MS = 7 * 1000;

	private boolean forceUpdateVarpsFlag = false;
	private Set<Integer> varpIdsToUpdate = new HashSet<>();
	private long lastVarpUpdate = 0;
	private NavigationButton navButton;
	private RuneScapeProfileType currentProfileType;

	@Inject	@Named("runelite.version") private String runeliteVersion;
	@Inject private Gson gson;
	@Inject	private Client client;
	@Inject	private SpriteManager spriteManager;
	@Inject	private PluginManager pluginManager;
	@Inject	private SkillIconManager skillIconManager;
	@Inject	private ClientToolbar clientToolbar;
	@Inject	private ClientThread clientThread;
	@Inject	private ChatMessageManager chatMessageManager;
	@Getter	@Inject	private ConfigManager configManager;
	@Getter @Inject	private TasksTrackerConfig config;

	@Inject private TaskDataClient taskDataClient;
	@Inject private TrackerDataStore trackerDataStore;

	@Provides
	TasksTrackerConfig getConfig(ConfigManager configManager)
	{
		return configManager.getConfig(TasksTrackerConfig.class);
	}

	@Override
	protected void startUp()
	{
		forceUpdateVarpsFlag = false;

		pluginPanel = new TasksTrackerPluginPanel(this, config, clientThread, spriteManager, skillIconManager);

		boolean isLoggedIn = isLoggedInState(client.getGameState());
		pluginPanel.setLoggedIn(isLoggedIn);

		// Load task managers
		for (TaskType taskType : TaskType.values())
		{
			TaskManager taskManager = new TaskManager(taskType, taskDataClient);
			taskManagers.put(taskType, taskManager);

			taskManager.asyncLoadTaskSourceData((tasks) -> {
				// If the player is already logged in when the plugin is started, treat like a new login
				if (isLoggedIn && taskType == config.taskType())
				{
					forceUpdateVarpsFlag = true;
				}
			});
		}

		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "panel_icon.png");
		navButton = NavigationButton.builder()
			.tooltip("Task Tracker")
			.icon(icon)
			.priority(5)
			.panel(pluginPanel)
			.build();
		clientToolbar.addNavigation(navButton);

		log.info("Tasks Tracker started!");
	}

	@Override
	protected void shutDown()
	{
		pluginPanel = null;
		taskManagers = new HashMap<>();
		clientToolbar.removeNavigation(navButton);
		log.info("Tasks Tracker stopped!");
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged varbitChanged)
	{
		if (forceUpdateVarpsFlag)
		{
			// Force update is coming on next game tick, so ignore varbit change events
			return;
		}
		varpIdsToUpdate.add(varbitChanged.getVarpId());
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged)
	{
		if (!configChanged.getGroup().equals(CONFIG_GROUP_NAME))
		{
			return;
		}
		log.debug("onConfigChanged {} {}", configChanged.getKey(), configChanged.getNewValue());
		if (configChanged.getKey().equals("untrackUponCompletion") && config.untrackUponCompletion())
		{
			forceVarpUpdate();
		}

		if (configChanged.getKey().equals("filterPanelCollapsible"))
		{
			pluginPanel.redraw();
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		log.debug("onGameStateChanged {}", gameStateChanged.getGameState().toString());
		GameState newGameState = gameStateChanged.getGameState();
		RuneScapeProfileType newProfileType = RuneScapeProfileType.getCurrent(client);

		SwingUtilities.invokeLater(() -> pluginPanel.setLoggedIn(isLoggedInState(newGameState)));

		// Logged in
		if (newGameState == GameState.LOGGING_IN)
		{
			forceUpdateVarpsFlag = true;
		}
		// Changed game mode
		if (isLoggedInState(newGameState) && currentProfileType != null && currentProfileType != newProfileType)
		{
			forceUpdateVarpsFlag = true;
		}

		currentProfileType = newProfileType;
	}

	private boolean isLoggedInState(GameState gameState)
	{
		return gameState == GameState.LOGGED_IN || gameState == GameState.HOPPING || gameState == GameState.LOADING;
	}

	@Subscribe
	public void onGameTick(GameTick gameTick)
	{
		if (forceUpdateVarpsFlag)
		{
			log.debug("loginFlag game tick");
			loadSavedTaskTypeData(config.taskType());
			forceVarpUpdate();
			SwingUtilities.invokeLater(() -> pluginPanel.redraw());
			forceUpdateVarpsFlag = false;
		}

		// Flush throttled varp updates
		long currentTimeEpoch = System.currentTimeMillis();
		if (currentTimeEpoch - lastVarpUpdate > VARP_UPDATE_THROTTLE_DELAY_MS)
		{
			flushVarpUpdates(varpIdsToUpdate);
			varpIdsToUpdate = new HashSet<>();
			lastVarpUpdate = currentTimeEpoch;
		}

		int[] newSkills = client.getRealSkillLevels();
		boolean changed = !Arrays.equals(playerSkills, newSkills);
		if (changed)
		{
			playerSkills = client.getRealSkillLevels();
			SwingUtilities.invokeLater(() -> pluginPanel.refresh(null));
		}
	}

	public void refresh()
	{
		pluginPanel.refresh(null);
	}

	public void saveCurrentTaskData()
	{
		log.debug("saveCurrentTaskData");
		trackerDataStore.saveTaskTypeToConfig(config.taskType(), taskManagers.get(config.taskType()).tasks.values());
	}

	public void openImportJsonDialog()
	{
		JOptionPane optionPane = new JOptionPane("Paste import data into the text field below to import task tracker data.", JOptionPane.INFORMATION_MESSAGE);
		optionPane.setWantsInput(true);
		JDialog inputDialog = optionPane.createDialog(pluginPanel, "Import Tasks Input");
		inputDialog.setAlwaysOnTop(true);
		inputDialog.setVisible(true);

		if(optionPane.getInputValue().equals("") || optionPane.getInputValue().equals("uninitializedValue"))
		{
			showMessageBox("Import Tasks Error", "Input was empty so no data has been imported.", JOptionPane.ERROR_MESSAGE, false);
			return;
		}

		String json = "";
		ReldoImport reldoImport;
		try
		{
			json = (String) optionPane.getInputValue();
			reldoImport = this.gson.fromJson(json, ReldoImport.class);
		}
		catch (Exception ex)
		{
			showMessageBox("Import Tasks Error", "There was an issue importing task tracker data. " + ex.getMessage(), JOptionPane.ERROR_MESSAGE, false);
			log.error("There was an issue importing task tracker data.", ex);
			log.debug("reldoImport json: {}", json);
			return;
		}

		optionPane = new JOptionPane("Importing tasks will overwrite task tracker settings and cannot be undone. Are you sure you want to import tasks?", JOptionPane.WARNING_MESSAGE, JOptionPane.YES_NO_OPTION);
		JDialog confirmDialog = optionPane.createDialog(pluginPanel, "Import Tasks Overwrite Confirmation");
		confirmDialog.setAlwaysOnTop(true);
		confirmDialog.setVisible(true);

		Object selectedValue = optionPane.getValue();
		if (selectedValue == null) return;

		if (selectedValue.equals(JOptionPane.YES_OPTION))
		{
			// FIXME: Hardcoded for league 4 only
			reldoImport.getTasks().forEach((id, reldoTaskSave) -> {
				Task task = taskManagers.get(TaskType.LEAGUE_4).tasks.get(id);
				task.loadReldoSave(reldoTaskSave);
			});
			trackerDataStore.saveTaskTypeToConfig(TaskType.LEAGUE_4, taskManagers.get(TaskType.LEAGUE_4).tasks.values());
			pluginPanel.redraw();
		}
	}

	public void sendTotalsToChat()
	{
		TasksSummary summary = taskManagers.get(config.taskType()).getSummary();
		int trackedTasks = summary.trackedTasksCount;
		int trackedPoints = summary.trackedTasksPoints;

		final String message = new ChatMessageBuilder()
			.append(Color.BLACK, String.format("Task Tracker - Tracked Tasks: %s | Tracked Points: %s", trackedTasks, trackedPoints))
			.build();

		chatMessageManager.queue(
			QueuedMessage.builder()
				.type(ChatMessageType.CONSOLE)
				.runeLiteFormattedMessage(message)
				.build());
	}

	public void copyJsonToClipboard(TaskType taskType)
	{
		clientThread.invokeLater(() -> {
			String exportJson = exportToJson(taskType);
			final StringSelection stringSelection = new StringSelection(exportJson);
			Toolkit.getDefaultToolkit().getSystemClipboard().setContents(stringSelection, null);

			String message = "Exported " + taskType.getDisplayString() + " data copied to clipboard!";

			showMessageBox("Data Exported!", message, JOptionPane.INFORMATION_MESSAGE, true);
		});
	}

	private void loadSavedTaskTypeData(TaskType taskType)
	{
		log.debug("loadSavedTaskTypeData {}", taskType.name());
		HashMap<Integer, Task> taskData = trackerDataStore.loadTaskTypeFromConfig(taskType);

		taskManagers.get(taskType).applyTrackerSave(taskData);

		trackerDataStore.saveTaskTypeToConfig(taskType, taskManagers.get(taskType).tasks.values());
	}

	private void forceVarpUpdate()
	{
		log.debug("forceVarpUpdate");
		List<Integer> allVarbitIds = new ArrayList<>();
		allVarbitIds.addAll(League4TaskVarps.getIdToVarpMap().keySet());
		allVarbitIds.addAll(CombatTaskVarps.getIdToVarpMap().keySet());
		allVarbitIds.forEach((id) -> this.processVarpAndUpdateTasks(id, processed -> {
			if (processed)
			{
				this.saveCurrentTaskData();
			}
		}));
	}

	private void flushVarpUpdates(Set<Integer> varpIds)
	{
		log.debug("Flushing throttled varp updates {}", varpIds);
		varpIds.forEach((id) -> this.processVarpAndUpdateTasks(id, processed -> {
			if (processed)
			{
				this.saveCurrentTaskData();
			}
		}));
	}

	private void processVarpAndUpdateTasks(int varpId, CallbackCommand<Boolean> resultCallback)
	{
		int ordinal = -1;
		TaskType taskType = null;

		League3TaskVarps league3Varp = League3TaskVarps.getIdToVarpMap().get(varpId);
		if (league3Varp != null)
		{
			ordinal = league3Varp.ordinal();
			taskType = TaskType.LEAGUE_3;
		}

		League4TaskVarps league4Varp = League4TaskVarps.getIdToVarpMap().get(varpId);
		if (league4Varp != null)
		{
			ordinal = league4Varp.ordinal();
			taskType = TaskType.LEAGUE_4;
		}

		CombatTaskVarps combatTaskVarp = CombatTaskVarps.getIdToVarpMap().get(varpId);
		if (combatTaskVarp != null)
		{
			ordinal = combatTaskVarp.ordinal();
			taskType = TaskType.COMBAT;
		}

		if (taskType == null)
		{
			resultCallback.execute(false);
			return;
		}

		HashMap<Integer, Boolean> completionById = new HashMap<>();

		int finalOrdinal = ordinal;
		TaskType finalTaskType = taskType;
		clientThread.invokeLater(() -> {
			// We don't use the VarbitChanged event value because it may not be the latest value
			// Instead we refetch the varp value
			BigInteger varpValue = BigInteger.valueOf(client.getVarpValue(varpId));
			log.debug("processVarpAndUpdateTasks {} {}", varpId, varpValue);
			int minTaskId = finalOrdinal * 32;
			int maxTaskId = minTaskId + 31;

			for (int i = minTaskId; i <= maxTaskId; i++)
			{
				boolean isTaskVarbitCompleted;
				int bitIndex = i % 32;
				try
				{
					isTaskVarbitCompleted = varpValue.testBit(bitIndex);
				}
				catch (IllegalArgumentException ex)
				{
					log.error("Bit test failed {} {}", varpId, bitIndex, ex);
					isTaskVarbitCompleted = false;
				}

				completionById.put(i, isTaskVarbitCompleted);
			}

			for (Map.Entry<Integer, Boolean> taskCompletion : completionById.entrySet())
			{
				int id = taskCompletion.getKey();
				boolean completed = taskCompletion.getValue();
				Task task = taskManagers.get(finalTaskType).tasks.get(id);
				if (task == null)
				{
					continue;
				}

				task.setCompleted(completed);
				if (completed && config.untrackUponCompletion())
				{
					task.setTracked(false);
				}
				SwingUtilities.invokeLater(() -> pluginPanel.refresh(task));
			}

			resultCallback.execute(true);
		});
	}

	private String exportToJson(TaskType taskType)
	{
		Gson gson = this.gson.newBuilder()
			.excludeFieldsWithoutExposeAnnotation()
			.registerTypeAdapter(float.class, new LongSerializer())
			.create();

		if (taskType == null)
		{
			return gson.toJson(taskManagers);
		}
		else
		{
			Export export = new Export(taskType, runeliteVersion, client, pluginManager, configManager);

			// TODO: This is a holdover for tasks until the web is ready to accept varbits
			// TODO: We already export the varbits, so ready to go
			HashMap<String, Task> tasksById = new HashMap<>();
			taskManagers.get(taskType).tasks.values().forEach((task) -> tasksById.put(String.valueOf(task.getId()), task));
			export.setTasks(tasksById);

			return gson.toJson(export);
		}
	}

	private void showMessageBox(final String title, final String message, int messageType, boolean showOpenLeagueTools)
	{
		SwingUtilities.invokeLater(() -> {
			JOptionPane optionPane;
			JDialog dialog;

			if(showOpenLeagueTools)
			{
				String[] options = {"Open OS League Tools", "Ok"};

				optionPane = new JOptionPane(message, messageType, JOptionPane.YES_NO_OPTION, null, options, options[1]);
			}
			else
			{
				optionPane = new JOptionPane(message, messageType);
			}

			dialog = optionPane.createDialog(pluginPanel, title);
			dialog.setAlwaysOnTop(true);
			dialog.setVisible(true);

			Object selectedValue = optionPane.getValue();
			if(selectedValue == null) return;

			if (selectedValue.equals("Open OS League Tools"))
			{
				LinkBrowser.browse("https://www.osleague.tools/tracker?open=import&tab=tasks");
			}
		});
	}
}

package net.reldo.taskstracker.panel;

import java.util.ArrayList;
import java.util.List;
import javax.swing.BoxLayout;
import javax.swing.border.EmptyBorder;
import net.reldo.taskstracker.TasksTrackerPlugin;
import net.reldo.taskstracker.panel.components.FixedWidthPanel;
import net.reldo.taskstracker.panel.subfilters.*;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.ColorScheme;

public class SubFilterPanel extends FixedWidthPanel
{
    private final List<FilterButtonPanel> filterPanels = new ArrayList<>();

    public SubFilterPanel(TasksTrackerPlugin plugin, SpriteManager spriteManager)
    {
        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        setBorder(new EmptyBorder(0, 0, 0, 0));
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setVisible(false);

        addFilterButtonPanel(new SkillFilterPanel(plugin));

        addFilterButtonPanel(new DifficultyFilterPanel(plugin, spriteManager));

        addFilterButtonPanel(new AreaFilterPanel(plugin, spriteManager));

//  @todo Category filters disabled due to lack of data
//        addFilterButtonPanel(new CategoryFilterPanel(plugin, spriteManager));
    }

    public void addFilterButtonPanel(FilterButtonPanel panel)
    {
        filterPanels.add(panel);
        add(panel);
    }

    public void redraw()
    {
        filterPanels.forEach(FilterButtonPanel::redraw);
    }
}

package net.reldo.taskstracker.panel;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JTabbedPane;
import javax.swing.JToggleButton;
import javax.swing.SwingConstants;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.plaf.basic.BasicButtonUI;
import lombok.extern.slf4j.Slf4j;
import net.reldo.taskstracker.TasksTrackerConfig;
import net.reldo.taskstracker.TasksTrackerPlugin;
import net.reldo.taskstracker.config.ConfigValues;
import net.reldo.taskstracker.panel.components.SearchBox;
import net.reldo.taskstracker.panel.components.TriToggleButton;
import net.reldo.taskstracker.tasktypes.Task;
import net.reldo.taskstracker.tasktypes.TaskType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

@Slf4j
public class LoggedInPanel extends JPanel  implements ChangeListener
{
	public TaskListPanel taskListPanel;
	private JComboBox<TaskType> taskTypeDropdown;

	private final TasksTrackerPlugin plugin;
	private final ClientThread clientThread;
	private final SpriteManager spriteManager;
	private final SkillIconManager skillIconManager;
	private final TasksTrackerConfig config;

	// Filter buttons
	private final TriToggleButton completedFilterBtn = new TriToggleButton();
	private final TriToggleButton trackedFilterBtn = new TriToggleButton();
	private final TriToggleButton ignoredFilterBtn = new TriToggleButton();
	private final JPanel titlePanel = new JPanel();

	private final String completeBtnPath = "panel/components/complete_button/style_2a/";
	private final Icon COMPLETE_INCOMPLETE_ICON = new ImageIcon(ImageUtil.loadImageResource(TasksTrackerPlugin.class, completeBtnPath + "complete_and_incomplete_icon.png"));
	private final Icon COMPLETE_ONLY_ICON = new ImageIcon(ImageUtil.loadImageResource(TasksTrackerPlugin.class, completeBtnPath + "complete_only_icon.png"));
	private final Icon INCOMPLETE_ONLY_ICON = new ImageIcon(ImageUtil.loadImageResource(TasksTrackerPlugin.class, completeBtnPath + "incomplete_only_icon.png"));

	private final String ignoredBtnPath = "panel/components/ignored_button/";
	private final Icon VISIBLE_ICON = new ImageIcon(ImageUtil.loadImageResource(TasksTrackerPlugin.class, ignoredBtnPath + "visible_icon.png"));
	private final Icon INVISIBLE_ICON = new ImageIcon(ImageUtil.loadImageResource(TasksTrackerPlugin.class, ignoredBtnPath + "invisible_icon.png"));
	private final BufferedImage semivisibleimg = ImageUtil.loadImageResource(TasksTrackerPlugin.class, ignoredBtnPath + "semivisible_icon.png");
	private final Icon SEMIVISIBLE_ICON = new ImageIcon(ImageUtil.alphaOffset(semivisibleimg, -180));

	private final String trackedBtnPath = "panel/components/tracked_button/";
	private final Icon TRACKED_UNTRACKED_ICON = new ImageIcon(ImageUtil.loadImageResource(TasksTrackerPlugin.class, trackedBtnPath + "tracked_and_untracked_icon.png"));
	private final Icon TRACKED_ONLY_ICON = new ImageIcon(ImageUtil.loadImageResource(TasksTrackerPlugin.class, trackedBtnPath + "tracked_icon.png"));
	private final Icon UNTRACKED_ONLY_ICON = new ImageIcon(ImageUtil.loadImageResource(TasksTrackerPlugin.class, trackedBtnPath + "untracked_icon.png"));

	// Task list tabs
	private final JTabbedPane tabbedPane = new JTabbedPane();

	// sub-filter panel
	private SubFilterPanel subFilterPanel;
	private final JToggleButton collapseBtn = new JToggleButton();

	private final String expandBtnPath = "panel/components/";
	private final BufferedImage collapseImg = ImageUtil.loadImageResource(TasksTrackerPlugin.class, expandBtnPath + "filter_menu_collapsed.png");
	private final Icon MENU_COLLAPSED_ICON = new ImageIcon(ImageUtil.alphaOffset(collapseImg, -180));
	private final Icon MENU_ICON_HOVER = new ImageIcon(collapseImg);
	private final Icon MENU_EXPANDED_ICON = new ImageIcon(ImageUtil.loadImageResource(TasksTrackerPlugin.class, expandBtnPath + "filter_menu_expanded.png"));

	public LoggedInPanel(TasksTrackerPlugin plugin, TasksTrackerConfig config, ClientThread clientThread, SpriteManager spriteManager, SkillIconManager skillIconManager)
	{
		super(false);
		this.plugin = plugin;
		this.clientThread = clientThread;
		this.spriteManager = spriteManager;
		this.skillIconManager = skillIconManager;
		this.config = config;

		createPanel(this);
	}

	@Override
	public Dimension getPreferredSize()
	{
		return this.getParent().getSize();
	}

	public void redraw()
	{
		subFilterPanel.redraw();
		updateCollapseButtonText();

		taskListPanel.redraw();
	}

	public void refresh(Task task)
	{
		if(task == null)
			updateCollapseButtonText();

		taskListPanel.refresh(task);
	}

	private void createPanel(JPanel parent)
	{
		parent.setLayout(new BorderLayout());
		parent.setBackground(ColorScheme.DARK_GRAY_COLOR);

		taskListPanel = new TaskListPanel(plugin, clientThread, spriteManager, skillIconManager);

		parent.add(getNorthPanel(), BorderLayout.NORTH);
		parent.add(getCenterPanel(), BorderLayout.CENTER);
		parent.add(getSouthPanel(), BorderLayout.SOUTH);

		loadAndApplyFilters(config.taskListTab());
		if(config.taskListTab().equals(ConfigValues.TaskListTabs.TRACKED))
		{
			trackedFilterBtn.setState(1);
			trackedFilterBtn.setEnabled(false);
			plugin.getConfigManager().setConfiguration(TasksTrackerPlugin.CONFIG_GROUP_NAME, "trackedFilter", ConfigValues.TrackedFilterValues.TRACKED);
		}
	}

	private JPanel getCenterPanel() {
		// wrapper for the task list and tab buttons
		final JPanel taskListPanel = new JPanel(new BorderLayout());
		taskListPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		taskListPanel.setBorder(new MatteBorder(0, 0, 1, 0, ColorScheme.MEDIUM_GRAY_COLOR));

		tabbedPane.setBorder(new EmptyBorder(0,0,0,0));
		tabbedPane.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH,24));

		tabbedPane.addTab("Tracked Tasks", emptyPanel());
		tabbedPane.addTab("All Tasks", emptyPanel());
		tabbedPane.addTab("Custom", emptyPanel());

		taskListPanel.add(tabbedPane, BorderLayout.NORTH);
		taskListPanel.add(this.taskListPanel, BorderLayout.CENTER);

		// set initial filter states to "complete and incomplete", "tracked and untracked", "not ignored"
		Map<String, Integer> filterStates = new HashMap<>();
		filterStates.put("completed",0);
		filterStates.put("tracked",0);
		filterStates.put("ignored",0);
		for(ConfigValues.TaskListTabs tab : ConfigValues.TaskListTabs.values())
		{
			filterStore.put(tab, filterStates);
		}

		tabbedPane.setSelectedIndex(config.taskListTab().ordinal());
		tabbedPane.addChangeListener(this);

		return taskListPanel;
	}

	@Override
	public void stateChanged(ChangeEvent e)
	{
		ConfigValues.TaskListTabs newTab = ConfigValues.TaskListTabs.values()[tabbedPane.getSelectedIndex()];
		changeTab(newTab);

		if(newTab.equals(ConfigValues.TaskListTabs.TRACKED))
		{
			trackedFilterBtn.setState(1);
			trackedFilterBtn.setEnabled(false);
			plugin.getConfigManager().setConfiguration("tasks-tracker", "taskListTab", ConfigValues.TaskListTabs.TRACKED);
			filterButtonAction("tracked");
		}
		else
		{
			plugin.getConfigManager().setConfiguration("tasks-tracker", "taskListTab", newTab);
			plugin.refresh();
		}
	}

	private JPanel emptyPanel()
	{
		JPanel emptyPanel = new JPanel();
		emptyPanel.setBorder(new EmptyBorder(0,0,0,0));
		emptyPanel.setPreferredSize(new Dimension(0,0));
		emptyPanel.setBackground(ColorScheme.MEDIUM_GRAY_COLOR.darker());
		emptyPanel.setVisible(false);
		return emptyPanel;
	}

	private void changeTab(ConfigValues.TaskListTabs newTab)
	{
		saveFilters();
		resetFilters();
		loadAndApplyFilters(newTab);
	}

	private final Map<ConfigValues.TaskListTabs, Map<String, Integer>> filterStore = new HashMap<>();

	private void saveFilters()
	{
		ConfigValues.TaskListTabs tab = config.taskListTab();

		Map<String, Integer> filterStates = new HashMap<>();
		filterStates.put("completed",config.completedFilter().ordinal());
		filterStates.put("tracked",config.trackedFilter().ordinal());
		filterStates.put("ignored",config.ignoredFilter().ordinal());

		filterStore.put(tab, filterStates);
	}

	private void resetFilters()
	{
		completedFilterBtn.setEnabled(true);
		trackedFilterBtn.setEnabled(true);
		ignoredFilterBtn.setEnabled(true);
	}

	private void loadAndApplyFilters(ConfigValues.TaskListTabs tab)
	{
		Map<String,Integer> filterStates = filterStore.get(tab);

		if(filterStates == null) return;

		Enum configValue;

		completedFilterBtn.setState(filterStates.get("completed"));
		trackedFilterBtn.setState(filterStates.get("tracked"));
		ignoredFilterBtn.setState(filterStates.get("ignored"));

		configValue = ConfigValues.CompletedFilterValues.values()[completedFilterBtn.getState()];
		plugin.getConfigManager().setConfiguration(TasksTrackerPlugin.CONFIG_GROUP_NAME, "completedFilter", configValue);

		configValue = ConfigValues.TrackedFilterValues.values()[trackedFilterBtn.getState()];
		plugin.getConfigManager().setConfiguration(TasksTrackerPlugin.CONFIG_GROUP_NAME, "trackedFilter", configValue);

		configValue = ConfigValues.IgnoredFilterValues.values()[ignoredFilterBtn.getState()];
		plugin.getConfigManager().setConfiguration(TasksTrackerPlugin.CONFIG_GROUP_NAME, "ignoredFilter", configValue);
	}

	private JPanel getSouthPanel()
	{
		JPanel southPanel = new JPanel(new BorderLayout());
		southPanel.setBorder(new EmptyBorder(5,0,2,0));

		JButton importButton = new JButton("Import");
		importButton.setBorder(new EmptyBorder(5, 5, 5, 5));
		importButton.setLayout(new BorderLayout(0, PluginPanel.BORDER_OFFSET));
		importButton.addActionListener(e -> plugin.openImportJsonDialog());
		southPanel.add(importButton, BorderLayout.WEST);

		JButton totalsButton = new JButton("Totals");
		totalsButton.setBorder(new EmptyBorder(5, 5, 5, 5));
		totalsButton.setLayout(new BorderLayout(0, PluginPanel.BORDER_OFFSET));
		totalsButton.addActionListener(e -> plugin.sendTotalsToChat());
		southPanel.add(totalsButton, BorderLayout.CENTER);

		JButton exportButton = new JButton("Export");
		exportButton.setBorder(new EmptyBorder(5, 5, 5, 5));
		exportButton.setLayout(new BorderLayout(0, PluginPanel.BORDER_OFFSET));
		exportButton.addActionListener(e -> plugin.copyJsonToClipboard(plugin.getConfig().taskType()));
		southPanel.add(exportButton, BorderLayout.EAST);

		return southPanel;
	}

	private JPanel getNorthPanel()
	{
		JPanel northPanel = new JPanel();
		BoxLayout layout = new BoxLayout(northPanel, BoxLayout.Y_AXIS);
		northPanel.setLayout(layout);
		northPanel.setBorder(new EmptyBorder(10, 10, 10, 10));

		taskTypeDropdown = new JComboBox<>(TaskType.values());
		taskTypeDropdown.setAlignmentX(LEFT_ALIGNMENT);
		taskTypeDropdown.setSelectedItem(plugin.getConfig().taskType());
		taskTypeDropdown.addActionListener(e -> updateWithNewTaskType(taskTypeDropdown.getItemAt(taskTypeDropdown.getSelectedIndex())));

		// Wrapper for collapsible sub-filter menu
		JPanel subFilterWrapper = new JPanel();
		subFilterWrapper.setLayout(new BorderLayout());
		subFilterWrapper.setBorder(new MatteBorder(1, 0, 1, 0, ColorScheme.MEDIUM_GRAY_COLOR));
		subFilterWrapper.setAlignmentX(LEFT_ALIGNMENT);
		subFilterWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		// collapse button
		SwingUtil.removeButtonDecorations(collapseBtn);
		collapseBtn.setIcon(MENU_COLLAPSED_ICON);
		collapseBtn.setSelectedIcon(MENU_EXPANDED_ICON);
		collapseBtn.setRolloverIcon(MENU_ICON_HOVER);
		SwingUtil.addModalTooltip(collapseBtn, "Collapse filters", "Expand filters");
		collapseBtn.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		collapseBtn.setAlignmentX(LEFT_ALIGNMENT);
		collapseBtn.setUI(new BasicButtonUI()); // substance breaks the layout
		collapseBtn.addActionListener(ev -> subFilterPanel.setVisible(!subFilterPanel.isVisible()));
		collapseBtn.setHorizontalTextPosition(JButton.CENTER);
		collapseBtn.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		collapseBtn.setFont(FontManager.getRunescapeSmallFont());

		// filter button
		SwingUtil.removeButtonDecorations(collapseBtn);
		collapseBtn.setIcon(MENU_COLLAPSED_ICON);
		collapseBtn.setSelectedIcon(MENU_EXPANDED_ICON);

		// panel to hold sub-filters
		subFilterPanel = new SubFilterPanel(plugin, spriteManager);

		subFilterWrapper.add(collapseBtn, BorderLayout.NORTH);
		subFilterWrapper.add(subFilterPanel, BorderLayout.CENTER);

		northPanel.add(getTitleAndButtonPanel());
		northPanel.add(Box.createVerticalStrut(10));
		northPanel.add(taskTypeDropdown);
		northPanel.add(Box.createVerticalStrut(2));
		northPanel.add(getSearchPanel());
		northPanel.add(Box.createVerticalStrut(5));
		northPanel.add(subFilterWrapper);

		return northPanel;
	}

	private JPanel getTitleAndButtonPanel()
	{
		titlePanel.setLayout(new BorderLayout());
		titlePanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		titlePanel.setPreferredSize(new Dimension(0, 30));
		titlePanel.setBorder(new EmptyBorder(5, 5, 5, 10));

		JLabel title = new JLabel("Tasks Tracker");
		title.setHorizontalAlignment(SwingConstants.LEFT);
		title.setForeground(Color.WHITE);

		// Filter button bar
		final JPanel viewControls = new JPanel();
		viewControls.setLayout(new BoxLayout(viewControls, BoxLayout.X_AXIS));
		viewControls.setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Completed tasks filter button
		SwingUtil.removeButtonDecorations(completedFilterBtn);
		completedFilterBtn.setIcons(COMPLETE_INCOMPLETE_ICON, COMPLETE_ONLY_ICON, INCOMPLETE_ONLY_ICON);
		completedFilterBtn.setToolTips("All tasks", "Completed tasks only", "Incomplete tasks only");
		completedFilterBtn.setBackground(ColorScheme.DARK_GRAY_COLOR);
		completedFilterBtn.addActionListener(e -> {
			completedFilterBtn.changeState();
			filterButtonAction("completed");
		});
		completedFilterBtn.setState(config.completedFilter().ordinal());

		// Create popup menu for manually setting the button state
		final JPopupMenu completedFilterBtnPopupMenu = new JPopupMenu();
		completedFilterBtnPopupMenu.setBorder(new EmptyBorder(5, 5, 5, 5));
		completedFilterBtn.setComponentPopupMenu(completedFilterBtnPopupMenu);

		final JMenuItem allTasksC = new JMenuItem("All tasks");
		allTasksC.addActionListener(e -> {
			completedFilterBtn.setState(0);
			filterButtonAction("completed");
		});
		completedFilterBtnPopupMenu.add(allTasksC);

		final JMenuItem completedTasks = new JMenuItem("Completed tasks only");
		completedTasks.addActionListener(e -> {
			completedFilterBtn.setState(1);
			filterButtonAction("completed");
		});
		completedFilterBtnPopupMenu.add(completedTasks);

		final JMenuItem incompleteTasks = new JMenuItem("Incomplete tasks only");
		incompleteTasks.addActionListener(e -> {
			completedFilterBtn.setState(2);
			filterButtonAction("completed");
		});
		completedFilterBtnPopupMenu.add(incompleteTasks);

		viewControls.add(completedFilterBtn);

		// Tracked tasks filter button
		SwingUtil.removeButtonDecorations(trackedFilterBtn);
		trackedFilterBtn.setIcons(TRACKED_UNTRACKED_ICON, TRACKED_ONLY_ICON, UNTRACKED_ONLY_ICON);
		trackedFilterBtn.setToolTips("All tasks", "Tracked tasks only", "Untracked tasks only");
		trackedFilterBtn.setBackground(ColorScheme.DARK_GRAY_COLOR);
		trackedFilterBtn.addActionListener(e -> {
			trackedFilterBtn.changeState();
			filterButtonAction("tracked");
		});
		trackedFilterBtn.setState(config.trackedFilter().ordinal());

		// Create popup menu for manually setting the button state
		final JPopupMenu trackedFilterBtnPopupMenu = new JPopupMenu();
		trackedFilterBtnPopupMenu.setBorder(new EmptyBorder(5, 5, 5, 5));
		trackedFilterBtn.setComponentPopupMenu(trackedFilterBtnPopupMenu);

		final JMenuItem allTasksT = new JMenuItem("All tasks");
		allTasksT.addActionListener(e -> {
			trackedFilterBtn.setState(0);
			filterButtonAction("tracked");
		});
		trackedFilterBtnPopupMenu.add(allTasksT);

		final JMenuItem trackedTasks = new JMenuItem("Tracked tasks only");
		trackedTasks.addActionListener(e -> {
			trackedFilterBtn.setState(1);
			filterButtonAction("tracked");
		});
		trackedFilterBtnPopupMenu.add(trackedTasks);

		final JMenuItem untrackedTasks = new JMenuItem("Untracked tasks only");
		untrackedTasks.addActionListener(e -> {
			trackedFilterBtn.setState(2);
			filterButtonAction("tracked");
		});
		trackedFilterBtnPopupMenu.add(untrackedTasks);

		viewControls.add(trackedFilterBtn);

		// Ignored tasks filter button
		SwingUtil.removeButtonDecorations(ignoredFilterBtn);
		ignoredFilterBtn.setIcons(SEMIVISIBLE_ICON, VISIBLE_ICON, INVISIBLE_ICON);
		ignoredFilterBtn.setToolTips("Hide ignored tasks", "All tasks", "Ignored tasks only");
		ignoredFilterBtn.setBackground(ColorScheme.DARK_GRAY_COLOR);
		ignoredFilterBtn.addActionListener(e -> {
			ignoredFilterBtn.changeState();
			filterButtonAction("ignored");
		});
		ignoredFilterBtn.setState(config.ignoredFilter().ordinal());

		// Create popup menu for manually setting the button state
		final JPopupMenu ignoredFilterBtnPopupMenu = new JPopupMenu();
		ignoredFilterBtnPopupMenu.setBorder(new EmptyBorder(5, 5, 5, 5));
		ignoredFilterBtn.setComponentPopupMenu(ignoredFilterBtnPopupMenu);

		final JMenuItem allTasksI = new JMenuItem("All tasks");
		allTasksI.addActionListener(e -> {
			ignoredFilterBtn.setState(1);
			filterButtonAction("ignored");
		});
		ignoredFilterBtnPopupMenu.add(allTasksI);

		final JMenuItem unignoredTasks = new JMenuItem("Hide ignored tasks");
		unignoredTasks.addActionListener(e -> {
			ignoredFilterBtn.setState(0);
			filterButtonAction("ignored");
		});
		ignoredFilterBtnPopupMenu.add(unignoredTasks);

		final JMenuItem ignoredTasks = new JMenuItem("Ignored tasks only");
		ignoredTasks.addActionListener(e -> {
			ignoredFilterBtn.setState(2);
			filterButtonAction("ignored");
		});
		ignoredFilterBtnPopupMenu.add(ignoredTasks);

		viewControls.add(ignoredFilterBtn);

		titlePanel.add(viewControls, BorderLayout.EAST);
		titlePanel.add(title, BorderLayout.WEST);
		titlePanel.setAlignmentX(LEFT_ALIGNMENT);

		return titlePanel;
	}

	private void filterButtonAction(String filter)
	{
		int state;
		Enum configValue;

		switch (filter)
		{
			case "completed":
				state = completedFilterBtn.getState();
				configValue = ConfigValues.CompletedFilterValues.values()[state];
				break;
			case "tracked":
				state = trackedFilterBtn.getState();
				configValue = ConfigValues.TrackedFilterValues.values()[state];
				break;
			case "ignored":
				state = ignoredFilterBtn.getState();
				configValue = ConfigValues.IgnoredFilterValues.values()[state];
				break;
			default:
				log.debug("Filter button action failed due to unrecognised filter.");
				return;
		}

		plugin.getConfigManager().setConfiguration(TasksTrackerPlugin.CONFIG_GROUP_NAME, filter + "Filter", configValue);
		plugin.refresh();
	}

	private JPanel getSearchPanel()
	{
		JPanel filtersPanel = new JPanel();
		filtersPanel.setAlignmentX(LEFT_ALIGNMENT);
		filtersPanel.setLayout(new BoxLayout(filtersPanel, BoxLayout.Y_AXIS));

		SearchBox textSearch = new SearchBox();
		textSearch.addTextChangedListener(() -> {
			plugin.taskTextFilter = textSearch.getText().toLowerCase();
			plugin.refresh();
		});

		filtersPanel.add(textSearch);

		return filtersPanel;
	}

	private void updateWithNewTaskType(TaskType taskType)
	{
		plugin.getConfigManager().setConfiguration(TasksTrackerPlugin.CONFIG_GROUP_NAME, "taskType", taskType);
		redraw();
		refresh(null);
	}

	private void updateCollapseButtonText()
	{
		if(plugin.getConfig().taskType() == null) return;

		List<String> filterCounts = new ArrayList<>();

		if(plugin.getConfig().taskType().equals(TaskType.LEAGUE_3) ||
		   plugin.getConfig().taskType().equals(TaskType.LEAGUE_4))
		{
			int count = config.skillFilter().equals("") ? 0 : config.skillFilter().split(",").length ;
			filterCounts.add(count + " skill");
		}

		if(plugin.getConfig().taskType().equals(TaskType.LEAGUE_4))
		{
			int count = config.areaFilter().equals("") ? 0 : config.areaFilter().split(",").length ;
			filterCounts.add(count + " area");

//  @todo Category filters disabled due to lack of data
//			count = config.categoryFilter().equals("") ? 0 : config.categoryFilter().split(",").length ;
//			filterCounts.add(count + " cat");
		}

		int count = config.tierFilter().equals("") ? 0 : config.tierFilter().split(",").length;
		filterCounts.add(count + " tier");

		collapseBtn.setText(String.join(", ", filterCounts) + " filters");
	}
}
package net.reldo.taskstracker.panel;

import java.awt.Component;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.Optional;
import java.util.stream.Collectors;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import lombok.extern.slf4j.Slf4j;
import net.reldo.taskstracker.TasksTrackerPlugin;
import net.reldo.taskstracker.panel.components.FixedWidthPanel;
import net.reldo.taskstracker.tasktypes.Task;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.FontManager;

@Slf4j
public class TaskListPanel extends JScrollPane
{
	public TasksTrackerPlugin plugin;
	public final ArrayList<TaskPanel> taskPanels = new ArrayList<>();
	private final ClientThread clientThread;
	private final SpriteManager spriteManager;
	private final SkillIconManager skillIconManager;
	private final TaskListListPanel taskList;
	private final JLabel emptyTasks = new JLabel();

	public TaskListPanel(TasksTrackerPlugin plugin, ClientThread clientThread, SpriteManager spriteManager, SkillIconManager skillIconManager)
	{
		this.plugin = plugin;
		this.clientThread = clientThread;
		this.spriteManager = spriteManager;
		this.skillIconManager = skillIconManager;

		taskList = new TaskListListPanel();

		setViewportView(taskList);
		setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
	}

	public Collection<Task> getTasks()
	{
		// TODO: Build a filter service
		if (plugin.getConfig().taskType() == null)
		{
			return null;
		}
		return plugin.taskManagers.get(plugin.getConfig().taskType()).tasks.values()
			.stream()
			.sorted(Comparator.comparing(Task::getClientSortId))
			.collect(Collectors.toList());
	}

	public String getEmptyTaskListMessage()
	{
		return "No tasks match the current filters.";
	}

	public void redraw()
	{
		taskList.redraw();
	}

	public void refresh(Task task)
	{
		assert SwingUtilities.isEventDispatchThread();

		emptyTasks.setVisible(false);

		if (task != null)
		{
			Optional<TaskPanel> panel = taskPanels.stream()
				.filter(tp -> tp.task.getName().equalsIgnoreCase(task.getName()))
				.findFirst();
			panel.ifPresent(TaskPanel::refresh);
		}
		else
		{
			for (TaskPanel taskPanel : taskPanels)
			{
				taskPanel.refresh();
			}
		}

		Optional<TaskPanel> visibleTaskPanel = taskPanels.stream()
				.filter(TaskPanel::isVisible)
				.findFirst();

		if (!visibleTaskPanel.isPresent())
		{
			emptyTasks.setVisible(true);
		}
	}

	private class TaskListListPanel extends FixedWidthPanel
	{
		public TaskListListPanel()
		{
			setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
			setBorder(new EmptyBorder(0, 10, 10, 10));
			setAlignmentX(Component.LEFT_ALIGNMENT);

			emptyTasks.setBorder(new EmptyBorder(10,0,10,0));
			emptyTasks.setText("<html><center>" + getEmptyTaskListMessage() + "</center></html>");
			emptyTasks.setFont(FontManager.getRunescapeSmallFont());
			emptyTasks.setHorizontalAlignment(JLabel.CENTER);
			emptyTasks.setVerticalAlignment(JLabel.CENTER);
			add(emptyTasks);
			emptyTasks.setVisible(false);
		}

		public void redraw()
		{
			assert SwingUtilities.isEventDispatchThread();
			removeAll();
			taskPanels.clear();
			add(emptyTasks);
			emptyTasks.setVisible(false);

			log.debug(" Creating panels...");
			Collection<Task> tasks = getTasks();
			if (tasks == null || tasks.size() == 0)
			{
				emptyTasks.setVisible(true);
				return;
			}
			for (Task task : tasks)
			{
				TaskPanel taskPanel = task.generatePanel(plugin, clientThread, spriteManager, skillIconManager);
				add(taskPanel);
				taskPanels.add(taskPanel);
			}
			log.debug("Validated and repaint...");
			validate();
			repaint();
		}
	}
}

package net.reldo.taskstracker.panel;

import java.util.ArrayList;
import net.reldo.taskstracker.TasksTrackerConfig;
import net.reldo.taskstracker.TasksTrackerPlugin;
import net.reldo.taskstracker.Util;
import net.reldo.taskstracker.config.ConfigValues.IgnoredFilterValues;
import net.reldo.taskstracker.config.ConfigValues.CompletedFilterValues;
import net.reldo.taskstracker.config.ConfigValues.TrackedFilterValues;
import net.reldo.taskstracker.panel.filters.Filter;
import net.reldo.taskstracker.tasktypes.Task;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JToggleButton;
import javax.swing.JToolTip;
import javax.swing.ToolTipManager;
import javax.swing.border.EmptyBorder;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Constants;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.shadowlabel.JShadowedLabel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

@Slf4j
public abstract class TaskPanel extends JPanel
{
	public static Color QUALIFIED_TEXT_COLOR = new Color(34, 177, 77);
	public static Color UNQUALIFIED_TEXT_COLOR = new Color(251, 93, 93);
	public static Color COMPLETED_BACKGROUND_COLOR = new Color(0, 50, 0);
	public static Color UNQUALIFIED_BACKGROUND_COLOR = new Color(70, 30, 0);

	public static ImageIcon PLUS_ICON = new ImageIcon(ImageUtil.loadImageResource(TasksTrackerPlugin.class, "plus.png"));
	public static ImageIcon MINUS_ICON = new ImageIcon(ImageUtil.loadImageResource(TasksTrackerPlugin.class, "minus.png"));
	public static ImageIcon EYE_ICON = new ImageIcon(ImageUtil.loadImageResource(TasksTrackerPlugin.class, "eye.png"));
	public static ImageIcon EYE_CROSS_GREY = new ImageIcon(ImageUtil.loadImageResource(TasksTrackerPlugin.class, "eye-cross-grey.png"));

	public final SpriteManager spriteManager;
	public final Task task;
	private final ClientThread clientThread;

	private final JLabel icon = new JLabel();
	private final JPanel container = new JPanel(new BorderLayout());
	private final JPanel body = new JPanel(new BorderLayout());
	private final JShadowedLabel name = new JShadowedLabel();
	private final JLabel description = new JLabel();
	private final JPanel buttons = new JPanel();
	private final JToggleButton toggleTrack = new JToggleButton();
	private final JToggleButton toggleIgnore = new JToggleButton();

	protected final ArrayList<Filter> filters = new ArrayList<>();

	protected TasksTrackerPlugin plugin;

	public TaskPanel(TasksTrackerPlugin plugin, ClientThread clientThread, SpriteManager spriteManager, Task task)
	{
		super(new BorderLayout());
		this.plugin = plugin;
		this.clientThread = clientThread;
		this.spriteManager = spriteManager;
		this.task = task;
		createPanel(task);
		setComponentPopupMenu(getPopupMenu());
		ToolTipManager.sharedInstance().registerComponent(this);
		refresh();
	}

	public abstract JPopupMenu getPopupMenu();

	public abstract String getTaskTooltip();

	public abstract BufferedImage getIcon();

	public Color getTaskBackgroundColor(Task task, int[] playerSkills)
	{
		return task.isCompleted() ? COMPLETED_BACKGROUND_COLOR : ColorScheme.DARKER_GRAY_COLOR;
	}

	public void createPanel(Task task)
	{
		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(0, 0, 7, 0));

		container.setBorder(new EmptyBorder(7, 7, 6, 0));

		// Body

		name.setFont(FontManager.getRunescapeSmallFont());
		name.setForeground(Color.WHITE);
		body.add(name, BorderLayout.NORTH);

		description.setFont(FontManager.getRunescapeSmallFont());
		description.setForeground(Color.GRAY);
		body.add(description, BorderLayout.CENTER);

		// Buttons
		buttons.setLayout(new BoxLayout(buttons, BoxLayout.Y_AXIS));
		buttons.setBorder(new EmptyBorder(0, 0, 0, 7));

		toggleTrack.setPreferredSize(new Dimension(8, 8));
		toggleTrack.setIcon(PLUS_ICON);
		toggleTrack.setSelectedIcon(MINUS_ICON);
		toggleTrack.setBorder(new EmptyBorder(5, 0, 5, 0));
		toggleTrack.addActionListener(e -> {
			task.setTracked(toggleTrack.isSelected());
			plugin.pluginPanel.taskListPanel.refresh(task);
			plugin.saveCurrentTaskData();
		});
		SwingUtil.removeButtonDecorations(toggleTrack);

		toggleIgnore.setPreferredSize(new Dimension(8, 8));
		toggleIgnore.setIcon(EYE_CROSS_GREY);
		toggleIgnore.setSelectedIcon(EYE_ICON);
		SwingUtil.addModalTooltip(toggleIgnore, "Unignore", "Ignore");
		toggleIgnore.setBorder(new EmptyBorder(5, 0, 5, 0));
		toggleIgnore.addActionListener(e -> {
			task.setIgnored(!task.isIgnored());
			plugin.pluginPanel.taskListPanel.refresh(task);
			plugin.saveCurrentTaskData();
		});
		SwingUtil.removeButtonDecorations(toggleIgnore);

		buttons.add(toggleTrack);
		buttons.add(toggleIgnore);

		// Full
		container.add(icon, BorderLayout.WEST);
		container.add(body, BorderLayout.CENTER);
		container.add(buttons, BorderLayout.EAST);

		clientThread.invoke(() -> {
			if (getIcon() != null)
			{
				icon.setMinimumSize(new Dimension(Constants.ITEM_SPRITE_WIDTH, Constants.ITEM_SPRITE_HEIGHT));
				icon.setIcon(new ImageIcon(getIcon()));
				icon.setBorder(new EmptyBorder(0, 0, 0, 5));
			}
			else
			{
				icon.setBorder(new EmptyBorder(0, 0, 0, 0));
			}
		});

		add(container, BorderLayout.NORTH);
	}

	public void refresh()
	{
		name.setText(Util.wrapWithHtml(task.getName()));
		description.setText(Util.wrapWithHtml(task.getDescription()));
		setBackgroundColor(getTaskBackgroundColor(task, plugin.playerSkills));
		toggleTrack.setSelected(task.isTracked());
		toggleIgnore.setSelected(task.isIgnored());

		setVisible(meetsFilterCriteria());

		revalidate();
	}

	protected boolean meetsFilterCriteria()
	{
		String nameLowercase = task.getName().toLowerCase();
		String descriptionLowercase = task.getDescription().toLowerCase();
		if (plugin.taskTextFilter != null &&
			!nameLowercase.contains(plugin.taskTextFilter) &&
			!descriptionLowercase.contains(plugin.taskTextFilter))
		{
			return false;
		}

		TasksTrackerConfig config = plugin.getConfig();

		for(Filter filter : filters)
		{
			if(!filter.meetsCriteria(task)) return false;
		}

		if (config.completedFilter().equals(CompletedFilterValues.INCOMPLETE) && task.isCompleted())
		{
			return false;
		}
		if (config.completedFilter().equals(CompletedFilterValues.COMPLETE) && !task.isCompleted())
		{
			return false;
		}

		if (config.ignoredFilter().equals(IgnoredFilterValues.NOT_IGNORED) && task.isIgnored())
		{
			return false;
		}
		if (config.ignoredFilter().equals(IgnoredFilterValues.IGNORED) && !task.isIgnored())
		{
			return false;
		}

		if (config.trackedFilter().equals(TrackedFilterValues.UNTRACKED) && task.isTracked())
		{
			return false;
		}
		return !config.trackedFilter().equals(TrackedFilterValues.TRACKED) || task.isTracked();
	}

	private void setBackgroundColor(Color color)
	{
		container.setBackground(color);
		body.setBackground(color);
		buttons.setBackground(color);
	}

	@Override
	public Dimension getMaximumSize()
	{
		return new Dimension(PluginPanel.PANEL_WIDTH, getPreferredSize().height);
	}

	@Override
	public JToolTip createToolTip()
	{
		JToolTip customTooltip = new JToolTip();
		customTooltip.setFont(FontManager.getRunescapeSmallFont());
		return customTooltip;
	}

	@Override
	public String getToolTipText(MouseEvent mouseEvent)
	{
		return getTaskTooltip();
	}
}

package net.reldo.taskstracker.panel;

import javax.swing.JLabel;
import javax.swing.JPanel;

public class LoggedOutPanel extends JPanel
{
	public LoggedOutPanel()
	{
		this.add(new JLabel("Log into an account to track tasks."));
	}
}

package net.reldo.taskstracker.panel.filters;

import java.util.Arrays;
import net.reldo.taskstracker.TasksTrackerConfig;
import net.reldo.taskstracker.tasktypes.RequiredSkill;
import net.reldo.taskstracker.tasktypes.Task;

public class SkillFilter extends Filter
{
    private final TasksTrackerConfig config;

    public SkillFilter(TasksTrackerConfig config)
    {
        this.config = config;
    }

    @Override
    public boolean meetsCriteria(Task task)
    {
        if(task.getSkills() == null) return true;

        String skillFilter = config.skillFilter();

        if (task.getSkills().length > 0 && !Arrays.stream(task.getSkills())
                .filter((RequiredSkill skill) -> !skill.getSkill().equalsIgnoreCase("combat")) //@todo replace with combat level requirement filtering
                .allMatch((RequiredSkill skill) -> skillFilter.contains(skill.getSkill().toLowerCase())))
        {
            return false;
        }

        return Arrays.stream(task.getSkills()).anyMatch((RequiredSkill skill) -> !skill.getSkill().equalsIgnoreCase("combat")) || skillFilter.contains("noskill");
    }
}

package net.reldo.taskstracker.panel.filters;

import net.reldo.taskstracker.tasktypes.Task;

public abstract class Filter {

    public abstract boolean meetsCriteria(Task task);
}

package net.reldo.taskstracker.panel.filters;

import net.reldo.taskstracker.TasksTrackerConfig;
import net.reldo.taskstracker.tasktypes.Task;

public class CategoryFilter extends Filter
{

    private final TasksTrackerConfig config;

    public CategoryFilter(TasksTrackerConfig config)
    {
        this.config = config;
    }

    @Override
    public boolean meetsCriteria(Task task) {
        //@todo Criteria check removed while category filter is disabled.
        return true;
    }
}

package net.reldo.taskstracker.panel.filters;

import net.reldo.taskstracker.TasksTrackerConfig;
import net.reldo.taskstracker.tasktypes.Task;

public class AreaFilter extends Filter
{

    private final TasksTrackerConfig config;

    public AreaFilter(TasksTrackerConfig config)
    {
        this.config = config;
    }

    @Override
    public boolean meetsCriteria(Task task) {
        String areaFilter = config.areaFilter();

        boolean globalFilter = areaFilter.contains("f-" +task.getArea().toLowerCase());
        boolean generalFilter = areaFilter.contains("f-" +task.getArea().replace("General", "Global").toLowerCase());

        return globalFilter || generalFilter;
    }
}

package net.reldo.taskstracker.panel.filters;

import net.reldo.taskstracker.TasksTrackerConfig;
import net.reldo.taskstracker.tasktypes.Task;

public class TierFilter extends Filter
{

    private final TasksTrackerConfig config;

    public TierFilter(TasksTrackerConfig config)
    {
        this.config = config;
    }

    @Override
    public boolean meetsCriteria(Task task) {
        String tierFilter = config.tierFilter();

        return tierFilter.contains("f-" +task.getTier().toLowerCase());
    }
}

package net.reldo.taskstracker.panel.components;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.event.ActionListener;
import javax.swing.JCheckBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import net.runelite.client.ui.ColorScheme;
import static net.runelite.client.ui.PluginPanel.PANEL_WIDTH;

public class CheckBox extends JPanel
{
	private final JCheckBox jCheckBox = new JCheckBox();

	public CheckBox(String name)
	{
		setLayout(new BorderLayout());
		setMinimumSize(new Dimension(PANEL_WIDTH, 0));

		JLabel label = new JLabel(name);
		add(label, BorderLayout.CENTER);

		jCheckBox.setBackground(ColorScheme.LIGHT_GRAY_COLOR);
		add(jCheckBox, BorderLayout.EAST);
	}

	public boolean isSelected()
	{
		return jCheckBox.isSelected();
	}

	public void setSelected(boolean selected)
	{
		jCheckBox.setSelected(selected);
	}

	public void addActionListener(ActionListener l)
	{
		jCheckBox.addActionListener(l);
	}
}

package net.reldo.taskstracker.panel.components;

import java.awt.Dimension;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;

public class SearchBox extends IconTextField
{
	private SearchBoxCallback fn;

	public SearchBox()
	{
		this.setIcon(IconTextField.Icon.SEARCH);
		this.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 30));
		this.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		this.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
		this.getDocument().addDocumentListener(new DocumentListener()
		{
			@Override
			public void insertUpdate(DocumentEvent documentEvent)
			{
				fn.call();
			}

			@Override
			public void removeUpdate(DocumentEvent documentEvent)
			{
				fn.call();
			}

			@Override
			public void changedUpdate(DocumentEvent documentEvent)
			{
			}
		});

		this.addActionListener(e -> fn.call()
		);
	}

	public void addTextChangedListener(SearchBoxCallback fn)
	{
		this.fn = fn;
	}

	public interface SearchBoxCallback
	{
		void call();
	}
}

package net.reldo.taskstracker.panel.components;

import java.awt.Dimension;
import javax.swing.JPanel;
import net.runelite.client.ui.PluginPanel;

public class FixedWidthPanel extends JPanel
{
	@Override
	public Dimension getPreferredSize()
	{
		return new Dimension(PluginPanel.PANEL_WIDTH, super.getPreferredSize().height);
	}

}

package net.reldo.taskstracker.panel.components;

import javax.swing.Icon;
import javax.swing.JButton;
import lombok.Getter;

public class TriToggleButton extends JButton
{

	// Icons
	private final Icon[] icons = new Icon[3];
	// Tooltips
	private final String[] tooltips = new String[3];
	@Getter
	private int state = 0;

	public TriToggleButton()
	{
		super();
	}

	/* Action listener must include changeState() */

	public void setIcon(Icon icon, int state)
	{
		if (state < 0 || state > 3 || icon == null)
		{
			return;
		}

		icons[state] = icon;

		setIconState();
	}

	public boolean setIcons(Icon icon0, Icon icon1, Icon icon2)
	{
		if (icon0 == null || icon1 == null || icon2 == null)
		{
			return false;
		}

		setIcon(icon0, 0);
		setIcon(icon1, 1);
		setIcon(icon2, 2);

		setIconState();
		return true;
	}

	public void setToolTip(String tooltip, int state)
	{
		if (state < 0 || state > 3 || tooltip == null)
		{
			return;
		}

		tooltips[state] = tooltip;

		setTooltipState();
	}

	public boolean setToolTips(String tooltip0, String tooltip1, String tooltip2)
	{
		if (tooltip0 == null || tooltip1 == null || tooltip2 == null)
		{
			return false;
		}

		setToolTip(tooltip0, 0);
		setToolTip(tooltip1, 1);
		setToolTip(tooltip2, 2);

		setTooltipState();
		return true;
	}

	public void changeState()
	{
		setState((state + 1) % 3);
	}

	private void setIconState()
	{
		super.setIcon(icons[state]);
	}

	private void setTooltipState()
	{
		super.setToolTipText(tooltips[state]);
	}

	public void setState(int state)
	{
		this.state = state;
		setIconState();
		setTooltipState();
	}
}

package net.reldo.taskstracker.panel;

import net.reldo.taskstracker.TasksTrackerConfig;
import net.reldo.taskstracker.TasksTrackerPlugin;
import net.reldo.taskstracker.tasktypes.Task;
import java.awt.BorderLayout;
import java.awt.Dimension;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;

@Slf4j
public class TasksTrackerPluginPanel extends PluginPanel
{
	private final ClientThread clientThread;
	private final SpriteManager spriteManager;
	private final TasksTrackerPlugin plugin;
	private final SkillIconManager skillIconManager;

	private final LoggedInPanel loggedInPanel;
	private final LoggedOutPanel loggedOutPanel = new LoggedOutPanel();

	public TaskListPanel taskListPanel;

	private boolean loggedIn = false;

	public TasksTrackerPluginPanel(TasksTrackerPlugin plugin, TasksTrackerConfig config, ClientThread clientThread, SpriteManager spriteManager, SkillIconManager skillIconManager)
	{
		super(false);
		this.plugin = plugin;
		this.clientThread = clientThread;
		this.spriteManager = spriteManager;
		this.skillIconManager = skillIconManager;

		setBorder(new EmptyBorder(6, 6, 6, 6));
		setBackground(ColorScheme.DARK_GRAY_COLOR);
		setLayout(new BorderLayout());

		loggedInPanel = new LoggedInPanel(plugin, config, clientThread, spriteManager, skillIconManager);
		taskListPanel = loggedInPanel.taskListPanel;
		add(loggedInPanel, BorderLayout.NORTH);
		loggedInPanel.setVisible(false);

		// Add error pane
		add(loggedOutPanel);
	}

	@Override
	public Dimension getPreferredSize()
	{
		return new Dimension(PANEL_WIDTH + SCROLLBAR_WIDTH, super.getPreferredSize().height);
	}

	public void redraw()
	{
		if (loggedIn)
		{
			loggedInPanel.redraw();
		}
	}

	public void refresh(Task task)
	{
		if (loggedIn)
		{
			loggedInPanel.refresh(task);
		}
	}

	public void setLoggedIn(boolean loggedIn)
	{
		assert SwingUtilities.isEventDispatchThread();

		if (loggedIn != this.loggedIn)
		{
			if (loggedIn)
			{
				loggedOutPanel.setVisible(false);
				loggedInPanel.setVisible(true);
			}
			else
			{
				loggedInPanel.setVisible(false);
				loggedOutPanel.setVisible(true);
			}

			validate();
			repaint();
		}
		this.loggedIn = loggedIn;
	}
}
package net.reldo.taskstracker.panel.subfilters;

import com.google.common.collect.ImmutableList;
import java.awt.BorderLayout;
import java.awt.GridLayout;
import java.awt.image.BufferedImage;
import java.util.LinkedHashMap;
import java.util.List;
import javax.swing.JPanel;
import javax.swing.JToggleButton;
import javax.swing.border.EmptyBorder;
import net.reldo.taskstracker.TasksTrackerPlugin;
import net.reldo.taskstracker.tasktypes.TaskType;
import net.runelite.client.hiscore.HiscoreSkill;
import static net.runelite.client.hiscore.HiscoreSkill.*;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;

public class SkillFilterPanel extends FilterButtonPanel
{

    /**
     * Real skills, ordered in the way they should be displayed in the panel.
     */
    private static final List<HiscoreSkill> SKILLS = ImmutableList.of(
            ATTACK, HITPOINTS, MINING,
            STRENGTH, AGILITY, SMITHING,
            DEFENCE, HERBLORE, FISHING,
            RANGED, THIEVING, COOKING,
            PRAYER, CRAFTING, FIREMAKING,
            MAGIC, FLETCHING, WOODCUTTING,
            RUNECRAFT, SLAYER, FARMING,
            CONSTRUCTION, HUNTER
    );

    public SkillFilterPanel(TasksTrackerPlugin plugin)
    {
        super(plugin, "Skill");
        this.configKey = "skillFilter";

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setBorder(new EmptyBorder(10, 10, 10, 10));

        redraw();
    }

    @Override
    protected JPanel makeButtonPanel()
    {
        // Panel that holds skill icons
        JPanel buttonPanel = new JPanel();
        buttonPanel.setLayout(new GridLayout(8, 3));
        buttonPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        LinkedHashMap<String, BufferedImage> skillImages = getIconImages();

        // For each skill on the in-game skill panel, create a button and add it to the UI
        skillImages.forEach((name, image) -> {
            JToggleButton button = makeButton(name, image);
            buttons.put(name, button);
            buttonPanel.add(button);
        });

        buttons.get("noskill").setToolTipText("No skill requirements.");

        return buttonPanel;
    }

    @Override
    protected LinkedHashMap<String, BufferedImage> getIconImages()
    {
        LinkedHashMap<String, BufferedImage> images = new LinkedHashMap<>();
        String skillName;
        BufferedImage skillImage;

        for (HiscoreSkill skill : SKILLS)
        {
            skillName = skill.name().toLowerCase();

            String directory = "/skill_icons_small/";
            String skillIcon = directory + skillName + ".png";

            skillImage = ImageUtil.loadImageResource(getClass(), skillIcon);

            images.put(skillName, skillImage);
        }

        skillName = "noskill";
        skillImage = ImageUtil.loadImageResource(TasksTrackerPlugin.class, "panel/components/no_skill.png");
        images.put(skillName, skillImage);

        return images;
    }

    @Override
    public void redraw()
    {
        if (plugin.getConfig().taskType() != null)
            this.setVisible(!plugin.getConfig().taskType().equals(TaskType.COMBAT));

        super.redraw();
    }
}

package net.reldo.taskstracker.panel.subfilters;

import net.reldo.taskstracker.TasksTrackerPlugin;
import net.reldo.taskstracker.tasktypes.TaskType;
import net.reldo.taskstracker.tasktypes.league4.League4TaskArea;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.LinkedHashMap;

public class AreaFilterPanel extends FilterButtonPanel
{
    public AreaFilterPanel(TasksTrackerPlugin plugin, SpriteManager spriteManager)
    {
        super(plugin, "Area");
        this.configKey = "areaFilter";

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setBorder(new EmptyBorder(10, 10, 10, 10));

        redraw();
    }

    @Override
    protected JPanel makeButtonPanel()
    {
        // Panel that holds area icons
        JPanel buttonPanel = new JPanel();
        buttonPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        LinkedHashMap<String, BufferedImage> buttonImages = getIconImages();

        buttonPanel.setLayout(new GridLayout(buttonImages.size() / 3, 3));

        // For each area create a button and add it to the UI
        buttonImages.forEach((name, image) -> {
            JToggleButton button = makeButton(name, image);
            buttons.put(name, button);
            buttonPanel.add(button);
        });

        return buttonPanel;
    }

    //@todo (maybe) change this to use SpriteManager after it has apologised to me
    @Override
    protected LinkedHashMap<String, BufferedImage> getIconImages()
    {
        LinkedHashMap<String, BufferedImage> images = new LinkedHashMap<>();
        String areaName;
        BufferedImage areaImage;
        String directory = "panel/components/task_areas/";

        if (plugin.getConfig().taskType() == null ||
            plugin.getConfig().taskType().equals(TaskType.COMBAT) ||
            plugin.getConfig().taskType().equals(TaskType.LEAGUE_3)) return images;

        if (plugin.getConfig().taskType().equals(TaskType.LEAGUE_4))
        {
            directory += "league4/";

            for (League4TaskArea area : League4TaskArea.values())
            {
                areaName = area.name().toLowerCase();
                String areaIcon = directory + areaName + ".png";
                areaImage = ImageUtil.loadImageResource(TasksTrackerPlugin.class, areaIcon);

                images.put(areaName, areaImage);
            }
        }

        return images;
    }

    @Override
    public void redraw()
    {
        if (plugin.getConfig().taskType() != null)
            this.setVisible(plugin.getConfig().taskType().equals(TaskType.LEAGUE_4));

        //@todo remove duplication by generalising save/load to all subfilters
        assert SwingUtilities.isEventDispatchThread();

        buttons.clear();
        removeAll();

        collapseBtn = makeCollapseButton();
        buttonPanel = makeButtonPanel();

        add(collapseBtn, BorderLayout.NORTH);
        add(buttonPanel, BorderLayout.CENTER);
        add(allOrNoneButtons(), BorderLayout.SOUTH);

        if(plugin.getConfig().saveAreaFilterState())
        {
            String filterText = plugin.getConfig().areaFilter();

            buttons.forEach((key, value) -> value.setSelected(filterText.contains("f-" + key)));
        }
        else
        {
            updateFilterText();
        }

        updateCollapseButtonText();

        collapseBtn.setVisible(plugin.getConfig().filterPanelCollapsible());

        validate();
        repaint();
    }

}

package net.reldo.taskstracker.panel.subfilters;

import net.reldo.taskstracker.TasksTrackerPlugin;
import net.reldo.taskstracker.tasktypes.TaskType;
import net.reldo.taskstracker.tasktypes.league4.League4TaskCategory;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.LinkedHashMap;

public class CategoryFilterPanel extends FilterButtonPanel
{

    public CategoryFilterPanel(TasksTrackerPlugin plugin, SpriteManager spriteManager)
    {
        super(plugin, "Category");
        this.configKey = "categoryFilter";

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setBorder(new EmptyBorder(10, 10, 10, 10));

        redraw();
    }

    @Override
    protected JPanel makeButtonPanel()
    {
        // Panel that holds category icons
        JPanel buttonPanel = new JPanel();
        buttonPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        LinkedHashMap<String, BufferedImage> buttonImages = getIconImages();

        buttonPanel.setLayout(new GridLayout(buttonImages.size() / 3, 3));

        // For each category create a button and add it to the UI
        buttonImages.forEach((name, image) -> {
            JToggleButton button = makeButton(name, image);
            buttons.put(name, button);
            buttonPanel.add(button);
        });

        return buttonPanel;
    }

    //@todo (maybe) change this to use SpriteManager after it has apologised to me
    @Override
    protected LinkedHashMap<String, BufferedImage> getIconImages()
    {
        LinkedHashMap<String, BufferedImage> images = new LinkedHashMap<>();
        String categoryName;
        BufferedImage categoryImage;
        String directory = "panel/components/task_categories/";

        if (plugin.getConfig().taskType() == null ||
            plugin.getConfig().taskType().equals(TaskType.COMBAT) ||
            plugin.getConfig().taskType().equals(TaskType.LEAGUE_3)) return images;

        if (plugin.getConfig().taskType().equals(TaskType.LEAGUE_4))
        {
            directory += "league4/";

            for (League4TaskCategory category : League4TaskCategory.values())
            {
                categoryName = category.name().toLowerCase();
                String categoryIcon = directory + categoryName + ".png";
                categoryImage = ImageUtil.loadImageResource(TasksTrackerPlugin.class, categoryIcon);

                images.put(categoryName, categoryImage);
            }
        }

        return images;
    }

    @Override
    public void redraw()
    {
        if (plugin.getConfig().taskType() != null)
            this.setVisible(plugin.getConfig().taskType().equals(TaskType.LEAGUE_4));

        super.redraw();
    }
}

package net.reldo.taskstracker.panel.subfilters;

import java.awt.BorderLayout;
import java.awt.GridLayout;
import java.awt.image.BufferedImage;
import java.util.LinkedHashMap;
import javax.swing.JPanel;
import javax.swing.JToggleButton;
import javax.swing.border.EmptyBorder;
import net.reldo.taskstracker.TasksTrackerPlugin;
import net.reldo.taskstracker.tasktypes.TaskType;
import net.reldo.taskstracker.tasktypes.combattask.CombatTaskTier;
import net.reldo.taskstracker.tasktypes.league4.League4TaskTier;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;

public class DifficultyFilterPanel extends FilterButtonPanel
{

    public DifficultyFilterPanel(TasksTrackerPlugin plugin, SpriteManager spriteManager)
    {
        super(plugin, "Tier");
        this.configKey = "tierFilter";

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setBorder(new EmptyBorder(10, 10, 10, 10));

        redraw();
    }

    @Override
    protected JPanel makeButtonPanel()
    {
        // Panel that holds tier icons
        JPanel buttonPanel = new JPanel();
        buttonPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        LinkedHashMap<String, BufferedImage> buttonImages = getIconImages();

        buttonPanel.setLayout(new GridLayout(buttonImages.size() / 3, 3));

        // For each difficulty tier create a button and add it to the UI
        buttonImages.forEach((name, image) -> {
            JToggleButton button = makeButton(name, image);
            buttons.put(name, button);
            buttonPanel.add(button);
        });

        return buttonPanel;
    }

    //@todo (maybe) change this to use SpriteManager after it has apologised to me
    @Override
    protected LinkedHashMap<String, BufferedImage> getIconImages()
    {
        LinkedHashMap<String, BufferedImage> images = new LinkedHashMap<>();
        String tierName;
        BufferedImage tierImage;
        String directory = "panel/components/task_tiers/";

        if (plugin.getConfig().taskType() == null) return images;

        if (plugin.getConfig().taskType().equals(TaskType.LEAGUE_3) ||
            plugin.getConfig().taskType().equals(TaskType.LEAGUE_4))
        {
            directory += "league3/";

            //@fixme Hardcoded for league 4
            for (League4TaskTier tier : League4TaskTier.values())
            {
                tierName = tier.name().toLowerCase();
                String tierIcon = directory + tierName + ".png";
                tierImage = ImageUtil.loadImageResource(TasksTrackerPlugin.class, tierIcon);

                images.put(tierName, tierImage);
            }
        }

        if (plugin.getConfig().taskType().equals(TaskType.COMBAT))
        {
            directory += "combat/";

            for (CombatTaskTier tier : CombatTaskTier.values())
            {
                tierName = tier.name().toLowerCase();
                String tierIcon = directory + tierName + ".png";
                tierImage = ImageUtil.loadImageResource(TasksTrackerPlugin.class, tierIcon);

                images.put(tierName, tierImage);
            }
        }

        return images;
    }
}

package net.reldo.taskstracker.panel.subfilters;

import java.awt.BorderLayout;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.stream.Collectors;
import javax.swing.BoxLayout;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JToggleButton;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import javax.swing.plaf.basic.BasicButtonUI;
import net.reldo.taskstracker.TasksTrackerPlugin;
import net.reldo.taskstracker.panel.components.FixedWidthPanel;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

public abstract class FilterButtonPanel extends FixedWidthPanel
{
    protected final TasksTrackerPlugin plugin;
    private final String name;

    protected final Map<String, JToggleButton> buttons = new HashMap<>();
    protected String configKey;
    protected JPanel buttonPanel;

    protected JToggleButton collapseBtn;
    private final String expandBtnPath = "panel/components/";
    private final BufferedImage collapseImg = ImageUtil.loadImageResource(TasksTrackerPlugin.class, expandBtnPath + "filter_buttons_collapsed.png");
    private final Icon MENU_COLLAPSED_ICON = new ImageIcon(ImageUtil.alphaOffset(collapseImg, -180));
    private final Icon MENU_ICON_HOVER = new ImageIcon(collapseImg);
    private final BufferedImage expandedImg = ImageUtil.loadImageResource(TasksTrackerPlugin.class, expandBtnPath + "filter_buttons_expanded.png");
    private final Icon MENU_EXPANDED_ICON = new ImageIcon(ImageUtil.alphaOffset(expandedImg, -180));
    private final Icon MENU_ICON_HOVER_SELECTED = new ImageIcon(expandedImg);


    public FilterButtonPanel(TasksTrackerPlugin plugin, String name)
    {
        this.plugin = plugin;

        this.name = name;
    }

    protected abstract LinkedHashMap<String, BufferedImage> getIconImages();

    protected abstract JPanel makeButtonPanel();

    protected JToggleButton makeButton(String name, BufferedImage image)
    {
        JToggleButton button = new JToggleButton();
        button.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        button.setBorder(new EmptyBorder(2, 0, 2, 0));
        button.setFocusable(false);

        if(image != null) {
            ImageIcon selectedIcon = new ImageIcon(image);
            ImageIcon deselectedIcon = new ImageIcon(ImageUtil.alphaOffset(image, -180));

            button.setIcon(deselectedIcon);
            button.setSelectedIcon(selectedIcon);
        }

        button.setToolTipText(name.substring(0,1).toUpperCase() + name.substring(1).toLowerCase());

        button.addActionListener(e -> {
            updateFilterText();
            updateCollapseButtonText();
            plugin.refresh();
        });

        button.setSelected(true);

        return button;
    }

    protected JPanel allOrNoneButtons()
    {
        JPanel buttonWrapper = new JPanel();
        buttonWrapper.setLayout(new BoxLayout(buttonWrapper, BoxLayout.X_AXIS));
        buttonWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        buttonWrapper.setAlignmentX(JPanel.CENTER_ALIGNMENT);

        JButton all = new JButton("all");
        SwingUtil.removeButtonDecorations(all);
        all.setFocusable(false);
        all.setForeground(ColorScheme.MEDIUM_GRAY_COLOR);
        all.setFont(FontManager.getRunescapeSmallFont());
        all.addActionListener(e -> {
            setAllSelected(true);
            updateFilterText();
            updateCollapseButtonText();
            plugin.refresh();
        });

        JButton none = new JButton("none");
        SwingUtil.removeButtonDecorations(none);
        none.setFocusable(false);
        none.setForeground(ColorScheme.MEDIUM_GRAY_COLOR);
        none.setFont(FontManager.getRunescapeSmallFont());
        none.addActionListener(e -> {
            setAllSelected(false);
            updateFilterText();
            updateCollapseButtonText();
            plugin.refresh();
        });

        JLabel separator = new JLabel("|");
        separator.setForeground(ColorScheme.MEDIUM_GRAY_COLOR);

        buttonWrapper.add(all);
        buttonWrapper.add(separator);
        buttonWrapper.add(none);

        return buttonWrapper;
    }

    public JToggleButton makeCollapseButton()
    {
        JToggleButton collapseBtn = new JToggleButton();

        // collapse button
        SwingUtil.removeButtonDecorations(collapseBtn);
        collapseBtn.setIcon(MENU_COLLAPSED_ICON);
        collapseBtn.setSelectedIcon(MENU_EXPANDED_ICON);
        collapseBtn.setRolloverIcon(MENU_ICON_HOVER);
        collapseBtn.setRolloverSelectedIcon(MENU_ICON_HOVER_SELECTED);
        SwingUtil.addModalTooltip(collapseBtn, "Collapse filters", "Expand filters");
        collapseBtn.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        collapseBtn.setAlignmentX(LEFT_ALIGNMENT);
        collapseBtn.setUI(new BasicButtonUI()); // substance breaks the layout
        collapseBtn.addActionListener(ev -> buttonPanel.setVisible(!buttonPanel.isVisible()));
        collapseBtn.setHorizontalTextPosition(JButton.CENTER);
        collapseBtn.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        collapseBtn.setFont(FontManager.getRunescapeSmallFont());
        collapseBtn.setSelected(true);

        return collapseBtn;
    }

    protected void updateFilterText()
    {
        String filterText = buttons.entrySet().stream()
                .filter(e -> e.getValue().isSelected())
                .map(e -> "f-" + e.getKey()) // prefix included to cover cases where one key name is contained in another (e.g. "Master" -> "Grandmaster")
                .collect(Collectors.joining(","));

        plugin.getConfigManager().setConfiguration(TasksTrackerPlugin.CONFIG_GROUP_NAME, configKey, filterText);
    }

    protected void setAllSelected(boolean state)
    {
        buttons.values().forEach(button -> button.setSelected(state));
    }

    protected void updateCollapseButtonText()
    {
        collapseBtn.setText(name + " - " + buttons.values().stream().filter(JToggleButton::isSelected).count() + " / " + buttons.size());
    }

    public void redraw()
    {
        assert SwingUtilities.isEventDispatchThread();

        buttons.clear();
        removeAll();

        collapseBtn = makeCollapseButton();
        buttonPanel = makeButtonPanel();

        add(collapseBtn, BorderLayout.NORTH);
        add(buttonPanel, BorderLayout.CENTER);
        add(allOrNoneButtons(), BorderLayout.SOUTH);
        updateFilterText();
        updateCollapseButtonText();

        collapseBtn.setVisible(plugin.getConfig().filterPanelCollapsible());

        validate();
        repaint();
    }
}

package net.reldo.taskstracker.tasktypes;

import java.util.Collection;

public class TasksSummary
{
	public int trackedTasksCount = 0;
	public int trackedTasksPoints = 0;

	public TasksSummary(Collection<Task> values)
	{
		values.forEach(task -> {
			if (task.isTracked()) {
				trackedTasksCount++;
				System.out.printf("%s %s%n", task.getName(), task.getPoints());
				trackedTasksPoints += task.getPoints();
			}
		});
	}
}

package net.reldo.taskstracker.tasktypes.league4;

import java.util.ArrayList;
import java.util.List;
import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public enum League4Varps
{
	LEAGUE_POINTS(2614),
	SAGES_RENOWN(3276);

	private final int varpId;

	@Getter
	private static final List<Integer> allVarpIds = new ArrayList<>();

	static
	{
		for (League4Varps varp : League4Varps.values())
		{
			allVarpIds.add(varp.getVarpId());
		}
	}
}

package net.reldo.taskstracker.tasktypes.league4;

import net.reldo.taskstracker.TasksTrackerPlugin;
import net.reldo.taskstracker.panel.TaskPanel;
import net.reldo.taskstracker.tasktypes.Task;
import net.reldo.taskstracker.tasktypes.TaskType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.game.SpriteManager;

public class League4Task extends Task
{

	public League4Task(int id, String name, String description, String tier, int clientSortId)
	{
		super(id, name, description, tier, clientSortId);
	}

	@Override
	public int getPoints()
	{
		League4TaskTier tierType = League4TaskTier.tiersByName.get(this.getTier().toLowerCase());
		return tierType != null ? tierType.points : 0;
	}

	@Override
	public TaskType getType()
	{
		return TaskType.LEAGUE_4;
	}

	@Override
	public TaskPanel generatePanel(TasksTrackerPlugin plugin, ClientThread clientThread, SpriteManager spriteManager, SkillIconManager skillIconManager)
	{
		return new League4TaskPanel(plugin, clientThread, spriteManager, this);
	}
}

package net.reldo.taskstracker.tasktypes.league4;

import java.awt.Color;
import java.awt.image.BufferedImage;
import java.net.URL;
import javax.swing.JPopupMenu;
import net.reldo.taskstracker.TasksTrackerPlugin;
import net.reldo.taskstracker.Util;
import net.reldo.taskstracker.panel.TaskPanel;
import net.reldo.taskstracker.panel.filters.AreaFilter;
import net.reldo.taskstracker.panel.filters.CategoryFilter;
import net.reldo.taskstracker.panel.filters.SkillFilter;
import net.reldo.taskstracker.panel.filters.TierFilter;
import net.reldo.taskstracker.tasktypes.RequiredSkill;
import net.reldo.taskstracker.tasktypes.Task;
import net.runelite.api.Skill;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.ColorScheme;

public class League4TaskPanel extends TaskPanel
{
	public League4TaskPanel(TasksTrackerPlugin plugin, ClientThread clientThread, SpriteManager spriteManager, Task task)
	{
		super(plugin, clientThread, spriteManager, task);
		filters.add(new SkillFilter(plugin.getConfig()));
		filters.add(new TierFilter(plugin.getConfig()));
		filters.add(new AreaFilter(plugin.getConfig()));
		filters.add(new CategoryFilter(plugin.getConfig()));
	}

	@Override
	public JPopupMenu getPopupMenu()
	{
		return null;
	}

	@Override
	public String getTaskTooltip()
	{
		League4Task task = (League4Task) this.task;
		String text = Util.wrapWithBold(task.getName()) + Util.HTML_LINE_BREAK +
			task.getTier() + getPointsTooltipText() + Util.HTML_LINE_BREAK +
			task.getDescription() +
			getSkillSectionHtml();

		text = Util.wrapWithWrappingParagraph(text, 200);

		return Util.wrapWithHtml(text);
	}

	@Override
	public BufferedImage getIcon()
	{
		League4TaskTier tier = League4TaskTier.tiersByName.get(task.getTier().toLowerCase());
		if (tier == null)
		{
			return null;
		}

		return spriteManager.getSprite(tier.spriteId, 0);
	}

	// TODO (1/29/22): The required skill loop code is repeated in getSkillSectionHtml
	//  Ideally, checking skill requirements would be a responsibility of Task
	//  Current issue is that Task is instantiated by Gson in multiple places, so plugin may not be injected/accessible
	@Override
	public Color getTaskBackgroundColor(Task task, int[] playerSkills)
	{
		if (playerSkills == null)
		{
			return ColorScheme.DARKER_GRAY_COLOR;
		}

		if (task.isCompleted())
		{
			return COMPLETED_BACKGROUND_COLOR;
		}

		for (RequiredSkill requiredSkill : ((League4Task) task).getSkills())
		{
			Skill skill;
			// FIXME: Shouldn't use exception for control flow
			try
			{
				skill = Skill.valueOf(requiredSkill.skill.toUpperCase());
			}
			catch (IllegalArgumentException ex)
			{
				continue;
			}

			int level;
			// FIXME: Shouldn't use exception for control flow
			try
			{
				level = Integer.parseInt(requiredSkill.level);
			}
			catch (NumberFormatException ex)
			{
				continue;
			}

			if (playerSkills[skill.ordinal()] < level)
			{
				return UNQUALIFIED_BACKGROUND_COLOR;
			}
		}

		return ColorScheme.DARKER_GRAY_COLOR;
	}

	private String getPointsTooltipText()
	{
		int points = this.task.getPoints();
		if (points == 0)
		{
			return "";
		}
		return " - " + points + " points";
	}

	private String getSkillSectionHtml()
	{
		StringBuilder skillSection = new StringBuilder();
		League4Task task = (League4Task) this.task;
		for (RequiredSkill requiredSkill : task.getSkills())
		{
			Skill skill;
			// FIXME: Shouldn't use exception for control flow
			try
			{
				skill = Skill.valueOf(requiredSkill.skill.toUpperCase());
			}
			catch (IllegalArgumentException ex)
			{
				continue;
			}

			int level;
			// FIXME: Shouldn't use exception for control flow
			try
			{
				level = Integer.parseInt(requiredSkill.level);
			}
			catch (NumberFormatException ex)
			{
				continue;
			}

			skillSection.append(Util.HTML_LINE_BREAK);

			int playerLevel = 255;
			if (this.plugin.playerSkills != null)
			{
				playerLevel = this.plugin.playerSkills[skill.ordinal()];
			}
			skillSection.append(getSkillRequirementHtml(requiredSkill.getSkill().toLowerCase(), playerLevel, level));
		}

		return skillSection.toString();
	}

	private String getSkillRequirementHtml(String skillName, int playerLevel, int requiredLevel)
	{
		String skillIconPath = "/skill_icons_small/" + skillName + ".png";
		URL url = SkillIconManager.class.getResource(skillIconPath);
		Color color = playerLevel >= requiredLevel ? QUALIFIED_TEXT_COLOR : UNQUALIFIED_TEXT_COLOR;
		return Util.imageTag(url) + " " + Util.colorTag(color, playerLevel + "/" + requiredLevel);
	}
}

package net.reldo.taskstracker.tasktypes.league4;

import java.util.ArrayList;
import java.util.List;
import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public enum League4Varbits
{
	// Relics
	RELIC_SLOT_1(10049),
	RELIC_SLOT_2(10050),
	RELIC_SLOT_3(10051),
	RELIC_SLOT_4(10052),
	RELIC_SLOT_5(10053),
	RELIC_SLOT_6(11696),
	RELIC_SLOT_7(17301),
	RELIC_SLOT_8(17302),

	// Regions

	// Task data
	TASKS_COMPLETED(10046),
	LIBRARY_BOOKS(10039);

	private final int varbitId;

	@Getter
	private static final List<Integer> allVarbitIds = new ArrayList<>();

	static
	{
		for (League4Varbits varbit : League4Varbits.values())
		{
			allVarbitIds.add(varbit.getVarbitId());
		}
	}
}

package net.reldo.taskstracker.tasktypes.league4;

public enum League4TaskArea
{
    //@todo Add sprite IDs
    GLOBAL(0),
    MISTHALIN(0),
    KARAMJA(0),
    ASGARNIA(0),
    FREMENNIK(0),
    KANDARIN(0),
    DESERT(0),
    KOUREND(0),
    MORYTANIA(0),
    TIRANNWN(0),
    WILDERNESS(0);

    public final int spriteId;

    League4TaskArea(int spriteId)
    {
        this.spriteId = spriteId;
    }

    public static League4TaskArea getAreaByName(String name)
    {
        for (League4TaskArea value : values())
        {
            if (value.name().equalsIgnoreCase(name))
            {
                return value;
            }
        }

        return null;
    }
}

package net.reldo.taskstracker.tasktypes.league4;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public enum League4TaskVarps
{
	TASK_PROGRESS_0(2616),
	TASK_PROGRESS_1(2617),
	TASK_PROGRESS_2(2618),
	TASK_PROGRESS_3(2619),
	TASK_PROGRESS_4(2620),
	TASK_PROGRESS_5(2621),
	TASK_PROGRESS_6(2622),
	TASK_PROGRESS_7(2623),
	TASK_PROGRESS_8(2624),
	TASK_PROGRESS_9(2625),
	TASK_PROGRESS_10(2626),
	TASK_PROGRESS_11(2627),
	TASK_PROGRESS_12(2628),
	TASK_PROGRESS_13(2629),
	TASK_PROGRESS_14(2630),
	TASK_PROGRESS_15(2631),
	TASK_PROGRESS_16(2808),
	TASK_PROGRESS_17(2809),
	TASK_PROGRESS_18(2810),
	TASK_PROGRESS_19(2811),
	TASK_PROGRESS_20(2812),
	TASK_PROGRESS_21(2813),
	TASK_PROGRESS_22(2814),
	TASK_PROGRESS_23(2815),
	TASK_PROGRESS_24(2816),
	TASK_PROGRESS_25(2817),
	TASK_PROGRESS_26(2818),
	TASK_PROGRESS_27(2819),
	TASK_PROGRESS_28(2820),
	TASK_PROGRESS_29(2821),
	TASK_PROGRESS_30(2822),
	TASK_PROGRESS_31(2823),
	TASK_PROGRESS_32(2824),
	TASK_PROGRESS_33(2825),
	TASK_PROGRESS_34(2826),
	TASK_PROGRESS_35(2827),
	TASK_PROGRESS_36(2828),
	TASK_PROGRESS_37(2829),
	TASK_PROGRESS_38(2830),
	TASK_PROGRESS_39(2831),
	TASK_PROGRESS_40(2832),
	TASK_PROGRESS_41(2833),
	TASK_PROGRESS_42(2834),
	TASK_PROGRESS_43(2835),
	TASK_PROGRESS_44(3339),
	TASK_PROGRESS_45(3340),
	TASK_PROGRESS_46(3341),
	TASK_PROGRESS_47(3342),
	TASK_PROGRESS_48(4036),
	TASK_PROGRESS_49(4037),
	TASK_PROGRESS_50(4038),
	TASK_PROGRESS_51(4039),
	TASK_PROGRESS_52(4040),
	TASK_PROGRESS_53(4041),
	TASK_PROGRESS_54(4042),
	TASK_PROGRESS_55(4043),
	TASK_PROGRESS_56(4044),
	TASK_PROGRESS_57(4045),
	TASK_PROGRESS_58(4046),
	TASK_PROGRESS_59(4047),
	TASK_PROGRESS_60(4048),
	TASK_PROGRESS_61(4049);

	private int varpId;

	@Getter
	private static final HashMap<Integer, League4TaskVarps> idToVarpMap = new HashMap<>();

	@Getter
	private static final List<Integer> allVarpIds = new ArrayList<>();

	static
	{
		for (League4TaskVarps varp : League4TaskVarps.values())
		{
			idToVarpMap.put(varp.getVarpId(), varp);
			allVarpIds.add(varp.getVarpId());
		}
	}
}

package net.reldo.taskstracker.tasktypes.league4;

import java.util.HashMap;

public enum League4TaskTier
{
	EASY(2316, 10),
	MEDIUM(2318, 40),
	HARD(2319, 80),
	ELITE(2320, 200),
	MASTER(3739, 400);

	public final int spriteId;
	public final int points;
	public static final HashMap<String, League4TaskTier> tiersByName = new HashMap<>();

	League4TaskTier(int spriteId, int points)
	{
		this.spriteId = spriteId;
		this.points = points;
	}

	static
	{
		for (League4TaskTier tier : values())
		{
			tiersByName.put(tier.name().toLowerCase(), tier);
		}
	}
}

package net.reldo.taskstracker.tasktypes.league4;

public enum League4TaskCategory
{
    //@todo Add sprite IDs
    ACHIEVEMENT(0),
    COMBAT(0),
    QUEST(0),
    SKILL(0),
    MINIGAME(0),
    OTHER(0);

    public final int spriteId;

    League4TaskCategory(int spriteId)
    {
        this.spriteId = spriteId;
    }

    public static League4TaskCategory getCategoryByName(String name)
    {
        for (League4TaskCategory value : values())
        {
            if (value.name().equalsIgnoreCase(name))
            {
                return value;
            }
        }

        return null;
    }
}

package net.reldo.taskstracker.tasktypes;

import com.google.gson.annotations.Expose;
import net.reldo.taskstracker.TasksTrackerPlugin;
import net.reldo.taskstracker.data.reldo.ReldoTaskSave;
import net.reldo.taskstracker.panel.TaskPanel;
import java.time.Instant;
import lombok.Data;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.game.SpriteManager;

@Data
public abstract class Task
{
	@Expose
	private final int id;
	private final String name;
	private final String description;
	private final String tier;
	private final int clientSortId;

	@Expose
	private long completedOn;
	@Expose
	private long trackedOn;
	@Expose
	private long ignoredOn;

	private RequiredSkill[] skills = null;

	private String area;
	private String taskCategory;

	public boolean isCompleted()
	{
		return completedOn > 0;
	}

	public int getPoints()
	{
		return 0;
	}

	public void setCompleted(boolean completed)
	{
		long now = Instant.now().toEpochMilli();
		if (completed && completedOn > 0 && completedOn <= now)
		{
			return;
		}
		completedOn = completed ? now : 0;
	}

	public boolean isTracked()
	{
		return trackedOn > 0;
	}

	public void setTracked(boolean state)
	{
		long now = Instant.now().toEpochMilli();
		if (state && trackedOn > 0 && trackedOn <= now)
		{
			return;
		}
		trackedOn = state ? now : 0;
	}

	public boolean isIgnored()
	{
		return ignoredOn > 0;
	}

	public void setIgnored(boolean state)
	{
		long now = Instant.now().toEpochMilli();
		if (state && ignoredOn > 0 && ignoredOn <= now)
		{
			return;
		}
		ignoredOn = state ? now : 0;
	}

	public void loadConfigSave(Task loadedData)
	{
		setDates(loadedData.getCompletedOn(), loadedData.getIgnoredOn(), loadedData.getTrackedOn());
	}

	public void loadReldoSave(ReldoTaskSave loadedData)
	{
		setMostRecentDates(loadedData.getCompleted(), loadedData.getIgnored(), loadedData.getTodo());
	}

	private void setDates(long completedOn, long ignoredOn, long trackedOn)
	{
		// Set all dates regardless of how they compare
		this.setCompletedOn(completedOn);
		this.setIgnoredOn(ignoredOn);
		this.setTrackedOn(trackedOn);
	}

	private void setMostRecentDates(long completedOn, long ignoredOn, long trackedOn)
	{
		// Older completions take priority; incomplete (0) also takes priority
		if (completedOn < this.getCompletedOn())
		{
			this.setCompletedOn(completedOn);
		}
		// Newer ignores take priority
		if (ignoredOn > this.getIgnoredOn())
		{
			this.setIgnoredOn(ignoredOn);
		}
		// Newer tracks take priority
		if (trackedOn > this.getTrackedOn())
		{
			this.setTrackedOn(trackedOn);
		}
	}

	public abstract TaskType getType();

	public abstract TaskPanel generatePanel(TasksTrackerPlugin plugin, ClientThread clientThread, SpriteManager spriteManager, SkillIconManager skillIconManager);
}

package net.reldo.taskstracker.tasktypes;

import lombok.Data;

@Data
public class RequiredSkill
{
	public String skill;
	public String level;
}

package net.reldo.taskstracker.tasktypes;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.stream.Collectors;
import lombok.extern.slf4j.Slf4j;
import net.reldo.taskstracker.data.CallbackCommand;
import net.reldo.taskstracker.data.TaskDataClient;

@Slf4j
public class TaskManager
{
	private final TaskDataClient taskDataClient;
	public TaskType taskType;
	public HashMap<Integer, Task> tasks = new HashMap<>();

	public TaskManager(TaskType taskType, TaskDataClient taskDataClient)
	{
		this.taskType = taskType;
		this.taskDataClient = taskDataClient;
	}

	public void asyncLoadTaskSourceData(CallbackCommand<ArrayList<Task>> callback)
	{
		taskDataClient.loadTaskSourceData(taskType, (tasks) -> {
			this.tasks = tasks.stream().collect(Collectors.toMap(Task::getId, v -> v, (prev, next) -> next, HashMap::new));

			callback.execute(tasks);
		});
	}

	public void applyTrackerSave(HashMap<Integer, Task> loadedTasks)
	{
		log.debug("applyTrackerSave");
		if (loadedTasks == null)
		{
			return;
		}

		tasks.values().forEach(task -> {
			Task loadedTask = loadedTasks.get(task.getId());
			if (loadedTask == null)
			{
				return;
			}
			task.loadConfigSave(loadedTask);
		});
	}

	public TasksSummary getSummary()
	{
		return new TasksSummary(tasks.values());
	}
}

package net.reldo.taskstracker.tasktypes;

import net.reldo.taskstracker.tasktypes.combattask.CombatTask;
import net.reldo.taskstracker.tasktypes.league3.League3Task;
import java.lang.reflect.Type;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.reldo.taskstracker.tasktypes.league4.League4Task;

@AllArgsConstructor
@Getter
public enum TaskType
{

	COMBAT("Combat Tasks", "combat_tasks.min.json", CombatTask.class),
	LEAGUE_3("League III: Shattered Relics", "league3_tasks.min.json", League3Task.class),
	LEAGUE_4("League IV: Trailblazer Reloaded", "league4_tasks.min.json", League4Task.class);
	public final String displayString;
	public final String dataFileName;
	public final Type classType;

	@Override
	public String toString()
	{
		return displayString;
	}
}

package net.reldo.taskstracker.tasktypes.combattask;

import java.util.HashMap;

public enum CombatTaskTier
{
	EASY(3399, 1),
	MEDIUM(3400, 2),
	HARD(3401, 3),
	ELITE(3402, 4),
	MASTER(3403, 5),
	GRANDMASTER(3404, 6);

	public final int spriteId;
	public final int points;
	public static final HashMap<String, CombatTaskTier> tiersByName = new HashMap<>();

	CombatTaskTier(int spriteId, int points)
	{
		this.spriteId = spriteId;
		this.points = points;
	}

	static
	{
		for (CombatTaskTier tier : values())
		{
			tiersByName.put(tier.name().toLowerCase(), tier);
		}
	}
}

package net.reldo.taskstracker.tasktypes.combattask;

import java.util.HashMap;
import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public enum CombatTaskVarps
{
	TASK_PROGRESS_0(3116),
	TASK_PROGRESS_1(3117),
	TASK_PROGRESS_2(3118),
	TASK_PROGRESS_3(3119),
	TASK_PROGRESS_4(3120),
	TASK_PROGRESS_5(3121),
	TASK_PROGRESS_6(3122),
	TASK_PROGRESS_7(3123),
	TASK_PROGRESS_8(3124),
	TASK_PROGRESS_9(3125),
	TASK_PROGRESS_10(3126),
	TASK_PROGRESS_11(3127),
	TASK_PROGRESS_12(3128),
	TASK_PROGRESS_13(3387),
	TASK_PROGRESS_14(3718),
	TASK_PROGRESS_15(3773),
	TASK_PROGRESS_16(3774);

	private int varpId;

	@Getter
	private static final HashMap<Integer, CombatTaskVarps> idToVarpMap = new HashMap<>();

	static
	{
		for (CombatTaskVarps varp : CombatTaskVarps.values())
		{
			idToVarpMap.put(varp.getVarpId(), varp);
		}
	}
}

package net.reldo.taskstracker.tasktypes.combattask;

import java.awt.image.BufferedImage;
import java.text.SimpleDateFormat;
import java.util.Date;
import javax.swing.JPopupMenu;
import net.reldo.taskstracker.TasksTrackerPlugin;
import net.reldo.taskstracker.Util;
import net.reldo.taskstracker.panel.TaskPanel;
import net.reldo.taskstracker.panel.filters.TierFilter;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.SpriteManager;

public class CombatTaskPanel extends TaskPanel
{
	private String datePattern = "MM-dd-yyyy hh:mma";
	private SimpleDateFormat simpleDateFormat = new SimpleDateFormat(datePattern);

	public CombatTaskPanel(TasksTrackerPlugin plugin, ClientThread clientThread, SpriteManager spriteManager, CombatTask task)
	{
		super(plugin, clientThread, spriteManager, task);
		filters.add(new TierFilter(plugin.getConfig()));
	}

	@Override
	public JPopupMenu getPopupMenu()
	{
		return null;
	}

	@Override
	public String getTaskTooltip()
	{
		CombatTask task = (CombatTask) this.task;
		String text = Util.wrapWithBold(task.getName()) + Util.HTML_LINE_BREAK +
			task.getTier() + Util.HTML_LINE_BREAK +
			task.getMonster() + Util.HTML_LINE_BREAK +
			task.getDescription();

		if (task.isCompleted())
		{
			text += Util.HTML_LINE_BREAK + Util.HTML_LINE_BREAK + "✔ " + simpleDateFormat.format(new Date(task.getCompletedOn()));
		}

		text = Util.wrapWithWrappingParagraph(text, 200);

		return Util.wrapWithHtml(text);
	}

	@Override
	public BufferedImage getIcon()
	{
		CombatTaskTier tier = CombatTaskTier.tiersByName.get(task.getTier().toLowerCase());
		if (tier == null)
		{
			return null;
		}

		return spriteManager.getSprite(tier.spriteId, 0);
	}
}

package net.reldo.taskstracker.tasktypes.combattask;

import lombok.Getter;
import net.reldo.taskstracker.TasksTrackerPlugin;
import net.reldo.taskstracker.panel.TaskPanel;
import net.reldo.taskstracker.tasktypes.Task;
import net.reldo.taskstracker.tasktypes.TaskType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.game.SpriteManager;

public class CombatTask extends Task
{
	@Getter
	public String monster;
	@Getter
	public String category;

	public CombatTask(int id, String name, String description, String tier, int clientSortId)
	{
		super(id, name, description, tier, clientSortId);
	}

	@Override
	public int getPoints()
	{
		CombatTaskTier tierType = CombatTaskTier.tiersByName.get(this.getTier().toLowerCase());
		return tierType != null ? tierType.points : 0;
	}

	@Override
	public TaskType getType()
	{
		return TaskType.COMBAT;
	}

	@Override
	public TaskPanel generatePanel(TasksTrackerPlugin plugin, ClientThread clientThread, SpriteManager spriteManager, SkillIconManager skillIconManager)
	{
		return new CombatTaskPanel(plugin, clientThread, spriteManager, this);
	}
}

package net.reldo.taskstracker.tasktypes.league3;

import java.util.ArrayList;
import java.util.List;
import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public enum League3Varps
{
	LEAGUE_POINTS(2614),
	SAGES_RENOWN(3276);

	private final int varpId;

	@Getter
	private static final List<Integer> allVarpIds = new ArrayList<>();

	static
	{
		for (League3Varps varp : League3Varps.values())
		{
			allVarpIds.add(varp.getVarpId());
		}
	}
}

package net.reldo.taskstracker.tasktypes.league3;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public enum League3TaskVarps
{
	TASK_PROGRESS_0(2616),
	TASK_PROGRESS_1(2617),
	TASK_PROGRESS_2(2618),
	TASK_PROGRESS_3(2619),
	TASK_PROGRESS_4(2620),
	TASK_PROGRESS_5(2621),
	TASK_PROGRESS_6(2622),
	TASK_PROGRESS_7(2623),
	TASK_PROGRESS_8(2624),
	TASK_PROGRESS_9(2625),
	TASK_PROGRESS_10(2626),
	TASK_PROGRESS_11(2627),
	TASK_PROGRESS_12(2628),
	TASK_PROGRESS_13(2629),
	TASK_PROGRESS_14(2630),
	TASK_PROGRESS_15(2631),
	TASK_PROGRESS_16(2808),
	TASK_PROGRESS_17(2809),
	TASK_PROGRESS_18(2810),
	TASK_PROGRESS_19(2811),
	TASK_PROGRESS_20(2812),
	TASK_PROGRESS_21(2813),
	TASK_PROGRESS_22(2814),
	TASK_PROGRESS_23(2815),
	TASK_PROGRESS_24(2816),
	TASK_PROGRESS_25(2817),
	TASK_PROGRESS_26(2818),
	TASK_PROGRESS_27(2819),
	TASK_PROGRESS_28(2820),
	TASK_PROGRESS_29(2821),
	TASK_PROGRESS_30(2822),
	TASK_PROGRESS_31(2823),
	TASK_PROGRESS_32(2824),
	TASK_PROGRESS_33(2825),
	TASK_PROGRESS_34(2826),
	TASK_PROGRESS_35(2827),
	TASK_PROGRESS_36(2828),
	TASK_PROGRESS_37(2829),
	TASK_PROGRESS_38(2830),
	TASK_PROGRESS_39(2831),
	TASK_PROGRESS_40(2832),
	TASK_PROGRESS_41(2833),
	TASK_PROGRESS_42(2834),
	TASK_PROGRESS_43(2835),
	TASK_PROGRESS_44(3339),
	TASK_PROGRESS_45(3340),
	TASK_PROGRESS_46(3341),
	TASK_PROGRESS_47(3342);

	private int varpId;

	@Getter
	private static final HashMap<Integer, League3TaskVarps> idToVarpMap = new HashMap<>();

	@Getter
	private static final List<Integer> allVarpIds = new ArrayList<>();

	static
	{
		for (League3TaskVarps varp : League3TaskVarps.values())
		{
			idToVarpMap.put(varp.getVarpId(), varp);
			allVarpIds.add(varp.getVarpId());
		}
	}
}

package net.reldo.taskstracker.tasktypes.league3;

import net.reldo.taskstracker.TasksTrackerPlugin;
import net.reldo.taskstracker.Util;
import net.reldo.taskstracker.panel.TaskPanel;
import net.reldo.taskstracker.panel.filters.SkillFilter;
import net.reldo.taskstracker.panel.filters.TierFilter;
import net.reldo.taskstracker.tasktypes.RequiredSkill;
import net.reldo.taskstracker.tasktypes.Task;
import java.awt.Color;
import java.awt.image.BufferedImage;
import java.net.URL;
import javax.swing.JPopupMenu;
import net.runelite.api.Skill;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.ColorScheme;

public class League3TaskPanel extends TaskPanel
{
	public League3TaskPanel(TasksTrackerPlugin plugin, ClientThread clientThread, SpriteManager spriteManager, Task task)
	{
		super(plugin, clientThread, spriteManager, task);
		filters.add(new SkillFilter(plugin.getConfig()));
		filters.add(new TierFilter(plugin.getConfig()));
	}

	@Override
	public JPopupMenu getPopupMenu()
	{
		return null;
	}

	@Override
	public String getTaskTooltip()
	{
		League3Task task = (League3Task) this.task;
		String text = Util.wrapWithBold(task.getName()) + Util.HTML_LINE_BREAK +
			task.getTier() + Util.HTML_LINE_BREAK +
			task.getDescription() +
			getSkillSectionHtml();

		text = Util.wrapWithWrappingParagraph(text, 200);

		return Util.wrapWithHtml(text);
	}

	@Override
	public BufferedImage getIcon()
	{
		League3TaskTier tier = League3TaskTier.getTierByName(task.getTier());
		if (tier == null)
		{
			return null;
		}

		return spriteManager.getSprite(tier.spriteId, 0);
	}

	// TODO (1/29/22): The required skill loop code is repeated in getSkillSectionHtml
	//  Ideally, checking skill requirements would be a responsibility of Task
	//  Current issue is that Task is instantiated by Gson in multiple places, so plugin may not be injected/accessible
	@Override
	public Color getTaskBackgroundColor(Task task, int[] playerSkills)
	{
		if (playerSkills == null)
		{
			return ColorScheme.DARKER_GRAY_COLOR;
		}

		if (task.isCompleted())
		{
			return COMPLETED_BACKGROUND_COLOR;
		}

		for (RequiredSkill requiredSkill : ((League3Task) task).getSkills())
		{
			Skill skill;
			// FIXME: Shouldn't use exception for control flow
			try
			{
				skill = Skill.valueOf(requiredSkill.skill.toUpperCase());
			}
			catch (IllegalArgumentException ex)
			{
				continue;
			}

			int level;
			// FIXME: Shouldn't use exception for control flow
			try
			{
				level = Integer.parseInt(requiredSkill.level);
			}
			catch (NumberFormatException ex)
			{
				continue;
			}

			if (playerSkills[skill.ordinal()] < level)
			{
				return UNQUALIFIED_BACKGROUND_COLOR;
			}
		}

		return ColorScheme.DARKER_GRAY_COLOR;
	}

	private String getSkillSectionHtml()
	{
		StringBuilder skillSection = new StringBuilder();
		League3Task task = (League3Task) this.task;
		for (RequiredSkill requiredSkill : task.getSkills())
		{
			Skill skill;
			// FIXME: Shouldn't use exception for control flow
			try
			{
				skill = Skill.valueOf(requiredSkill.skill.toUpperCase());
			}
			catch (IllegalArgumentException ex)
			{
				continue;
			}

			int level;
			// FIXME: Shouldn't use exception for control flow
			try
			{
				level = Integer.parseInt(requiredSkill.level);
			}
			catch (NumberFormatException ex)
			{
				continue;
			}

			skillSection.append(Util.HTML_LINE_BREAK);

			int playerLevel = 255;
			if (this.plugin.playerSkills != null)
			{
				playerLevel = this.plugin.playerSkills[skill.ordinal()];
			}
			skillSection.append(getSkillRequirementHtml(requiredSkill.getSkill().toLowerCase(), playerLevel, level));
		}

		return skillSection.toString();
	}

	private String getSkillRequirementHtml(String skillName, int playerLevel, int requiredLevel)
	{
		String skillIconPath = "/skill_icons_small/" + skillName + ".png";
		URL url = SkillIconManager.class.getResource(skillIconPath);
		Color color = playerLevel >= requiredLevel ? QUALIFIED_TEXT_COLOR : UNQUALIFIED_TEXT_COLOR;
		return Util.imageTag(url) + " " + Util.colorTag(color, playerLevel + "/" + requiredLevel);
	}
}

package net.reldo.taskstracker.tasktypes.league3;

import java.util.ArrayList;
import java.util.List;
import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public enum League3Varbits
{
	// Fragments
	FRAGMENT_SLOT_1(13395),
	FRAGMENT_SLOT_2(13396),
	FRAGMENT_SLOT_3(13397),
	FRAGMENT_SLOT_4(13398),
	FRAGMENT_SLOT_5(13399),
	FRAGMENT_SLOT_6(13401),
	FRAGMENT_SLOT_7(13402),

	// Skill unlocks
	ATTACK_UNLOCKED(13344),
	STRENGTH_UNLOCKED(13345),
	HITPOINTS_UNLOCKED(13348),
	RANGED_UNLOCKED(13346),
	PRAYER_UNLOCKED(13349),
	MAGIC_UNLOCKED(13347),
	COOKING_UNLOCKED(13356),
	WOODCUTTING_UNLOCKED(13358),
	FLETCHING_UNLOCKED(13359),
	FIREMAKING_UNLOCKED(13357),
	CRAFTING_UNLOCKED(13352),
	SMITHING_UNLOCKED(13355),
	MINING_UNLOCKED(13354),
	HERBLORE_UNLOCKED(13351),
	AGILITY_UNLOCKED(13350),
	SLAYER_UNLOCKED(13360),
	FARMING_UNLOCKED(13361),
	RUNECRAFT_UNLOCKED(13353),
	HUNTER_UNLOCKED(13363),
	CONSTRUCTION_UNLOCKED(13362),

	// Boss unlocks
	ABYSSAL_SIRE_UNLOCKED(13393),
	GREAT_OLM_UNLOCKED(13388),
	KALPHITE_QUEEN_UNLOCKED(13366),
	BRYOPHYTA_UNLOCKED(13368),
	HESPORI_UNLOCKED(13372),
	DHAROK_THE_WRETCHED_UNLOCKED(13370),
	SARACHNIS_UNLOCKED(13373),
	PYROMANCER_UNLOCKED(13391),
	TEMPOROSS_UNLOCKED(13390),
	NEX_UNLOCKED(13394),
	GIANT_MOLE_UNLOCKED(13365),
	DAGANNOTH_SUPREME_UNLOCKED(13371),
	ZALCANO_UNLOCKED(13375),
	KREEARRA_UNLOCKED(13382),
	COMMANDER_ZILYANA_UNLOCKED(13384),
	CERBERUS_UNLOCKED(13381),
	GENERAL_GRAARDOR_UNLOCKED(13383),
	ALCHEMICAL_HYDRA_UNLOCKED(13387),
	DUSK_UNLOCKED(13369),
	KRAKEN_UNLOCKED(13376),
	KING_BLACK_DRAGON_UNLOCKED(13364),
	VERZIK_VITUR_UNLOCKED(13389),
	THERMONUCLEAR_SMOKE_DEVIL_UNLOCKED(13378),
	THE_NIGHTMARE_UNLOCKED(13386),
	SKOTIZO_UNLOCKED(13374),
	OBOR_UNLOCKED(13367),
	KRIL_TSUTSAROTH_UNLOCKED(13385),
	ZULRAH_UNLOCKED(13379),
	CRYSTALLINE_HUNLLEF_UNLOCKED(13377),
	VORKATH_UNLOCKED(13380),
	CORPOREAL_BEAST_UNLOCKED(13392),

	// Fragments
	FRAGMENT_UNLOCKED_1(13403),
	FRAGMENT_UNLOCKED_2(13404),
	FRAGMENT_UNLOCKED_3(13405),
	FRAGMENT_UNLOCKED_4(13406),
	FRAGMENT_UNLOCKED_5(13407),
	FRAGMENT_UNLOCKED_6(13408),
	FRAGMENT_UNLOCKED_7(13409),
	FRAGMENT_UNLOCKED_8(13410),
	FRAGMENT_UNLOCKED_9(13411),
	FRAGMENT_UNLOCKED_10(13412),
	FRAGMENT_UNLOCKED_11(13413),
	FRAGMENT_UNLOCKED_12(13414),
	FRAGMENT_UNLOCKED_13(13415),
	FRAGMENT_UNLOCKED_14(13416),
	FRAGMENT_UNLOCKED_15(13417),
	FRAGMENT_UNLOCKED_16(13418),
	FRAGMENT_UNLOCKED_17(13419),
	FRAGMENT_UNLOCKED_18(13420),
	FRAGMENT_UNLOCKED_19(13421),
	FRAGMENT_UNLOCKED_20(13422),
	FRAGMENT_UNLOCKED_21(13423),
	FRAGMENT_UNLOCKED_22(13424),
	FRAGMENT_UNLOCKED_23(13425),
	FRAGMENT_UNLOCKED_24(13426),
	FRAGMENT_UNLOCKED_25(13427),
	FRAGMENT_UNLOCKED_26(13428),
	FRAGMENT_UNLOCKED_27(13429),
	FRAGMENT_UNLOCKED_28(13430),
	FRAGMENT_UNLOCKED_29(13431),
	FRAGMENT_UNLOCKED_30(13432),
	FRAGMENT_UNLOCKED_31(13433),
	FRAGMENT_UNLOCKED_32(13434),
	FRAGMENT_UNLOCKED_33(13435),
	FRAGMENT_UNLOCKED_34(13436),
	FRAGMENT_UNLOCKED_35(13437),
	FRAGMENT_UNLOCKED_36(13438),
	FRAGMENT_UNLOCKED_37(13439),
	FRAGMENT_UNLOCKED_38(13440),
	FRAGMENT_UNLOCKED_39(13441),
	FRAGMENT_UNLOCKED_40(13442),
	FRAGMENT_UNLOCKED_41(13443),
	FRAGMENT_UNLOCKED_42(13444),
	FRAGMENT_UNLOCKED_43(13445),
	FRAGMENT_UNLOCKED_44(13446),
	FRAGMENT_UNLOCKED_45(13447),
	FRAGMENT_UNLOCKED_46(13448),
	FRAGMENT_UNLOCKED_47(13449),
	FRAGMENT_UNLOCKED_48(13450),
	FRAGMENT_UNLOCKED_49(13451),
	FRAGMENT_UNLOCKED_50(13452),
	FRAGMENT_UNLOCKED_51(13453),
	FRAGMENT_UNLOCKED_52(13454),
	FRAGMENT_UNLOCKED_53(13455),

	// Fragment XP
	FRAGMENT_XP_1(13403),
	FRAGMENT_XP_2(13404),
	FRAGMENT_XP_3(13405),
	FRAGMENT_XP_4(13406),
	FRAGMENT_XP_5(13407),
	FRAGMENT_XP_6(13408),
	FRAGMENT_XP_7(13409),
	FRAGMENT_XP_8(13410),
	FRAGMENT_XP_9(13411),
	FRAGMENT_XP_10(13412),
	FRAGMENT_XP_11(13413),
	FRAGMENT_XP_12(13414),
	FRAGMENT_XP_13(13415),
	FRAGMENT_XP_14(13416),
	FRAGMENT_XP_15(13417),
	FRAGMENT_XP_16(13418),
	FRAGMENT_XP_17(13419),
	FRAGMENT_XP_18(13420),
	FRAGMENT_XP_19(13421),
	FRAGMENT_XP_20(13422),
	FRAGMENT_XP_21(13423),
	FRAGMENT_XP_22(13424),
	FRAGMENT_XP_23(13425),
	FRAGMENT_XP_24(13426),
	FRAGMENT_XP_25(13427),
	FRAGMENT_XP_26(13428),
	FRAGMENT_XP_27(13429),
	FRAGMENT_XP_28(13430),
	FRAGMENT_XP_29(13431),
	FRAGMENT_XP_30(13432),
	FRAGMENT_XP_31(13433),
	FRAGMENT_XP_32(13434),
	FRAGMENT_XP_33(13435),
	FRAGMENT_XP_34(13436),
	FRAGMENT_XP_35(13437),
	FRAGMENT_XP_36(13438),
	FRAGMENT_XP_37(13439),
	FRAGMENT_XP_38(13440),
	FRAGMENT_XP_39(13441),
	FRAGMENT_XP_40(13442),
	FRAGMENT_XP_41(13443),
	FRAGMENT_XP_42(13444),
	FRAGMENT_XP_43(13445),
	FRAGMENT_XP_44(13446),
	FRAGMENT_XP_45(13447),
	FRAGMENT_XP_46(13448),
	FRAGMENT_XP_47(13449),
	FRAGMENT_XP_48(13450),
	FRAGMENT_XP_49(13451),
	FRAGMENT_XP_50(13452),
	FRAGMENT_XP_51(13453),
	FRAGMENT_XP_52(13454),
	FRAGMENT_XP_53(13455),

	// Task data
	TASKS_COMPLETED(10046),
	LIBRARY_BOOKS(10039);

	private final int varbitId;

	@Getter
	private static final List<Integer> allVarbitIds = new ArrayList<>();

	static
	{
		for (League3Varbits varbit : League3Varbits.values())
		{
			allVarbitIds.add(varbit.getVarbitId());
		}
	}
}

package net.reldo.taskstracker.tasktypes.league3;

public enum League3TaskTier
{
	BEGINNER(2316),
	EASY(2317),
	MEDIUM(2318),
	HARD(2319),
	ELITE(2320),
	MASTER(3739);

	public final int spriteId;

	League3TaskTier(int spriteId)
	{
		this.spriteId = spriteId;
	}

	public static League3TaskTier getTierByName(String name)
	{
		for (League3TaskTier value : values())
		{
			if (value.name().equalsIgnoreCase(name))
			{
				return value;
			}
		}

		return null;
	}
}

package net.reldo.taskstracker.tasktypes.league3;

import net.reldo.taskstracker.TasksTrackerPlugin;
import net.reldo.taskstracker.panel.TaskPanel;
import net.reldo.taskstracker.tasktypes.Task;
import net.reldo.taskstracker.tasktypes.TaskType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.game.SpriteManager;

public class League3Task extends Task
{

	public League3Task(int id, String name, String description, String tier, int clientSortId)
	{
		super(id, name, description, tier, clientSortId);
	}

	@Override
	public TaskType getType()
	{
		return TaskType.LEAGUE_3;
	}

	@Override
	public TaskPanel generatePanel(TasksTrackerPlugin plugin, ClientThread clientThread, SpriteManager spriteManager, SkillIconManager skillIconManager)
	{
		return new League3TaskPanel(plugin, clientThread, spriteManager, this);
	}
}

package net.reldo.taskstracker.quests;

import net.runelite.api.Client;

public enum DiaryVarbits
{
	DIARY_ARDOUGNE_EASY(4458),
	DIARY_ARDOUGNE_MEDIUM(4459),
	DIARY_ARDOUGNE_HARD(4460),
	DIARY_ARDOUGNE_ELITE(4461),
	DIARY_DESERT_EASY(4483),
	DIARY_DESERT_MEDIUM(4484),
	DIARY_DESERT_HARD(4485),
	DIARY_DESERT_ELITE(4486),
	DIARY_FALADOR_EASY(4462),
	DIARY_FALADOR_MEDIUM(4463),
	DIARY_FALADOR_HARD(4464),
	DIARY_FALADOR_ELITE(4465),
	DIARY_FREMENNIK_EASY(4491),
	DIARY_FREMENNIK_MEDIUM(4492),
	DIARY_FREMENNIK_HARD(4493),
	DIARY_FREMENNIK_ELITE(4494),
	DIARY_KANDARIN_EASY(4475),
	DIARY_KANDARIN_MEDIUM(4476),
	DIARY_KANDARIN_HARD(4477),
	DIARY_KANDARIN_ELITE(4478),
	DIARY_KARAMJA_EASY(3578),
	DIARY_KARAMJA_MEDIUM(3599),
	DIARY_KARAMJA_HARD(3611),
	DIARY_KARAMJA_ELITE(4566),
	DIARY_KOUREND_EASY(7925),
	DIARY_KOUREND_MEDIUM(7926),
	DIARY_KOUREND_HARD(7927),
	DIARY_KOUREND_ELITE(7928),
	DIARY_LUMBRIDGE_EASY(4495),
	DIARY_LUMBRIDGE_MEDIUM(4496),
	DIARY_LUMBRIDGE_HARD(4497),
	DIARY_LUMBRIDGE_ELITE(4498),
	DIARY_MORYTANIA_EASY(4487),
	DIARY_MORYTANIA_MEDIUM(4488),
	DIARY_MORYTANIA_HARD(4489),
	DIARY_MORYTANIA_ELITE(4490),
	DIARY_VARROCK_EASY(4479),
	DIARY_VARROCK_MEDIUM(4480),
	DIARY_VARROCK_HARD(4481),
	DIARY_VARROCK_ELITE(4482),
	DIARY_WESTERN_EASY(4471),
	DIARY_WESTERN_MEDIUM(4472),
	DIARY_WESTERN_HARD(4473),
	DIARY_WESTERN_ELITE(4474),
	DIARY_WILDERNESS_EASY(4466),
	DIARY_WILDERNESS_MEDIUM(4467),
	DIARY_WILDERNESS_HARD(4468),
	DIARY_WILDERNESS_ELITE(4469);

	public int id;

	DiaryVarbits(int id) {
		this.id = id;
	}

	public int getProgress(Client client)
	{
		return client.getVarbitValue(id);
	}
}

package net.reldo.taskstracker.quests;

import java.util.HashMap;
import net.runelite.api.Client;
import net.runelite.api.Quest;
import net.runelite.api.QuestState;

// FIXME: Moved diary & minis into another class so chaiin could quickly build out quest data with ids.
// TODO: Goal is to rid this entire package (sans QuestVarbits & QuestVarPlayer) and just send varbs/varps only. Consumers will contain parsing logic
public class QuestData extends HashMap<Integer, QuestState>
{
	public QuestData(Client client)
	{
		for (Quest quest : Quest.values())
		{
			this.put(quest.getId(), quest.getState(client));
		}
	}
}

package net.reldo.taskstracker.quests;

import java.util.HashMap;
import net.runelite.api.Client;

public class DiaryData extends HashMap<Integer, Integer>
{
	public DiaryData(Client client)
	{
		for (DiaryVarbits diary : DiaryVarbits.values())
		{
			this.put(diary.id, diary.getProgress(client));
		}
	}
}

