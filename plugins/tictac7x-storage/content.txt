package tictac7x.storage;

import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.overlay.OverlayManager;
import tictac7x.storage.overlays.InventoryOverlay;
import tictac7x.storage.overlays.StorageOverlay;
import tictac7x.storage.panel.PanelNavigator;
import tictac7x.storage.panel.StoragePanel;
import tictac7x.storage.storage.BankStorage;
import tictac7x.storage.storage.StorageItem;
import tictac7x.storage.storageManagers.DepositBox;
import tictac7x.storage.storage.Storage;
import tictac7x.storage.storage.ConfigStorage;
import tictac7x.storage.storageManagers.LunarLootChest;
import tictac7x.storage.utils.ItemContainerId;
import tictac7x.storage.utils.WidgetId;

import javax.inject.Inject;
import javax.swing.*;
import java.util.*;

@Slf4j
@PluginDescriptor(
	name = "Storage",
	description = "Show overlays of inventory and bank",
	tags = { "storage", "bank", "inventory", "item", "poh" }
)
public class TicTac7xStoragePlugin extends Plugin {
	private String pluginVersion = "v0.6";
	private String pluginMessage = "" +
		"<colHIGHLIGHT>Storage " + pluginVersion + ":<br>" +
		"<colHIGHLIGHT>* Player house items now searchable from the panel.<br>" +
		"<colHIGHLIGHT>* Panel performance improvements.<br>" +
		"<colHIGHLIGHT>* Lunar chest support."
	;

	@Inject
	private Client client;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private TicTac7xStorageConfig config;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ConfigManager configManager;

	@Inject
	private ItemManager itemManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Provides
	TicTac7xStorageConfig provideConfig(final ConfigManager configManager) {
		return configManager.getConfig(TicTac7xStorageConfig.class);
	}

	private List<Storage> storages;

	private StorageOverlay[] storageOverlays;

	private StoragePanel storagePanel;

	private PanelNavigator panelNavigator;

	private LunarLootChest lunarLootChest;

	@Override
	protected void startUp() {
		configMigration();
		storages = new ArrayList<>();

		final BankStorage bankStorage = new BankStorage(clientThread, configManager);
		storages.add(bankStorage);

		final Storage inventoryStorage = new Storage(ItemContainerId.INVENTORY);
		storages.add(inventoryStorage);

		final ConfigStorage homeStorage = new ConfigStorage(TicTac7xStorageConfig.home, ItemContainerId.HOME, clientThread, configManager);
		storages.add(homeStorage);

		lunarLootChest = new LunarLootChest(ItemContainerId.LUNAR_LOOT_CHEST, bankStorage, client, config);
		storages.add(lunarLootChest);

		new DepositBox(client, inventoryStorage, bankStorage);

		storageOverlays = new StorageOverlay[]{
			new InventoryOverlay(TicTac7xStorageConfig.inventory, inventoryStorage, WidgetId.INVENTORY, client, clientThread, overlayManager, configManager, itemManager, config),
			new StorageOverlay(TicTac7xStorageConfig.bank, bankStorage, WidgetId.BANK, client, clientThread, overlayManager, configManager, itemManager, config)
		};

		// Panel
		storagePanel = new StoragePanel(Arrays.asList(bankStorage, homeStorage), clientThread, itemManager);
		panelNavigator = new PanelNavigator(clientToolbar, config, storagePanel);

		// Load storage items from config.
		for (final Storage storage : storages) {
			if (storage instanceof ConfigStorage) {
				((ConfigStorage) storage).loadFromConfig(itemManager);
			}
		}
	}

	@Override
	protected void shutDown() {
		panelNavigator.shutDown();

		for (final StorageOverlay storageOverlay : storageOverlays) {
			storageOverlay.shutDown();
		}
	}

	@Subscribe
	public void onItemContainerChanged(final ItemContainerChanged event) {
		for (final Storage storage : storages) {
			if (event.getContainerId() != storage.itemContainerId) continue;
			final List<StorageItem> items = new ArrayList<>();

			for (final Item item : event.getItemContainer().getItems()) {
				if (item.getId() == -1) continue;
				final ItemComposition itemComposition = itemManager.getItemComposition(item.getId());

				// Valid item.
				items.add(new StorageItem(
					itemComposition.getPlaceholderTemplateId() != -1 ? itemComposition.getPlaceholderId() : item.getId(),
					itemComposition.getPlaceholderTemplateId() != -1 ? 0 : item.getQuantity(),
					itemComposition.getName()
				));
			}

			storage.addItems(items);
		}
	}

	@Subscribe
	public void onWidgetLoaded(final WidgetLoaded event) {
		lunarLootChest.onWidgetLoaded(event);
	}

	@Subscribe
	public void onWidgetClosed(final WidgetClosed event) {
		lunarLootChest.onWidgetClosed(event);
	}

	@Subscribe
	public void onMenuOptionClicked(final MenuOptionClicked event) {
		lunarLootChest.onMenuOptionClicked(event);
	}

	@Subscribe
	public void onConfigChanged(final ConfigChanged event) {
		if (!event.getGroup().equals(TicTac7xStorageConfig.group)) return;

		panelNavigator.onConfigChanged(event);
		lunarLootChest.onConfigChanged(event);

		for (final StorageOverlay storageOverlay : storageOverlays) {
			storageOverlay.onConfigChanged(event);
		}
	}

	@Subscribe
	public void onGameStateChanged(final GameStateChanged event) {
		// Plugin update message.
		if (event.getGameState() == GameState.LOGGED_IN && !config.getVersion().equals(pluginVersion)) {
			configManager.setConfiguration(TicTac7xStorageConfig.group, TicTac7xStorageConfig.version, pluginVersion);
			chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.CONSOLE)
				.runeLiteFormattedMessage(pluginMessage)
				.build()
			);
		}
	}

	private void configMigration() {
		// v0.5.1 -> v0.6
		final Optional<String> inventory = Optional.ofNullable(configManager.getConfiguration(TicTac7xStorageConfig.group, "inventory"));
		if (inventory.isPresent()) {
			configManager.setConfiguration(TicTac7xStorageConfig.group, TicTac7xStorageConfig.inventory + TicTac7xStorageConfig.storage, inventory.get());
			configManager.unsetConfiguration(TicTac7xStorageConfig.group, "inventory");
		}

		final Optional<String> bank = Optional.ofNullable(configManager.getConfiguration(TicTac7xStorageConfig.group, "bank"));
		if (bank.isPresent()) {
			configManager.setConfiguration(TicTac7xStorageConfig.group, TicTac7xStorageConfig.bank + TicTac7xStorageConfig.storage, bank.get());
			configManager.unsetConfiguration(TicTac7xStorageConfig.group, "bank");
		}
	}

	public static Optional<Widget> getWidget(final int[] ids, final Client client) {
		return Optional.ofNullable(client.getWidget(ids[0], ids[1]));
	}

	public static Optional<Widget> getWidget(final int id1, final int id2, final int id3, final Client client) {
		final Optional<Widget> widget = Optional.ofNullable(client.getWidget(id1, id2));

		if (widget.isPresent()) {
			return Optional.ofNullable(widget.get().getChild(id3));
		} else {
			return Optional.empty();
		}
	}

	private static final Map<String, ImageIcon> iconCache = new HashMap<>();

	public static ImageIcon getCachedIcon(final int itemId, final int itemQuantity, final ItemManager itemManager) {
		final String multiKey = itemId + "_" + itemQuantity;

		if (!iconCache.containsKey(multiKey)) {
			iconCache.put(multiKey, new ImageIcon(itemManager.getImage(itemId, itemQuantity, true)));
		}

		return iconCache.get(multiKey);
	}
}

package tictac7x.storage.utils;

public class WidgetId {
    public static int[] BANK = new int[]{12, 1};
    public static int[] INVENTORY = new int[]{149, 0};
    public static int[] DEPOSIT_BOX = new int[]{192, 23};
    public static int[] LUNAR_LOOT_CHEST = new int[]{868, 0};
}

package tictac7x.storage.utils;

import net.runelite.api.InventoryID;

public class ItemContainerId {
    public static final int INVENTORY = 93;
    public static final int BANK = 95;
    public static final int HOME = 33405;
    public static final int LUNAR_LOOT_CHEST = 847;
}

package tictac7x.storage;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigSection;

@ConfigGroup(TicTac7xStorageConfig.group)
public interface TicTac7xStorageConfig extends Config {
	String group = "tictac7x-storage";
	String visible = "_visible";
	String hidden = "_hidden";
	String show = "_show";
	String auto_hide = "_auto_hide";
	String storage = "_storage";
	String panel_priority = "panel_priority";
	String version = "version";
	String home = "home";
	String lunar_chest_hide_close = "lunar_chest_hide_close";

	enum InventoryEmpty { TOP, FIRST, LAST, BOTTOM, HIDDEN }

	@ConfigItem(
		keyName = version,
		name = "Version",
		description = "Plugin version",
		hidden = true
	) default String getVersion() {
		return "0";
	}

	@ConfigSection(
		name = "Inventory",
		description = "Inventory overlay settings",
		position = 1
	) String inventory = "inventory";

		@ConfigItem(
			keyName = inventory + show,
			name = "Show inventory overlay",
			description = "Show inventory overlay",
			section = inventory,
			position = 1
		) default boolean showInventory() { return true; }

		@ConfigItem(
			keyName = inventory + auto_hide,
			name = "Auto-hide when inventory is open",
			description = "Hide inventory overlay if inventory tab is open",
			section = inventory,
			position = 2
		) default boolean hideInventory() { return true; }

		@ConfigItem(
			keyName = inventory + visible,
			name = "Visible items",
			description = "Names of the items to show in the inventory overlay (all if empty)",
			section = inventory,
			position = 3
		) default String getInventoryVisible() { return ""; }

		@ConfigItem(
			keyName = inventory + hidden,
			name = "Hidden items",
			description = "Names of the items to hide in the inventory overlay",
			section = inventory,
			position = 4
		) default String getInventoryHidden() { return ""; }

		@ConfigItem(
			keyName = inventory + "_empty",
			name = "Empty slots",
			description = "Show the amount of free space in the inventory",
			section = inventory,
			position = 5
		) default InventoryEmpty getInventoryEmpty() { return InventoryEmpty.FIRST; }

	@ConfigSection(
		name = "Bank",
		description = "Bank overlay settings",
		position = 2
	) String bank = "bank";

		@ConfigItem(
			keyName = bank + show,
			name = "Show bank overlay",
			description = "Show bank overlay",
			section = bank,
			position = 1
		) default boolean showBank() { return true; }

		@ConfigItem(
			keyName = bank + auto_hide,
			name = "Auto-hide when bank is open",
			description = "Hide bank overlay if bank is open",
			section = bank,
			position = 2
		) default boolean hideBank() { return true; }

		@ConfigItem(
			keyName = bank + visible,
			name = "Visible items",
			description = "Names of the items to show in the bank overlay (all if empty)",
			section = bank,
			position = 3
		) default String getBankVisible() { return "Coins"; }

		@ConfigItem(
			keyName = bank + hidden,
			name = "Hidden items",
			description = "Names of the items to hide in the bank overlay",
			section = bank,
			position = 4
		) default String getBankHidden() { return ""; }

	@ConfigSection(
		name = "Panel",
		description = "Panel settings",
		position = 3
	) String panel = "panel";

		@ConfigItem(
			keyName = panel,
			name = "Show bank panel",
			description = "Show bank panel on the sidebar where you can check your bank items",
			section = panel,
			position = 1
		) default boolean showPanel() { return true; }

		@ConfigItem(
			keyName = panel_priority,
			name = "Bank panel priority",
			description = "Lower the number, higher the priority and storage icon on the sidebar",
			section = panel,
			position = 2
		) default int getPanelPriority() { return 5; }

	@ConfigSection(
		name = "Loot chests",
		description = "Additional loot chests settings",
		position = 4,
		closedByDefault = false
	) String loot_chests = "loot_chests";

		@ConfigItem(
			keyName = lunar_chest_hide_close,
			name = "Hide Lunar chest close",
			description = "Hide Lunar chest close so you don't ",
			section = loot_chests,
			position = 1
		) default boolean hideLunarChestClose() { return true; }

	@ConfigSection(
		name = "Debug",
		description = "Debug",
		position = 5,
		closedByDefault = true
	) String debug = "debug";

		@ConfigItem(
			keyName = bank + storage,
			name = bank + storage,
			description = bank + storage,
			section = debug,
			position = 1
		) default String getBankStorage() { return ""; }

		@ConfigItem(
			keyName = home + storage,
			name = home + storage,
			description = home + storage,
			section = debug,
			position = 2
		) default String getHomeStorage() { return ""; }
}

package tictac7x.storage.storage;

public class StorageItem {
    public final int id;
    public final String name;
    private int quantity;

    public StorageItem(final int id, final int quantity, final String name) {
        this.id = id;
        this.quantity = quantity;
        this.name = name;
    }

    public StorageItem(final StorageItem item) {
        this.id = item.id;
        this.quantity = item.getQuantity();
        this.name = item.name;
    }

    public void increaseQuantity(final int quantity) {
        this.quantity += quantity;
    }

    public int getQuantity() {
        return quantity;
    }
}

package tictac7x.storage.storage;

import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import tictac7x.storage.TicTac7xStorageConfig;

import java.util.ArrayList;
import java.util.List;

public class ConfigStorage extends Storage {
    public final String configKey;
    private final ClientThread clientThread;
    private final ConfigManager configManager;

    public ConfigStorage(final String configKey, final int itemContainerId, final ClientThread clientThread, final ConfigManager configManager) {
        super(itemContainerId);
        this.configKey = configKey;
        this.clientThread = clientThread;
        this.configManager = configManager;
    }

    public void loadFromConfig(final ItemManager itemManager) {
        final String storageJsonString = configManager.getConfiguration(TicTac7xStorageConfig.group, configKey + TicTac7xStorageConfig.storage);

        try {
            final JsonObject jsonObject = (JsonObject) new JsonParser().parse(storageJsonString);

            clientThread.invoke(() -> {
                final List<StorageItem> items = new ArrayList<>();

                for (final String itemKey : jsonObject.keySet()) {
                    final int itemId = Integer.parseInt(itemKey);
                    final int itemQuantity = jsonObject.get(itemKey).getAsInt();
                    final String itemName = itemManager.getItemComposition(itemId).getName();
                    items.add(new StorageItem(itemId, itemQuantity, itemName));
                }

                addItems(items);
            });
        } catch (final Exception ignored) {}
    }

    @Override
    public void addItems(final List<StorageItem> items) {
        super.addItems(items);
        updateConfig();
    }

    protected void updateConfig() {
        configManager.setConfiguration(TicTac7xStorageConfig.group, configKey + TicTac7xStorageConfig.storage, getJsonString());
    }

    private String getJsonString() {
        final JsonObject jsonObject = new JsonObject();

        for (final StorageItem item : storage.values()) {
            jsonObject.addProperty(String.valueOf(item.id), item.getQuantity());
        }

        return jsonObject.toString();
    }
}

package tictac7x.storage.storage;

import java.util.*;
import java.util.regex.Pattern;

public class Storage {
    public final int itemContainerId;
    protected final Map<Integer, StorageItem> storage = new LinkedHashMap<>();
    private int slotsUsed = 0;
    private final List<Runnable> listeners = new ArrayList<>();

    public Storage(final int itemContainerId) {
        this.itemContainerId = itemContainerId;
    }

    public void addItems(final List<StorageItem> items) {
        storage.clear();
        slotsUsed = 0;

        for (final StorageItem item : items) {
            addItem(item);
        }

        notifyListeners();
    }

    protected void addItem(final StorageItem item) {
        if (storage.containsKey(item.id)) {
            storage.get(item.id).increaseQuantity(item.getQuantity());
        } else {
            storage.put(item.id, item);
        }

        slotsUsed++;
    }

    public int getSlotsUsed() {
        return slotsUsed;
    }

    public List<StorageItem> getItems() {
        return new ArrayList<>(storage.values());
    }

    public List<StorageItem> getItems(final String visibleString, final String hiddenString, final boolean usePrioritize) {
        final String[] visibleList = visibleString.replaceAll("\\*", ".*").split(",");
        final String[] hiddenList = hiddenString.replaceAll("\\*", ".*").split(",");

        final List<StorageItem> startsWithItems = new ArrayList<>();
        final List<StorageItem> containsWordItems = new ArrayList<>();
        final List<StorageItem> otherItems = new ArrayList<>();

        for (final StorageItem item : storage.values()) {
            if (!isItemHidden(item, hiddenList, !usePrioritize) && isItemVisible(item, visibleList, !usePrioritize)) {
                if (usePrioritize && itemStartsWith(item, visibleList, !usePrioritize)) {
                    startsWithItems.add(item);
                } else if (usePrioritize && itemContains(item, visibleList, !usePrioritize)) {
                    containsWordItems.add(item);
                } else {
                    otherItems.add(item);
                }
            }
        }

        final List<StorageItem> allItems = new ArrayList<>();
        allItems.addAll(startsWithItems);
        allItems.addAll(containsWordItems);
        allItems.addAll(otherItems);
        return allItems;
    }

    private boolean itemContains(final StorageItem item, final String[] visibleList, final boolean caseSensitive) {
        for (final String visibleString : visibleList) {
            final Pattern pattern = Pattern.compile("\\b" + Pattern.quote(visibleString) + "\\b", caseSensitive ? 0 : Pattern.CASE_INSENSITIVE);
            if (pattern.matcher(item.name).find()) {
                return true;
            }
        }

        return false;
    }

    private boolean isItemVisible(final StorageItem item, final String[] visibleList, final boolean caseSensitive) {
        if (visibleList.length == 0 || (visibleList.length == 1 && visibleList[0].isEmpty())) return true;

        for (final String visibleString : visibleList) {
            final Pattern pattern = Pattern.compile(visibleString, caseSensitive ? 0 : Pattern.CASE_INSENSITIVE);
            if (pattern.matcher(item.name).find()) {
                return true;
            }
        }

        return false;
    }

    private boolean itemStartsWith(final StorageItem item, final String[] visibleList, final boolean caseSensitive) {
        for (final String visibleString : visibleList) {
            final Pattern pattern = Pattern.compile("^" + Pattern.quote(visibleString), caseSensitive ? 0 : Pattern.CASE_INSENSITIVE);
            if (pattern.matcher(item.name).find()) {
                return true;
            }
        }

        return false;
    }

    private boolean isItemHidden(final StorageItem item, final String[] hiddenList, final boolean caseSensitive) {
        if (hiddenList.length == 0 || (hiddenList.length == 1 && hiddenList[0].isEmpty())) return false;

        for (final String hiddenString : hiddenList) {
            final Pattern pattern = Pattern.compile(hiddenString, caseSensitive ? 0 : Pattern.CASE_INSENSITIVE);
            if (pattern.matcher(item.name).find()) {
                return true;
            }
        }

        return false;
    }

    public void addOnChangeListener(final Runnable listener) {
        listeners.add(listener);
    }

    protected void notifyListeners() {
        for (final Runnable listener : listeners) {
            listener.run();
        }
    }

    public Optional<StorageItem> getItem(final int itemId) {
        return Optional.ofNullable(storage.get(itemId));
    }
}

package tictac7x.storage.storage;

import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import tictac7x.storage.TicTac7xStorageConfig;
import tictac7x.storage.utils.ItemContainerId;

import java.util.List;

public class BankStorage extends ConfigStorage {
    public BankStorage(ClientThread clientThread, ConfigManager configManager) {
        super(TicTac7xStorageConfig.bank, ItemContainerId.BANK, clientThread, configManager);
    }

    public void depositItems(final List<StorageItem> items) {
        for (final StorageItem item : items) {
            addItem(item);
        }

        notifyListeners();
        updateConfig();
    }
}

package tictac7x.storage.storageManagers;

import net.runelite.api.Client;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.Widget;
import net.runelite.client.events.ConfigChanged;
import tictac7x.storage.TicTac7xStorageConfig;
import tictac7x.storage.storage.BankStorage;
import tictac7x.storage.storage.Storage;
import tictac7x.storage.utils.WidgetId;

import java.util.Optional;

import static tictac7x.storage.TicTac7xStoragePlugin.getWidget;

public class LunarLootChest extends Storage {
    private final Client client;
    private final TicTac7xStorageConfig config;
    private final BankStorage bank;
    private Optional<Widget> lunarChestWidget = Optional.empty();

    public LunarLootChest(final int itemContainerId, final BankStorage bank, final Client client, final TicTac7xStorageConfig config) {
        super(itemContainerId);
        this.client = client;
        this.config = config;
        this.bank = bank;
    }

    public void onMenuOptionClicked(final MenuOptionClicked event) {
        if (!lunarChestWidget.isPresent() || !event.getMenuOption().equals("Bank-all")) return;
        bank.depositItems(getItems());
    }

    public void onWidgetLoaded(final WidgetLoaded event) {
        if (event.getGroupId() == WidgetId.LUNAR_LOOT_CHEST[0]) {
            lunarChestWidget = getWidget(WidgetId.LUNAR_LOOT_CHEST, client);
            updateWidget();
        }
    }

    public void onWidgetClosed(final WidgetClosed event) {
        if (event.getGroupId() == WidgetId.LUNAR_LOOT_CHEST[0]) {
            lunarChestWidget = Optional.empty();
        }
    }

    public void onConfigChanged(final ConfigChanged event) {
        if (event.getKey().equals(TicTac7xStorageConfig.lunar_chest_hide_close)) {
            updateWidget();
        }
    }

    private void updateWidget() {
        if (lunarChestWidget.isPresent()) {
            final Optional<Widget> close = Optional.ofNullable(lunarChestWidget.get().getStaticChildren()[0].getChild(11));
            if (close.isPresent()) {
                close.get().setHidden(config.hideLunarChestClose());
            }
        }
    }
}

package tictac7x.storage.storageManagers;

import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;
import tictac7x.storage.storage.BankStorage;
import tictac7x.storage.storage.Storage;
import tictac7x.storage.storage.StorageItem;
import tictac7x.storage.utils.WidgetId;

import java.util.*;

import static tictac7x.storage.TicTac7xStoragePlugin.getWidget;

public class DepositBox {
    private final Client client;
    private final Storage inventory;
    private final BankStorage bank;

    private final List<StorageItem> inventoryItemsBefore = new ArrayList<>();

    public DepositBox(final Client client, final Storage inventory, final BankStorage bank) {
        this.client = client;
        this.inventory = inventory;
        this.bank = bank;

        inventory.addOnChangeListener(this::onInventoryChanged);
    }

    private void onInventoryChanged() {
        final Optional<Widget> depositBoxWidget = getWidget(WidgetId.DEPOSIT_BOX, client);
        if (depositBoxWidget.isPresent() && !depositBoxWidget.get().isHidden()) {
            depositItemsToBank();
        }

        updateInventoryItemsBefore();
    }

    private void depositItemsToBank() {
        final List<StorageItem> items = new ArrayList<>();

        for (final StorageItem itemBefore : inventoryItemsBefore) {
            final Optional<StorageItem> itemAfter = inventory.getItem(itemBefore.id);

            if (itemAfter.isPresent() && itemBefore.getQuantity() - itemAfter.get().getQuantity() != 0) {
                items.add(new StorageItem(itemBefore.id, itemBefore.getQuantity() - itemAfter.get().getQuantity(), itemBefore.name));
            } else {
                items.add(new StorageItem(itemBefore.id, itemBefore.getQuantity(), itemBefore.name));
            }
        }

        bank.depositItems(items);
    }

    private void updateInventoryItemsBefore() {
        inventoryItemsBefore.clear();
        inventoryItemsBefore.addAll(inventory.getItems());
    }
}

package tictac7x.storage.overlays;

import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.components.ImageComponent;
import net.runelite.client.util.ImageUtil;
import tictac7x.storage.TicTac7xStorageConfig;
import tictac7x.storage.storage.Storage;

import java.awt.Color;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.util.Optional;

public class InventoryOverlay extends StorageOverlay {
    private int panelWidth = 0;
    private final BufferedImage inventoryIcon;

    private Optional<ImageComponent> freeWithInventoryImage = Optional.empty();
    private Optional<ImageComponent> freeWithLabel = Optional.empty();

    public InventoryOverlay(final String configKey, final Storage storage, final int[] widgetIds, final Client client, final ClientThread clientThread, final OverlayManager overlayManager, final ConfigManager configManager, final ItemManager itemManager, final TicTac7xStorageConfig config) {
        super(configKey, storage, widgetIds, client, clientThread, overlayManager, configManager, itemManager, config);
        this.inventoryIcon = ImageUtil.loadImageResource(getClass(), "/inventory.png");
        storage.addOnChangeListener(this::updateFreeImages);
    }

    private void updateFreeImages() {
        updateFreeInventoryItem(28 - storage.getSlotsUsed());
        updateFreeWithLabel(28 - storage.getSlotsUsed());
    }

    @Override
    protected void renderBefore() {
        switch (config.getInventoryEmpty()) {
            case TOP:
                this.renderFreeWithLabel();
                return;
            case FIRST:
                if (freeWithInventoryImage.isPresent()) {
                    itemsPanelComponent.getChildren().add(freeWithInventoryImage.get());
                }
        }
    }

    @Override
    protected void renderAfter() {
        switch (config.getInventoryEmpty()) {
            case LAST:
                if (freeWithInventoryImage.isPresent()) {
                    itemsPanelComponent.getChildren().add(freeWithInventoryImage.get());
                }
                return;
            case BOTTOM:
                this.renderFreeWithLabel();
        }
    }

    private void renderFreeWithLabel() {
        // Extra checks to re-render the free text.
        if (
            !freeWithLabel.isPresent() ||
            freeWithLabel.get().getBounds().width == 0 ||
            itemsPanelComponent.getBounds().width != panelWidth
        ) {
            updateFreeWithLabel(28 - storage.getSlotsUsed());
            panelWidth = itemsPanelComponent.getBounds().width;
        }

        if (freeWithLabel.isPresent()) {
            panelComponent.getChildren().add(freeWithLabel.get());
        }
    }

    private void updateFreeInventoryItem(final int empty) {
        final String free = String.valueOf(empty);

        // Make copy of inventory icon.
        final BufferedImage inventoryImage = new BufferedImage(this.inventoryIcon.getWidth(), this.inventoryIcon.getHeight(), this.inventoryIcon.getType());
        final Graphics graphics = inventoryImage.getGraphics();
        graphics.drawImage(this.inventoryIcon, 0, 1, null);

        // Free slots count.
        final FontMetrics fontMetrics = graphics.getFontMetrics();
        graphics.setFont(FontManager.getRunescapeSmallFont());

        // Shadow.
        graphics.setColor(Color.BLACK);
        graphics.drawString(free, 1, 11);

        // Yellow label.
        graphics.setColor(Color.YELLOW);
        graphics.drawString(free, 0, 10);

        graphics.dispose();
        freeWithInventoryImage = Optional.of(new ImageComponent(inventoryImage));
    }

    private void updateFreeWithLabel(final int empty) {
        try {
            final String freeText = empty + " free";

            final BufferedImage freeImage = new BufferedImage(itemsPanelComponent.getBounds().width - 8, 16, BufferedImage.TYPE_4BYTE_ABGR);
            final Graphics graphics = freeImage.getGraphics();
            final FontMetrics fontMetrics = graphics.getFontMetrics();
            graphics.setFont(FontManager.getRunescapeFont());

            // Shadow.
            graphics.setColor(Color.BLACK);
            graphics.drawString(freeText, ((freeImage.getWidth() - fontMetrics.stringWidth(freeText)) / 2) + 1, fontMetrics.getAscent() + 2);

            // Label.
            graphics.setColor(Color.LIGHT_GRAY);
            graphics.drawString(freeText, (freeImage.getWidth() - fontMetrics.stringWidth(freeText)) / 2, fontMetrics.getAscent() + 1);

            graphics.dispose();
            freeWithLabel = Optional.of(new ImageComponent(freeImage));
        } catch (final Exception ignored) {}
    }
}

package tictac7x.storage.overlays;

import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.ComponentOrientation;
import net.runelite.client.ui.overlay.components.ImageComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;
import tictac7x.storage.TicTac7xStorageConfig;
import tictac7x.storage.storage.Storage;
import tictac7x.storage.storage.StorageItem;

import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

public class StorageOverlay extends OverlayPanel {
    private final String configKey;
    protected final Storage storage;
    private final int[] widgetIds;
    private final Client client;
    private final ClientThread clientThread;
    private final OverlayManager overlayManager;
    private final ConfigManager configManager;
    protected final TicTac7xStorageConfig config;
    private final ItemManager itemManager;

    protected final PanelComponent itemsPanelComponent = new PanelComponent();
    private List<ImageComponent> images = new ArrayList<>();

    public StorageOverlay(final String configKey, final Storage storage, final int[] widgetIds, final Client client, final ClientThread clientThread, final OverlayManager overlayManager, final ConfigManager configManager, final ItemManager itemManager, final TicTac7xStorageConfig config) {
        this.configKey = configKey;
        this.storage = storage;
        this.widgetIds = widgetIds;
        this.client = client;
        this.clientThread = clientThread;
        this.overlayManager = overlayManager;
        this.configManager = configManager;
        this.itemManager = itemManager;
        this.config = config;

        // Overlay configuration.
        setPreferredPosition(OverlayPosition.BOTTOM_RIGHT);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        panelComponent.setGap(new Point(0, 10));
        panelComponent.setOrientation(ComponentOrientation.VERTICAL);
        panelComponent.setBorder(new Rectangle(10, 10, 6, 10));
        itemsPanelComponent.setWrap(true);
        itemsPanelComponent.setBackgroundColor(null);
        itemsPanelComponent.setGap(new Point(6, 4));
        itemsPanelComponent.setOrientation(ComponentOrientation.HORIZONTAL);
        itemsPanelComponent.setBorder(new Rectangle(0,0,0,0));

        overlayManager.add(this);
        storage.addOnChangeListener(this::updateImages);
    }

    public void onConfigChanged(final ConfigChanged event) {
        if (
            event.getKey().equals(configKey + TicTac7xStorageConfig.visible) ||
            event.getKey().equals(configKey + TicTac7xStorageConfig.hidden)
        ) {
            updateImages();
        }
    }

    private void updateImages() {
        final String visibleString = configManager.getConfiguration(TicTac7xStorageConfig.group, this.configKey + TicTac7xStorageConfig.visible);
        final String hiddenString = configManager.getConfiguration(TicTac7xStorageConfig.group, this.configKey + TicTac7xStorageConfig.hidden);

        clientThread.invoke(() -> {
            final List<ImageComponent> images = new ArrayList<>();

            for (final StorageItem item : storage.getItems(visibleString, hiddenString, false)) {
                images.add(new ImageComponent(this.itemManager.getImage(item.id, item.getQuantity(), true)));
            }

            this.images = images;
        });
    }

    private boolean show() {
        return Boolean.parseBoolean(configManager.getConfiguration(TicTac7xStorageConfig.group, this.configKey + TicTac7xStorageConfig.show));
    }

    private boolean autoHide() {
        return Boolean.parseBoolean(configManager.getConfiguration(TicTac7xStorageConfig.group, this.configKey + TicTac7xStorageConfig.auto_hide));
    }

    private boolean isWidgetVisible() {
        final Optional<Widget> widget = Optional.ofNullable(client.getWidget(widgetIds[0], widgetIds[1]));
        return (widget.isPresent() && !widget.get().isHidden());
    }

    @Override
    public Dimension render(final Graphics2D graphics) {
        if (!show() || autoHide() && isWidgetVisible()) return null;

        panelComponent.getChildren().clear();
        itemsPanelComponent.getChildren().clear();

        renderBefore();

        images.forEach(image -> itemsPanelComponent.getChildren().add(image));
        panelComponent.getChildren().add(itemsPanelComponent);

        renderAfter();

        if (itemsPanelComponent.getChildren().size() == 0) return null;
        return super.render(graphics);
    }

    public void shutDown() {
        overlayManager.remove(this);
    }

    protected void renderBefore() {}

    protected void renderAfter() {}
}

package tictac7x.storage.panel;

import net.runelite.client.events.ConfigChanged;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import tictac7x.storage.TicTac7xStorageConfig;

public class PanelNavigator {
    private final ClientToolbar clientToolbar;
    private final TicTac7xStorageConfig config;
    private final StoragePanel storagePanel;

    private NavigationButton navigationButton;

    public PanelNavigator(final ClientToolbar clientToolbar, final TicTac7xStorageConfig config, final StoragePanel storagePanel) {
        this.clientToolbar = clientToolbar;
        this.config = config;
        this.storagePanel = storagePanel;
        updateNavigationButton();
    }

    private void updateNavigationButton() {
        this.navigationButton = NavigationButton.builder()
            .tooltip("Storage")
            .icon(ImageUtil.loadImageResource(getClass(), "/casket.png"))
            .priority(config.getPanelPriority())
            .panel(storagePanel)
            .build();

        if (config.showPanel()) {
            clientToolbar.addNavigation(navigationButton);
        } else {
            clientToolbar.removeNavigation(navigationButton);
        }
    }

    public void onConfigChanged(final ConfigChanged event) {
        if (event.getKey().equals(TicTac7xStorageConfig.panel) || event.getKey().equals(TicTac7xStorageConfig.panel_priority)) {
            updateNavigationButton();
        }
    }

    public void shutDown() {
        clientToolbar.removeNavigation(navigationButton);
    }
}

package tictac7x.storage.panel;

import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import tictac7x.storage.storage.StorageItem;
import tictac7x.storage.utils.ItemContainerId;

import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.Optional;

import static tictac7x.storage.TicTac7xStoragePlugin.getCachedIcon;

import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

public class PanelItem extends JLayeredPane {
    private final ItemManager itemManager;
    private final StorageItem item;
    public final int itemContainerId;

    private static Optional<BufferedImage> pohIcon = Optional.empty();
    private static final int ITEM_WIDTH = PluginPanel.PANEL_WIDTH + 3;
    private static final int ITEM_HEIGHT = 36;
    private static final int ICON_SIZE = 15;


    public PanelItem(final StorageItem item, final int itemContainerId, final ItemManager itemManager) {
        this.itemManager = itemManager;
        this.item = item;
        this.itemContainerId = itemContainerId;

        renderItem();
        addHoverEffect();
    }

    protected void renderItem() {
        setAlignmentX(LEFT_ALIGNMENT);
        setPreferredSize(new Dimension(ITEM_WIDTH, ITEM_HEIGHT));
        setMinimumSize(new Dimension(ITEM_WIDTH, ITEM_HEIGHT));
        setMaximumSize(new Dimension(ITEM_WIDTH, ITEM_HEIGHT));
        setOpaque(true);
        setBackground(ColorScheme.DARKER_GRAY_COLOR);

        final boolean hasIcon = itemContainerId != ItemContainerId.BANK;
        final int itemLabelWidth = ITEM_WIDTH + (hasIcon ? - ICON_SIZE - 7 : -0);
        final JLabel itemLabel = new JLabel();
        itemLabel.setPreferredSize(new Dimension(itemLabelWidth, ITEM_HEIGHT));
        itemLabel.setIcon(getCachedIcon(item.id, item.getQuantity(), itemManager));
        itemLabel.setText(item.name);
        itemLabel.setHorizontalAlignment(SwingConstants.LEFT);
        itemLabel.setBounds(5, 0, itemLabelWidth - 5, ITEM_HEIGHT);
        add(itemLabel, JLayeredPane.DEFAULT_LAYER);

        if (itemContainerId == ItemContainerId.HOME) {
            final BufferedImage smallIcon = getPohIcon();
            final JLabel iconOverlay = new JLabel(new ImageIcon(smallIcon));

            iconOverlay.setBounds(
                itemLabelWidth,
                (ITEM_HEIGHT - ICON_SIZE) / 2,  // Vertically center the icon
                ICON_SIZE,
                ICON_SIZE
            );

            add(iconOverlay, JLayeredPane.PALETTE_LAYER);
        }
    }

    private void addHoverEffect() {
        addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(final MouseEvent event) {
                setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
                setBorder(BorderFactory.createLineBorder(ColorScheme.BORDER_COLOR, 1));
                repaint();
            }

            @Override
            public void mouseExited(final MouseEvent event) {
                setBackground(ColorScheme.DARKER_GRAY_COLOR);
                setBorder(BorderFactory.createEmptyBorder());
                repaint();
            }
        });
    }

    private BufferedImage getPohIcon() {
        if (!pohIcon.isPresent()) {
            pohIcon = Optional.of(ImageUtil.loadImageResource(getClass(), "/poh.png"));
        }

        return pohIcon.get();
    }
}


package tictac7x.storage.panel;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;

import javax.swing.*;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import java.awt.*;
import java.util.function.Consumer;

public class PanelSearch extends JPanel {
    private final Consumer<String> onSearch;
    private final IconTextField search;

    public PanelSearch(final Consumer<String> onSearch) {
        this.onSearch = onSearch;
        this.search = new IconTextField();

        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        setBorder(BorderFactory.createEmptyBorder(7, 7, 7, 7));

        search.setIcon(IconTextField.Icon.SEARCH);
        search.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH + 3, 30));
        search.setMinimumSize(new Dimension(PluginPanel.PANEL_WIDTH + 3, 30));
        search.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH + 3, 30));
        search.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        search.setBorder(BorderFactory.createLineBorder(ColorScheme.BORDER_COLOR, 1));

        // Swap the order in which the borders are applied
        search.setBorder(BorderFactory.createLineBorder(ColorScheme.BORDER_COLOR, 1));
        search.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);

        search.getDocument().addDocumentListener(searchListener());
        add(search);
    }

    private DocumentListener searchListener() {
        return new DocumentListener() {
            @Override
            public void insertUpdate(DocumentEvent documentEvent) {
                onSearch.accept(search.getText());
            }

            @Override
            public void removeUpdate(DocumentEvent documentEvent) {
                onSearch.accept(search.getText());
            }

            @Override
            public void changedUpdate(DocumentEvent documentEvent) {
                onSearch.accept(search.getText());
            }
        };
    }
}
package tictac7x.storage.panel;

import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import tictac7x.storage.storage.Storage;

import javax.swing.*;
import java.awt.*;
import java.util.List;

public class StoragePanel extends PluginPanel {
    private final ClientThread clientThread;

    private final PanelItems panelItems;
    private final List<Storage> storages;
    private String search = "";

    public StoragePanel(final List<Storage> storages, final ClientThread clientThread, final ItemManager itemManager) {
        super(false);
        this.clientThread = clientThread;
        this.storages = storages;

        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

        // Panel search.
        final PanelSearch panelSearch = new PanelSearch((this::searchItems));
        add(panelSearch, BorderLayout.NORTH);

        // Panel items.
        panelItems = new PanelItems(itemManager);

        // Panel scroller.
        final JScrollPane scroller = new JScrollPane(panelItems);
        scroller.setBorder(BorderFactory.createMatteBorder(1, 0, 0, 0, ColorScheme.BORDER_COLOR));
        add(scroller, BorderLayout.SOUTH);

        for (final Storage storage : storages) {
            storage.addOnChangeListener(this::storagesChanged);
        }
    }

    private void storagesChanged() {
        searchItems(search);
    }

    public void searchItems(final String search) {
        this.search = search;

        clientThread.invoke(() -> {
            panelItems.update(storages, search);
        });
    }
}
package tictac7x.storage.panel;

import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import tictac7x.storage.storage.Storage;
import tictac7x.storage.storage.StorageItem;

import javax.swing.*;
import java.util.*;

public class PanelItems extends JPanel {
    private final ItemManager itemManager;
    private final Map<String, PanelItem> itemPanels = new LinkedHashMap<>();

    public PanelItems(final ItemManager itemManager) {
        this.itemManager = itemManager;
        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        setBorder(BorderFactory.createEmptyBorder(7, 7, 0, -7));
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
    }

    public void update(final List<Storage> storages, final String search) {
        final Set<String> visibleMultiKeys = new LinkedHashSet<>();

        for (final Storage storage : storages) {
            for (final StorageItem item : storage.getItems(search, "", true)) {
                final String multiKey = storage.itemContainerId + "_" + item.id + "_" + item.getQuantity();
                visibleMultiKeys.add(multiKey);

                if (!itemPanels.containsKey(multiKey)) {
                    final PanelItem panelItem = new PanelItem(new StorageItem(item), storage.itemContainerId, itemManager);
                    itemPanels.put(multiKey, panelItem);
                }
            }
        }

        SwingUtilities.invokeLater(() -> {
            removeAll();

            for (final String multiKey : visibleMultiKeys) {
                add(itemPanels.get(multiKey));
            }

            revalidate();
            repaint();
        });
    }
}

package tictac7x.storage;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class TicTac7xStoragePluginTest {
	public static void main(String[] args) throws Exception {
		ExternalPluginManager.loadBuiltin(TicTac7xStoragePlugin.class);
		RuneLite.main(args);
	}
}
