package com.clanrankhelper;

import net.runelite.api.Client;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

import javax.inject.Inject;
import java.awt.*;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;

public class ClanRankHelperOverlay extends OverlayPanel
{
    private final ClanRankHelperPlugin plugin;
    private final ClanRankHelperConfig config;

    // Define rank order for sorting
    private static final Map<String, Integer> RANK_ORDER = Map.of(
        "Recruit", 1,
        "Corporal", 2,
        "Sergeant", 3,
        "Cadet", 4,
        "Lieutenant", 5,
        "Captain", 6,
        "Veteran", 7,
        "General", 8,
        "Master", 9
    );

    @Inject
    public ClanRankHelperOverlay(ClanRankHelperPlugin plugin, ClanRankHelperConfig config)
    {
        super(plugin);
        this.plugin = plugin;
        this.config = config;
        setPosition(OverlayPosition.TOP_LEFT);
        setPriority(OverlayPriority.LOW);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (!config.showOverlay())
        {
            return null;
        }

        Map<String, String> pendingChanges = plugin.getPendingRankChanges();
        
        // Always show overlay for debugging
        if (pendingChanges.isEmpty())
        {
            panelComponent.getChildren().add(TitleComponent.builder()
                .text("Clan Rank Helper")
                .color(Color.YELLOW)
                .build());
            panelComponent.getChildren().add(LineComponent.builder()
                .left("No API data loaded")
                .leftColor(Color.GRAY)
                .build());
            panelComponent.getChildren().add(LineComponent.builder()
                .left("Check API URL in config")
                .leftColor(Color.GRAY)
                .build());
            return super.render(graphics);
        }

        // Build list of pending changes - show all confirmed to need a change
        List<Map.Entry<String, String>> displayList = new ArrayList<>();
        
        // Get the sets of confirmed members
        java.util.Set<String> confirmedNeedsChange = plugin.getConfirmedNeedsChange();
        java.util.Set<String> confirmedOk = plugin.getConfirmedOk();
        
        for (Map.Entry<String, String> entry : pendingChanges.entrySet())
        {
            // Skip if target rank is in ignored list
            if (isTargetRankIgnored(entry.getValue()))
            {
                continue;
            }
            
            // Skip if player is in ignored list
            if (isPlayerIgnored(entry.getKey()))
            {
                continue;
            }
            
            String playerNameLower = entry.getKey().toLowerCase();
            
            // Only show if confirmed to need a change
            if (confirmedNeedsChange.contains(playerNameLower))
            {
                displayList.add(entry);
            }
        }
        
        // Calculate how many members have been checked
        int totalFromApi = pendingChanges.size();
        int checkedCount = 0;
        for (Map.Entry<String, String> entry : pendingChanges.entrySet())
        {
            String playerNameLower = entry.getKey().toLowerCase();
            if (confirmedNeedsChange.contains(playerNameLower) || confirmedOk.contains(playerNameLower))
            {
                checkedCount++;
            }
        }

        if (displayList.isEmpty())
        {
            // Show status message
            panelComponent.getChildren().add(TitleComponent.builder()
                .text("Rank Helper")
                .color(Color.GREEN)
                .build());
            
            if (checkedCount < totalFromApi)
            {
                panelComponent.getChildren().add(LineComponent.builder()
                    .left("Checked: " + checkedCount + "/" + totalFromApi)
                    .leftColor(Color.YELLOW)
                    .build());
                panelComponent.getChildren().add(LineComponent.builder()
                    .left("Scroll member list")
                    .leftColor(Color.GRAY)
                    .build());
                panelComponent.getChildren().add(LineComponent.builder()
                    .left("to check all")
                    .leftColor(Color.GRAY)
                    .build());
            }
            else
            {
                panelComponent.getChildren().add(LineComponent.builder()
                    .left("All ranks correct!")
                    .leftColor(Color.GREEN)
                    .build());
            }
            return super.render(graphics);
        }

        // Sort by rank order
        displayList.sort(Comparator.comparingInt(e -> RANK_ORDER.getOrDefault(e.getValue(), 99)));

        // Title
        panelComponent.getChildren().add(TitleComponent.builder()
            .text("Ranks Needed")
            .color(Color.YELLOW)
            .build());

        // Display count
        panelComponent.getChildren().add(LineComponent.builder()
            .left("Need change: " + displayList.size())
            .leftColor(Color.WHITE)
            .build());
        
        if (checkedCount < totalFromApi)
        {
            panelComponent.getChildren().add(LineComponent.builder()
                .left("Checked: " + checkedCount + "/" + totalFromApi)
                .leftColor(Color.GRAY)
                .build());
        }

        panelComponent.getChildren().add(LineComponent.builder()
            .left("─────────────────")
            .leftColor(Color.DARK_GRAY)
            .build());

        // Limit display if configured
        int maxDisplay = config.maxDisplayed();
        int count = 0;

        for (Map.Entry<String, String> entry : displayList)
        {
            if (maxDisplay > 0 && count >= maxDisplay)
            {
                panelComponent.getChildren().add(LineComponent.builder()
                    .left("... and " + (displayList.size() - maxDisplay) + " more")
                    .leftColor(Color.GRAY)
                    .build());
                break;
            }

            String playerName = entry.getKey();
            String targetRank = entry.getValue();
            Color rankColor = getRankColor(targetRank);

            // Capitalize first letter of each word in player name for display
            String displayName = capitalizeWords(playerName);

            panelComponent.getChildren().add(LineComponent.builder()
                .left(displayName)
                .leftColor(Color.WHITE)
                .right("→ " + targetRank)
                .rightColor(rankColor)
                .build());

            count++;
        }

        return super.render(graphics);
    }

    private Color getRankColor(String rank)
    {
        // First check custom rank colors
        Color customColor = getCustomRankColor(rank);
        if (customColor != null)
        {
            return customColor;
        }
        
        // Then check built-in ranks
        switch (rank.toLowerCase())
        {
            case "recruit":
                return config.recruitColor();
            case "corporal":
                return config.corporalColor();
            case "sergeant":
                return config.sergeantColor();
            case "cadet":
                return config.cadetColor();
            case "lieutenant":
                return config.lieutenantColor();
            case "captain":
                return config.captainColor();
            case "veteran":
                return config.veteranColor();
            case "general":
                return config.generalColor();
            case "master":
                return config.masterColor();
            default:
                return config.highlightColor();
        }
    }
    
    private Color getCustomRankColor(String rank)
    {
        String customColors = config.customRankColors();
        if (customColors == null || customColors.trim().isEmpty())
        {
            return null;
        }
        
        String[] pairs = customColors.split(",");
        for (String pair : pairs)
        {
            String[] parts = pair.split(":");
            if (parts.length == 2)
            {
                String rankName = parts[0].trim();
                String hexColor = parts[1].trim();
                
                if (rankName.equalsIgnoreCase(rank))
                {
                    try
                    {
                        return Color.decode(hexColor);
                    }
                    catch (NumberFormatException e)
                    {
                        // Invalid hex, skip
                    }
                }
            }
        }
        return null;
    }

    private String capitalizeWords(String str)
    {
        if (str == null || str.isEmpty())
        {
            return str;
        }
        
        StringBuilder result = new StringBuilder();
        boolean capitalizeNext = true;
        
        for (char c : str.toCharArray())
        {
            if (Character.isWhitespace(c))
            {
                capitalizeNext = true;
                result.append(c);
            }
            else if (capitalizeNext)
            {
                result.append(Character.toUpperCase(c));
                capitalizeNext = false;
            }
            else
            {
                result.append(c);
            }
        }
        
        return result.toString();
    }
    
    private boolean isTargetRankIgnored(String rank)
    {
        String ignoredRanks = config.ignoredTargetRanks();
        if (ignoredRanks == null || ignoredRanks.trim().isEmpty())
        {
            return false;
        }
        
        // Split by comma, newline, or both
        String[] ignored = ignoredRanks.split("[,\\n\\r]+");
        for (String ignoredRank : ignored)
        {
            if (ignoredRank.trim().equalsIgnoreCase(rank.trim()))
            {
                return true;
            }
        }
        return false;
    }
    
    private boolean isPlayerIgnored(String playerName)
    {
        String ignoredPlayers = config.ignoredPlayers();
        if (ignoredPlayers == null || ignoredPlayers.trim().isEmpty())
        {
            return false;
        }
        
        String normalizedName = playerName.toLowerCase().replace(" ", "").replace("-", "").replace("_", "");
        
        // Split by comma, newline, or both
        String[] ignored = ignoredPlayers.split("[,\\n\\r]+");
        for (String ignoredPlayer : ignored)
        {
            String normalizedIgnored = ignoredPlayer.trim().toLowerCase().replace(" ", "").replace("-", "").replace("_", "");
            if (normalizedIgnored.equals(normalizedName))
            {
                return true;
            }
        }
        return false;
    }
}

package com.clanrankhelper;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Provides;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

import javax.inject.Inject;
import java.io.BufferedReader;
import java.io.StringReader;
import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

@Slf4j
@PluginDescriptor(
    name = "Clan Rank Helper",
    description = "Shows clan members who need rank changes based on API data",
    tags = {"clan", "rank", "management"}
)
public class ClanRankHelperPlugin extends Plugin
{
    @Inject
    private Client client;

    @Inject
    private ClanRankHelperConfig config;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private ClanRankHelperOverlay overlay;

    @Inject
    private ClanChatOverlay clanChatOverlay;

    @Inject
    private Gson gson;

    @Inject
    private OkHttpClient okHttpClient;

    @Getter
    private final Map<String, String> pendingRankChanges = new ConcurrentHashMap<>();
    
    @Getter
    private final Set<String> confirmedNeedsChange = ConcurrentHashMap.newKeySet();
    
    @Getter
    private final Set<String> confirmedOk = ConcurrentHashMap.newKeySet();

    private ScheduledExecutorService executor;
    
    @Subscribe
    public void onConfigChanged(ConfigChanged event)
    {
        if (!event.getGroup().equals("clanrankhelper"))
        {
            return;
        }
        
        if (event.getKey().equals("resetData") && config.resetData())
        {
            log.debug("Resetting confirmed data");
            confirmedNeedsChange.clear();
            confirmedOk.clear();
        }
        
        // Re-fetch when API URL changes
        if (event.getKey().equals("apiUrl"))
        {
            log.debug("API URL changed, re-fetching data");
            executor.submit(this::fetchRankData);
        }
        
        // Re-fetch when Google Sheets URL changes
        if (event.getKey().equals("googleSheetsUrl"))
        {
            log.debug("Google Sheets URL changed, re-fetching data");
            executor.submit(this::fetchRankData);
        }
    }

    @Override
    protected void startUp() throws Exception
    {
        log.debug("Clan Rank Helper starting up");
        overlayManager.add(overlay);
        overlayManager.add(clanChatOverlay);
        
        executor = Executors.newSingleThreadScheduledExecutor();
        
        // Fetch immediately on startup
        executor.submit(this::fetchRankData);
        
        // Then refresh periodically based on config
        scheduleRefresh();
        log.debug("Clan Rank Helper started");
    }

    @Override
    protected void shutDown() throws Exception
    {
        log.debug("Clan Rank Helper stopped");
        overlayManager.remove(overlay);
        overlayManager.remove(clanChatOverlay);
        
        if (executor != null)
        {
            executor.shutdown();
        }
        pendingRankChanges.clear();
        confirmedNeedsChange.clear();
        confirmedOk.clear();
    }

    private void scheduleRefresh()
    {
        int refreshMinutes = config.refreshInterval();
        executor.scheduleAtFixedRate(
            this::fetchRankData,
            refreshMinutes,
            refreshMinutes,
            TimeUnit.MINUTES
        );
    }

    private void fetchRankData()
    {
        // Check if Google Sheets URL is configured (takes priority)
        String sheetsUrl = config.googleSheetsUrl();
        if (sheetsUrl != null && !sheetsUrl.trim().isEmpty())
        {
            fetchFromGoogleSheets(sheetsUrl.trim());
            return;
        }
        
        // Otherwise use API URL
        String apiUrl = config.apiUrl();
        if (apiUrl != null && !apiUrl.trim().isEmpty())
        {
            fetchFromApi(apiUrl.trim());
            return;
        }
        
        log.debug("Clan Rank Helper: No API URL or Google Sheets URL configured");
    }

    private void fetchFromGoogleSheets(String sheetsUrl)
    {
        try
        {
            String csvUrl = convertToCsvUrl(sheetsUrl);
            if (csvUrl == null)
            {
                log.error("Clan Rank Helper: Invalid Google Sheets URL format");
                return;
            }

            log.debug("Clan Rank Helper: Fetching from Google Sheets: {}", csvUrl);

            Request request = new Request.Builder()
                    .url(csvUrl)
                    .header("User-Agent", "RuneLite-ClanRankHelper")
                    .build();

            try (Response response = okHttpClient.newCall(request).execute())
            {
                if (!response.isSuccessful())
                {
                    log.error("Clan Rank Helper: Google Sheets returned non-200 response: {}", response.code());
                    return;
                }

                String responseBody = response.body().string();
                Map<String, String> rankMap = new HashMap<>();

                // 1-based -> 0-based
                final int rsnIdx = Math.max(0, config.sheetsRsnColumn() - 1);
                final int rankIdx = Math.max(0, config.sheetsRankColumn() - 1);
                final boolean skipHeader = config.sheetsHasHeader();

                BufferedReader reader = new BufferedReader(new StringReader(responseBody));
                String line;
                boolean firstLine = true;

                while ((line = reader.readLine()) != null)
                {
                    if (firstLine)
                    {
                        firstLine = false;

                        // If user says header exists, skip it no matter what
                        if (skipHeader)
                        {
                            continue;
                        }

                        // Otherwise, keep your old "looks like header" heuristic (optional)
                        String lowerLine = line.toLowerCase();
                        if (lowerLine.contains("rsn") || lowerLine.contains("name") || lowerLine.contains("rank"))
                        {
                            // If you do NOT want any heuristics, delete this block.
                            continue;
                        }
                    }

                    String[] parts = parseCsvLine(line);

                    // Need enough columns to read both indices
                    int maxIdx = Math.max(rsnIdx, rankIdx);
                    if (parts.length <= maxIdx)
                    {
                        continue;
                    }

                    String rsn = parts[rsnIdx].trim();
                    String rank = parts[rankIdx].trim();

                    if (!rsn.isEmpty() && !rank.isEmpty())
                    {
                        // Keep your existing behavior: normalize key for matching
                        rankMap.put(rsn.toLowerCase(), rank);
                    }
                }
                reader.close();

                log.debug("Clan Rank Helper: Fetched {} entries from Google Sheets", rankMap.size());
                updateRankData(rankMap);
            }
        }
        catch (Exception e)
        {
            log.error("Clan Rank Helper: Failed to fetch from Google Sheets", e);
        }
    }
    
    private String convertToCsvUrl(String sheetsUrl)
    {
        // Handle various Google Sheets URL formats
        try
        {
            if (sheetsUrl.contains("/spreadsheets/d/"))
            {
                int startIdx = sheetsUrl.indexOf("/spreadsheets/d/") + 16;
                int endIdx = sheetsUrl.indexOf("/", startIdx);
                if (endIdx == -1)
                {
                    endIdx = sheetsUrl.indexOf("?", startIdx);
                }
                if (endIdx == -1)
                {
                    endIdx = sheetsUrl.length();
                }
                
                String sheetId = sheetsUrl.substring(startIdx, endIdx);
                
                // Check if there's a gid parameter for specific sheet
                String gid = "";
                if (sheetsUrl.contains("gid="))
                {
                    int gidStart = sheetsUrl.indexOf("gid=") + 4;
                    int gidEnd = sheetsUrl.indexOf("&", gidStart);
                    if (gidEnd == -1) gidEnd = sheetsUrl.length();
                    gid = "&gid=" + sheetsUrl.substring(gidStart, gidEnd);
                }
                
                return "https://docs.google.com/spreadsheets/d/" + sheetId + "/export?format=csv" + gid;
            }
        }
        catch (Exception e)
        {
            log.error("Clan Rank Helper: Error parsing Google Sheets URL", e);
        }
        return null;
    }
    
    private String[] parseCsvLine(String line)
    {
        // Simple CSV parser that handles quoted values
        java.util.List<String> result = new java.util.ArrayList<>();
        StringBuilder current = new StringBuilder();
        boolean inQuotes = false;
        
        for (int i = 0; i < line.length(); i++)
        {
            char c = line.charAt(i);
            
            if (c == '"')
            {
                inQuotes = !inQuotes;
            }
            else if (c == ',' && !inQuotes)
            {
                result.add(current.toString());
                current = new StringBuilder();
            }
            else
            {
                current.append(c);
            }
        }
        result.add(current.toString());
        
        return result.toArray(new String[0]);
    }
    
    private void fetchFromApi(String apiUrl)
    {
        try
        {
            log.debug("Clan Rank Helper: Fetching from {}", apiUrl);

            Request request = new Request.Builder()
                .url(apiUrl)
                .header("Accept", "application/json")
                .header("User-Agent", "RuneLite-ClanRankHelper")
                .build();
            
            try (Response response = okHttpClient.newCall(request).execute())
            {
                if (!response.isSuccessful())
                {
                    log.error("Clan Rank Helper: API returned non-200 response: {}", response.code());
                    return;
                }

                String responseBody = response.body().string();
                log.debug("Clan Rank Helper: Got response, parsing JSON...");
                
                // Parse the JSON response
                Type listType = new TypeToken<List<RankEntry>>(){}.getType();
                List<RankEntry> entries = gson.fromJson(responseBody, listType);

                if (entries == null)
                {
                    log.error("Clan Rank Helper: Failed to parse JSON - entries is null");
                    return;
                }

                // Convert to map: playerName -> targetRank
                Map<String, String> rankMap = new HashMap<>();
                for (RankEntry entry : entries)
                {
                    if (entry.mainRSN != null && !entry.mainRSN.isEmpty())
                    {
                        String normalizedName = entry.mainRSN.toLowerCase().trim();
                        rankMap.put(normalizedName, entry.osrsName);
                    }
                }

                log.debug("Clan Rank Helper: Fetched {} pending rank changes", rankMap.size());
                updateRankData(rankMap);
            }
        }
        catch (Exception e)
        {
            log.error("Clan Rank Helper: Failed to fetch rank data", e);
        }
    }

    private void updateRankData(Map<String, String> newData)
    {
        pendingRankChanges.clear();
        pendingRankChanges.putAll(newData);
        confirmedNeedsChange.clear();
        confirmedOk.clear();
        log.debug("Updated rank data: {} pending changes", pendingRankChanges.size());
    }
    
    public void markNeedsChange(String playerName)
    {
        String lower = playerName.toLowerCase();
        confirmedNeedsChange.add(lower);
        confirmedOk.remove(lower);
    }
    
    public void markConfirmedOk(String playerName)
    {
        String lower = playerName.toLowerCase();
        confirmedOk.add(lower);
        confirmedNeedsChange.remove(lower);
    }

    @Provides
    ClanRankHelperConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(ClanRankHelperConfig.class);
    }

    // Inner class for JSON parsing
    private static class RankEntry
    {
        String mainRSN;
        String osrsName;
    }
}

package com.clanrankhelper;

import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;

import javax.inject.Inject;
import java.awt.*;
import java.util.*;
import java.util.List;

public class ClanChatOverlay extends Overlay
{
    private final Client client;
    private final ClanRankHelperPlugin plugin;
    private final ClanRankHelperConfig config;

    private static final int CLAN_SETTINGS_GROUP_ID = 693;

    // Viewport/panel and name column (per your inspector)
    private static final int CLAN_MEMBER_PANEL_CHILD = 9;  // viewport
    private static final int CLAN_MEMBER_NAME_CHILD  = 10; // names live here

    // Row alignment tolerance in pixels
    private static final int ROW_Y_TOLERANCE = 15;

    @Inject
    public ClanChatOverlay(Client client, ClanRankHelperPlugin plugin, ClanRankHelperConfig config)
    {
        super(plugin);
        this.client = client;
        this.plugin = plugin;
        this.config = config;

        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPriority(OverlayPriority.HIGH);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (!config.highlightInChat())
        {
            return null;
        }

        Map<String, String> pendingChanges = plugin.getPendingRankChanges();
        if (pendingChanges == null || pendingChanges.isEmpty())
        {
            return null;
        }

        Widget root = client.getWidget(CLAN_SETTINGS_GROUP_ID, 0);
        if (root == null || root.isHidden())
        {
            return null;
        }

        Widget memberPanel = client.getWidget(CLAN_SETTINGS_GROUP_ID, CLAN_MEMBER_PANEL_CHILD);
        if (memberPanel == null || memberPanel.isHidden())
        {
            return null;
        }

        Rectangle viewport = memberPanel.getBounds();
        if (viewport == null || viewport.width <= 0 || viewport.height <= 0)
        {
            return null;
        }

        Widget nameColumn = client.getWidget(CLAN_SETTINGS_GROUP_ID, CLAN_MEMBER_NAME_CHILD);
        if (nameColumn == null || nameColumn.isHidden())
        {
            return null;
        }

        // All row text under panel (used for rank lookup)
        List<Widget> allRowTextWidgets = new ArrayList<>();
        collectAllTextWidgets(memberPanel, allRowTextWidgets, newSetIdentity());
        if (allRowTextWidgets.isEmpty())
        {
            return null;
        }

        // Only names from the name column
        List<Widget> nameTextWidgets = new ArrayList<>();
        collectAllTextWidgets(nameColumn, nameTextWidgets, newSetIdentity());
        if (nameTextWidgets.isEmpty())
        {
            return null;
        }

        Widget[] rowWidgetArray = allRowTextWidgets.toArray(new Widget[0]);

        for (Widget nameWidget : nameTextWidgets)
        {
            if (nameWidget == null)
            {
                continue;
            }

            String raw = nameWidget.getText();
            if (raw == null || raw.isEmpty())
            {
                continue;
            }

            Rectangle nameBounds = nameWidget.getBounds();
            if (nameBounds == null)
            {
                continue;
            }

            // Only process visible rows
            if (!viewport.intersects(nameBounds))
            {
                continue;
            }

            String playerName = extractCleanText(raw);
            if (playerName == null || playerName.isEmpty())
            {
                continue;
            }

            if (isPlayerIgnored(playerName))
            {
                continue;
            }

            String normalizedName = normalizeName(playerName);

            String targetRank = null;
            for (Map.Entry<String, String> e : pendingChanges.entrySet())
            {
                if (normalizeName(e.getKey()).equals(normalizedName))
                {
                    targetRank = e.getValue();
                    break;
                }
            }

            if (targetRank == null)
            {
                continue;
            }

            // New: rank detection without a whitelist
            String currentRank = findCurrentRankForPlayer(rowWidgetArray, nameWidget);
            if (currentRank == null || currentRank.isEmpty())
            {
                continue;
            }

            if (isRankIgnored(currentRank))
            {
                plugin.markConfirmedOk(playerName);
                continue;
            }

            if (!currentRank.equalsIgnoreCase(targetRank))
            {
                plugin.markNeedsChange(playerName);
                renderHighlight(graphics, nameWidget, targetRank);
            }
            else
            {
                plugin.markConfirmedOk(playerName);
            }
        }

        return null;
    }

    // -----------------------
    // Rank detection (NO whitelist)
    // -----------------------
    private String findCurrentRankForPlayer(Widget[] allWidgets, Widget nameWidget)
    {
        Rectangle nameBounds = nameWidget.getBounds();
        if (nameBounds == null)
        {
            return null;
        }

        String playerNameClean = extractCleanText(nameWidget.getText());
        String playerNameNorm = normalizeName(playerNameClean);

        // Prefer widgets to the RIGHT of the name text (after the name ends)
        final int nameRightX = nameBounds.x + nameBounds.width;

        Widget best = null;
        int bestDx = Integer.MAX_VALUE;

        for (Widget w : allWidgets)
        {
            if (w == null || w == nameWidget)
            {
                continue;
            }

            String txt = w.getText();
            if (txt == null || txt.isEmpty())
            {
                continue;
            }

            Rectangle b = w.getBounds();
            if (b == null)
            {
                continue;
            }

            // Same row
            if (Math.abs(b.y - nameBounds.y) > ROW_Y_TOLERANCE)
            {
                continue;
            }

            // Must be to the right of the name (not just right of name x)
            if (b.x < nameRightX)
            {
                continue;
            }

            String clean = extractCleanText(txt);
            if (clean == null || clean.isEmpty())
            {
                continue;
            }

            // Don’t treat the name itself as the rank
            if (normalizeName(clean).equals(playerNameNorm))
            {
                continue;
            }

            // Only accept text that looks like a rank
            if (!isLikelyRankText(clean))
            {
                continue;
            }

            int dx = b.x - nameRightX;
            if (dx < bestDx)
            {
                bestDx = dx;
                best = w;
            }
        }

        return best == null ? null : extractCleanText(best.getText());
    }
    private boolean isLikelyRankText(String text)
    {
        String s = text.trim();
        if (s.isEmpty())
        {
            return false;
        }

        // Too long to be a rank label (tune if your ranks are long)
        if (s.length() > 20)
        {
            return false;
        }

        String lower = s.toLowerCase();

        // Reject worlds (examples: "W477", "w 477", "world 477")
        if (lower.matches("^w\\s*\\d+$") || lower.matches("^world\\s*\\d+$"))
        {
            return false;
        }

        // Reject pure numbers / times / dates-ish
        if (lower.matches("^\\d+$"))
        {
            return false;
        }
        if (lower.matches("^\\d{1,2}:\\d{2}.*$")) // 10:42, 3:15pm, etc.
        {
            return false;
        }

        // Reject common UI/status strings that are not ranks (add more if you see false positives)
        if (lower.equals("online") || lower.equals("offline") || lower.equals("muted") || lower.equals("banned"))
        {
            return false;
        }

        // Must contain at least one letter
        if (!lower.matches(".*[a-z].*"))
        {
            return false;
        }

        // Allowed characters (letters/digits/spaces/'-/)
        // This still allows “Deputy Owner”, “Co-Leader”, etc.
        return s.matches("^[A-Za-z][A-Za-z0-9 '\\-]{0,19}$");
    }
    // -----------------------
    // Widget collection
    // -----------------------
    private Set<Widget> newSetIdentity()
    {
        return Collections.newSetFromMap(new IdentityHashMap<>());
    }

    private void collectAllTextWidgets(Widget root, List<Widget> out, Set<Widget> visited)
    {
        if (root == null || visited.contains(root))
        {
            return;
        }
        visited.add(root);

        String t = root.getText();
        if (t != null && !t.isEmpty())
        {
            out.add(root);
        }

        Widget[] dyn = root.getDynamicChildren();
        if (dyn != null)
        {
            for (Widget c : dyn)
            {
                collectAllTextWidgets(c, out, visited);
            }
        }

        Widget[] stat = root.getStaticChildren();
        if (stat != null)
        {
            for (Widget c : stat)
            {
                collectAllTextWidgets(c, out, visited);
            }
        }

        Widget[] nested = root.getNestedChildren();
        if (nested != null)
        {
            for (Widget c : nested)
            {
                collectAllTextWidgets(c, out, visited);
            }
        }
    }

    // -----------------------
    // Ignore lists
    // -----------------------
    private boolean isPlayerIgnored(String playerName)
    {
        String ignoredPlayers = config.ignoredPlayers();
        if (ignoredPlayers == null || ignoredPlayers.trim().isEmpty())
        {
            return false;
        }

        String normalizedName = normalizeName(playerName);

        String[] ignored = ignoredPlayers.split("[,\\n\\r]+");
        for (String ignoredPlayer : ignored)
        {
            String n = normalizeName(ignoredPlayer.trim());
            if (!n.isEmpty() && n.equals(normalizedName))
            {
                return true;
            }
        }
        return false;
    }

    private boolean isRankIgnored(String rank)
    {
        String ignoredRanks = config.ignoredRanks();
        if (ignoredRanks == null || ignoredRanks.trim().isEmpty())
        {
            return false;
        }

        String[] ignored = ignoredRanks.split("[,\\n\\r]+");
        for (String ignoredRank : ignored)
        {
            if (ignoredRank.trim().equalsIgnoreCase(rank.trim()))
            {
                return true;
            }
        }
        return false;
    }

    // -----------------------
    // Rendering
    // -----------------------
    private void renderHighlight(Graphics2D graphics, Widget widget, String targetRank)
    {
        Color highlightColor = getRankColor(targetRank);

        Rectangle bounds = widget.getBounds();
        if (bounds == null || bounds.width <= 0 || bounds.height <= 0)
        {
            return;
        }

        graphics.setColor(new Color(
                highlightColor.getRed(),
                highlightColor.getGreen(),
                highlightColor.getBlue(),
                60
        ));
        graphics.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);

        graphics.setColor(highlightColor);
        graphics.drawRect(bounds.x, bounds.y, bounds.width, bounds.height);

        String rankAbbr = getRankAbbreviation(targetRank);
        FontMetrics fm = graphics.getFontMetrics();
        int textWidth = fm.stringWidth(rankAbbr);

        graphics.setColor(Color.BLACK);
        graphics.fillRect(bounds.x + bounds.width - textWidth - 6, bounds.y, textWidth + 6, bounds.height);

        graphics.setColor(highlightColor);
        graphics.drawString(rankAbbr, bounds.x + bounds.width - textWidth - 3, bounds.y + bounds.height - 3);
    }

    // -----------------------
    // Text cleanup / normalization
    // -----------------------
    private String extractCleanText(String widgetText)
    {
        if (widgetText == null)
        {
            return null;
        }

        String cleaned = widgetText.replaceAll("<col=[^>]*>", "").replaceAll("</col>", "");
        cleaned = cleaned.replaceAll("<img=[^>]*>", "");
        cleaned = cleaned.trim();

        return cleaned;
    }

    private String normalizeName(String name)
    {
        if (name == null)
        {
            return "";
        }

        return extractCleanText(name).toLowerCase().trim()
                .replace(" ", "")
                .replace("-", "")
                .replace("_", "");
    }

    // -----------------------
    // Colors / abbreviations
    // -----------------------
    private Color getRankColor(String rank)
    {
        Color customColor = getCustomRankColor(rank);
        if (customColor != null)
        {
            return customColor;
        }

        switch (rank.toLowerCase())
        {
            case "recruit":
                return config.recruitColor();
            case "corporal":
                return config.corporalColor();
            case "sergeant":
                return config.sergeantColor();
            case "cadet":
                return config.cadetColor();
            case "lieutenant":
                return config.lieutenantColor();
            case "captain":
                return config.captainColor();
            case "veteran":
                return config.veteranColor();
            case "general":
                return config.generalColor();
            case "master":
                return config.masterColor();
            default:
                return config.highlightColor();
        }
    }

    private Color getCustomRankColor(String rank)
    {
        String customColors = config.customRankColors();
        if (customColors == null || customColors.trim().isEmpty())
        {
            return null;
        }

        String[] pairs = customColors.split(",");
        for (String pair : pairs)
        {
            String[] parts = pair.split(":");
            if (parts.length == 2)
            {
                String rankName = parts[0].trim();
                String hexColor = parts[1].trim();

                if (rankName.equalsIgnoreCase(rank))
                {
                    try
                    {
                        return Color.decode(hexColor);
                    }
                    catch (NumberFormatException e)
                    {
                        // ignore invalid hex
                    }
                }
            }
        }
        return null;
    }

    private String getRankAbbreviation(String rank)
    {
        if (rank == null || rank.isEmpty())
        {
            return "?";
        }

        switch (rank)
        {
            case "Recruit":
                return "RCT";
            case "Corporal":
                return "CPL";
            case "Sergeant":
                return "SGT";
            case "Cadet":
                return "CDT";
            case "Lieutenant":
                return "LT";
            case "Captain":
                return "CPT";
            case "Veteran":
                return "VET";
            case "General":
                return "GEN";
            case "Master":
                return "MST";
            default:
                String abbr = rank.length() > 3 ? rank.substring(0, 3) : rank;
                return abbr.toUpperCase();
        }
    }
}

package com.clanrankhelper;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

import java.awt.Color;

@ConfigGroup("clanrankhelper")
public interface ClanRankHelperConfig extends Config
{
    @ConfigSection(
        name = "API Settings",
        description = "Configure the API connection",
        position = 0
    )
    String apiSection = "api";

    @ConfigSection(
            name = "Sheets Customization ",
            description = "Configure the API connection",
            position = 1
    )
    String sheetsSection = "SheetsCustom";

    @ConfigSection(
        name = "Display Settings",
        description = "Configure how rank changes are displayed",
        position = 2,
        closedByDefault = true
    )
    String displaySection = "display";

    @ConfigSection(
        name = "Rank Colors",
        description = "Customize colors for each rank",
        position = 3,
        closedByDefault = true
    )
    String rankColorsSection = "rankColors";

    @ConfigItem(
        keyName = "apiUrl",
        name = "API URL",
        description = "URL to fetch pending rank changes. Must return JSON array: [{\"mainRSN\": \"PlayerName\", \"osrsName\": \"TargetRank\"}, ...]",
        section = apiSection,
        position = 0,
        warning = "This plugin submits your IP address to a 3rd party website not controlled or verified by the RuneLite Developers."
    )
    default String apiUrl()
    {
        return "";
    }

    @ConfigItem(
        keyName = "googleSheetsUrl",
        name = "Google Sheets URL",
        description = "URL to a public Google Sheet. Column A = RSN, Column B = Rank (must be the in-game rank name, not clan-specific name). Leave empty to use API URL instead.",
        section = apiSection,
        position = 1,
        warning = "This plugin submits your IP address to a 3rd party website not controlled or verified by the RuneLite Developers."
    )
    default String googleSheetsUrl()
    {
        return "";
    }

    @ConfigItem(
            keyName = "sheetsRsnColumn",
            name = "Sheets RSN column",
            description = "number-based column index in the google sheet that contains the RSN/name (e.g., 1 = column A).",
            section = sheetsSection,
            position = 3
    )
    default int sheetsRsnColumn()
    {
        return 1;
    }

    @ConfigItem(
            keyName = "sheetsRankColumn",
            name = "Sheets rank column",
            description = "number-based column index in the google sheet that contains the target rank (e.g., 2 = column B).",
            section = sheetsSection,
            position = 4
    )
    default int sheetsRankColumn()
    {
        return 2;
    }

    @ConfigItem(
            keyName = "sheetsHasHeader",
            name = "Sheets has header row",
            description = "If enabled, the first row will be treated as a header and skipped.",
            section = sheetsSection,
            position = 5
    )
    default boolean sheetsHasHeader()
    {
        return true;
    }

    @ConfigItem(
        keyName = "refreshInterval",
        name = "Refresh Interval (minutes)",
        description = "How often to refresh rank data from the API/Google Sheets",
        section = apiSection,
        position = 2
    )
    default int refreshInterval()
    {
        return 5;
    }

    @ConfigItem(
        keyName = "showOverlay",
        name = "Show Overlay Panel",
        description = "Show a panel listing all pending rank changes",
        section = displaySection,
        position = 0
    )
    default boolean showOverlay()
    {
        return true;
    }

    @ConfigItem(
        keyName = "highlightInChat",
        name = "Highlight in Member List",
        description = "Highlight players who need rank changes in the member list",
        section = displaySection,
        position = 1
    )
    default boolean highlightInChat()
    {
        return true;
    }

    @ConfigItem(
        keyName = "highlightColor",
        name = "Default Highlight Color",
        description = "Default color for unknown ranks",
        section = displaySection,
        position = 2
    )
    default Color highlightColor()
    {
        return new Color(255, 200, 0); // Gold/yellow
    }

    @ConfigItem(
        keyName = "maxDisplayed",
        name = "Max Displayed in Overlay",
        description = "Maximum number of pending changes to show in the overlay (0 for all)",
        section = displaySection,
        position = 3
    )
    default int maxDisplayed()
    {
        return 20;
    }

    @ConfigItem(
        keyName = "ignoredRanks",
        name = "Ignored Current Ranks",
        description = "Comma-separated list of current ranks to ignore (e.g. Owner,Deputy Owner,Therapist)",
        section = displaySection,
        position = 4
    )
    default String ignoredRanks()
    {
        return "";
    }

    @ConfigItem(
        keyName = "ignoredTargetRanks",
        name = "Ignored Target Ranks",
        description = "Comma-separated list of target ranks to ignore in the overlay (e.g. Recruit,Corporal)",
        section = displaySection,
        position = 5
    )
    default String ignoredTargetRanks()
    {
        return "";
    }

    @ConfigItem(
        keyName = "ignoredPlayers",
        name = "Ignored Players",
        description = "Comma-separated list of player RSNs to ignore (e.g. Steve ffs,SomePlayer)",
        section = displaySection,
        position = 6
    )
    default String ignoredPlayers()
    {
        return "";
    }

    @ConfigItem(
        keyName = "resetData",
        name = "Reset Checked Data",
        description = "Toggle ON to reset all checked/confirmed data",
        section = displaySection,
        position = 7
    )
    default boolean resetData()
    {
        return false;
    }

    // ==================== Rank Colors Section ====================

    @ConfigItem(
        keyName = "recruitColor",
        name = "Recruit",
        description = "Color for Recruit rank",
        section = rankColorsSection,
        position = 0
    )
    default Color recruitColor()
    {
        return new Color(144, 238, 144); // Light green
    }

    @ConfigItem(
        keyName = "corporalColor",
        name = "Corporal",
        description = "Color for Corporal rank",
        section = rankColorsSection,
        position = 1
    )
    default Color corporalColor()
    {
        return new Color(100, 149, 237); // Cornflower blue
    }

    @ConfigItem(
        keyName = "sergeantColor",
        name = "Sergeant",
        description = "Color for Sergeant rank",
        section = rankColorsSection,
        position = 2
    )
    default Color sergeantColor()
    {
        return new Color(255, 165, 0); // Orange
    }

    @ConfigItem(
        keyName = "cadetColor",
        name = "Cadet",
        description = "Color for Cadet rank",
        section = rankColorsSection,
        position = 3
    )
    default Color cadetColor()
    {
        return new Color(138, 43, 226); // Purple
    }

    @ConfigItem(
        keyName = "lieutenantColor",
        name = "Lieutenant",
        description = "Color for Lieutenant rank",
        section = rankColorsSection,
        position = 4
    )
    default Color lieutenantColor()
    {
        return new Color(255, 215, 0); // Gold
    }

    @ConfigItem(
        keyName = "captainColor",
        name = "Captain",
        description = "Color for Captain rank",
        section = rankColorsSection,
        position = 5
    )
    default Color captainColor()
    {
        return new Color(255, 69, 0); // Red-orange
    }

    @ConfigItem(
        keyName = "veteranColor",
        name = "Veteran",
        description = "Color for Veteran rank",
        section = rankColorsSection,
        position = 6
    )
    default Color veteranColor()
    {
        return new Color(192, 192, 192); // Silver
    }

    @ConfigItem(
        keyName = "generalColor",
        name = "General",
        description = "Color for General rank",
        section = rankColorsSection,
        position = 7
    )
    default Color generalColor()
    {
        return new Color(255, 0, 0); // Red
    }

    @ConfigItem(
        keyName = "masterColor",
        name = "Master",
        description = "Color for Master rank",
        section = rankColorsSection,
        position = 8
    )
    default Color masterColor()
    {
        return new Color(255, 0, 255); // Magenta
    }

    @ConfigItem(
        keyName = "customRankColors",
        name = "Custom Rank Colors",
        description = "Custom colors for ranks. Format: RankName:#HEXCOLOR,RankName2:#HEXCOLOR2 (e.g. Oracle:#FF5500,Teacher:#00FF00)",
        section = rankColorsSection,
        position = 9
    )
    default String customRankColors()
    {
        return "";
    }
}

package com.clanrankhelper;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ClanRankHelperPluginTest
{
    public static void main(String[] args) throws Exception
    {
        ExternalPluginManager.loadBuiltin(ClanRankHelperPlugin.class);
        RuneLite.main(args);
    }
}

