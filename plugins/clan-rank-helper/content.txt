package com.clanrankhelper;

import net.runelite.api.Client;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

import javax.inject.Inject;
import java.awt.*;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;

public class ClanRankHelperOverlay extends OverlayPanel
{
    private final ClanRankHelperPlugin plugin;
    private final ClanRankHelperConfig config;

    // Define rank order for sorting
    private static final Map<String, Integer> RANK_ORDER = Map.of(
        "Recruit", 1,
        "Corporal", 2,
        "Sergeant", 3,
        "Cadet", 4,
        "Lieutenant", 5,
        "Captain", 6,
        "Veteran", 7,
        "General", 8,
        "Master", 9
    );

    @Inject
    public ClanRankHelperOverlay(ClanRankHelperPlugin plugin, ClanRankHelperConfig config)
    {
        super(plugin);
        this.plugin = plugin;
        this.config = config;
        setPosition(OverlayPosition.TOP_LEFT);
        setPriority(OverlayPriority.LOW);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (!config.showOverlay())
        {
            return null;
        }

        Map<String, String> pendingChanges = plugin.getPendingRankChanges();
        
        // Always show overlay for debugging
        if (pendingChanges.isEmpty())
        {
            panelComponent.getChildren().add(TitleComponent.builder()
                .text("Clan Rank Helper")
                .color(Color.YELLOW)
                .build());
            panelComponent.getChildren().add(LineComponent.builder()
                .left("No API data loaded")
                .leftColor(Color.GRAY)
                .build());
            panelComponent.getChildren().add(LineComponent.builder()
                .left("Check API URL in config")
                .leftColor(Color.GRAY)
                .build());
            return super.render(graphics);
        }

        // Build list of pending changes - show all confirmed to need a change
        List<Map.Entry<String, String>> displayList = new ArrayList<>();
        
        // Get the sets of confirmed members
        java.util.Set<String> confirmedNeedsChange = plugin.getConfirmedNeedsChange();
        java.util.Set<String> confirmedOk = plugin.getConfirmedOk();
        
        for (Map.Entry<String, String> entry : pendingChanges.entrySet())
        {
            // Skip if target rank is in ignored list
            if (isTargetRankIgnored(entry.getValue()))
            {
                continue;
            }
            
            // Skip if player is in ignored list
            if (isPlayerIgnored(entry.getKey()))
            {
                continue;
            }
            
            String playerNameLower = entry.getKey().toLowerCase();
            
            // Only show if confirmed to need a change
            if (confirmedNeedsChange.contains(playerNameLower))
            {
                displayList.add(entry);
            }
        }
        
        // Calculate how many members have been checked
        int totalFromApi = pendingChanges.size();
        int checkedCount = 0;
        for (Map.Entry<String, String> entry : pendingChanges.entrySet())
        {
            String playerNameLower = entry.getKey().toLowerCase();
            if (confirmedNeedsChange.contains(playerNameLower) || confirmedOk.contains(playerNameLower))
            {
                checkedCount++;
            }
        }

        if (displayList.isEmpty())
        {
            // Show status message
            panelComponent.getChildren().add(TitleComponent.builder()
                .text("Rank Helper")
                .color(Color.GREEN)
                .build());
            
            if (checkedCount < totalFromApi)
            {
                panelComponent.getChildren().add(LineComponent.builder()
                    .left("Checked: " + checkedCount + "/" + totalFromApi)
                    .leftColor(Color.YELLOW)
                    .build());
                panelComponent.getChildren().add(LineComponent.builder()
                    .left("Scroll member list")
                    .leftColor(Color.GRAY)
                    .build());
                panelComponent.getChildren().add(LineComponent.builder()
                    .left("to check all")
                    .leftColor(Color.GRAY)
                    .build());
            }
            else
            {
                panelComponent.getChildren().add(LineComponent.builder()
                    .left("All ranks correct!")
                    .leftColor(Color.GREEN)
                    .build());
            }
            return super.render(graphics);
        }

        // Sort by rank order
        displayList.sort(Comparator.comparingInt(e -> RANK_ORDER.getOrDefault(e.getValue(), 99)));

        // Title
        panelComponent.getChildren().add(TitleComponent.builder()
            .text("Ranks Needed")
            .color(Color.YELLOW)
            .build());

        // Display count
        panelComponent.getChildren().add(LineComponent.builder()
            .left("Need change: " + displayList.size())
            .leftColor(Color.WHITE)
            .build());
        
        if (checkedCount < totalFromApi)
        {
            panelComponent.getChildren().add(LineComponent.builder()
                .left("Checked: " + checkedCount + "/" + totalFromApi)
                .leftColor(Color.GRAY)
                .build());
        }

        panelComponent.getChildren().add(LineComponent.builder()
            .left("─────────────────")
            .leftColor(Color.DARK_GRAY)
            .build());

        // Limit display if configured
        int maxDisplay = config.maxDisplayed();
        int count = 0;

        for (Map.Entry<String, String> entry : displayList)
        {
            if (maxDisplay > 0 && count >= maxDisplay)
            {
                panelComponent.getChildren().add(LineComponent.builder()
                    .left("... and " + (displayList.size() - maxDisplay) + " more")
                    .leftColor(Color.GRAY)
                    .build());
                break;
            }

            String playerName = entry.getKey();
            String targetRank = entry.getValue();
            Color rankColor = getRankColor(targetRank);

            // Capitalize first letter of each word in player name for display
            String displayName = capitalizeWords(playerName);

            panelComponent.getChildren().add(LineComponent.builder()
                .left(displayName)
                .leftColor(Color.WHITE)
                .right("→ " + targetRank)
                .rightColor(rankColor)
                .build());

            count++;
        }

        return super.render(graphics);
    }

    private Color getRankColor(String rank)
    {
        // First check custom rank colors
        Color customColor = getCustomRankColor(rank);
        if (customColor != null)
        {
            return customColor;
        }
        
        // Then check built-in ranks
        switch (rank.toLowerCase())
        {
            case "recruit":
                return config.recruitColor();
            case "corporal":
                return config.corporalColor();
            case "sergeant":
                return config.sergeantColor();
            case "cadet":
                return config.cadetColor();
            case "lieutenant":
                return config.lieutenantColor();
            case "captain":
                return config.captainColor();
            case "veteran":
                return config.veteranColor();
            case "general":
                return config.generalColor();
            case "master":
                return config.masterColor();
            default:
                return config.highlightColor();
        }
    }
    
    private Color getCustomRankColor(String rank)
    {
        String customColors = config.customRankColors();
        if (customColors == null || customColors.trim().isEmpty())
        {
            return null;
        }
        
        String[] pairs = customColors.split(",");
        for (String pair : pairs)
        {
            String[] parts = pair.split(":");
            if (parts.length == 2)
            {
                String rankName = parts[0].trim();
                String hexColor = parts[1].trim();
                
                if (rankName.equalsIgnoreCase(rank))
                {
                    try
                    {
                        return Color.decode(hexColor);
                    }
                    catch (NumberFormatException e)
                    {
                        // Invalid hex, skip
                    }
                }
            }
        }
        return null;
    }

    private String capitalizeWords(String str)
    {
        if (str == null || str.isEmpty())
        {
            return str;
        }
        
        StringBuilder result = new StringBuilder();
        boolean capitalizeNext = true;
        
        for (char c : str.toCharArray())
        {
            if (Character.isWhitespace(c))
            {
                capitalizeNext = true;
                result.append(c);
            }
            else if (capitalizeNext)
            {
                result.append(Character.toUpperCase(c));
                capitalizeNext = false;
            }
            else
            {
                result.append(c);
            }
        }
        
        return result.toString();
    }
    
    private boolean isTargetRankIgnored(String rank)
    {
        String ignoredRanks = config.ignoredTargetRanks();
        if (ignoredRanks == null || ignoredRanks.trim().isEmpty())
        {
            return false;
        }
        
        // Split by comma, newline, or both
        String[] ignored = ignoredRanks.split("[,\\n\\r]+");
        for (String ignoredRank : ignored)
        {
            if (ignoredRank.trim().equalsIgnoreCase(rank.trim()))
            {
                return true;
            }
        }
        return false;
    }
    
    private boolean isPlayerIgnored(String playerName)
    {
        String ignoredPlayers = config.ignoredPlayers();
        if (ignoredPlayers == null || ignoredPlayers.trim().isEmpty())
        {
            return false;
        }
        
        String normalizedName = playerName.toLowerCase().replace(" ", "").replace("-", "").replace("_", "");
        
        // Split by comma, newline, or both
        String[] ignored = ignoredPlayers.split("[,\\n\\r]+");
        for (String ignoredPlayer : ignored)
        {
            String normalizedIgnored = ignoredPlayer.trim().toLowerCase().replace(" ", "").replace("-", "").replace("_", "");
            if (normalizedIgnored.equals(normalizedName))
            {
                return true;
            }
        }
        return false;
    }
}

package com.clanrankhelper;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Provides;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

import javax.inject.Inject;
import java.io.BufferedReader;
import java.io.StringReader;
import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

@Slf4j
@PluginDescriptor(
    name = "Clan Rank Helper",
    description = "Shows clan members who need rank changes based on API data",
    tags = {"clan", "rank", "management"}
)
public class ClanRankHelperPlugin extends Plugin
{
    @Inject
    private Client client;

    @Inject
    private ClanRankHelperConfig config;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private ClanRankHelperOverlay overlay;

    @Inject
    private ClanChatOverlay clanChatOverlay;

    @Inject
    private Gson gson;

    @Inject
    private OkHttpClient okHttpClient;

    @Getter
    private final Map<String, String> pendingRankChanges = new ConcurrentHashMap<>();
    
    @Getter
    private final Set<String> confirmedNeedsChange = ConcurrentHashMap.newKeySet();
    
    @Getter
    private final Set<String> confirmedOk = ConcurrentHashMap.newKeySet();

    private ScheduledExecutorService executor;
    
    @Subscribe
    public void onConfigChanged(ConfigChanged event)
    {
        if (!event.getGroup().equals("clanrankhelper"))
        {
            return;
        }
        
        if (event.getKey().equals("resetData") && config.resetData())
        {
            log.debug("Resetting confirmed data");
            confirmedNeedsChange.clear();
            confirmedOk.clear();
        }
        
        // Re-fetch when API URL changes
        if (event.getKey().equals("apiUrl"))
        {
            log.debug("API URL changed, re-fetching data");
            executor.submit(this::fetchRankData);
        }
        
        // Re-fetch when Google Sheets URL changes
        if (event.getKey().equals("googleSheetsUrl"))
        {
            log.debug("Google Sheets URL changed, re-fetching data");
            executor.submit(this::fetchRankData);
        }
    }

    @Override
    protected void startUp() throws Exception
    {
        log.debug("Clan Rank Helper starting up");
        overlayManager.add(overlay);
        overlayManager.add(clanChatOverlay);
        
        executor = Executors.newSingleThreadScheduledExecutor();
        
        // Fetch immediately on startup
        executor.submit(this::fetchRankData);
        
        // Then refresh periodically based on config
        scheduleRefresh();
        log.debug("Clan Rank Helper started");
    }

    @Override
    protected void shutDown() throws Exception
    {
        log.debug("Clan Rank Helper stopped");
        overlayManager.remove(overlay);
        overlayManager.remove(clanChatOverlay);
        
        if (executor != null)
        {
            executor.shutdown();
        }
        pendingRankChanges.clear();
        confirmedNeedsChange.clear();
        confirmedOk.clear();
    }

    private void scheduleRefresh()
    {
        int refreshMinutes = config.refreshInterval();
        executor.scheduleAtFixedRate(
            this::fetchRankData,
            refreshMinutes,
            refreshMinutes,
            TimeUnit.MINUTES
        );
    }

    private void fetchRankData()
    {
        // Check if Google Sheets URL is configured (takes priority)
        String sheetsUrl = config.googleSheetsUrl();
        if (sheetsUrl != null && !sheetsUrl.trim().isEmpty())
        {
            fetchFromGoogleSheets(sheetsUrl.trim());
            return;
        }
        
        // Otherwise use API URL
        String apiUrl = config.apiUrl();
        if (apiUrl != null && !apiUrl.trim().isEmpty())
        {
            fetchFromApi(apiUrl.trim());
            return;
        }
        
        log.debug("Clan Rank Helper: No API URL or Google Sheets URL configured");
    }
    
    private void fetchFromGoogleSheets(String sheetsUrl)
    {
        try
        {
            // Convert Google Sheets URL to CSV export URL
            String csvUrl = convertToCsvUrl(sheetsUrl);
            if (csvUrl == null)
            {
                log.error("Clan Rank Helper: Invalid Google Sheets URL format");
                return;
            }
            
            log.debug("Clan Rank Helper: Fetching from Google Sheets: {}", csvUrl);
            
            Request request = new Request.Builder()
                .url(csvUrl)
                .header("User-Agent", "RuneLite-ClanRankHelper")
                .build();
            
            try (Response response = okHttpClient.newCall(request).execute())
            {
                if (!response.isSuccessful())
                {
                    log.error("Clan Rank Helper: Google Sheets returned non-200 response: {}", response.code());
                    return;
                }
                
                String responseBody = response.body().string();
                Map<String, String> rankMap = new HashMap<>();
                BufferedReader reader = new BufferedReader(new StringReader(responseBody));
                String line;
                boolean firstLine = true;
                
                while ((line = reader.readLine()) != null)
                {
                    // Skip header row if it looks like a header
                    if (firstLine)
                    {
                        firstLine = false;
                        String lowerLine = line.toLowerCase();
                        if (lowerLine.contains("rsn") || lowerLine.contains("name") || lowerLine.contains("rank"))
                        {
                            continue; // Skip header
                        }
                    }
                    
                    // Parse CSV line (handle quoted values)
                    String[] parts = parseCsvLine(line);
                    if (parts.length >= 2)
                    {
                        String rsn = parts[0].trim();
                        String rank = parts[1].trim();
                        
                        if (!rsn.isEmpty() && !rank.isEmpty())
                        {
                            rankMap.put(rsn.toLowerCase(), rank);
                        }
                    }
                }
                reader.close();
                
                log.debug("Clan Rank Helper: Fetched {} entries from Google Sheets", rankMap.size());
                updateRankData(rankMap);
            }
        }
        catch (Exception e)
        {
            log.error("Clan Rank Helper: Failed to fetch from Google Sheets", e);
        }
    }
    
    private String convertToCsvUrl(String sheetsUrl)
    {
        // Handle various Google Sheets URL formats
        try
        {
            if (sheetsUrl.contains("/spreadsheets/d/"))
            {
                int startIdx = sheetsUrl.indexOf("/spreadsheets/d/") + 16;
                int endIdx = sheetsUrl.indexOf("/", startIdx);
                if (endIdx == -1)
                {
                    endIdx = sheetsUrl.indexOf("?", startIdx);
                }
                if (endIdx == -1)
                {
                    endIdx = sheetsUrl.length();
                }
                
                String sheetId = sheetsUrl.substring(startIdx, endIdx);
                
                // Check if there's a gid parameter for specific sheet
                String gid = "";
                if (sheetsUrl.contains("gid="))
                {
                    int gidStart = sheetsUrl.indexOf("gid=") + 4;
                    int gidEnd = sheetsUrl.indexOf("&", gidStart);
                    if (gidEnd == -1) gidEnd = sheetsUrl.length();
                    gid = "&gid=" + sheetsUrl.substring(gidStart, gidEnd);
                }
                
                return "https://docs.google.com/spreadsheets/d/" + sheetId + "/export?format=csv" + gid;
            }
        }
        catch (Exception e)
        {
            log.error("Clan Rank Helper: Error parsing Google Sheets URL", e);
        }
        return null;
    }
    
    private String[] parseCsvLine(String line)
    {
        // Simple CSV parser that handles quoted values
        java.util.List<String> result = new java.util.ArrayList<>();
        StringBuilder current = new StringBuilder();
        boolean inQuotes = false;
        
        for (int i = 0; i < line.length(); i++)
        {
            char c = line.charAt(i);
            
            if (c == '"')
            {
                inQuotes = !inQuotes;
            }
            else if (c == ',' && !inQuotes)
            {
                result.add(current.toString());
                current = new StringBuilder();
            }
            else
            {
                current.append(c);
            }
        }
        result.add(current.toString());
        
        return result.toArray(new String[0]);
    }
    
    private void fetchFromApi(String apiUrl)
    {
        try
        {
            log.debug("Clan Rank Helper: Fetching from {}", apiUrl);

            Request request = new Request.Builder()
                .url(apiUrl)
                .header("Accept", "application/json")
                .header("User-Agent", "RuneLite-ClanRankHelper")
                .build();
            
            try (Response response = okHttpClient.newCall(request).execute())
            {
                if (!response.isSuccessful())
                {
                    log.error("Clan Rank Helper: API returned non-200 response: {}", response.code());
                    return;
                }

                String responseBody = response.body().string();
                log.debug("Clan Rank Helper: Got response, parsing JSON...");
                
                // Parse the JSON response
                Type listType = new TypeToken<List<RankEntry>>(){}.getType();
                List<RankEntry> entries = gson.fromJson(responseBody, listType);

                if (entries == null)
                {
                    log.error("Clan Rank Helper: Failed to parse JSON - entries is null");
                    return;
                }

                // Convert to map: playerName -> targetRank
                Map<String, String> rankMap = new HashMap<>();
                for (RankEntry entry : entries)
                {
                    if (entry.mainRSN != null && !entry.mainRSN.isEmpty())
                    {
                        String normalizedName = entry.mainRSN.toLowerCase().trim();
                        rankMap.put(normalizedName, entry.osrsName);
                    }
                }

                log.debug("Clan Rank Helper: Fetched {} pending rank changes", rankMap.size());
                updateRankData(rankMap);
            }
        }
        catch (Exception e)
        {
            log.error("Clan Rank Helper: Failed to fetch rank data", e);
        }
    }

    private void updateRankData(Map<String, String> newData)
    {
        pendingRankChanges.clear();
        pendingRankChanges.putAll(newData);
        confirmedNeedsChange.clear();
        confirmedOk.clear();
        log.debug("Updated rank data: {} pending changes", pendingRankChanges.size());
    }
    
    public void markNeedsChange(String playerName)
    {
        String lower = playerName.toLowerCase();
        confirmedNeedsChange.add(lower);
        confirmedOk.remove(lower);
    }
    
    public void markConfirmedOk(String playerName)
    {
        String lower = playerName.toLowerCase();
        confirmedOk.add(lower);
        confirmedNeedsChange.remove(lower);
    }

    @Provides
    ClanRankHelperConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(ClanRankHelperConfig.class);
    }

    // Inner class for JSON parsing
    private static class RankEntry
    {
        String mainRSN;
        String osrsName;
    }
}

package com.clanrankhelper;

import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;

import javax.inject.Inject;
import java.awt.*;
import java.util.Map;

public class ClanChatOverlay extends Overlay
{
    private final Client client;
    private final ClanRankHelperPlugin plugin;
    private final ClanRankHelperConfig config;

    // Clan settings interface group ID (693) and member list child
    // You may need to adjust these using RuneLite's Developer Tools > Widget Inspector
    private static final int CLAN_SETTINGS_GROUP_ID = 693;
    private static final int CLAN_SETTINGS_MEMBERS_LIST_CHILD = 11;

    @Inject
    public ClanChatOverlay(Client client, ClanRankHelperPlugin plugin, ClanRankHelperConfig config)
    {
        super(plugin);
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPriority(OverlayPriority.HIGH);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (!config.highlightInChat())
        {
            return null;
        }

        Map<String, String> pendingChanges = plugin.getPendingRankChanges();
        if (pendingChanges.isEmpty())
        {
            return null;
        }

        // Only scan when the Clan Settings Member List window is open
        // This is widget group 693 - check if it's visible and has the member list structure
        Widget clanSettingsWidget = client.getWidget(693, 0);
        if (clanSettingsWidget == null || clanSettingsWidget.isHidden())
        {
            // Member list window is not open, don't scan
            return null;
        }
        
        // Additional check: look for the "Member list" title or the member list content
        // Widget 693,1 typically contains the title bar
        Widget titleWidget = client.getWidget(693, 1);
        boolean isMemberListOpen = false;
        
        if (titleWidget != null)
        {
            // Check children for title text
            Widget[] children = titleWidget.getDynamicChildren();
            if (children != null)
            {
                for (Widget child : children)
                {
                    if (child != null && child.getText() != null && 
                        child.getText().toLowerCase().contains("member list"))
                    {
                        isMemberListOpen = true;
                        break;
                    }
                }
            }
            // Also check static children
            if (!isMemberListOpen)
            {
                children = titleWidget.getStaticChildren();
                if (children != null)
                {
                    for (Widget child : children)
                    {
                        if (child != null && child.getText() != null && 
                            child.getText().toLowerCase().contains("member list"))
                        {
                            isMemberListOpen = true;
                            break;
                        }
                    }
                }
            }
        }
        
        // Fallback: check if widget 693 has the member list structure (many children with names/ranks)
        if (!isMemberListOpen)
        {
            // Check widget 693,11 which typically contains the member list
            Widget memberListWidget = client.getWidget(693, 11);
            if (memberListWidget != null && !memberListWidget.isHidden())
            {
                Widget[] dynamicChildren = memberListWidget.getDynamicChildren();
                if (dynamicChildren != null && dynamicChildren.length > 10)
                {
                    // Has many children, likely the member list
                    isMemberListOpen = true;
                }
            }
        }
        
        if (!isMemberListOpen)
        {
            return null;
        }

        // Scan the clan settings widget and its children
        for (int childId = 0; childId < 30; childId++)
        {
            Widget widget = client.getWidget(693, childId);
            if (widget != null && !widget.isHidden())
            {
                checkWidgetAndChildren(graphics, widget, pendingChanges);
            }
        }

        return null;
    }
    
    private void checkWidgetAndChildren(Graphics2D graphics, Widget widget, Map<String, String> pendingChanges)
    {
        if (widget == null)
        {
            return;
        }
        
        // Collect all text widgets from all child types
        java.util.List<Widget> allTextWidgets = new java.util.ArrayList<>();
        
        // Check dynamic children
        Widget[] dynamicChildren = widget.getDynamicChildren();
        if (dynamicChildren != null)
        {
            for (Widget child : dynamicChildren)
            {
                if (child != null && child.getText() != null && !child.getText().isEmpty())
                {
                    allTextWidgets.add(child);
                }
            }
        }
        
        // Check static children
        Widget[] staticChildren = widget.getStaticChildren();
        if (staticChildren != null)
        {
            for (Widget child : staticChildren)
            {
                if (child != null && child.getText() != null && !child.getText().isEmpty())
                {
                    allTextWidgets.add(child);
                }
            }
        }
        
        // Check nested children
        Widget[] nestedChildren = widget.getNestedChildren();
        if (nestedChildren != null)
        {
            for (Widget child : nestedChildren)
            {
                if (child != null && child.getText() != null && !child.getText().isEmpty())
                {
                    allTextWidgets.add(child);
                }
            }
        }
        
        if (allTextWidgets.isEmpty())
        {
            return;
        }
        
        // Convert to array for the rank finder
        Widget[] widgetArray = allTextWidgets.toArray(new Widget[0]);
        
        // Now process each widget to find player names
        for (Widget child : allTextWidgets)
        {
            String widgetText = child.getText();
            String playerName = extractPlayerName(widgetText);
            
            if (playerName == null || playerName.isEmpty())
            {
                continue;
            }
            
            String normalizedName = playerName.toLowerCase().trim().replace(" ", "").replace("-", "").replace("_", "");
            
            // Check if this player is in our list (try both with and without spaces)
            String targetRank = null;
            for (Map.Entry<String, String> entry : pendingChanges.entrySet())
            {
                String apiName = entry.getKey().replace(" ", "").replace("-", "").replace("_", "");
                if (apiName.equals(normalizedName))
                {
                    targetRank = entry.getValue();
                    break;
                }
            }
            
            if (targetRank != null)
            {
                // Check if player is in the ignored list
                if (isPlayerIgnored(playerName))
                {
                    continue;
                }
                
                // Now find their current rank by looking at nearby widgets
                String currentRank = findCurrentRankForPlayer(widgetArray, child);
                
                // If we couldn't find the current rank, skip
                if (currentRank == null)
                {
                    continue;
                }
                
                // Check if current rank is in the ignored list
                if (isRankIgnored(currentRank))
                {
                    plugin.markConfirmedOk(playerName);
                    continue;
                }
                
                // Only highlight if ranks don't match
                if (!currentRank.equalsIgnoreCase(targetRank))
                {
                    plugin.markNeedsChange(playerName);
                    renderHighlight(graphics, child, targetRank);
                }
                else
                {
                    plugin.markConfirmedOk(playerName);
                }
            }
        }
    }
    
    private boolean isPlayerIgnored(String playerName)
    {
        String ignoredPlayers = config.ignoredPlayers();
        if (ignoredPlayers == null || ignoredPlayers.trim().isEmpty())
        {
            return false;
        }
        
        String normalizedName = playerName.toLowerCase().replace(" ", "").replace("-", "").replace("_", "");
        
        String[] ignored = ignoredPlayers.split("[,\\n\\r]+");
        for (String ignoredPlayer : ignored)
        {
            String normalizedIgnored = ignoredPlayer.trim().toLowerCase().replace(" ", "").replace("-", "").replace("_", "");
            if (normalizedIgnored.equals(normalizedName))
            {
                return true;
            }
        }
        return false;
    }
    
    private boolean isRankIgnored(String rank)
    {
        String ignoredRanks = config.ignoredRanks();
        if (ignoredRanks == null || ignoredRanks.trim().isEmpty())
        {
            return false;
        }
        
        // Split by comma, newline, or both
        String[] ignored = ignoredRanks.split("[,\\n\\r]+");
        for (String ignoredRank : ignored)
        {
            if (ignoredRank.trim().equalsIgnoreCase(rank.trim()))
            {
                return true;
            }
        }
        return false;
    }
    
    private String findCurrentRankForPlayer(Widget[] allWidgets, Widget nameWidget)
    {
        if (nameWidget == null)
        {
            return null;
        }
        
        Rectangle nameBounds = nameWidget.getBounds();
        if (nameBounds == null)
        {
            return null;
        }
        
        // Look for a rank widget on the same row (similar Y position)
        // Include common ranks plus any ranks from the ignored list in config
        java.util.Set<String> possibleRanks = new java.util.HashSet<>();
        
        // Default OSRS clan ranks
        String[] defaultRanks = {"Recruit", "Corporal", "Sergeant", "Cadet", "Lieutenant", "Captain", 
                                  "Veteran", "General", "Master", "Owner", "Deputy Owner", "Guest"};
        for (String r : defaultRanks) {
            possibleRanks.add(r.toLowerCase());
        }
        
        // Custom clan ranks (add common ones)
        String[] customRanks = {"Therapist", "Defiler", "Overseer", "Coordinator", "Organiser", "Admin",
                                 "Dogsbody", "Quester", "Oracle", "Teacher", "Artisan", "Medic", "Scout", 
                                 "Guard", "Ranger", "Warrior", "Mage", "Archer", "Champion", "Hero", 
                                 "Legend", "Elder", "Sage", "Mentor", "Initiate", "Novice", "Apprentice", 
                                 "Journeyman", "Expert", "Adept", "Warden", "Sentinel", "Marshal", 
                                 "Commander", "Chief", "Leader", "Founder", "Member", "Friend", "Minion",
                                 "Achiever", "Adventurer", "Collector", "Competitor", "Skiller", "Slayer",
                                 "Banker", "Crafter", "Farmer", "Fisher", "Hunter", "Miner", "Smith",
                                 "Woodcutter", "Cook", "Fletcher", "Runecrafter", "Thief", "Assassin"};
        for (String r : customRanks) {
            possibleRanks.add(r.toLowerCase());
        }
        
        // Also add any ranks from the ignored list (so we can detect them)
        String ignoredRanksConfig = config.ignoredRanks();
        if (ignoredRanksConfig != null && !ignoredRanksConfig.trim().isEmpty()) {
            String[] ignored = ignoredRanksConfig.split("[,\\n\\r]+");
            for (String r : ignored) {
                if (!r.trim().isEmpty()) {
                    possibleRanks.add(r.trim().toLowerCase());
                }
            }
        }
        
        // First try: look in the passed widgets array
        for (Widget widget : allWidgets)
        {
            if (widget == null || widget.getText() == null || widget.getText().isEmpty())
            {
                continue;
            }
            
            if (widget == nameWidget)
            {
                continue;
            }
            
            Rectangle widgetBounds = widget.getBounds();
            if (widgetBounds == null)
            {
                continue;
            }
            
            if (Math.abs(widgetBounds.y - nameBounds.y) <= 15)
            {
                String text = extractPlayerName(widget.getText());
                if (text != null && possibleRanks.contains(text.toLowerCase()))
                {
                    return text;
                }
            }
        }
        
        // Second try: scan all widgets in the clan settings interface (multiple widget groups)
        for (int widgetGroupId = 690; widgetGroupId <= 710; widgetGroupId++)
        {
            Widget group = client.getWidget(widgetGroupId, 0);
            if (group == null)
            {
                continue;
            }
            
            // Check all possible child indices
            for (int childIdx = 0; childIdx <= 50; childIdx++)
            {
                Widget parentWidget = client.getWidget(widgetGroupId, childIdx);
                if (parentWidget == null)
                {
                    continue;
                }
                
                // Scan dynamic children
                Widget[] dynamicChildren = parentWidget.getDynamicChildren();
                if (dynamicChildren != null)
                {
                    for (Widget child : dynamicChildren)
                    {
                        String rank = checkWidgetForRank(child, nameBounds, nameWidget, possibleRanks);
                        if (rank != null)
                        {
                            return rank;
                        }
                    }
                }
                
                // Scan static children
                Widget[] staticChildren = parentWidget.getStaticChildren();
                if (staticChildren != null)
                {
                    for (Widget child : staticChildren)
                    {
                        String rank = checkWidgetForRank(child, nameBounds, nameWidget, possibleRanks);
                        if (rank != null)
                        {
                            return rank;
                        }
                    }
                }
            }
        }
        
        return null;
    }
    
    private String checkWidgetForRank(Widget widget, Rectangle nameBounds, Widget nameWidget, java.util.Set<String> possibleRanks)
    {
        if (widget == null || widget == nameWidget)
        {
            return null;
        }
        
        String text = widget.getText();
        if (text == null || text.isEmpty())
        {
            return null;
        }
        
        Rectangle widgetBounds = widget.getBounds();
        if (widgetBounds == null)
        {
            return null;
        }
        
        // Check if on same row (within 15 pixels vertically)
        if (Math.abs(widgetBounds.y - nameBounds.y) <= 15)
        {
            String cleanText = extractPlayerName(text);
            if (cleanText != null && possibleRanks.contains(cleanText.toLowerCase()))
            {
                return cleanText;
            }
        }
        
        return null;
    }
    
    private void renderHighlight(Graphics2D graphics, Widget widget, String targetRank)
    {
        Color highlightColor = getRankColor(targetRank);
        
        Rectangle bounds = widget.getBounds();
        if (bounds != null && bounds.width > 0 && bounds.height > 0)
        {
            // Draw background highlight
            graphics.setColor(new Color(
                highlightColor.getRed(),
                highlightColor.getGreen(),
                highlightColor.getBlue(),
                60
            ));
            graphics.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);
            
            // Draw border
            graphics.setColor(highlightColor);
            graphics.drawRect(bounds.x, bounds.y, bounds.width, bounds.height);
            
            // Draw small rank indicator on the right
            String rankAbbr = getRankAbbreviation(targetRank);
            FontMetrics fm = graphics.getFontMetrics();
            int textWidth = fm.stringWidth(rankAbbr);
            
            graphics.setColor(Color.BLACK);
            graphics.fillRect(bounds.x + bounds.width - textWidth - 6, bounds.y, textWidth + 6, bounds.height);
            
            graphics.setColor(highlightColor);
            graphics.drawString(rankAbbr, bounds.x + bounds.width - textWidth - 3, bounds.y + bounds.height - 3);
        }
    }
    
    private void renderWidgetIfMatch(Graphics2D graphics, Widget widget, Map<String, String> pendingChanges)
    {
        // This method is no longer used but kept for compatibility
    }

    private String extractPlayerName(String widgetText)
    {
        if (widgetText == null)
        {
            return null;
        }
        
        // Remove color tags: <col=xxxxxx>text</col>
        String cleaned = widgetText.replaceAll("<col=[^>]*>", "").replaceAll("</col>", "");
        // Remove any img tags: <img=x>
        cleaned = cleaned.replaceAll("<img=[^>]*>", "");
        // Trim whitespace
        cleaned = cleaned.trim();
        
        return cleaned;
    }

    private Color getRankColor(String rank)
    {
        // First check custom rank colors
        Color customColor = getCustomRankColor(rank);
        if (customColor != null)
        {
            return customColor;
        }
        
        // Then check built-in ranks
        switch (rank.toLowerCase())
        {
            case "recruit":
                return config.recruitColor();
            case "corporal":
                return config.corporalColor();
            case "sergeant":
                return config.sergeantColor();
            case "cadet":
                return config.cadetColor();
            case "lieutenant":
                return config.lieutenantColor();
            case "captain":
                return config.captainColor();
            case "veteran":
                return config.veteranColor();
            case "general":
                return config.generalColor();
            case "master":
                return config.masterColor();
            default:
                return config.highlightColor();
        }
    }
    
    private Color getCustomRankColor(String rank)
    {
        String customColors = config.customRankColors();
        if (customColors == null || customColors.trim().isEmpty())
        {
            return null;
        }
        
        String[] pairs = customColors.split(",");
        for (String pair : pairs)
        {
            String[] parts = pair.split(":");
            if (parts.length == 2)
            {
                String rankName = parts[0].trim();
                String hexColor = parts[1].trim();
                
                if (rankName.equalsIgnoreCase(rank))
                {
                    try
                    {
                        return Color.decode(hexColor);
                    }
                    catch (NumberFormatException e)
                    {
                        // Invalid hex, skip
                    }
                }
            }
        }
        return null;
    }

    private String getRankAbbreviation(String rank)
    {
        if (rank == null || rank.isEmpty())
        {
            return "?";
        }
        
        switch (rank)
        {
            case "Recruit":
                return "RCT";
            case "Corporal":
                return "CPL";
            case "Sergeant":
                return "SGT";
            case "Cadet":
                return "CDT";
            case "Lieutenant":
                return "LT";
            case "Captain":
                return "CPT";
            case "Veteran":
                return "VET";
            case "General":
                return "GEN";
            case "Master":
                return "MST";
            default:
                // For unknown ranks, return first 3 characters (uppercase)
                String abbr = rank.length() > 3 ? rank.substring(0, 3) : rank;
                return abbr.toUpperCase();
        }
    }
}

package com.clanrankhelper;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

import java.awt.Color;

@ConfigGroup("clanrankhelper")
public interface ClanRankHelperConfig extends Config
{
    @ConfigSection(
        name = "API Settings",
        description = "Configure the API connection",
        position = 0
    )
    String apiSection = "api";

    @ConfigSection(
        name = "Display Settings",
        description = "Configure how rank changes are displayed",
        position = 1
    )
    String displaySection = "display";

    @ConfigSection(
        name = "Rank Colors",
        description = "Customize colors for each rank",
        position = 2,
        closedByDefault = true
    )
    String rankColorsSection = "rankColors";

    @ConfigItem(
        keyName = "apiUrl",
        name = "API URL",
        description = "URL to fetch pending rank changes. Must return JSON array: [{\"mainRSN\": \"PlayerName\", \"osrsName\": \"TargetRank\"}, ...]",
        section = apiSection,
        position = 0,
        warning = "This plugin submits your IP address to a 3rd party website not controlled or verified by the RuneLite Developers."
    )
    default String apiUrl()
    {
        return "";
    }

    @ConfigItem(
        keyName = "googleSheetsUrl",
        name = "Google Sheets URL",
        description = "URL to a public Google Sheet. Column A = RSN, Column B = Rank (must be the in-game rank name, not clan-specific name). Leave empty to use API URL instead.",
        section = apiSection,
        position = 1,
        warning = "This plugin submits your IP address to a 3rd party website not controlled or verified by the RuneLite Developers."
    )
    default String googleSheetsUrl()
    {
        return "";
    }

    @ConfigItem(
        keyName = "refreshInterval",
        name = "Refresh Interval (minutes)",
        description = "How often to refresh rank data from the API/Google Sheets",
        section = apiSection,
        position = 2
    )
    default int refreshInterval()
    {
        return 5;
    }

    @ConfigItem(
        keyName = "showOverlay",
        name = "Show Overlay Panel",
        description = "Show a panel listing all pending rank changes",
        section = displaySection,
        position = 0
    )
    default boolean showOverlay()
    {
        return true;
    }

    @ConfigItem(
        keyName = "highlightInChat",
        name = "Highlight in Member List",
        description = "Highlight players who need rank changes in the member list",
        section = displaySection,
        position = 1
    )
    default boolean highlightInChat()
    {
        return true;
    }

    @ConfigItem(
        keyName = "highlightColor",
        name = "Default Highlight Color",
        description = "Default color for unknown ranks",
        section = displaySection,
        position = 2
    )
    default Color highlightColor()
    {
        return new Color(255, 200, 0); // Gold/yellow
    }

    @ConfigItem(
        keyName = "maxDisplayed",
        name = "Max Displayed in Overlay",
        description = "Maximum number of pending changes to show in the overlay (0 for all)",
        section = displaySection,
        position = 3
    )
    default int maxDisplayed()
    {
        return 20;
    }

    @ConfigItem(
        keyName = "ignoredRanks",
        name = "Ignored Current Ranks",
        description = "Comma-separated list of current ranks to ignore (e.g. Owner,Deputy Owner,Therapist)",
        section = displaySection,
        position = 4
    )
    default String ignoredRanks()
    {
        return "";
    }

    @ConfigItem(
        keyName = "ignoredTargetRanks",
        name = "Ignored Target Ranks",
        description = "Comma-separated list of target ranks to ignore in the overlay (e.g. Recruit,Corporal)",
        section = displaySection,
        position = 5
    )
    default String ignoredTargetRanks()
    {
        return "";
    }

    @ConfigItem(
        keyName = "ignoredPlayers",
        name = "Ignored Players",
        description = "Comma-separated list of player RSNs to ignore (e.g. Steve ffs,SomePlayer)",
        section = displaySection,
        position = 6
    )
    default String ignoredPlayers()
    {
        return "";
    }

    @ConfigItem(
        keyName = "resetData",
        name = "Reset Checked Data",
        description = "Toggle ON to reset all checked/confirmed data",
        section = displaySection,
        position = 7
    )
    default boolean resetData()
    {
        return false;
    }

    // ==================== Rank Colors Section ====================

    @ConfigItem(
        keyName = "recruitColor",
        name = "Recruit",
        description = "Color for Recruit rank",
        section = rankColorsSection,
        position = 0
    )
    default Color recruitColor()
    {
        return new Color(144, 238, 144); // Light green
    }

    @ConfigItem(
        keyName = "corporalColor",
        name = "Corporal",
        description = "Color for Corporal rank",
        section = rankColorsSection,
        position = 1
    )
    default Color corporalColor()
    {
        return new Color(100, 149, 237); // Cornflower blue
    }

    @ConfigItem(
        keyName = "sergeantColor",
        name = "Sergeant",
        description = "Color for Sergeant rank",
        section = rankColorsSection,
        position = 2
    )
    default Color sergeantColor()
    {
        return new Color(255, 165, 0); // Orange
    }

    @ConfigItem(
        keyName = "cadetColor",
        name = "Cadet",
        description = "Color for Cadet rank",
        section = rankColorsSection,
        position = 3
    )
    default Color cadetColor()
    {
        return new Color(138, 43, 226); // Purple
    }

    @ConfigItem(
        keyName = "lieutenantColor",
        name = "Lieutenant",
        description = "Color for Lieutenant rank",
        section = rankColorsSection,
        position = 4
    )
    default Color lieutenantColor()
    {
        return new Color(255, 215, 0); // Gold
    }

    @ConfigItem(
        keyName = "captainColor",
        name = "Captain",
        description = "Color for Captain rank",
        section = rankColorsSection,
        position = 5
    )
    default Color captainColor()
    {
        return new Color(255, 69, 0); // Red-orange
    }

    @ConfigItem(
        keyName = "veteranColor",
        name = "Veteran",
        description = "Color for Veteran rank",
        section = rankColorsSection,
        position = 6
    )
    default Color veteranColor()
    {
        return new Color(192, 192, 192); // Silver
    }

    @ConfigItem(
        keyName = "generalColor",
        name = "General",
        description = "Color for General rank",
        section = rankColorsSection,
        position = 7
    )
    default Color generalColor()
    {
        return new Color(255, 0, 0); // Red
    }

    @ConfigItem(
        keyName = "masterColor",
        name = "Master",
        description = "Color for Master rank",
        section = rankColorsSection,
        position = 8
    )
    default Color masterColor()
    {
        return new Color(255, 0, 255); // Magenta
    }

    @ConfigItem(
        keyName = "customRankColors",
        name = "Custom Rank Colors",
        description = "Custom colors for ranks. Format: RankName:#HEXCOLOR,RankName2:#HEXCOLOR2 (e.g. Oracle:#FF5500,Teacher:#00FF00)",
        section = rankColorsSection,
        position = 9
    )
    default String customRankColors()
    {
        return "";
    }
}

package com.clanrankhelper;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ClanRankHelperPluginTest
{
    public static void main(String[] args) throws Exception
    {
        ExternalPluginManager.loadBuiltin(ClanRankHelperPlugin.class);
        RuneLite.main(args);
    }
}

