package com.random.hopper;

public class FilterConfig {
    public int subscriptionIndex;
    public int pvpIndex;
    public int highRiskIndex;
    public int skillTotalIndex;
    public int bountyWorldIndex;
    
    public String seed;
    
    public boolean usaEastSelected;
    public boolean usaWestSelected;
    public boolean ukSelected;
    public boolean germanySelected;
    public boolean australiaSelected;

    public int worldTypeIndex;

    public FilterConfig(
            int subscriptionIndex,
            int pvpIndex,
            int highRiskIndex,
            int skillTotalIndex,
            int bountyWorldIndex,
            String seed,
            boolean usaEastSelected,
            boolean usaWestSelected,
            boolean ukSelected,
            boolean germanySelected,
            boolean australiaSelected,
            int worldTypeIndex) {
        this.subscriptionIndex = subscriptionIndex;
        this.pvpIndex = pvpIndex;
        this.highRiskIndex = highRiskIndex;
        this.skillTotalIndex = skillTotalIndex;
        this.bountyWorldIndex = bountyWorldIndex;
        this.seed = seed;
        this.usaEastSelected = usaEastSelected;
        this.usaWestSelected = usaWestSelected;
        this.ukSelected = ukSelected;
        this.germanySelected = germanySelected;
        this.australiaSelected = australiaSelected;
        this.worldTypeIndex = worldTypeIndex;
    }
}

package com.random.hopper.filters;

import net.runelite.http.api.worlds.World;

public class BlockIDWorldFilter implements WorldFilter{
    private int blockID;

    public BlockIDWorldFilter(int id) {
        blockID = id;
    }

    @Override
    public boolean isWorldAccepted(World world) {
        return world.getId() != blockID;
    }
}

package com.random.hopper.filters;

import net.runelite.http.api.worlds.World;

import java.util.List;

// A class that can merge filters together such that all filters
// must pass for the world to pass.
public class ComboWorldFilter implements WorldFilter{
    List<WorldFilter> filters;

    public ComboWorldFilter(List<WorldFilter> filters) {
        this.filters = filters;
    }

    @Override
    public boolean isWorldAccepted(World world) {
        for(WorldFilter filter : filters) {
            if(!filter.isWorldAccepted(world)) {
                return false;
            }
        }
        return true;
    }
}

package com.random.hopper.filters;


import com.random.hopper.USWorld;
import com.random.hopper.WorldHelper;
import net.runelite.http.api.worlds.World;
import net.runelite.http.api.worlds.WorldRegion;

public class RegionWorldFilter implements WorldFilter {
    private boolean allowAustralia;
    private boolean allowGermany;
    private boolean allowUK;
    private boolean allowUSAEast;
	private boolean allowUSAWest;

    public RegionWorldFilter(boolean allowAustralia, boolean allowUSAEast, boolean allowUSAWest, boolean allowGermany, boolean allowUK) {
        this.allowAustralia = allowAustralia;
		this.allowUSAEast = allowUSAEast;
		this.allowUSAWest = allowUSAWest;
        this.allowGermany = allowGermany;
        this.allowUK = allowUK;
    }

    @Override
    public boolean isWorldAccepted(World world) {
        WorldRegion region = world.getRegion();
        switch(region){
            case AUSTRALIA:
                return allowAustralia;
            case GERMANY:
                return allowGermany;
            case UNITED_KINGDOM:
                return allowUK;
            case UNITED_STATES_OF_AMERICA:
				USWorld usWorld = WorldHelper.getUSWorldSide(world.getId());
				if(usWorld == null) {
					return false;
				}
				switch(usWorld) {
					case EAST:
						return allowUSAEast;
					case WEST:
						return allowUSAWest;
					default:
						return false;
				}
            default:
                return false;
        }
    }

    @Override
    public String toString() {
        return "RegionWorldFilter{" +
                "allowAustralia=" + allowAustralia +
                ", allowGermany=" + allowGermany +
                ", allowUK=" + allowUK +
                ", allowUSAEast=" + allowUSAEast +
				", allowUSAWest=" + allowUSAWest +
                '}';
    }
}

package com.random.hopper.filters;

import net.runelite.http.api.worlds.World;

public class SkillTotalWorldFilter implements WorldFilter{
    private int maximumLevel;

    public SkillTotalWorldFilter(int maximumLevel) {
        this.maximumLevel = maximumLevel;
    }

    @Override
    public boolean isWorldAccepted(World world) {
        if(!WorldFilterHelpers.isWorldSkillTotal.test(world))
        { // Accept all non-skill total worlds
            return true;
        }
        else
        {
            String maxLevelString = world.getActivity().split(" ")[0];
            return maximumLevel >= Integer.parseInt(maxLevelString);
        }
    }
}

package com.random.hopper.filters;

import net.runelite.http.api.worlds.World;

import java.util.function.Predicate;

// Assumes that the world being compared can always BE filtered
public class TrinaryWorldFilter implements WorldFilter{
    Predicate<World> matcher;
    TrinaryWorldFilterParameters parameters;

    public TrinaryWorldFilter(Predicate<World> matcher, TrinaryWorldFilterParameters parameters) {
        this.matcher = matcher;
        this.parameters = parameters;
    }

    @Override
    public boolean isWorldAccepted(World world) {
        return matcher.test(world) ? parameters.getAllowTrue() : parameters.getAllowFalse();
    }

    @Override
    public String toString() {
        return String.format("matcher: %s | %s", matcher, parameters.toStringDebug());
    }
}

package com.random.hopper.filters;

public class TrinaryWorldFilterParameters {
    private String description;
    private boolean allowTrue;
    private boolean allowFalse;

    public TrinaryWorldFilterParameters(String description, boolean allowTrue, boolean allowFalse) {
        this.description = description;
        this.allowTrue = allowTrue;
        this.allowFalse = allowFalse;
    }

    public String getDescription() {
        return description;
    }

    public boolean getAllowTrue() {
        return allowTrue;
    }

    public boolean getAllowFalse() {
        return allowFalse;
    }

    @Override
    public String toString() {
        return description;
    }

    public String toStringDebug() {
        return String.format("(%s) %s %s", description, allowTrue, allowFalse);
    }
}

package com.random.hopper.filters;

import net.runelite.http.api.worlds.World;

public interface WorldFilter {
    public boolean isWorldAccepted(World world);
}

package com.random.hopper.filters;


import net.runelite.http.api.worlds.World;
import net.runelite.http.api.worlds.WorldType;

import java.util.function.Predicate;

public class WorldFilterHelpers {
    public static final Predicate<World> isWorldPayToPlay =
        world -> world.getTypes().contains(WorldType.MEMBERS);

    public static final Predicate<World> isWorldPVP =
            world -> world.getTypes().contains(WorldType.PVP);

    public static final Predicate<World> isWorldHighRisk =
            world -> world.getTypes().contains(WorldType.HIGH_RISK);

    public static final Predicate<World> isWorldSkillTotal =
            world -> world.getTypes().contains(WorldType.SKILL_TOTAL);

    public static final Predicate<World> isWorldBounty =
            world -> world.getTypes().contains(WorldType.BOUNTY);

    public static final Predicate<World> isWorldDeadman =
            world -> world.getTypes().contains(WorldType.DEADMAN);

    public static final Predicate<World> isWorldSeasonal =
            world -> world.getTypes().contains(WorldType.SEASONAL);

    public static final Predicate<World> isWorldFreshStart =
            world -> world.getTypes().contains(WorldType.FRESH_START_WORLD);

    public static final Predicate<World> isWorldQuest =
            world -> world.getTypes().contains(WorldType.QUEST_SPEEDRUNNING);

    public static final Predicate<World> isWorldPVPArena =
            world -> world.getTypes().contains(WorldType.PVP_ARENA);

    public static final Predicate<World> isWorldBeta =
            world -> world.getTypes().contains(WorldType.BETA_WORLD);

	public static final Predicate<World> isWorldNoSave =
		world -> world.getTypes().contains(WorldType.NOSAVE_MODE);

    public static final Predicate<World> isWorldTournament =
            world -> world.getTypes().contains(WorldType.TOURNAMENT);

    public static final Predicate<World> isWorldNormal = world ->
            !isWorldDeadman.test(world) &&
            !isWorldSeasonal.test(world) &&
            !isWorldFreshStart.test(world) &&
            !isWorldQuest.test(world) &&
            !isWorldPVPArena.test(world) &&
            !isWorldBeta.test(world) &&
			!isWorldNoSave.test(world) &&
            !isWorldTournament.test(world);

}

package com.random.hopper;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.Keybind;

import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;

@ConfigGroup(RandomHopperConfig.GROUP)
public interface RandomHopperConfig extends Config {
    String GROUP = "randomhopper";

    @ConfigItem(
            keyName = "previousKey",
            name = "Hop previous",
            description = "Press this key to hop to the previous world in the cycle",
            position = 0
    )
    default Keybind previousKey()
    {
        return new Keybind(KeyEvent.VK_1, InputEvent.CTRL_DOWN_MASK | InputEvent.SHIFT_DOWN_MASK);
    }

    @ConfigItem(
            keyName = "randomKey",
            name = "Hop random",
            description = "Press this key to hop to a random world",
            position = 1
    )
    default Keybind randomKey()
    {
        return new Keybind(KeyEvent.VK_2, InputEvent.CTRL_DOWN_MASK | InputEvent.SHIFT_DOWN_MASK);
    }

    @ConfigItem(
            keyName = "nextKey",
            name = "Hop next",
            description = "Press this key to hop to the next world in the cycle",
            position = 2
    )
    default Keybind nextKey()
    {
        return new Keybind(KeyEvent.VK_3, InputEvent.CTRL_DOWN_MASK | InputEvent.SHIFT_DOWN_MASK);
    }
}

package com.random.hopper;

import com.random.hopper.filters.*;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.PluginPanel;

import javax.swing.*;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;

class RandomHopperPanel extends PluginPanel  {
    private RandomHopperPlugin plugin;

    private JComboBox<TrinaryWorldFilterParameters> subscriptionDropdown;
    private JComboBox<TrinaryWorldFilterParameters> pvpDropdown;
    private JComboBox<TrinaryWorldFilterParameters> highRiskDropdown;
    private JComboBox<TrinaryWorldFilterParameters> skillTotalDropdown;
    private JComboBox<TrinaryWorldFilterParameters> bountyWorldDropdown;

    private JCheckBox usaEastBox;
	private JCheckBox usaWestBox;
    private JCheckBox ukBox;
    private JCheckBox gerBox;
    private JCheckBox ausBox;

    private JLabel worldCountLabel;

    private JRadioButton normalButton;
    private JRadioButton deadmanButton;
    private JRadioButton seasonalButton;
    private JRadioButton questButton;
    private JRadioButton freshButton;
    private JRadioButton pvpArenaButton;
    private JRadioButton betaButton;
	private JRadioButton noSaveButton;
    private JRadioButton tournamentButton;

    public JRadioButton[] getWorldTypeButtons() {
        return new JRadioButton[]{
            normalButton, deadmanButton, seasonalButton, questButton, freshButton, pvpArenaButton, betaButton, noSaveButton, tournamentButton
        };
    }
    private JTextField seedTextField;

    private JLabel prevLabel;
    private JLabel currLabel;
    private JLabel nextLabel;

    RandomHopperPanel(RandomHopperPlugin plugin)
    {
        this.plugin = plugin;

        setBorder(null);
        setLayout(new DynamicGridLayout(0, 1));

        JPanel panel = createPanel();

        add(panel);
    }

    Dimension preferredSize = new Dimension(100, 16);
    //private static final String[] comboBoxText = new String[]{"Require", "Reject", "Don't filter"};
    private static final TrinaryWorldFilterParameters[] comboBoxOptions =
        new TrinaryWorldFilterParameters[] {
            new TrinaryWorldFilterParameters( "Always", true, false),
            new TrinaryWorldFilterParameters( "Never", false, true),
            new TrinaryWorldFilterParameters( "Sometimes", true, true),
    };

    private JPanel createLabel(String text) {
        JPanel textPanel = new JPanel();
        textPanel.setLayout(new BoxLayout(textPanel, BoxLayout.X_AXIS));
        textPanel.setPreferredSize(preferredSize);
        textPanel.add(new JLabel(text));
        return textPanel;
    }

    public JPanel createTopBar() {
        JPanel topPanel = new JPanel();
        topPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        topPanel.setLayout(new BoxLayout(topPanel, BoxLayout.X_AXIS));

        JLabel titleLabel = new JLabel("Random Hopper");
        topPanel.add(titleLabel);

        return topPanel;
    }

    public JPanel createPanel() {
        JPanel panel = new JPanel();
        panel.add(createTopBar());
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));

        JPanel subscriptionPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        subscriptionPanel.add(createLabel("Subscription: "));
        subscriptionDropdown = new JComboBox<>(new TrinaryWorldFilterParameters[] {
            new TrinaryWorldFilterParameters( "P2P", true, false),
            new TrinaryWorldFilterParameters( "F2P", false, true),
            new TrinaryWorldFilterParameters( "Either", true, true),
        });
        subscriptionDropdown.setSelectedIndex(0);
        subscriptionPanel.add(subscriptionDropdown);
        panel.add(subscriptionPanel);

        JPanel pvpPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        pvpPanel.add(createLabel("PVP: "));
        pvpDropdown = new JComboBox<>(comboBoxOptions);
        pvpDropdown.setSelectedIndex(1);
        pvpPanel.add(pvpDropdown);
        panel.add(pvpPanel);

        JPanel highRiskPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        highRiskPanel.add(createLabel("High Risk: "));
        highRiskDropdown = new JComboBox<>(comboBoxOptions);
        highRiskDropdown.setSelectedIndex(1);
        highRiskPanel.add(highRiskDropdown);
        panel.add(highRiskPanel);

        // Add the "Skill total World" dropdown
        JPanel skillTotalPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        skillTotalPanel.add(createLabel("Skill total: "));
        skillTotalDropdown = new JComboBox<>(comboBoxOptions);
        skillTotalDropdown.setSelectedIndex(2);
        skillTotalPanel.add(skillTotalDropdown);
        panel.add(skillTotalPanel);

        // Add the "Bounty World" dropdown
        JPanel bountyWorldPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        bountyWorldPanel.add(createLabel("Bounty World: "));
        bountyWorldDropdown = new JComboBox<>(comboBoxOptions);
        bountyWorldDropdown.setSelectedIndex(1);
        bountyWorldPanel.add(bountyWorldDropdown);
        panel.add(bountyWorldPanel);

        JPanel groupCodePanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        seedTextField = new JTextField(8);
        seedTextField.setToolTipText(seedToolTipText);
        groupCodePanel.add(createLabel("Seed: "));
        groupCodePanel.add(seedTextField);
        panel.add(groupCodePanel);

        // Add a checkbox selection titled "Region" with values "Australia", "Germany", "U.K.", "U.S.A"
        JPanel regionPanel = new JPanel();
        regionPanel.setBorder(BorderFactory.createTitledBorder("Region"));
        regionPanel.setLayout(new GridLayout(0, 1));
		usaEastBox = new JCheckBox("U.S.A East");
		usaWestBox = new JCheckBox("U.S.A West");
        ukBox = new JCheckBox("U.K.");
        gerBox = new JCheckBox("Germany");
        ausBox = new JCheckBox("Australia");
        for(JCheckBox box : new JCheckBox[]{usaEastBox, usaWestBox, ukBox, gerBox, ausBox}){
            regionPanel.add(box);
            box.setSelected(true);
        }
        panel.add(regionPanel);

        // World type
        JPanel typePanel = new JPanel();
        typePanel.setBorder(BorderFactory.createTitledBorder("World Type"));
        typePanel.setLayout(new GridLayout(0, 1));

        ButtonGroup typeGroup = new ButtonGroup();

        normalButton = new JRadioButton("Normal");
        deadmanButton = new JRadioButton("Deadman");
        seasonalButton = new JRadioButton("Seasonal");
        questButton = new JRadioButton("Quest Speedrun");
        freshButton = new JRadioButton("Fresh Start");
        pvpArenaButton = new JRadioButton("PVP Arena");
        betaButton = new JRadioButton("Beta");
		noSaveButton = new JRadioButton("No Save");
		tournamentButton = new JRadioButton("Tournament");

        normalButton.setSelected(true);

        typeGroup.add(normalButton);
        typeGroup.add(deadmanButton);
        typeGroup.add(seasonalButton);
        typeGroup.add(questButton);
        typeGroup.add(freshButton);
        typeGroup.add(pvpArenaButton);
        typeGroup.add(betaButton);
		typeGroup.add(noSaveButton);
        typeGroup.add(tournamentButton);

        typePanel.add(normalButton);
        typePanel.add(deadmanButton);
        typePanel.add(seasonalButton);
        typePanel.add(questButton);
        typePanel.add(freshButton);
        typePanel.add(pvpArenaButton);
        typePanel.add(betaButton);
		typePanel.add(noSaveButton);
        typePanel.add(tournamentButton);

        panel.add(typePanel);

        JPanel wordCountPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
        worldCountLabel = new JLabel("");
        worldCountLabel.setToolTipText(worldCountToolTipText);
        wordCountPanel.add(worldCountLabel);
        panel.add(wordCountPanel);

        // Add a "Random" button to the panel
        JPanel randomButtonWrapper = new JPanel(new FlowLayout(FlowLayout.CENTER));
        JButton randomButton = new JButton("Random Hop");
        randomButton.setToolTipText(randomHopToolTipText);
        randomButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                plugin.doRandomHop();
            }
        });
        randomButtonWrapper.add(randomButton);
        panel.add(randomButtonWrapper);

        // Add a row with "Previous" and "Next" buttons to the panel
        JPanel prevNextPanel = new JPanel();
        Dimension buttonPreferredSize = new Dimension(110, 32);
        JButton prevButton = new JButton("Hop Previous");
        prevButton.setPreferredSize(buttonPreferredSize);
        prevButton.setToolTipText(hopPreviousToolTipText);

        JButton nextButton = new JButton("Hop Next");
        nextButton.setPreferredSize(buttonPreferredSize);
        nextButton.setToolTipText(hopNextToolTipText);
        nextButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                plugin.hopNext();
            }
        });
        prevButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                plugin.hopPrevious();
            }
        });
        prevNextPanel.add(prevButton);
        prevNextPanel.add(nextButton);
        panel.add(prevNextPanel);

        JPanel worldPanel = new JPanel();
        worldPanel.setLayout(new GridLayout(1, 3, 10, 0));

        prevLabel = new JLabel();
        prevLabel.setToolTipText(previousWorldToolTipText);
        prevLabel.setHorizontalAlignment(SwingConstants.CENTER);
        worldPanel.add(prevLabel);

        currLabel = new JLabel();
        currLabel.setToolTipText(currentWorldToolTipText);
        currLabel.setHorizontalAlignment(SwingConstants.CENTER);
        worldPanel.add(currLabel);

        nextLabel = new JLabel();
        nextLabel.setToolTipText(nextWorldToolTipText);
        nextLabel.setHorizontalAlignment(SwingConstants.CENTER);

        worldPanel.add(nextLabel);
        updateAdjacentWorlds();
        panel.add(worldPanel);

        ActionListener updateWorldsListener = e -> {
            updateWorldCountLabel();
            updateAdjacentWorlds();
            plugin.saveConfig(generateConfig());
        };

        List<JComboBox<TrinaryWorldFilterParameters>> components = Arrays.asList(subscriptionDropdown, pvpDropdown, highRiskDropdown, skillTotalDropdown, bountyWorldDropdown);
        for (JComboBox<TrinaryWorldFilterParameters> component : components) {
            component.addActionListener(updateWorldsListener);
        }
        for(JRadioButton component : new JRadioButton[]{normalButton, deadmanButton, seasonalButton, questButton, freshButton, pvpArenaButton, betaButton, noSaveButton, tournamentButton}) {
            component.addActionListener(updateWorldsListener);
        }
        for(JCheckBox component : new JCheckBox[] {gerBox, usaEastBox, usaWestBox, ausBox, ukBox}) {
            component.addActionListener(updateWorldsListener);
        }

        seedTextField.getDocument().addDocumentListener(new DocumentListener() {
            @Override
            public void insertUpdate(DocumentEvent e) {
                plugin.newCycle();
                updateAdjacentWorlds();
                plugin.saveConfig(generateConfig());
            }

            @Override
            public void removeUpdate(DocumentEvent e) {
                plugin.newCycle();
                updateAdjacentWorlds();
                plugin.saveConfig(generateConfig());
            }

            @Override
            public void changedUpdate(DocumentEvent e) {
                plugin.newCycle();
                updateAdjacentWorlds();
                plugin.saveConfig(generateConfig());
            }
        });

        return panel;
    }

    public void updateAdjacentWorlds() {
        Integer[] worlds = plugin.getAdjacentWorlds();
        prevLabel.setText(worlds[0] == null ? "?" : String.format("W%s", worlds[0]));
        currLabel.setText(worlds[1] == null ? "?" : String.format("W%s", worlds[1]));
        nextLabel.setText(worlds[2] == null ? "?" : String.format("W%s", worlds[2]));
    }


    public void updateWorldCountLabel() {
        plugin.newCycle();
        setWorldCountLabel(plugin.getWorldCount());
    }

    private void setWorldCountLabel(int count) {
        worldCountLabel.setText(String.format("%d Worlds", count));
    }

    List<WorldFilter> getFilters() {
        List<WorldFilter> filters = new ArrayList<WorldFilter>();

        // subscription filter;
        filters.add(new TrinaryWorldFilter(
                WorldFilterHelpers.isWorldPayToPlay,
                (TrinaryWorldFilterParameters) subscriptionDropdown.getSelectedItem()));

        // pvp filter;
        filters.add(new TrinaryWorldFilter(
                WorldFilterHelpers.isWorldPVP,
                (TrinaryWorldFilterParameters) pvpDropdown.getSelectedItem()));

        // high risk filter;
        filters.add(new TrinaryWorldFilter(
                WorldFilterHelpers.isWorldHighRisk,
                (TrinaryWorldFilterParameters) highRiskDropdown.getSelectedItem()));

        // skill total filter;
        filters.add(new TrinaryWorldFilter(
                WorldFilterHelpers.isWorldSkillTotal,
                (TrinaryWorldFilterParameters) skillTotalDropdown.getSelectedItem()));

        // bounty world filter;
        filters.add(new TrinaryWorldFilter(
                WorldFilterHelpers.isWorldBounty,
                (TrinaryWorldFilterParameters) bountyWorldDropdown.getSelectedItem()));

        filters.add(new RegionWorldFilter(
                ausBox.isSelected(),
				usaEastBox.isSelected(),
				usaWestBox.isSelected(),
                gerBox.isSelected(),
                ukBox.isSelected()));

        if(normalButton.isSelected()) {
            filters.add(new TrinaryWorldFilter(WorldFilterHelpers.isWorldNormal, new TrinaryWorldFilterParameters("normal", true, false)));
        }
        if(deadmanButton.isSelected()) {
            filters.add(new TrinaryWorldFilter(WorldFilterHelpers.isWorldDeadman, new TrinaryWorldFilterParameters("deadman", true, false)));
        }
        if(seasonalButton.isSelected()) {
            filters.add(new TrinaryWorldFilter(WorldFilterHelpers.isWorldSeasonal, new TrinaryWorldFilterParameters("seasonal", true, false)));
        }
        if(questButton.isSelected()) {
            filters.add(new TrinaryWorldFilter(WorldFilterHelpers.isWorldQuest, new TrinaryWorldFilterParameters("quest", true, false)));
        }
        if(freshButton.isSelected()) {
            filters.add(new TrinaryWorldFilter(WorldFilterHelpers.isWorldFreshStart, new TrinaryWorldFilterParameters("fresh", true, false)));
        }
        if(pvpArenaButton.isSelected()) {
            filters.add(new TrinaryWorldFilter(WorldFilterHelpers.isWorldPVPArena, new TrinaryWorldFilterParameters("pvpArena", true, false)));
        }
        if(betaButton.isSelected()) {
            filters.add(new TrinaryWorldFilter(WorldFilterHelpers.isWorldBeta, new TrinaryWorldFilterParameters("beta", true, false)));
        }
		if(noSaveButton.isSelected()) {
			filters.add(new TrinaryWorldFilter(WorldFilterHelpers.isWorldNoSave, new TrinaryWorldFilterParameters("no save", true, false)));
		}
        if(tournamentButton.isSelected()) {
            filters.add(new TrinaryWorldFilter(WorldFilterHelpers.isWorldTournament, new TrinaryWorldFilterParameters("tournament", true, false)));
        }
        return filters;
    }

    public int getSeed() {
        if(seedTextField.getText().isEmpty()) {
            return new Random().nextInt();
        } else {
            return seedTextField.getText().hashCode();
        }
    }

    public void setUiFromConfig(FilterConfig config) {
        if (config == null) {
            return;
        }
        subscriptionDropdown.setSelectedIndex(config.subscriptionIndex);
        pvpDropdown.setSelectedIndex(config.pvpIndex);
        highRiskDropdown.setSelectedIndex(config.highRiskIndex);
        skillTotalDropdown.setSelectedIndex(config.skillTotalIndex);
        bountyWorldDropdown.setSelectedIndex(config.bountyWorldIndex);
        seedTextField.setText(config.seed);
        usaEastBox.setSelected(config.usaEastSelected);
        usaWestBox.setSelected(config.usaWestSelected);
        ukBox.setSelected(config.ukSelected);
        gerBox.setSelected(config.germanySelected);
        ausBox.setSelected(config.australiaSelected);
        getWorldTypeButtons()[config.worldTypeIndex].setSelected(true);

    }

    public FilterConfig generateConfig() {
        int worldTypeIndex = 0;
        JRadioButton[] worldTypeRadioButtons = getWorldTypeButtons();
        for(int i = 0; i < worldTypeRadioButtons.length; i++) {
            if(worldTypeRadioButtons[i].isSelected()) {
                worldTypeIndex = i;
                break;
            }
        }
        return new FilterConfig(
            subscriptionDropdown.getSelectedIndex(),
            pvpDropdown.getSelectedIndex(),
            highRiskDropdown.getSelectedIndex(),
            skillTotalDropdown.getSelectedIndex(),
            bountyWorldDropdown.getSelectedIndex(),
            seedTextField.getText(),
            usaEastBox.isSelected(),
            usaWestBox.isSelected(),
            ukBox.isSelected(),
            gerBox.isSelected(),
            ausBox.isSelected(),
            worldTypeIndex
        );
    }

    private static final String worldCountToolTipText = "How many worlds passed through the filters.";
    private static final String randomHopToolTipText = "Hops to a random world.";
    private static final String hopPreviousToolTipText = "Hops to the previous world in the cycle, or a random world if you aren't in the cycle yet.";
    private static final String hopNextToolTipText = "Hops to the next world in the cycle, or a random world if you aren't in the cycle yet.";
    private static final String seedToolTipText = "If multiple people have the same seed and all the same configuration, \"Hop Next\" will always follow the same worlds.";

    private static final String previousWorldToolTipText = "Previous world";
    private static final String currentWorldToolTipText = "Current world";
    private static final String nextWorldToolTipText = "Next world";

}

package com.random.hopper;

import java.awt.image.BufferedImage;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Random;

import javax.inject.Inject;

import com.google.common.collect.BiMap;
import com.google.common.collect.HashBiMap;
import com.google.common.reflect.TypeToken;
import com.google.gson.Gson;
import com.google.inject.Provides;
import com.random.hopper.filters.BlockIDWorldFilter;
import com.random.hopper.filters.ComboWorldFilter;
import com.random.hopper.filters.SkillTotalWorldFilter;
import com.random.hopper.filters.WorldFilter;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.WorldChanged;
import net.runelite.api.widgets.ComponentID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.WorldService;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.HotkeyListener;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.WorldUtil;
import net.runelite.http.api.worlds.World;
import net.runelite.http.api.worlds.WorldResult;

@Slf4j
@PluginDescriptor(
	name = "Random Hopper",
	description = "",
	tags = {"World Hop"}
)
public class RandomHopperPlugin extends Plugin
{
	@Inject private Client client;
	@Inject private ClientToolbar clientToolbar;
	@Inject private WorldService worldService;
	@Inject private ClientThread clientThread;
	@Inject private ConfigManager configManager;
	@Inject private RandomHopperConfig config;
	@Inject private KeyManager keyManager;
	@Inject private Gson gson;

	private static final String CONFIG_GROUP = "randomhopper";
	private static final String CONFIG_KEY = "config";

	private NavigationButton navButton;
	private RandomHopperPanel panel;

	private World targetWorld;

	// A map from current world to next world
	private BiMap<Integer, Integer> cycleMapping;

	private boolean shouldRecalculateWorldsOnTick = false;

	@Override
	protected void startUp()
	{
		clientThread.invoke(() -> {
			WorldHelper.setWorldEnum(client.getEnum(4992));
			shouldRecalculateWorldsOnTick = true;
		});
		keyManager.registerKeyListener(randomKeyListener);
		keyManager.registerKeyListener(previousKeyListener);
		keyManager.registerKeyListener(nextKeyListener);
		targetWorld = null;
		BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/randomhopper_icon.png");
		panel = new RandomHopperPanel(this);
		navButton = NavigationButton.builder()
				.tooltip("Random Hopper")
				.icon(icon)
				.priority(5)
				.panel(panel)
				.build();
		panel.setUiFromConfig(loadConfig());
		panel.updateWorldCountLabel();
		clientToolbar.addNavigation(navButton);
	}

	@Override
	protected void shutDown() throws Exception
	{
		clientToolbar.removeNavigation(navButton);
		keyManager.unregisterKeyListener(randomKeyListener);
		keyManager.unregisterKeyListener(previousKeyListener);
		keyManager.unregisterKeyListener(nextKeyListener);
	}

	@Provides
	RandomHopperConfig getConfig(ConfigManager configManager)
	{
		return configManager.getConfig(RandomHopperConfig.class);
	}

	@Subscribe
	public void onGameTick(GameTick tick)
	{
		if (targetWorld == null)
		{
			return;
		}
		if(shouldRecalculateWorldsOnTick) {
			newCycle();
			panel.updateAdjacentWorlds();
			shouldRecalculateWorldsOnTick = false;
		}
		if(isWorldHopperOpen()) {
			client.hopToWorld(convertToApiWorld(targetWorld));
			targetWorld = null;
		} else {
			client.openWorldHopper();
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		if(gameStateChanged.getGameState() == GameState.LOGGED_IN) {
			panel.updateAdjacentWorlds();
		}
	}

	@Subscribe
	public void onWorldChanged(WorldChanged worldChanged) {
		panel.updateAdjacentWorlds();
	}

	boolean isWorldHopperOpen()
	{
		return client.getWidget(ComponentID.WORLD_SWITCHER_WORLD_LIST) != null;
	}

	private void hop(World world)
	{
		assert client.isClientThread();

		final net.runelite.api.World rsWorld = convertToApiWorld(world);

		if (client.getGameState() == GameState.LOGIN_SCREEN)
		{ // on the login screen we can just change the world by ourselves
			client.changeWorld(rsWorld);
		}
		else if(client.getGameState() != GameState.HOPPING)
		{ // Clicking the hop button mid-hop will queue another hop immediately without this.
			targetWorld = world;
		}
		panel.updateAdjacentWorlds();
	}

	private net.runelite.api.World convertToApiWorld(net.runelite.http.api.worlds.World world) {
		final net.runelite.api.World rsWorld = client.createWorld();
		rsWorld.setActivity(world.getActivity());
		rsWorld.setAddress(world.getAddress());
		rsWorld.setId(world.getId());
		rsWorld.setPlayerCount(world.getPlayers());
		rsWorld.setLocation(world.getLocation());
		rsWorld.setTypes(WorldUtil.toWorldTypes(world.getTypes()));
		return rsWorld;
	}

	ArrayList<World> getValidWorlds(WorldFilter filter) {
		WorldResult worldResult = worldService.getWorlds();
		if(worldResult == null) {
			log.error("worldResult was null");
			return new ArrayList<World>();
		}
		List<World> worlds = worldResult.getWorlds();
		ArrayList<World> validWorlds = new ArrayList<>();
		for(World world : worlds) {
			if(filter.isWorldAccepted(world)) {
				validWorlds.add(world);
			}
		}
		return validWorlds;
	}

	List<World> filterWorlds(List<World> worlds, WorldFilter filter) {
		List<World> newWorlds = new ArrayList<>();
		for(World world : worlds) {
			if(filter.isWorldAccepted(world)) {
				newWorlds.add(world);
			}
		}
		return newWorlds;
	}

	// Cycle must exist
	private World getRandomWorldFromCycle() {
		WorldResult worldResult = worldService.getWorlds();
		if(worldResult == null) {
			log.error("worldResult was null");
			return null;
		}
		Random r = new Random();
		int nextWorldIndex = r.nextInt(cycleMapping.keySet().size());
		int i = 0;
		int nextWorldID = -1; // This will never be -1
		for(int worldID : cycleMapping.keySet()) {
			if(i == nextWorldIndex) {
				nextWorldID = worldID;
				break;
			}
			i++;
		}
		return worldResult.findWorld(nextWorldID);
	}

	void hopPrevious() {
		if(cycleMapping == null) {
			return;
		}
		if(client.getGameState() == GameState.LOADING || client.getGameState() == GameState.HOPPING) {
			return;
		}
		int currentWorld = client.getWorld();
		World nextWorld;
		WorldResult worldResult = worldService.getWorlds();
		if(worldResult == null) {
			log.error("worldResult was null");
			return;
		}
		if(!cycleMapping.containsKey(currentWorld)) {
			nextWorld = getRandomWorldFromCycle();
		}
		else
		{
			int nextWorldID = cycleMapping.inverse().get(currentWorld);
			nextWorld = worldResult.findWorld(nextWorldID);
		}

		clientThread.invoke(() -> hop(nextWorld));
	}

	void hopNext() {
		if(cycleMapping == null) {
			return;
		}
		if(client.getGameState() == GameState.LOADING || client.getGameState() == GameState.HOPPING) {
			return;
		}
		int currentWorld = client.getWorld();
		World nextWorld;
		WorldResult worldResult = worldService.getWorlds();
		if(worldResult == null) {
			log.error("worldResult was null");
			return;
		}
		if(!cycleMapping.containsKey(currentWorld)) {
			nextWorld = getRandomWorldFromCycle();
		}
		else
		{
			int nextWorldID = cycleMapping.get(currentWorld);
			nextWorld = worldResult.findWorld(nextWorldID);
		}

		clientThread.invoke(() -> hop(nextWorld));
	}

	void newCycle() {
		List<WorldFilter> panelFilters = panel.getFilters();
		panelFilters.add(getSkillTotalFilter());
		WorldFilter comboFilter = new ComboWorldFilter(panelFilters);

		/**
		 * getWorlds() does not return a sorted list, must manually sort to ensure
		 * that the shuffle is consistent given a seed.
 		 */
		WorldResult worldResult = worldService.getWorlds();
		if(worldResult == null) {
			log.error("worldResult was null");
			return;
		}
		List<World> allWorlds = worldResult.getWorlds();
		Collections.sort(allWorlds, Comparator.comparingInt(World::getId));
		Collections.shuffle(allWorlds, new Random(panel.getSeed()));
		List<World> validWorlds = filterWorlds(allWorlds, comboFilter);

		ArrayList<Integer> validWorldIDs = new ArrayList<>();
		for(World world : validWorlds) {
			validWorldIDs.add(world.getId());
		}

		if(validWorlds.size() == 0) {
			cycleMapping = null;
			return;
		}

		cycleMapping = HashBiMap.create();
		for(int i = 0; i < validWorlds.size() - 1; i++) {
			cycleMapping.put(validWorldIDs.get(i), validWorldIDs.get(i + 1));
		}
		cycleMapping.put(validWorldIDs.get(validWorldIDs.size() - 1), validWorldIDs.get(0));
	}

	public int getWorldCount() {
		if(cycleMapping == null) {
			return 0;
		} else {
			return cycleMapping.size();
		}
	}

	void doRandomHop()
	{
		if(client.getGameState() == GameState.LOADING || client.getGameState() == GameState.HOPPING) {
			return;
		}
		List<WorldFilter> filters = panel.getFilters();
		filters.add(new BlockIDWorldFilter(client.getWorld()));
		filters.add(getSkillTotalFilter());
		WorldFilter comboFilter = new ComboWorldFilter(filters);
		ArrayList<World> validWorlds = getValidWorlds(comboFilter);
		Random r = new Random();
		if(validWorlds.size() == 0) {
			return;
		}
		int chosenIndex = r.nextInt(validWorlds.size());
		World chosenWorld = validWorlds.get(chosenIndex);
		clientThread.invoke(() -> hop(chosenWorld));
	}

	WorldFilter getSkillTotalFilter() {
		return new SkillTotalWorldFilter(client.getTotalLevel());
	}

	public Integer[] getAdjacentWorlds() {
		int currentWorldID = client.getWorld();
		if(cycleMapping == null || !cycleMapping.containsKey(currentWorldID))
		{
			// If there is only one available world though, then it's always that one.
			if(cycleMapping != null && cycleMapping.size() == 1) {
				int onlyWorld = cycleMapping.values().iterator().next();
				return new Integer[] {onlyWorld, currentWorldID, onlyWorld};
			}
			// Not in the cycle currently - next would be random
			return new Integer[] {null, currentWorldID, null};
		}
		else
		{
			int nextWorldID = cycleMapping.get(currentWorldID);
			int prevWorldID = cycleMapping.inverse().get(currentWorldID);
			return new Integer[] {prevWorldID, currentWorldID, nextWorldID};
		}
	}

	private final HotkeyListener randomKeyListener = new HotkeyListener(() -> config.randomKey())
	{
		@Override
		public void hotkeyPressed()
		{
			clientThread.invoke(() -> doRandomHop());
		}
	};
	private final HotkeyListener previousKeyListener = new HotkeyListener(() -> config.previousKey())
	{
		@Override
		public void hotkeyPressed()
		{
			clientThread.invoke(() -> hopPrevious());
		}
	};
	private final HotkeyListener nextKeyListener = new HotkeyListener(() -> config.nextKey())
	{
		@Override
		public void hotkeyPressed()
		{
			clientThread.invoke(() -> hopNext());
		}
	};

	public void saveConfig(FilterConfig config) {
		String json = gson.toJson(config);
		// System.out.printf("Got string %s%n", json);
		configManager.setConfiguration(CONFIG_GROUP, CONFIG_KEY, json);
	}

	public FilterConfig loadConfig() {
		try {
			String json = configManager.getConfiguration(CONFIG_GROUP, CONFIG_KEY);
			// System.out.printf("Got string %s%n", json);
			Type type = new TypeToken<FilterConfig>() {}.getType();
			FilterConfig config = gson.fromJson(json, type);
			return config;
		} catch (Exception e) {
			// System.out.println("ERROR");
			// System.out.println(e);
		}
		return null;
	}
}

package com.random.hopper;

public enum USWorld
{
	EAST(-42),
	WEST(-73);

	private final int enumValue;

	USWorld(int enumValue) {
		this.enumValue = enumValue;
	}

	public int getEnumValue() {
		return enumValue;
	}
}

package com.random.hopper;

import java.util.Arrays;
import net.runelite.api.EnumComposition;

public class WorldHelper
{
	private static EnumComposition worldEnum = null;
	// Sets the enum that holds the US East vs West map
	public static void setWorldEnum(EnumComposition worldEnum) {
		WorldHelper.worldEnum = worldEnum;
	}

	public static USWorld getUSWorldSide(int worldNumber) {
		if(worldEnum == null) {
			return null;
		}
		boolean worldInKeys = Arrays.stream(worldEnum.getKeys()).anyMatch((key) -> key == worldNumber);
		if (worldInKeys)
		{
			int worldEnumValue = worldEnum.getIntValue(worldNumber);
			if(worldEnumValue == USWorld.WEST.getEnumValue())
			{
				return USWorld.WEST;
			}
			else if(worldEnumValue == USWorld.EAST.getEnumValue()) {
				return USWorld.EAST;
			}
			else {
				return null;
			}
		}
		else {
			return null;
		}
	}
}

package com.random.hopper;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class randomHopperTest
{
	@SuppressWarnings("unchecked")
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(RandomHopperPlugin.class);
		RuneLite.main(args);
	}
}
