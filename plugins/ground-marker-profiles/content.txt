package com.groundMarkerProfiles;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;


@ConfigGroup(GroundMarkerProfilesConfig.GROUP)
public interface GroundMarkerProfilesConfig extends Config {
	String GROUP = "groundMarkerProfile";

	// ------------------------------------------------------------

	// Group 0 (+1 for visible strings)
	@ConfigSection(
			name = "Ground Marker Group 1",
			position = 0,
			description = "Settings for the first group of ground markers",
			closedByDefault = true
	)
	String groundMarkerProfile0 = "groundMarkerProfile0";

	@ConfigItem(
			keyName = "nameProfile0",
			name = "Marker Name 1",
			description = "Name for the first set of ground markers",
			section = groundMarkerProfile0,
			position = 0
	)
	default String nameProfile0() {
		return "CM 5 tg";
	}

	@ConfigItem(
			keyName = "tilesProfile0",
			name = "Marker Profile 1",
			description = "Ground markers associated with first group",
			section = groundMarkerProfile0,
			position = 0
	)
	default String tilesProfile0() {
		return "[{\"regionId\":13140,\"regionX\":46,\"regionY\":3,\"z\":0,\"color\":\"#FFFFFFFF\",\"label\":\"1\"},{\"regionId\":13140,\"regionX\":46,\"regionY\":7,\"z\":0,\"color\":\"#FFFFFFFF\",\"label\":\"2\"},{\"regionId\":13140,\"regionX\":48,\"regionY\":6,\"z\":0,\"color\":\"#FFFFFFFF\",\"label\":\"3\"},{\"regionId\":13140,\"regionX\":47,\"regionY\":8,\"z\":0,\"color\":\"#FFFFFFFF\",\"label\":\"4\"},{\"regionId\":13140,\"regionX\":49,\"regionY\":9,\"z\":0,\"color\":\"#FFFFFFFF\",\"label\":\"5\"},{\"regionId\":13140,\"regionX\":49,\"regionY\":13,\"z\":0,\"color\":\"#FFFFFFFF\",\"label\":\"6\"},{\"regionId\":13140,\"regionX\":53,\"regionY\":15,\"z\":0,\"color\":\"#FFFFFFFF\",\"label\":\"7\"},{\"regionId\":13140,\"regionX\":43,\"regionY\":3,\"z\":0,\"color\":\"#FFFF0000\",\"label\":\"1\"},{\"regionId\":13140,\"regionX\":41,\"regionY\":3,\"z\":0,\"color\":\"#FFFF0000\",\"label\":\"2\"},{\"regionId\":13140,\"regionX\":40,\"regionY\":5,\"z\":0,\"color\":\"#FFFF0000\",\"label\":\"3\"},{\"regionId\":13140,\"regionX\":41,\"regionY\":7,\"z\":0,\"color\":\"#FFFF0000\",\"label\":\"4\"},{\"regionId\":13140,\"regionX\":43,\"regionY\":7,\"z\":0,\"color\":\"#FFFF0000\",\"label\":\"5\"},{\"regionId\":13140,\"regionX\":45,\"regionY\":13,\"z\":0,\"color\":\"#FFFF0000\",\"label\":\"6\"},{\"regionId\":13140,\"regionX\":51,\"regionY\":7,\"z\":0,\"color\":\"#FFFF0000\",\"label\":\"7\"},{\"regionId\":13140,\"regionX\":52,\"regionY\":10,\"z\":0,\"color\":\"#FFFF0000\",\"label\":\"8\"},{\"regionId\":13140,\"regionX\":54,\"regionY\":10,\"z\":0,\"color\":\"#FFFF0000\",\"label\":\"drop\"},{\"regionId\":13140,\"regionX\":44,\"regionY\":2,\"z\":0,\"color\":\"#FF0087FF\",\"label\":\"1\"},{\"regionId\":13140,\"regionX\":43,\"regionY\":6,\"z\":0,\"color\":\"#FF0087FF\",\"label\":\"2\"},{\"regionId\":13140,\"regionX\":42,\"regionY\":9,\"z\":0,\"color\":\"#FF0087FF\",\"label\":\"3\"},{\"regionId\":13140,\"regionX\":44,\"regionY\":11,\"z\":0,\"color\":\"#FF0087FF\",\"label\":\"4\"},{\"regionId\":13140,\"regionX\":47,\"regionY\":13,\"z\":0,\"color\":\"#FF0087FF\",\"label\":\"5\"},{\"regionId\":13140,\"regionX\":48,\"regionY\":14,\"z\":0,\"color\":\"#FF0087FF\",\"label\":\"6\"},{\"regionId\":13140,\"regionX\":50,\"regionY\":16,\"z\":0,\"color\":\"#FF0087FF\",\"label\":\"7\"},{\"regionId\":13140,\"regionX\":52,\"regionY\":17,\"z\":0,\"color\":\"#FF0087FF\",\"label\":\"8\"},{\"regionId\":13140,\"regionX\":57,\"regionY\":12,\"z\":0,\"color\":\"#FF000000\",\"label\":\"drop\"},{\"regionId\":13140,\"regionX\":46,\"regionY\":5,\"z\":0,\"color\":\"#FF000000\",\"label\":\"1\"},{\"regionId\":13140,\"regionX\":45,\"regionY\":8,\"z\":0,\"color\":\"#FF000000\",\"label\":\"2\"},{\"regionId\":13140,\"regionX\":46,\"regionY\":9,\"z\":0,\"color\":\"#FF000000\",\"label\":\"3\"},{\"regionId\":13140,\"regionX\":48,\"regionY\":12,\"z\":0,\"color\":\"#FF000000\",\"label\":\"4\"},{\"regionId\":13140,\"regionX\":50,\"regionY\":11,\"z\":0,\"color\":\"#FF000000\",\"label\":\"5\"},{\"regionId\":13140,\"regionX\":52,\"regionY\":13,\"z\":0,\"color\":\"#FF000000\",\"label\":\"6\"},{\"regionId\":13140,\"regionX\":56,\"regionY\":13,\"z\":0,\"color\":\"#FF000000\",\"label\":\"7\"}]";
	}

	// Group 1 (+1 for visible strings)
	@ConfigSection(
			name = "Ground Marker Group 2",
			position = 1,
			description = "Settings for the second group of ground markers",
			closedByDefault = true
	)
	String groundMarkerProfile1 = "groundMarkerProfile1";

	@ConfigItem(
			keyName = "nameProfile1",
			name = "Marker Name 2",
			description = "Name for the second set of ground markers",
			section = groundMarkerProfile1,
			position = 0
	)
	default String nameProfile1() {
		return "Profile 2";
	}

	@ConfigItem(
			keyName = "tilesProfile1",
			name = "Marker Profile 2",
			description = "Ground markers associated with second group",
			section = groundMarkerProfile1,
			position = 0
	)
	default String tilesProfile1() {
		return "";
	}

	// Group 2 (+1 for visible strings)
	@ConfigSection(
			name = "Ground Marker Group 3",
			position = 2,
			description = "Settings for the third group of ground markers",
			closedByDefault = true
	)
	String groundMarkerProfile2 = "groundMarkerProfile2";

	@ConfigItem(
			keyName = "nameProfile2",
			name = "Marker Name 3",
			description = "Name for the third set of ground markers",
			section = groundMarkerProfile2,
			position = 0
	)
	default String nameProfile2() {
		return "Profile 3";
	}

	@ConfigItem(
			keyName = "tilesProfile2",
			name = "Marker Profile 3",
			description = "Ground markers associated with third group",
			section = groundMarkerProfile2,
			position = 0
	)
	default String tilesProfile2() {
		return "";
	}

	// Group 3 (+1 for visible strings)
	@ConfigSection(
			name = "Ground Marker Group 4",
			position = 3,
			description = "Settings for the fourth group of ground markers",
			closedByDefault = true
	)
	String groundMarkerProfile3 = "groundMarkerProfile3";

	@ConfigItem(
			keyName = "nameProfile3",
			name = "Marker Name 4",
			description = "Name for the fourth set of ground markers",
			section = groundMarkerProfile3,
			position = 0
	)
	default String nameProfile3() {
		return "Profile 4";
	}

	@ConfigItem(
			keyName = "tilesProfile3",
			name = "Marker Profile 4",
			description = "Ground markers associated with fourth group",
			section = groundMarkerProfile3,
			position = 0
	)
	default String tilesProfile3() {
		return "";
	}

	// Group 4 (+1 for visible strings)
	@ConfigSection(
			name = "Ground Marker Group 5",
			position = 4,
			description = "Settings for the fifth group of ground markers",
			closedByDefault = true
	)
	String groundMarkerProfile4 = "groundMarkerProfile4";

	@ConfigItem(
			keyName = "nameProfile4",
			name = "Marker Name 5",
			description = "Name for the fifth set of ground markers",
			section = groundMarkerProfile4,
			position = 0
	)
	default String nameProfile4() {
		return "Profile 5";
	}

	@ConfigItem(
			keyName = "tilesProfile4",
			name = "Marker Profile 5",
			description = "Ground markers associated with fifth group",
			section = groundMarkerProfile4,
			position = 0
	)
	default String tilesProfile4() {
		return "";
	}

	// Group 5 (+1 for visible strings)
	@ConfigSection(
			name = "Ground Marker Group 6",
			position = 5,
			description = "Settings for the sixth group of ground markers",
			closedByDefault = true
	)
	String groundMarkerProfile5 = "groundMarkerProfile5";

	@ConfigItem(
			keyName = "nameProfile5",
			name = "Marker Name 6",
			description = "Name for the sixth set of ground markers",
			section = groundMarkerProfile5,
			position = 0
	)
	default String nameProfile5() {
		return "Profile 6";
	}

	@ConfigItem(
			keyName = "tilesProfile5",
			name = "Marker Profile 6",
			description = "Ground markers associated with sixth group",
			section = groundMarkerProfile5,
			position = 0
	)
	default String tilesProfile5() {
		return "";
	}

	// Group 6 (+1 for visible strings)
	@ConfigSection(
			name = "Ground Marker Group 7",
			position = 6,
			description = "Settings for the seventh group of ground markers",
			closedByDefault = true
	)
	String groundMarkerProfile6 = "groundMarkerProfile6";

	@ConfigItem(
			keyName = "nameProfile6",
			name = "Marker Name 7",
			description = "Name for the seventh set of ground markers",
			section = groundMarkerProfile6,
			position = 0
	)
	default String nameProfile6() {
		return "Profile 7";
	}

	@ConfigItem(
			keyName = "tilesProfile6",
			name = "Marker Profile 7",
			description = "Ground markers associated with seventh group",
			section = groundMarkerProfile6,
			position = 0
	)
	default String tilesProfile6() {
		return "";
	}

	// Group 7 (+1 for visible strings)
	@ConfigSection(
			name = "Ground Marker Group 8",
			position = 7,
			description = "Settings for the eighth group of ground markers",
			closedByDefault = true
	)
	String groundMarkerProfile7 = "groundMarkerProfile7";

	@ConfigItem(
			keyName = "nameProfile7",
			name = "Marker Name 8",
			description = "Name for the eighth set of ground markers",
			section = groundMarkerProfile7,
			position = 0
	)
	default String nameProfile7() {
		return "Profile 8";
	}

	@ConfigItem(
			keyName = "tilesProfile7",
			name = "Marker Profile 8",
			description = "Ground markers associated with eighth group",
			section = groundMarkerProfile7,
			position = 0
	)
	default String tilesProfile7() {
		return "";
	}

	// Group 8 (+1 for visible strings)
	@ConfigSection(
			name = "Ground Marker Group 9",
			position = 8,
			description = "Settings for the ninth group of ground markers",
			closedByDefault = true
	)
	String groundMarkerProfile8 = "groundMarkerProfile8";

	@ConfigItem(
			keyName = "nameProfile8",
			name = "Marker Name 9",
			description = "Name for the ninth set of ground markers",
			section = groundMarkerProfile8,
			position = 0
	)
	default String nameProfile8() {
		return "Profile 9";
	}

	@ConfigItem(
			keyName = "tilesProfile8",
			name = "Marker Profile 9",
			description = "Ground markers associated with ninth group",
			section = groundMarkerProfile8,
			position = 0
	)
	default String tilesProfile8() {
		return "";
	}

	// Group 9 (+1 for visible strings)
	@ConfigSection(
			name = "Ground Marker Group 10",
			position = 9,
			description = "Settings for the tength group of ground markers",
			closedByDefault = true
	)
	String groundMarkerProfile9 = "groundMarkerProfile9";

	@ConfigItem(
			keyName = "nameProfile9",
			name = "Marker Name 10",
			description = "Name for the tenth set of ground markers",
			section = groundMarkerProfile9,
			position = 0
	)
	default String nameProfile9() {
		return "Profile 10";
	}

	@ConfigItem(
			keyName = "tilesProfile9",
			name = "Marker Profile 10",
			description = "Ground markers associated with tenth group",
			section = groundMarkerProfile9,
			position = 0
	)
	default String tilesProfile9() {
		return "";
	}

	@ConfigItem(
			keyName = "previousMarkerProfile",
			name = "",
			description = "",
			hidden = true
	)
	default Integer previousMarkerProfile() {
		return 0;
	}

	@ConfigItem(
			keyName = "previousMarkerProfile",
			name = "",
			description = "",
			hidden = true
	)
	void setPreviousMarkerProfile(Integer index);
}
package com.groundMarkerProfiles;

import com.google.gson.Gson;
import com.google.inject.Provides;
import javax.inject.Inject;

import com.groundMarkerProfiles.ui.GroundMarkerOverlay;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.awt.image.BufferedImage;

@PluginDescriptor(
	name = "Ground Marker Profiles"
)
public class GroundMarkerProfilesPlugin extends Plugin {
	@Inject
	private Client client;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private GroundMarkerProfilesConfig config;

	@Inject
	private Gson gson;

	@Inject
	private OverlayManager overlayManager;

	public ProfileSwapper profileSwapper;
	private PointManager pointManager;
	private GroundMarkerOverlay groundMarkerOverlay;
	private GroundMarkerProfilesSidePanel sidePanel;
	private NavigationButton sidePanelButton;

	public static final Logger log = LoggerFactory.getLogger(GroundMarkerProfilesPlugin.class);

	@Override
	protected void startUp() throws Exception
	{
		log.info("Ground Marker Profiles started");

		profileSwapper = new ProfileSwapper(this, config);
		pointManager = new PointManager(profileSwapper, gson, client);

		groundMarkerOverlay = new GroundMarkerOverlay(pointManager, client, config);
		overlayManager.add(groundMarkerOverlay);

		pointManager.loadPoints();
		createSidePanel();
	}

	@Override
	protected void shutDown() throws Exception
	{
		log.info("Ground Marker Profiles stopped");
		overlayManager.remove(groundMarkerOverlay);
		removeSidePanel();
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged) {
		if (gameStateChanged.getGameState() == GameState.LOGGED_IN) {
			pointManager.loadPoints();
		}
	}

	@Provides
	GroundMarkerProfilesConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(GroundMarkerProfilesConfig.class);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged) {
		if (configChanged.getGroup().equals(GroundMarkerProfilesConfig.GROUP)) {
			// Example key name is "nameProfile9" NOTE: these can go to multiple digits
			String keyChanged = configChanged.getKey();
			if (keyChanged.startsWith("nameProfile")) {
				Integer indexChanged = Integer.valueOf(keyChanged.substring(11));
				sidePanel.updateButtonName(indexChanged, configChanged.getNewValue());
			} else {
				profileSwapper.updateTileProfiles();
				pointManager.loadPoints();
			}
		}
	}

	private void createSidePanel() {
		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/ico.png");
		sidePanel = new GroundMarkerProfilesSidePanel(this, config);
		sidePanelButton = NavigationButton.builder().tooltip("Ground Marker Profiles").icon(icon).priority(6).panel(sidePanel).build();
		clientToolbar.addNavigation(sidePanelButton);
		sidePanel.startPanel();
	}

	private void removeSidePanel()
	{
		clientToolbar.removeNavigation(sidePanelButton);
	}
}

/*
 * Copyright (c) 2019, Jordan Atwood <nightfirecat@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.groundMarkerProfiles.data;

import lombok.Value;
import net.runelite.api.coords.WorldPoint;

import javax.annotation.Nullable;
import java.awt.*;

/**
 * Used to denote marked tiles and their colors.
 * Note: This is not used for serialization of ground markers; see {@link GroundMarkerPoint}
 */
@Value
public class ColorTileMarker {
    private WorldPoint worldPoint;
    @Nullable
    private Color color;
    @Nullable
    private String label;
}
/*
 * Copyright (c) 2018, TheLonelyDev <https://github.com/TheLonelyDev>
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Source: https://github.com/runelite/runelite/blob/master/runelite-client/src/main/java/net/runelite/client/plugins/groundmarkers/GroundMarkerPoint.java
 */
package com.groundMarkerProfiles.data;

import lombok.EqualsAndHashCode;
import lombok.Value;

import javax.annotation.Nullable;
import java.awt.*;

/**
 * Used for serialization of ground marker points.
 */
@Value
@EqualsAndHashCode(exclude = {"color", "label"})
public class GroundMarkerPoint {
    private int regionId;
    private int regionX;
    private int regionY;
    private int z;
    @Nullable
    private Color color;
    @Nullable
    private String label;
}
/*
 * Copyright (c) 2024, Trevor <https://github.com/TrevorMDev>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.groundMarkerProfiles;

import com.google.common.reflect.TypeToken;
import com.google.gson.Gson;
import com.groundMarkerProfiles.data.ColorTileMarker;
import com.groundMarkerProfiles.data.GroundMarkerPoint;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.coords.WorldPoint;

import javax.inject.Inject;
import java.util.*;
import java.util.List;
import java.util.stream.Collectors;

/**
 * This class is responsible for translating the json strings into drawable points
 */
@Slf4j
@Value
public class PointManager {

    private List<ColorTileMarker> points = new ArrayList<>();

    private final ProfileSwapper profileSwapper;
    private final Gson gson;
    private final Client client;

    @Inject
    PointManager(ProfileSwapper profileSwapper, Gson gson, Client client) {
        this.profileSwapper = profileSwapper;
        this.gson = gson;
        this.client = client;
    }

    public void loadPoints() {
        points.clear();

        // When the plugin is toggled on from the sign in page, errors occur when using client.getMapRegions();
        if (client.getGameState() != GameState.LOGGED_IN) {
            return;
        }

        int[] regions = client.getMapRegions();

        if (regions == null) {
            return;
        }

        for (int regionId : regions) {
            Collection<GroundMarkerPoint> regionPoints = getActivePoints(regionId);
            Collection<ColorTileMarker> colorTileMarkers = translateToColorTileMarker(regionPoints);
            points.addAll(colorTileMarkers);
        }
    }

    private List<GroundMarkerPoint> getActivePoints() {
        List<GroundMarkerPoint> markers = new ArrayList<>();
        String activeGroundMarkerJson = profileSwapper.getActiveTileProfile();

        if (activeGroundMarkerJson.isEmpty()) {
            return markers;
        }

        try {
            markers.addAll(gson.fromJson(
                    activeGroundMarkerJson,
                    new TypeToken<List<GroundMarkerPoint>>() {
                    }.getType()));
        } catch (Exception ex) {
            return markers;
        }

        return markers;
    }

    //gets all the active points, filtered for a region
    private List<GroundMarkerPoint> getActivePoints(int regionId) {
        List<GroundMarkerPoint> activePoints = getActivePoints();
        Map<Integer, List<GroundMarkerPoint>> regionGroupedPoints = activePoints.stream()
                .collect(Collectors.groupingBy(GroundMarkerPoint::getRegionId));
        List<GroundMarkerPoint> regionPoints = regionGroupedPoints.get(regionId);
        if (regionPoints == null) {
            return Collections.emptyList();
        }
        return regionPoints;
    }


    private Collection<ColorTileMarker> translateToColorTileMarker(Collection<GroundMarkerPoint> points) {
        if (points.isEmpty()) {
            return Collections.emptyList();
        }

        return points.stream()
                .map(point -> new ColorTileMarker(
                        WorldPoint.fromRegion(point.getRegionId(), point.getRegionX(), point.getRegionY(), point.getZ()),
                        point.getColor(), point.getLabel()))
                .flatMap(colorTile ->
                {
                    final Collection<WorldPoint> localWorldPoints = WorldPoint.toLocalInstance(client, colorTile.getWorldPoint());
                    return localWorldPoints.stream().map(wp -> new ColorTileMarker(wp, colorTile.getColor(), colorTile.getLabel()));
                })
                .collect(Collectors.toList());
    }
}

package com.groundMarkerProfiles;

import javax.swing.border.TitledBorder;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.LineBorder;
import java.awt.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;


public class GroundMarkerProfilesSidePanel extends PluginPanel
{
    private static final Logger log = LoggerFactory.getLogger(GroundMarkerProfilesSidePanel.class);
    private final GroundMarkerProfilesPlugin plugin;
    private final GroundMarkerProfilesConfig config;

    JButton buttonTiles0 = new JButton();
    JButton buttonTiles1 = new JButton();
    JButton buttonTiles2 = new JButton();
    JButton buttonTiles3 = new JButton();
    JButton buttonTiles4 = new JButton();
    JButton buttonTiles5 = new JButton();
    JButton buttonTiles6 = new JButton();
    JButton buttonTiles7 = new JButton();
    JButton buttonTiles8 = new JButton();
    JButton buttonTiles9 = new JButton();

    ArrayList<JButton> buttonTilesList = new ArrayList<>(
            Arrays.asList(
                    buttonTiles0, buttonTiles1, buttonTiles2, buttonTiles3, buttonTiles4,
                    buttonTiles5, buttonTiles6, buttonTiles7, buttonTiles8, buttonTiles9
            )
    );

    ArrayList<String> buttonNames = new ArrayList<>();

    @Inject
    GroundMarkerProfilesSidePanel(GroundMarkerProfilesPlugin plugin, GroundMarkerProfilesConfig config)
    {
        this.config = config;
        this.plugin = plugin;

        Collections.addAll(buttonNames,
                config.nameProfile0(), config.nameProfile1(), config.nameProfile2(), config.nameProfile3(), config.nameProfile4(),
                config.nameProfile5(), config.nameProfile6(), config.nameProfile7(), config.nameProfile8(), config.nameProfile9()
        );
    }

    public void startPanel() {
        getParent().setLayout(new BorderLayout());
        getParent().add(this, BorderLayout.CENTER);
        setLayout(new BorderLayout());
        setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        setBackground(ColorScheme.DARK_GRAY_COLOR);

        final JPanel layout = new JPanel();
        BoxLayout boxLayout = new BoxLayout(layout, BoxLayout.Y_AXIS);
        layout.setLayout(boxLayout);
        add(layout, BorderLayout.NORTH);

        layout.add(Box.createRigidArea(new Dimension(0, 15)));
        JPanel frame = createFrame();
        layout.add(frame);
    }

    public void updateButtonName(Integer index, String text) {
        buttonTilesList.get(index).setText(text);
    }

    private JPanel createFrame() {
        JPanel swapsFrame = new JPanel();
        swapsFrame.setLayout(new GridLayout(5, 2));
        TitledBorder border = BorderFactory.createTitledBorder(new LineBorder(Color.BLACK), "Ground Marker Profiles");
        swapsFrame.setBorder(border);

        for (int i = 0; i < buttonTilesList.size(); i++) {
            buttonTilesList.get(i).setText(buttonNames.get(i));
            buttonTilesList.get(i).setPreferredSize(new Dimension(40, 40));
            buttonTilesList.get(i).setFocusable(false);
            buttonTilesList.get(i).setBackground(ColorScheme.DARKER_GRAY_COLOR);
            buttonTilesList.get(i).setForeground(Color.GRAY);

            final int index = i;

            buttonTilesList.get(i).addActionListener(e -> _configureMarker(index));

            swapsFrame.add(buttonTilesList.get(i));
        }

        // default is set to 1000 for this field so that no button is selected initially
        if (config.previousMarkerProfile() < buttonTilesList.size()) {
            _configureMarker(config.previousMarkerProfile());
        }

        return swapsFrame;
    }

    private void _configureMarker(Integer index) {
        _resetProfileSelection();
        plugin.profileSwapper.setActiveProfileIndex(index);
        buttonTilesList.get(index).setForeground(Color.WHITE);
        config.setPreviousMarkerProfile(index);
    }

    private void _resetProfileSelection() {
        for (int i = 0; i < buttonTilesList.size(); i++) {
            buttonTilesList.get(i).setForeground(Color.GRAY);
        }
    }
}
/*
 * Copyright (c) 2018, TheLonelyDev <https://github.com/TheLonelyDev>
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * Copyright (c) 2022, Trevor <https://github.com/TrevorMDev>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.groundMarkerProfiles.ui;

import com.google.common.base.Strings;
import com.groundMarkerProfiles.PointManager;
import com.groundMarkerProfiles.GroundMarkerProfilesConfig;
import com.groundMarkerProfiles.data.ColorTileMarker;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.*;

import javax.annotation.Nullable;
import javax.inject.Inject;
import java.awt.*;

/**
 * Manages the drawing of the markers on ground
 */
public class GroundMarkerOverlay extends Overlay {
    private static final int MAX_DRAW_DISTANCE = 32;

    private final PointManager pointManager;
    private final Client client;
    private final GroundMarkerProfilesConfig config;

    @Inject
    public GroundMarkerOverlay(PointManager pointManager, Client client, GroundMarkerProfilesConfig config) {
        this.pointManager = pointManager;
        this.client = client;
        this.config = config;
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(OverlayPriority.LOW);
        setLayer(OverlayLayer.ABOVE_SCENE);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (pointManager.getPoints().isEmpty()) {
            return null;
        }

        Stroke stroke = new BasicStroke((float) 2.0);
        for (final ColorTileMarker point : pointManager.getPoints()) {
            WorldPoint worldPoint = point.getWorldPoint();
            if (worldPoint.getPlane() != client.getPlane()) {
                continue;
            }

            Color tileColor = point.getColor();

            String label = point.getLabel();

            drawTile(graphics, worldPoint, tileColor, label, stroke);
        }

        return null;
    }

    private void drawTile(Graphics2D graphics, WorldPoint point, Color color, @Nullable String label, Stroke borderStroke) {
        WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();

        if (point.distanceTo(playerLocation) >= MAX_DRAW_DISTANCE) {
            return;
        }

        LocalPoint lp = LocalPoint.fromWorld(client, point);
        if (lp == null) {
            return;
        }

        Polygon poly = Perspective.getCanvasTilePoly(client, lp);
        if (poly != null) {
            OverlayUtil.renderPolygon(graphics, poly, color, new Color(0, 0, 0, 0), borderStroke);
        }

        if (!Strings.isNullOrEmpty(label)) {
            Point canvasTextLocation = Perspective.getCanvasTextLocation(client, graphics, lp, label, 0);
            if (canvasTextLocation != null) {
                OverlayUtil.renderTextLocation(graphics, canvasTextLocation, label, color);
            }
        }
    }
}
package com.groundMarkerProfiles;

import lombok.Getter;
import lombok.Setter;

import javax.inject.Inject;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class ProfileSwapper {

    GroundMarkerProfilesPlugin plugin;
    GroundMarkerProfilesConfig config;

    @Getter
    @Setter
    Integer activeProfileIndex;

    private final List<String> tileProfiles = new ArrayList<>();

    @Inject
    protected ProfileSwapper(GroundMarkerProfilesPlugin plugin, GroundMarkerProfilesConfig config) {
        this.plugin = plugin;
        this.config = config;
        this.activeProfileIndex = config.previousMarkerProfile();

        Collections.addAll(tileProfiles,
                config.tilesProfile0(), config.tilesProfile1(), config.tilesProfile2(), config.tilesProfile3(), config.tilesProfile4(),
                config.tilesProfile5(), config.tilesProfile6(), config.tilesProfile7(), config.tilesProfile8(), config.tilesProfile9()
        );
    }

    public void updateTileProfiles() {
        tileProfiles.clear();
        Collections.addAll(tileProfiles,
                config.tilesProfile0(), config.tilesProfile1(), config.tilesProfile2(), config.tilesProfile3(), config.tilesProfile4(),
                config.tilesProfile5(), config.tilesProfile6(), config.tilesProfile7(), config.tilesProfile8(), config.tilesProfile9()
        );
    }

    public String getActiveTileProfile() {
        if (activeProfileIndex < tileProfiles.size()) {
            return tileProfiles.get(activeProfileIndex);
        } else {
            return "";
        }
    }
}

package com.groundMarkerProfiles;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(GroundMarkerProfilesPlugin.class);
		RuneLite.main(args);
	}
}
