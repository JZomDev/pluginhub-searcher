package com.mjhylkema.SlayerTaskSorter;

import com.google.inject.Provides;
import static com.mjhylkema.SlayerTaskSorter.TaskEntry.extractFriendlyName;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ScriptEvent;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.util.Text;

@Slf4j
@PluginDescriptor(
	name = "Slayer Task Sorter"
)
public class SlayerTaskSorterPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private SlayerTaskSorterConfig config;

	@Inject
	ClientThread clientThread;

	private Widget taskListsClickable;
	private Widget taskListsDrawable;
	private Widget taskListFrame;
	private Widget taskListTitle;

	private final static int HEIGHT = 22;

	private final List<TaskEntry> entries = new ArrayList<>();

	@Override
	public void startUp() {
		clientThread.invokeLater(this::initWidgets);
	}

	@Provides
	SlayerTaskSorterConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(SlayerTaskSorterConfig.class);
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event) {
		if (event.getGroupId() == InterfaceID.SLAYER_REWARDS_TASK_LIST) {
			initWidgets();

			if (taskListsDrawable == null || taskListsClickable == null) {
				return;
			}

			sortLater();
		}
	}
	@Subscribe
	public void onConfigChanged(ConfigChanged e)
	{
		switch (e.getKey())
		{
			case SlayerTaskSorterConfig.KEY_ACTIVE_SORT_METHOD:
				reorderSortButton(config.sortingMethod());
				break;
			case SlayerTaskSorterConfig.KEY_REVERSE_SORT:
				sortLater();
				break;
			default:
				return;
		}
	}

	private void sortLater() {

		// Delay sorting to the next game tick after the widget updates
		clientThread.invokeLater(() -> {
			if (taskListsDrawable == null || taskListsClickable == null) {
				return;
			}

			entries.clear();

			Widget[] drawableChildren = taskListsDrawable.getChildren();
			if (drawableChildren == null) {
				return;
			}

			Widget[] clickableChildren = taskListsClickable.getChildren();
			if (clickableChildren == null) {
				return;
			}

			for (int i = 0; i < drawableChildren.length - 3; i++) {
				if (isTaskRow(drawableChildren, i)) {
					String friendlyName = extractFriendlyName(drawableChildren[i].getText());
					entries.add(new TaskEntry(
						this, getClickableWidgetFromName(clickableChildren, friendlyName),
						drawableChildren[i],
						drawableChildren[i + 1],
						drawableChildren[i + 2],
						drawableChildren[i + 3]
					));
				}
			}

			sort();
		});
	}

	private void initWidgets() {
		taskListsDrawable = client.getWidget(InterfaceID.SlayerRewardsTaskList.DRAWABLE);
		taskListsClickable = client.getWidget(InterfaceID.SlayerRewardsTaskList.CLICKABLE);
		taskListFrame = client.getWidget(InterfaceID.SlayerRewardsTaskList.FRAME);

		clientThread.invokeLater(() -> {
			if (taskListFrame == null) {
				return;
			}
			taskListTitle = taskListFrame.getChild(1);

			if (taskListTitle == null) {
				return;
			}

			taskListTitle.setOnOpListener((JavaScriptCallback) this::handleSortButtonOp);
			taskListTitle.setHasListener(true);
			reorderSortButton(config.sortingMethod());
			taskListTitle.revalidate();
		});
	}

	private Widget getClickableWidgetFromName(Widget[] clickableWidgets, String name) {
		for (Widget widget : clickableWidgets) {
			if (Text.removeTags(widget.getName()).equals(name)) {
				return widget;
			}
		}
		return null;
	}

	private boolean isTaskRow(Widget[] widgets, int index) {
		return (widgets[index].getType() == 4 && widgets[index].getText() != null) &&
				widgets[index + 1].getType() == 3 &&
				widgets[index + 2].getType() == 5 &&
			   (widgets[index + 3].getType() == 4 && widgets[index + 3].getText() != null);
	}

	private void sort() {
		Comparator<TaskEntry> comparator = null;
		switch (config.sortingMethod()) {
			case SORT_BY_NAME:
				comparator = Comparator.comparing(TaskEntry::getFriendlyName, config.reverseSort()
					? Comparator.nullsLast(Comparator.reverseOrder())   // ascending
					: Comparator.nullsLast(Comparator.naturalOrder())   // descending
					);
				break;
			case SORT_BY_WEIGHTING:
				comparator = Comparator.comparing(TaskEntry::getWeighting, config.reverseSort()
					? Comparator.nullsLast(Comparator.naturalOrder())   // ascending
					: Comparator.nullsLast(Comparator.reverseOrder())   // descending
					)
					.thenComparing(entry -> entry.getStatus().getSortOrder())
					.thenComparing(TaskEntry::getFriendlyName);
				break;
		}

		if (comparator != null) {
			entries.sort(comparator);
		}

		for (int i = 0; i < entries.size(); i++) {
			entries.get(i).setOriginalYAndRevalidate(HEIGHT * i);
		}
	}

	private void handleSortButtonOp(ScriptEvent event) {
		// Special case for first index - reverse sort order
		if (event.getOp() == 1) {
			config.setReverseOrder(!config.reverseSort());
			sortLater();
			return;
		}
		for (SortMethod method : SortMethod.values()) {
			if (method.actionIndex == event.getOp()) {
				config.setSortingMethod(method);
				reorderSortButton(method);
				return;
			}
		}
	}

	private void reorderSortButton(SortMethod firstMethod) {
		int index = 0;
		taskListTitle.setAction(index, "Reverse sort order");
		firstMethod.actionIndex = 1;
		for (SortMethod method : SortMethod.values()) {
			if (method != firstMethod) {
				taskListTitle.setAction(++index, method.name);
				method.actionIndex = index + 1;
			}
		}
		sortLater();
	}
}

package com.mjhylkema.SlayerTaskSorter;

public enum TaskStatus {
	AVAILABLE("Available", 2848, 1),
	BLOCKED("Blocked", 6412, 2),
	UNAVAILABLE("Cannot Assign", 6411, 3),
	CURRENT("Current Task", 6413, 4);

	private final String description;
	private final int id;
	private final int sortOrder;

	TaskStatus(String description, int id, int sortOrder) {
		this.description = description;
		this.id = id;
		this.sortOrder = sortOrder;
	}

	public String getDescription() {
		return description;
	}

	public int getId() {
		return id;
	}

	public int getSortOrder() {
		return sortOrder;
	}

	public static TaskStatus fromId(int id) {
		for (TaskStatus status : values()) {
			if (status.getId() == id) {
				return status;
			}
		}
		throw new IllegalArgumentException("No TaskStatus with id: " + id);
	}
}

package com.mjhylkema.SlayerTaskSorter;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("slayerTaskSorter")
public interface SlayerTaskSorterConfig extends Config
{
	static String KEY_ACTIVE_SORT_METHOD = "activeSortMethod";
	static String KEY_REVERSE_SORT = "reverseSort";

	@ConfigItem(
		keyName = KEY_ACTIVE_SORT_METHOD,
		name = "Sort by",
		description = "The active sort method that's used for sorting slayer tasks"
	)
	default SortMethod sortingMethod() {
		return SortMethod.SORT_BY_WEIGHTING;
	}

	@ConfigItem(
		keyName = KEY_ACTIVE_SORT_METHOD,
		name = "",
		description = ""
	)
	void setSortingMethod(SortMethod sortMethod);


	@ConfigItem(
		keyName = KEY_REVERSE_SORT,
		name = "Reverse sort order",
		description = "Reverse the sort method"
	)
	default boolean reverseSort() {
		return false;
	}

	@ConfigItem(
		keyName = KEY_REVERSE_SORT,
		name = "",
		description = ""
	)
	void setReverseOrder(boolean value);
}

package com.mjhylkema.SlayerTaskSorter;

public enum SortMethod {
	SORT_BY_NAME("Sort by name"),
	SORT_BY_WEIGHTING("Sort by weighting");

	String name;
	int actionIndex = -1;

	SortMethod(String name) {
		this.name = name;
	}

}

package com.mjhylkema.SlayerTaskSorter;

import net.runelite.api.widgets.Widget;

public class TaskEntry
{
	SlayerTaskSorterPlugin plugin;
	Widget clickable;
	Widget text;
	Widget item;
	Widget icon;
	Widget percent;

	String friendlyName;
	Double weighting;
	TaskStatus status;

	private static int ICON_OFFSET = 2;

	public TaskEntry(SlayerTaskSorterPlugin plugin, Widget clickable, Widget text, Widget item, Widget icon, Widget percent) {
		this.plugin = plugin;
		this.clickable = clickable;
		this.text = text;
		this.item = item;
		this.icon = icon;
		this.percent = percent;

		friendlyName = extractFriendlyName(this.text.getText());
		weighting = extractPercentage(this.percent.getText());
		status = TaskStatus.fromId(icon.getSpriteId());

		icon.setName(status.getDescription());
		icon.setAction(0, "TEST");
		icon.revalidate();
	}

	public static String extractFriendlyName(String nameWithCount)
	{
		if (nameWithCount == null)
			return null;

		int index = nameWithCount.indexOf("(");

		if (index == -1)
			return nameWithCount.trim();

		return nameWithCount.substring(0, index).trim();
	}

	public static double extractPercentage(String input) {
		if (input == null || !input.endsWith("%")) {
			throw new IllegalArgumentException("Input must be a percentage string like '3.3%'");
		}
		String numericPart = input.replace("%", "").trim();
		return Double.parseDouble(numericPart);
	}

	public String getFriendlyName() {
		return this.friendlyName;
	}

	public Double getWeighting() {
		return this.weighting;
	}

	public TaskStatus getStatus() {
		return this.status;
	}

	public void setOriginalYAndRevalidate(int y) {
		if (clickable != null) {
			clickable.setOriginalY(y);
			clickable.revalidate();
		}
		text.setOriginalY(y);
		text.revalidate();
		item.setOriginalY(y);
		item.revalidate();
		icon.setOriginalY(y + ICON_OFFSET);
		icon.revalidate();
		percent.setOriginalY(y);
		percent.revalidate();
	}
}

package com.mjhylkema.SlayerTaskSorter;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class SlayerTasksSorterTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(SlayerTaskSorterPlugin.class);
		RuneLite.main(args);
	}
}
