package nl.alowaniak.runelite.musicreplacer;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class MusicReplacerPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(MusicReplacerPlugin.class);
		RuneLite.main(args);
	}
}
package nl.alowaniak.runelite.musicreplacer;

import com.google.common.primitives.Ints;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.MenuOpened;
import net.runelite.api.events.VarClientIntChanged;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetID;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.chatbox.ChatboxPanelManager;
import net.runelite.client.game.chatbox.ChatboxTextMenuInput;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import javax.swing.filechooser.FileFilter;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.time.Duration;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.stream.Stream;

import static net.runelite.http.api.RuneLiteAPI.GSON;
import static nl.alowaniak.runelite.musicreplacer.MusicReplacerConfig.CONFIG_GROUP;
import static nl.alowaniak.runelite.musicreplacer.MusicReplacerPlugin.CURRENTLY_PLAYING_WIDGET_ID;
import static nl.alowaniak.runelite.musicreplacer.Tracks.OVERRIDE_CONFIG_KEY_PREFIX;

@Slf4j
@Singleton
class TracksOverridesUi
{
	public static final int PAGE_SIZE = 4;

	public static final int OVERRIDE_FONT = FontID.BOLD_12;
	public static final int NORMAL_FONT = FontID.PLAIN_12;

	public static final int RESIZABLE_VIEWPORT_BOTTOM_LINE_MUSIC_TAB_ID = 10747946;

	@Inject
	private Client client;
	@Inject
	private ClientThread clientThread;
	@Inject
	private TooltipManager tooltipManager;
	@Inject
	private ChatboxPanelManager chatboxPanelManager;

	@Inject
	private Tracks tracks;
	@Inject
	private YouTubeSearcher ytSearcher;

	private String lastPlayingTrack;
	private boolean overrideWidgetsOutdated = true;

	@Subscribe
	public void onGameTick(GameTick tick)
	{
		Widget playingTrackWidget = client.getWidget(WidgetID.MUSIC_GROUP_ID, CURRENTLY_PLAYING_WIDGET_ID);
		if (playingTrackWidget == null) return;

		String playingTrack = playingTrackWidget.getText();
		if (!playingTrack.equals(lastPlayingTrack))
		{
			lastPlayingTrack = playingTrack;
			updateCurrentlyPlayingWidget();
		}

		if (overrideWidgetsOutdated)
		{
			updateOverridesInTrackList();
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged)
	{
		String key = configChanged.getKey();
		if (CONFIG_GROUP.equals(configChanged.getGroup()) && key.startsWith(OVERRIDE_CONFIG_KEY_PREFIX))
		{
			overrideWidgetsOutdated = true;
			if (key.contains(lastPlayingTrack))
			{
				updateCurrentlyPlayingWidget();
			}
		}
	}

	@Subscribe
	public void onVarClientIntChanged(VarClientIntChanged varClientIntChanged)
	{
		if (varClientIntChanged.getIndex() == VarClientInt.INVENTORY_TAB && isOnMusicTab())
		{
			// The widgets could be outdated, just ensure it's updated whenever we go to the music tab
			// TODO figure out better way of ensuring the tracklist is up to date
			overrideWidgetsOutdated = true;
		}
	}

	private boolean isOnMusicTab()
	{
		return client.getVarcIntValue(VarClientInt.INVENTORY_TAB) == 13;
	}

	@Subscribe
	public void onMenuOpened(final MenuOpened event)
	{
		final MenuEntry entry = event.getFirstEntry();
		if (entry == null) return;

		int widgetId = entry.getParam1();
		if (widgetId == WidgetInfo.MUSIC_TRACK_LIST.getId())
		{
			String trackName = Text.removeTags(entry.getTarget());
			addMenuEntry("Override", entry).onClick(e ->
				chatboxPanelManager.openTextMenuInput("How would you like to override " + trackName + "?")
				.option("With a local file.", () -> overrideByLocal(trackName))
				.option("From a youtube search.", () -> overrideBySearch(trackName))
				.build()
			);

			if (tracks.getOverride(trackName) != null)
			{
				addMenuEntry("Remove override", entry).onClick(e -> tracks.removeOverride(trackName));
			}
		}
		else if (widgetId == WidgetInfo.FIXED_VIEWPORT_MUSIC_TAB.getId()
				|| widgetId == WidgetInfo.RESIZABLE_VIEWPORT_MUSIC_TAB.getId()
				|| widgetId == RESIZABLE_VIEWPORT_BOTTOM_LINE_MUSIC_TAB_ID)
		{
			if (!tracks.overriddenTracks().isEmpty())
			{
				addMenuEntry("Remove overrides", entry).onClick(e -> tracks.removeAllOverrides());
			}

			addMenuEntry("Override tracks", entry).onClick(e ->
				chatboxPanelManager.openTextMenuInput("How would you like to bulk override?")
						.option("From preset", choosePresetForBulkOverride)
						.option("From directory", () -> SwingUtilities.invokeLater(chooseDirectoryForBulkOverride))
						.build()
			);
		}
	}

	private final Runnable choosePresetForBulkOverride =  () -> {
		try (InputStreamReader reader = new InputStreamReader(getClass().getResourceAsStream("/presets.json"))) {
			ChatboxTextMenuInput input = chatboxPanelManager.openTextMenuInput("Which preset? (This will download ALL overridden tracks!)");
			List<Preset> presets = GSON.fromJson(reader, Preset.LIST_TYPE.getType());
			presets.forEach(preset -> input.option(preset.getName(), () -> tracks.bulkCreateOverride(preset)));
			input.build();
		} catch (NullPointerException | IOException ex) {
			log.warn("Something went wrong when reading presets.", ex);
		}
	};

	private final Runnable chooseDirectoryForBulkOverride = () -> {
		JFileChooser fileChooser = new JFileChooser();
		fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
		fileChooser.setMultiSelectionEnabled(false);
		int status = fileChooser.showOpenDialog(client.getCanvas());
		if (status == JFileChooser.APPROVE_OPTION) {
			tracks.bulkCreateOverride(fileChooser.getSelectedFile().toPath());
		}
	};

	private MenuEntry addMenuEntry(String option, MenuEntry entryForCopy)
	{
		return client.createMenuEntry(-1)
			.setOption(option)
			.setTarget(entryForCopy.getTarget())
			.setType(MenuAction.RUNELITE)
			.setParam0(entryForCopy.getParam0())
			.setParam1(entryForCopy.getParam1())
			.setIdentifier(entryForCopy.getIdentifier());
	}

	private void overrideByLocal(String trackName)
	{
		SwingUtilities.invokeLater(() -> {
			JFileChooser fileChooser = new JFileChooser();
			fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
			fileChooser.setMultiSelectionEnabled(false);
			fileChooser.setFileFilter(new FileFilter() {
				@Override
				public boolean accept(File f) {
					return f.isDirectory() || MusicPlayer.PLAYER_PER_EXT.keySet().stream().anyMatch(ext -> f.getName().endsWith(ext));
				}

				@Override
				public String getDescription() {
					return "Supported audio files";
				}
			});
			int status = fileChooser.showOpenDialog(client.getCanvas());
			if (status == JFileChooser.APPROVE_OPTION) {
				tracks.createOverride(trackName, fileChooser.getSelectedFile().toPath());
			}
		});
	}

	private void overrideBySearch(String trackName)
	{
		chatboxPanelManager.openTextInput("Enter your search criteria for " + trackName)
				.value(trackName)
				.onDone((String s) -> ytSearcher.search(s, hits -> paginateSearch(trackName, hits)))
				.build();
	}

	private void paginateSearch(String trackName, List<SearchResult> hits)
	{
		ChatboxTextMenuInput chooser = chatboxPanelManager.openTextMenuInput("Choose which you want to use as override for " + trackName);

		int pageSize = PAGE_SIZE + (PAGE_SIZE + 1 == hits.size() ? 1 : 0);

		hits.stream().limit(pageSize).forEach(hit ->
			chooser.option(
				hit.getName() + " " + Duration.ofSeconds(hit.getDuration()).toString().substring(2) + " " + hit.getUploader(),
				() -> tracks.createOverride(trackName, hit)
			)
		);

		List<SearchResult> remainingHits = hits.subList(Math.min(hits.size(), pageSize), hits.size());
		if (!remainingHits.isEmpty()) chooser.option("Continue", () -> paginateSearch(trackName, remainingHits));

		chooser.build();
	}

	private void updateOverridesInTrackList()
	{
		clientThread.invoke(() ->
		{
			Widget trackList = client.getWidget(WidgetInfo.MUSIC_TRACK_LIST);
			if (trackList == null) return;
			for (Widget e : trackList.getDynamicChildren())
			{
				e.setFontId(tracks.overrideExists(e.getText()) ? OVERRIDE_FONT : NORMAL_FONT);
				e.revalidate();
			}
		});
	}

	private void updateCurrentlyPlayingWidget()
	{
		clientThread.invoke(() ->
		{
			Widget trackPlayingWidget = client.getWidget(WidgetID.MUSIC_GROUP_ID, CURRENTLY_PLAYING_WIDGET_ID);
			if (trackPlayingWidget == null) return;

			trackPlayingWidget.setOnClickListener((JavaScriptCallback) e -> scrollToTrack(e.getSource().getText()));
			trackPlayingWidget.setHasListener(true);

			TrackOverride override = tracks.getOverride(trackPlayingWidget.getText());
			if (override != null)
			{
				trackPlayingWidget.setFontId(OVERRIDE_FONT);

				String origin = truncate(override.getOriginalPath(), 40);

				StringBuilder tooltipTxt = new StringBuilder("From: " + origin + "</br>");
				override.getAdditionalInfo().entrySet().stream()
						.sorted(Map.Entry.comparingByKey(Comparator.comparing(String::length).thenComparing(String::compareTo)))
						.forEach(e -> tooltipTxt.append(e.getKey()).append(": ").append(e.getValue()).append("</br>"));
				Tooltip tooltip = new Tooltip(tooltipTxt.toString());

				trackPlayingWidget.setOnMouseRepeatListener((JavaScriptCallback) e ->
				{
					if (!tooltipManager.getTooltips().contains(tooltip)) tooltipManager.add(tooltip);
				});
			}
			else
			{
				trackPlayingWidget.setOnMouseRepeatListener((Object[]) null);
				trackPlayingWidget.setFontId(NORMAL_FONT);
			}
		});
	}

	private void scrollToTrack(String name)
	{
		Widget track = findTrackWidget(name);
		if (track == null) return;

		Widget scrollContainer = client.getWidget(WidgetInfo.MUSIC_TRACK_SCROLL_CONTAINER);
		if (scrollContainer == null) return;

		int centralY = track.getRelativeY() + track.getHeight() / 2;

		int newScroll = Ints.constrainToRange(
			centralY - scrollContainer.getHeight() / 2,
			0, scrollContainer.getScrollHeight()
		);

		client.runScript(
			ScriptID.UPDATE_SCROLLBAR,
			WidgetInfo.MUSIC_TRACK_SCROLLBAR.getId(),
			WidgetInfo.MUSIC_TRACK_SCROLL_CONTAINER.getId(),
			newScroll
		);
	}

	private Widget findTrackWidget(String name) {
		Widget trackList = client.getWidget(WidgetInfo.MUSIC_TRACK_LIST);
		if (trackList == null) return null;

		return Stream.of(trackList.getDynamicChildren())
				.filter(w -> name.equals(w.getText()))
				.findAny().orElse(null);
	}

	private void clearCurrentlyPlayingWidget()
	{
		clientThread.invoke(() ->
		{
			Widget trackPlayingWidget = client.getWidget(WidgetID.MUSIC_GROUP_ID, CURRENTLY_PLAYING_WIDGET_ID);
			if (trackPlayingWidget == null) return;

			trackPlayingWidget.setFontId(NORMAL_FONT);

			trackPlayingWidget.setOnClickListener((Object[]) null);
			trackPlayingWidget.setOnMouseRepeatListener((Object[]) null);
			trackPlayingWidget.setHasListener(false);
		});
	}

	public void shutdown()
	{
		overrideWidgetsOutdated = true;
		lastPlayingTrack = null;
		clientThread.invoke(() ->
		{
			Widget trackList = client.getWidget(WidgetInfo.MUSIC_TRACK_LIST);
			if (trackList == null) return;
			for (Widget e : trackList.getDynamicChildren())
			{
				e.setFontId(NORMAL_FONT);
				e.revalidate();
			}
		});
		clearCurrentlyPlayingWidget();
	}

	private static String truncate(String s, int length)
	{
		return s.length() <= length ? s : s.substring(0, length / 2 - 2) + " .. " + s.substring(s.length() - (length / 2 - 2));
	}
}

package nl.alowaniak.runelite.musicreplacer;

import com.adonax.audiocue.AudioCue;
import com.google.common.collect.ImmutableMap;
import jaco.mp3.player.MP3Player;
import lombok.SneakyThrows;
import org.slf4j.LoggerFactory;

import javax.swing.*;
import java.io.File;
import java.net.URI;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.util.Map;
import java.util.function.Function;

public interface MusicPlayer {

    static void preloadNecessaries() {
        // Jaco's MP3Player does some init that needs to happen on the UI thread
        SwingUtilities.invokeLater(JacoPlayer.player::toString);
    }

    ImmutableMap<String, Function<URI, MusicPlayer>> PLAYER_PER_EXT = ImmutableMap.of(
            ".mp3", JacoPlayer::new,
            ".wav", AudioCuePlayer::new
    );

    static MusicPlayer create(URI media)
    {
        for (Map.Entry<String, Function<URI, MusicPlayer>> extAndPlayer : PLAYER_PER_EXT.entrySet()) {
            if (media.getPath().endsWith(extAndPlayer.getKey()))
                try {
                    return extAndPlayer.getValue().apply(media);
                } catch (Exception e) {
                    LoggerFactory.getLogger(MusicPlayer.class).warn("Couldn't load player for " + media, e);
                }
        }
        return null;
    }

    void play();

    boolean isPlaying();

    void setVolume(double volume);

    default void close() {}

    class JacoPlayer implements MusicPlayer {

        public static final MP3Player player = new MP3Player();
        private final File tempPlayFile; // A hacky solution for overriding/deleting current playing song

        @SneakyThrows
        public JacoPlayer(URI mediaFile) {
            player.getPlayList().clear();
            tempPlayFile = File.createTempFile("tmpJacoPlayfile", ".mp3");
            tempPlayFile.deleteOnExit();
            Files.copy(new File(mediaFile).toPath(), tempPlayFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
            player.add(tempPlayFile);
        }

        @Override
        public void play() {
            player.play();
        }

        @Override
        public boolean isPlaying() {
            return player.isPlaying();
        }

        @Override
        public void setVolume(double volume) {
            int intVol = (int) (volume * 100);
            if (volume > 0 && intVol == 0) intVol = 1;
            player.setVolume(intVol);
        }

        @Override
        public void close() {
            player.stop();
            tempPlayFile.delete();
        }
    }

    class AudioCuePlayer implements MusicPlayer
    {
        // Same hacky solution as JaCo even though it shouldn't happen here cause audiocue fully loads in memory
        private final File tempPlayFile;
        private final AudioCue audioCue;

        @SneakyThrows
        private AudioCuePlayer(URI media)
        {
            tempPlayFile = File.createTempFile("tmpJacoPlayfile", ".mp3");
            tempPlayFile.deleteOnExit();
            Files.copy(new File(media).toPath(), tempPlayFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
            audioCue = AudioCue.makeStereoCue(tempPlayFile.toURL(), 1);
            audioCue.open();
        }

        @Override
        public void play()
        {
            if (audioCue.getIsActive(0)) audioCue.releaseInstance(0);
            audioCue.play();
        }

        @Override
        public boolean isPlaying()
        {
            return audioCue.getIsActive(0);
        }

        @Override
        public void setVolume(double volume)
        {
            audioCue.setVolume(0, volume);
        }

        @Override
        public void close()
        {
            tempPlayFile.delete();
            audioCue.close();
        }
    }
}

package nl.alowaniak.runelite.musicreplacer;

import lombok.extern.slf4j.Slf4j;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Singleton;
import java.io.IOException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;

import static net.runelite.http.api.RuneLiteAPI.GSON;
import static nl.alowaniak.runelite.musicreplacer.MusicReplacerPlugin.MUSIC_REPLACER_API;

@Slf4j
@Singleton
class YouTubeSearcher
{

    @Inject
	private OkHttpClient http;
	@Inject
	@Named(MusicReplacerPlugin.MUSIC_REPLACER_EXECUTOR)
	private ExecutorService executor;

	/**
	 * @param term the {@code term} to search for.
	 * @param resultCollector will be called with the found results.
	 */
	public void search(String term, Consumer<List<SearchResult>> resultCollector)
	{
		executor.submit(() -> resultCollector.accept(getSearchResults(term)));
	}

    private List<SearchResult> getSearchResults(String term) {
        try (Response res = getSearchResponse(term))
        {
            if (!res.isSuccessful()) throw new IOException(res.code() + ": " + res.message() + " " + res.body().string());

            return GSON.fromJson(res.body().string(), SearchResult.LIST_TYPE.getType());
        }
        catch (IOException e)
        {
            log.warn("Something went wrong when searching for " + term, e);
            return Collections.emptyList();
        }
    }

    private Response getSearchResponse(String term) throws IOException {
        return http.newBuilder().readTimeout(1, TimeUnit.MINUTES)
            .build()
            .newCall(new Request.Builder()
                .url(MUSIC_REPLACER_API + "search/" + URLEncoder.encode(term, StandardCharsets.UTF_8.toString()))
                .build()
            ).execute();
    }
}

package nl.alowaniak.runelite.musicreplacer;

import com.google.common.collect.ImmutableMap;
import lombok.Getter;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.EnumID;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;

import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Singleton;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.time.Duration;
import java.util.Arrays;
import java.util.List;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.concurrent.ExecutorService;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static net.runelite.http.api.RuneLiteAPI.GSON;
import static nl.alowaniak.runelite.musicreplacer.MusicReplacerConfig.CONFIG_GROUP;
import static nl.alowaniak.runelite.musicreplacer.MusicReplacerPlugin.MUSIC_REPLACER_API;

/**
 * Provides access to all OSRS track names as well as all {@link TrackOverride overridden tracks}.
 */
@Slf4j
@Singleton
class Tracks
{
	static final File MUSIC_OVERRIDES_DIR = new File(RuneLite.RUNELITE_DIR, "music-replacer");
	{ // Not static initializer, if we fail we only want to fail loading our plugin
		if (!MUSIC_OVERRIDES_DIR.exists() && !MUSIC_OVERRIDES_DIR.mkdirs())
		{
			throw new IllegalStateException("Failed to create " + MUSIC_OVERRIDES_DIR);
		}
	}

	public static final String OVERRIDE_CONFIG_KEY_PREFIX = "track_";
	public static final String FULL_OVERRIDE_CONFIG_KEY_PREFIX = CONFIG_GROUP + '.' + OVERRIDE_CONFIG_KEY_PREFIX;

	@Inject
	private ConfigManager configMgr;
	@Inject
	private MusicReplacerConfig config;
	@Inject
	private MusicReplacerPlugin musicReplacer;
	@Inject
	@Named(MusicReplacerPlugin.MUSIC_REPLACER_EXECUTOR)
	private ExecutorService executor;

	/**
	 * @return whether or not given {@code name} exists as a {@link TrackOverride}
	 */
	public boolean overrideExists(String name)
	{
		return configMgr.getConfiguration(CONFIG_GROUP, OVERRIDE_CONFIG_KEY_PREFIX + name) != null;
	}

	public List<String> overriddenTracks()
	{
		return configMgr.getConfigurationKeys(CONFIG_GROUP).stream()
			.filter(e -> e.startsWith(FULL_OVERRIDE_CONFIG_KEY_PREFIX))
			.map(e -> e.replace(FULL_OVERRIDE_CONFIG_KEY_PREFIX, ""))
			.collect(Collectors.toList());
	}

	/**
	 * Bulk creates overrides assuming {@code dir} contains audio files with exact same names as tracks
	 */
	public void bulkCreateOverride(Path dirPath)
	{
		@Value class PathAndFilename {
			Path path;
			@Getter(lazy = true) String filename = path.getFileName().toString().replaceAll("\\..+$", "");
		}
		executor.submit(() ->
		{
			musicReplacer.chatMsg("Overriding with tracks in " + dirPath + ".");
			try (Stream<Path> ls = Files.list(dirPath))
			{
				ls.map(e -> new PathAndFilename(e))
						// Ideally we filtered only files with an osrs track name, but music track enum is removed, let place responsibility on user
						.forEach(e -> {
							if (!config.skipAlreadyOverriddenWhenBulkOverride() || !overrideExists(e.getFilename())) {
								createOverride(e.getFilename(), e.getPath());
							} else {
								musicReplacer.chatMsg("Skipping " + e.getFilename() + ", already overridden.");
							}
						});
			}
			catch (IOException e)
			{
				log.warn("Error opening `" + dirPath + "` for bulk override.", e);
			}
			musicReplacer.chatMsg("Done overriding.");
		});
	}

    public void createOverride(String name, Path path)
	{
		createOverride(new TrackOverride(name, path.toString(), true, ImmutableMap.of()));
	}

	public void bulkCreateOverride(Preset preset) {
		musicReplacer.chatMsg(
				"Downloading " + preset.getTracks().size() + " tracks, won't dl all if RL closes prematurely.",
				preset.getCredits()
		);
		preset.getTracks().forEach((name, override) -> {
			if (!config.skipAlreadyOverriddenWhenBulkOverride() || !overrideExists(name)) {
				createOverride(name, override);
			} else {
				musicReplacer.chatMsg("Skipping " + name + ", already overridden.");
			}
		});
		executor.submit(() -> musicReplacer.chatMsg("Finished downloading preset " + preset.getName() + ".", preset.getCredits()));
	}

	public void createOverride(String trackName, SearchResult hit)
	{
		executor.submit(() -> createOverride(
			new TrackOverride(trackName, hit.id, false,
				ImmutableMap.of(
				"Name", hit.getName(),
				"Duration", Duration.ofSeconds(hit.getDuration()).toString(),
				"Uploader", hit.getUploader()
				)
			)
		));
	}

	private void createOverride(TrackOverride override)
	{
		Path overridePath = transfer(override);
		if (overridePath != null)
		{
			// Ensure we only keep the current override transferred file
			override.getPaths()
					.filter(e -> !e.equals(overridePath))
					.forEach(path -> {
						try {
							Files.deleteIfExists(path);
						} catch (IOException e) {
							log.warn("Couldn't delete " + path, e);
						}
					});

			configMgr.setConfiguration(CONFIG_GROUP, OVERRIDE_CONFIG_KEY_PREFIX + override.getName(), GSON.toJson(override));
			musicReplacer.chatMsg(override.isFromLocal()
							? "Overridden " + override.getName()
							: "Overridden " + override.getName() + ", uploaded by " + override.getAdditionalInfo().get("Uploader")
			);
		} else {
			musicReplacer.chatMsg("Failed to override " + override.getName() + ", check the logs.");
		}
	}

	public TrackOverride getOverride(String name)
	{
		TrackOverride override = GSON.fromJson(
			configMgr.getConfiguration(CONFIG_GROUP, OVERRIDE_CONFIG_KEY_PREFIX + name),
			TrackOverride.class
		);

		if (override == null || override.getPaths().anyMatch(Files::exists))
		{
			return override;
		}
		else
		{
			log.warn("Deleting: " + override + " because there was no override file for it.");
			configMgr.unsetConfiguration(CONFIG_GROUP, OVERRIDE_CONFIG_KEY_PREFIX + name);
			return null;
		}
	}

	/**
	 * Clears all overridden tracks.
	 */
	public void removeAllOverrides()
	{
		executor.submit(() -> overriddenTracks().forEach(this::removeOverride));
	}

	public void removeOverride(String name) {
		TrackOverride override = getOverride(name);
		if (override == null) return;

		configMgr.unsetConfiguration(CONFIG_GROUP, OVERRIDE_CONFIG_KEY_PREFIX + name);
		override.getPaths().forEach(overridePath -> {
			try {
				Files.deleteIfExists(overridePath);
			} catch (IOException e) {
				log.warn("Couldn't delete " + name, e);
			}
		});
	}

	private Path transfer(TrackOverride override)
	{
		return override.isFromLocal()
			? transferLocal(override)
			: transferLink(override);
	}

	private Path transferLocal(TrackOverride override)
	{
		Path path = Paths.get(override.getOriginalPath());
		Path targetPath = override.getPaths()
				.filter(e -> extensionOf(path).equals(extensionOf(e)))
				.findFirst().orElse(null);

		if (targetPath == null)
		{
			log.warn("Can only load " + MusicPlayer.PLAYER_PER_EXT.keySet() + " files. " + override);
			return null;
		}

		try
		{
			Files.copy(path, targetPath, StandardCopyOption.REPLACE_EXISTING);
			return targetPath;
		} catch (IOException e)
		{
			log.warn("Something went wrong when copying " + override, e);
			return null;
		}
	}

	private String extensionOf(Path p) {
		String fileName = p.getFileName().toString();
		return fileName.substring(fileName.lastIndexOf('.'));
	}

	private Path transferLink(TrackOverride override)
	{
		Path targetPath = override.getPaths().findFirst().orElseThrow(IllegalStateException::new);

		String dlUrl = MUSIC_REPLACER_API + "download/" + override.getOriginalPath() + "?ext=" + extensionOf(targetPath);
		try (InputStream is = new URL(dlUrl).openStream())
		{
			Files.copy(is, targetPath, StandardCopyOption.REPLACE_EXISTING);
			return targetPath;
		}
		catch (IOException e)
		{
			log.warn("Something went wrong when downloading for " + override, e);
			return null;
		}
	}
}

package nl.alowaniak.runelite.musicreplacer;

import java.nio.file.Path;
import java.util.Map;
import java.util.stream.Stream;

import lombok.Value;

/*
 * Ideally this class is refactored a bunch.
 * But such a refactor will likely break already existing overrides + not sure what the best design would be.
 *
 * Things that aren't too clean:
 * 	originalPath when downloaded
 *  fromLocal which could be deduced (or maybe have a hierarchy LocalOverride/RemoteOverride)
 *  coupling of name to path and not knowing it's extension (which is requiring nasty workarounds)
 */
@Value
class TrackOverride
{
	String name;
	/**
	 * The originalPath for a local override or the {@link SearchResult#id} for downloads
	 */
	String originalPath;
	boolean fromLocal;
	Map<String, String> additionalInfo;

	/**
	 * Multiple possibilities because extension is unknown.
	 *
	 * @return the possible paths of the overridden tracks in most favouring first.
	 */
	public Stream<Path> getPaths()
	{
		return MusicPlayer.PLAYER_PER_EXT.keySet().stream().map(e -> Tracks.MUSIC_OVERRIDES_DIR.toPath().resolve(name + e));
	}
}

package nl.alowaniak.runelite.musicreplacer;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

import static nl.alowaniak.runelite.musicreplacer.MusicReplacerConfig.CONFIG_GROUP;

@ConfigGroup(CONFIG_GROUP)
public interface MusicReplacerConfig extends Config
{
	String CONFIG_GROUP = "musicreplacer";
	@ConfigItem(
			keyName = "skipAlreadyOverriddenWhenBulkOverride",
			name = "Skip overridden if bulk",
			description = "When on this will skip any already overridden tracks when doing a bulk override.<br>" +
					"If off the bulk override will replace already overridden tracks (if said track is in the bulk)."
	)
	default boolean skipAlreadyOverriddenWhenBulkOverride()
	{
		return true;
	}

	@ConfigItem(
			keyName = "playOverridesToEnd",
			name = "Play overrides to end",
			description = "When on a next track won't play until current override has ended."
	)
	default boolean playOverridesToEnd()
	{
		return false;
	}
}

package nl.alowaniak.runelite.musicreplacer;

import com.google.common.primitives.Doubles;
import com.google.common.primitives.Ints;
import com.google.inject.Binder;
import com.google.inject.Provides;
import com.google.inject.name.Names;
import joptsimple.internal.Strings;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.music.MusicConfig;
import net.runelite.client.plugins.music.MusicPlugin;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;

import javax.inject.Inject;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.Objects;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import static nl.alowaniak.runelite.musicreplacer.TracksOverridesUi.NORMAL_FONT;
import static nl.alowaniak.runelite.musicreplacer.TracksOverridesUi.OVERRIDE_FONT;

@Slf4j
@PluginDescriptor(
		name = "Music Replacer",
		description = "Replace music tracks with presets (e.g. OSRSBeatz) or your own music",
		tags = {"music", "replace", "override", "track", "song", "youtube", "beats", "osrsbeatz", "rs3"}
)
@PluginDependency(MusicPlugin.class)
public class MusicReplacerPlugin extends Plugin
{
	static {
		MusicPlayer.preloadNecessaries();
	}

	public static final String MUSIC_REPLACER_API = "https://alowan.nl/runelite-music-replacer/";
	public static final String MUSIC_REPLACER_EXECUTOR = "musicReplacerExecutor";
	public static final int PLAYING_WIDGET_ID = 8;
	public static final int CURRENTLY_PLAYING_WIDGET_ID = 9;

	private static final int MUSIC_LOOP_STATE_VAR_ID = 4137;
	private static final double MAX_VOL = 255;

	@Override
	public void configure(Binder binder)
	{
		// Use our own ExecutorService instead of ScheduledExecutorService because the downloads can take a while
		binder.bind(ExecutorService.class).annotatedWith(Names.named(MUSIC_REPLACER_EXECUTOR)).toInstance(Executors.newSingleThreadExecutor());
	}

	@Inject
	private Client client;
	@Inject
	private EventBus eventBus;
	@Inject
	private ClientThread clientThread;
	@Inject
	private TooltipManager tooltipManager;

	@Inject
	private Tracks tracks;
	@Inject
	private TracksOverridesUi tracksOverridesUi;

	@Inject
	private MusicConfig musicConfig;
	@Inject
	private MusicReplacerConfig config;

	private MusicPlayer player;
	private String actualCurTrack;
	private boolean restoreActualCurTrack;
	private TrackOverride trackToPlay;

	private double fading;

	@Override
	protected void startUp()
	{
		eventBus.register(tracksOverridesUi);
	}

	@Provides
	MusicReplacerConfig getConfig(ConfigManager configManager)
	{
		return configManager.getConfig(MusicReplacerConfig.class);
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		if (gameStateChanged.getGameState() == GameState.LOGIN_SCREEN)
		{
			stopPlaying();
		}
	}

	private double oldVolume = -1;
	@Subscribe
	public void onClientTick(ClientTick tick)
	{
		Widget curTrackWidget = client.getWidget(WidgetID.MUSIC_GROUP_ID, CURRENTLY_PLAYING_WIDGET_ID);
		Widget playingWidget = client.getWidget(WidgetID.MUSIC_GROUP_ID, PLAYING_WIDGET_ID);
		if (curTrackWidget == null || playingWidget == null) return;
		String curTrack = curTrackWidget.getText();
		if (Strings.isNullOrEmpty(curTrack)) return;

		// I would rather do UI kinda stuff in TracksOverridesUi, but let's do it here for now
		if (restoreActualCurTrack)
		{
			restoreActualCurTrack = false;
			curTrackWidget.setText(curTrack = actualCurTrack);
			playingWidget.setFontId(NORMAL_FONT);
			playingWidget.setHasListener(false);
		}
		else if (config.playOverridesToEnd() && trackToPlay != null && !curTrack.equals(trackToPlay.getName()))
		{
			// curTrack is a new one, so keep track of actual playing track and change widget
			actualCurTrack = curTrack;
			playingWidget.setFontId(OVERRIDE_FONT);
			Tooltip tooltip = new Tooltip("Up next: " + actualCurTrack);
			playingWidget.setOnMouseRepeatListener((JavaScriptCallback) e ->
			{
				if (!tooltipManager.getTooltips().contains(tooltip)) tooltipManager.add(tooltip);
			});
			playingWidget.setOnClickListener((JavaScriptCallback) e -> restoreActualCurTrack = true);
			playingWidget.setHasListener(true);
			curTrackWidget.setText(curTrack = trackToPlay.getName());
			// Sometimes a track tries to come through briefly, this might fix that hopefully?
			applyVolume();
		}

		TrackOverride newTrack = tracks.getOverride(curTrack);
		if (!Objects.equals(trackToPlay, newTrack))
		{
			trackToPlay = newTrack;
			if (fading <= 0) fading = 1;
		}


		if (fading > 0)
		{
			applyVolume(fading -= .01);

			if (fading <= 0)
			{
				stopCurrentAndStartNew();
			}
		}
		else if (player != null)
		{
			double volume = (musicConfig.getMusicVolume() - 1) / MAX_VOL;
			boolean actualTrackIsBeingOverruled = config.playOverridesToEnd() && actualCurTrack != null && trackToPlay != null && !actualCurTrack.equals(trackToPlay.getName());
			if (actualTrackIsBeingOverruled && (volume <= 0 || !player.isPlaying()))
			{
				restoreActualCurTrack = true;
			}
			else if ((oldVolume <= 0 && volume > 0) || (!player.isPlaying() && client.getVarbitValue(MUSIC_LOOP_STATE_VAR_ID) == 1))
			{
				// Restart play if
				// we switched from muted to on (mimic osrs behavior)
				// or we ended and have loop enabled
				player.play();
			}

			applyVolume();
			oldVolume = volume;
		}
	}

	private void stopCurrentAndStartNew() {
		stopPlaying();

		if (trackToPlay != null)
		{
			try
			{
				player = trackToPlay.getPaths()
						.filter(Files::exists)
						.map(Path::toUri)
						.map(MusicPlayer::create)
						.filter(Objects::nonNull)
						.findFirst()
						.orElse(null);
				if (player != null) player.play();
				else {
					chatMsg("Deleting " + trackToPlay + " override because no player could be made (no file or wrong format?).");
					tracks.removeOverride(trackToPlay.getName());
				}
			}
			catch (OutOfMemoryError e)
			{
				log.warn("Out of memory when loading " + trackToPlay, e);
				trackToPlay = null;
			}
		}

		applyVolume();
	}

	private void applyVolume()
	{
		applyVolume(1);
	}

	private void applyVolume(double multiplier)
	{
		// Setting client music volume with invokeLater seems to prevent the original music from coming through
		// I'm guessing because it depends on "where" in the client loop the vol is set
		// And with invokeLater it happens to "overwrite" Music plugin's write at the correct "point" in the client loop

		if (player == null)
		{
			int volume = (int) ((musicConfig.getMusicVolume() - 1) * multiplier);
			clientThread.invokeLater(() -> client.setMusicVolume(Ints.constrainToRange(volume, 0, (int) MAX_VOL)));
		}
		else
		{
			if (player.isPlaying())
			{
				double volume = Doubles.constrainToRange((musicConfig.getMusicVolume() - 1) / MAX_VOL * multiplier, 0, 1);
				player.setVolume(volume);
			}
			clientThread.invokeLater(() -> client.setMusicVolume(0));
		}
	}

	public void stopPlaying()
	{
		fading = 0;
		if (player != null)
		{
			player.close();
			player = null;
		}
	}

	@Override
	protected void shutDown()
	{
		eventBus.unregister(tracksOverridesUi);
		tracksOverridesUi.shutdown();
		trackToPlay = null;
		stopPlaying();
		clientThread.invoke(() ->
		{
			applyVolume();
			Widget curTrackWidget = client.getWidget(WidgetID.MUSIC_GROUP_ID, CURRENTLY_PLAYING_WIDGET_ID);
			Widget playingWidget = client.getWidget(WidgetID.MUSIC_GROUP_ID, PLAYING_WIDGET_ID);
			if (curTrackWidget == null || playingWidget == null) return;
			if (!Strings.isNullOrEmpty(actualCurTrack)) curTrackWidget.setText(actualCurTrack);
			playingWidget.setFontId(NORMAL_FONT);
			playingWidget.setHasListener(false);
			playingWidget.setOnMouseRepeatListener((Object[]) null);
			actualCurTrack = null;
		});
	}

	public void chatMsg(String... msgs) {
		clientThread.invoke(() -> Arrays.stream(msgs).forEach(msg -> client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", msg, null)));
	}
}

package nl.alowaniak.runelite.musicreplacer;

import com.google.gson.reflect.TypeToken;
import lombok.Data;

import java.util.List;

@Data
public class SearchResult {
    public static final TypeToken<List<SearchResult>> LIST_TYPE = new TypeToken<List<SearchResult>>() {};

    String id;
    String name;
    long duration;
    String uploader;
}

package nl.alowaniak.runelite.musicreplacer;

import com.google.gson.reflect.TypeToken;
import lombok.Value;

import java.util.List;
import java.util.Map;

@Value
public class Preset {
    public static final TypeToken<List<Preset>> LIST_TYPE = new TypeToken<List<Preset>>() {};

    String name;
    String credits;
    Map<String, SearchResult> tracks;
}

/*
 * This file is part of AudioCue,
 * Copyright 2017 Philip Freihofner.
 *
 * Redistribution and use in source and binary forms, with or
 * without modification, are permitted provided that the
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials
 * provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of
 * its contributors may be used to endorse or promote products
 * derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
 * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.adonax.audiocue;

/**
 * The {@code AudioCueInstanceEvent} class represents an event
 * in the life cycle of an {@code AudioCue} <em>instance</em>.
 * An {@code AudioCueInstanceEvent} is passed as
 * an argument to every class that implements the
 * {@code AudioCueListener} interface and is registered to
 * receive notifications about <em>instance</em> events.
 * <p>
 * An {@code AudioCue} supports concurrent plays of its media, where
 * the maximum number of concurrent plays is equal to the value
 * held in the final variable {@code AudioCue.polyphony}.
 * Each concurrent play is referred to as an <em>instance</em>.
 * Instance <em>events</em> mark the life cycle of
 * a single playing or playable instance as follows:
 * <ul>
 * <li>OBTAIN_INSTANCE: an instance is obtained from the pool
 * of available instances if the limit of allocated concurrent
 * instances is not exceeded</li>
 * <li>START_INSTANCE: an instance starts to play</li>
 * <li>LOOP: a instance that finishes playing restarts from the
 * beginning</li>
 * <li>STOP_INSTANCE: a playing instance is stopped (but can
 * still be restarted)</li>
 * <li>RELEASE_INSTANCE: an instance is released back into the
 * pool of available instances. </li>
 * </ul>
 * <p>
 * The information packaged in the {@code AudioCueInstanceEvent}
 * is contained in the following immutable fields:
 * <ul>
 * <li><strong>type</strong> - an {@code enum} designating the
 * nature of the event</li>
 * <li><strong>time</strong> - a {@code long} containing the time
 * of occurrence of the event, to the nearest millisecond</li>
 * <li><strong>source</strong> - the originating
 * {@code AudioCue}</li>
 * <li><strong>frame</strong> - a {@code double} containing the
 * sample frame (may be fractional) current at the time of the
 * event</li>
 * <li><strong>instanceID</strong> - an {@code int} used to
 * identify the {@code AudioCue} instance.</li></ul>
 *
 * @author Philip Freihofner
 * @version AudioCue 1.1
 * @see <a href="http://adonax.com/AudioCue">http://adonax.com/AudioCue</a>
 */
public class AudioCueInstanceEvent {

	/**
	 * The {@code enum Type} represents events that occur during
	 * the lifetime of an {@code AudioCue} <em>instance</em>.
	 */
	static public enum Type {
		/**
		 * Indicates that an instance has been obtained from
		 * the pool of available instances.
		 */
		OBTAIN_INSTANCE,
		/**
		 * Indicates that an instance has been released and
		 * returned to the pool of available instances.
		 */
		RELEASE_INSTANCE,
		/**
		 * Indicates that an instance has started playing.
		 */
		START_INSTANCE,
		/**
		 * Indicates that an instance has stopped playing.
		 */
		STOP_INSTANCE,
		/**
		 * Indicates that an instance has finished playing
		 * and is starting to play again from the beginning
		 * of the media.
		 */
		LOOP};

	/**
	 * the triggering event
	 */
	public final Type type;

	/**
	 * the time in milliseconds when the event occurred
	 */
	public final long time;

	/**
	 * the {@code AudioCue} from which the event originated
	 */
	public final AudioCue source;

	/**
	 * the hook used to identify the instance
	 */
	public final int instanceID;

	/**
	 * the sample frame number (may be fractional) current
	 * at the time of the event
	 */
	public final double frame;

	/**
	 * Constructor for an {@code AudioCueInstanceEvent}, a
	 * class that is passed as a parameter for
	 * {@code AudioCuelistener}.
	 *
	 * @param type an {@code enum} that designates the
	 * category of {@code AudioCue} instance event
	 * @param source the {@code AudioCue} that is the origin
	 * of the event
	 * @param instanceID an {@code int} hook used to identify the
	 * {@code AudioCue}	instance
	 * @param frame a {@code double} that holds the sample
	 * frame current at the time of the event
	 */
	public AudioCueInstanceEvent(Type type, AudioCue source,
								 int instanceID, double frame)
	{
		this.type = type;
		time = System.currentTimeMillis();
		this.source = source;
		this.instanceID = instanceID;
		this.frame = frame;
	}
}

/*
 * This file is part of AudioCue,
 * Copyright 2017 Philip Freihofner.
 *
 * Redistribution and use in source and binary forms, with or
 * without modification, are permitted provided that the
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials
 * provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of
 * its contributors may be used to endorse or promote products
 * derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
 * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.adonax.audiocue;

/**
 * A listener interface for receiving notifications of events
 * pertaining to an {@code AudioCue} and its playable or playing
 * instances. For a class to receive and act on these
 * notifications, it implements this interface, and a copy of
 * the class is registered with the {@code AudioCue} via the
 * following method:
 * <pre>    myAudioCue.addAudioCueListener(myAudioCueListener);</pre>
 * <p>
 * The execution of the implementing methods will occur on the
 * same thread that processes the audio data, and thus should
 * be coded for brevity in order to minimize extraneous processing
 * that might contribute to dropouts during playback.
 *
 * @author Philip Freihofner
 * @version AudioCue 1.1
 * @see <a href="http://adonax.com/AudioCue">http://adonax.com/AudioCue</a>
 */
public interface AudioCueListener
{
	/**
	 * Method called when an {@code AudioCue} executes its
	 * {@code open} method.
	 *
	 * @param now {@code long} holding millisecond value
	 * @param threadPriority {@code int} specifying thread
	 * priority
	 * @param bufferSize {@code int} specifying buffer size
	 * in sample frames
	 * @param source {@code AudioCue} that originated the
	 * notification
	 */
	void audioCueOpened(long now, int threadPriority, int bufferSize,
						AudioCue source);
	/**
	 * Method called when an {@code AudioCue} executes its
	 * {@code close} method.
	 *
	 * @param now {@code long} holding millisecond value
	 * @param source {@code AudioCue} that originated the
	 * notification
	 */
	void audioCueClosed(long now, AudioCue source);

	/**
	 * Method called when an {@code AudioCue} instance event
	 * occurs.
	 *
	 * @param event {@code AudioCueInstanceEvent}
	 */
	void instanceEventOccurred(AudioCueInstanceEvent event);
}
/*
 * This file is part of AudioCue,
 * Copyright 2017 Philip Freihofner.
 *
 * Redistribution and use in source and binary forms, with or
 * without modification, are permitted provided that the
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials
 * provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of
 * its contributors may be used to endorse or promote products
 * derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
 * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.adonax.audiocue;

import java.util.concurrent.CopyOnWriteArrayList;

import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.Mixer;
import javax.sound.sampled.SourceDataLine;

/**
 * {@code AudioMixer} combines the output of members of an
 * {@code AudioCue} collection into a single
 * {@code SourceDataLine} output line. Classes implementing
 * {@code AudioCue} can be added and removed from the
 * mix asynchronously, with the operation occurring at the
 * next buffer iteration. Source tracks must provide for the
 * return of an array of sound data frames whose length is
 * specified by the {@code AudioMixer}. Unlike an analog
 * mixer used in sound studios, the AudioMixer does <i>not</i>
 * provide functions such as panning or volume
 * controls. The only standard function is an equivalent
 * of a <em>mute</em> control, accessible via the {@code running}
 * variable. The mixer imposes a simple floor/ceiling of -1, 1,
 * to guard against volume overflows.
 *
 * @author Philip Freihofner
 * @version AudioCue 1.1
 * @see <a href="http://adonax.com/AudioCue">http://adonax.com/AudioCue</a>
 */
public class AudioMixer
{
	private AudioCue[] trackCache, mixerTracks;
	private CopyOnWriteArrayList<AudioCue> trackManager;
	private volatile boolean trackCacheUpdated;
	private int trackCount;

	/**
	 * Returns the number of tracks being mixed.
	 *
	 * @return integer number of tracks being mixed.
	 */
	public int getTrackLength() {return trackCount;}

	public final int bufferSize, sdlByteBufferSize,
		readBufferSize;
	private float[] audioData;
	private Mixer mixer;
	public final int threadPriority;

	private volatile boolean running;

	/**
	 * Constructor for {@code AudioMixer}, using default
	 * settings:
	 * Mixer           = system default
	 * Buffer size     = 8196 frames
	 * Thread priority = 10.
	 *
	 * The buffer size pertains to the frames collected in
	 * a single {@code while} loop iteration. A buffer that
	 * corresponds to the same number of frames converted
	 * to bytes is assigned to the {@code SourceDataLine}.
	 */
	public AudioMixer()
	{
		this(null, 1024 * 8, 10); // default build
	}

	/**
	 * Constructor for {@code AudioMixer}. The buffer size
	 * is the number of frames collected in a single {@code while}
	 * loop iteration. A buffer with a corresponding frame
	 * count, calculated in bytes, is assigned to the
	 * {@code SourceDataLine}. A thread priority of 10 is
	 * recommended, in order to help prevent sound drop outs.
	 * Note that a well designed and properly running sound thread
	 * should spend the vast majority of its time in a blocked
	 * state, and thus have a minimal impact in terms of usurping
	 * cpu cycles from other threads.
	 *
	 * @param mixer javax.sound.sampled.Mixer to be used
	 * @param bufferSize int specifying the number of frames to
	 * process with each iteration
	 * @param threadPriority int ranging from 1 to 10 specifying
	 * the priority of the sound thread
	 */
	public AudioMixer(Mixer mixer, int bufferSize, int threadPriority)
	{
		trackManager = new CopyOnWriteArrayList<AudioCue>();
		this.bufferSize = bufferSize;
		this.readBufferSize = bufferSize * 2;
		this.sdlByteBufferSize = bufferSize * 4;
		this.mixer = mixer;
		this.threadPriority = threadPriority;
	}

	// reminder: this does NOT update the trackCache!!
	/**
	 * Designates an {@code AudioCue} to be staged
	 * for loading to the array of tracks being mixed. If
	 * the mixer is not running, the track will become
	 * part of the mix when the (@code AudioMixer} is started.
	 * If the {@code AudioMixer} is running, the method
	 * {@code updateTracks} must be executed in order for
	 * the new track to be added to the mix.
	 *
	 * @param track {@code AudioCue} to be added
	 */
	public void addTrack(AudioCue track)
	{
		trackManager.add(track);
	}

	// reminder: this does NOT update the trackCache!!
	/**
	 * Designates an {@code AudioCue} to be staged
	 * for removal from the array of tracks being mixed. If
	 * the mixer is not running, the track, if previously
	 * added, will <em>not</em> be included in the mix
	 * when the (@code AudioMixer} is started.
	 * If the {@code AudioMixer} is running, the method
	 * {@code updateTracks} must be executed in order for
	 * the new track to be removed from the mix.
	 *
	 * @param track
	 * @throws IllegalThreadStateException
	 */
	public void removeTrack(AudioCue track) throws IllegalThreadStateException
	{
		trackManager.remove(track);
	}

	/**
	 * This method signals the {@code AudioMixer}'s playback
	 * loop to update the collection of tracks being mixed
	 * at the next opportunity (depends on the size of the
	 * buffer). Tracks to be added or removed are staged
	 * for update by the methods {@code addTrack} and
	 * {@code removeTrack}.
	 */
	public void updateTracks()
	{
		int size = trackManager.size();
		AudioCue[] workCopyTracks = new AudioCue[size];
		for (int i = 0; i < size; i++)
		{
			workCopyTracks[i] = trackManager.get(i);
		}

		trackCache = workCopyTracks;
		trackCacheUpdated = true;
		System.out.println("CoreMixer.updateTracks, new size:" + size);
	}

	/**
	 * Starts the operation of the {@code AudioMixer}. A running
	 * {@code AudioMixer} iteratively sums a buffer's worth of
	 * frames of sound data from a collection of
	 * {@code AudioCue}s, and writes the resulting
	 * array to a {@code SourceDataLine}.
	 *
	 * @throws IllegalStateException is thrown if the
	 * {@code AudioMixer} is already running.
	 * @throws LineUnavailableException is thrown if there
	 * is a problem securing a {@code SourceDataLine}
	 */
	public void start() throws IllegalStateException,
		LineUnavailableException
	{
		if (running) throw new IllegalStateException(
			"AudioMixer is already running!");

		updateTracks();

		AudioMixerPlayer player = new AudioMixerPlayer(
			mixer, bufferSize);
		Thread t = new Thread(player);
		t.setPriority(threadPriority);
		t.start();

		running = true;
	}

	/**
	 * Stops the iteration of the {@code AudioMixer} after the
	 * soonest data write operation.
	 *
	 * @throws IllegalStateException if the {@code AudioMixer}
	 * is already in a stopped state.
	 */
	public void stop() throws IllegalStateException
	{
		if (!running) throw new IllegalStateException("PFCoreMixer already stopped!");

		running = false;
	}

	private float[] fillBufferFromTracks(float[] normalizedOut)
	{
		// loop through all tracks, summing
		for (int n = 0; n < trackCount; n++)
		{
			if (mixerTracks[n].isRunning())
			{
				try
				{
					audioData = mixerTracks[n].readTrack();
					for (int i = 0; i < readBufferSize; i++)
					{
						normalizedOut[i] += audioData[i];
					}
				}
				catch (Exception e)
				{
					e.printStackTrace();
				}
			}
			for (int i = 0; i < readBufferSize; i++)
			{
				if (normalizedOut[i] > 1)
				{
					normalizedOut[i] = 1;
				}
				else if (normalizedOut[i] < -1)
				{
					normalizedOut[i] = -1;
				}
			}
		}
		return normalizedOut;
	}

	private class AudioMixerPlayer implements Runnable
	{
		private SourceDataLine sdl;
		private float[] readBuffer;
		private byte[] audioBytes;

		AudioMixerPlayer(Mixer mixer, int bufferFrames) throws
			LineUnavailableException
		{
			audioBytes = new byte[sdlByteBufferSize];

			sdl = AudioCue.getSourceDataLine(mixer, AudioCue.info);
			sdl.open(AudioCue.audioFormat, sdlByteBufferSize);
			sdl.start();
		}

		// Sound Thread
		public void run()
		{
			while(running)
			{
				if (trackCacheUpdated)
				{
					/*
					 * Concurrency plan: Better to allow a late
					 * or redundant update than to skip an update.
					 * Example: flag = true, next line resets, but
					 * updater sets true again prior to mixerTracks
					 * assignment. We might load the same trackCache
					 * twice. That is OK.
					 */
					trackCacheUpdated = false;
					mixerTracks = trackCache;
					trackCount = mixerTracks.length;
				}
				readBuffer = new float[readBufferSize];
				readBuffer = fillBufferFromTracks(readBuffer);
				audioBytes = AudioCue.fromBufferToAudioBytes(
					audioBytes, readBuffer);
				sdl.write(audioBytes, 0, sdlByteBufferSize);
			}

			sdl.drain();
			sdl.close();
			sdl = null;
		}
	}
}
/*
 * This file is part of AudioCue,
 * Copyright 2017 Philip Freihofner.
 *
 * Redistribution and use in source and binary forms, with or
 * without modification, are permitted provided that the
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials
 * provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of
 * its contributors may be used to endorse or promote products
 * derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
 * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.adonax.audiocue;

import java.io.IOException;
import java.net.URL;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.function.Function;

import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.DataLine;
import javax.sound.sampled.Line.Info;

import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.Mixer;
import javax.sound.sampled.SourceDataLine;
import javax.sound.sampled.UnsupportedAudioFileException;

import static com.adonax.audiocue.AudioCueInstanceEvent.Type.LOOP;
import static com.adonax.audiocue.AudioCueInstanceEvent.Type.OBTAIN_INSTANCE;
import static com.adonax.audiocue.AudioCueInstanceEvent.Type.RELEASE_INSTANCE;
import static com.adonax.audiocue.AudioCueInstanceEvent.Type.START_INSTANCE;
import static com.adonax.audiocue.AudioCueInstanceEvent.Type.STOP_INSTANCE;

/**
 * The {@code AudioCue} represents a segment of audio media
 * that is loaded into memory prior to playback and which
 * offers minimal latency, concurrent playback of instances,
 * and real time controls for volume, panning and playback
 * speed of each instance. The {@code AudioCue} combines
 * and builds upon many features of the
 * {@code javax.sound.sampled.Clip} and
 * {@code javafx.scene.media.AudioClip}. Data is loaded
 * either from a "CD Quality" wav file (44100 fps, 16-bit,
 * little-endian) or a float array that conforms to this
 * format, and stored in an internal float array as
 * normalized values with the range [-1.0, 1.0].
 * <p>
 * Unlike a {@code Clip} or {@code AudioClip} the {@code
 * play} method returns an {@code int} <em>hook</em> to
 * the playable instance. You can ignore the hook and
 * use the {@code play} method in a fire-and-forget
 * manner, in which case the instance hook is automatically
 * returned to the pool of available instances when play
 * completes. Alternatively, you can use the hook as a
 * parameter to specify an instance to {@code start} or
 * {@code stop} (in effect, <em>pause</em>)
 * or to position the "play head" to any sample frame,
 * or to set other properties of the instance such as the
 * number of repetitions. The hook can also be used to
 * designate the target instance for setting or modulating
 * the volume, pan, or play speed while it is playing. This
 * provides a reliable alternative to the use of a
 * {@code javax.sound.sampled.Control} for smooth
 * volume fade-ins and fade-outs, as well as a basis for
 * pitch-based effects such as Doppler shifting.
 * <p>
 * Internally, a {@code javax.sound.sampled.SourceDataLine}
 * is used for output. When you {@code open} the {@code AudioCue},
 * the line is configured with a buffer size of 1024
 * frames (4192 bytes) and a thread priority of {@code
 * HIGHEST}. Alternative values can be specified as parameters
 * to the {@code open} method.
 *
 * @author Philip Freihofner
 * @version AudioCue 1.1
 * @see <a href="http://adonax.com/AudioCue">http://adonax.com/AudioCue</a>
 */
public class AudioCue
{
	public static final AudioFormat audioFormat =
		new AudioFormat(AudioFormat.Encoding.PCM_SIGNED,
			44100, 16, 2, 4, 44100, false);
	public static final Info info =
		new DataLine.Info(SourceDataLine.class, audioFormat);

	private final int VOLUME_STEPS = 1024;
	private final int SPEED_STEPS = 1024 * 4;
	private final int PAN_STEPS = 1024;
	private final int DEFAULT_BUFFER_FRAMES = 1024 ;

	private final LinkedBlockingDeque<AudioCueCursor> availables;
	private final float[] cue;
	private final int cueFrameLength;
	private final AudioCueCursor[] cursors;
	private final int polyphony;

	private volatile boolean playerRunning;
	private float[] readBuffer;


	private String name;
	/**
	 * Returns the name associated with the {@code AudioCue}.
	 * @return the name as a {@code String}
	 */
	public String getName() { return name; }
	/**
	 * Sets the name of the {@code AudioCue}.
	 *
	 * @param name a {@code String} to associate with this
	 * {@code AudioCue}
	 */
	public void setName(String name) {this.name = name;}

	// only stored if AudioMixer is opened:
	private AudioMixer audioMixer;

	private CopyOnWriteArrayList<AudioCueListener> listeners;

	/**
	 * Registers an {@code AudioCueListener} to receive
	 * notifications of events pertaining to the {@code AudioCue}
	 * and its playing or playable instances.
	 * <p>
	 * Notifications occur on the thread which processes the
	 * audio signal, and includes events such as the starting,
	 * stopping, and looping of instances. Implementations of
	 * the methods that receive these notifications should be
	 * coded for brevity in order to minimize extraneous
	 * processing on the audio thread.
	 *
	 * @param listener a class implementing the
	 * {@code AudioCueListener} interface
	 */
	public void addAudioCueListener(AudioCueListener listener)
	{
		listeners.add(listener);
	}

	/**
	 * Removes an {@code AudioCueListener} from receiving
	 * notifications of events pertaining to the {@code AudioCue}
	 * and its playing instances.
	 *
	 * @param listener a class implementing the
	 * {@code AudioCueListener} interface
	 */
	public void removeAudioCueListener(AudioCueListener listener)
	{
		listeners.remove(listener);
	}

	/**
	 * The {@code enum Type} is a repository of functions
	 * used to perform volume-based panning for stereo media.
	 * Each function takes a pan setting as an input, ranging
	 * from -1 (100% left) to 1 (100% right) with 0 being the
	 * center pan setting.
	 * <p>
	 * In the future, if or when mono media is implemented, a
	 * delay-based panning function option will be added.
	 */
	public static enum PanType
	{
		/**
		 * Represents a panning function that uses linear
		 * gradients that taper from the center to the edges
		 * on the weak side, and the combined volume is
		 * stronger at the center than at the edges.
		 * For the pan values -1 to 0, the
		 * left channel factor is kept at full volume ( = 1)
		 * and the right channel factor is tapered via a
		 * linear function from 0 to 1.
		 * For pan values from 0 to 1, the left channel factor
		 * is tapered via a linear function from 0 to 1 and the
		 * right channel is kept at full volume ( = 1).
		 */
		CENTER_LINEAR(
			x -> Math.max(0, Math.min(1, 1 - x)),
			x -> Math.max(0, Math.min(1, 1 + x))
		),
		/**
		 * Represents a panning function that uses linear
		 * gradients that taper from edge to edge, and the
		 * combined volume is stronger at the edges than
		 * at the center. For pan values -1 to 1 the left
		 * channel factor is tapered with a linear function
		 * from 1 to 0, and the right channel factor is
		 * tapered via a linear function from 0 to 1.
		 */
		FULL_LINEAR(
			x -> (1 + x) / 2,
			x -> 1 - ((1 + x) / 2)
		),
		/**
		 * Represents a panning function that uses
		 * circle-shaped gradients that taper from edge to
		 * edge, and the combined volume is close to uniform
		 * for all pan settings. For the pan values -1 to 1,
		 * the left channel factor is tapered via a {@code cos}
		 * function with values ranging from 1 to 0, and the
		 * right channel factor is tapered via a {@code sin}
		 * function with values ranging from 0 to 1.
		 */
		CIRCULAR(
			x -> (float)(Math.cos(Math.PI * (1 + x) / 4)),
			x -> (float)(Math.sin(Math.PI * (1 + x) / 4))
		);

		private final Function<Float, Float> left;
		private final Function<Float, Float> right;

		PanType(Function<Float, Float> left,
				Function<Float, Float> right)
		{
			this.left = left;
			this.right = right;
		}
	}

	private Function<Float, Float> panL;
	private Function<Float, Float> panR;

	/**
	 * Assigns the type of panning to be used.
	 *
	 * @param panType a member of the {@code enum
	 * AudioCue.PanType}
	 * @see PanType
	 */
	public void setPanType(PanType panType)
	{
		panL = panType.left;
		panR = panType.right;
	}

	/**
	 * Creates and returns a new AudioCue. This method
	 * allows the direct insertion of a {@code float}
	 * array as an argument, where the data is presumed
	 * to conform to the "CD Quality" format: 44100 frames
	 * per second, 16-bit encoding, stereo, little-endian.
	 * The maximum number of concurrent playing instances
	 * is given as the {@code polyphony} argument.
	 * The {@code polyphony} value can not be changed.
	 * A large value may require additional buffering and
	 * result in noticeable lag in order to prevent
	 * drop outs.
	 *
	 * @param cue a {@code float} array of audio data
	 * in "CD Quality" format, scaled to the range
	 * [-1, 1]
	 * @param name a {@code String} to be associated
	 * with the {@code AudioCue}
	 * @param polyphony an {@code int} specifying
	 * the maximum number of concurrent instances
	 * @return AudioCue
	 */
	public static AudioCue makeStereoCue(float[] cue,
										 String name, int polyphony)
	{
		return new AudioCue(cue, name, polyphony);
	}

	/**
	 * Creates and returns a new AudioCue. A {@code URL}
	 * for a WAV file to be loaded is provided. At this
	 * point, only one format, known as "CD Quality", is
	 * supported: 44100 frames per second, 16-bit encoding,
	 * stereo, little-endian. The maximum number of
	 * concurrent playing instances is given as
	 * the {@code polyphony} argument. The {@code polyphony}
	 * value can not be changed. A large value may require
	 * additional buffering and result in noticeable lag
	 * in order to prevent drop outs.
	 * <p>
	 * The file name provided by the URL is automatically
	 * used as the name for the {@code AudioCue}, but can
	 * be changed via the method {@code setName}.
	 *
	 * @param url a {@code URL} for the source file
	 * @param polyphony an {@code int} specifying
	 * the maximum number of concurrent instances
	 * @return AudioCue
	 * @throws UnsupportedAudioFileException if the media
	 * is not a WAV file of "CD Quality"
	 * @throws IOException if unable to load the file
	 */
	public static AudioCue makeStereoCue(URL url, int polyphony)
		throws UnsupportedAudioFileException, IOException
	{
		String urlName = url.getPath();
		int urlLen = urlName.length();
		String name = urlName.substring(urlName.lastIndexOf("/") + 1, urlLen);
		float[] cue = AudioCue.loadURL(url);

		return new AudioCue(cue, name, polyphony);
	}

	/**
	 * Private constructor, used internally.
	 *
	 * @param cue a {@code float} array of audio data
	 * in "CD Quality" format, scaled to the range [-1..1]
	 * @param name a {@code String} to be associated
	 * with the {@code AudioCue}
	 * @param polyphony an {@code int} specifying
	 * the maximum number of concurrent instances
	 */
	private AudioCue(float[] cue, String name, int polyphony)
	{
		this.cue = cue;
		this.cueFrameLength = cue.length / 2;
		this.polyphony = polyphony;
		this.name = name;

		availables =
			new LinkedBlockingDeque<AudioCueCursor>(polyphony);
		cursors = new AudioCueCursor[polyphony];

		for (int i = 0; i < polyphony; i++)
		{
			cursors[i] = new AudioCueCursor(i);
			cursors[i].resetInstance();
			availables.add(cursors[i]);
		}

		// default pan calculation function
		setPanType(PanType.CENTER_LINEAR);

		listeners = new CopyOnWriteArrayList<AudioCueListener>();
	}

	// Currently assumes stereo format ("CD Quality")
	private static float[] loadURL(URL url) throws
		UnsupportedAudioFileException, IOException
	{
		AudioInputStream ais = AudioSystem.getAudioInputStream(url);

		int framesCount = 0;
		if (ais.getFrameLength() > Integer.MAX_VALUE >> 1)
		{
			System.out.println(
				"WARNING: Clip is too large to entirely fit!");
			framesCount = Integer.MAX_VALUE >> 1;
		}
		else
		{
			framesCount = (int)ais.getFrameLength();
		}

		// stereo output, so two entries per frame
		float[] temp = new float[framesCount * 2];
		long tempCountdown = temp.length;

		int bytesRead = 0;
		int bufferIdx;
		int clipIdx = 0;
		byte[] buffer = new byte[1024];
		while((bytesRead = ais.read(buffer, 0, 1024)) != -1)
		{
			bufferIdx = 0;
			for (int i = 0, n = (bytesRead >> 1); i < n; i ++)
			{
				if ( tempCountdown-- >= 0)
				{
					temp[clipIdx++] =
						( buffer[bufferIdx++] & 0xff )
							| ( buffer[bufferIdx++] << 8 ) ;
				}
			}
		}

		for (int i = 0; i < temp.length; i++)
		{
			temp[i] = temp[i] / 32767f;
		}

		return temp;
	}

	/**
	 * Allocates resources for media play, using default
	 * {@code Mixer}, thread priority and buffer size values. The
	 * {@code AudioCueListener} will broadcast a notification
	 * using the method {@code audioCueOpened}.
	 *
	 * @throws IllegalStateException if the player is already
	 * open
	 * @throws LineUnavailableException if unable to obtain a
	 * {@code SourceDataLine} for the player
	 */
	public void open() throws IllegalStateException, LineUnavailableException
	{
		open(null, DEFAULT_BUFFER_FRAMES, Thread.MAX_PRIORITY);
	}

	/**
	 * Allocates resources for media play, using the
	 * default {@code Mixer} and thread priority values, while
	 * setting the internal a custom buffer size. The
	 * {@code AudioCueListener} will broadcast a notification
	 * using the method {@code audioCueOpened}.
	 *
	 * @param bufferFrames number of stereo frames
	 * @throws IllegalStateException if the player is already
	 * open
	 * @throws LineUnavailableException if unable to obtain a
	 * {@code SourceDataLine} for the player
	 */
	public void open(int bufferFrames) throws IllegalStateException, LineUnavailableException
	{
		open(null, bufferFrames, Thread.MAX_PRIORITY);
	}

	/**
	 * Allocates resources for media play, setting explicit values to
	 * over ride the defaults. The {@code AudioCueListener}  will
	 * broadcast a notification using the method {@code audioCueOpened}.
	 *
	 * @param mixer a {@code javax.sound.sampled.Mixer}
	 * @param bufferFrames an {@code int} specifying the size of the
	 * internal buffer
	 * @param threadPriority an {@code int} specifying the priority
	 * level of the thread, ranging [1, 10]
	 * @throws LineUnavailableException if unable to obtain a
	 * {@code SourceDataLine} for the player
	 * @throws IllegalStateException if the {@code AudioCue} is
	 * already open
	 */
	public void open(Mixer mixer, int bufferFrames, int threadPriority)
		throws LineUnavailableException, IllegalStateException
	{
		if (playerRunning)
		{
			throw new IllegalStateException(
				"Already open.");
		}

		AudioCuePlayer player = new AudioCuePlayer(mixer, bufferFrames);
		Thread t = new Thread(player);

		t.setPriority(threadPriority);
		playerRunning = true;
		t.start();

		broadcastOpenEvent(t.getPriority(), bufferFrames, name);
	}

	/**
	 * Assigns an {@code AudioMixer}, instead of an internal
	 * AudioCuePlay, for media playback. The buffer size
	 * and thread priority of the {@code AudioMixer} will be
	 * used for playback. The {@code AudioCueListener} will
	 * broadcast a notification using the method
	 * {@code audioCueOpened}.
	 *
	 * @param audioMixer
	 * @throws IllegalStateException
	 */
	public void open(AudioMixer audioMixer) throws IllegalStateException
	{
		if (playerRunning)
		{
			throw new IllegalStateException(
				"Already open.");
		}
		playerRunning = true;
		this.audioMixer = audioMixer;

		// assigned size is frames * stereo
		readBuffer = new float[audioMixer.bufferSize * 2];

		audioMixer.addTrack(this);
		audioMixer.updateTracks();

		broadcastOpenEvent(audioMixer.threadPriority,
			audioMixer.bufferSize, name);
	}

	/**
	 * Releases resources allocated for media play. The
	 * {@code AudioCueListener} will broadcast a notification
	 * using the method {@code audioCueClosed}.
	 *
	 * @throws IllegalStateException if player is already
	 * closed
	 */
	public void close() throws IllegalStateException
	{
		if (playerRunning == false)
		{
			throw new IllegalStateException(
				"Already closed.");
		}

		if (audioMixer != null)
		{
			audioMixer.removeTrack(this);
			audioMixer.updateTracks();
			audioMixer = null;
		}

		playerRunning = false;

		broadcastCloseEvent(name);
	}

	/**
	 * Gets the media length in sample frames.
	 *
	 * @return length in sample frames
	 */
	public long getFrameLength()
	{
		return cueFrameLength;
	}

	/**
	 * Gets the media length in microseconds.
	 *
	 * @return length in microseconds
	 */
	public long getMicrosecondLength()
	{
		return (long)((cueFrameLength * 1_000_000.0)
			/ audioFormat.getFrameRate());
	}


	/**
	 * Obtains an {@code int} hook from a pool of available
	 * instances.
	 * The {@code AudioCueListener} method {@code obtainedInstance}
	 * will be called. If no playable instances are available,
	 * the method returns -1. An instance obtained by this
	 * method does <em>not</em> recycle back into the pool of
	 * available instances when it finishes playing. To put the
	 * instance back in the pool of availables, the method
	 * {@code releaseInstance} must be called.
	 *
	 * @return an {@code int} hook to the playing instance, or -1
	 * if no instances are available
	 */
	public int obtainInstance()
	{
		AudioCueCursor aci = availables.pollLast();

		if (aci == null) return -1;
		else
		{
			aci.isActive = true;
			broadcastCreateInstanceEvent(aci);
			return aci.hook;
		}
	}

	/**
	 * Releases an {@code AudioCue} instance, making
	 * it available for a new {@code play} method.
	 * The {@code AudioCueListener} method {@code releaseInstance}
	 * will be called.
	 *
	 * @param instanceHook {@code int} hook identifying the cue
	 * instance to be released
	 */
	public void releaseInstance(int instanceHook)
	{
		cursors[instanceHook].resetInstance();
		availables.offerFirst(cursors[instanceHook]);
		broadcastReleaseEvent(cursors[instanceHook]);
	}

	/**
	 * Plays an available {@code AudioCue} instance
	 * from the start of the audio data, at full volume, center
	 * pan, and at normal speed, or, returns -1 if no
	 * {@code AudioCue} instance is available. If an
	 * {@code AudioCue} instance is able to play,
	 * the {@code AudioCueListener} methods
	 * {@code createInstance} and {@code startInstance}
	 * will be called. When the instance finishes playing
	 * it will be automatically recycled into the pool of
	 * available instances.
	 * <p>
	 * For best response time (lowest latency), the {@code play}
	 * method should be called on an {@code AudioCue} that has
	 * already been opened, as opening requires the creation
	 * of an audio thread and the acquisition of an output line.
	 *
	 * @return an {@code int} hook to the playing instance,
	 * or -1 if no instance is available
	 */
	public int play()
	{
		return play(1, 0, 1, 0);
	}

	/**
	 * Plays an available {@code AudioCue} instance
	 * from the start of the audio data at the given volume, at
	 * center pan, and at normal speed, or, returns -1 if no
	 * {@code AudioCue} instance is available.  If an
	 * {@code AudioCue} instance is able to play,
	 * the {@code AudioCueListener} methods
	 * {@code createInstance} and {@code startInstance}
	 * will be called. When the instance finishes playing
	 * it will be automatically recycled into the pool of
	 * available instances.
	 * <p>
	 * For best response time (lowest latency), the {@code play}
	 * method should be called on an {@code AudioCue} that has
	 * already been opened, as opening requires the creation
	 * of an audio thread and the acquisition of an output line.
	 *
	 * @param volume a {@code double} in the range [0, 1]
	 * @return an {@code int} hook to the playing instance,
	 * or -1 if no instance is available
	 */
	public int play(double volume)
	{
		return play(volume, 0, 1, 0);
	}

	/**
	 * Plays an available {@code AudioCue} instance from
	 * the start of the audio data, at center pan, and at the
	 * specified speed, or, returns -1 if no {@code AudioCue}
	 * instance is available. If an {@code AudioCue} instance
	 * is able to play, the {@code AudioCueListener}
	 * notifications {@code createInstance} and
	 * {@code startInstance} will be sent to all registered
	 * listeners. When the instance finishes playing
	 * it will be automatically recycled into the pool of
	 * available instances.
	 * <p>
	 * For best response time (lowest latency), the {@code play}
	 * method should be called on an {@code AudioCue} that has
	 * already been opened, as opening requires the creation
	 * of an audio thread and the acquisition of an output line.
	 *
	 * @param volume a {@code double} within the range [0, 1]
	 * @param pan a {@code double} within the range [-1, 1]
	 * @param speed a {@code double} that becomes the frame rate
	 * @param loop an {@code int} that specifies a number of
	 * additional plays (looping)
	 * @return an {@code int} hook to the playing instance,
	 * or -1 if no instance is available
	 */
	public int play(double volume, double pan, double speed, int loop)
	{
		int idx = obtainInstance();
		if (idx < 0)
		{
			System.out.println("All available notes are playing.");
			return idx;
		}

		setVolume(idx, volume);
		setPan(idx, pan);
		setSpeed(idx, speed);
		setLooping(idx, loop);
		setRecycleWhenDone(idx, true);

		start(idx);

		return idx;
	}

	/**
	 * Plays the specified {@code AudioCue} instance from its current
	 * position within the sound cue, using current volume, pan,
	 * and speed settings. The {@code AudioCueListener} method
	 * {@code startInstance} will be called.
	 *
	 * @param instanceHook an {@code int} used to identify an
	 * {@code AudioCue} instance
	 * @throws IllegalStateException if instance is not active
	 * or if instance is playing
	 */
	public void start(int instanceHook) throws IllegalStateException
	{
		if (!cursors[instanceHook].isActive ||
			cursors[instanceHook].isPlaying)
		{
			throw new IllegalStateException("Illegal state, "
				+ name + ", instance:" + instanceHook);
		}

		cursors[instanceHook].isPlaying = true;
		broadcastStartEvent(cursors[instanceHook]);
	};

	/**
	 * Sends message to indicate that the playing of the cue
	 * associated with the hook should be paused. The
	 * {@code AudioCueListener} method {@code stopInstance}
	 * will be called. Sending this message to an already
	 * stopped instance does nothing. Once an instance is
	 * stopped, it will be left in an active state until
	 * it is explicitly released.
	 *
	 * @param instanceHook an {@code int} used to identify an
	 * {@code AudioCue} instance
	 * @throws IllegalStateException if instance is not active
	 */
	public void stop(int instanceHook) throws IllegalStateException
	{
		if (!cursors[instanceHook].isActive)
		{
			throw new IllegalStateException("Illegal state, "
				+ name + ", instance:" + instanceHook);
		}

		cursors[instanceHook].isPlaying = false;
		broadcastStopEvent(cursors[instanceHook]);
		cursors[instanceHook].recycleWhenDone = false;
	};

	/**
	 * Sets the play position ("play head") to a
	 * specified sample frame. The frame count is zero-based.
	 * The new play position can include a fractional sample
	 * amount. The new sample frame position will be clamped to
	 * a value that lies within the {@code AudioCue}. When
	 * the instance is restarted, it will commence from this
	 * sample frame.
	 *
	 * @param instanceHook an {@code int} used to identify an
	 * {@code AudioCue} instance
	 * @param frame the sample frame number from which play will
	 * commence when the next {@code start} method is executed
	 * @throws IllegalStateException if instance is not active
	 * or if instance is playing
	 */
	public void setFramePosition(int instanceHook, double frame)
		throws IllegalStateException
	{
		if (!cursors[instanceHook].isActive ||
			cursors[instanceHook].isPlaying)
		{
			throw new IllegalStateException("Illegal state, "
				+ name + ", instance:" + instanceHook);
		}

		cursors[instanceHook].idx = Math.max(0, Math.min(
			getFrameLength() - 1, (float)frame));
	};

	/**
	 * Returns the current sample frame number. The frame count
	 * is zero-based. The position may lie in between two frames.
	 *
	 * @param instanceHook an {@code int} used to identify an
	 * {@code AudioCue} instance
	 * @return a {@code double} corresponding to the current
	 * sample frame position
	 * @throws IllegalStateException if instance is not active
	 */
	public double getFramePosition(int instanceHook)
	{
		if (!cursors[instanceHook].isActive)
		{
			throw new IllegalStateException(name + " instance: "
				+ instanceHook + " is inactive");
		}

		return cursors[instanceHook].idx;
	}

	/**
	 * Repositions the play position ("play head") of the
	 * given {@code AudioCue} instance to the sample frame that
	 * corresponds to the specified elapsed time in milliseconds.
	 * The new play position can include a fractional sample
	 * amount. The new sample frame position will be clamped to
	 * a value that lies within the {@code AudioCue}. When the
	 * instance is restarted, it will commence from this
	 * sample frame.
	 *
	 * @param instanceHook an {@code int} used to identify an
	 * {@code AudioCue} instance
	 * @param milliseconds an {@code int} in milliseconds that
	 * corresponds to the desired starting point for the
	 * {@code AudioCue} instance
	 * @throws IllegalStateException if instance is not active
	 * or if instance is playing
	 */
	public void setMillisecondPosition(int instanceHook,
									   int milliseconds)
	{
		if (!cursors[instanceHook].isActive ||
			cursors[instanceHook].isPlaying)
		{
			throw new IllegalStateException("Illegal state, "
				+ name + ", instance:" + instanceHook);
		}

		float samples = (audioFormat.getFrameRate() * milliseconds)
			/ 1000f;
		cursors[instanceHook].idx =
			Math.max(0,	Math.min(cueFrameLength - 1, samples));
	};

	/**
	 * Repositions the play position ("play head") of the
	 * given {@code AudioCue} instance to the sample frame that
	 * corresponds to the specified elapsed fractional
	 * part the total audio cue length. The new play position can
	 * include a fractional sample amount. Arguments are clamped
	 * to the range [0..1]. When restarted, the audio cue will
	 * commence from the new sample frame position.
	 *
	 * @param instanceHook an {@code int} used to identify the
	 * {@code AudioCue} instance
	 * @param normal a {@code double} in the range [0..1] that
	 * corresponds to the desired starting point for the
	 * {@code AudioCue} instance
	 * @throws IllegalStateException if instance is not active
	 * or if instance is playing
	 */
	public void setFractionalPosition(int instanceHook, double normal)
	{
		if (!cursors[instanceHook].isActive ||
			cursors[instanceHook].isPlaying)
		{
			throw new IllegalStateException("Illegal state, "
				+ name + ", instance:" + instanceHook);
		}

		cursors[instanceHook].idx = (float)((cueFrameLength - 1) *
			Math.max(0, Math.min(1, normal)));
	};

	/**
	 * Sets the volume of the instance. Volumes can be altered
	 * while a cue is playing with a latency largely determined
	 * by the buffer setting specified in the {@code open} method
	 * in combination with a smoothing algorithm used to prevent
	 * signal discontinuities that result in audible clicks or
	 * other forms of distortion. Volumes can be altered
	 * concurrently, with the most recent call
	 * taking precedence over and interrupting previous calls.
	 * Arguments are clamped to the range [0..1] and
	 * thus can only diminish, not amplify, the volume.
	 * <p>
	 * Internally, the volume argument is used as a factor that
	 * is directly multiplied against the media's sample values,
	 * and it should be noted that this linear scaling of
	 * sample values is not proportional with the human sense of
	 * loudness.
	 *
	 * @param  instanceHook  an {@code int} used to identify the
	 * {@code AudioCue} instance
	 * @param  volume a {@code float} in the range [0, 1] to be
	 * multiplied against the audio sample values
	 * @throws IllegalStateException if instance is not active
	 */
	public void setVolume(int instanceHook, double volume)
		throws IllegalStateException
	{
		if (!cursors[instanceHook].isActive)
		{
			throw new IllegalStateException(name + " instance: "
				+ instanceHook + " is inactive");
		}

		cursors[instanceHook].targetVolume =
			(float)Math.min(1, Math.max(0, volume));
		if (cursors[instanceHook].isPlaying)
		{
			cursors[instanceHook].targetVolumeIncr =
				(cursors[instanceHook].targetVolume
					- cursors[instanceHook].volume)
					/ VOLUME_STEPS;
			cursors[instanceHook].targetVolumeSteps = VOLUME_STEPS;
		}
		else
		{
			cursors[instanceHook].volume =
				cursors[instanceHook].targetVolume;
		}
	};

	/**
	 * Returns a value indicating the current volume setting
	 * of an {@code AudioCue} instance, ranging [0..1].
	 *
	 * @param instanceHook an {@code int} used to identify the
	 * {@code AudioCue} instance
	 * @return volume factor as a {@code double}
	 * @throws IllegalStateException if instance is not active
	 */
	public double getVolume(int instanceHook)
		throws IllegalStateException
	{
		if (!cursors[instanceHook].isActive)
		{
			throw new IllegalStateException(name + " instance: "
				+ instanceHook + " is inactive");
		}

		return cursors[instanceHook].volume;
	};

	/**
	 * Sets the pan of the instance, where 100% left corresponds
	 * to -1, 100% right corresponds to 1, and center = 0.
	 * The pan setting can be changed while a cue is playing
	 * with a latency largely determined by the buffer setting
	 * specified in the {@code open} method in combination with
	 * a smoothing algorithm used to prevent signal
	 * discontinuities that result in audible clicks or
	 * other forms of distortion. Pans can be altered
	 * concurrently, with the most recent call
	 * taking precedence over and interrupting previous calls.
	 * Arguments are clamped to the range [-1, 1].
	 * <p>
	 * For stereo {@code AudioCue}s, a volume-based pan is
	 * performed. The calculation is performed by method
	 * specified by {@code AudioCue.Pan}.
	 *
	 * @param instanceHook an {@code int} used to identify the
	 * {@code AudioCue} instance
	 * @param pan a {@code double} ranging from -1 to 1
	 * @throws IllegalStateException if instance is not active
	 * @see AudioCue.PanType
	 */
	public void setPan(int instanceHook, double pan)
		throws IllegalStateException
	{
		if (!cursors[instanceHook].isActive)
		{
			throw new IllegalStateException(name + " instance: "
				+ instanceHook + " is inactive");
		}
		cursors[instanceHook].targetPan =
			(float)Math.min(1, Math.max(-1, pan));
		if (cursors[instanceHook].isPlaying)
		{
			cursors[instanceHook].targetPanIncr =
				(cursors[instanceHook].targetPan
					- cursors[instanceHook].pan)
					/ PAN_STEPS;
			cursors[instanceHook].targetPanSteps = PAN_STEPS;
		}
		else
		{
			cursors[instanceHook].pan =
				cursors[instanceHook].targetPan;
		}
	};

	/**
	 * Returns a double in the range [-1, 1] where -1
	 * indicates 100% left and 1 indicates 100% right.
	 *
	 * @param instanceHook an {@code int} used to identify the
	 * {@code AudioCue} instance
	 * @return the current pan value, ranging [-1, 1]
	 * @throws IllegalStateException if instance is not active
	 */
	public double getPan(int instanceHook) throws
		IllegalStateException
	{
		if (!cursors[instanceHook].isActive)
		{
			throw new IllegalStateException(name + " instance: "
				+ instanceHook + " is inactive");
		}

		return cursors[instanceHook].pan;
	};

	/**
	 * Sets the play speed of the {@code AudioCue} instance. A
	 * faster speed results in both higher-pitched frequency
	 * content and a shorter duration. Play speeds can be
	 * altered in real time while a cue is playing with a latency
	 * largely determined by the buffer setting specified in the
	 * {@code open} method in combination with a smoothing
	 * algorithm used to prevent signal discontinuities.
	 * Speeds can be altered concurrently, with the most recent
	 * call taking precedence over and interrupting previous calls.
	 * A speed of 1 will play the {@code AudioCue} instance at its
	 * originally recorded speed. A value of 2 will double the
	 * play speed, and a value of 0.5 will halve the play speed.
	 * Arguments are clamped to values ranging from 8 times slower
	 * to 8 times faster than unity, a range of [0.125, 8].
	 * <p>
	 * Note that the determination of what is an effective amount
	 * of speed-up or slow-down depends upon the frequency content
	 * of the original sample, thus "safe bounds" for the speed
	 * argument are difficult to specify. Thus, it is possible
	 * to enter values that result in signals that are either
	 * too low or too high in frequency to be audible.
	 *
	 * @param instanceHook an {@code int} used to identify an
	 * {@code AudioCue} instance
	 * @param speed a {@code double} factor ranging from
	 * 0.125 to 8 (1/8th to 8 times the original speed)
	 * @throws IllegalStateException if instance is not active
	 */
	public void setSpeed(int instanceHook, double speed)
		throws IllegalStateException
	{
		if (!cursors[instanceHook].isActive)
		{
			throw new IllegalStateException(name + " instance: "
				+ instanceHook + " is inactive");
		}

		cursors[instanceHook].targetSpeed =
			(float)Math.min(8, Math.max(0.125, speed));
		if (cursors[instanceHook].isPlaying)
		{
			cursors[instanceHook].targetSpeedIncr =
				(cursors[instanceHook].targetSpeed
					- cursors[instanceHook].speed) / SPEED_STEPS;
			cursors[instanceHook].targetSpeedSteps = SPEED_STEPS;
		}
		else
		{
			cursors[instanceHook].speed =
				cursors[instanceHook].targetSpeed;
		}
	};

	/**
	 * Returns a factor indicating the current rate of play of
	 * the {@code AudioCue} instance relative to normal play.
	 *
	 * @param instanceHook an {@code int} used to identify an
	 * {@code AudioCue} instance
	 * @return a {@code float} factor indicating the speed at
	 * which the {@code AudioCue} instance is being played
	 * in the range [0.125, 8]
	 * @throws IllegalStateException if instance is not active
	 */
	public double getSpeed(int instanceHook) throws
		IllegalStateException
	{
		if (!cursors[instanceHook].isActive)
		{
			throw new IllegalStateException(name + " instance: "
				+ instanceHook + " is inactive");
		}

		return cursors[instanceHook].speed;
	};

	/**
	 * Sets the number of times the media will restart
	 * from the beginning, after completing, or specifies
	 * infinite looping via the value -1. Note: an instance
	 * set to loop 2 times will play back a total of 3 times.
	 *
	 * @param instanceHook an {@code int} used to identify an
	 * {@code AudioCue} instance
	 * @param loops an {@code int} that specifies the number
	 * of times an instance will return to the beginning
	 * and play again
	 * @throws IllegalStateException if instance is not active
	 */
	public void setLooping(int instanceHook, int loops)
		throws IllegalStateException
	{
		if (!cursors[instanceHook].isActive)
		{
			throw new IllegalStateException(name + " instance: "
				+ instanceHook + " is inactive");
		}

		cursors[instanceHook].loop = loops;
	};

	/**
	 * Sets a flag which determines what happens when the instance
	 * finishes playing. If {@code true} the instance will be
	 * added to the pool of available instances and will no longer
	 * allow updates. If {@code false} then the instance will
	 * remain available for updates. By default, an instance that
	 * is obtained via a {@code play} method recycles, and an
	 * instance obtained via {@code getInstance} will not. But in
	 * both cases the behavior can be changed by setting this
	 * flag.
	 *
	 * @param instanceHook an {@code int} used to identify an
	 * {@code AudioCue} instance
	 * @param recycleWhenDone a {@code boolean} that designates
	 * the behavior ("recycle" or not) that occurs when the
	 * instance finishes playing
	 * @throws IllegalStateException if the instance is not active
	 */
	public void setRecycleWhenDone(int instanceHook,
								   boolean recycleWhenDone) throws IllegalStateException
	{
		if (!cursors[instanceHook].isActive)
		{
			throw new IllegalStateException(name + " instance: "
				+ instanceHook + " is inactive");
		}

		cursors[instanceHook].recycleWhenDone = recycleWhenDone;
	}

	/**
	 * Returns {@code true} if instance is active, {@code false}
	 * if not.
	 *
	 * @param instanceHook an {@code int} used to identify an
	 * {@code AudioCue} instance
	 * @return {@code true} if instance is playing, {@code false}
	 * if not
	 */
	public boolean getIsActive(int instanceHook)
	{
		return cursors[instanceHook].isActive;
	}

	/**
	 * Returns {@code true} if instance is playing, {@code false}
	 * if not
	 *
	 * @param instanceHook an {@code int} used to identify an
	 * {@code AudioCue} instance
	 * @return {@code true} if instance is playing, {@code false}
	 * if not
	 */
	public boolean getIsPlaying(int instanceHook)
	{
		return cursors[instanceHook].isPlaying;
	}


	/*
	 * A private, data-only class that is created and
	 * maintained internally for managing each concurrent instance
	 * of an {@code AudioCue}. The 'hook' variable is an identifier
	 * that is created upon instantiation to correspond
	 * to the position of the {@code AudioCueCursor} instance in
	 * the {@code AudioCue.cursors} array.
	 * <p>
	 * An instance is either active ({code isActive = true})
	 * in which case it can be updated, or inactive, in which case
	 * it is in a pool of <em>available</em> instances. An
	 * <em>active</em> instance is either playing or stopped
	 * (paused). These flags are checked for appropriate state
	 * for various method calls. The {@code recycleWhenDone
	 * boolean} is used to determine whether the instance is placed
	 * back in the pool of available instances when a play
	 * completes, or if it remains available to update.
	 * <p>
	 * The <em>target</em> variables are used to ensure that
	 * changes in real time to the corresponding settings change
	 * in small enough increments that discontinuities are not
	 * created in the data.
	 */
	private class AudioCueCursor
	{
		volatile boolean isPlaying;
		volatile boolean isActive;
		final int hook;

		float idx;
		float speed;
		float volume;
		float pan;
		int loop;
		boolean recycleWhenDone;

		float targetSpeed;
		float targetSpeedIncr;
		int targetSpeedSteps;

		float targetVolume;
		float targetVolumeIncr;
		int targetVolumeSteps;

		float targetPan;
		float targetPanIncr;
		int targetPanSteps;

		AudioCueCursor(int hook)
		{
			this.hook = hook;
		}

		/*
		 * Used to clear settings from previous plays
		 * and put in default settings.
		 */
		void resetInstance()
		{
			isActive = false;
			isPlaying = false;
			idx = 0;
			speed = 1;
			volume = 0;
			pan = 0;
			loop = 0;
			recycleWhenDone = false;

			targetSpeedSteps = 0;
			targetVolumeSteps = 0;
			targetPanSteps = 0;
		}
	}

	/*
	 * "Opening" line sets the SourceDataLine waiting for data.
	 * "Run" will start loop that will either send out silence
	 * (zero-filled arrays) or sound data.
	 */
	private class AudioCuePlayer implements Runnable
	{
		private SourceDataLine sdl;
		private final int sdlBufferSize;
		private byte[] audioBytes;

		AudioCuePlayer(Mixer mixer, int bufferFrames) throws
			LineUnavailableException
		{
			readBuffer = new float[bufferFrames * 2];
			sdlBufferSize = bufferFrames * 4;
			audioBytes = new byte[sdlBufferSize];

			sdl = getSourceDataLine(mixer, info);
			sdl.open(audioFormat, sdlBufferSize);
			sdl.start();
		}

		// Audio Thread Code
		public void run()
		{
			while(playerRunning)
			{
				readBuffer = fillBuffer(readBuffer);
				audioBytes = fromBufferToAudioBytes(audioBytes, readBuffer);
				sdl.write(audioBytes, 0, sdlBufferSize);
			}
			sdl.drain();
			sdl.close();
			sdl = null;
		}
	}

	/*
	 * AudioThread code.
	 * Within while loop.
	 */
	private float[] fillBuffer(float[] readBuffer)
	{
		// Start with 0-filled buffer, send out silence
		// if nothing playing.
		int bufferLength = readBuffer.length;
		for (int i = 0; i < bufferLength; i++)
		{
			readBuffer[i] = 0;
		}

		for (int ci = 0; ci < polyphony; ci++)
		{
			if (cursors[ci].isPlaying)
			{
				AudioCueCursor acc = cursors[ci];
				/*
				 * Usually, pan won't change, so let's
				 * store value and only recalculate when
				 * it changes.
				 */
				float panFactorL = panL.apply(acc.pan);
				float panFactorR = panR.apply(acc.pan);

				for (int i = 0; i < bufferLength; i += 2)
				{
					// adjust volume if needed
					if (acc.targetVolumeSteps-- > 0)
					{
						acc.volume += acc.targetVolumeIncr;
					}

					// adjust pan if needed
					if (acc.targetPanSteps-- > 0)
					{
						acc.pan += acc.targetPanIncr;
						panFactorL = panL.apply(acc.pan);
						panFactorR = panR.apply(acc.pan);
					}

					// get audioVals (with LERP for fractional idx)
					float[] audioVals = new float[2];
					audioVals = readFractionalFrame(audioVals, acc.idx);

					readBuffer[i] += (audioVals[0]
						* acc.volume * panFactorL);
					readBuffer[i + 1] += (audioVals[1]
						* acc.volume * panFactorR);

					// SET UP FOR NEXT ITERATION
					// adjust pitch if needed
					if (acc.targetSpeedSteps-- > 0)
					{
						acc.speed +=
							acc.targetSpeedIncr;
					}

					// set NEXT read position
					acc.idx += acc.speed;

					// test for "eof" and "looping"
					if (acc.idx >= (cueFrameLength - 1))
					{
						// keep looping indefinitely
						if (acc.loop == -1)
						{
							acc.idx = 0;
							broadcastLoopEvent(acc);
						}
						// loop specific number of times
						else if (acc.loop > 0)
						{
							acc.loop--;
							acc.idx = 0;
							broadcastLoopEvent(acc);
						}
						else // no more loops to do
						{
							acc.isPlaying = false;
							broadcastStopEvent(acc);
							if (acc.recycleWhenDone)
							{
								acc.resetInstance();
								availables.offerFirst(acc);
								broadcastReleaseEvent(acc);
							}
							break;
						}
					}
				}
			}
		}
		return readBuffer;
	}

	// Audio thread code, gets single stereo Frame pairs.
	// Due to variable pitch, requires LERP between frames.
	private float[] readFractionalFrame(float[] audioVals, float idx)
	{
		final int intIndex = (int) idx;
		final int flatIndex = intIndex * 2;

		audioVals[0] = cue[flatIndex + 2] * (idx - intIndex)
			+ cue[flatIndex] * ((intIndex + 1) - idx);

		audioVals[1] = cue[flatIndex + 3] * (idx - intIndex)
			+ cue[flatIndex + 1] * ((intIndex + 1) - idx);

		return audioVals;
	}

	// Audio Thread Code, keep this a self-contained function!
	public static byte[] fromBufferToAudioBytes(byte[] audioBytes, float[] buffer)
	{
		for (int i = 0, n = buffer.length; i < n; i++)
		{
			buffer[i] *= 32767;

			audioBytes[i*2] = (byte) buffer[i];
			audioBytes[i*2 + 1] = (byte)((int)buffer[i] >> 8 );
		}

		return audioBytes;
	}

	// Function - keep it self contained.
	public static SourceDataLine getSourceDataLine(Mixer mixer,
												   Info info) throws LineUnavailableException
	{
		SourceDataLine sdl;

		if (mixer == null)
		{
			sdl = (SourceDataLine)AudioSystem.getLine(info);
		}
		else
		{
			sdl = (SourceDataLine)mixer.getLine(info);
		}

		return sdl;
	}

	public boolean isRunning()
	{
		return playerRunning;
	}

	public void setRunning(boolean bool)
	{
		this.playerRunning = bool;
	}

	public float[] readTrack() throws IOException
	{
		return fillBuffer(readBuffer);
	}



	// The following are the methods that broadcast events to
	// the registered listeners.
	private void broadcastOpenEvent(int threadPriority,
									int bufferSize,	String name)
	{
		for (AudioCueListener acl : listeners)
		{
			acl.audioCueOpened(System.currentTimeMillis(),
				threadPriority,	bufferSize, this);
		}
	}

	private void broadcastCloseEvent(String name)
	{
		for (AudioCueListener acl : listeners)
		{
			acl.audioCueClosed(System.currentTimeMillis(), this);
		}
	}


	private void broadcastCreateInstanceEvent(AudioCueCursor acc)
	{
		for (AudioCueListener acl:listeners)
		{
			acl.instanceEventOccurred(
				new AudioCueInstanceEvent(
					OBTAIN_INSTANCE,
					this, acc.hook, 0
				));
		}
	}

	private void broadcastReleaseEvent(AudioCueCursor acc)
	{
		for (AudioCueListener acl:listeners)
		{
			acl.instanceEventOccurred(
				new AudioCueInstanceEvent(
					RELEASE_INSTANCE,
					this, acc.hook, acc.idx
				));
		}
	}

	private void broadcastStartEvent(AudioCueCursor acc)
	{
		for (AudioCueListener acl:listeners)
		{
			acl.instanceEventOccurred(
				new AudioCueInstanceEvent(
					START_INSTANCE,
					this, acc.hook, acc.idx
				));
		}
	}

	private void broadcastLoopEvent(AudioCueCursor acc)
	{
		for (AudioCueListener acl:listeners)
		{
			acl.instanceEventOccurred(
				new AudioCueInstanceEvent(
					LOOP, this, acc.hook, 0
				));
		}
	}

	private void broadcastStopEvent(AudioCueCursor acc)
	{
		for (AudioCueListener acl:listeners)
		{
			acl.instanceEventOccurred(
				new AudioCueInstanceEvent(
					STOP_INSTANCE,
					this, acc.hook, acc.idx
				));
		}
	}
}
