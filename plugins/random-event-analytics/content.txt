package com.randomEventAnalytics;

import com.google.inject.Guice;
import com.google.inject.testing.fieldbinder.Bind;
import com.google.inject.testing.fieldbinder.BoundFieldModule;
import com.randomEventAnalytics.localstorage.RandomEventAnalyticsLocalStorage;
import javax.inject.Inject;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;
import net.runelite.api.Player;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.InteractingChanged;
import net.runelite.client.Notifier;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.plugins.xptracker.XpTrackerService;
import net.runelite.client.ui.overlay.OverlayManager;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import static org.mockito.ArgumentMatchers.any;
import org.mockito.Mock;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.lenient;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import org.mockito.junit.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class RandomEventAnalyticsPluginTest
{
	@Mock
	@Bind
	Client client;
	@Mock
	@Bind
	ConfigManager configManager;
	@Mock
	@Bind
	RandomEventAnalyticsConfig config;
	@Mock
	@Bind
	OverlayManager overlayManager;
	@Mock
	@Bind
	RandomEventAnalyticsOverlay overlay;
	@Mock
	@Bind
	RandomEventAnalyticsPanel panel;
	@Mock
	@Bind
	RandomEventAnalyticsLocalStorage localStorage;
	@Mock
	@Bind
	TimeTracking timeTracking;
	@Mock
	@Bind
	ChatMessageManager chatMessageManager;
	@Mock
	@Bind
	XpTrackerService xpTrackerService;

	@Mock
	@Bind
	Notifier notifier;

	@Inject
	RandomEventAnalyticsPlugin plugin;

	@Before
	public void before() {
		Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);
		mockLocalStorage();
	}

	@Test
	public void testAddsRandomEventWhenValidNPCInteractionChanged()
	{
		doNothing().when(panel).addRandom(any());
		plugin.setPanel(panel);

		final Player player = getMockedPlayer();
		when(client.getLocalPlayer()).thenReturn(player);
		when(client.getTickCount()).thenReturn(10);

		NPC npc1 = getMockedNPC(NpcID.BEE_KEEPER_6747);
		interactingChanged(npc1, player);

		verify(localStorage, times(1)).addRandomEventRecord(any());
		verify(panel, times(1)).addRandom(any());
		verify(timeTracking, times(1)).setRandomEventSpawned();
	}

	@Test
	public void testDoesNotAddOtherPlayersRandoms()
	{
		final Player player = getMockedPlayer();
		when(client.getLocalPlayer()).thenReturn(player);

		Player otherPlayer = getMockedPlayer();
		NPC npc1 = getMockedNPC(NpcID.BEE_KEEPER_6747);
		interactingChanged(npc1, otherPlayer);

		verify(localStorage, times(0)).addRandomEventRecord(any());
		verify(panel, times(0)).addRandom(any());
		verify(timeTracking, times(0)).setRandomEventSpawned();
	}

	private void mockLocalStorage() {
		when(localStorage.addRandomEventRecord(any())).thenReturn(true);
	}

	private NPC getMockedNPC(int npcID) {
		final NPC npc = mock(NPC.class);
		when(npc.getWorldLocation()).thenReturn(new WorldPoint(0, 0, 0));
		when(npc.getLocalLocation()).thenReturn(new LocalPoint(0,0));
		when(npc.getName()).thenReturn("MockedNPCName");
		when(npc.getCombatLevel()).thenReturn(1);
		when(npc.getId()).thenReturn(npcID);
		return npc;
	}

	private Player getMockedPlayer() {
		final Player player = mock(Player.class);
		when(player.getWorldLocation()).thenReturn(new WorldPoint(0, 0, 0));
		when(player.getLocalLocation()).thenReturn(new LocalPoint(0,0));
		when(player.getCombatLevel()).thenReturn(126);
		return player;
	}

	private void interactingChanged(final Actor source, final Actor target) {
		lenient().when(source.getInteracting()).thenReturn(target);
		plugin.onInteractingChanged(new InteractingChanged(source, target));
	}
}

package com.randomEventAnalytics;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class RandomEventInfoPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(RandomEventAnalyticsPlugin.class);
		RuneLite.main(args);
	}
}
package com.randomEventAnalytics;


import com.google.inject.Guice;
import com.google.inject.testing.fieldbinder.Bind;
import com.google.inject.testing.fieldbinder.BoundFieldModule;
import com.randomEventAnalytics.localstorage.RandomEventRecord;
import java.time.Duration;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import javax.inject.Inject;
import net.runelite.client.config.ConfigManager;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import org.mockito.junit.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class TimeTrackingTest
{

	@Inject
	private TimeTracking timeTracking;

	@Mock
	@Bind
	ConfigManager configManager;

	@Before
	public void before() {
		Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);
		when(configManager.getRSProfileKey()).thenReturn("ABCDEF01");
	}

	@Test
	public void testSetsIntervalsForOldProfiles()
	{
		mockConfigGet(RandomEventAnalyticsConfig.INTERVALS_SINCE_LAST_RANDOM, -1);
		mockConfigGet(RandomEventAnalyticsConfig.TICKS_SINCE_LAST_RANDOM, 0);
		mockConfigGet(RandomEventAnalyticsConfig.SECONDS_IN_INSTANCE, 0);

		int secondsSinceLastSpawn = 60 * 60 * 10;
		mockConfigGet(RandomEventAnalyticsConfig.SECONDS_SINCE_LAST_RANDOM, secondsSinceLastSpawn);

		timeTracking.init(
			Instant.now(),
			null
		);

		Assert.assertEquals(secondsSinceLastSpawn / TimeTracking.SPAWN_INTERVAL_SECONDS, timeTracking.getIntervalsSinceLastRandom());
	}

	@Test
	public void testResetsIntervalsAndSecondsWhenSpawned()
	{
		int secondsSinceLastSpawn = 60 * 60;

		Instant now = Instant.now();
		timeTracking.init(
			Instant.now(),
			now.minus(secondsSinceLastSpawn, ChronoUnit.SECONDS)
		);

		timeTracking.setRandomEventSpawned();

		assertConfigSet(RandomEventAnalyticsConfig.SECONDS_SINCE_LAST_RANDOM, 0);
		assertConfigSet(RandomEventAnalyticsConfig.INTERVALS_SINCE_LAST_RANDOM, 0);
		assertConfigSet(RandomEventAnalyticsConfig.TICKS_SINCE_LAST_RANDOM, 0);
		assertConfigSet(RandomEventAnalyticsConfig.SECONDS_IN_INSTANCE, 0);


		Assert.assertEquals(0, timeTracking.getIntervalsSinceLastRandom());
		Assert.assertEquals(0, timeTracking.getTotalSecondsSinceLastRandomEvent());
	}

	@Test
	public void testResetsIntervalsAndSecondsWhenStrangePlantAccepted()
	{
		int secondsSinceLastSpawn = 60 * 60;
		mockConfigGet(RandomEventAnalyticsConfig.INTERVALS_SINCE_LAST_RANDOM, secondsSinceLastSpawn / TimeTracking.SPAWN_INTERVAL_SECONDS);
		mockConfigGet(RandomEventAnalyticsConfig.TICKS_SINCE_LAST_RANDOM, (int) (secondsSinceLastSpawn * 0.6));
		mockConfigGet(RandomEventAnalyticsConfig.SECONDS_IN_INSTANCE, 0);
		mockConfigGet(RandomEventAnalyticsConfig.SECONDS_SINCE_LAST_RANDOM, secondsSinceLastSpawn);

		Instant loginTime = Instant.now().minus(25, ChronoUnit.MINUTES ); // logged in 25 minutes ago.

		timeTracking.init(
			loginTime,
			loginTime.minus(secondsSinceLastSpawn, ChronoUnit.SECONDS)
		);

		mockConfigGet(RandomEventAnalyticsConfig.INTERVALS_SINCE_LAST_RANDOM,0);

		Instant spawnedInstant = loginTime.plus(10 * 60, ChronoUnit.SECONDS); // 15 minutes ago (10min after login)
		timeTracking.setStrangePlantSpawned(new RandomEventRecord(spawnedInstant.toEpochMilli(), timeTracking, null, null, null));

		Assert.assertEquals(3, timeTracking.getIntervalsSinceLastRandom());
		int newEventSpawnedSeconds = (int) Duration.between(timeTracking.getLastRandomSpawnInstant(), Instant.now()).getSeconds();
		Assert.assertEquals(900, newEventSpawnedSeconds);
		Assert.assertEquals(3, timeTracking.getIntervalsSinceLastRandom());

		Assert.assertEquals(900, timeTracking.getTotalSecondsSinceLastRandomEvent());
	}

	private <T> void mockConfigGet(String key, T returnValue) {
		when(configManager.getRSProfileConfiguration(RandomEventAnalyticsConfig.CONFIG_GROUP, key, int.class)).thenReturn(returnValue);
	}

	private <T> void assertConfigSet(String key, T value) {
		verify(configManager).setRSProfileConfiguration(RandomEventAnalyticsConfig.CONFIG_GROUP, key, value);
	}
}

package com.randomEventAnalytics;

import com.google.inject.Inject;
import com.randomEventAnalytics.localstorage.RandomEventRecord;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Font;
import java.awt.GridLayout;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.ProgressBar;
import net.runelite.client.util.ImageUtil;

public class RandomEventAnalyticsPanel extends PluginPanel
{
	private final ArrayList<RandomEventRecordBox> infoBoxes = new ArrayList<RandomEventRecordBox>();
	private final ProgressBar spawnTimeProgressBar = new ProgressBar();
	private final JPanel estimationPanel = new JPanel();
	@Getter
	private final JComponent eventPanel = new JPanel();
	private final RandomEventAnalyticsConfig config;
	private final Client client;
	private final JLabel estimationUntilNext = new JLabel(RandomEventAnalyticsUtil.htmlLabel("Next Event Window: ",
		"--:--"));
	private final JLabel countdownLabel = new JLabel(RandomEventAnalyticsUtil.htmlLabel("Next Event: ", "--:--"));
	private final JLabel numIntervals = new JLabel();
	private final JLabel inInstanceIcon = new JLabel("\u26A0");
	public SimpleDateFormat shortTimeFormat = new SimpleDateFormat("MMM dd, h:mm a");
	public SimpleDateFormat longTimeFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
	TimeTracking timeTracking;
	RandomEventAnalyticsPlugin plugin;

	@Inject
	RandomEventAnalyticsPanel(RandomEventAnalyticsPlugin plugin, RandomEventAnalyticsConfig config,
							  TimeTracking timeTracking, Client client)
	{
		super();
		this.timeTracking = timeTracking;
		this.plugin = plugin;
		this.config = config;
		this.client = client;
		setBorder(new EmptyBorder(6, 6, 6, 6));
		setBackground(ColorScheme.DARK_GRAY_COLOR);
		setLayout(new BorderLayout());

		final JPanel layoutPanel = new JPanel();
		BoxLayout boxLayout = new BoxLayout(layoutPanel, BoxLayout.Y_AXIS);
		layoutPanel.setLayout(boxLayout);
		add(layoutPanel, BorderLayout.NORTH);

		estimationPanel.setBorder(new EmptyBorder(10, 10, 10, 10));
		estimationPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		estimationPanel.setLayout(new BorderLayout());

		final JPanel estimationInfo = new JPanel();
		estimationInfo.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		estimationInfo.setLayout(new GridLayout(3, 1));
		estimationInfo.setBorder(new EmptyBorder(0, 10, 0, 0));

		estimationUntilNext.setFont(FontManager.getRunescapeSmallFont());
		countdownLabel.setFont(FontManager.getRunescapeSmallFont());
		numIntervals.setFont(FontManager.getRunescapeSmallFont());

		estimationInfo.add(new JLabel("Random Event Estimation"));
		estimationInfo.add(estimationUntilNext);
		estimationInfo.add(countdownLabel);
//		estimationInfo.add(numIntervals);

		estimationPanel.add(new JLabel(new ImageIcon(ImageUtil.loadImageResource(getClass(), "estimation_icon.png"))),
			BorderLayout.WEST);

		estimationPanel.add(estimationInfo);
		setupInInstanceIcon();
		estimationPanel.add(inInstanceIcon, BorderLayout.EAST);

		JPanel progressWrapper = new JPanel();
		progressWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		// https://github.com/runelite/runelite/blob/master/runelite-client/src/main/java/net/runelite/client/plugins/xptracker/XpInfoBox.java#L277
		progressWrapper.setBorder(new EmptyBorder(10, 0, 0, 0));
		progressWrapper.setLayout(new BorderLayout());

		spawnTimeProgressBar.setMaximumValue(TimeTracking.SPAWN_INTERVAL_SECONDS);
		spawnTimeProgressBar.setBackground(ColorScheme.DARK_GRAY_COLOR);
		spawnTimeProgressBar.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
		progressWrapper.add(spawnTimeProgressBar);

		estimationPanel.add(progressWrapper, BorderLayout.SOUTH);

		layoutPanel.add(estimationPanel);

		eventPanel.setLayout(new BoxLayout(eventPanel, BoxLayout.Y_AXIS));
		eventPanel.setBorder(new EmptyBorder(10, 0, 0, 0));
		layoutPanel.add(eventPanel, BorderLayout.SOUTH);
		updateConfig();
	}

	private void setupInInstanceIcon()
	{
		inInstanceIcon.setVisible(false);
		inInstanceIcon.setFont(new Font(Font.DIALOG, Font.PLAIN, 12));
		inInstanceIcon.setForeground(Color.RED);
		// Technically they can spawn in houses (I wonder what other instances.)
		inInstanceIcon.setToolTipText("You are currently in an instance where random events may not spawn.");
	}

	public void eventRecordBoxUpdated(RandomEventRecordBox randomEventRecordBox, boolean isConfirmed)
	{
		eventPanel.remove(randomEventRecordBox);
		if (isConfirmed)
		{
			plugin.addRandomEvent(randomEventRecordBox.getRandomEvent());
		}
		infoBoxes.remove(randomEventRecordBox);
		eventPanel.revalidate();
		eventPanel.repaint();
	}

	public void clearAllRandomsView()
	{
		eventPanel.removeAll();
		infoBoxes.clear();
		eventPanel.repaint();
	}

	public void addRandom(RandomEventRecord record)
	{
		SwingUtilities.invokeLater(() -> {
			RandomEventRecordBox recordBox = new RandomEventRecordBox(this, record);
			eventPanel.add(recordBox, 0);
			infoBoxes.add(recordBox);
		});
	}

	public void addUnconfirmedRandom(RandomEventRecord record)
	{
		SwingUtilities.invokeLater(() -> {
			RandomEventRecordBox recordBox = new RandomEventRecordBox(this, record, false);
			eventPanel.add(recordBox, 0);
			infoBoxes.add(recordBox);
		});
	}

	public void updateConfig()
	{
		spawnTimeProgressBar.setVisible(config.enableEstimation());
		estimationUntilNext.setVisible(config.enableEstimation());
		countdownLabel.setVisible(config.enableConfigCountdown());
		if (config.timeFormatMode() == TimeFormat.TIME_12H) {
			shortTimeFormat = new SimpleDateFormat("MMM dd, h:mm a");
			longTimeFormat = new SimpleDateFormat("yyyy-MM-dd h:mm:ss a");
		} else {
			shortTimeFormat = new SimpleDateFormat("MMM dd, HH:mm");
			longTimeFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		}

	}

	public void updateAllRandomEventBoxes() {
		infoBoxes.forEach(RandomEventRecordBox::update);
	}

	public void updateEstimation()
	{
		if (!config.enableEstimation() && !config.enableConfigCountdown())
		{
			return;
		}

		spawnTimeProgressBar.setValue(Math.abs(TimeTracking.SPAWN_INTERVAL_SECONDS - timeTracking.getNextRandomEventEstimation()));
//		spawnTimeProgressBar.setCenterLabel(timeTracking.getProbabilityForNextWindow() * 100 + "% Chance This Interval");
//		numIntervals.setText(String.valueOf(timeTracking.getIntervalsSinceLastRandom()));

		SwingUtilities.invokeLater(() -> {
			int estimatedSeconds = timeTracking.getNextRandomEventEstimation();
			inInstanceIcon.setVisible(client.isInInstancedRegion());
			estimationUntilNext.setText(RandomEventAnalyticsUtil.htmlLabel("Next Event Window: ",
				RandomEventAnalyticsUtil.formatSeconds(Math.abs(estimatedSeconds))));
			estimationUntilNext.setToolTipText("Intervals: " + timeTracking.getIntervalsSinceLastRandom());
			countdownLabel.setText(RandomEventAnalyticsUtil.htmlLabel("Next Event: ",
				RandomEventAnalyticsUtil.formatSeconds(Math.abs(timeTracking.getCountdownSeconds(config.countdownMinutes())))));
		});
	}
}

package com.randomEventAnalytics;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;

@ConfigGroup(RandomEventAnalyticsConfig.CONFIG_GROUP)
public interface RandomEventAnalyticsConfig extends Config
{
	String CONFIG_GROUP = "randomeventanalytics";
	String SECONDS_SINCE_LAST_RANDOM = "secondsSinceLastRandom";
	String TICKS_SINCE_LAST_RANDOM = "ticksSinceLastRandom";
	String SECONDS_IN_INSTANCE = "secondsInInstance";
	String LAST_RANDOM_SPAWN_INSTANT = "lastRandomSpawnInstant";
	String INTERVALS_SINCE_LAST_RANDOM = "intervalsSinceLastRandom";
	@ConfigSection(
		name = "Countdown",
		description = "Logged-in countdown configuration",
		position = 1,
		closedByDefault = false
	)
	String countdownSection = "countdown";
	@ConfigSection(
		name = "Logging Panel",
		description = "Settings related to the logging panel",
		position = 2,
		closedByDefault = false
	)
	String loggingPanelSection = "loggingPanelSection";
	@ConfigSection(
		name = "Experimental",
		description = "Experimental features. May have a negative impact on performance.",
		position = 3,
		closedByDefault = true
	)
	String experimentalSection = "experimental";


//	@ConfigSection(
//		name = "Notifications",
//		description = "Notifications for Random Event timing & activity",
//		position = 0,
//		closedByDefault = true
//	)
//	String notificationSection = "notifications";

	@ConfigItem(
		keyName = "enableEstimation",
		name = "Enable Estimation",
		description = "Shows a 5 minute sliding timer for events."
	)
	default boolean enableEstimation()
	{
		return true;
	}

	@ConfigItem(
		keyName = "enableOverlay",
		name = "Enable Overlay",
		description = "Show the Random Events overlay."
	)
	default boolean enableOverlay()
	{
		return false;
	}

	@ConfigItem(
		keyName = "enableConfigCountdown",
		name = "Enable Countdown",
		description = "Enables the time since last random countdown",
		section = countdownSection
	)
	default boolean enableConfigCountdown()
	{
		return true;
	}

	@ConfigItem(
		keyName = "logTimeFormat",
		name = "Time Format",
		description = "Configures time between 12 or 24 hour time format",
		section = loggingPanelSection
	)
	default TimeFormat timeFormatMode()
	{
		return TimeFormat.TIME_24H;
	}

	@Range(min = 1)
	@ConfigItem(
		keyName = "countdownMinutes",
		name = "Countdown (Minutes)",
		description = "Number of minutes the countdown should last",
		section = countdownSection
	)
	default int countdownMinutes()
	{
		return 60;
	}

	@ConfigItem(
		keyName = "showDebug",
		name = "Show Debug",
		description = "Shows debug information in the overlay.",
		section = experimentalSection
	)
	default boolean showDebug()
	{
		return false;
	}
}

package com.randomEventAnalytics;

import java.math.RoundingMode;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import javax.swing.ImageIcon;
import lombok.AllArgsConstructor;
import lombok.Data;
import net.runelite.api.NpcID;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.QuantityFormatter;

public class RandomEventAnalyticsUtil
{

	public static final HashMap<Integer, NpcIdWrapper> NPCS = new HashMap<Integer, NpcIdWrapper>()
	{
		{
			put(NpcID.BEE_KEEPER_6747,
				new NpcIdWrapper(
					new ImageIcon(ImageUtil.loadImageResource(RandomEventAnalyticsPlugin.class, "chatheads" +
						"/bee_keeper" +
						".png")),
					false,
					true)
			);
			put(NpcID.CAPT_ARNAV,
				new NpcIdWrapper(
					new ImageIcon(ImageUtil.loadImageResource(RandomEventAnalyticsPlugin.class, "chatheads" +
						"/capt_arnav" +
						".png")),
					true,
					true
				)
			);
			put(NpcID.DRUNKEN_DWARF,
				new NpcIdWrapper(
					new ImageIcon(ImageUtil.loadImageResource(RandomEventAnalyticsPlugin.class, "chatheads" +
						"/drunken_dwarf.png")),
					true,
					true
				)
			);
			put(NpcID.FLIPPA_6744,
				new NpcIdWrapper(
					new ImageIcon(ImageUtil.loadImageResource(RandomEventAnalyticsPlugin.class, "chatheads/flippa" +
						".png")),
					false,
					true
				)
			);

			NpcIdWrapper giles = new NpcIdWrapper(
				new ImageIcon(ImageUtil.loadImageResource(RandomEventAnalyticsPlugin.class, "chatheads/giles.png")),
				true,
				true
			);
			put(NpcID.GILES, giles);
			put(NpcID.GILES_5441, giles);

			NpcIdWrapper miles = new NpcIdWrapper(
				new ImageIcon(ImageUtil.loadImageResource(RandomEventAnalyticsPlugin.class, "chatheads/miles.png")),
				true,
				true
			);
			put(NpcID.MILES, miles);
			put(NpcID.MILES_5440, miles);

			NpcIdWrapper niles = new NpcIdWrapper(
				new ImageIcon(ImageUtil.loadImageResource(RandomEventAnalyticsPlugin.class, "chatheads/niles.png")),
				true,
				true
			);
			put(NpcID.NILES, niles);
			put(NpcID.NILES_5439, niles);

			put(NpcID.PILLORY_GUARD,
				new NpcIdWrapper(
					new ImageIcon(ImageUtil.loadImageResource(RandomEventAnalyticsPlugin.class, "chatheads" +
						"/pillory_guard.png")),
					false,
					true
				)
			);
			put(NpcID.POSTIE_PETE_6738,
				new NpcIdWrapper(
					new ImageIcon(ImageUtil.loadImageResource(RandomEventAnalyticsPlugin.class, "chatheads" +
						"/postie_pete" +
						".png")),
					false,
					true
				)
			);

			NpcIdWrapper rickTurpentine = new NpcIdWrapper(
				new ImageIcon(ImageUtil.loadImageResource(RandomEventAnalyticsPlugin.class, "chatheads" +
					"/rick_turpentine" +
					".png")),
				true,
				true
			);
			put(NpcID.RICK_TURPENTINE, rickTurpentine);
			put(NpcID.RICK_TURPENTINE_376, rickTurpentine);

			put(NpcID.SERGEANT_DAMIEN_6743, new NpcIdWrapper(
				new ImageIcon(ImageUtil.loadImageResource(RandomEventAnalyticsPlugin.class, "chatheads" +
					"/sergeant_damien" +
					".png")),
				false,
				true
			));
			put(NpcID.FREAKY_FORESTER_6748, new NpcIdWrapper(
				new ImageIcon(ImageUtil.loadImageResource(RandomEventAnalyticsPlugin.class, "chatheads" +
					"/freaky_forester" +
					".png")),
				false,
				true
			));
			put(NpcID.FROG_5429, new NpcIdWrapper(
				new ImageIcon(ImageUtil.loadImageResource(RandomEventAnalyticsPlugin.class, "chatheads/frog.png")),
				true,
				true
			));

			NpcIdWrapper genie = new NpcIdWrapper(
				new ImageIcon(ImageUtil.loadImageResource(RandomEventAnalyticsPlugin.class, "chatheads/genie.png")),
				true,
				true
			);
			put(NpcID.GENIE, genie);
			put(NpcID.GENIE_327, genie);

			NpcIdWrapper drJekyll = new NpcIdWrapper(
				new ImageIcon(ImageUtil.loadImageResource(RandomEventAnalyticsPlugin.class, "chatheads/dr_jekyll" +
					".png")),
				true,
				false
			);
			put(NpcID.DR_JEKYLL, drJekyll);
			put(NpcID.DR_JEKYLL_314, drJekyll);

			NpcIdWrapper evilBob = new NpcIdWrapper(
				new ImageIcon(ImageUtil.loadImageResource(RandomEventAnalyticsPlugin.class, "chatheads/evil_bob.png")),
				false,
				true
			);
			put(NpcID.EVIL_BOB, evilBob);
			put(NpcID.EVIL_BOB_6754, evilBob); // Pete

			put(NpcID.LEO_6746, new NpcIdWrapper(
				new ImageIcon(ImageUtil.loadImageResource(RandomEventAnalyticsPlugin.class, "chatheads/leo.png")),
				false,
				true
			));

			NpcIdWrapper mysteriousOldMan = new NpcIdWrapper(
				new ImageIcon(ImageUtil.loadImageResource(RandomEventAnalyticsPlugin.class, "chatheads" +
					"/mysterious_old_man.png")),
				true,
				true
			);
			// TODO: Determine which of these are maze/mime to better describe "isAvailableInWilderness"
			put(NpcID.MYSTERIOUS_OLD_MAN_6750, mysteriousOldMan); // Rick Turpentine style
			put(NpcID.MYSTERIOUS_OLD_MAN_6751, mysteriousOldMan);
			put(NpcID.MYSTERIOUS_OLD_MAN_6752, mysteriousOldMan); // Maze
			put(NpcID.MYSTERIOUS_OLD_MAN_6753, mysteriousOldMan); // Mime

			put(NpcID.QUIZ_MASTER_6755, new NpcIdWrapper(
				new ImageIcon(ImageUtil.loadImageResource(RandomEventAnalyticsPlugin.class, "chatheads/quiz_master" +
					".png")),
				false,
				true
			));
			put(NpcID.DUNCE_6749, new NpcIdWrapper(
				new ImageIcon(ImageUtil.loadImageResource(RandomEventAnalyticsPlugin.class, "chatheads/dunce.png")),
				false,
				true
			));
			put(NpcID.SANDWICH_LADY, new NpcIdWrapper(
				new ImageIcon(ImageUtil.loadImageResource(RandomEventAnalyticsPlugin.class, "chatheads/sandwich_lady" +
					".png")),
				true,
				true
			));
			put(NpcID.STRANGE_PLANT, new NpcIdWrapper(
				new ImageIcon(ImageUtil.loadImageResource(RandomEventAnalyticsPlugin.class, "chatheads/strange_plant" +
					".png")),
				true,
				false
			));
			NpcIdWrapper countCheck = new NpcIdWrapper(
				new ImageIcon(ImageUtil.loadImageResource(RandomEventAnalyticsPlugin.class, "chatheads/count_check" +
					".png")),
				false, // TODO: Unsure if he is available in wilderness, but this flag is currently unused.
				true
			);
			put(NpcID.COUNT_CHECK_12551, countCheck);
			put(NpcID.COUNT_CHECK_12552, countCheck);
		}
	};
	static final DecimalFormat TWO_DECIMAL_FORMAT = new DecimalFormat("0.00");
	private static final String HTML_LABEL_TEMPLATE =
		"<html><body style='color:%s'>%s<span style='color:white'>%s</span></body></html>";
	private static final ImageIcon unknownNPC =
		new ImageIcon(ImageUtil.loadImageResource(RandomEventAnalyticsPlugin.class, "chatheads/question_mark.png"));

	static
	{
		TWO_DECIMAL_FORMAT.setRoundingMode(RoundingMode.DOWN);
	}

	public static Set<Integer> getEventNpcIds()
	{
		return NPCS.keySet();
	}

	public static Set<Integer> getWildernessEventNpcIds()
	{
		return NPCS.entrySet().stream()
			.filter(npcWrapper -> npcWrapper.getValue().isAvailableInWilderness)
			.map(Map.Entry::getKey)
			.collect(Collectors.toSet());
	}

	public static Set<Integer> getF2PEventNpcIds()
	{
		return NPCS.entrySet().stream()
			.filter(npcWrapper -> npcWrapper.getValue().isAvailableF2P)
			.map(Map.Entry::getKey)
			.collect(Collectors.toSet());
	}

	public static String calculateTimeFromTicks(int ticks)
	{
		long seconds = Math.round(ticks * 0.6);
		long durationDays = seconds / (24 * 60 * 60);
		long durationHours = (seconds % (24 * 60 * 60)) / (60 * 60);
		long durationHoursTotal = seconds / (60 * 60);
		long durationMinutes = (seconds % (60 * 60)) / 60;
		long durationSeconds = seconds % 60;
		if (durationHoursTotal > 0)
		{
			return String.format("%02d:%02d:%02d", durationHoursTotal, durationMinutes, durationSeconds);
		}

		// Minutes and seconds will always be present
		return String.format("%02d:%02d", durationMinutes, durationSeconds);
	}

	public static String formatSeconds(int seconds)
	{
		long durationDays = seconds / (24 * 60 * 60);
		long durationHours = (seconds % (24 * 60 * 60)) / (60 * 60);
		long durationHoursTotal = seconds / (60 * 60);
		long durationMinutes = (seconds % (60 * 60)) / 60;
		long durationSeconds = seconds % 60;
		// durationDays = 0 or durationHoursTotal = 0 or goalTimeType = SHORT if we got here.
		// return time remaining in hh:mm:ss or mm:ss format where hh can be > 24
		if (durationHoursTotal > 0)
		{
			return String.format("%02d:%02d:%02d", durationHoursTotal, durationMinutes, durationSeconds);
		}

		// Minutes and seconds will always be present
		return String.format("%02d:%02d", durationMinutes, durationSeconds);
	}

	static String htmlLabel(String key, int value)
	{
		return htmlLabel(key,
			QuantityFormatter.quantityToRSDecimalStack(value, true)
		);
	}

	static String htmlLabel(String key, String value)
	{
		return String.format(HTML_LABEL_TEMPLATE, ColorUtil.toHexColor(ColorScheme.LIGHT_GRAY_COLOR), key, value);
	}

	public static String formatNumber(int value)
	{
		return NumberFormat.getNumberInstance(Locale.US).format(value);
	}

	public static String formatNumber(long value)
	{
		return NumberFormat.getNumberInstance(Locale.US).format(value);
	}

	public static ImageIcon getNPCIcon(int id)
	{
		NpcIdWrapper npc = NPCS.get(id);
		if (npc == null || npc.icon == null)
		{
			return unknownNPC;
		}
		return npc.icon;
	}

	@Data
	@AllArgsConstructor
	private static class NpcIdWrapper
	{
		ImageIcon icon;
		boolean isAvailableInWilderness;
		boolean isAvailableF2P;
	}
}

package com.randomEventAnalytics;

import com.google.inject.Singleton;
import com.randomEventAnalytics.localstorage.RandomEventRecord;
import java.time.Duration;
import java.time.Instant;
import javax.inject.Inject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;

/*
	Notes:
		Does everyone get a random 5 minutes after their first login after an
		update / server restart?
 */
@Slf4j
@Singleton
public class TimeTracking
{
	public static final int SPAWN_INTERVAL_SECONDS = 60 * 5;
	private static final int SPAWN_INTERVAL_MARGIN_SECONDS = 0;
	private static final int SPAWN_INTERVAL_TIMEFRAME_SECONDS = 15;
	public static final int SECONDS_IN_AN_HOUR = 60 /*seconds in a minute*/ * 60 /*minutes in an hour*/;

	private int sessionTicks;

	@Getter
	private Instant lastRandomSpawnInstant;

	@Getter
	private Instant loginTime;

	@Inject
	private ConfigManager configManager;

	public void init(Instant loginTime, Instant lastRandomSpawnInstant)
	{
		this.loginTime = loginTime;
		this.lastRandomSpawnInstant = lastRandomSpawnInstant;
	}

	public int getTotalSecondsSinceLastRandomEvent()
	{
		if (this.loginTime == null)
		{
			return getConfigSecondsSinceLastRandom();
		}

		if (this.lastRandomSpawnInstant != null && this.lastRandomSpawnInstant.isAfter(this.loginTime))
		{
			return (int) Duration.between(this.lastRandomSpawnInstant, Instant.now()).toMillis() / 1000;
		}

		Duration duration = Duration.between(this.loginTime, Instant.now());
		return getConfigSecondsSinceLastRandom() + (int) duration.getSeconds();
	}

	public void onTick()
	{
		sessionTicks += 1;

	}

	public boolean hasLoggedInLongEnoughForSpawn()
	{
		return getSecondsSinceLogin() > SPAWN_INTERVAL_SECONDS;
	}

	public int getSecondsSinceLogin()
	{
		if (loginTime == null)
		{
			return -1;
		}
		return (int) Duration.between(loginTime, Instant.now()).toMillis() / 1000;
	}

	public int getNextRandomEventEstimation()
	{
		int loginTime = getSecondsSinceLogin();

		if (loginTime < 0)
		{
			return SPAWN_INTERVAL_SECONDS;
		}

		if (!hasLoggedInLongEnoughForSpawn())
		{
			// Initial login, must wait 5 minutes
			return SPAWN_INTERVAL_SECONDS - loginTime;
		}

		int secondsMod = loginTime % SPAWN_INTERVAL_SECONDS;
		if (secondsMod <= SPAWN_INTERVAL_MARGIN_SECONDS)
		{
			// Event should spawn within a 15-second window of 5 minutes.
			return -secondsMod;
		}

		// The event will spawn around the next 5-minute period.
		return SPAWN_INTERVAL_SECONDS - secondsMod;
	}

	private boolean isInsideRandomEventWindow()
	{
		int loginTime = getSecondsSinceLogin();
		int secondsMod = loginTime % SPAWN_INTERVAL_SECONDS;
		// If we're within 15 seconds of an event window, it's considered a possible time.
		return secondsMod <= SPAWN_INTERVAL_TIMEFRAME_SECONDS || secondsMod >= SPAWN_INTERVAL_SECONDS - SPAWN_INTERVAL_TIMEFRAME_SECONDS;
	}

	public boolean isPossibleTimeForRandomEvent()
	{
		if (lastRandomSpawnInstant == null)
		{
			return isInsideRandomEventWindow();
		}

		if (!hasLoggedInLongEnoughForSpawn())
		{
			return false;
		}

		if (getTotalSecondsSinceLastRandomEvent() <  SECONDS_IN_AN_HOUR)
		{
			// There's a minimum of an hour between random events.
			return false;
		}

		return isInsideRandomEventWindow();
	}

	public void setRandomEventSpawned()
	{
		lastRandomSpawnInstant = Instant.now();
		sessionTicks = 0;
		setConfigAfterSpawn();
	}

	public void setStrangePlantSpawned(RandomEventRecord record)
	{
		lastRandomSpawnInstant = Instant.ofEpochMilli(record.spawnedTime);
		sessionTicks = 0;
		setConfigAfterSpawn();
	}

	public void setLoginTime(Instant instant)
	{
		this.loginTime = instant;
	}


	private Instant getMostRecentInstant()
	{
		if (loginTime == null)
		{
			return null;
		}
		if (lastRandomSpawnInstant == null)
		{
			return loginTime;
		}
		if (lastRandomSpawnInstant.isAfter(loginTime))
		{
			return lastRandomSpawnInstant;
		}
		return loginTime;
	}

	public int getIntervalsSinceLastRandom()
	{
		if (getMostRecentInstant() == null)
		{
			return getConfigIntervalsSinceLastRandom();
		}
		else
		{
			int sessionDuration = (int) Duration.between(getMostRecentInstant(), Instant.now()).getSeconds();
			return getConfigIntervalsSinceLastRandom() + (sessionDuration / SPAWN_INTERVAL_SECONDS);
		}
	}

	public int getTicksSinceLastRandomEvent()
	{
		return this.getConfigTicksSinceLastRandom() + this.sessionTicks;
	}

	// TODO: Rework how instances are calculated
	public int getSecondsInInstance()
	{
		return this.getConfigSecondsInInstance();
	}

	public int getCountdownSeconds(int numMinutesPerRandom)
	{
		return (numMinutesPerRandom * 60) - this.getTotalSecondsSinceLastRandomEvent();
	}

	public double getProbabilityForNextWindow() {
		int intervalsAfterHour = this.getIntervalsSinceLastRandom() - (60 / 5);
		if (intervalsAfterHour < 0) {
			return 0;
		}
		return ((double) intervalsAfterHour)/12;
	}


	private int getConfigIntervalsSinceLastRandom()
	{
		int configIntervals = getIntFromConfig(RandomEventAnalyticsConfig.INTERVALS_SINCE_LAST_RANDOM, -1);
		if (configIntervals == -1)
		{
			// One-time Update: Should only need to be set once per profile config.
			configIntervals = getTotalSecondsSinceLastRandomEvent() / SPAWN_INTERVAL_SECONDS;
		}
		return configIntervals;
	}

	private int getConfigTicksSinceLastRandom()
	{
		return getIntFromConfig(RandomEventAnalyticsConfig.TICKS_SINCE_LAST_RANDOM, 0);
	}

	private int getConfigSecondsSinceLastRandom()
	{
		return getIntFromConfig(RandomEventAnalyticsConfig.SECONDS_SINCE_LAST_RANDOM, 0);
	}

	private int getConfigSecondsInInstance()
	{
		return getIntFromConfig(RandomEventAnalyticsConfig.SECONDS_IN_INSTANCE, -1);
	}

	public void persistConfig()
	{
		saveConfig(RandomEventAnalyticsConfig.SECONDS_SINCE_LAST_RANDOM, getTotalSecondsSinceLastRandomEvent());
		saveConfig(RandomEventAnalyticsConfig.INTERVALS_SINCE_LAST_RANDOM, getIntervalsSinceLastRandom());
		saveConfig(RandomEventAnalyticsConfig.TICKS_SINCE_LAST_RANDOM, getTicksSinceLastRandomEvent());
		saveConfig(RandomEventAnalyticsConfig.SECONDS_IN_INSTANCE, getSecondsInInstance());
		if (lastRandomSpawnInstant != null)
		{
			saveConfig(RandomEventAnalyticsConfig.LAST_RANDOM_SPAWN_INSTANT, lastRandomSpawnInstant);
		}
	}

	public void setConfigAfterSpawn()
	{
		saveConfig(RandomEventAnalyticsConfig.SECONDS_SINCE_LAST_RANDOM, 0);
		saveConfig(RandomEventAnalyticsConfig.INTERVALS_SINCE_LAST_RANDOM, 0);
		saveConfig(RandomEventAnalyticsConfig.TICKS_SINCE_LAST_RANDOM, 0);
		saveConfig(RandomEventAnalyticsConfig.SECONDS_IN_INSTANCE, 0);
		if (lastRandomSpawnInstant != null)
		{
			saveConfig(RandomEventAnalyticsConfig.LAST_RANDOM_SPAWN_INSTANT, lastRandomSpawnInstant);
		}
	}

	private <T> void saveConfig(String key, T value)
	{
		try
		{
			configManager.setRSProfileConfiguration(RandomEventAnalyticsConfig.CONFIG_GROUP,
				key, value);
		} catch (NullPointerException e) {
			log.debug("Error setting config {}: {} | ConfigManager most likely not set", key, value);
		}
	}

	private int getIntFromConfig(String key, int _default)
	{
		try
		{
			return configManager.getRSProfileConfiguration(RandomEventAnalyticsConfig.CONFIG_GROUP, key, int.class);
		}
		catch (NullPointerException e)
		{
			try
			{
				log.debug("No config loaded for: {}@{}", key, configManager.getRSProfileKey());
				return _default;
			} catch (NullPointerException configError) {
				log.debug("Error loading configManager");
				return _default;
			}
		}
	}
}

package com.randomEventAnalytics;

import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;

public class RandomEventAnalyticsOverlay extends Overlay
{
	private static final String TIME_UNTIL_LABEL = "Estimate: ";
	private static final String OVERESTIMATE_LABEL = "Overestimate: ";
	private static final String TITLE_LABEL = "Random Event";
	private final RandomEventAnalyticsConfig config;
	private final PanelComponent panelComponent = new PanelComponent();
	private final TimeTracking timeTracking;
	private final RandomEventAnalyticsPlugin plugin;

	@Inject
	private RandomEventAnalyticsOverlay(RandomEventAnalyticsConfig config,
										TimeTracking timeTracking, RandomEventAnalyticsPlugin plugin)
	{
		setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
		this.config = config;
		this.timeTracking = timeTracking;
		this.plugin = plugin;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!config.enableOverlay())
		{
			return null;
		}
		panelComponent.getChildren().clear();

		if (config.enableEstimation())
		{
			int closestSpawnTimer = timeTracking.getNextRandomEventEstimation();
			panelComponent.getChildren().add(LineComponent.builder()
				.left(timeTracking.hasLoggedInLongEnoughForSpawn() ? "Random Event Eligible In" : "Initial login " +
					"countdown." +
					"..")
				.right(RandomEventAnalyticsUtil.formatSeconds(Math.abs(closestSpawnTimer)))
				.build());
		}

		if (config.enableConfigCountdown())
		{
			int estimatedSeconds = timeTracking.getCountdownSeconds(config.countdownMinutes());
			panelComponent.getChildren().add(LineComponent.builder()
				.left(estimatedSeconds >= 0 ? TIME_UNTIL_LABEL : OVERESTIMATE_LABEL)
				.right(RandomEventAnalyticsUtil.formatSeconds(Math.abs(estimatedSeconds)))
				.build());
		}


		if (config.showDebug())
		{
			panelComponent.getChildren().add(LineComponent.builder()
				.left("Ticks: ")
				.right(String.valueOf(timeTracking.getTicksSinceLastRandomEvent()))
				.build());

			panelComponent.getChildren().add(LineComponent.builder()
				.left("Intervals: ")
				.right(String.valueOf(timeTracking.getIntervalsSinceLastRandom()))
				.build());

			panelComponent.getChildren().add(LineComponent.builder()
				.left("# of Events Logged: ")
				.right(String.valueOf(plugin.getNumberOfEventsLogged()))
				.build());
		}

		return panelComponent.render(graphics);
	}
}

package com.randomEventAnalytics;

import com.randomEventAnalytics.localstorage.RandomEventRecord;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Font;
import java.awt.GridLayout;
import java.text.SimpleDateFormat;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

public class RandomEventRecordBox extends JPanel
{
	private final RandomEventAnalyticsPanel panel;
	private final RandomEventRecord randomEvent;

	private final JLabel spawnedTimeLabel = new JLabel();

	RandomEventRecordBox(RandomEventAnalyticsPanel panel, RandomEventRecord randomEvent)
	{
		this(panel, randomEvent, true);
	}

	RandomEventRecordBox(RandomEventAnalyticsPanel panel, RandomEventRecord randomEvent, boolean isConfirmed)
	{
		this.randomEvent = randomEvent;
		this.panel = panel;
		buildRandomEventPanel(randomEvent, isConfirmed);
	}

	private String buildToolTip(RandomEventRecord record)
	{
		String spawnedTime = panel.longTimeFormat.format(record.spawnedTime);
		String data =
			"<html> " + "NPC ID: " + record.npcInfoRecord.npcId + "<br>\u0394 Event Time: " + RandomEventAnalyticsUtil.formatSeconds(record.secondsSinceLastRandomEvent) + "<br>Spawned Time: " + spawnedTime;
		data += "<br>PlayerLocal: <p style=\"font-size: 0.95em\">" + "(X: " + record.playerInfoRecord.localX + " , Y: "
			+ record.playerInfoRecord.localY + ")</p>";
		data += "Intervals: ";
		if (record.intervalsSinceLastRandom > 0)
		{
			data += record.intervalsSinceLastRandom + "<p style=\"font-size: 0.95em\">(" + record.intervalsSinceLastRandom * 5 + " minutes)</p>";
		} else {
			data += "Record has no data<br>";
		}
		data += "World: <p style=\"font-size: 0.95em\">" + "(X: " + record.playerInfoRecord.worldX + " , Y: " + record.playerInfoRecord.worldY + " , P: " + record.playerInfoRecord.worldPlane + ")</p>";
		data += "</html>";
		return data;

	}

	public RandomEventRecord getRandomEvent()
	{
		return randomEvent;
	}

	private JPanel buildRandomEventPanel(RandomEventRecord record, boolean isConfirmed)
	{
		JLabel randomName = new JLabel(record.npcInfoRecord.npcName);
		spawnedTimeLabel.setText(panel.shortTimeFormat.format(record.spawnedTime));

		this.setBorder(new EmptyBorder(10, 10, 10, 10));
		this.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		this.setLayout(new BorderLayout());

		JPanel randomInfo = new JPanel();
		randomInfo.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		randomInfo.setLayout(new GridLayout(2, 1));
		randomInfo.setBorder(new EmptyBorder(0, 10, 0, 0));

		randomName.setFont(FontManager.getRunescapeBoldFont());
		spawnedTimeLabel.setFont(FontManager.getRunescapeSmallFont());
		randomInfo.add(randomName);
		randomInfo.add(spawnedTimeLabel);

		this.add(new JLabel(RandomEventAnalyticsUtil.getNPCIcon(record.npcInfoRecord.npcId)), BorderLayout.WEST);
		this.add(randomInfo);
		this.setToolTipText(buildToolTip(record));
		if (!isConfirmed)
		{
			this.add(buildConfirmationPanel(record));
		}
		update();
		return this;
	}

	private JPanel buildConfirmationPanel(RandomEventRecord record)
	{
		JPanel confirmationPanel = new JPanel();
		confirmationPanel.setBorder(new EmptyBorder(0, 0, 0, 0));
		confirmationPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		confirmationPanel.setLayout(new BorderLayout());
		JLabel confirmRandomLabel = new JLabel("Is this your random event?");
		JButton confirm = new JButton("\u2713");
		confirm.setFont(new Font(Font.DIALOG, Font.PLAIN, 12));
		confirm.setForeground(Color.GREEN);
		confirm.addActionListener((e) -> {
			SwingUtilities.invokeLater(() -> {
				panel.eventRecordBoxUpdated(this, true);
			});
		});
		JButton cancel = new JButton("\u2717");
		cancel.setFont(new Font(Font.DIALOG, Font.PLAIN, 12));
		cancel.setForeground(Color.RED);
		cancel.addActionListener((e) -> {
			panel.eventRecordBoxUpdated(this, false);
		});
		confirmationPanel.add(confirmRandomLabel, BorderLayout.NORTH);
		confirmationPanel.add(confirm, BorderLayout.WEST);
		confirmationPanel.add(cancel, BorderLayout.EAST);
		return confirmationPanel;
	}

	void update() {
		// TODO: We'll eventually want to update the rest of the values, but
		//		for now just the spawned time (when config changed)
		spawnedTimeLabel.setText(panel.shortTimeFormat.format(randomEvent.spawnedTime));
		this.setToolTipText(buildToolTip(randomEvent));
	}
}

package com.randomEventAnalytics;

import com.google.inject.Provides;
import com.randomEventAnalytics.localstorage.NpcInfoRecord;
import com.randomEventAnalytics.localstorage.PlayerInfoRecord;
import com.randomEventAnalytics.localstorage.RandomEventAnalyticsLocalStorage;
import com.randomEventAnalytics.localstorage.RandomEventRecord;
import com.randomEventAnalytics.localstorage.XpInfoRecord;
import java.awt.image.BufferedImage;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import javax.inject.Inject;
import javax.swing.SwingUtilities;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;
import net.runelite.api.Player;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.InteractingChanged;
import net.runelite.api.events.NpcSpawned;
import net.runelite.client.Notifier;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ClientShutdown;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.xptracker.XpTrackerPlugin;
import net.runelite.client.plugins.xptracker.XpTrackerService;
import net.runelite.client.task.Schedule;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;

@Slf4j
@PluginDescriptor(name = "Random Event Analytics")
@PluginDependency(XpTrackerPlugin.class)
public class RandomEventAnalyticsPlugin extends Plugin
{
	private static final int RANDOM_EVENT_TIMEOUT = 150;
	private static final int STRANGE_PLANT_SPAWN_RADIUS = 1;
	private static final String PLANT_SPAWNED_NOTIFICATION_MESSAGE =
		"A Strange Plant has spawned, please visit the Random Event Analytics panel to confirm the random.";
	@Inject
	private ConfigManager configManager;
	@Inject
	private OverlayManager overlayManager;
	@Inject
	private RandomEventAnalyticsOverlay overlay;
	@Inject
	private Client client;
	@Inject
	private RandomEventAnalyticsConfig config;
	@Inject
	private RandomEventAnalyticsLocalStorage localStorage;
	@Inject
	private TimeTracking timeTracking;
	@Inject
	private ClientToolbar clientToolbar;
	@Inject
	private ChatMessageManager chatMessageManager;
	@Inject
	private Notifier notifier;
	@Inject
	private XpTrackerService xpTrackerService;

	@Setter
	private RandomEventAnalyticsPanel panel;
	private String profile;
	private int lastNotificationTick = -RANDOM_EVENT_TIMEOUT;
	private NavigationButton navButton;

	@Provides
	RandomEventAnalyticsConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(RandomEventAnalyticsConfig.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		overlayManager.add(overlay);
		panel = injector.getInstance(RandomEventAnalyticsPanel.class);
		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "random_event_analytics.png");

		navButton =
			NavigationButton.builder().tooltip("Random Event Analytics").icon(icon).panel(panel).priority(7).build();

		clientToolbar.addNavigation(navButton);

		if (!this.isLoggedIn())
		{
			return;
		}
		this.loadConfig();
		loadPreviousRandomEvents();
	}

	@Override
	protected void shutDown()
	{
		persistTimeTrackingConfig();
		lastNotificationTick = 0;
		clientToolbar.removeNavigation(navButton);
		overlayManager.remove(overlay);
	}

	private boolean isLoggedIn()
	{
		return client.getAccountHash() != -1;
	}

	private void loadConfig()
	{
		profile = configManager.getRSProfileKey();
		timeTracking.init(
			Instant.now(),
			getLastRandomSpawnInstant()
		);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged)
	{
		if (!configChanged.getGroup().equals(RandomEventAnalyticsConfig.CONFIG_GROUP))
		{
			return;
		}

		panel.updateConfig();
		if (configChanged.getKey().equals("logTimeFormat")) {
			SwingUtilities.invokeLater(panel::updateAllRandomEventBoxes);
		}
	}

	@Subscribe
	public void onClientShutdown(ClientShutdown event)
	{
		persistTimeTrackingConfig();
	}


	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{

		GameState state = gameStateChanged.getGameState();
		// TODO: Update timeTracking loginTime when relogging.
		if (state == GameState.LOGGED_IN)
		{
			if (timeTracking.getLoginTime() == null)
			{
				timeTracking.setLoginTime(Instant.now());
			}

			final long hash = client.getAccountHash();
			if (String.valueOf(hash).equalsIgnoreCase(localStorage.getUsername()))
			{
				return;
			}

			String username = client.getUsername();
			if (username != null && username.length() > 0)
			{
				localStorage.renameUsernameFolderToAccountHash(username, hash);
			}

			if (localStorage.setPlayerUsername(String.valueOf(hash)))
			{
				this.loadConfig();
				loadPreviousRandomEvents();
			}
		}
		else if (state == GameState.CONNECTION_LOST || state == GameState.UNKNOWN)
		{
			persistTimeTrackingConfig();
		}
		else if (state == GameState.HOPPING)
		{
			persistTimeTrackingConfig();
			timeTracking.setLoginTime(null);
		}
		else if (state == GameState.LOGIN_SCREEN)
		{
			persistTimeTrackingConfig();
			timeTracking.setLoginTime(null);
			panel.updateEstimation();
		}
	}

	private Instant getLastRandomSpawnInstant()
	{
		Instant spawned = getInstantFromProfileConfig(RandomEventAnalyticsConfig.LAST_RANDOM_SPAWN_INSTANT);
		if (spawned != null)
		{
			return spawned;
		}

		// One-time Update: This handles outdated profile config, should only ever need to be called once per profile.
		RandomEventRecord record = localStorage.getMostRecentRandom();
		if (record == null || record.spawnedTime < 0)
		{
			// This assumes the profile failed to load. eg. malformed data, old profile that never had a random spawn, etc.
			// we'll reset the timer.
			return Instant.now();
		}

		return Instant.ofEpochMilli(record.spawnedTime);
	}

	private Instant getInstantFromProfileConfig(String key)
	{
		try
		{
			return configManager.getConfiguration(RandomEventAnalyticsConfig.CONFIG_GROUP, profile, key,
				Instant.class);
		}
		catch (NullPointerException e)
		{
			log.debug("No config loaded for: {}@{}", key, profile);
			return null;
		}
	}

	private synchronized void loadPreviousRandomEvents()
	{
		panel.clearAllRandomsView();
		ArrayList<RandomEventRecord> randomEvents = localStorage.loadRandomEventRecords();
		if (randomEvents.size() > 0)
		{
			randomEvents.forEach(panel::addRandom);
		} else {
			panel.clearAllRandomsView();
		}
	}

	@Subscribe
	public void onInteractingChanged(InteractingChanged event)
	{
		Actor source = event.getSource();
		Actor target = event.getTarget();
		Player player = client.getLocalPlayer();
		// Check that the npc is interacting with the player and the player isn't interacting with the npc, so
		// that the notification doesn't fire from talking to other user's randoms
		if (player == null || target != player || player.getInteracting() == source || !(source instanceof NPC) || !RandomEventAnalyticsUtil.getEventNpcIds().contains(((NPC) source).getId()))
		{
			return;
		}

		/**
		 * This is brought to you by the RandomEventPlugin. It seems sometimes you can
		 * have multiple notifications for a single random, and in our case we can have
		 * the same event added multiple times
		 */
		if (client.getTickCount() - lastNotificationTick > RANDOM_EVENT_TIMEOUT)
		{
			lastNotificationTick = client.getTickCount();
			handleRandomEvent((NPC) source);
		}
	}

	private void handleRandomEvent(NPC npc)
	{
		addRandomEvent(npc);
	}

	@Subscribe
	public void onNpcSpawned(final NpcSpawned event)
	{
		final NPC npc = event.getNpc();
		if (!isStrangePlant(npc.getId()))
		{
			return;
		}
		Player player = client.getLocalPlayer();
		if (player.getWorldLocation().distanceTo(npc.getWorldLocation()) != STRANGE_PLANT_SPAWN_RADIUS)
		{
			return;
		}
		if (!timeTracking.isPossibleTimeForRandomEvent())
		{
			// We only want to notify about strange plants when it's possibly the user's random
			return;
		}
		/**
		 * Unfortunately we cannot determine if the Strange Plant belongs to the player
		 * (See onInteractingChange)
		 * So we need to add an unconfirmed record (UI only) that allows the player to
		 * confirm if the plant belongs to them. Only then will it update the records.
		 */
		RandomEventRecord record = createRandomEventRecord(npc);
		panel.addUnconfirmedRandom(record);
		chatMessageManager.queue(QueuedMessage.builder().type(ChatMessageType.CONSOLE).runeLiteFormattedMessage(PLANT_SPAWNED_NOTIFICATION_MESSAGE).build());
		notifier.notify(PLANT_SPAWNED_NOTIFICATION_MESSAGE);
	}

	@Subscribe
	public void onGameTick(GameTick tick)
	{
		if (client.getGameState() == GameState.LOGGED_IN)
		{
			panel.updateEstimation();
			timeTracking.onTick();
		}
	}

	private void persistTimeTrackingConfig()
	{
		timeTracking.persistConfig();
	}

	public void addRandomEvent(final NPC npc)
	{
		addRandomEvent(createRandomEventRecord(npc));
	}

	public void addRandomEvent(final RandomEventRecord record)
	{
		localStorage.addRandomEventRecord(record);
		panel.addRandom(record);
		/**
		 * The strange plant is added after the confirmation is clicked. This offsets
		 * our timers since the time the plant spawned.
		 */
		if (isStrangePlant(record.npcInfoRecord.npcId))
		{
			timeTracking.setStrangePlantSpawned(record);
		}
		else
		{
			timeTracking.setRandomEventSpawned();
		}
	}

	public int getNumberOfEventsLogged()
	{
		return localStorage.getNumberOfLoggedEvents();
	}

	private RandomEventRecord createRandomEventRecord(final NPC npc)
	{
		Player player = client.getLocalPlayer();
		PlayerInfoRecord playerInfoRecord = PlayerInfoRecord.create(player);
		NpcInfoRecord npcInfoRecord = NpcInfoRecord.create(npc);
		XpInfoRecord xpInfoRecord = XpInfoRecord.create(client, xpTrackerService);
		RandomEventRecord record = new RandomEventRecord(Instant.now().toEpochMilli(), timeTracking, npcInfoRecord,
			playerInfoRecord, xpInfoRecord);
		return record;
	}

	private boolean isStrangePlant(int npcId)
	{
		return npcId == NpcID.STRANGE_PLANT;
	}

	@Schedule(
		period = 500,
		unit = ChronoUnit.MILLIS
	)
	public void updateSchedule()
	{
		if (client.getGameState() == GameState.LOGGED_IN)
		{
			panel.updateEstimation();
		}
	}
}

package com.randomEventAnalytics.localstorage;

import com.randomEventAnalytics.TimeTracking;
import lombok.Data;

@Data
public class RandomEventRecord
{
	// Random event spawned  time
	public final long spawnedTime;
	// Seconds (logged in) since last random event occurred
	public final int secondsSinceLastRandomEvent;
	// Ticks (logged in) since last random event occurred
	public final int ticksSinceLastRandomEvent;
	// Total 5-minute intervals that have passed.
	public final int intervalsSinceLastRandom;
	public final NpcInfoRecord npcInfoRecord;
	public final PlayerInfoRecord playerInfoRecord;
	public final XpInfoRecord xpInfoRecord;
	private final int secondsInInstance;

	public RandomEventRecord(long spawnedTime, TimeTracking timeTracking,
							 NpcInfoRecord npcInfoRecord, PlayerInfoRecord playerInfoRecord, XpInfoRecord xpInfoRecord)
	{
		this.spawnedTime = spawnedTime;
		this.secondsSinceLastRandomEvent = timeTracking.getTotalSecondsSinceLastRandomEvent();
		this.ticksSinceLastRandomEvent = timeTracking.getTicksSinceLastRandomEvent();
		this.secondsInInstance = -1; // TODO: reimplement this at some point. Need more information about spawning in
		// instances.
		this.intervalsSinceLastRandom = timeTracking.getIntervalsSinceLastRandom();
		this.xpInfoRecord = xpInfoRecord;
		this.playerInfoRecord = playerInfoRecord;
		this.npcInfoRecord = npcInfoRecord;
	}
}
package com.randomEventAnalytics.localstorage;

import lombok.AllArgsConstructor;
import lombok.Data;
import net.runelite.api.Player;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;

@Data
@AllArgsConstructor
public class PlayerInfoRecord
{
	public final int combatLevel;
	public final int localX;
	public final int localY;
	public final int worldX;
	public final int worldY;
	public final int worldPlane;

	public static PlayerInfoRecord create(Player player)
	{
		LocalPoint playerLocalLocation = player.getLocalLocation();
		WorldPoint playerWorldLocation = player.getWorldLocation();
		return new PlayerInfoRecord(player.getCombatLevel(), playerLocalLocation.getX(), playerLocalLocation.getY(),
			playerWorldLocation.getX(), playerWorldLocation.getY(), playerWorldLocation.getPlane());
	}
}

/*
 * Copyright (c) 2018
 * 	TheStonedTurtle <https://github.com/TheStonedTurtle>, zmanowar <https://github.com/zmanowar>
 * All rights reserved.
 *
 * Modified source from https://github.com/TheStonedTurtle/Loot-Logger/
 */
package com.randomEventAnalytics.localstorage;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import javax.inject.Inject;
import lombok.Getter;
import static net.runelite.client.RuneLite.RUNELITE_DIR;
import net.runelite.http.api.RuneLiteAPI;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * TODO: Either break the random events into seperate files
 * or implement/import a DB system.
 **/
public class RandomEventAnalyticsLocalStorage
{
	private static final String FILE_EXTENSION = ".log";
	private static final File RANDOM_EVENT_RECORD_DIR = new File(RUNELITE_DIR, "random-event-analytics");
	private static final String RANDOM_EVENTS_FILE = "random-events";
	private static final Logger log = LoggerFactory.getLogger(RandomEventAnalyticsLocalStorage.class);
	private File playerFolder;
	@Getter
	private int numberOfLoggedEvents = 0;
	@Getter
	private String username;

	@Inject
	public RandomEventAnalyticsLocalStorage()
	{
		RANDOM_EVENT_RECORD_DIR.mkdir();
	}


	public boolean setPlayerUsername(final String username)
	{
		if (username.equalsIgnoreCase(this.username))
		{
			return false;
		}

		playerFolder = new File(RANDOM_EVENT_RECORD_DIR, username);
		playerFolder.mkdir();
		this.username = username;
		return true;
	}

	private File getFile(String fileName)
	{
		return new File(playerFolder, fileName + FILE_EXTENSION);
	}

	public synchronized ArrayList<RandomEventRecord> loadRandomEventRecords()
	{
		final File file = getFile(RANDOM_EVENTS_FILE);
		final ArrayList<RandomEventRecord> data = new ArrayList<>();

		try (final BufferedReader br = new BufferedReader(new FileReader(file)))
		{
			String line;
			while ((line = br.readLine()) != null)
			{
				// Skips the empty line at end of file
				if (line.length() > 0)
				{
					final RandomEventRecord r = RuneLiteAPI.GSON.fromJson(line, RandomEventRecord.class);
					data.add(r);
				}
			}

		}
		catch (FileNotFoundException e)
		{
			log.debug("File not found: {}", file.getName());
		}
		catch (IOException e)
		{
			log.warn("IOException for file {}: {}", file.getName(), e.getMessage());
		}

		numberOfLoggedEvents = data.size();
		return data;
	}

	public synchronized RandomEventRecord getMostRecentRandom()
	{
		final ArrayList<RandomEventRecord> data = loadRandomEventRecords();
		if (data.size() > 0)
		{
			return data.get(data.size() - 1);
		}

		return null;
	}

	public synchronized boolean renameUsernameFolderToAccountHash(final String username, final long hash)
	{
		final File usernameDir = new File(RANDOM_EVENT_RECORD_DIR, username);
		if (!usernameDir.exists())
		{
			return true;
		}

		final File hashDir = new File(RANDOM_EVENT_RECORD_DIR, String.valueOf(hash));
		if (hashDir.exists())
		{
			log.warn("Can't rename username folder to account hash as the folder for this account hash already exists" + "." + " This was most likely caused by running RL through the Jagex launcher before the migration code" + " was" + " added");
			log.warn("Username: {} | AccountHash: {}", username, hash);
			return false;
		}

		return usernameDir.renameTo(hashDir);
	}

	public synchronized boolean addRandomEventRecord(RandomEventRecord rec)
	{
		final File randomEventsFile = getFile(RANDOM_EVENTS_FILE);

		// Convert entry to JSON
		final String dataAsString = RuneLiteAPI.GSON.toJson(rec);

		// Open File in append mode and write new data
		try
		{
			final BufferedWriter file = new BufferedWriter(new FileWriter(String.valueOf(randomEventsFile), true));
			file.append(dataAsString);
			file.newLine();
			file.close();
			numberOfLoggedEvents += 1;
			return true;
		}
		catch (IOException ioe)
		{
			log.warn("Error writing loot data to file {}: {}", randomEventsFile.getName(), ioe.getMessage());
			return false;
		}
	}

}

package com.randomEventAnalytics.localstorage;

import lombok.AllArgsConstructor;
import lombok.Data;
import net.runelite.api.NPC;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;

@Data
@AllArgsConstructor
public class NpcInfoRecord
{
	public final int npcId;
	public final String npcName;
	public final int combatLevel;
	public final int localX;
	public final int localY;
	public final int worldX;
	public final int worldY;
	public final int worldPlane;

	public static NpcInfoRecord create(NPC npc)
	{
		LocalPoint npcLocalLocation = npc.getLocalLocation();
		WorldPoint npcWorldLocation = npc.getWorldLocation();
		return new NpcInfoRecord(npc.getId(), npc.getName(), npc.getCombatLevel(), npcLocalLocation.getX(),
			npcLocalLocation.getY(), npcWorldLocation.getX(), npcWorldLocation.getY(), npcWorldLocation.getPlane());
	}
}
package com.randomEventAnalytics.localstorage;

import java.util.HashMap;
import lombok.AllArgsConstructor;
import lombok.Data;
import net.runelite.api.Client;
import net.runelite.api.Skill;
import net.runelite.client.plugins.xptracker.XpTrackerService;

@Data
@AllArgsConstructor
public class XpInfoRecord
{
	public final int totalActionsHr;
	public final int totalXpHr;
	public final String maximumActionsHrSkillName;
	public final int maximumActionsHr;
	public final String maximumXpHrSkillName;
	public final int maximumXpHr;
	public final long overallExperience;
	public final HashMap<String, Integer> xpPerSkill;

	public static XpInfoRecord create(Client client, XpTrackerService xpTrackerService)
	{
		Skill maximumActionsHrSkill = Skill.AGILITY;
		int maximumActionsHr = xpTrackerService.getActionsHr(Skill.AGILITY);
		Skill maximumXpHrSkill = Skill.AGILITY;
		int maximumXpHr = xpTrackerService.getXpHr(Skill.AGILITY);
		int newSkillActionsHr = -1;
		int newSkillXpHr = -1;
		HashMap<String, Integer> xpPerSkill = new HashMap<>();

		for (Skill skill : Skill.values())
		{
			xpPerSkill.put(skill.getName(), client.getSkillExperience(skill));
			newSkillActionsHr = xpTrackerService.getActionsHr(skill);
			newSkillXpHr = xpTrackerService.getXpHr(skill);
			if (newSkillActionsHr > xpTrackerService.getActionsHr(maximumActionsHrSkill))
			{
				maximumActionsHrSkill = skill;
				maximumActionsHr = newSkillActionsHr;
			}
			if (newSkillXpHr > xpTrackerService.getXpHr(maximumXpHrSkill))
			{
				maximumXpHrSkill = skill;
				maximumXpHr = newSkillXpHr;
			}
		}
		// TODO: Poll & Remove/consolidate most of the XP tracking as it's unnecessary.
		return new XpInfoRecord(
			0, // deprecated overall
			0,  // deprecated overall
			maximumActionsHrSkill.getName(),
			maximumActionsHr,
			maximumXpHrSkill.getName(),
			maximumXpHr,
			client.getOverallExperience(),
			xpPerSkill
		);
	}
}

package com.randomEventAnalytics;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum TimeFormat
{
	TIME_12H("12-hour"),
	TIME_24H("24-hour");

	private final String name;

	@Override
	public String toString()
	{
		return this.name;
	}
}

