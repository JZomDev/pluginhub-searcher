package com.deepseatrawling;

import java.util.HashMap;
import java.util.Map;

public enum ShoalTypes {
    GIANT_KRILL(26, 27, 28, 29),
    HADDOCK(23, 24, 25),
    YELLOWFIN(20, 21, 22),
    HALIBUT(18, 19),
    BLUEFIN(16, 17),
    MARLIN(14, 15);

    private static final Map<Integer, ShoalTypes> SHOAL_ID = new HashMap<>();

    static {
        for (ShoalTypes type : values()) {
            for (int id : type.ids) {
                SHOAL_ID.put(id, type);
            }
        }
    }

    private final int[] ids;

    ShoalTypes(int... ids) {
        this.ids = ids;
    }

    public int[] getIds() {
        return ids;
    }

    public static ShoalTypes fromId(int id) {
        return SHOAL_ID.get(id);
    }
}
package com.deepseatrawling;

import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.api.gameval.NpcID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.api.ChatMessageType;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.*;


@Slf4j
@PluginDescriptor(
	name = "Deep Sea Trawling",
	description = "Tracks Shoals - their movement, depth and relation to your net(s)",
	tags = {"trawl", "trawling", "sailing", "fishing", "shoal", "deep", "sea", "net"}
)
public class DeepSeaTrawling extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private DeepSeaTrawlingConfig config;

	@Inject
	private DeepSeaTrawlingOverlay overlay;

	@Inject
	private DeepSeaTrawlingWidgetOverlay widgetOverlay;

	@Inject
	private TrawlingNetOverlay trawlingNetOverlay;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private InfoBoxManager infoBoxManager;

	private TrawlingNetInfoBox trawlingNetInfoBox;

	public final Set<Integer> trackedShoals = new HashSet<>();

	private ShoalData nearestShoal;

	@Provides
	DeepSeaTrawlingConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(DeepSeaTrawlingConfig.class);
	}

	private static final int SHOAL_WORLD_ENTITY_TYPE = 4;

	public Net[] netList = {
			new Net(VarbitID.SAILING_SIDEPANEL_BOAT_TRAWLING_NET_0_DEPTH),
			new Net(VarbitID.SAILING_SIDEPANEL_BOAT_TRAWLING_NET_1_DEPTH)
	};

	@Override
	protected void startUp() throws Exception
	{
		overlayManager.add(overlay);
		overlayManager.add(widgetOverlay);
		overlayManager.add(trawlingNetOverlay);

		BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/icon.png");
		trawlingNetInfoBox = new TrawlingNetInfoBox(icon, this);
		infoBoxManager.addInfoBox(trawlingNetInfoBox);

		nearestShoal = null;
		rebuildTrackedShoals();
		log.info("Deep Sea Trawling Plugin Started");

	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove(overlay);
		overlayManager.remove(widgetOverlay);
		overlayManager.remove(trawlingNetOverlay);

		if (trawlingNetInfoBox != null) {
			infoBoxManager.removeInfoBox(trawlingNetInfoBox);
			trawlingNetInfoBox = null;
		}
		trackedShoals.clear();
		netObjectByIndex[0] = null;
		netObjectByIndex[1] = null;
		log.info("Deep Sea Trawling Plugin Stopped");
	}

	public ShoalData getNearestShoal() {
		return nearestShoal;
	}

	public final GameObject[] netObjectByIndex = new GameObject[2];

	public int fishQuantity = 0;

	@Subscribe
	public void onWorldEntitySpawned(WorldEntitySpawned event) throws IOException {
		WorldEntity entity = event.getWorldEntity();
		WorldEntityConfig cfg = entity.getConfig();

		if (cfg == null || cfg.getId() != SHOAL_WORLD_ENTITY_TYPE) {
			return;
		}

		WorldView view = entity.getWorldView();
		if (view == null) {
			return;
		}

		int worldViewId = view.getId();

		if(nearestShoal == null)
		{
			nearestShoal = new ShoalData(worldViewId, entity);
		}

		if (nearestShoal.getWorldViewId() != worldViewId) {
			nearestShoal = new ShoalData(worldViewId, entity);
		}


		//debugging
		log.debug("Registered shoal entity worldViewId={} typeId={}", worldViewId, cfg.getId());
	}

	@Subscribe
	public void onWorldEntityDespawned(WorldEntityDespawned event)
	{
		//?
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned e)
	{
		if (e.getNpc().getId() == NpcID.SAILING_SHOAL_RIPPLES)
		{
			nearestShoal.setShoalNpc(e.getNpc());
			nearestShoal.setDepthFromAnimation();
		}
	}

	public void onNpcDespawned(NpcDespawned e)
	{
		if ( nearestShoal.getShoalNpc() == e.getNpc() )
		{
			nearestShoal.setShoalNpc(null);
			nearestShoal.setDepth(ShoalData.ShoalDepth.UNKNOWN);
		}
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned event)
	{
		GameObject object = event.getGameObject();
		if(object == null || object.getWorldView() == null) {
			return;
		}

		GameObject obj = event.getGameObject();
		if (obj == null || obj.getWorldView() == null) return;

		int id = obj.getId();

		if (client.getLocalPlayer().getWorldView() != null && obj.getWorldView() != null && client.getLocalPlayer().getWorldView() == obj.getWorldView())
		{
			if (isStarboardNetObject(id)) {
				netObjectByIndex[0] = obj;
				return;
			}

			if (isPortNetObject(id)) {
				netObjectByIndex[1] = obj;
				return;
			}
		}
		ShoalData.ShoalSpecies species = ShoalData.ShoalSpecies.fromGameObjectId(id);
		if (species == null) {
			return;
		}

		int worldViewId = object.getWorldView().getId();
		ShoalData shoal = nearestShoal;
		if (shoal == null) {
			return;
		}

		shoal.setSpecies(species);
		shoal.setShoalObject(object);
		shoal.setDepthFromAnimation();
		shoal.setCurrent(shoal.getWorldEntity().getLocalLocation());

		log.debug("Shoal worldViewId={} species={} objectId={}", worldViewId, species, id);
	}

	public void onGameObjectDespawned(GameObjectDespawned event) {
		GameObject obj = event.getGameObject();
		if (obj == null) return;

		if (netObjectByIndex[0] == obj) netObjectByIndex[0] = null;
		if (netObjectByIndex[1] == obj) netObjectByIndex[1] = null;
	}

	@Subscribe
	public void onGameTick(GameTick tick)
	{
		ShoalData shoal = getNearestShoal();
		if (shoal == null) {
			return;
		}
		shoal.setDepthFromAnimation();

		shoal.setCurrent(shoal.getWorldEntity().getLocalLocation());

/*

		LocalPoint current = shoal.getWorldEntity().getLocalLocation();
		LocalPoint next = shoal.getWorldEntity().getTargetLocation();

		WorldPoint currentWorldPoint = WorldPoint.fromLocalInstance(client, current);
		WorldPoint last = shoal.getLast();

		boolean isMoving = (current != null && next != null && !current.equals(next));

		if (currentWorldPoint != null && isMoving) {
			if ((last == null || worldDistanceSq(last, currentWorldPoint) < 40 * 40)) {
				shoal.setPathPoints(currentWorldPoint);
			} else {
				shoal.setPathPoints(currentWorldPoint);
			}
		}

		if (shoal.getWasMoving() && !isMoving && current != null)
		{
			shoal.setStopPoints(currentWorldPoint);
		}

		shoal.setWasMoving(isMoving);
		shoal.setLast(currentWorldPoint);

		*/
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		String msg = event.getMessage().replaceAll("<[^>]*>","");
		ChatMessageType type = event.getType();
		String substring = "";

		if (type == ChatMessageType.GAMEMESSAGE || type == ChatMessageType.SPAM)
		{
			if (msg.equals("You empty the nets into the cargo hold.")) {
				fishQuantity = 0;
				log.debug("Emptied nets");
			} else if (msg.equals("You empty the net into the cargo hold.")) {
				fishQuantity = 0;
				log.debug("Emptied net");
			}

			if (msg.contains("You catch ") && !msg.contains("Trawler's Trust"))
			{
				int index = "You catch ".length();
				substring = msg.substring(index, msg.indexOf(" ", index + 1));
			} else if (msg.contains(" catches ")) {
				int index = msg.indexOf(" catches ") + " catches ".length();
				substring = msg.substring(index, msg.indexOf(" ", index + 1));
			}

			if (!substring.equals(""))
			{
				fishQuantity += convertToNumber(substring);
			}

		}
	}


	@Subscribe
	public void onVarbitChanged(VarbitChanged e)
	{
		int changed = e.getVarbitId();

		switch (changed)
		{

			case VarbitID.SAILING_SIDEPANEL_BOAT_TRAWLING_NET_0_DEPTH:
				netList[0].setNetDepth(e.getValue());
				break;
			case VarbitID.SAILING_SIDEPANEL_BOAT_TRAWLING_NET_1_DEPTH:
				netList[1].setNetDepth(e.getValue());
				break;
		}

	}

	public int localDistanceSq(LocalPoint a, LocalPoint b)
	{
		int dx = a.getX() - b.getX();
		int dy = a.getY() - b.getY();
		return dx * dx + dy * dy;
	}
/*
	public int worldDistanceSq(WorldPoint a, WorldPoint b)
	{
		int dx = a.getX() - b.getX();
		int dy = a.getY() - b.getY();
		return dx * dx + dy * dy;
	}
*/
	private void rebuildTrackedShoals() {
		trackedShoals.clear();

		if(config.showGiantKrill()) {
			for (int id : ShoalTypes.GIANT_KRILL.getIds()) {
				trackedShoals.add(id);
			}
		}
		if(config.showHaddock()) {
			for (int id : ShoalTypes.HADDOCK.getIds()) {
				trackedShoals.add(id);
			}
		}
		if(config.showHalibut()) {
			for (int id : ShoalTypes.HALIBUT.getIds()) {
				trackedShoals.add(id);
			}
		}
		if(config.showYellowfin()) {
			for (int id : ShoalTypes.YELLOWFIN.getIds()) {
				trackedShoals.add(id);
			}
		}
		if(config.showBluefin()) {
			for (int id : ShoalTypes.BLUEFIN.getIds()) {
				trackedShoals.add(id);
			}
		}
		if(config.showMarlin()) {
			for (int id : ShoalTypes.MARLIN.getIds()) {
				trackedShoals.add(id);
			}
		}
	}

	@Subscribe
	private void onConfigChanged(ConfigChanged event) {
		if (!event.getGroup().equals("deepseatrawling")) {
			return;
		}
		rebuildTrackedShoals();
		/*
		StringBuilder builder = new StringBuilder();
		builder.append("Shoal wv=").append(nearestShoal.getWorldViewId()).append(" species=").append(nearestShoal.getSpecies()).append(" path=[");

		for (WorldPoint worldPoint : nearestShoal.getPathPoints()) {
			builder.append(worldPoint.getX()).append(", ").append(worldPoint.getY()).append(", 0|");
		}
		builder.append("] stops=[");
		for (WorldPoint worldPoint : nearestShoal.getStopPoints()) {
			builder.append(worldPoint.getX()).append(", ").append(worldPoint.getY()).append(", 0|");
		}

		log.info(builder.toString());*/
	}

	private static final Map<String, Integer> WORD_NUMBERS = Map.of(
			"a", 1,
			"two", 2,
			"three", 3,
			"four", 4,
			"five", 5,
			"six", 6,
			"seven", 7,
			"eight", 8,
			"nine", 9,
			"ten", 10
	);

	private int convertToNumber(String s)
	{
		s = s.toLowerCase();

		Integer v = WORD_NUMBERS.get(s);
		if (v != null)
		{
			return v;
		}

		throw new IllegalArgumentException("Unknown quantity: " + s);
	}
	public boolean isPortNetObject(int objectId)
	{
		return objectId == net.runelite.api.gameval.ObjectID.SAILING_ROPE_TRAWLING_NET_3X8_PORT
				|| objectId == net.runelite.api.gameval.ObjectID.SAILING_LINEN_TRAWLING_NET_3X8_PORT
				|| objectId == net.runelite.api.gameval.ObjectID.SAILING_HEMP_TRAWLING_NET_3X8_PORT
				|| objectId == net.runelite.api.gameval.ObjectID.SAILING_COTTON_TRAWLING_NET_3X8_PORT;
	}

	public boolean isStarboardNetObject(int objectId)
	{
		return objectId == net.runelite.api.gameval.ObjectID.SAILING_ROPE_TRAWLING_NET_3X8_STARBOARD
				|| objectId == net.runelite.api.gameval.ObjectID.SAILING_LINEN_TRAWLING_NET_3X8_STARBOARD
				|| objectId == net.runelite.api.gameval.ObjectID.SAILING_HEMP_TRAWLING_NET_3X8_STARBOARD
				|| objectId == net.runelite.api.gameval.ObjectID.SAILING_COTTON_TRAWLING_NET_3X8_STARBOARD
				|| objectId == net.runelite.api.gameval.ObjectID.SAILING_ROPE_TRAWLING_NET
				|| objectId == net.runelite.api.gameval.ObjectID.SAILING_LINEN_TRAWLING_NET
				|| objectId == net.runelite.api.gameval.ObjectID.SAILING_HEMP_TRAWLING_NET
				|| objectId == net.runelite.api.gameval.ObjectID.SAILING_COTTON_TRAWLING_NET;
	}

}

package com.deepseatrawling;

import net.runelite.client.ui.overlay.infobox.InfoBox;

import java.awt.*;
import java.awt.image.BufferedImage;

public class TrawlingNetInfoBox extends InfoBox {
    private final DeepSeaTrawling plugin;

    public TrawlingNetInfoBox(BufferedImage image, DeepSeaTrawling plugin)
    {
        super(image, plugin);
        this.plugin = plugin;
    }

    @Override
    public boolean render()
    {
        return plugin.fishQuantity > 0;
    }

    @Override
    public String getText()
    {
        // Example: show fish count
        return String.valueOf(plugin.fishQuantity);
    }

    @Override
    public String getTooltip()
    {
        // Example tooltip
        return "Fish in nets: " + plugin.fishQuantity;
    }

    @Override
    public Color getTextColor()
    {
        return Color.WHITE;
    }

}

package com.deepseatrawling;

import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;


import java.io.IOException;
import java.io.InputStream;
import java.util.*;
import java.util.stream.Collectors;

public class ShoalData {

    public enum ShoalSpecies
    {
        GIANT_KRILL (ObjectID.GIANT_KRILL_SHOAL),
        HADDOCK (ObjectID.HADDOCK_SHOAL),
        YELLOWFIN (ObjectID.YELLOWFIN_SHOAL),
        HALIBUT (ObjectID.HALIBUT_SHOAL),
        BLUEFIN (ObjectID.BLUEFIN_SHOAL),
        MARLIN (ObjectID.MARLIN_SHOAL),
        SHIMMERING (ObjectID.SHIMMERING_SHOAL),
        GLISTENING (ObjectID.GLISTENING_SHOAL),
        VIBRANT (ObjectID.VIBRANT_SHOAL);

        private final int objectID;

        public ShoalDepth defaultDepth()
        {
            switch (this)
            {
                case GIANT_KRILL:
                case HADDOCK:
                case SHIMMERING:
                    return ShoalDepth.SHALLOW;
                default:
                    return ShoalDepth.MEDIUM;
            }
        }

        ShoalSpecies(int objectID) {
            this.objectID = objectID;
        }

        public static ShoalSpecies fromGameObjectId(int id)
        {
            for (ShoalSpecies s : values())
            {
                if (s.objectID == id) {
                    return s;
                }
            }
            return null;
        }

    }

    public enum ShoalDepth
    {
        SHALLOW,
        MEDIUM,
        DEEP,
        UNKNOWN;

        public static int asInt(ShoalDepth depth)
        {
            switch(depth) {
                case SHALLOW:
                    return 1;
                case MEDIUM:
                    return 2;
                case DEEP:
                    return 3;
                default:
                    return -1;
            }
        }
    }

    private NPC shoalNpc;

    private ShoalDepth depth;

    private static final String RESOURCE_NAME = "shoals.properties";

    private final WorldEntity worldEntity;
    private final int worldViewId;
    private ShoalSpecies species;

    private GameObject shoalObject;

    //private WorldPoint last;
    private LocalPoint current;
    //private LocalPoint next;
    private boolean wasMoving;

    private List<WorldPoint> pathPoints = new ArrayList<>();
    private List<WorldPoint> stopPoints = new ArrayList<>();

    public ShoalData(int worldViewId, WorldEntity worldEntity) throws IOException {
        this.worldViewId = worldViewId;
        this.worldEntity = worldEntity;
        load();
    }

    public void setSpecies(ShoalSpecies species) {
        this.species = species;
        this.depth = species.defaultDepth();
    }

    public ShoalSpecies getSpecies() {
        return species;
    }

    public ShoalDepth getDepth() {
        return depth;
    }

    public void setDepth(ShoalDepth depth) {
        this.depth = depth;
    }


    public void setShoalObject(GameObject shoalObject) {
        this.shoalObject = shoalObject;
    }

    public GameObject getShoalObject() {
        return shoalObject;
    }

    public WorldEntity getWorldEntity() {
        return worldEntity;
    }

    public int getWorldViewId() {
        return worldViewId;
    }

    public LocalPoint getCurrent() {
        return current;
    }

    public void setCurrent(LocalPoint current) {
        this.current = current;
    }
/*
    public WorldPoint getLast() { return last; }

    public void setNext(LocalPoint next) {
        this.next = next;
    }

    public void setLast(WorldPoint last) {
        this.last = last;
    }

    public void setPathPoints(WorldPoint worldPoint) {
            pathPoints.add(worldPoint);
    }

    public void setStopPoints(WorldPoint worldPoint) {
        if(stopPoints.contains(worldPoint))
        {
            return;
        }
        stopPoints.add(worldPoint);
    }
*/
    public List<WorldPoint> getPathPoints() {
        return pathPoints;
    }

    public List<WorldPoint> getStopPoints() {
        return stopPoints;
    }

    public boolean getWasMoving() {
        return wasMoving;
    }

    public void setWasMoving(boolean wasMoving) { this.wasMoving = wasMoving; }

    public void setShoalNpc(NPC shoalNpc) {
        this.shoalNpc = shoalNpc;
    }

    private void load() throws IOException
    {
        Properties properties = new Properties();
        String idStr;
        int id;
        String value;

        try (InputStream in = getClass().getResourceAsStream("/" + RESOURCE_NAME))
        {
            if (in == null) {
                throw new IOException("Could not find resource: " + RESOURCE_NAME);
            }
            properties.load(in);
        }

        for (String key : properties.stringPropertyNames())
        {
            if (key.startsWith("shoalpath."))
            {
                idStr = key.substring("shoalpath.".length());
                if(Integer.parseInt(idStr) == getWorldViewId()) {
                    value = properties.getProperty(key);
                    this.pathPoints = parsePoints(value);
                }
            }

            if (key.startsWith("shoalstops.")) {
                idStr = key.substring("shoalstops.".length());
                if (Integer.parseInt(idStr) == getWorldViewId()) {
                    value = properties.getProperty(key);
                    this.stopPoints = parsePoints(value);
                }
            }
        }
    }

    private List<WorldPoint> parsePoints(String value) {
        if (value == null || value.trim().isEmpty()) {
            return Collections.emptyList();
        }

        return Arrays.stream(value.split("\\|"))
                .map(String::trim)
                .filter(s -> !s.isEmpty())
                .map(this::parsePoint)
                .collect(Collectors.toList());
    }

    private WorldPoint parsePoint(String token)
    {
        String[] parts = token.split(", ");
        if(parts.length < 2)
        {
            throw new IllegalArgumentException("Invalid Point: " + token);
        }

        int x = Integer.parseInt(parts[0].trim());
        int y = Integer.parseInt(parts[1].trim());
        int plane = Integer.parseInt(parts[2].trim());

        return new WorldPoint(x, y, plane);
    }

    public void setDepthFromAnimation()
    {
        if (shoalNpc == null)
        {
            this.depth = ShoalDepth.UNKNOWN;
            return;
        }
        int animation = shoalNpc.getAnimation();
        if (animation == -1)
        {
            return;
        }

        switch (animation)
        {
            case net.runelite.api.gameval.AnimationID.DEEP_SEA_TRAWLING_SHOAL_SHALLOW:
                this.depth = ShoalDepth.SHALLOW;
                break;
            case net.runelite.api.gameval.AnimationID.DEEP_SEA_TRAWLING_SHOAL_MID:
                this.depth = ShoalDepth.MEDIUM;
                break;
            case net.runelite.api.gameval.AnimationID.DEEP_SEA_TRAWLING_SHOAL_DEEP:
                this.depth = ShoalDepth.DEEP;
                break;
            default:
                this.depth = ShoalDepth.UNKNOWN;

        }

    }

    public NPC getShoalNpc() {
        return shoalNpc;
    }

}

package com.deepseatrawling;

import net.runelite.api.*;
import net.runelite.api.Point;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.coords.LocalPoint;

import javax.inject.Inject;
import java.awt.*;
import java.util.EnumMap;
import java.util.Map;

public class DeepSeaTrawlingOverlay extends Overlay {

    private final Client client;
    private final DeepSeaTrawling plugin;

    private final Map<ShoalData.ShoalSpecies, Color> speciesColors = new EnumMap<>(ShoalData.ShoalSpecies.class);

    @Inject
    private DeepSeaTrawlingOverlay(Client client, DeepSeaTrawling plugin) {
        this.client = client;
        this.plugin = plugin;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);

        speciesColors.put(ShoalData.ShoalSpecies.GIANT_KRILL, new Color(255, 150, 150));
        speciesColors.put(ShoalData.ShoalSpecies.YELLOWFIN, new Color(255, 220, 120));
        speciesColors.put(ShoalData.ShoalSpecies.HADDOCK, new Color(255, 255, 200));
        speciesColors.put(ShoalData.ShoalSpecies.HALIBUT, new Color(200, 255, 200));
        speciesColors.put(ShoalData.ShoalSpecies.BLUEFIN, new Color(120, 180, 255));
        speciesColors.put(ShoalData.ShoalSpecies.MARLIN, new Color(0, 200, 255));
        speciesColors.put(ShoalData.ShoalSpecies.SHIMMERING, new Color(200, 255, 255));
        speciesColors.put(ShoalData.ShoalSpecies.GLISTENING, new Color(220, 200, 255));
        speciesColors.put(ShoalData.ShoalSpecies.VIBRANT, new Color(255, 200, 220));
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        ShoalData shoal = plugin.getNearestShoal();
        if (shoal == null) {
            return null;
        }
        if(!plugin.trackedShoals.contains(shoal.getWorldViewId())) {
            return null;
        }

        GameObject object = shoal.getShoalObject();
        if (object == null)
        {
            LocalPoint localPoint = shoal.getCurrent();
            if (localPoint != null) {
                drawArea(graphics, localPoint, 3, Color.WHITE);
            }
            return null;
        }

        LocalPoint localLocation = object.getLocalLocation();

        ObjectComposition composition = client.getObjectDefinition(object.getId());
        if (composition == null) {
            return null;
        }

        int sizeX = composition.getSizeX();
        int sizeY = composition.getSizeY();

        int size = Math.max(sizeX, sizeY);
        if (size <= 0) {
            size = 1;
        }
        if(plugin.trackedShoals.contains(shoal.getWorldViewId())) {
            Color baseColour = speciesColors.getOrDefault(shoal.getSpecies(), Color.WHITE);

            if (shoal.getSpecies() == ShoalData.ShoalSpecies.SHIMMERING || shoal.getSpecies() == ShoalData.ShoalSpecies.GLISTENING || shoal.getSpecies() == ShoalData.ShoalSpecies.VIBRANT)
            {
                drawPath(graphics, shoal, new Color(0,204,255));
            } else {
                drawPath(graphics, shoal, new Color(0,51,102));
            }
            drawStopSquares(graphics, shoal, size, baseColour);

            drawArea(graphics, localLocation, size, baseColour);

            drawDepthLabel(graphics, shoal, size);
        }

        return null;
    }

    private void drawArea(Graphics2D graphics, LocalPoint centerLP, int sizeTiles, Color baseColour)
    {
        Polygon poly = Perspective.getCanvasTileAreaPoly(client, centerLP, sizeTiles);
        if (poly == null)
        {
            return;
        }

        graphics.setStroke(new BasicStroke(2));
        OverlayUtil.renderPolygon(graphics, poly, baseColour);

        Color fill = new Color(baseColour.getRed(), baseColour.getGreen(), baseColour.getBlue(), 50);
        Composite old = graphics.getComposite();
        graphics.setComposite(AlphaComposite.SrcOver.derive(fill.getAlpha() / 255f));
        graphics.setColor(fill);
        graphics.fill(poly);
        graphics.setComposite(old);
    }

    private void drawPath (Graphics2D path, ShoalData shoal, Color baseColour)
    {
        java.util.List<WorldPoint> points = shoal.getPathPoints();
        if (points.size() < 2) {
            return;
        }

        int plane = shoal.getWorldEntity().getWorldView().getPlane();

        path.setStroke(new BasicStroke(1.5f));
        path.setColor(baseColour);

        int ARROW_EVERY_N_SEGMENTS = 5;
        for (int i = 0; i < points.size() - 1; i++)
        {
            WorldPoint worldPointA = points.get(i);
            WorldPoint worldPointB = points.get(i+1);
            if (worldPointA == null || worldPointB == null) {
                continue;
            }

            LocalPoint localPointA = LocalPoint.fromWorld(client, worldPointA);
            LocalPoint localPointB = LocalPoint.fromWorld(client, worldPointB);
            if (localPointA == null || localPointB == null) {
                continue;
            }

            Point pointA = Perspective.localToCanvas(client, localPointA, plane);
            Point pointB = Perspective.localToCanvas(client, localPointB, plane);
            if (pointA == null || pointB == null)
            {
                continue;
            }

            path.drawLine(pointA.getX(), pointA.getY(), pointB.getX(), pointB.getY());

            if (i % ARROW_EVERY_N_SEGMENTS == 0)
            {
                drawArrow(path, pointA, pointB, baseColour);
            }
        }
    }

    private void drawStopSquares(Graphics2D square, ShoalData shoal, int sizeTiles, Color baseColour)
    {
        Color outline = new Color(baseColour.getRed(), baseColour.getGreen(), baseColour.getBlue());
        Color fill = new Color(baseColour.getRed(), baseColour.getGreen(), baseColour.getBlue(), 50);

        for (WorldPoint worldPoint : shoal.getStopPoints())
        {
            if (worldPoint == null ) {
                continue;
            }

            LocalPoint localPoint = LocalPoint.fromWorld(client, worldPoint);
            if (localPoint == null) {
                continue;
            }

            if (plugin.localDistanceSq(localPoint, shoal.getCurrent()) < 512 * 512 && !shoal.getWasMoving()) {
                continue;
            }

            Polygon polygon = Perspective.getCanvasTileAreaPoly(client, localPoint, sizeTiles);
            if (polygon == null) {
                continue;
            }

            square.setStroke(new BasicStroke(2));
            OverlayUtil.renderPolygon(square, polygon, outline);

            Composite old = square.getComposite();
            square.setComposite(AlphaComposite.SrcOver.derive(fill.getAlpha() / 255f));
            square.setColor(fill);
            square.fill(polygon);
            square.setComposite(old);
        }
    }

    private void drawArrow(Graphics2D graphics, Point from, Point to, Color colour)
    {
        if (from == null || to == null) {
            return;
        }

        graphics.setColor(colour);
        graphics.setStroke(new BasicStroke(2));

        double dx = to.getX() - from.getX();
        double dy = to.getY() - from.getY();
        double angle = Math.atan2(dy, dx);

        int arrowLength = 10;
        int arrowWidth = 6;

        double leftAngle = angle + Math.toRadians(155);
        double rightAngle = angle - Math.toRadians(155);

        int x1 = to.getX() + (int) (Math.cos(leftAngle) * arrowLength);
        int y1 = to.getY() + (int) (Math.sin(leftAngle) * arrowLength);

        int x2 = to.getX() + (int) (Math.cos(rightAngle) * arrowLength);
        int y2 = to.getY() + (int) (Math.sin(rightAngle) * arrowLength);

        int[] xs = { to.getX(), x1, x2 };
        int[] ys = { to.getY(), y1, y2 };

        graphics.fillPolygon(xs, ys, 3);
    }

    private void drawDepthLabel(Graphics2D graphic, ShoalData shoal, int sizeTiles)
    {
        ShoalData.ShoalDepth depth = shoal.getDepth();
        String text;
        Color textColour;

        switch (depth)
        {
            case SHALLOW:
                text = "Shallow";
                textColour = new Color(0, 200, 0);
                break;
            case MEDIUM:
                text = "Medium";
                textColour = new Color(255, 165, 0);
                break;
            case DEEP:
                text = "Deep";
                textColour = new Color(200, 60, 60);
                break;
            default:
                text = "?";
                textColour = Color.GRAY;
        }

        GameObject object = shoal.getShoalObject();
        if (object == null) {
            return;
        }

        LocalPoint centralPoint = object.getLocalLocation();
        if (centralPoint == null) {
            return;
        }

        Polygon poly = Perspective.getCanvasTilePoly(client, centralPoint, sizeTiles);
        if (poly == null) {
            return;
        }

        Rectangle bounds = poly.getBounds();
        int anchorX = bounds.x + bounds.width / 2;
        int anchorY = bounds.y;

        graphic.setFont(FontManager.getRunescapeBoldFont().deriveFont( 14f));
        FontMetrics metrics = graphic.getFontMetrics();
        int width = metrics.stringWidth(text);
        int height = metrics.getHeight();

        int x = anchorX - width / 2;
        int y = anchorY - 8;

        graphic.setColor(new Color(0,0,0,140));
        graphic.fillRoundRect(x - 3, y - height, width + 6, height, 6, 6);

        graphic.setColor((textColour));
        graphic.drawString(text, x, y);

    }

}

package com.deepseatrawling;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

import java.awt.*;

@ConfigGroup("deepseatrawling")
public interface DeepSeaTrawlingConfig extends Config
{
	@ConfigItem(
		keyName = "showGiantKrill",
		name = "Show Giant Krill Shoals",
		description = "Highlight Giant Krill Shoals"
	)
	default boolean showGiantKrill()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showHaddock",
			name = "Show Haddock Shoals",
			description = "Highlight Haddock Shoals"
	)
	default boolean showHaddock()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showYellowfin",
			name = "Show Yellowfin Shoals",
			description = "Highlight Yellowfin Shoals"
	)
	default boolean showYellowfin()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showHalibut",
			name = "Show Halibut Shoals",
			description = "Highlight Halibut Shoals"
	)
	default boolean showHalibut()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showBluefin",
			name = "Show Bluefin Shoals",
			description = "Highlight Bluefin Shoals"
	)
	default boolean showBluefin()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showMarlin",
			name = "Show Marlin Shoals",
			description = "Highlight Marlin Shoals"
	)
	default boolean showMarlin()
	{
		return true;
	}

	/*
	@ConfigItem(
			keyName = "showShimmering",
			name = "Show Shimmering Shoals",
			description = "Highlight Shimmering Shoals"
	)
	default boolean showShimmering()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showGlistening",
			name = "Show Glistening Shoals",
			description = "Highlight Glistening Shoals"
	)
	default boolean showGlistening()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showVibrant",
			name = "Show Vibrant Shoals",
			description = "Highlight Vibrant Shoals"
	)
	default boolean showVibrant()
	{
		return true;
	}
*/
}

package com.deepseatrawling;

import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.inject.Inject;
import java.awt.*;

public class TrawlingNetOverlay extends Overlay {

    private final Client client;
    private final DeepSeaTrawling plugin;

    @Inject
    private TrawlingNetOverlay(Client client, DeepSeaTrawling plugin) {
        this.client = client;
        this.plugin = plugin;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        int totalNetSize = 0;
        if (plugin.netList[0] != null)
        {
            totalNetSize += plugin.netList[0].getNetSize();
        }
        if (plugin.netList[1] != null)
        {
            totalNetSize += plugin.netList[1].getNetSize();
        }
        if (plugin.netList[0] == null && plugin.netList[1] == null)
        {
            return null;
        }

        ShoalData shoal = plugin.getNearestShoal();
        if (shoal == null || shoal.getDepth() == ShoalData.ShoalDepth.UNKNOWN)
        {
            return null;
        }

        int desired = ShoalData.ShoalDepth.asInt(shoal.getDepth());
        if (desired < 1)
        {
            return null;
        }

        for (int netIndex = 0; netIndex <= 1; netIndex++)
        {
            GameObject netObj = plugin.netObjectByIndex[netIndex];
            if (netObj == null) continue;

            Net net = plugin.netList[netIndex];
            if (net == null) continue;

            int current = Net.NetDepth.asInt(net.getNetDepth());
            if (current <= 0 || current == desired || plugin.fishQuantity >= totalNetSize) continue;

            trawlingNetOutline(graphics, plugin.fishQuantity, totalNetSize, plugin.netObjectByIndex[netIndex]);
        }

        return null;

    }

    private void trawlingNetOutline(Graphics2D graphic, int fishQuantity, int totalNetSize, GameObject netObject) {
        Color colour;
        if (fishQuantity >= totalNetSize) {
            colour = Color.RED;
        } else {
            colour = new Color(255, 255, 0, 220);
        }

        if (netObject == null) {
            return;
        }

        Shape convexHull = netObject.getConvexHull();
        if (convexHull == null) {
            return;
        }
        OverlayUtil.renderPolygon(graphic, convexHull, colour);

    }
}

package com.deepseatrawling;

public class Net {

    private final int netIndex;
    private NetDepth netDepth = NetDepth.RAISED;
    private final static int netSize = 125;

    public Net(int netIndex) {
        this.netIndex = netIndex;
    }

    public int getNetSize() {
        return netSize;
    }

    public void setNetDepth(int netDepth) {
        for (NetDepth newDepth : NetDepth.values())
        {
            if (newDepth.depth == netDepth) {
                this.netDepth = newDepth;
            }
        }
    }

    public NetDepth getNetDepth() {
        return netDepth;
    }

    public enum NetDepth {
        RAISED(0),
        SHALLOW(1),
        MEDIUM(2),
        DEEP(3);

        public static int asInt(NetDepth depth) {
            switch (depth) {
                case RAISED:
                    return 0;
                case SHALLOW:
                    return 1;
                case MEDIUM:
                    return 2;
                case DEEP:
                    return 3;
                default:
                    return -1;
            }
        }

        private final int depth;

        NetDepth(int depth) {
            this.depth = depth;
        }
    }
}

package com.deepseatrawling;

import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.api.WorldEntity;

import javax.inject.Inject;
import java.awt.*;

public class DeepSeaTrawlingWidgetOverlay extends Overlay {

    private static final int SAILING_SIDEPANEL_GROUP = 937;
    private static final int FACILITIES_CONTENT_CLICKLAYER_CHILD = 25;

    private static final int SKIFF_DOWN_INDEX = 29;
    private static final int SKIFF_UP_INDEX = 30;
    private static final int STARBOARD_DOWN_INDEX = 41;
    private static final int STARBOARD_UP_INDEX = 42;
    private static final int PORT_DOWN_INDEX = 45;
    private static final int PORT_UP_INDEX = 46;

    private final Client client;
    private final DeepSeaTrawling plugin;

    enum Direction {
        UP,
        DOWN
    }

    @Inject
    public DeepSeaTrawlingWidgetOverlay(Client client, DeepSeaTrawling plugin)
    {
        this.client = client;
        this.plugin = plugin;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
       ShoalData shoal = plugin.getNearestShoal();
       if (shoal != null && shoal.getDepth() != ShoalData.ShoalDepth.UNKNOWN)
       {
           int desired = ShoalData.ShoalDepth.asInt(shoal.getDepth());
           if (desired < 1) {
               return null;
           }

           for (int netIndex = 0; netIndex < 2; netIndex++)
           {
               int current = Net.NetDepth.asInt(plugin.netList[netIndex].getNetDepth());
               if (current <= 0 || current == desired) {
                   continue;
               }

               Direction direction = current < desired ? Direction.DOWN : Direction.UP;
               highlightNetButton(graphics, netIndex, direction);
           }
       }
        return null;
    }

    private void highlightNetButton(Graphics2D g, int netIndex, Direction direction)
    {
        Widget parent = client.getWidget(SAILING_SIDEPANEL_GROUP , FACILITIES_CONTENT_CLICKLAYER_CHILD);
        if (parent == null) return;
        boolean hidden = false;
        for (Widget widgetParent = parent; widgetParent != null; widgetParent = widgetParent.getParent())
        {
            if (widgetParent.isHidden()) {
                hidden = true;
            }
        }

        int[] childIds = {-1, -1};
        if (netIndex == 0) {
            childIds[0] = (direction == Direction.DOWN ? STARBOARD_DOWN_INDEX : STARBOARD_UP_INDEX);
            childIds[1] = (direction == Direction.DOWN ? SKIFF_DOWN_INDEX : SKIFF_UP_INDEX);
        } else if (netIndex == 1) {
            childIds[0] = direction == Direction.DOWN ? PORT_DOWN_INDEX : PORT_UP_INDEX;
        } else {
            return;
        }

        for(int childId : childIds) {
            if (childId == -1) continue;

            Widget button = parent.getChild(childId);
            if (button == null || button.isHidden() || button.getBounds().width <=0 || button.getBounds().height <= 0 || hidden || !client.getWidget(161,73).getBounds().intersects(button.getBounds())) continue;

            Rectangle bounds = button.getBounds();
            if (bounds == null) continue;

            g.setColor(new Color(255, 255, 0, 120));
            g.fillRoundRect(bounds.x, bounds.y, bounds.width, bounds.height, 8, 8);

            g.setColor(new Color(255, 255, 0, 220));
            g.setStroke(new BasicStroke(2));
            g.drawRoundRect(bounds.x, bounds.y, bounds.width, bounds.height, 8, 8);
        }

    }

}

package com.deepseatrawling;

import lombok.Getter;
import net.runelite.api.NPC;
import net.runelite.api.WorldEntity;
import net.runelite.api.WorldEntityConfig;

import java.awt.*;
import java.util.Arrays;
import java.util.Set;

@Getter
public enum ShoalType {
    GIANT_KRILL("Giant Krill Shoal", 0xFF7878, 59734),
    HADDOCK("Haddock Shoal", 0xC8C8FF, 59735),
    YELLOWFIN("Yellowfin Shoal", 0xFFFF78, 59736),
    HALIBUT("Halibut Shoal", 0xC8FFC8, 4),
    BLUEFIN("Bluefin Shoal", 0x7890FF, 59738),
    MARLIN("Marlin Shoal", 0xFFB450,  59739),

    SHIMMERING("Shimmering Shoal", 0xAAFFFF, 59740),
    GLISTENING("Glistening Shoal", 0xC8FFF0, 59741),
    VIBRANT("Vibrant Shoal", 0xDCFFC8, 59742);

    private final String displayName;
    private final int rgb;
    private final int entityId;

    ShoalType(String displayName, int rgb, int entityId)
    {
        this.displayName = displayName;
        this.rgb = rgb;
        this.entityId = entityId;
    }

    public String getDisplayName() {
        return displayName;
    }

    public Color getColour() {
        return new Color(rgb);
    }

    public int getEntityId() {
        return entityId;
    }

    public static ShoalType fromWorldEntity(WorldEntity worldEntity)
    {
        WorldEntityConfig cfg = worldEntity.getConfig();
        if (cfg == null) {
            return null;
        }
        int id = cfg.getId();
        for(ShoalType shoalType : values())
        {
            if (shoalType.entityId == id) {
                return shoalType;
            }
        }
        return null;
    }
}

package com.deepseatrawling;

import net.runelite.api.gameval.ObjectID;
import org.apache.commons.lang3.ArrayUtils;

public enum NetTiers {
    ROPE(new int[]{
            ObjectID.SAILING_ROPE_TRAWLING_NET,
            ObjectID.SAILING_ROPE_TRAWLING_NET_3X8_PORT,
            ObjectID.SAILING_ROPE_TRAWLING_NET_3X8_STARBOARD
        }
    ),
    LINEN(new int[]{
            ObjectID.SAILING_LINEN_TRAWLING_NET,
            ObjectID.SAILING_LINEN_TRAWLING_NET_3X8_PORT,
            ObjectID.SAILING_LINEN_TRAWLING_NET_3X8_STARBOARD
        }
    ),
    HEMP(new int[]{
            ObjectID.SAILING_HEMP_TRAWLING_NET,
            ObjectID.SAILING_HEMP_TRAWLING_NET_3X8_PORT,
            ObjectID.SAILING_HEMP_TRAWLING_NET_3X8_STARBOARD,
        }
    ),
    COTTON(new int[]{
            ObjectID.SAILING_COTTON_TRAWLING_NET,
            ObjectID.SAILING_COTTON_TRAWLING_NET_3X8_PORT,
            ObjectID.SAILING_COTTON_TRAWLING_NET_3X8_STARBOARD,
        }
    );

    private final int[] gameObjectIds;

    NetTiers(int[] gameObjectIds) {
        this.gameObjectIds = gameObjectIds;
    }

    public int[] getGameObjectIds() {
        return gameObjectIds;
    }

}

package com.deepseatrawling;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PluginLauncher
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(DeepSeaTrawling.class);
		RuneLite.main(args);
	}
}
