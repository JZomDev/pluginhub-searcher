package com.deepseatrawling;

import java.util.HashMap;
import java.util.Map;

public enum ShoalTypes {
    GIANT_KRILL(26, 27, 28, 29),
    HADDOCK(23, 24, 25),
    YELLOWFIN(20, 21, 22),
    HALIBUT(18, 19),
    BLUEFIN(16, 17),
    MARLIN(14, 15);

    private static final Map<Integer, ShoalTypes> SHOAL_ID = new HashMap<>();

    private static final Map<ShoalTypes, ShoalData.ShoalSpecies> SHOAL_TYPES_SHOAL_SPECIES_MAP = Map.of(
            GIANT_KRILL, ShoalData.ShoalSpecies.GIANT_KRILL,
            HADDOCK, ShoalData.ShoalSpecies.HADDOCK,
            YELLOWFIN, ShoalData.ShoalSpecies.YELLOWFIN,
            HALIBUT, ShoalData.ShoalSpecies.HALIBUT,
            BLUEFIN, ShoalData.ShoalSpecies.BLUEFIN,
            MARLIN, ShoalData.ShoalSpecies.MARLIN
    );

    static {
        for (ShoalTypes type : values()) {
            for (int id : type.ids) {
                SHOAL_ID.put(id, type);
            }
        }
    }

    private final int[] ids;

    ShoalTypes(int... ids) {
        this.ids = ids;
    }

    public int[] getIds() {
        return ids;
    }

    public static ShoalTypes fromId(int id) {
        return SHOAL_ID.get(id);
    }

    public static ShoalData.ShoalSpecies fromType(ShoalTypes shoal) { return SHOAL_TYPES_SHOAL_SPECIES_MAP.get(shoal); }

    public static ShoalData.ShoalSpecies fromIdToSpecies(int id) { return SHOAL_TYPES_SHOAL_SPECIES_MAP.get(SHOAL_ID.get(id)); }
}
package com.deepseatrawling;

import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.events.*;
import net.runelite.api.gameval.NpcID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.Notifier;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.api.ChatMessageType;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.*;


@Slf4j
@PluginDescriptor(
	name = "Deep Sea Trawling",
	description = "Tracks Shoals - their movement, depth and relation to your net(s)",
	tags = {"trawl", "trawling", "sailing", "fishing", "shoal", "deep", "sea", "net"}
)
public class DeepSeaTrawling extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private DeepSeaTrawlingConfig config;

	@Inject
	private DeepSeaTrawlingOverlay overlay;

	@Inject
	private DeepSeaTrawlingWidgetOverlay widgetOverlay;

	@Inject
	private TrawlingNetOverlay trawlingNetOverlay;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private InfoBoxManager infoBoxManager;

    @Inject
    ShoalRouteRegistry shoalRouteRegistry;

    @Inject
    private Notifier notifier;
    private boolean notifiedFull = false;

	private TrawlingNetInfoBox trawlingNetInfoBox;

	public final Set<Integer> trackedShoals = new HashSet<>();

    public final int SKIFF_WORLD_ENTITY_TYPE = 2;
    public final int SLOOP_WORLD_ENTITY_TYPE = 3;
    public Map<Integer, Integer> boats = new HashMap<>();

	private ShoalData nearestShoal;

    public Map<ShoalData.ShoalSpecies, Color> speciesColours = new EnumMap<>(ShoalData.ShoalSpecies.class);

    @Provides
	DeepSeaTrawlingConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(DeepSeaTrawlingConfig.class);
	}

	private static final int SHOAL_WORLD_ENTITY_TYPE = 4;

	public Net[] netList = {
			new Net(VarbitID.SAILING_SIDEPANEL_BOAT_TRAWLING_NET_0_DEPTH),
			new Net(VarbitID.SAILING_SIDEPANEL_BOAT_TRAWLING_NET_1_DEPTH)
	};

	@Override
	protected void startUp() throws Exception
	{
		overlayManager.add(overlay);
		overlayManager.add(widgetOverlay);
		overlayManager.add(trawlingNetOverlay);

		BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/icon.png");
		trawlingNetInfoBox = new TrawlingNetInfoBox(icon, this);
		infoBoxManager.addInfoBox(trawlingNetInfoBox);

		nearestShoal = null;
		rebuildTrackedShoals();
        rebuildShoalColours();

        shoalRouteRegistry.load();

		log.info("Deep Sea Trawling Plugin Started");

	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove(overlay);
		overlayManager.remove(widgetOverlay);
		overlayManager.remove(trawlingNetOverlay);

		if (trawlingNetInfoBox != null) {
			infoBoxManager.removeInfoBox(trawlingNetInfoBox);
			trawlingNetInfoBox = null;
		}
		trackedShoals.clear();
		netObjectByIndex[0] = null;
		netObjectByIndex[1] = null;
		log.info("Deep Sea Trawling Plugin Stopped");
	}

	public ShoalData getNearestShoal() {
		return nearestShoal;
	}

	public final GameObject[] netObjectByIndex = new GameObject[2];

	public int fishQuantity = 0;

	@Subscribe
	public void onWorldEntitySpawned(WorldEntitySpawned event) throws IOException {
		WorldEntity entity = event.getWorldEntity();
		WorldEntityConfig cfg = entity.getConfig();

		if (cfg == null) {
			return;
		}

        if (cfg.getId() != SHOAL_WORLD_ENTITY_TYPE && cfg.getId() != SKIFF_WORLD_ENTITY_TYPE && cfg.getId() != SLOOP_WORLD_ENTITY_TYPE) {
            return;
        }

		WorldView view = entity.getWorldView();
		if (view == null) {
			return;
		}

		int worldViewId = view.getId();

        if(nearestShoal == null && cfg.getId() == SHOAL_WORLD_ENTITY_TYPE)
		{
			nearestShoal = new ShoalData(worldViewId, entity, shoalRouteRegistry.get(worldViewId));
		} else if (nearestShoal != null && nearestShoal.getWorldViewId() != worldViewId && cfg.getId() == SHOAL_WORLD_ENTITY_TYPE) {
			nearestShoal = new ShoalData(worldViewId, entity, shoalRouteRegistry.get(worldViewId));
		} else if (cfg.getId() == SKIFF_WORLD_ENTITY_TYPE || cfg.getId() == SLOOP_WORLD_ENTITY_TYPE) {
            boats.put(worldViewId, cfg.getId());
        }
	}

	@Subscribe
	public void onWorldEntityDespawned(WorldEntityDespawned event)
	{
        WorldEntity entity = event.getWorldEntity();
        WorldEntityConfig cfg = entity.getConfig();

        if (cfg == null) {
            return;
        }

        boats.remove(entity.getWorldView().getId());
		//?
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned e)
	{
		if (e.getNpc().getId() == NpcID.SAILING_SHOAL_RIPPLES)
		{
			nearestShoal.setShoalNpc(e.getNpc());
			nearestShoal.setDepthFromAnimation();
		}
	}

	public void onNpcDespawned(NpcDespawned e)
	{
		if ( nearestShoal.getShoalNpc() == e.getNpc() )
		{
			nearestShoal.setShoalNpc(null);
			nearestShoal.setDepth(ShoalData.ShoalDepth.UNKNOWN);
		}
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned event)
	{
		GameObject object = event.getGameObject();
		if(object == null || object.getWorldView() == null) {
			return;
		}

		GameObject obj = event.getGameObject();
		if (obj == null || obj.getWorldView() == null) return;

		int id = obj.getId();

		if (client.getLocalPlayer().getWorldView() != null && obj.getWorldView() != null && client.getLocalPlayer().getWorldView() == obj.getWorldView())
		{
			if (isStarboardNetObject(id)) {
				netObjectByIndex[0] = obj;
				return;
			}

			if (isPortNetObject(id)) {
				netObjectByIndex[1] = obj;
				return;
			}
		}
		ShoalData.ShoalSpecies species = ShoalData.ShoalSpecies.fromGameObjectId(id);
		if (species == null) {
			return;
		}

		int worldViewId = object.getWorldView().getId();
		ShoalData shoal = nearestShoal;
		if (shoal == null) {
			return;
		}

		shoal.setSpecies(species);
		shoal.setShoalObject(object);
		shoal.setDepthFromAnimation();
		shoal.setCurrent(shoal.getWorldEntity().getLocalLocation());

		log.debug("Shoal worldViewId={} species={} objectId={}", worldViewId, species, id);
	}

	public void onGameObjectDespawned(GameObjectDespawned event) {
		GameObject obj = event.getGameObject();
		if (obj == null) return;

		if (netObjectByIndex[0] == obj) netObjectByIndex[0] = null;
		if (netObjectByIndex[1] == obj) netObjectByIndex[1] = null;
	}

	@Subscribe
	public void onGameTick(GameTick tick)
	{
        ShoalData shoal = getNearestShoal();
		if (shoal == null) {
			return;
		}
		shoal.setDepthFromAnimation();

        LocalPoint current = shoal.getWorldEntity().getLocalLocation();
        shoal.setCurrent(current);

        int nowTick = client.getTickCount();

        boolean isMoving = current != null
            && shoal.getLast() != null
            && !current.equals(shoal.getLast());

        if (shoal.getLast() == null) {
            shoal.setLast(current);
            shoal.setWasMoving(false);
            return;
        }

        if (shoal.getWasMoving() && !isMoving) {
            int stopDurationTicks = ShoalData.shoalTimers.getOrDefault(shoal.getSpecies(), 0);
            shoal.beginStopTimer(nowTick, stopDurationTicks);
        }

        // Transition: stopped -> moving
        if (!shoal.getWasMoving() && isMoving)
        {
            shoal.clearStopTimer();
        }

		shoal.setWasMoving(isMoving);
        shoal.setLast(current);
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		ChatMessageType type = event.getType();

		if (type == ChatMessageType.GAMEMESSAGE || type == ChatMessageType.SPAM)
		{
            String msg = event.getMessage().replaceAll("<[^>]*>","");
			if (msg.equals("You empty the nets into the cargo hold.") || msg.equals("You empty the net into the cargo hold.")) {
                fishQuantity = 0;
                log.debug("Emptied nets");
                notifiedFull = false;
            }

			if (msg.contains("Trawler's trust")) {
				// Another message includes the additional fish caught
				return;
			}

			String substring = "";
			if (msg.contains("You catch "))
			{
				int index = "You catch ".length();
				substring = msg.substring(index, msg.indexOf(" ", index + 1));
			} else if (msg.contains(" catches ")) {
				int index = msg.indexOf(" catches ") + " catches ".length();
				substring = msg.substring(index, msg.indexOf(" ", index + 1));
			}

			if (!substring.equals(""))
			{
				fishQuantity += convertToNumber(substring);
                int totalNetSize = 0;
                if (netList[0] != null)
                {
                    totalNetSize += netList[0].getNetSize();
                }
                if (netList[1] != null)
                {
                    totalNetSize += netList[1].getNetSize();
                }
                if (fishQuantity >= totalNetSize && config.notifyNetFull() && !notifiedFull) {
                    notifier.notify("Trawling net(s) full! Empty now!");
                    notifiedFull = true;
                }
			}
		}
	}


	@Subscribe
	public void onVarbitChanged(VarbitChanged e)
	{
		int changed = e.getVarbitId();

		switch (changed)
		{

			case VarbitID.SAILING_SIDEPANEL_BOAT_TRAWLING_NET_0_DEPTH:
				netList[0].setNetDepth(e.getValue());
				break;
			case VarbitID.SAILING_SIDEPANEL_BOAT_TRAWLING_NET_1_DEPTH:
				netList[1].setNetDepth(e.getValue());
				break;
		}

	}

	public int localDistanceSq(LocalPoint a, LocalPoint b)
	{
		int dx = a.getX() - b.getX();
		int dy = a.getY() - b.getY();
		return dx * dx + dy * dy;
	}
/*
	public int worldDistanceSq(WorldPoint a, WorldPoint b)
	{
		int dx = a.getX() - b.getX();
		int dy = a.getY() - b.getY();
		return dx * dx + dy * dy;
	}
*/
	private void rebuildTrackedShoals() {
		trackedShoals.clear();

		if(config.showGiantKrill()) {
			for (int id : ShoalTypes.GIANT_KRILL.getIds()) {
				trackedShoals.add(id);
			}
		}
		if(config.showHaddock()) {
			for (int id : ShoalTypes.HADDOCK.getIds()) {
				trackedShoals.add(id);
			}
		}
		if(config.showHalibut()) {
			for (int id : ShoalTypes.HALIBUT.getIds()) {
				trackedShoals.add(id);
			}
		}
		if(config.showYellowfin()) {
			for (int id : ShoalTypes.YELLOWFIN.getIds()) {
				trackedShoals.add(id);
			}
		}
		if(config.showBluefin()) {
			for (int id : ShoalTypes.BLUEFIN.getIds()) {
				trackedShoals.add(id);
			}
		}
		if(config.showMarlin()) {
			for (int id : ShoalTypes.MARLIN.getIds()) {
				trackedShoals.add(id);
			}
		}
	}

	@Subscribe
	private void onConfigChanged(ConfigChanged event) {
		if (!event.getGroup().equals("deepseatrawling")) {
			return;
		}
		rebuildTrackedShoals();
        rebuildShoalColours();

		/*
		StringBuilder builder = new StringBuilder();
		builder.append("Shoal wv=").append(nearestShoal.getWorldViewId()).append(" species=").append(nearestShoal.getSpecies()).append(" path=[");

		for (WorldPoint worldPoint : nearestShoal.getPathPoints()) {
			builder.append(worldPoint.getX()).append(", ").append(worldPoint.getY()).append(", 0|");
		}
		builder.append("] stops=[");
		for (WorldPoint worldPoint : nearestShoal.getStopPoints()) {
			builder.append(worldPoint.getX()).append(", ").append(worldPoint.getY()).append(", 0|");
		}

		log.info(builder.toString());*/
	}

	private static final Map<String, Integer> WORD_NUMBERS = Map.of(
			"a", 1,
			"two", 2,
			"three", 3,
			"four", 4,
			"five", 5,
			"six", 6,
			"seven", 7,
			"eight", 8,
			"nine", 9,
			"ten", 10
	);

	private int convertToNumber(String s)
	{
		s = s.toLowerCase();

		Integer v = WORD_NUMBERS.get(s);
		if (v != null)
		{
			return v;
		}

		throw new IllegalArgumentException("Unknown quantity: " + s);
	}
	public boolean isPortNetObject(int objectId)
	{
		return objectId == net.runelite.api.gameval.ObjectID.SAILING_ROPE_TRAWLING_NET_3X8_PORT
				|| objectId == net.runelite.api.gameval.ObjectID.SAILING_LINEN_TRAWLING_NET_3X8_PORT
				|| objectId == net.runelite.api.gameval.ObjectID.SAILING_HEMP_TRAWLING_NET_3X8_PORT
				|| objectId == net.runelite.api.gameval.ObjectID.SAILING_COTTON_TRAWLING_NET_3X8_PORT;
	}

	public boolean isStarboardNetObject(int objectId)
	{
		return objectId == net.runelite.api.gameval.ObjectID.SAILING_ROPE_TRAWLING_NET_3X8_STARBOARD
				|| objectId == net.runelite.api.gameval.ObjectID.SAILING_LINEN_TRAWLING_NET_3X8_STARBOARD
				|| objectId == net.runelite.api.gameval.ObjectID.SAILING_HEMP_TRAWLING_NET_3X8_STARBOARD
				|| objectId == net.runelite.api.gameval.ObjectID.SAILING_COTTON_TRAWLING_NET_3X8_STARBOARD
				|| objectId == net.runelite.api.gameval.ObjectID.SAILING_ROPE_TRAWLING_NET
				|| objectId == net.runelite.api.gameval.ObjectID.SAILING_LINEN_TRAWLING_NET
				|| objectId == net.runelite.api.gameval.ObjectID.SAILING_HEMP_TRAWLING_NET
				|| objectId == net.runelite.api.gameval.ObjectID.SAILING_COTTON_TRAWLING_NET;
	}

    private void rebuildShoalColours() {
        speciesColours.clear();
        speciesColours.put(ShoalData.ShoalSpecies.GIANT_KRILL, config.giantKrillColour());
        speciesColours.put(ShoalData.ShoalSpecies.YELLOWFIN, config.yellowfinColour());
        speciesColours.put(ShoalData.ShoalSpecies.HADDOCK, config.haddockColour());
        speciesColours.put(ShoalData.ShoalSpecies.HALIBUT, config.halibutColour());
        speciesColours.put(ShoalData.ShoalSpecies.BLUEFIN, config.bluefinColour());
        speciesColours.put(ShoalData.ShoalSpecies.MARLIN, config.marlinColour());
        speciesColours.put(ShoalData.ShoalSpecies.SHIMMERING, config.shimmeringColour());
        speciesColours.put(ShoalData.ShoalSpecies.GLISTENING, config.glisteningColour());
        speciesColours.put(ShoalData.ShoalSpecies.VIBRANT, config.vibrantColour());

    }

}

package com.deepseatrawling;

import net.runelite.client.ui.overlay.infobox.InfoBox;

import javax.inject.Inject;
import java.awt.*;
import java.awt.image.BufferedImage;

public class TrawlingNetInfoBox extends InfoBox {
    private final DeepSeaTrawling plugin;

    @Inject
    DeepSeaTrawlingConfig config;

    public TrawlingNetInfoBox(BufferedImage image, DeepSeaTrawling plugin)
    {
        super(image, plugin);
        this.plugin = plugin;
    }

    @Override
    public boolean render()
    {
        return plugin.fishQuantity > 0;
    }

    @Override
    public String getText()
    {
        // Example: show fish count
        return String.valueOf(plugin.fishQuantity);
    }

    @Override
    public String getTooltip()
    {
        // Example tooltip
        return "Fish in nets: " + plugin.fishQuantity;
    }

    @Override
    public Color getTextColor()
    {
        return config.fishCounterTextColour();
    }

}

package com.deepseatrawling;

import java.util.*;

import net.runelite.api.GameObject;
import net.runelite.api.NPC;
import net.runelite.api.gameval.AnimationID;
import net.runelite.api.gameval.ObjectID;
import net.runelite.api.WorldEntity;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;


import java.io.IOException;
import java.io.InputStream;
import java.util.stream.Collectors;

public class ShoalData {

    public enum ShoalSpecies
    {
        GIANT_KRILL (ObjectID.SAILING_SHOAL_CLICKBOX_GIANT_KRILL),
        HADDOCK (ObjectID.SAILING_SHOAL_CLICKBOX_HADDOCK),
        YELLOWFIN (ObjectID.SAILING_SHOAL_CLICKBOX_YELLOWFIN),
        HALIBUT (ObjectID.SAILING_SHOAL_CLICKBOX_HALIBUT),
        BLUEFIN (ObjectID.SAILING_SHOAL_CLICKBOX_BLUEFIN),
        MARLIN (ObjectID.SAILING_SHOAL_CLICKBOX_MARLIN),
        SHIMMERING (ObjectID.SAILING_SHOAL_CLICKBOX_SHIMMERING),
        GLISTENING (ObjectID.SAILING_SHOAL_CLICKBOX_GLISTENING),
        VIBRANT (ObjectID.SAILING_SHOAL_CLICKBOX_VIBRANT);

        private final int objectID;

        public ShoalDepth defaultDepth()
        {
            switch (this)
            {
                case GIANT_KRILL:
                case HADDOCK:
                case SHIMMERING:
                    return ShoalDepth.SHALLOW;
                default:
                    return ShoalDepth.MEDIUM;
            }
        }

        ShoalSpecies(int objectID) {
            this.objectID = objectID;
        }

        public static ShoalSpecies fromGameObjectId(int id)
        {
            for (ShoalSpecies s : values())
            {
                if (s.objectID == id) {
                    return s;
                }
            }
            return null;
        }

    }

    public enum ShoalDepth
    {
        SHALLOW,
        MEDIUM,
        DEEP,
        UNKNOWN;

        public static int asInt(ShoalDepth depth)
        {
			if (depth == null) {
				return -1;
			}
            switch(depth) {
                case SHALLOW:
                    return 1;
                case MEDIUM:
                    return 2;
                case DEEP:
                    return 3;
                default:
                    return -1;
            }
        }
    }

    public static Map<ShoalSpecies, Integer> shoalTimers = Map.of(
            ShoalSpecies.GIANT_KRILL, 150,
            ShoalSpecies.HADDOCK, 120,
            ShoalSpecies.YELLOWFIN, 100,
            ShoalSpecies.HALIBUT, 80,
            ShoalSpecies.BLUEFIN, 66,
            ShoalSpecies.MARLIN, 50
    );

    private int stopStartTick = -1;
    private int stopDurationTicks = 0; // set when stop begins
    private int lastMoveTick = -1;

    private NPC shoalNpc;

    private ShoalDepth depth;

    private static final String RESOURCE_NAME = "shoals.properties";

    private final WorldEntity worldEntity;
    private final int worldViewId;
    private ShoalSpecies species;

    private GameObject shoalObject;

    private LocalPoint last;
    private LocalPoint current;
    //private LocalPoint next;
    private boolean wasMoving;

    private List<WorldPoint> pathPoints = new ArrayList<>();
    private List<WorldPoint> stopPoints = new ArrayList<>();

    public ShoalData(int worldViewId, WorldEntity worldEntity, ShoalRoute route) throws IOException {
        this.worldViewId = worldViewId;
        this.worldEntity = worldEntity;
        this.pathPoints = route.getPathPoints();
        this.stopPoints = route.getStopPoints();
    }

    public void setSpecies(ShoalSpecies species) {
        this.species = species;
        this.depth = species.defaultDepth();
    }

    public ShoalSpecies getSpecies() {
        return species;
    }

    public ShoalDepth getDepth() {
        return depth;
    }

    public void setDepth(ShoalDepth depth) {
        this.depth = depth;
    }


    public void setShoalObject(GameObject shoalObject) {
        this.shoalObject = shoalObject;
    }

    public GameObject getShoalObject() {
        return shoalObject;
    }

    public WorldEntity getWorldEntity() {
        return worldEntity;
    }

    public int getWorldViewId() {
        return worldViewId;
    }

    public LocalPoint getCurrent() {
        return current;
    }

    public void setCurrent(LocalPoint current) {
        this.current = current;
    }

    public LocalPoint getLast() { return last; }

    public void setLast(LocalPoint last) {
        this.last = last;
    }

    /*
    public void setNext(LocalPoint next) {
        this.next = next;
    }

    public void setPathPoints(WorldPoint worldPoint) {
            pathPoints.add(worldPoint);
    }

    public void setStopPoints(WorldPoint worldPoint) {
        if(stopPoints.contains(worldPoint))
        {
            return;
        }
        stopPoints.add(worldPoint);
    }
*/
    public List<WorldPoint> getPathPoints() {
        return pathPoints;
    }

    public List<WorldPoint> getStopPoints() {
        return stopPoints;
    }

    public boolean getWasMoving() {
        return wasMoving;
    }

    public void setWasMoving(boolean wasMoving) { this.wasMoving = wasMoving; }

    public void setShoalNpc(NPC shoalNpc) {
        this.shoalNpc = shoalNpc;
    }

    public void setDepthFromAnimation()
    {
        if (shoalNpc == null)
        {
            this.depth = ShoalDepth.UNKNOWN;
            return;
        }
        int animation = shoalNpc.getAnimation();
        if (animation == -1)
        {
            return;
        }

        switch (animation)
        {
			case AnimationID.DEEP_SEA_TRAWLING_SHOAL_SHALLOW:
                this.depth = ShoalDepth.SHALLOW;
                break;
            case AnimationID.DEEP_SEA_TRAWLING_SHOAL_MID:
                this.depth = ShoalDepth.MEDIUM;
                break;
            case AnimationID.DEEP_SEA_TRAWLING_SHOAL_DEEP:
                this.depth = ShoalDepth.DEEP;
                break;
            default:
                this.depth = ShoalDepth.UNKNOWN;

        }

    }
    public NPC getShoalNpc() {
        return shoalNpc;
    }

    public void beginStopTimer(int currentTick, int durationTicks)
    {
        this.stopStartTick = currentTick;
        this.stopDurationTicks = durationTicks;
    }

    public void clearStopTimer()
    {
        this.stopStartTick = -1;
        this.stopDurationTicks = 0;
    }

    public boolean hasActiveStopTimer()
    {
        return stopStartTick >= 0 && stopDurationTicks > 0;
    }

    public int getTicksUntilMove(int currentTick)
    {
        if (!hasActiveStopTimer()) return -1;
        int elapsed = currentTick - stopStartTick;
        return Math.max(0, stopDurationTicks - elapsed);
    }

    public int getTicksUntilDepthChange(int currentTick)
    {
        if (!hasActiveStopTimer()) return -1;
        int half = stopDurationTicks / 2;
        int elapsed = currentTick - stopStartTick;
        return Math.max(0, half - elapsed);
    }

    public boolean isPastDepthChangePoint(int currentTick)
    {
        if (!hasActiveStopTimer()) return false;
        int half = stopDurationTicks / 2;
        return (currentTick - stopStartTick) >= half;
    }


}

package com.deepseatrawling;

import lombok.Value;
import net.runelite.api.coords.WorldPoint;

import java.util.List;

@Value
public class ShoalRoute
{
    List<WorldPoint> pathPoints;
    List<WorldPoint> stopPoints;

    public static final ShoalRoute EMPTY = new ShoalRoute(List.of(), List.of());
}
package com.deepseatrawling;

import net.runelite.api.*;
import net.runelite.api.Point;
import net.runelite.client.Notifier;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.coords.LocalPoint;

import javax.inject.Inject;
import java.util.ArrayList;
import java.util.List;
import java.awt.*;


public class DeepSeaTrawlingOverlay extends Overlay {

    private final Client client;
    private final DeepSeaTrawling plugin;

    @Inject
    DeepSeaTrawlingConfig config;

    @Inject
    Notifier notifier;
    private boolean notifiedShoalMoving = false;

    @Inject
    private DeepSeaTrawlingOverlay(Client client, DeepSeaTrawling plugin) {
        this.client = client;
        this.plugin = plugin;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
    }

    @Override
    public Dimension render(Graphics2D graphics) {

        if (plugin.netObjectByIndex[0] == null && plugin.netObjectByIndex[1] == null)
        {
            return null;
        }
        ShoalData shoal = plugin.getNearestShoal();
        if (shoal == null) {
            return null;
        }

        GameObject object = shoal.getShoalObject();
        if (object == null)
        {
            return null;
        }

        LocalPoint localLocation = object.getLocalLocation();

        ObjectComposition composition = client.getObjectDefinition(object.getId());
        if (composition == null) {
            return null;
        }

        int sizeX = composition.getSizeX();
        int sizeY = composition.getSizeY();

        int size = Math.max(sizeX, sizeY);
        if (size <= 0) {
            size = 1;
        }
        if(plugin.trackedShoals.contains(shoal.getWorldViewId())) {
            Color baseColour = plugin.speciesColours.getOrDefault(shoal.getSpecies(), Color.WHITE);

            if (config.pathColourMode() == DeepSeaTrawlingConfig.PathColourMode.SOLID && (shoal.getSpecies() == ShoalData.ShoalSpecies.SHIMMERING || shoal.getSpecies() == ShoalData.ShoalSpecies.GLISTENING || shoal.getSpecies() == ShoalData.ShoalSpecies.VIBRANT))
            {
                drawPath(graphics, shoal, config.specialPathColour());
            } else if (config.pathColourMode() == DeepSeaTrawlingConfig.PathColourMode.SOLID) {
                drawPath(graphics, shoal, config.shoalPathColour());
            } else {
                drawPath(graphics, shoal, Color.WHITE);
            }
            drawStopSquares(graphics, shoal, size, baseColour);

            drawArea(graphics, localLocation, size, baseColour);

            drawDepthLabel(graphics, shoal, size);

            if (!shoal.hasActiveStopTimer() && !notifiedShoalMoving && config.notifyShoalMoving()) {
                notifier.notify("Shoal is on the move! Set sail!");
                notifiedShoalMoving = true;
            } else if (shoal.hasActiveStopTimer()){
                notifiedShoalMoving = false;
            }
        }

        return null;
    }

    private void drawArea(Graphics2D graphics, LocalPoint centerLP, int sizeTiles, Color baseColour)
    {
        Polygon poly = Perspective.getCanvasTileAreaPoly(client, centerLP, sizeTiles);
        if (poly == null)
        {
            return;
        }

        graphics.setStroke(new BasicStroke(2));
        OverlayUtil.renderPolygon(graphics, poly, baseColour);

        Color fill = new Color(baseColour.getRed(), baseColour.getGreen(), baseColour.getBlue(), 50);
        Composite old = graphics.getComposite();
        graphics.setComposite(AlphaComposite.SrcOver.derive(fill.getAlpha() / 255f));
        graphics.setColor(fill);
        graphics.fill(poly);
        graphics.setComposite(old);
    }

    private void drawPath (Graphics2D path, ShoalData shoal, Color baseColour)
    {
        java.util.List<WorldPoint> points = shoal.getPathPoints();
        if (points.size() < 2) {
            return;
        }
        if (config.diagonalSmoothing())
        {
            points = smoothDiagonals(points);
        }

        int plane = shoal.getWorldEntity().getWorldView().getPlane();

        path.setStroke(new BasicStroke(1.5f));

        int ARROW_EVERY_N_SEGMENTS = 5;
        for (int i = 0; i < points.size() - 1; i++)
        {
            WorldPoint worldPointA = points.get(i);
            WorldPoint worldPointB = points.get(i+1);
            if (worldPointA == null || worldPointB == null) {
                continue;
            }

            LocalPoint localPointA = LocalPoint.fromWorld(client, worldPointA);
            LocalPoint localPointB = LocalPoint.fromWorld(client, worldPointB);
            if (localPointA == null || localPointB == null) {
                continue;
            }

            Point pointA = Perspective.localToCanvas(client, localPointA, plane);
            Point pointB = Perspective.localToCanvas(client, localPointB, plane);
            if (pointA == null || pointB == null)
            {
                continue;
            }

            if (config.pathColourMode() == DeepSeaTrawlingConfig.PathColourMode.GRADIENT) {
                float t = (points.size() <= 1) ? 0f : (i / (float)(points.size() - 1));
                baseColour = Color.getHSBColor(t, 1.0f, 1.0f);
            }

            path.setColor(baseColour);

            path.drawLine(pointA.getX(), pointA.getY(), pointB.getX(), pointB.getY());

            if (config.showDirectionArrows() && i % ARROW_EVERY_N_SEGMENTS == 0)
            {
                drawArrow(path, pointA, pointB, baseColour);
            }
        }
    }

    private void drawStopSquares(Graphics2D square, ShoalData shoal, int sizeTiles, Color baseColour)
    {
        Color outline = new Color(baseColour.getRed(), baseColour.getGreen(), baseColour.getBlue());
        Color fill = new Color(baseColour.getRed(), baseColour.getGreen(), baseColour.getBlue(), 50);

        for (WorldPoint worldPoint : shoal.getStopPoints())
        {
            if (worldPoint == null ) {
                continue;
            }

            LocalPoint localPoint = LocalPoint.fromWorld(client, worldPoint);
            if (localPoint == null) {
                continue;
            }

            if (plugin.localDistanceSq(localPoint, shoal.getCurrent()) < 512 * 512) {
                continue;
            }

            Polygon polygon = Perspective.getCanvasTileAreaPoly(client, localPoint, sizeTiles);
            if (polygon == null) {
                continue;
            }

            square.setStroke(new BasicStroke(2));
            OverlayUtil.renderPolygon(square, polygon, outline);

            Composite old = square.getComposite();
            square.setComposite(AlphaComposite.SrcOver.derive(fill.getAlpha() / 255f));
            square.setColor(fill);
            square.fill(polygon);
            square.setComposite(old);
        }
    }

    private void drawArrow(Graphics2D graphics, Point from, Point to, Color colour)
    {
        if (from == null || to == null) {
            return;
        }

        graphics.setColor(colour);
        graphics.setStroke(new BasicStroke(2));

        double dx = to.getX() - from.getX();
        double dy = to.getY() - from.getY();
        double angle = Math.atan2(dy, dx);

        int arrowLength = 10;
        int arrowWidth = 6;

        double leftAngle = angle + Math.toRadians(155);
        double rightAngle = angle - Math.toRadians(155);

        int x1 = to.getX() + (int) (Math.cos(leftAngle) * arrowLength);
        int y1 = to.getY() + (int) (Math.sin(leftAngle) * arrowLength);

        int x2 = to.getX() + (int) (Math.cos(rightAngle) * arrowLength);
        int y2 = to.getY() + (int) (Math.sin(rightAngle) * arrowLength);

        int[] xs = { to.getX(), x1, x2 };
        int[] ys = { to.getY(), y1, y2 };

        graphics.fillPolygon(xs, ys, 3);
    }

    private void drawDepthLabel(Graphics2D graphic, ShoalData shoal, int sizeTiles)
    {
        if (!config.showShoalDepthText() && !config.showDepthTimer()) {
            return;
        }
        ShoalData.ShoalDepth depth = shoal.getDepth();
        String depthText;
        Color textColour;

        switch (depth)
        {
            case SHALLOW:
                depthText = "Shallow";
                textColour = new Color(0, 200, 0);
                break;
            case MEDIUM:
                depthText = "Medium";
                textColour = new Color(255, 165, 0);
                break;
            case DEEP:
                depthText = "Deep";
                textColour = new Color(200, 60, 60);
                break;
            default:
                depthText = "UNKNOWN";
                textColour = Color.GRAY;
        }

        GameObject object = shoal.getShoalObject();
        if (object == null) {
            return;
        }

        LocalPoint centralPoint = object.getLocalLocation();

        Polygon poly = Perspective.getCanvasTilePoly(client, centralPoint, sizeTiles);
        if (poly == null) {
            return;
        }

        Rectangle bounds = poly.getBounds();
        int anchorX = bounds.x + bounds.width / 2;
        int anchorY = bounds.y;

        graphic.setFont(FontManager.getRunescapeBoldFont().deriveFont( 14f));
        FontMetrics metrics = graphic.getFontMetrics();

        java.util.List<String> lines = new ArrayList<>();

        if (config.showShoalDepthText()) {
            lines.add(depthText);
        }

        int nowTick = client.getTickCount();
        if (!shoal.getWasMoving() && shoal.hasActiveStopTimer() && config.showDepthTimer())
        {
            int tDepth = shoal.getTicksUntilDepthChange(nowTick);
            int tMove  = shoal.getTicksUntilMove(nowTick);

            // Show "until net change" only before halfway point
            if (tDepth > 0)
            {
                lines.add("Net change: " + formatTicks(tDepth));
            }
            // Always show "until move" while stopped (until it hits 0)
            if (tMove >= 0)
            {
                lines.add("Moves: " + formatTicks(tMove));
            }
        }
        if (lines.isEmpty()) {
            return;
        }

        int lineHeight = metrics.getHeight();
        int maxWidth = 0;

        for (String str : lines) {
            maxWidth = Math.max(maxWidth, metrics.stringWidth(str));
        }

        int x = anchorX - maxWidth / 2;
        int y = anchorY - 8;

        int boxHeight = lineHeight * lines.size();
        graphic.setColor(new Color(0,0,0,140));
        graphic.fillRoundRect(x - 3, y - boxHeight, maxWidth + 6, boxHeight, 6, 6);

        // Draw lines top -> bottom
        for (int i = 0; i < lines.size(); i++)
        {
            String l = lines.get(i);
            int lx = anchorX - (metrics.stringWidth(l) / 2);
            int ly = y - (lineHeight * (lines.size() - 1 - i)); // stack upward

            // color: depth line uses depth colour; timers use white
            graphic.setColor(i == 0 ? textColour : Color.WHITE);
            graphic.drawString(l, lx, ly);
        }

    }

    private static String formatTicks(int ticks)
    {
        if (ticks < 0) return "";
        int totalSeconds = (int) Math.ceil(ticks * 0.6);
        int m = totalSeconds / 60;
        int s = totalSeconds % 60;
        return (m > 0) ? String.format("%d:%02d", m, s) : String.format("%ds", s);
    }

    private static List<WorldPoint> smoothDiagonals(List<WorldPoint> in) {
        if (in == null || in.size() < 3) return in;

        java.util.List<WorldPoint> out = new ArrayList<>();
        out.add(in.get(0));

        int i = 1;
        while (i < in.size() - 1)
        {
            WorldPoint a = out.get(out.size() - 1);
            WorldPoint b = in.get(i);
            WorldPoint c = in.get(i + 1);

            int abx = b.getX() - a.getX();
            int aby = b.getY() - a.getY();
            int bcx = c.getX() - b.getX();
            int bcy = c.getY() - b.getY();

            // A->B and B->C are cardinal steps (N/E/S/W)
            boolean abCardinal = (Math.abs(abx) + Math.abs(aby)) == 1;
            boolean bcCardinal = (Math.abs(bcx) + Math.abs(bcy)) == 1;

            // A->C is a diagonal neighbour (one tile diagonally)
            int acx = c.getX() - a.getX();
            int acy = c.getY() - a.getY();
            boolean acDiagonal = Math.abs(acx) == 1 && Math.abs(acy) == 1;

            // Ensure itâ€™s a "turn" not a straight line
            boolean turnsCorner = (abx != bcx) || (aby != bcy);

            if (abCardinal && bcCardinal && acDiagonal && turnsCorner)
            {
                // Drop the corner point b (replace stair with diagonal)
                i++;           // skip b
                out.add(c);    // add c directly
                i++;           // move past c
                continue;

            }

            out.add(b);
            i++;
        }

        // Add the last point if we didn't already
        WorldPoint lastIn = in.get(in.size() - 1);
        if (out.get(out.size() - 1) != lastIn)
        {
            out.add(lastIn);
        }

        return out;
    }
}

package com.deepseatrawling;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

import java.awt.*;

@ConfigGroup("deepseatrawling")
public interface DeepSeaTrawlingConfig extends Config
{
    // --------------- Sections ------------------------
    @ConfigSection(
            name = "Shoals",
            description = "Shoal rendering and prediction settings",
            position = 0
    )
    String shoalsSection = "Shoals Section";

    @ConfigSection(
            name = "Nets",
            description = "Net overlays + UI highlights",
            position = 1
    )
    String netsSection = "Nets Section";

    @ConfigSection(
            name = "Notifications",
            description = "Desktop notifications",
            position = 2
    )
    String notifSection = "Notification Section";

    @ConfigSection(
            name = "Colours",
            description = "Custom colours for overlays",
            position = 3
    )
    String coloursSection = "Colours Section";


    // --------------- Shoals Section ------------------
    @ConfigItem(
            keyName = "showGiantKrill",
            name = "Show Giant Krill Shoals",
            description = "Highlight Giant Krill Shoals",
            position = 0,
            section = shoalsSection
    )
    default boolean showGiantKrill()
    {
        return true;
    }


    @ConfigItem(
			keyName = "showHaddock",
			name = "Show Haddock Shoals",
			description = "Highlight Haddock Shoals",
            position = 1,
            section = shoalsSection
	)
	default boolean showHaddock()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showYellowfin",
			name = "Show Yellowfin Shoals",
			description = "Highlight Yellowfin Shoals",
            position = 2,
            section = shoalsSection
	)
	default boolean showYellowfin()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showHalibut",
			name = "Show Halibut Shoals",
			description = "Highlight Halibut Shoals",
            position = 3,
            section = shoalsSection
	)
	default boolean showHalibut()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showBluefin",
			name = "Show Bluefin Shoals",
			description = "Highlight Bluefin Shoals",
            position = 4,
            section = shoalsSection
	)
	default boolean showBluefin()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showMarlin",
			name = "Show Marlin Shoals",
			description = "Highlight Marlin Shoals",
            position = 5,
            section = shoalsSection
	)
	default boolean showMarlin()
	{
		return true;
	}

    @ConfigItem(
            keyName = "showDirectionArrows",
            name = "Show direction arrows",
            description = "Draw arrowheads along the path line",
            position = 10,
            section = shoalsSection
    )
    default boolean showDirectionArrows() { return true; }

    @ConfigItem(
            keyName = "diagonalSmoothing",
            name = "Smooth diagonal path prediction",
            description = "Reduces zig-zag in diagonal segments (higher = smoother, but less 'grid accurate')",
            position = 12,
            section = shoalsSection
    )
    default boolean diagonalSmoothing() { return false; }

    @ConfigItem(
            keyName = "showDepthTimer",
            name = "Depth Change Timer",
            description = "Show the Timer until the Depth changes / the Shoal moves again",
            position = 13,
            section = shoalsSection
    )
    default boolean showDepthTimer() { return true; }

    // ------------------------ Path Colour Mode ---------------------
    enum PathColourMode { SOLID, GRADIENT }

    @ConfigItem(
            keyName = "pathColourMode",
            name = "Path colour mode",
            description = "Solid uses one colour; Gradient cycles colours along the route to help follow overlaps",
            position = 13,
            section = shoalsSection
    )
    default PathColourMode pathColourMode() { return PathColourMode.SOLID; }

    // -------------------- Nets Section -----------------------------------
    enum NetHighlightStyle
    {
        OUTLINE,        // convex hull / polygon outline
        HULL_FILL,      // filled convex hull
        CLICKBOX        // use getClickbox() if available
    }

    @ConfigItem(
            keyName = "highlightWrongDepthNets",
            name = "Highlight nets at wrong depth",
            description = "Highlights trawling nets when they don't match the shoal depth",
            position = 0,
            section = netsSection
    )
    default boolean highlightWrongDepthNets() { return true; }

    @ConfigItem(
            keyName = "highlightFullNets",
            name = "Highlight nets when full",
            description = "Highlights trawling nets when they're full",
            position = 1,
            section = netsSection
    )
    default boolean highlightFullNets() { return true; }

    @ConfigItem(
            keyName = "netHighlightStyle",
            name = "Net highlight style",
            description = "How the net should be highlighted when it needs adjustment",
            position = 2,
            section = netsSection
    )
    default NetHighlightStyle netHighlightStyle() { return NetHighlightStyle.OUTLINE; }

    @ConfigItem(
            keyName = "showNetDepthText",
            name = "Show net depth text (R/S/M/D)",
            description = "Draws the current depth setting of each net on-screen (scene or widget overlay)",
            position = 3,
            section = netsSection
    )
    default boolean showNetDepthText() { return true; }

    @ConfigItem(
            keyName = "showNetWidgetHint",
            name = "Highlight net up/down UI buttons",
            description = "Highlights the sailing sidepanel buttons that should be pressed",
            position = 4,
            section = netsSection
    )
    default boolean showNetWidgetHint() { return true; }

    @ConfigItem(
            keyName = "showShoalDepthText",
            name = "Show shoal depth text (Shallow/Medium/Deep)",
            description = "Draws the current depth setting of nearest shoal on screen",
            position = 5,
            section = netsSection
    )
    default boolean showShoalDepthText() { return true; }

    // ---------- Notifications ----------
    @ConfigItem(
            keyName = "notifyNetFull",
            name = "Notify when net is full",
            description = "Shows a RuneLite notification when your nets are full",
            position = 0,
            section = notifSection
    )
    default boolean notifyNetFull() { return true; }

    @ConfigItem(
            keyName = "notifyDepthChange",
            name = "Notify when depth change (on screen)",
            description = "Shows a RuneLite notification when the rendered shoal's depth changes",
            position = 1,
            section = notifSection
    )
    default boolean notifyDepthChange() { return true; }

    @ConfigItem(
            keyName = "notifyShoalMoving",
            name = "Notify when shoal moves (on screen)",
            description = "Shows a RuneLite notification when the rendered shoal begins moving",
            position = 2,
            section  = notifSection
    )
    default boolean notifyShoalMoving() { return true; }

    // -------------- Colours ---------------------
    @ConfigItem(
            keyName = "fishCounterTextColour",
            name = "Fish counter text colour",
            description = "Colour of the fish quantity text",
            position = 0,
            section = coloursSection
    )
    default Color fishCounterTextColour() { return Color.WHITE; }

    @ConfigItem(
            keyName = "uiHighlightColour",
            name = "Highlight UI Button Colour",
            description = "Colour UI Button to improve readability",
            position = 1,
            section = coloursSection
    )
    default Color uiHighlightColour() { return new Color(255, 255, 0); }

    @ConfigItem(
            keyName = "netDepthHighlightColour",
            name = "Wrong Net Depth highlight colour",
            description = "Colour used to highlight the net when it's at the wrong depth",
            position = 2,
            section = coloursSection
    )
    default Color netDepthHighlightColour() { return new Color(255, 255, 0, 220); }

    @ConfigItem(
            keyName = "netFullHighlightColour",
            name = "Net Full highlight colour",
            description = "Colour used to highlight the net when it's full",
            position = 3,
            section = coloursSection
    )
    default Color netFullHighlightColour() { return Color.RED; }

    @ConfigItem(
            keyName = "shoalPathColour",
            name = "Regular Shoal path solid colour",
            description = "Solid path line colour (used when Path colour mode = SOLID) and NOT special shoal",
            position = 3,
            section = coloursSection
    )
    default Color shoalPathColour() { return new Color(0,51,102); }

    @ConfigItem(
            keyName = "specialPathColour",
            name = "Special Shoal path solid colour",
            description = "Solid path line colour (used when path colour mode = SOLID) and IS special shoal",
            position = 4,
            section = coloursSection
    )
    default Color specialPathColour() { return new Color(0,204,255); }

    @ConfigItem(
            keyName = "giantKrillColour",
            name = "Giant Krill Colour",
            description = "Colour of Giant Krill Shoals",
            position = 5,
            section = coloursSection
    )
    default Color giantKrillColour() { return new Color(255, 150, 150); }

    @ConfigItem(
            keyName = "haddockColour",
            name = "Haddock Colour",
            description = "Colour of Haddock Shoals",
            position = 6,
            section = coloursSection
    )
    default Color haddockColour() { return new Color(255, 255, 200); }

    @ConfigItem(
            keyName = "shimmeringColour",
            name = "Shimmering Colour",
            description = "Colour of Shimmering Shoals",
            position = 7,
            section = coloursSection
    )
    default Color shimmeringColour() { return new Color(200, 255, 255); }

    @ConfigItem(
            keyName = "yellowfinColour",
            name = "Yellowfin Colour",
            description = "Colour of Yellowfin Shoals",
            position = 8,
            section = coloursSection
    )
    default Color yellowfinColour() { return new Color(255, 220, 120); }

    @ConfigItem(
            keyName = "halibutColour",
            name = "Halibut Colour",
            description = "Colour of Halibut Shoals",
            position = 9,
            section = coloursSection
    )
    default Color halibutColour() { return new Color(200, 255, 200); }

    @ConfigItem(
            keyName = "glisteningColour",
            name = "Glistening Colour",
            description = "Colour of Glistening Shoals",
            position = 10,
            section = coloursSection
    )
    default Color glisteningColour() { return new Color(220, 200, 255); }

    @ConfigItem(
            keyName = "bluefinColour",
            name = "Bluefin Colour",
            description = "Colour of Bluefin Shoals",
            position = 11,
            section = coloursSection
    )
    default Color bluefinColour() { return new Color(120, 180, 255); }

    @ConfigItem(
            keyName = "marlinColour",
            name = "Marlin Colour",
            description = "Colour of Marlin Shoals",
            position = 12,
            section = coloursSection
    )
    default Color marlinColour() { return new Color(0, 200, 255); }

    @ConfigItem(
            keyName = "vibrantColour",
            name = "Vibrant Colour",
            description = "Colour of Vibrant Shoals",
            position = 13,
            section = coloursSection
    )
    default Color vibrantColour() { return new Color(255, 200, 220); }

}

package com.deepseatrawling;

import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.client.config.Config;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.inject.Inject;
import java.awt.*;

public class TrawlingNetOverlay extends Overlay {

    private final Client client;
    private final DeepSeaTrawling plugin;

    @Inject
    DeepSeaTrawlingConfig config;

    @Inject
    private TrawlingNetOverlay(Client client, DeepSeaTrawling plugin) {
        this.client = client;
        this.plugin = plugin;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!config.highlightFullNets() && !config.highlightWrongDepthNets()) {
            return null;
        }
        if (plugin.netList[0] == null && plugin.netList[1] == null)
        {
            return null;
        }

        int totalNetSize = 0;
        if (plugin.netList[0] != null)
        {
            totalNetSize += plugin.netList[0].getNetSize();
        }
        if (plugin.netList[1] != null)
        {
            totalNetSize += plugin.netList[1].getNetSize();
        }

        int desiredDepth = -1;
        if (config.highlightWrongDepthNets())
        {
            ShoalData shoal = plugin.getNearestShoal();
            if (shoal != null && shoal.getDepth() != ShoalData.ShoalDepth.UNKNOWN)
            {
                desiredDepth = ShoalData.ShoalDepth.asInt(shoal.getDepth());
            }
        }

        if (desiredDepth < 1)
        {
            return null;
        }

        for (int netIndex = 0; netIndex <= 1; netIndex++)
        {
            GameObject netObj = plugin.netObjectByIndex[netIndex];
            if (netObj == null) continue;

            Net net = plugin.netList[netIndex];
            if (net == null) continue;

            if (config.highlightFullNets() && plugin.fishQuantity >= totalNetSize)
            {
                trawlingNetOutline(graphics, plugin.fishQuantity, totalNetSize, netObj);
                continue;
            }

            int currentDepth = Net.NetDepth.asInt(net.getNetDepth());
            if (config.highlightWrongDepthNets() && currentDepth > 0 && currentDepth != desiredDepth)
            {
                trawlingNetOutline(graphics, plugin.fishQuantity, totalNetSize, netObj);
            }

        }

        return null;

    }

    private void trawlingNetOutline(Graphics2D graphic, int fishQuantity, int totalNetSize, GameObject netObject) {
        if (netObject == null) {
            return;
        }

        Shape netShape = null;
        switch (config.netHighlightStyle()) {
            case CLICKBOX:
                netShape = netObject.getClickbox();
                break;
            case HULL_FILL:
            case OUTLINE:
                netShape = netObject.getConvexHull();
                break;
        }
        if (netShape == null) {
            return;
        }

        if (fishQuantity >= totalNetSize && config.highlightFullNets()) {
            if (config.netHighlightStyle() == DeepSeaTrawlingConfig.NetHighlightStyle.HULL_FILL) {
                graphic.setColor(new Color(config.netFullHighlightColour().getRed(), config.netFullHighlightColour().getGreen(),config.netFullHighlightColour().getBlue(), 60));
                graphic.fill(netShape);
            }
            OverlayUtil.renderPolygon(graphic, netShape, config.netFullHighlightColour());
        } else if (config.highlightWrongDepthNets()) {
            if (config.netHighlightStyle() == DeepSeaTrawlingConfig.NetHighlightStyle.HULL_FILL) {
                graphic.setColor(new Color(config.netDepthHighlightColour().getRed(), config.netDepthHighlightColour().getGreen(),config.netDepthHighlightColour().getBlue(), 60));
                graphic.fill(netShape);
            }
            OverlayUtil.renderPolygon(graphic, netShape, config.netDepthHighlightColour());
        }

    }
}
package com.deepseatrawling;

public class Net {

    private final int netIndex;
    private NetDepth netDepth = NetDepth.RAISED;
    private final static int netSize = 125;

    public Net(int netIndex) {
        this.netIndex = netIndex;
    }

    public int getNetSize() {
        return netSize;
    }

    public void setNetDepth(int netDepth) {
        for (NetDepth newDepth : NetDepth.values())
        {
            if (newDepth.depth == netDepth) {
                this.netDepth = newDepth;
            }
        }
    }

    public NetDepth getNetDepth() {
        return netDepth;
    }
    public int getNetDepthAsInt() {
        return netDepth.depth;
    }

    public enum NetDepth {
        RAISED(0),
        SHALLOW(1),
        MEDIUM(2),
        DEEP(3);

        public static int asInt(NetDepth depth) {
            switch (depth) {
                case RAISED:
                    return 0;
                case SHALLOW:
                    return 1;
                case MEDIUM:
                    return 2;
                case DEEP:
                    return 3;
                default:
                    return -1;
            }
        }

        private final int depth;

        NetDepth(int depth) {
            this.depth = depth;
        }
    }
}

package com.deepseatrawling;

import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;
import net.runelite.client.Notifier;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.api.WorldEntity;

import javax.inject.Inject;
import java.awt.*;

public class DeepSeaTrawlingWidgetOverlay extends Overlay {

    @Inject
    private Notifier notifier;
    private boolean notifiedDepthChange = false;

    private static final int SAILING_SIDEPANEL_GROUP = 937;
    private static final int FACILITIES_CONTENT_CLICKLAYER_CHILD = 25;

    private static final int SKIFF_DOWN_INDEX = 29;
    private static final int SKIFF_UP_INDEX = 30;
    private static final int STARBOARD_DOWN_INDEX = 41;
    private static final int STARBOARD_UP_INDEX = 42;
    private static final int PORT_DOWN_INDEX = 45;
    private static final int PORT_UP_INDEX = 46;

    private static final int SKIFF_WORLDVIEW_ID = 2;
    private static final int SLOOP_WORLDVIEW_ID = 3;

    private final Client client;
    private final DeepSeaTrawling plugin;

    @Inject
    DeepSeaTrawlingConfig config;

    enum Direction {
        UP,
        DOWN
    }

    @Inject
    public DeepSeaTrawlingWidgetOverlay(Client client, DeepSeaTrawling plugin)
    {
        this.client = client;
        this.plugin = plugin;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (plugin.boats.get(client.getLocalPlayer().getWorldView().getId()) != null) {
            int playerBoat = plugin.boats.get(client.getLocalPlayer().getWorldView().getId());
            if (config.showNetDepthText()) {
                if (playerBoat == SKIFF_WORLDVIEW_ID) {
                    drawNetDepthLetter(graphics, 0);
                } else if (playerBoat == SLOOP_WORLDVIEW_ID) {
                    drawNetDepthLetter(graphics, 0);
                    drawNetDepthLetter(graphics, 1);
                }
        }
    }
       ShoalData shoal = plugin.getNearestShoal();
       if (shoal != null && shoal.getDepth() != ShoalData.ShoalDepth.UNKNOWN)
       {
           int desired = ShoalData.ShoalDepth.asInt(shoal.getDepth());
           if (desired < 1) {
               return null;
           }

           for (int netIndex = 0; netIndex < 2; netIndex++)
           {
               int current = Net.NetDepth.asInt(plugin.netList[netIndex].getNetDepth());
               if (current <= 0 || current == desired) {
                   notifiedDepthChange = false;
                   continue;
               }

               if (!notifiedDepthChange && config.notifyDepthChange()) {
                   notifier.notify("Shoal Depth Changed! Change net depth!");
                   notifiedDepthChange = true;
               }
               if (config.showNetWidgetHint()) {
                   Direction direction = current < desired ? Direction.DOWN : Direction.UP;
                   highlightNetButton(graphics, netIndex, direction);
               }
           }
       }
        return null;
    }

    private void highlightNetButton(Graphics2D g, int netIndex, Direction direction)
    {
        Widget parent = client.getWidget(SAILING_SIDEPANEL_GROUP , FACILITIES_CONTENT_CLICKLAYER_CHILD);
        if (parent == null) return;
        boolean hidden = false;
        for (Widget widgetParent = parent; widgetParent != null; widgetParent = widgetParent.getParent())
        {
            if (widgetParent.isHidden()) {
                hidden = true;
            }
        }

        if (plugin.boats.get(client.getLocalPlayer().getWorldView().getId()) == null) {
            return;
        }
        int shipType = plugin.boats.get(client.getLocalPlayer().getWorldView().getId());

        int childId = -1;
        if (netIndex == 0) {
            if (shipType == SKIFF_WORLDVIEW_ID) {
                childId = (direction == Direction.DOWN ? SKIFF_DOWN_INDEX : SKIFF_UP_INDEX);
            } else if (shipType == SLOOP_WORLDVIEW_ID){
                childId = (direction == Direction.DOWN ? STARBOARD_DOWN_INDEX : STARBOARD_UP_INDEX);
            }
        } else if (netIndex == 1) {
            childId = direction == Direction.DOWN ? PORT_DOWN_INDEX : PORT_UP_INDEX;
        } else {
            return;
        }

        Widget viewport = client.getWidget(161, 73);
        if (viewport == null) {
            viewport = client.getWidget(164, 72);
            if (viewport == null) return;
        }
        Rectangle canvas = viewport.getBounds();

        Widget button = parent.getChild(childId);
        if (button == null || button.isHidden() || hidden) return;

        Rectangle bounds = button.getBounds();
        if (bounds == null || bounds.width <= 0 || bounds.height <= 0) return;
        if (!canvas.intersects(button.getBounds())) return;

        g.setColor(new Color(config.uiHighlightColour().getRed(), config.uiHighlightColour().getGreen(), config.uiHighlightColour().getBlue(), 120));
        g.fillRoundRect(bounds.x, bounds.y, bounds.width, bounds.height, 8, 8);

        g.setColor(new Color(config.uiHighlightColour().getRed(), config.uiHighlightColour().getGreen(), config.uiHighlightColour().getBlue(), 220));
        g.setStroke(new BasicStroke(2));
        g.drawRoundRect(bounds.x, bounds.y, bounds.width, bounds.height, 8, 8);


    }

    private void drawNetDepthLetter(Graphics2D graphics, int netIndex) {
        int downId = -1;

        Widget parent = client.getWidget(SAILING_SIDEPANEL_GROUP , FACILITIES_CONTENT_CLICKLAYER_CHILD);
        if (parent == null) return;
        boolean hidden = false;
        for (Widget widgetParent = parent; widgetParent != null; widgetParent = widgetParent.getParent())
        {
            if (widgetParent.isHidden()) {
                hidden = true;
            }
        }

        if (plugin.boats.get(client.getLocalPlayer().getWorldView().getId()) == null) {
            return;
        }
        int shipType = plugin.boats.get(client.getLocalPlayer().getWorldView().getId());


        if (shipType == SLOOP_WORLDVIEW_ID) {
            downId = (netIndex == 0) ? STARBOARD_DOWN_INDEX : PORT_DOWN_INDEX;
        } else if (shipType == SKIFF_WORLDVIEW_ID) {
            downId = SKIFF_DOWN_INDEX;
        }
        if (downId < 0) { return; }

        Widget down = parent.getChild(downId);

        Widget viewport = client.getWidget(161, 73);
        if (viewport == null) {
            viewport = client.getWidget(164, 72);
            if (viewport == null) return;
        }
        Rectangle canvas = viewport.getBounds();

        if (down == null || down.isHidden())
        {
            return;
        }

        Rectangle downButton = down.getBounds();

        if (downButton == null || downButton.width <= 0 || downButton.height <= 0)
        {
            return;
        }
        if (!canvas.intersects(downButton)) return;

        Net net = plugin.netList[netIndex];
        if (net == null)
        {
            return;
        }

        String letter = depthLetter(net.getNetDepth());

        int targetX = downButton.x - 39;                  // left of the down button (magic number)
        int targetY = downButton.y;                       // halfway towards the up button (if dy=0, stays on down)

        // Draw the label with a background pill
        graphics.setFont(FontManager.getRunescapeBoldFont().deriveFont( 14f));
        FontMetrics fm = graphics.getFontMetrics();

        int textW = fm.stringWidth(letter);
        int textH = fm.getAscent();

        int x = targetX - textW / 2 + downButton.width / 2;  // center-ish relative to down button width
        int y = targetY + downButton.height / 2 + textH / 2 - 2;

        int padX = 6;
        int padY = 4;

        int bgW = textW + padX * 2;
        int bgH = fm.getHeight() + padY * 2;

        int bgX = x - padX;
        int bgY = y - fm.getAscent() - padY;

        graphics.setColor(new Color(0, 0, 0, 160));
        graphics.fillRoundRect(bgX, bgY, bgW, bgH, 10, 10);

        graphics.setColor(colorForDepth(net.getNetDepth()));
        graphics.drawString(letter, x, y);
    }

    private static String depthLetter(Net.NetDepth d)
    {
        switch (d)
        {
            case RAISED:  return "R";
            case SHALLOW: return "S";
            case MEDIUM:  return "M";
            case DEEP:    return "D";
            default:      return "?";
        }
    }

    private static Color colorForDepth(Net.NetDepth d)
    {
        switch (d)
        {
            case RAISED:  return new Color(200, 200, 200);
            case SHALLOW: return new Color(80, 255, 80);
            case MEDIUM:  return new Color(255, 200, 80);
            case DEEP:    return new Color(255, 80, 80);
            default:      return Color.WHITE;
        }
    }
}

package com.deepseatrawling;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.coords.WorldPoint;

import javax.inject.Singleton;
import java.io.IOException;
import java.io.InputStream;
import java.util.*;
import java.util.stream.Collectors;

@Slf4j
@Singleton
public class ShoalRouteRegistry
{
    private static final String RESOURCE_NAME = "shoals.properties";

    @Getter
    private final Map<Integer, ShoalRoute> routesByWorldViewId = new HashMap<>();

    public void load() throws IOException
    {
        routesByWorldViewId.clear();

        Properties props = new Properties();
        try (InputStream in = getClass().getResourceAsStream("/" + RESOURCE_NAME))
        {
            if (in == null)
            {
                throw new IOException("Could not find resource: " + RESOURCE_NAME);
            }
            props.load(in);
        }

        // Temporary accumulators so order doesn't matter
        Map<Integer, List<WorldPoint>> paths = new HashMap<>();
        Map<Integer, List<WorldPoint>> stops = new HashMap<>();

        for (String key : props.stringPropertyNames())
        {
            String value = props.getProperty(key);

            if (key.startsWith("shoalpath."))
            {
                int id = Integer.parseInt(key.substring("shoalpath.".length()));
                paths.put(id, parsePoints(value));
            }
            else if (key.startsWith("shoalstops."))
            {
                int id = Integer.parseInt(key.substring("shoalstops.".length()));
                stops.put(id, parsePoints(value));
            }
        }

        // Merge into final routes map
        Set<Integer> allIds = new HashSet<>();
        allIds.addAll(paths.keySet());
        allIds.addAll(stops.keySet());

        for (int id : allIds)
        {
            List<WorldPoint> p = paths.getOrDefault(id, List.of());
            List<WorldPoint> s = stops.getOrDefault(id, List.of());
            routesByWorldViewId.put(id, new ShoalRoute(p, s));
        }

        log.info("Loaded {} shoal routes from {}", routesByWorldViewId.size(), RESOURCE_NAME);
    }

    public ShoalRoute get(int worldViewId)
    {
        return routesByWorldViewId.getOrDefault(worldViewId, ShoalRoute.EMPTY);
    }

    private List<WorldPoint> parsePoints(String value)
    {
        if (value == null || value.trim().isEmpty())
        {
            return List.of();
        }

        return Arrays.stream(value.split("\\|"))
                .map(String::trim)
                .filter(s -> !s.isEmpty())
                .map(this::parsePoint)
                .collect(Collectors.toList());
    }

    private WorldPoint parsePoint(String token)
    {
        String[] parts = token.split(",\\s*");
        if (parts.length < 3)
        {
            throw new IllegalArgumentException("Invalid point token: " + token);
        }

        int x = Integer.parseInt(parts[0].trim());
        int y = Integer.parseInt(parts[1].trim());
        int plane = Integer.parseInt(parts[2].trim());
        return new WorldPoint(x, y, plane);
    }
}

package com.deepseatrawling;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PluginLauncher
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(DeepSeaTrawling.class);
		RuneLite.main(args);
	}
}
