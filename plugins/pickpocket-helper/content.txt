package com.pickpockethelper.entity;

import com.pickpockethelper.PickpocketHelperConfig;
import lombok.Getter;
import net.runelite.api.Actor;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.time.Duration;
import java.time.Instant;

/**
 * The currently ongoing streak of pickpocketing a specific target.
 * Keeps track of the pickpocket target, potential splashers, and relevant events and stats.
 */
@Getter
@Singleton
public class Session {
    private final PickpocketHelperConfig config;
    private final Target target;
    private final Splasher splasher;
    private Instant lastPickpocketAttempt;
    private Instant lastPickpocketSuccess;
    private Instant lastPlayerIdleNotify;
    private Instant lastRogueEquipmentProc;
    private Instant lastStun;
    private int pickpocketSuccessCount = 0;
    private int pickpocketFailCount = 0;
    private Instant sessionStart;

    @Inject
    public Session(PickpocketHelperConfig pluginConfig) {
        config = pluginConfig;
        target = new Target(this);
        splasher = new Splasher();
    }

    public void updateLastPickpocketAttempt(){
        this.lastPickpocketAttempt = Instant.now();
    }

    public void updateLastPlayerIdleNotify() {
        this.lastPlayerIdleNotify = Instant.now();
    }

    public void updateLastPickpocketSuccess() {
        this.lastPickpocketSuccess = Instant.now();
    }

    public void updateLastRogueEquipmentProc() {
        this.lastRogueEquipmentProc = Instant.now();
    }

    public void updateLastStun(){
        this.lastStun = Instant.now();
    }

    public void increasePickpocketSuccessCount(){
        pickpocketSuccessCount++;
    }

    public void increasePickpocketFailCount(){
        pickpocketFailCount++;
    }

    public void setupListeners() {
        target.addNpcListener(this::onTargetChange);
    }

    private void onTargetChange() {
        if (!isActive()) {
            sessionStart = Instant.now();
        }
    }

    /**
     * Determine if the local player is currently pickpocketing or is stunned after a failed pickpocket.
     *
     * @param delay a duration to expand the pickpocketing timeframe.
     */
    public boolean isPickpocketing(Duration delay) {
        if (lastPickpocketAttempt == null) {
            return false;
        }

        if (lastStun != null) {
            Duration stunDuration = Duration.between(lastStun, Instant.now());
            if (stunDuration.getSeconds() < 6) {
                delay = delay.plus(Duration.ofSeconds(6));
            }
        }

        return lastPickpocketAttempt.plus(delay).isAfter(Instant.now());
    }

	/**
	 * Determine if the current session is still active.
	 * A session deactivates after 2 minutes of no pickpocketing.
	 */
	public boolean isActive() {
		return this.isPickpocketing(Duration.ofSeconds(120));
	}

    /**
     * Determine if the given actor is the player's target.
     *
     * @param actor the actor being checked.
     */
    public boolean isTarget(Actor actor) {
        return actor != null && actor == target.getNpc();
    }

    public void reset() {
        lastPickpocketAttempt = null;
        lastPickpocketSuccess = null;
        lastRogueEquipmentProc = null;
        lastPlayerIdleNotify = null;
        lastStun = null;
        pickpocketSuccessCount = 0;
        pickpocketFailCount = 0;
        sessionStart = null;
    }

    public void clear() {
        splasher.clear();
        target.clear();
        reset();
    }
}

package com.pickpockethelper.entity;

import com.pickpockethelper.utility.ArdyMode;
import com.pickpockethelper.utility.Helper;
import java.util.Objects;
import lombok.Getter;
import net.runelite.api.NPC;
import net.runelite.api.coords.WorldPoint;

import java.time.Instant;
import java.util.ArrayList;
import java.util.List;

public class Target {
    private static final int DEFAULT_DESPAWN_TIME = 300;
    private static final int ARDY_KNIGHT_GROUP_DESPAWN_TIME = 600;

    private final Session session;

    @Getter
    private NPC npc;

    private final List<Runnable> npcListeners = new ArrayList<>();
    @Getter
    private WorldPoint lastLocation;

    @Getter
    private Instant lastMove;

    @Getter
    private Instant lastDespawnNotify;

    public Target(Session session) {
        this.session = session;
    }

    public void setNpc(NPC npc) {
        if(this.npc != null && session.isTarget(npc)) {
            return;
        }

		boolean similarTarget = this.npc != null && (this.npc.getIndex() == npc.getIndex() || Objects.equals(npc.getName(), this.npc.getName()));

        this.npc = npc;
        this.lastLocation = npc.getWorldLocation();

		if(!similarTarget) {
			session.reset();
		}

        npcListeners.forEach(Runnable::run);
    }

    public void updateLocation(WorldPoint location) {
        this.lastMove = Instant.now();
        this.lastLocation = location;
    }

    public void updateLastDespawnNotify() {
        lastDespawnNotify = Instant.now();
    }

    public void addNpcListener(Runnable runnable) {
        npcListeners.add(runnable);
    }

    public boolean isRendered() {
        return Helper.isRendered(npc);
    }

    public int getSecondsBeforeDespawn() {
        if (lastMove == null) {
            return -1;
        }
        int despawnTime = isArdyKnight() && session.getConfig().ardyMode() == ArdyMode.GROUP ? ARDY_KNIGHT_GROUP_DESPAWN_TIME : DEFAULT_DESPAWN_TIME;
        int secondsSinceLastMove = Helper.secondsSince(lastMove);
        Integer secondsSinceLastAttackReceived = (session.getSplasher().getLastAttack() != null) ? Helper.secondsSince(session.getSplasher().getLastAttack()) : null;
        int secondsBeforeDespawn = (secondsSinceLastAttackReceived == null || secondsSinceLastMove < secondsSinceLastAttackReceived) ? despawnTime - secondsSinceLastMove : despawnTime - secondsSinceLastAttackReceived;

        if (secondsBeforeDespawn == despawnTime) {
            lastDespawnNotify = null;
        }

        return secondsBeforeDespawn;
    }

    public void reset() {
        npc = null;
        lastLocation = null;
        lastMove = null;
        lastDespawnNotify = null;
    }

    public void clear() {
        npcListeners.clear();
        reset();
    }

    private boolean isArdyKnight() {
        return npc != null && "Knight of Ardougne".equals(npc.getName());
    }
}

package com.pickpockethelper.entity;

import lombok.Getter;
import net.runelite.api.Player;

import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;

public class Splasher {
    @Getter
    private Player player;
    @Getter
    private Instant lastAttack;

    private final List<Runnable> isAttackingListeners = new ArrayList<>();
    private final List<Runnable> playerListeners = new ArrayList<>();

    @Getter
    private Instant lastIdleNotify;

    public void updatePlayer(Player player) {
        this.player = player;
        playerListeners.forEach(Runnable::run);
    }

    public void addPlayerListener(Runnable runnable) {
        playerListeners.add(runnable);
    }

    public void updateLastIdleNotify() {
        lastIdleNotify = Instant.now();
    }

    public void updateLastAttack() {
        lastAttack = Instant.now();
        lastIdleNotify = null;
    }

    public void updateIsAttacking() {
        isAttackingListeners.forEach(Runnable::run);
    }

    public boolean isAttacking() {
        Duration timeSinceLastAttack = Duration.between(lastAttack, Instant.now());
        return timeSinceLastAttack.getSeconds() < 8;
    }

    public void addIsAttackingListener(Runnable runnable) {
        isAttackingListeners.add(runnable);
    }

    public void reset(){
        lastAttack = null;
        player = null;
        lastIdleNotify = null;
    }

    public void clear() {
        isAttackingListeners.clear();
        playerListeners.clear();

        reset();
    }

    @Override
    public String toString(){
        return player.getName();
    }
}

package com.pickpockethelper;

import com.google.common.math.DoubleMath;
import com.google.common.primitives.Floats;
import com.pickpockethelper.utility.AlertID;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.Clip;
import javax.sound.sampled.FloatControl;
import java.io.BufferedInputStream;
import java.io.InputStream;
import java.util.*;

/**
 * Handles the playing of speech alerts.
 */
@Slf4j
@Singleton
public class AudioManager {
    private final HashMap<Integer, Clip> clips = new HashMap<>();

    @Inject
    private PickpocketHelperConfig config;

    /**
     * Plays the file connected to the provided alert id.
     * If the clip is already running it does nothing.
     * @param alertId alert to be played.
     */
    public boolean play(int alertId) {
        Clip clip = clips.get(alertId);
        if (clip == null) {
            log.debug("Clip doesn't exist: " + alertId);
            return false;
        }

        if (!clip.isRunning()) {
            var control = (FloatControl) clip.getControl(FloatControl.Type.MASTER_GAIN);
            var gain = (float) DoubleMath.log2(config.volume() / 50D) * 20;
            control.setValue(Floats.constrainToRange(gain, control.getMinimum(), control.getMaximum()));

            clip.setFramePosition(0);
            clip.start();
        }
        return true;
    }

    public void init() {
        final Map<Integer, String> alertAudioFiles = new HashMap<>();
        alertAudioFiles.put(AlertID.ROGUE_SET_INCOMPLETE, "rogue_set.wav");
        alertAudioFiles.put(AlertID.DODGY_BREAK, "dodgy_necklace_break.wav");
        alertAudioFiles.put(AlertID.HITPOINTS_LOW, "hitpoints_low.wav");
        alertAudioFiles.put(AlertID.SHADOW_VEIL_FADED, "shadow_veil_faded.wav");
        alertAudioFiles.put(AlertID.TARGET_DESPAWN, "target_despawn.wav");
        alertAudioFiles.put(AlertID.SPLASHER_IDLE, "splasher_idle.wav");
        alertAudioFiles.put(AlertID.PLAYER_IDLE, "player_idle.wav");
        alertAudioFiles.put(AlertID.NO_INVENTORY_SPACE, "no_space.wav");

        alertAudioFiles.forEach(this::loadAudioFile);
    }

    public void clear() {
        clips.forEach((id, clip) -> {
            clip.stop();
            clip.flush();
            clip.close();
        });

        clips.clear();
    }


    /**
     * Loads file from the resources audio folder.
     * @param alertId id connected to filename.
     * @param fileName filename to be retrieved.
     */
    private void loadAudioFile(int alertId, String fileName) {
        try (
                InputStream source = getClass().getResourceAsStream("/audio/" + fileName);
                BufferedInputStream bufferedInputStream = new BufferedInputStream(source);
                AudioInputStream audioInputStream = AudioSystem.getAudioInputStream(bufferedInputStream)
        ) {
            Clip clip = AudioSystem.getClip();
            clips.put(alertId, clip);
            clip.open(audioInputStream);
        } catch (Exception ex) {
            log.error(ex.getMessage());
        }
    }

}

package com.pickpockethelper;

import com.pickpockethelper.entity.Session;
import com.pickpockethelper.utility.AlertID;
import com.pickpockethelper.utility.AlertType;
import net.runelite.client.chat.ChatColorType;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.Map;

/**
 * Handles executing alerts through chat messages, notifications, or audio files.
 */
@Singleton
public class AlertManager {
    @Inject
    private FeedbackManager feedbackManager;
    @Inject
    private AudioManager audioManager;

	@Inject
	private Session session;

    @Inject
    private PickpocketHelperConfig config;

    private final static Map<Integer, String> messages = new HashMap<>();

    public AlertManager() {
        messages.put(AlertID.DODGY_BREAK, "Your dodgy necklace broke!");
        messages.put(AlertID.HITPOINTS_LOW, "Your hitpoints are low!");
        messages.put(AlertID.SHADOW_VEIL_FADED, "Shadow Veil has faded!");
        messages.put(AlertID.TARGET_DESPAWN, "Your target is about to de-spawn!");
        messages.put(AlertID.ROGUE_SET_INCOMPLETE, "You are not wearing the full rogue set!");
        messages.put(AlertID.SPLASHER_IDLE, "Your target is no longer being splashed!");
        messages.put(AlertID.PLAYER_IDLE, "You are no longer pickpocketing!");
        messages.put(AlertID.NO_INVENTORY_SPACE, "There is no space for your loot!");
		messages.put(AlertID.GLOVES_BREAK, "Your gloves of silence are about to break!");
    }

    /**
     * Send an alert to the player. Only sends alerts while the session is active.
     * @param alertId alert to be executed.
     * @param includeChatMessage whether to include a chat message.
     */
    public void sendAlert(int alertId, boolean includeChatMessage) {
		if (!session.isActive()) {
			return;
		}

        AlertType type = config.getAlertType();

        if(type == AlertType.CHAT_MESSAGE || includeChatMessage) {
            feedbackManager.sendChatMessage(messages.get(alertId), ChatColorType.HIGHLIGHT);
        }

		boolean audioSuccess = true;
		if(type == AlertType.SPEECH) {
			audioSuccess = audioManager.play(alertId);
		}

		if(type == AlertType.NOTIFICATION || !audioSuccess) {
			feedbackManager.sendNotification(messages.get(alertId), false);
		}
    }
}

package com.pickpockethelper.ui;

import com.pickpockethelper.PickpocketHelperConfig;
import com.pickpockethelper.PickpocketHelperPlugin;
import com.pickpockethelper.entity.Session;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;

import javax.inject.Inject;
import java.awt.*;
import java.time.Duration;
import java.time.Instant;

/**
 * Used to display the player's session stats.
 * Includes successful attempts total and per hour, and the number of failed and fail rate.
 */
public class StatisticOverlay extends OverlayPanel {

    private final PickpocketHelperConfig config;
    private final Session session;

    @Inject
    private StatisticOverlay(PickpocketHelperPlugin plugin, PickpocketHelperConfig config, Session session){
        super(plugin);
        setPosition(OverlayPosition.TOP_LEFT);
        this.config = config;
        this.session = session;
    }

    @Override
    public Dimension render(Graphics2D graphics) {

        if(session.getLastPickpocketAttempt() == null || session.getSessionStart() == null || !config.enableStatsOverlay()) {
            return null;
        }

		if(!session.isPickpocketing(Duration.ofSeconds(30))) {
			return null;
		}

        Integer failCount = session.getPickpocketFailCount();
        Integer successCount = session.getPickpocketSuccessCount();
        int totalCount = failCount + successCount;
        long secondsSinceSessionStart = Duration.between(session.getSessionStart(), Instant.now()).getSeconds();
        int perHourCount = (successCount < 1) ? 0 : Math.round(((float) successCount / (float) secondsSinceSessionStart) * 3600);

        int failRatio = (totalCount == 0) ? 0 : (failCount == 0) ? 0 : Math.round(((float) failCount / (float) totalCount) * 100);
		int successRatio = 100 - failRatio;

        panelComponent.getChildren().add(LineComponent.builder()
                .left("Picked:")
                .right(String.valueOf(successCount))
                .build());
		panelComponent.getChildren().add(LineComponent.builder()
			.left("Rate:")
			.right(successRatio +"%")
			.build());
        if (totalCount > 1) {
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Per hour:")
                    .right(String.valueOf(perHourCount))
                    .build());
        }

		panelComponent.getChildren().add(LineComponent.builder().build());

		panelComponent.getChildren().add(LineComponent.builder()
			.left("Failed:")
			.right(String.valueOf(failCount))
			.build());
		panelComponent.getChildren().add(LineComponent.builder()
			.left("Rate:")
			.right(failRatio +"%")
			.build());

        return super.render(graphics);
    }
}

package com.pickpockethelper.ui;

import com.pickpockethelper.*;
import com.pickpockethelper.entity.Session;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Point;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.inject.Inject;
import java.awt.*;

/**
 * Overlay used to display a de-spawn timer above the player's target.
 */
public class TimerOverlay extends OverlayPanel {

    private final Client client;
    private final PickpocketHelperConfig config;
    private final Session session;

    @Inject
    private TimerOverlay(Client client, PickpocketHelperPlugin plugin, PickpocketHelperConfig config, Session session){
        super(plugin);
        this.client = client;
        this.config = config;
        this.session = session;

        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
    }

    @Override
    public Dimension render(Graphics2D graphics) {

        NPC target = session.getTarget().getNpc();
        if(target == null || !config.enableDespawnTimer() || client.isInInstancedRegion() || !session.getTarget().isRendered()) {
            return null;
        }

        int displayedAmount = session.getTarget().getSecondsBeforeDespawn();

        if(displayedAmount < 0) {
            return null;
        }

        Point timerLocation = target.getCanvasTextLocation(graphics, String.valueOf(displayedAmount), target.getLogicalHeight() + 25);
        Color textColor = (displayedAmount > 30) ? Color.white : Color.RED;

        OverlayUtil.renderTextLocation(graphics, timerLocation, String.valueOf(displayedAmount), textColor);

        return null;
    }
}

package com.pickpockethelper.ui;

import com.pickpockethelper.PickpocketHelperConfig;
import com.pickpockethelper.PickpocketHelperPlugin;
import com.pickpockethelper.entity.Session;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.TitleComponent;

import javax.inject.Inject;
import java.awt.*;
import java.time.Duration;

/**
 * Overlay used to display the pickpocketing status of the player.
 * Honestly, pretty useless since pickpocketing isn't afk.
 */
public class StatusOverlay extends OverlayPanel {

    private final PickpocketHelperConfig config;
    private final Session session;

    @Inject
    private StatusOverlay(PickpocketHelperPlugin plugin, PickpocketHelperConfig config, Session session){
        super(plugin);
        setPosition(OverlayPosition.TOP_LEFT);
        this.config = config;
        this.session = session;
    }

    @Override
    public Dimension render(Graphics2D graphics) {

        if(session.getLastPickpocketAttempt() == null || !config.enableStatusOverlay()) {
            return null;
        }

		if(!session.isPickpocketing(Duration.ofSeconds(30))) {
			return null;
		}

        if(session.isPickpocketing(Duration.ofSeconds(6))) {
            panelComponent.getChildren().add(TitleComponent.builder()
                    .text("Pickpocketing")
                    .color(Color.GREEN)
                    .build());
        } else {
            panelComponent.getChildren().add(TitleComponent.builder()
                    .text("NOT pickpocketing")
                    .color(Color.RED)
                    .build());
        }

        return super.render(graphics);
    }
}

package com.pickpockethelper.ui;

import com.pickpockethelper.PickpocketHelperConfig;
import com.pickpockethelper.PickpocketHelperPlugin;
import com.pickpockethelper.entity.Session;
import java.time.Duration;
import net.runelite.api.Player;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

import javax.inject.Inject;
import java.awt.*;

/**
 * Used to display information about the last active splasher.
 * Includes their name and whether they are idle or splashing.
 */
public class SplasherOverlay extends OverlayPanel {

    private final PickpocketHelperConfig config;
    private final Session session;

    @Inject
    private SplasherOverlay(PickpocketHelperPlugin plugin, PickpocketHelperConfig config, Session session){
        super(plugin);
        setPosition(OverlayPosition.TOP_LEFT);
        this.config = config;
        this.session = session;
    }

    @Override
    public Dimension render(Graphics2D graphics) {

        if(session.getLastPickpocketAttempt() == null || !config.enableSplasherOverlay()) {
            return null;
        }

		if(!session.isPickpocketing(Duration.ofSeconds(30))) {
			return null;
		}

        Player player = session.getSplasher().getPlayer();
        if(player == null) {
            panelComponent.getChildren().add(TitleComponent.builder()
                    .color(Color.RED)
                    .text("NO Splasher")
                    .build());

            return super.render(graphics);
        }

        panelComponent.getChildren().add(LineComponent.builder()
                .left("Name:")
                .right(player.getName())
                .build());

        boolean isAttacking = session.getSplasher().isAttacking();
        panelComponent.getChildren().add(LineComponent.builder()
                .left("Status:")
                .right(isAttacking ? "Splashing" : "Idle")
                .rightColor(isAttacking ? Color.GREEN : Color.RED)
                .build());

        return super.render(graphics);
    }
}

package com.pickpockethelper;

import com.google.common.collect.ImmutableSet;
import com.pickpockethelper.entity.Session;
import com.pickpockethelper.ui.SplasherOverlay;
import com.pickpockethelper.ui.StatisticOverlay;
import com.pickpockethelper.ui.StatusOverlay;
import com.pickpockethelper.ui.TimerOverlay;
import com.pickpockethelper.utility.AlertID;
import com.pickpockethelper.utility.AnimationID;
import com.pickpockethelper.utility.MessagePattern;
import com.pickpockethelper.utility.SoundEffectID;
import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.client.callback.Hooks;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import java.time.Duration;
import java.time.Instant;
import java.util.*;
import java.util.regex.Pattern;

@Slf4j
@PluginDescriptor(
        name = "Pickpocket Helper",
        description = "Adds quality of life improvements for pickpocketing.",
        tags = {"thieving", "pickpocketing", "ardy", "knights", "master", "farmer", "vyres"}
)
public class PickpocketHelperPlugin extends Plugin {
    private static final Map<Pattern, Runnable> messageTriggers = new LinkedHashMap<>();
    private static final Set<Pattern> blockedPatterns = ImmutableSet.of(
            Pattern.compile(MessagePattern.NO_SPACE_PATTERN),
            Pattern.compile(MessagePattern.EMPTY_POUCHES_PATTERN),
            Pattern.compile(MessagePattern.CANT_REACH_PATTERN)
    );
    private static final Set<Integer> splashAnimations = Set.of(
            AnimationID.ATTACK_MAGE_IBAN,
            AnimationID.ATTACK_MAGE_STANDARD,
            AnimationID.ATTACK_MAGE_WAVE,
            AnimationID.ATTACK_MAGE_SURGE
    );
    private static final Set<Integer> rogueEquipmentIds = Set.of(
            ItemID.ROGUE_BOOTS,
            ItemID.ROGUE_GLOVES,
            ItemID.ROGUE_MASK,
            ItemID.ROGUE_TOP,
            ItemID.ROGUE_TROUSERS
    );

    @Inject
    private PickpocketHelperConfig config;
    @Inject
    private Client client;
    @Inject
    private Hooks hooks;
    @Inject
    private HighlightManager highlightManager;
    @Inject
    private FeedbackManager feedbackManager;
    @Inject
    private AlertManager alertManager;
    @Inject
    private AudioManager audioManager;
    @Inject
    private OverlayManager overlayManager;
    @Inject
    private StatisticOverlay statisticOverlay;
    @Inject
    private StatusOverlay statusOverlay;
    @Inject
    private SplasherOverlay splasherOverlay;
    @Inject
    private TimerOverlay timerOverlay;
    @Inject
    private Session session;

    @Provides
    PickpocketHelperConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(PickpocketHelperConfig.class);
    }

    /**
     * Setup listeners for changing session values.
     */
    private void setupListeners() {
        session.getTarget().addNpcListener(this::onLastPickpocketTargetChanged);
        session.getSplasher().addIsAttackingListener(this::onSplasherIsAttackingChanged);
        session.getSplasher().addPlayerListener(this::onSplasherChanged);
        session.setupListeners();
    }

    /**
     * Setup methods that will trigger based on incoming chat messages.
     */
    private void setupMessageTriggers() {
        registerMessageTrigger(MessagePattern.DODGY_NECKLACE_BREAK_PATTERN, this::onDodgyNecklaceBreak);
        registerMessageTrigger(MessagePattern.STUN_PATTERN, this::onStun);
        registerMessageTrigger(MessagePattern.SHADOW_VEIL_FADE_PATTERN, this::onShadowVeilFade);
        registerMessageTrigger(MessagePattern.PICKPOCKET_SUCCEED_PATTERN, this::onPickpocketSuccess);
        registerMessageTrigger(MessagePattern.PICKPOCKET_FAIL_PATTERN, this::onPickpocketFail);
        registerMessageTrigger(MessagePattern.PICKPOCKET_ROGUE_EQUIPMENT_PATTERN, this::onRogueEquipmentProc);
        registerMessageTrigger(MessagePattern.POUCHES_FULL_PATTERN, this::onPouchesFull);
        registerMessageTrigger(MessagePattern.INVENTORY_FULL_PATTERN, this::onInventoryFull);
        registerMessageTrigger(MessagePattern.NO_SPACE_PATTERN, this::onInventoryFull);
        registerMessageTrigger(MessagePattern.GLOVES_OF_SILENCE_BREAKING_PATTERN, this::onGlovesBreak);
    }

    private void registerMessageTrigger(String regex, Runnable action) {
        messageTriggers.put(Pattern.compile(regex), action);
    }

    /**
     * Determines if an entity should be rendered before it is.
     * If enabled by the player, while pickpocketing this hides everyone except:
     *  - the player and their pet
     *  - their pickpocket target
     *  - the splasher
     *  - friends and clan mates
     */
    private boolean shouldRenderEntity(Renderable renderable, boolean drawingUI) {
        if(!config.enableHideOthers() || !session.isPickpocketing(Duration.ofSeconds(10))) {
            return true;
        }

        if(!(renderable instanceof Actor)) {
            return true;
        }

        Actor actor = (Actor) renderable;

        if(session.isTarget(actor) || actor.equals(client.getLocalPlayer()) || actor.equals(session.getSplasher().getPlayer())) {
            return true;
        }

        if(actor instanceof NPC) {
            NPC npc = (NPC) actor;
            if(npc.getComposition().isFollower()) {
                return client.getLocalPlayer().equals(npc.getInteracting());
            }

            return false;
        }

        Player player = (Player) actor;
        return player.isFriend() || player.isClanMember();
    }

    @Override
    protected void startUp() {
        setupListeners();
        setupMessageTriggers();
        overlayManager.add(statusOverlay);
        overlayManager.add(splasherOverlay);
        overlayManager.add(statisticOverlay);
        overlayManager.add(timerOverlay);
        audioManager.init();
        highlightManager.register();
        hooks.registerRenderableDrawListener(this::shouldRenderEntity);
    }

    @Override
    protected void shutDown() {
        hooks.unregisterRenderableDrawListener(this::shouldRenderEntity);
        highlightManager.clearTargets();
        highlightManager.unregister();
        overlayManager.remove(statusOverlay);
        overlayManager.remove(splasherOverlay);
        overlayManager.remove(statisticOverlay);
        overlayManager.remove(timerOverlay);
        audioManager.clear();
        messageTriggers.clear();
        session.clear();
    }

    @Override
    public void resetConfiguration() {
        overlayManager.resetOverlay(statisticOverlay);
        overlayManager.resetOverlay(statusOverlay);
        overlayManager.resetOverlay(splasherOverlay);
        overlayManager.resetOverlay(timerOverlay);
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged change) {
        switch (change.getGameState()) {
            case LOGIN_SCREEN:
                session.reset();
                // intentional fall-through
            case CONNECTION_LOST:
            case HOPPING:
                session.getSplasher().reset();
                session.getTarget().reset();
                highlightManager.clearTargets();
                break;
        }
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged configChanged) {
        if (!"pickpockethelper".equals(configChanged.getGroup()) || configChanged.getNewValue() == null) {
            return;
        }
        if (HighlightManager.CONFIG_DEPENDENCIES.contains(configChanged.getKey())) {
            highlightManager.refresh();
        }
    }

    @Subscribe
    private void onChatMessage(ChatMessage chatMessage) {
        checkAndExecuteChatMessageTriggers(chatMessage);
    }

	@Subscribe
	public void onScriptCallbackEvent(ScriptCallbackEvent event) {
		if (!config.enableBlockSpam() || !"chatFilterCheck".equals(event.getEventName())) {
			return;
		}

		String message = client.getStringStack()[client.getStringStackSize() - 1];
		String content = Text.removeTags(message);

        for (Pattern pattern : blockedPatterns) {
            if (pattern.matcher(content).find()) {
                client.getIntStack()[client.getIntStackSize() - 3] = 0;
                break;
            }
        }
    }

	@Subscribe
    private void onHitsplatApplied(HitsplatApplied hitsplatApplied) {
        checkAndNotifyLowHitpoints(hitsplatApplied.getHitsplat());
    }

    @Subscribe
    public void onGameTick(GameTick gameTick) {
        checkAndNotifyPlayerIdle();
        checkAndUpdateTargetLocation();
        checkAndNotifyTargetDespawn();
    }

    @Subscribe
    public void onClientTick(ClientTick clientTick) {
        swapLeftClickPickpocket();
    }

    @Subscribe
    public void onAnimationChanged(AnimationChanged change) {
        checkAndUpdateSplasher(change.getActor());
    }

    @Subscribe
    public void onNpcSpawned(NpcSpawned npcSpawned) {
        checkAndUpdateTargetFromCache(npcSpawned.getNpc());
    }

    @Subscribe
    public void onSoundEffectPlayed(SoundEffectPlayed soundEffect) {
        checkAndMuteSoundEffect(soundEffect);
    }

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked menuOptionClicked) {
		checkAndUpdatePickpocketAttempt(menuOptionClicked);
	}

    private void checkAndUpdatePickpocketAttempt(MenuOptionClicked menuOptionClicked) {
		if (!menuOptionClicked.getMenuOption().equalsIgnoreCase("Pickpocket")) {
			return;
		}

		session.getTarget().setNpc(menuOptionClicked.getMenuEntry().getNpc());
		session.updateLastPickpocketAttempt();
		session.getSplasher().updateIsAttacking();
    }

    private void onPickpocketSuccess() {
        session.updateLastPickpocketSuccess();
        session.increasePickpocketSuccessCount();
        checkAndNotifyRogueEquipment();
    }

    private void onPickpocketFail() {
        session.increasePickpocketFailCount();
    }

    /**
     * The player can get stunned after a failed pickpocket.
     * The stun is guaranteed, unless they are wearing a dodgy necklace.
     */
    private void onStun() {
        session.updateLastStun();
    }

    /**
     * The player attempts to pickpocket with a full inventory.
     */
    private void onInventoryFull() {
        notifyNoSpace();
    }

    /**
     * The player attempts to pickpocket with a full stack of pouches.
     */
    private void onPouchesFull() {
        notifyNoSpace();
    }

    private void onLastPickpocketTargetChanged() {
        updatePickpocketTargetHighlight();
    }

    private void onSplasherChanged() {
        checkAndNotifySplasherFound();
    }

    private void onSplasherIsAttackingChanged() {
        checkAndNotifySplasherIdle();
    }

    private void onShadowVeilFade() {
        notifyShadowVeilFade();
    }

	private void onGlovesBreak() {
        notifyGlovesBreak();
	}

    private void onDodgyNecklaceBreak() {
        notifyNecklaceBreak();
    }

    /**
     * When pickpocketing with a piece of rogue equipment, there is a 20% chance it procs and gives double loot.
     * Wearing the full set will guarantee this effect to proc.
     */
    private void onRogueEquipmentProc() {
        session.updateLastRogueEquipmentProc();
    }

    /**
     * Check if there is a splasher and, if so, notify the player of the splasher.
     * Does nothing if no splasher is actually present.
     */
    private void checkAndNotifySplasherFound() {
        if (session.getSplasher().getPlayer() == null) {
            return;
        }

        String message = new ChatMessageBuilder()
                .append(ChatColorType.NORMAL)
                .append("Splasher found: ")
                .append(ChatColorType.HIGHLIGHT)
                .append(session.getSplasher().getPlayer().getName())
                .build();

        feedbackManager.sendChatMessage(message);
    }

    /**
     * Update the current pickpocketed target being highlighted.
     */
    private void updatePickpocketTargetHighlight() {
        highlightManager.clearTargets();
        highlightManager.addTarget(session.getTarget().getNpc());
    }

    /**
     * Checks if the player is idle after having pickpocketed and, if so, notifies the player.
     * Takes delay configuration into account set by player. If the delay is 0, the notification is disabled entirely.
     * If no pickpocket attempt has been made since last notification, nothing will de done.
     */
    private void checkAndNotifyPlayerIdle() {
        Duration delay = Duration.ofSeconds(config.getInactiveNotificationDelay());
        if (delay.isZero() || delay.isNegative() || session.getLastPlayerIdleNotify() != null) {
            return;
        }

        if (session.getLastPickpocketAttempt() != null && !session.isPickpocketing(delay)) {
            session.updateLastPlayerIdleNotify();
            alertManager.sendAlert(AlertID.PLAYER_IDLE, false);
        }
    }

    /**
     * Check if the splasher is idle and, if so, notfies the player.
     */
    private void checkAndNotifySplasherIdle() {
        if (!config.enableIdleSplasherNotification() || session.getSplasher().getLastIdleNotify() != null || session.getSplasher().getPlayer() == null || session.getSplasher().isAttacking()) {
            return;
        }

        session.getSplasher().updateLastIdleNotify();
        alertManager.sendAlert(AlertID.SPLASHER_IDLE, true);
    }

    /**
     * Check if the player is pickpocketing and, if so, if they are wearing the complete rogue outfit.
     * To prevent checking too often, equipment is only checked if no rogue equipment proc has occurred for 3 seconds.
     */
    private void checkAndNotifyRogueEquipment() {
        if (!config.enableRogueEquipmentNotification()) {
            return;
        }

        if (session.getLastPickpocketSuccess() != null && session.getLastRogueEquipmentProc() != null) {
            Duration timeSinceLastProc = Duration.between(session.getLastRogueEquipmentProc(), Instant.now());
            if (timeSinceLastProc.getSeconds() < 3) {
                return;
            }
        }

        int[] equippedGearIds = client.getLocalPlayer().getPlayerComposition().getEquipmentIds();
        int rogueCount = 0;
        for (int equipmentId : equippedGearIds) {
            // Only values above 2048 are items.
            if (equipmentId < PlayerComposition.ITEM_OFFSET) {
                continue;
            }

            int itemId = equipmentId - PlayerComposition.ITEM_OFFSET;
            if (rogueEquipmentIds.contains(itemId)) {
                rogueCount++;
            }
        }

        if (rogueCount < rogueEquipmentIds.size()) {
            alertManager.sendAlert(AlertID.ROGUE_SET_INCOMPLETE, true);
        }
    }

    /**
     * Notify the player that they try to pickpocket without having space left for the pouch.
     */
    private void notifyNoSpace() {
        if (!config.enableNoSpaceNotification()) {
            return;
        }

        alertManager.sendAlert(AlertID.NO_INVENTORY_SPACE, false);
    }

	/**
	 * Notify the player that their gloves of silence are about to break.
	 */
	private void notifyGlovesBreak() {
		if(!config.enableGlovesNotification()) {
			return;
		}

		alertManager.sendAlert(AlertID.GLOVES_BREAK, false);
	}
    /**
     * Notify the player that their dodgy necklace broke.
     */
    private void notifyNecklaceBreak() {
        if (!config.enableNecklaceNotification()) {
            return;
        }

        alertManager.sendAlert(AlertID.DODGY_BREAK, false);
    }

    /**
     * Notify the player that their Shadow Veil spell has faded.
     */
    private void notifyShadowVeilFade() {
        if (!config.enableShadowVeilNotification()) {
            return;
        }

        alertManager.sendAlert(AlertID.SHADOW_VEIL_FADED, false);
    }

    /**
     * Check if the player's hitpoints have subceeded their set threshold and,  if so, notify them.
     * If the threshold is set to 0, the notification is disabled.
     *
     * @param hitsplat the hitsplat applied that triggers the check.
     */
    private void checkAndNotifyLowHitpoints(Hitsplat hitsplat) {
        if (client.getGameState() != GameState.LOGGED_IN || config.getHitpointsThreshold() < 1 || !hitsplat.isMine()) {
            return;
        }

        int hitpoints = client.getBoostedSkillLevel(Skill.HITPOINTS) - hitsplat.getAmount();
        if (hitpoints <= config.getHitpointsThreshold()) {
            alertManager.sendAlert(AlertID.HITPOINTS_LOW, true);
        }
    }

    /**
     * Check if the player's target is about to despawn and, if so, notify them.
     * If the threshold is set to 0, the notification is disabled.
     */
    private void checkAndNotifyTargetDespawn() {
        int targetDespawnThreshold = config.getTargetDespawnThreshold();
        if (client.getGameState() != GameState.LOGGED_IN || session.getTarget().getLastDespawnNotify() != null || targetDespawnThreshold == 0 || session.getTarget().getNpc() == null || !session.getTarget().isRendered()) {
            return;
        }

        int secondsBeforeDespawn = session.getTarget().getSecondsBeforeDespawn();
        if (secondsBeforeDespawn <= targetDespawnThreshold && secondsBeforeDespawn > 0) {
            session.getTarget().updateLastDespawnNotify();
            alertManager.sendAlert(AlertID.TARGET_DESPAWN, true);
        }
    }

    /**
     * Check if an incoming chat message should trigger an action and, if so, trigger the action.
     * The triggers only work for game- and spam massages.
     *
     * @param message the incoming chat message.
     */
    private void checkAndExecuteChatMessageTriggers(ChatMessage message) {
        if (message.getType() != ChatMessageType.GAMEMESSAGE && message.getType() != ChatMessageType.SPAM) {
            return;
        }

        String content = Text.removeTags(message.getMessage());
        for (var entry : messageTriggers.entrySet()) {
            if (entry.getKey().matcher(content).find()) {
                entry.getValue().run();
                break;
            }
        }
    }

    /**
     * Check if the provided player is splashing the target the local player is pickpocketing.
     * If so, either store this new splasher or process the new attack of an existing splasher.
     *
     * @param target the target being verified as splasher.
     */
    private void checkAndUpdateSplasher(Actor target) {
        if (client.getGameState() != GameState.LOGGED_IN || !(target instanceof Player)) {
            return;
        }

        Player player = (Player) target;

        if (player.getInteracting() == null || !session.isTarget(player.getInteracting()) || !splashAnimations.contains(player.getAnimation())) {
            return;
        }

        if (player == session.getSplasher().getPlayer()) {
            session.getSplasher().updateLastAttack();
        } else {
            session.getSplasher().updatePlayer(player);
        }
    }

    /**
     * Check if the provided sound effect is muted by the player and, if so, interrupt it from being played.
	 * Only interrupts sounds when the session is active.
     *
     * @param soundEffect the to-be-played sound effect to check and mute.
     */
    private void checkAndMuteSoundEffect(SoundEffectPlayed soundEffect) {
		if (!session.isActive()) {
			return;
		}

        switch (soundEffect.getSoundId()) {
            // Block fail sound
            case com.pickpockethelper.utility.SoundEffectID.PICKPOCKET_FAIL:
            // Block damage sounds
            case com.pickpockethelper.utility.SoundEffectID.HUMAN_TAKE_DAMAGE_ONE:
            case com.pickpockethelper.utility.SoundEffectID.HUMAN_TAKE_DAMAGE_TWO:
            case com.pickpockethelper.utility.SoundEffectID.HUMAN_TAKE_DAMAGE_THREE:
            case com.pickpockethelper.utility.SoundEffectID.HUMAN_TAKE_DAMAGE_FOUR:
            case com.pickpockethelper.utility.SoundEffectID.HUMAN_TAKE_DAMAGE_SIX:
            case com.pickpockethelper.utility.SoundEffectID.HUMAN_TAKE_DAMAGE_SEVEN:
			case com.pickpockethelper.utility.SoundEffectID.FEMALE_TAKE_DAMAGE_ONE:
			case com.pickpockethelper.utility.SoundEffectID.FEMALE_TAKE_DAMAGE_TWO:
                if (config.muteFailSounds()) {
                    soundEffect.consume();
                }
                break;
            case com.pickpockethelper.utility.SoundEffectID.PICKPOCKET_SUCCEED:
                if (config.muteSuccessSounds()) {
                    soundEffect.consume();
                }
                break;
            case com.pickpockethelper.utility.SoundEffectID.POUCHES_EMPTY:
				if (config.muteEmptyPouchSound()) {
					soundEffect.consume();
				}
				break;
            case com.pickpockethelper.utility.SoundEffectID.NO_SPACE:
                if (config.muteNoSpaceSound()) {
                    soundEffect.consume();
                }
                break;
            case com.pickpockethelper.utility.SoundEffectID.SHADOW_VEIL_ACTIVE:
				if(config.muteVeilActivateSound()) {
					soundEffect.consume();
				}
				break;
            case SoundEffectID.SHADOW_VEIL_FADE:
                if (config.muteVeilFadeSound()) {
                    soundEffect.consume();
                }
                break;
        }
    }

    /**
     * Check if a spawned NPC is the target being pickpocketed using the cache and, if so, update the target session info.
     * This needs to happen after the target re-renders - like walking away and bank into range, or the target dying and respawning.
     *
     * @param npc the spawned npc being checked.
     */
    private void checkAndUpdateTargetFromCache(NPC npc) {
        if (session.getTarget().getNpc() == null || npc.getName() == null) {
            return;
        }

        if (npc.getIndex() != session.getTarget().getNpc().getIndex()) {
            return;
        }

        session.getTarget().setNpc(npc);
    }

    /**
     * Check if the target being pickpocketed has moved since last check and, if so, store the new location.
     */
    private void checkAndUpdateTargetLocation() {
        if (session.getTarget().getNpc() == null) {
            return;
        }

        if (session.getTarget().getNpc().getWorldLocation().equals(session.getTarget().getLastLocation())) {
            return;
        }

        session.getTarget().updateLocation(session.getTarget().getNpc().getWorldLocation());
    }

    private void swapLeftClickPickpocket() {
        if (!config.enableLeftClickPickpocket() || client.getGameState().getState() != GameState.LOGGED_IN.getState() || client.isMenuOpen()) {
            return;
        }
        MenuEntry[] entries = client.getMenuEntries();
        HashMap<MenuEntry, Integer> swaps = new HashMap<>();
        HashMap<Integer, Map.Entry<MenuEntry, Integer>> defaultLeftClicks = new HashMap<>();

        for(int index = entries.length - 1; index >= 0; index--){
            MenuEntry entry = entries[index];

            if(entry.getNpc() == null) {
                continue;
            }

            if(entry.getOption().equalsIgnoreCase("pickpocket")) {
                Map.Entry<MenuEntry, Integer> defaultLeftClickOption = defaultLeftClicks.get(entry.getNpc().getIndex());

                if (defaultLeftClickOption != null) {
                    swaps.put(entry, defaultLeftClickOption.getValue());
                    swaps.put(defaultLeftClickOption.getKey(), index);
                }
            } else if(
                    (
                            entry.getType() == MenuAction.NPC_FIRST_OPTION
                                    || entry.getType() == MenuAction.NPC_SECOND_OPTION
                                    || entry.getType() == MenuAction.NPC_THIRD_OPTION
                                    || entry.getType() == MenuAction.NPC_FOURTH_OPTION
                    )
                            && !defaultLeftClicks.containsKey(entry.getIdentifier())
            ) {
                defaultLeftClicks.put(entry.getNpc().getIndex(), new AbstractMap.SimpleEntry<>(entry, index));
            }
        }

        if (swaps.isEmpty()) {
            return;
        }

        swaps.forEach((entry, index) -> {
            entries[index] = entry;
        });

        try {
            client.setMenuEntries(entries);
        } catch (AssertionError er) {
            log.debug(er.getMessage());
        };
    }
}

package com.pickpockethelper.utility;

/**
 * Message patterns for chat message triggers.
 */
public final class MessagePattern {
    public static final String DODGY_NECKLACE_BREAK_PATTERN = "Your dodgy necklace protects you\\..*It then crumbles to dust\\.";
    public static final String DODGY_NECKLACE_PROTECT_PATTERN = "Your dodgy necklace protects you\\. It has 7 charges left.";
    public static final String PICKPOCKET_ATTEMPT_PATTERN = "You attempt to pick .*\\ pocket\\.";
    public static final String PICKPOCKET_SUCCEED_PATTERN = "You pick .*\\ pocket\\.";
    public static final String PICKPOCKET_FAIL_PATTERN = "You fail to pick .*\\ pocket\\.";
    public static final String PICKPOCKET_ROGUE_EQUIPMENT_PATTERN = "Your rogue clothing allows you to steal twice as much loot!";
    public static final String GLOVES_OF_SILENCE_BREAKING_PATTERN = "Your gloves of silence are going to fall apart!";

	public static final String STUN_PATTERN = "You've been stunned!";
    public static final String POUCHES_FULL_PATTERN = "You need to empty your coin pouches before you can continue pickpocketing\\.";
    public static final String INVENTORY_FULL_PATTERN = "You don't have enough inventory space to do that\\.";
    public static final String SHADOW_VEIL_ACTIVATE_PATTERN = "Your thieving abilities have been enhanced\\.";
    public static final String SHADOW_VEIL_FADE_PATTERN = "Your Shadow Veil has faded away\\.";
	public static final String EMPTY_POUCHES_PATTERN = "You need to empty your coin pouches before you can continue pickpocketing\\.";
	public static final String NO_SPACE_PATTERN = "You have no space in your inventory for your loot\\.";
	public static final String CANT_REACH_PATTERN = "I can't reach that!";
}

package com.pickpockethelper.utility;

/**
 * Runelite sound effect id references.
 */
public final class SoundEffectID {
    public final static int PICKPOCKET_FAIL = 2727;
    public final static int PICKPOCKET_SUCCEED = 2581;
	public final static int FEMALE_TAKE_DAMAGE_ONE = 509;
	public final static int FEMALE_TAKE_DAMAGE_TWO = 510;
    public final static int HUMAN_TAKE_DAMAGE_ONE = 518;
    public final static int HUMAN_TAKE_DAMAGE_TWO = 519;
    public final static int HUMAN_TAKE_DAMAGE_THREE = 520;
    public final static int HUMAN_TAKE_DAMAGE_FOUR = 521;
	public final static int HUMAN_TAKE_DAMAGE_SIX = 522;
	public final static int HUMAN_TAKE_DAMAGE_SEVEN = 523;
    public final static int NO_SPACE = 2277;
    public final static int POUCHES_EMPTY = 2115;
    public final static int SHADOW_VEIL_ACTIVE = 5032;
    public final static int SHADOW_VEIL_FADE = 5062;
}
package com.pickpockethelper.utility;

public enum AlertType {
    CHAT_MESSAGE,
    NOTIFICATION,
    SPEECH
}

package com.pickpockethelper.utility;

import net.runelite.api.Actor;
import net.runelite.api.NPC;
import net.runelite.api.NPCComposition;

import java.time.Duration;
import java.time.Instant;
import java.util.Arrays;
import java.util.List;

/**
 * Collection of helper functions.
 */
public class Helper {
    /**
     * Determine if an NPC can be pickpocketed.
     *
     * @param target the NPC being checked.
     */
    public static boolean canPickpocket(NPC target) {
        final NPCComposition npcComposition = target.getComposition();
        final List<String> npcMenuActions = Arrays.asList(npcComposition.getActions());

        return npcMenuActions.contains("Pickpocket");
    }

    /**
     * Determine the amount of seconds passed since a past instant.
     *
     * @param instant the instant to compare against now.
     * @return amount of seconds.
     */
    public static int secondsSince(Instant instant) {
        return (int) Duration.between(instant, Instant.now()).getSeconds();
    }

    /**
     * Determine if the given actor is currently rendered in the client.
     *
     * @param actor the actor being checked.
     * @return indication if actor is rendered.
     */
    public static boolean isRendered(Actor actor) {
        if(actor == null) {
            return false;
        }

        return actor.getName() != null;
    }
}

package com.pickpockethelper.utility;

public class AlertID {
    public final static int DODGY_BREAK = 0;
    public final static int HITPOINTS_LOW = 1;
    public final static int NO_INVENTORY_SPACE = 2;
    public final static int PLAYER_IDLE = 3;
    public final static int ROGUE_SET_INCOMPLETE = 4;
    public final static int SHADOW_VEIL_FADED = 5;
    public final static int SPLASHER_IDLE = 6;
    public final static int TARGET_DESPAWN = 7;
	public final static int GLOVES_BREAK = 8;
}

package com.pickpockethelper.utility;

/**
 * Runelite animation id references.
 */
public final class AnimationID {
    public final static int ATTACK_MAGE_STANDARD = 1162;
    public final static int ATTACK_MAGE_IBAN = 708;
    public final static int ATTACK_MAGE_WAVE = 1167;
    public final static int ATTACK_MAGE_SURGE = 7855;
}

package com.pickpockethelper.utility;

public enum ArdyMode {
    SOLO,
    GROUP
}

package com.pickpockethelper;

import com.pickpockethelper.utility.AlertType;
import java.awt.Color;

import com.pickpockethelper.utility.ArdyMode;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;
import net.runelite.client.config.Units;

@ConfigGroup("pickpockethelper")
public interface PickpocketHelperConfig extends Config
{
	@ConfigSection(
		name = "Sounds",
		description = "",
		position = 0
	)
	String soundSection = "soundSection";

	@ConfigItem(
		keyName = "muteFailSounds",
		name = "Mute Fail Sounds",
		description = "Mute sounds caused by a failed pickpocket attempt.",
		position = 0,
		section = soundSection
	)
	default boolean muteFailSounds()
	{
		return true;
	}

	@ConfigItem(
		keyName = "muteSuccessSound",
		name = "Mute Success Sounds",
		description = "Mute sounds caused by a successful pickpocket attempt.",
		position = 1,
		section = soundSection
	)
	default boolean muteSuccessSounds()
	{
		return true;
	}

	@ConfigItem(
		keyName = "muteEmptyPouch",
		name = "Mute Empty Pouch",
		description = "Mute sounds caused by emptying pouches.",
		position = 2,
		section = soundSection
	)
	default boolean muteEmptyPouchSound()
	{
		return false;
	}

	@ConfigItem(
		keyName = "muteNoSpace",
		name = "Mute No Space",
		description = "Mute sounds caused by pickpocketing while having no space for new pouches.",
		position = 3,
		section = soundSection
	)
	default boolean muteNoSpaceSound()
	{
		return false;
	}

	@ConfigItem(
		keyName = "muteVeilActivateSound",
		name = "Mute Shadow Veil Activate",
		description = "Mute sounds caused by Shadow Veil activating.",
		position = 4,
		section = soundSection
	)
	default boolean muteVeilActivateSound()
	{
		return false;
	}

	@ConfigItem(
		keyName = "muteVeilFadeSound",
		name = "Mute Shadow Veil Fade",
		description = "Mute sounds caused by Shadow Veil fading.",
		position = 5,
		section = soundSection
	)
	default boolean muteVeilFadeSound()
	{
		return false;
	}

	@ConfigSection(
		name = "Alerts",
		description = "",
		position = 1
	)
	String alertSection = "alertSection";

	@ConfigItem(
		keyName = "alertType",
		name = "Type",
		description = "How you will be alerted. Either chat messages, notifications, or speech audio.",
		position = 0,
		section = alertSection
	)
	default AlertType getAlertType()
	{
		return AlertType.SPEECH;
	}

	@ConfigItem(
		keyName = "volume",
		name = "Speech Volume",
		description = "Adjustable volume for Speech Alerts",
		position = 0,
		section = alertSection
	)
	@Units(Units.PERCENT)
	@Range(min = 1, max = 100)
	default int volume() {
		return 50;
	}

	@ConfigItem(
		keyName = "inactiveDelay",
		name = "Inactive Delay",
		description = "The delay for being notified after not having picked any pockets. A value of 0 will disable the notification.",
		position = 1,
		section = alertSection
	)
	@Units(Units.SECONDS)
	default int getInactiveNotificationDelay()
	{
		return 30;
	}

	@ConfigItem(
		keyName = "targetDespawnThreshold",
		name = "Despawn Threshold",
		description = "The threshold for being notified when your target is about to despawn due to not moving. A value of 0 will disable the notification,",
		position = 2,
		section = alertSection
	)
	@Units(Units.SECONDS)
	default int getTargetDespawnThreshold()
	{
		return 30;
	}

	@ConfigItem(
		keyName = "hpThreshold",
		name = "HP Threshold",
		description = "The hitpoint threshold for being notified. A value of 0 will disable the notification.",
		position = 3,
		section = alertSection
	)
	default int getHitpointsThreshold()
	{
		return 12;
	}

	@ConfigItem(
		keyName = "enableIdleSplasherNotification",
		name = "Idle Splasher",
		description = "Enable being notified when, if a splasher is present, the target your are pickpocketing is no longer being splashed. Stopping pickpocketing will allow the splasher to restart attacking.",
		position = 4,
		section = alertSection
	)
	default boolean enableIdleSplasherNotification()
	{
		return true;
	}

	@ConfigItem(
		keyName = "enableNecklaceNotification",
		name = "Dodgy Necklace Breaking",
		description = "Enable being notified when your dodgy necklace breaks.",
		position = 5,
		section = alertSection
	)
	default boolean enableNecklaceNotification()
	{
		return true;
	}

	@ConfigItem(
		keyName = "enableGlovesNotification",
		name = "Gloves of Silence Breaking",
		description = "Enable being notified when your gloves of silence are about to break.",
		position = 6,
		section = alertSection
	)
	default boolean enableGlovesNotification()
	{
		return false;
	}

	@ConfigItem(
		keyName = "enableRogueEquipmentNotification",
		name = "Missing Rogue Equipment",
		description = "Enable being notified when pickpocketing while missing one or more pieces of rogue equipment.",
		position = 7,
		section = alertSection
	)
	default boolean enableRogueEquipmentNotification()
	{
		return true;
	}

	@ConfigItem(
		keyName = "enableShadowVeilNotification",
		name = "Shadow Veil Fading",
		description = "Enable being notified when the Shadow Veil spell fades. Only recommended when you have veil sounds muted.",
		position = 8,
		section = alertSection
	)
	default boolean enableShadowVeilNotification()
	{
		return false;
	}

	@ConfigItem(
		keyName = "enableNoSpaceNotification",
		name = "No Space",
		description = "Enable being notified when there is no space for new pouches. Only recommended when you have pouch sounds muted.",
		position = 9,
		section = alertSection
	)
	default boolean enableNoSpaceNotification()
	{
		return false;
	}

	@ConfigItem(
		keyName = "muteChatMessages",
		name = "Mute Chat Messages",
		description = "Disable chat messages that are send accompanying notification- and voice alerts.",
		position = 10,
		section = alertSection
	)
	default boolean muteChatMessages()
	{
		return false;
	}

	@ConfigSection(
		name = "Utility",
		description = "",
		position = 2
	)
	String utilitySection = "utilitySection";

	@ConfigItem(
		keyName = "hideOthers",
		name = "Hide Others",
		description = "Hide any entity that is not you, your target, the splasher, or your pet, friend, or clanmate. This avoids yellow-clicks and being interrupted by random events or wandering NPC blocking your target.",
		position = 0,
		section = utilitySection
	)
	default boolean enableHideOthers()
	{
		return true;
	}

	@ConfigItem(
		keyName = "blockSpam",
		name = "Hide Spam Messages",
		description = "Hide game messages that spam your chat box but aren't filtered, like having to empty your pouches.",
		position = 1,
		section = utilitySection
	)
	default boolean enableBlockSpam()
	{
		return true;
	}

	@ConfigItem(
		keyName = "enableLeftClickPickpocket",
		name = "Left-click Pickpocket",
		description = "Make pickpocket the left-click option for any NPC that can be pickpocketed.",
		position = 2,
		section = utilitySection
	)
	default boolean enableLeftClickPickpocket()
	{
		return false;
	}

	@ConfigSection(
		name = "Indicators",
		description = "",
		position = 3
	)
	String indicatorsSection = "indicatorsSection";

	@ConfigItem(
		keyName = "enableDespawnTimer",
		name = "Despawn Timer",
		description = "Show a timer above your target that counts down to despawning because of not moving.",
		position = 0,
		section = indicatorsSection
	)
	default boolean enableDespawnTimer()
	{
		return true;
	}

	@ConfigItem(
		keyName = "ardyMode",
		name = "Ardy Knight Mode",
		description = "Controls whether Knight of Ardougne despawn timer should be 600 seconds (for large groups) or 300 seconds (for solo).",
		position = 1,
		section = indicatorsSection
	)
	default ArdyMode ardyMode() {
		return ArdyMode.GROUP;
	}

	@ConfigItem(
		keyName = "highLightTarget",
		name = "Highlight Target",
		description = "Highlight the clickable area of your last target.",
		position = 2,
		section = indicatorsSection
	)
	default boolean highLightTarget()
	{
		return true;
	}

	@Alpha
	@ConfigItem(
		keyName = "npcColor",
		name = "Highlight Color",
		description = "Color of the highlight border, menu, and text.",
		position = 3,
		section = indicatorsSection
	)
	default Color highlightColor()
	{
		return new Color(255, 57, 125, 255);
	}

	@Alpha
	@ConfigItem(
		keyName = "fillColor",
		name = "Fill Color",
		description = "Color of the highlight fill",
		position = 4,
		section = indicatorsSection
	)
	default Color fillColor()
	{
		return new Color(255, 57, 125, 85);
	}

	@ConfigItem(
		keyName = "borderWidth",
		name = "Border Width",
		description = "Width of the highlighted border",
		position = 5,
		section = indicatorsSection
	)
	default double borderWidth()
	{
		return 2;
	}

	@ConfigItem(
		keyName = "outlineFeather",
		name = "Outline Feather",
		description = "Fade the highlight outline with a value of 0 to 4.",
		position = 6,
		section = indicatorsSection
	)
	@Range(
		min = 0,
		max = 4
	)
	default int outlineFeather()
	{
		return 0;
	}

	@ConfigSection(
		name = "Overlays",
		description = "",
		position = 4
	)
	String overlaySection = "overlaySection";

	@ConfigItem(
		keyName = "enableSplasherOverlay",
		name = "Splasher Info",
		description = "Enable displaying an overlaying containing information, if present, about the splasher.",
		position = 0,
		section = overlaySection
	)
	default boolean enableSplasherOverlay()
	{
		return true;
	}

	@ConfigItem(
		keyName = "enableStatsOverlay",
		name = "Session Stats",
		description = "Enable displaying an overlaying containing session stats.",
		position = 1,
		section = overlaySection
	)
	default boolean enableStatsOverlay()
	{
		return true;
	}

	@ConfigItem(
		keyName = "enableStatusOverlay",
		name = "Pickpocket Status",
		description = "Enable displaying an overlay indicating if you are pickpocketing.",
		position = 2,
		section = overlaySection
	)
	default boolean enableStatusOverlay()
	{
		return false;
	}
}

package com.pickpockethelper;

import net.runelite.api.ChatMessageType;
import net.runelite.client.Notifier;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;

import javax.inject.Inject;
import javax.inject.Singleton;

/**
 * Simplifies interacting with Runelite's chat- and notification services.
 * Handles any feedback to the player through chat messages and notifications.
 */
@Singleton
public class FeedbackManager {
    private final PickpocketHelperConfig config;

    private final Notifier notifier;

    private final ChatMessageManager chatMessageManager;

    @Inject
    public FeedbackManager(PickpocketHelperConfig config, Notifier notifier, ChatMessageManager chatMessageManager) {
        this.config = config;
        this.notifier = notifier;
        this.chatMessageManager = chatMessageManager;
    }

    /**
     * Send a simple chat messages with a unified type.
     * @param content the text of the chat message.
     * @param type the message's color type.
     */
    public void sendChatMessage(String content, ChatColorType type) {
        String message = new ChatMessageBuilder()
                .append(type)
                .append(content)
                .build();

        sendChatMessage(message);
    }

    /**
     * Send chat message without additional style applied.
     * @param content the content of the message, optionally made with the message builder.
     */
    public void sendChatMessage(String content) {
        chatMessageManager.queue(QueuedMessage.builder()
                .type(ChatMessageType.CONSOLE)
                .runeLiteFormattedMessage(content)
                .build());
    }

    /**
     * Send a notification, with the option to also send the message in chat.
     * @param content content of the notification.
     * @param sendChatMessage if a chat message is included.
     */
    public void sendNotification(String content, boolean sendChatMessage) {
        // Send notification.
        notifier.notify(content);

        // Don't send chat message if muted.
        if (sendChatMessage && !config.muteChatMessages()) {
            sendChatMessage(content, ChatColorType.HIGHLIGHT);
        }
    }
}

package com.pickpockethelper;

import net.runelite.api.NPC;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.npcoverlay.HighlightedNpc;
import net.runelite.client.game.npcoverlay.NpcOverlayService;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.IdentityHashMap;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;

/**
 * Simplifies interaction with Runelite's overlay service.
 * Handles highlighting NPCs.
 */
@Singleton
public class HighlightManager {

    static final Set<String> CONFIG_DEPENDENCIES = Set.of("highLightTarget", "npcColor", "fillColor", "borderWidth", "outlineFeather");

    private final PickpocketHelperConfig config;

    private final NpcOverlayService npcOverlayService;

    private final Map<NPC, HighlightedNpc> targets = new IdentityHashMap<>();
    private final Function<NPC, HighlightedNpc> isTarget = targets::get;

    @Inject
    public HighlightManager(PickpocketHelperConfig config, NpcOverlayService npcOverlayService, ClientThread clientThread) {
        this.config = config;
        this.npcOverlayService = npcOverlayService;

        clientThread.invoke(this::refresh);
    }

    public void register() {
        npcOverlayService.registerHighlighter(isTarget);
    }

    public void unregister() {
        npcOverlayService.unregisterHighlighter(isTarget);
    }

    /**
     * Format an NPC as a highlightedNPC, so it can be highlighted.
     * @param npc the NPC to be highlighted.
     * @return an highlightedNpc object used by the highlight service.
     */
    private HighlightedNpc highLightNpc(NPC npc) {
        return HighlightedNpc.builder()
                .npc(npc)
                .highlightColor(config.highlightColor())
                .fillColor(config.fillColor())
                .hull(config.highLightTarget())
                .borderWidth((float) config.borderWidth())
                .outlineFeather(config.outlineFeather())
                .build();
    }

    public void addTarget(NPC target) {
        targets.put(target, highLightNpc(target));
        this.refresh();
    }

    public void clearTargets() {
        targets.clear();
        this.refresh();
    }

    /**
     * Refresh currently highlighted targets.
     * This needs to happen after, for example, the configuration changes.
     */
    public void refresh() {
        targets.replaceAll((npc, v) -> highLightNpc(npc));
        npcOverlayService.rebuild();
    }
}

package com.pickpockethelper;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PickpocketHelperPluginTest
{
	@SuppressWarnings("unchecked")
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(PickpocketHelperPlugin.class);
		RuneLite.main(args);
	}
}

