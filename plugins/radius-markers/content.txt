package com.radiusmarkers;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class RadiusMarkerPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(RadiusMarkerPlugin.class);
		RuneLite.main(args);
	}
}
package com.radiusmarkers;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JSpinner;
import javax.swing.SpinnerNumberModel;
import javax.swing.SwingUtilities;
import javax.swing.border.Border;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.components.FlatTextField;
import net.runelite.client.ui.components.TitleCaseListCellRenderer;
import net.runelite.client.ui.components.colorpicker.RuneliteColorPicker;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

class RadiusMarkerPanel extends JPanel
{
	private static final Border NAME_BOTTOM_BORDER = new CompoundBorder(
		BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.DARK_GRAY_COLOR),
		BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_COLOR));

	private static final ImageIcon BORDER_COLOR_ICON;
	private static final ImageIcon BORDER_COLOR_HOVER_ICON;
	private static final ImageIcon NO_BORDER_COLOR_ICON;
	private static final ImageIcon NO_BORDER_COLOR_HOVER_ICON;

	private static final ImageIcon VISIBLE_ICON;
	private static final ImageIcon VISIBLE_HOVER_ICON;
	private static final ImageIcon INVISIBLE_ICON;
	private static final ImageIcon INVISIBLE_HOVER_ICON;

	private static final ImageIcon DELETE_ICON;
	private static final ImageIcon DELETE_HOVER_ICON;

	private static final ImageIcon COLLAPSE_ICON;
	private static final ImageIcon COLLAPSE_HOVER_ICON;
	private static final ImageIcon EXPAND_ICON;
	private static final ImageIcon EXPAND_HOVER_ICON;

	private final RadiusMarkerPlugin plugin;
	private final RadiusMarkerConfig config;
	private final ColourRadiusMarker marker;

	private final JPanel containerSpawn = new JPanel(new BorderLayout());
	private final JPanel containerWander = new JPanel(new BorderLayout());
	private final JPanel containerMax = new JPanel(new BorderLayout());
	private final JPanel containerAggression = new JPanel(new BorderLayout());
	private final JPanel containerRetreatInteraction = new JPanel(new BorderLayout());
	private final JPanel containerNpcId = new JPanel(new BorderLayout());
	private final JPanel containerAttack = new JPanel(new BorderLayout());
	private final JPanel containerHunt = new JPanel(new BorderLayout());
	private final JPanel containerInteraction = new JPanel(new BorderLayout());
	private final JLabel colourSpawn = new JLabel();
	private final JLabel colourWander = new JLabel();
	private final JLabel colourMax = new JLabel();
	private final JLabel colourAggression = new JLabel();
	private final JLabel colourRetreatInteraction = new JLabel();
	private final JLabel colourAttack = new JLabel();
	private final JLabel colourHunt = new JLabel();
	private final JLabel colourInteraction = new JLabel();
	private final JLabel visibilityMarker = new JLabel();
	private final JLabel visibilitySpawn = new JLabel();
	private final JLabel visibilityWander = new JLabel();
	private final JLabel visibilityMax = new JLabel();
	private final JLabel visibilityAggression = new JLabel();
	private final JLabel visibilityRetreatInteraction = new JLabel();
	private final JLabel visibilityAttack = new JLabel();
	private final JLabel visibilityHunt = new JLabel();
	private final JLabel visibilityInteraction = new JLabel();
	private final JLabel deleteLabel = new JLabel();
	private final JButton expandToggle;

	private final FlatTextField nameInput = new FlatTextField();
	private final JLabel save = new JLabel("Save");
	private final JLabel cancel = new JLabel("Cancel");
	private final JLabel rename = new JLabel("Rename");

	private final JSpinner spinnerX = new JSpinner(new SpinnerNumberModel(5, 0, Integer.MAX_VALUE, 1));
	private final JSpinner spinnerY = new JSpinner(new SpinnerNumberModel(5, 0, Integer.MAX_VALUE, 1));
	private final JSpinner spinnerRadiusWander = new JSpinner(new SpinnerNumberModel(5, 0, Integer.MAX_VALUE, 1));
	private final JSpinner spinnerRadiusMax = new JSpinner(new SpinnerNumberModel(5, 0, Integer.MAX_VALUE, 1));
	private final JSpinner spinnerNpcId = new JSpinner(new SpinnerNumberModel(5, 0, Integer.MAX_VALUE, 1));
	private final JSpinner spinnerRadiusAttack = new JSpinner(new SpinnerNumberModel(5, 0, Integer.MAX_VALUE, 1));
	private final JSpinner spinnerRadiusHunt = new JSpinner(new SpinnerNumberModel(5, 0, Integer.MAX_VALUE, 1));
	private final JSpinner spinnerRadiusInteraction = new JSpinner(new SpinnerNumberModel(5, 0, Integer.MAX_VALUE, 1));

	static
	{
		final BufferedImage borderImg = ImageUtil.loadImageResource(RadiusMarkerPlugin.class, "border_color_icon.png");
		final BufferedImage borderImgHover = ImageUtil.luminanceOffset(borderImg, -150);
		BORDER_COLOR_ICON = new ImageIcon(borderImg);
		BORDER_COLOR_HOVER_ICON = new ImageIcon(borderImgHover);

		NO_BORDER_COLOR_ICON = new ImageIcon(borderImgHover);
		NO_BORDER_COLOR_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(borderImgHover, -100));

		final BufferedImage visibleImg = ImageUtil.loadImageResource(RadiusMarkerPlugin.class, "visible_icon.png");
		VISIBLE_ICON = new ImageIcon(visibleImg);
		VISIBLE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(visibleImg, -100));

		final BufferedImage invisibleImg = ImageUtil.loadImageResource(RadiusMarkerPlugin.class, "invisible_icon.png");
		INVISIBLE_ICON = new ImageIcon(invisibleImg);
		INVISIBLE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(invisibleImg, -100));

		final BufferedImage deleteImg = ImageUtil.loadImageResource(RadiusMarkerPlugin.class, "delete_icon.png");
		DELETE_ICON = new ImageIcon(deleteImg);
		DELETE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(deleteImg, -100));

		BufferedImage retractIcon = ImageUtil.loadImageResource(RadiusMarkerPlugin.class, "arrow_right.png");
		retractIcon = ImageUtil.luminanceOffset(retractIcon, -121);
		EXPAND_ICON = new ImageIcon(retractIcon);
		EXPAND_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(retractIcon, -100));
		final BufferedImage expandIcon = ImageUtil.rotateImage(retractIcon, Math.PI / 2);
		COLLAPSE_ICON = new ImageIcon(expandIcon);
		COLLAPSE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(expandIcon, -100));
	}

	RadiusMarkerPanel(RadiusMarkerPlugin plugin, RadiusMarkerConfig config, ColourRadiusMarker marker)
	{
		this.plugin = plugin;
		this.config = config;
		this.marker = marker;

		marker.setPanel(this);

		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARKER_GRAY_COLOR);
		setBorder(new EmptyBorder(0, 0, 0, 0));

		JPanel nameWrapper = new JPanel(new BorderLayout());
		nameWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		nameWrapper.setBorder(NAME_BOTTOM_BORDER);

		JPanel nameActions = new JPanel(new FlowLayout(FlowLayout.RIGHT, 3, 3));
		nameActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		save.setVisible(false);
		save.setFont(FontManager.getRunescapeSmallFont());
		save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
		save.setBorder(new EmptyBorder(3, 0, 0, 3));
		save.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				save();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR.darker());
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
			}
		});

		cancel.setVisible(false);
		cancel.setFont(FontManager.getRunescapeSmallFont());
		cancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
		cancel.setBorder(new EmptyBorder(3, 0, 0, 3));
		cancel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				cancel();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				cancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR.darker());
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				cancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
			}
		});

		rename.setFont(FontManager.getRunescapeSmallFont());
		rename.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
		rename.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				nameInput.setEditable(true);
				updateNameActions(true);
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				rename.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker().darker());
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				rename.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
			}
		});

		nameInput.setText(marker.getName());
		nameInput.setBorder(null);
		nameInput.setEditable(false);
		nameInput.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		nameInput.setPreferredSize(new Dimension(0, 24));
		nameInput.getTextField().setForeground(Color.WHITE);
		nameInput.getTextField().setBorder(new EmptyBorder(0, 5, 0, 0));
		nameInput.addKeyListener(new KeyAdapter()
		{
			@Override
			public void keyPressed(KeyEvent e)
			{
				if (e.getKeyCode() == KeyEvent.VK_ENTER)
				{
					save();
				}
				else if (e.getKeyCode() == KeyEvent.VK_ESCAPE)
				{
					cancel();
				}
			}
		});
		nameInput.getTextField().addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				if (e.getClickCount() == 2 && e.getButton() == MouseEvent.BUTTON1)
				{
					final boolean open = containerSpawn.isVisible();
					marker.setCollapsed(open);
					updateCollapsed();
					plugin.saveMarkers();
				}
			}
		});

		final JPanel[] containers = new JPanel[]
		{
			containerSpawn, containerWander, containerMax, containerAggression, containerRetreatInteraction,
			containerNpcId, containerAttack, containerHunt, containerInteraction
		};
		for (JPanel container : containers)
		{
			container.setBorder(new EmptyBorder(5, 0, 5, 0));
			container.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		}
		containerNpcId.setBorder(new EmptyBorder(5, 26, 5, 26));

		JPanel leftActionsSpawn = new JPanel(new FlowLayout(FlowLayout.LEFT, 8, 0));
		JPanel leftActionsWander = new JPanel(new FlowLayout(FlowLayout.LEFT, 8, 0));
		JPanel leftActionsMax = new JPanel(new FlowLayout(FlowLayout.LEFT, 8, 0));
		JPanel leftActionsAggression = new JPanel(new FlowLayout(FlowLayout.LEFT, 8, 0));
		JPanel leftActionsRetreatInteraction = new JPanel(new FlowLayout(FlowLayout.LEFT, 8, 0));
		JPanel leftActionsNpcId = new JPanel(new FlowLayout(FlowLayout.LEFT, 8, 0));
		JPanel leftActionsAttack = new JPanel(new FlowLayout(FlowLayout.LEFT, 8, 0));
		JPanel leftActionsHunt = new JPanel(new FlowLayout(FlowLayout.LEFT, 8, 0));
		JPanel leftActionsInteraction = new JPanel(new FlowLayout(FlowLayout.LEFT, 8, 0));

		leftActionsSpawn.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		leftActionsWander.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		leftActionsMax.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		leftActionsAggression.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		leftActionsRetreatInteraction.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		leftActionsNpcId.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		leftActionsAttack.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		leftActionsHunt.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		leftActionsInteraction.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		colourSpawn.setToolTipText("Edit spawn point colour");
		colourSpawn.setForeground(marker.getSpawnColour() == null ?
			config.defaultColourSpawn() : marker.getSpawnColour());
		colourSpawn.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				openColourPickerSpawn();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				colourSpawn.setIcon(config.borderWidth() == 0 ? NO_BORDER_COLOR_HOVER_ICON : BORDER_COLOR_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				colourSpawn.setIcon(config.borderWidth() == 0 ? NO_BORDER_COLOR_ICON : BORDER_COLOR_ICON);
			}
		});

		colourWander.setToolTipText("Edit wander range colour");
		colourWander.setForeground(marker.getWanderColour() == null ?
			config.defaultColourWander() : marker.getWanderColour());
		colourWander.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				openColourPickerWander();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				colourWander.setIcon(config.borderWidth() == 0 ? NO_BORDER_COLOR_HOVER_ICON : BORDER_COLOR_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				colourWander.setIcon(config.borderWidth() == 0 ? NO_BORDER_COLOR_ICON : BORDER_COLOR_ICON);
			}
		});

		colourMax.setToolTipText("Edit max range colour");
		colourMax.setForeground(marker.getMaxColour() == null ? config.defaultColourMax() : marker.getMaxColour());
		colourMax.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				openColourPickerMax();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				colourMax.setIcon(config.borderWidth() == 0 ? NO_BORDER_COLOR_HOVER_ICON : BORDER_COLOR_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				colourMax.setIcon(config.borderWidth() == 0 ? NO_BORDER_COLOR_ICON : BORDER_COLOR_ICON);
			}
		});

		colourAggression.setToolTipText("Edit aggression range colour");
		colourAggression.setForeground(marker.getAggressionColour() == null ?
			config.defaultColourAggression() : marker.getAggressionColour());
		colourAggression.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				openColourPickerAggression();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				colourAggression.setIcon(config.borderWidth() == 0 ? NO_BORDER_COLOR_HOVER_ICON : BORDER_COLOR_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				colourAggression.setIcon(config.borderWidth() == 0 ? NO_BORDER_COLOR_ICON : BORDER_COLOR_ICON);
			}
		});

		colourRetreatInteraction.setToolTipText("Edit retreat interaction range colour");
		colourRetreatInteraction.setForeground(marker.getRetreatInteractionColour() == null ?
			config.defaultColourRetreatInteraction() : marker.getRetreatInteractionColour());
		colourRetreatInteraction.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				openColourPickerRetreatInteraction();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				colourRetreatInteraction.setIcon(config.borderWidth() == 0 ? NO_BORDER_COLOR_HOVER_ICON : BORDER_COLOR_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				colourRetreatInteraction.setIcon(config.borderWidth() == 0 ? NO_BORDER_COLOR_ICON : BORDER_COLOR_ICON);
			}
		});

		colourAttack.setToolTipText("Edit attack range colour");
		colourAttack.setForeground(marker.getAttackColour() == null ?
			config.defaultColourAttack() : marker.getAttackColour());
		colourAttack.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				openColourPickerAttack();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				colourAttack.setIcon(config.borderWidth() == 0 ? NO_BORDER_COLOR_HOVER_ICON : BORDER_COLOR_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				colourAttack.setIcon(config.borderWidth() == 0 ? NO_BORDER_COLOR_ICON : BORDER_COLOR_ICON);
			}
		});

		colourHunt.setToolTipText("Edit hunt range colour");
		colourHunt.setForeground(marker.getHuntColour() == null ? config.defaultColourHunt() : marker.getHuntColour());
		colourHunt.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				openColourPickerHunt();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				colourHunt.setIcon(config.borderWidth() == 0 ? NO_BORDER_COLOR_HOVER_ICON : BORDER_COLOR_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				colourHunt.setIcon(config.borderWidth() == 0 ? NO_BORDER_COLOR_ICON : BORDER_COLOR_ICON);
			}
		});

		colourInteraction.setToolTipText("Edit interaction range colour");
		colourInteraction.setForeground(marker.getInteractionColour() == null ?
			config.defaultColourInteraction() : marker.getInteractionColour());
		colourInteraction.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				openColourPickerInteraction();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				colourInteraction.setIcon(config.borderWidth() == 0 ? NO_BORDER_COLOR_HOVER_ICON : BORDER_COLOR_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				colourInteraction.setIcon(config.borderWidth() == 0 ? NO_BORDER_COLOR_ICON : BORDER_COLOR_ICON);
			}
		});

		spinnerX.setValue(marker.getSpawnX());
		spinnerY.setValue(marker.getSpawnY());
		spinnerRadiusWander.setValue(marker.getWanderRadius());
		spinnerRadiusMax.setValue(marker.getMaxRadius());
		spinnerNpcId.setValue(marker.getNpcId());
		spinnerRadiusAttack.setValue(marker.getAttackRadius());
		spinnerRadiusHunt.setValue(marker.getHuntRadius());
		spinnerRadiusInteraction.setValue(marker.getInteractionRadius());

		final JSpinner[] spinners = new JSpinner[]
		{
			spinnerX, spinnerY, spinnerRadiusWander, spinnerRadiusMax, spinnerNpcId,
			spinnerRadiusAttack, spinnerRadiusHunt, spinnerRadiusInteraction
		};
		for (JSpinner spinner : spinners)
		{
			spinner.setPreferredSize(new Dimension(53, 20));
			spinner.addChangeListener(ce -> updateMarker());
		}
		spinnerX.setPreferredSize(new Dimension(70, 20));
		spinnerY.setPreferredSize(new Dimension(70, 20));
		spinnerRadiusWander.setPreferredSize(new Dimension(62, 20));
		spinnerRadiusMax.setPreferredSize(new Dimension(62, 20));
		spinnerNpcId.setPreferredSize(new Dimension(80, 20));

		JLabel labelWander = new JLabel("Wander range");
		JLabel labelMax = new JLabel("Max range");
		JLabel labelAggression = new JLabel("Aggression range");
		JLabel labelRetreatInteraction = new JLabel("Retreat interaction range");
		JLabel labelNpcId = new JLabel("NPC ID");
		JLabel labelHunt = new JLabel("Hunt range");
		JLabel labelInteraction = new JLabel("Interaction range");

		final JLabel[] labels = new JLabel[]
		{
			labelWander, labelMax, labelAggression, labelRetreatInteraction, labelNpcId, labelHunt, labelInteraction
		};
		for (JLabel label : labels)
		{
			label.setFont(FontManager.getRunescapeSmallFont());
			label.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
		}
		labelNpcId.setPreferredSize(new Dimension(58, 21));

		JComboBox<AttackType> selectionAttackType = new JComboBox<>(AttackType.values());
		selectionAttackType.setRenderer(new TitleCaseListCellRenderer());
		selectionAttackType.setPreferredSize(new Dimension(84, 20));
		selectionAttackType.setSelectedIndex(marker.getAttackType() == null ? 0 : marker.getAttackType().ordinal());
		selectionAttackType.setToolTipText("Attack range type");
		selectionAttackType.addActionListener(e ->
		{
			marker.setAttackType((AttackType) selectionAttackType.getSelectedItem());
			plugin.saveMarkers();
		});

		leftActionsSpawn.add(colourSpawn);
		leftActionsSpawn.add(spinnerX);

		leftActionsWander.add(colourWander);
		leftActionsWander.add(labelWander);

		leftActionsMax.add(colourMax);
		leftActionsMax.add(labelMax);

		leftActionsAggression.add(colourAggression);
		leftActionsAggression.add(labelAggression);

		leftActionsRetreatInteraction.add(colourRetreatInteraction);
		leftActionsRetreatInteraction.add(labelRetreatInteraction);

		leftActionsNpcId.add(labelNpcId);

		leftActionsAttack.add(colourAttack);
		leftActionsAttack.add(selectionAttackType);

		leftActionsHunt.add(colourHunt);
		leftActionsHunt.add(labelHunt);

		leftActionsInteraction.add(colourInteraction);
		leftActionsInteraction.add(labelInteraction);

		JPanel rightActionsSpawn = new JPanel(new FlowLayout(FlowLayout.RIGHT, 8, 0));
		JPanel rightActionsWander = new JPanel(new FlowLayout(FlowLayout.RIGHT, 8, 0));
		JPanel rightActionsMax = new JPanel(new FlowLayout(FlowLayout.RIGHT, 8, 0));
		JPanel rightActionsAggression = new JPanel(new FlowLayout(FlowLayout.RIGHT, 8, 0));
		JPanel rightActionsRetreatInteraction = new JPanel(new FlowLayout(FlowLayout.RIGHT, 8, 0));
		JPanel rightActionsNpcId = new JPanel(new FlowLayout(FlowLayout.RIGHT, 8, 0));
		JPanel rightActionsAttack = new JPanel(new FlowLayout(FlowLayout.RIGHT, 8, 0));
		JPanel rightActionsHunt = new JPanel(new FlowLayout(FlowLayout.RIGHT, 8, 0));
		JPanel rightActionsInteraction = new JPanel(new FlowLayout(FlowLayout.RIGHT, 8, 0));

		rightActionsSpawn.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		rightActionsWander.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		rightActionsMax.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		rightActionsAggression.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		rightActionsRetreatInteraction.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		rightActionsNpcId.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		rightActionsAttack.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		rightActionsHunt.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		rightActionsInteraction.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		expandToggle = new JButton(marker.isCollapsed() ? COLLAPSE_ICON : EXPAND_ICON);
		expandToggle.setRolloverIcon(marker.isCollapsed() ? COLLAPSE_HOVER_ICON : EXPAND_HOVER_ICON);
		expandToggle.setPreferredSize(new Dimension(15, 0));
		expandToggle.setBorder(new EmptyBorder(0, 6, 1, 0));
		expandToggle.setToolTipText((marker.isCollapsed() ? "Expand" : "Collapse") + " marker");
		SwingUtil.removeButtonDecorations(expandToggle);
		expandToggle.addActionListener(actionEvent ->
		{
			final boolean open = containerSpawn.isVisible();
			marker.setCollapsed(open);
			updateCollapsed();
			plugin.saveMarkers();
		});

		visibilityMarker.setToolTipText((marker.isVisible() ? "Hide" : "Show") + " marker");
		visibilityMarker.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				marker.setVisible(!marker.isVisible());
				updateVisibility();
				plugin.saveMarkers();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				visibilityMarker.setIcon(marker.isVisible() ? VISIBLE_HOVER_ICON : INVISIBLE_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				updateVisibility();
			}
		});

		deleteLabel.setIcon(DELETE_ICON);
		deleteLabel.setToolTipText("Delete marker");
		deleteLabel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				int confirm = JOptionPane.showConfirmDialog(RadiusMarkerPanel.this,
					"Are you sure you want to permanently delete this radius marker?",
					"Warning", JOptionPane.OK_CANCEL_OPTION);

				if (confirm == 0)
				{
					plugin.removeMarker(marker);
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				deleteLabel.setIcon(DELETE_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				deleteLabel.setIcon(DELETE_ICON);
			}
		});

		visibilitySpawn.setToolTipText((marker.isSpawnVisible() ? "Hide" : "Show") + " spawn point");
		visibilitySpawn.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				marker.setSpawnVisible(!marker.isSpawnVisible());
				updateVisibility();
				plugin.saveMarkers();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				visibilitySpawn.setIcon(marker.isSpawnVisible() ? VISIBLE_HOVER_ICON : INVISIBLE_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				updateVisibility();
			}
		});

		visibilityWander.setToolTipText((marker.isWanderVisible() ? "Hide" : "Show") + " wander range");
		visibilityWander.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				marker.setWanderVisible(!marker.isWanderVisible());
				updateVisibility();
				plugin.saveMarkers();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				visibilityWander.setIcon(marker.isWanderVisible() ? VISIBLE_HOVER_ICON : INVISIBLE_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				updateVisibility();
			}
		});

		visibilityMax.setToolTipText((marker.isMaxVisible() ? "Hide" : "Show") + " max range");
		visibilityMax.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				marker.setMaxVisible(!marker.isMaxVisible());
				updateVisibility();
				plugin.saveMarkers();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				visibilityMax.setIcon(marker.isMaxVisible() ? VISIBLE_HOVER_ICON : INVISIBLE_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				updateVisibility();
			}
		});

		visibilityAggression.setToolTipText((marker.isAggressionVisible() ? "Hide" : "Show") + " aggression range");
		visibilityAggression.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				marker.setAggressionVisible(!marker.isAggressionVisible());
				updateVisibility();
				plugin.saveMarkers();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				visibilityAggression.setIcon(marker.isAggressionVisible() ? VISIBLE_HOVER_ICON : INVISIBLE_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				updateVisibility();
			}
		});

		visibilityRetreatInteraction.setToolTipText((marker.isRetreatInteractionVisible() ? "Hide" : "Show") + " retreat interaction range");
		visibilityRetreatInteraction.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				marker.setRetreatInteractionVisible(!marker.isRetreatInteractionVisible());
				updateVisibility();
				plugin.saveMarkers();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				visibilityRetreatInteraction.setIcon(marker.isRetreatInteractionVisible() ? VISIBLE_HOVER_ICON : INVISIBLE_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				updateVisibility();
			}
		});

		visibilityAttack.setToolTipText((marker.isAttackVisible() ? "Hide" : "Show") + " attack range");
		visibilityAttack.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				marker.setAttackVisible(!marker.isAttackVisible());
				updateVisibility();
				plugin.saveMarkers();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				visibilityAttack.setIcon(marker.isAttackVisible() ? VISIBLE_HOVER_ICON : INVISIBLE_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				updateVisibility();
			}
		});

		visibilityHunt.setToolTipText((marker.isHuntVisible() ? "Hide" : "Show") + " hunt range");
		visibilityHunt.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				marker.setHuntVisible(!marker.isHuntVisible());
				updateVisibility();
				plugin.saveMarkers();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				visibilityHunt.setIcon(marker.isHuntVisible() ? VISIBLE_HOVER_ICON : INVISIBLE_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				updateVisibility();
			}
		});

		visibilityInteraction.setToolTipText((marker.isInteractionVisible() ? "Hide" : "Show") + " interaction range");
		visibilityInteraction.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				marker.setInteractionVisible(!marker.isInteractionVisible());
				updateVisibility();
				plugin.saveMarkers();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				visibilityInteraction.setIcon(marker.isInteractionVisible() ? VISIBLE_HOVER_ICON : INVISIBLE_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				updateVisibility();
			}
		});

		nameActions.add(rename);
		nameActions.add(cancel);
		nameActions.add(save);
		nameActions.add(visibilityMarker);
		nameActions.add(deleteLabel);

		nameWrapper.add(expandToggle, BorderLayout.WEST);
		nameWrapper.add(nameInput, BorderLayout.CENTER);
		nameWrapper.add(nameActions, BorderLayout.EAST);

		rightActionsSpawn.add(spinnerY);
		rightActionsSpawn.add(visibilitySpawn);

		rightActionsWander.add(spinnerRadiusWander);
		rightActionsWander.add(visibilityWander);

		rightActionsMax.add(spinnerRadiusMax);
		rightActionsMax.add(visibilityMax);

		rightActionsAggression.add(visibilityAggression);
		rightActionsRetreatInteraction.add(visibilityRetreatInteraction);

		rightActionsNpcId.add(spinnerNpcId);

		rightActionsAttack.add(spinnerRadiusAttack);
		rightActionsAttack.add(visibilityAttack);

		rightActionsHunt.add(spinnerRadiusHunt);
		rightActionsHunt.add(visibilityHunt);

		rightActionsInteraction.add(spinnerRadiusInteraction);
		rightActionsInteraction.add(visibilityInteraction);

		containerSpawn.add(leftActionsSpawn, BorderLayout.WEST);
		containerSpawn.add(rightActionsSpawn, BorderLayout.EAST);

		containerWander.add(leftActionsWander, BorderLayout.WEST);
		containerWander.add(rightActionsWander, BorderLayout.EAST);

		containerMax.add(leftActionsMax, BorderLayout.WEST);
		containerMax.add(rightActionsMax, BorderLayout.EAST);

		containerAggression.add(leftActionsAggression, BorderLayout.WEST);
		containerAggression.add(rightActionsAggression, BorderLayout.EAST);

		containerRetreatInteraction.add(leftActionsRetreatInteraction, BorderLayout.WEST);
		containerRetreatInteraction.add(rightActionsRetreatInteraction, BorderLayout.EAST);

		containerNpcId.add(leftActionsNpcId, BorderLayout.WEST);
		containerNpcId.add(rightActionsNpcId, BorderLayout.EAST);

		containerAttack.add(leftActionsAttack, BorderLayout.WEST);
		containerAttack.add(rightActionsAttack, BorderLayout.EAST);

		containerHunt.add(leftActionsHunt, BorderLayout.WEST);
		containerHunt.add(rightActionsHunt, BorderLayout.EAST);

		containerInteraction.add(leftActionsInteraction, BorderLayout.WEST);
		containerInteraction.add(rightActionsInteraction, BorderLayout.EAST);

		JPanel markerContainer = new JPanel();
		markerContainer.setLayout(new BoxLayout(markerContainer, BoxLayout.Y_AXIS));
		markerContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		markerContainer.add(nameWrapper);
		markerContainer.add(containerSpawn);
		if (config.includeWanderRange())
		{
			markerContainer.add(containerWander);
		}
		if (config.includeMaxRange())
		{
			markerContainer.add(containerMax);
		}
		if (config.includeAggressionRange())
		{
			markerContainer.add(containerAggression);
		}
		if (config.includeRetreatInteractionRange())
		{
			markerContainer.add(containerRetreatInteraction);
		}
		if (config.includeAttackRange() || config.includeHuntRange() || config.includeInteractionRange())
		{
			markerContainer.add(containerNpcId);
		}
		if (config.includeAttackRange())
		{
			markerContainer.add(containerAttack);
		}
		if (config.includeHuntRange())
		{
			markerContainer.add(containerHunt);
		}
		if (config.includeInteractionRange())
		{
			markerContainer.add(containerInteraction);
		}

		add(markerContainer);

		updateVisibility();
		updateColourIndicators();
		updateCollapsed();
	}

	public void setMarkerText(final String text)
	{
		nameInput.setText(text);
	}

	public void setNpcId(final int npcId)
	{
		spinnerNpcId.setValue(npcId);
	}

	private void save()
	{
		marker.setName(nameInput.getText());
		plugin.saveMarkers();

		nameInput.setEditable(false);
		updateNameActions(false);
		requestFocusInWindow();
	}

	private void cancel()
	{
		nameInput.setEditable(false);
		nameInput.setText(marker.getName());
		updateNameActions(false);
		requestFocusInWindow();
	}

	private void updateNameActions(boolean saveAndCancel)
	{
		save.setVisible(saveAndCancel);
		cancel.setVisible(saveAndCancel);
		rename.setVisible(!saveAndCancel);
		expandToggle.setVisible(!saveAndCancel);
		visibilityMarker.setVisible(!saveAndCancel);
		deleteLabel.setVisible(!saveAndCancel);

		if (saveAndCancel)
		{
			nameInput.getTextField().requestFocusInWindow();
			nameInput.getTextField().selectAll();
			plugin.setRenameMarker(marker);
		}
		else
		{
			plugin.setRenameMarker(null);
		}
	}

	private void updateMarker()
	{
		marker.setSpawnX((int) spinnerX.getValue());
		marker.setSpawnY((int) spinnerY.getValue());

		marker.setWanderRadius((int) spinnerRadiusWander.getValue());
		marker.setMaxRadius((int) spinnerRadiusMax.getValue());

		marker.setNpcId((int) spinnerNpcId.getValue());

		marker.setAttackRadius((int) spinnerRadiusAttack.getValue());
		marker.setHuntRadius((int) spinnerRadiusHunt.getValue());
		marker.setInteractionRadius((int) spinnerRadiusInteraction.getValue());

		updateVisibility();

		plugin.saveMarkers();
	}

	private void updateVisibility()
	{
		visibilityMarker.setIcon(marker.isVisible() ? VISIBLE_ICON : INVISIBLE_ICON);
		visibilitySpawn.setIcon(marker.isSpawnVisible() ? VISIBLE_ICON : INVISIBLE_ICON);
		visibilityWander.setIcon(marker.isWanderVisible() ? VISIBLE_ICON : INVISIBLE_ICON);
		visibilityMax.setIcon(marker.isMaxVisible() ? VISIBLE_ICON : INVISIBLE_ICON);
		visibilityAggression.setIcon(marker.isAggressionVisible() ? VISIBLE_ICON : INVISIBLE_ICON);
		visibilityRetreatInteraction.setIcon(marker.isRetreatInteractionVisible() ? VISIBLE_ICON : INVISIBLE_ICON);
		visibilityAttack.setIcon(marker.isAttackVisible() ? VISIBLE_ICON : INVISIBLE_ICON);
		visibilityHunt.setIcon(marker.isHuntVisible() ? VISIBLE_ICON : INVISIBLE_ICON);
		visibilityInteraction.setIcon(marker.isInteractionVisible() ? VISIBLE_ICON : INVISIBLE_ICON);
	}

	private void updateCollapsed()
	{
		final boolean open = !marker.isCollapsed();

		rename.setVisible(open);

		containerSpawn.setVisible(open);
		containerWander.setVisible(open);
		containerMax.setVisible(open);
		containerAggression.setVisible(open);
		containerRetreatInteraction.setVisible(open);
		containerNpcId.setVisible(open);
		containerAttack.setVisible(open);
		containerHunt.setVisible(open);
		containerInteraction.setVisible(open);

		expandToggle.setIcon(open ? COLLAPSE_ICON : EXPAND_ICON);
		expandToggle.setRolloverIcon(open ? COLLAPSE_HOVER_ICON : EXPAND_HOVER_ICON);
		expandToggle.setToolTipText((open ? "Collapse" : "Expand") + " marker");
	}

	private void updateColourIndicators()
	{
		final boolean borderless = config.borderWidth() == 0;

		colourSpawn.setBorder(borderless ? null : new MatteBorder(0, 0, 3, 0, marker.getSpawnColour()));
		colourWander.setBorder(borderless ? null : new MatteBorder(0, 0, 3, 0, marker.getWanderColour()));
		colourMax.setBorder(borderless ? null : new MatteBorder(0, 0, 3, 0, marker.getMaxColour()));
		colourAggression.setBorder(borderless ? null : new MatteBorder(0, 0, 3, 0, marker.getAggressionColour()));
		colourRetreatInteraction.setBorder(borderless ? null : new MatteBorder(0, 0, 3, 0, marker.getRetreatInteractionColour()));
		colourAttack.setBorder(borderless ? null : new MatteBorder(0, 0, 3, 0, marker.getAttackColour()));
		colourHunt.setBorder(borderless ? null : new MatteBorder(0, 0, 3, 0, marker.getHuntColour()));
		colourInteraction.setBorder(borderless ? null : new MatteBorder(0, 0, 3, 0, marker.getInteractionColour()));

		colourSpawn.setIcon(borderless ? NO_BORDER_COLOR_ICON : BORDER_COLOR_ICON);
		colourWander.setIcon(borderless ? NO_BORDER_COLOR_ICON : BORDER_COLOR_ICON);
		colourMax.setIcon(borderless ? NO_BORDER_COLOR_ICON : BORDER_COLOR_ICON);
		colourAggression.setIcon(borderless ? NO_BORDER_COLOR_ICON : BORDER_COLOR_ICON);
		colourRetreatInteraction.setIcon(borderless ? NO_BORDER_COLOR_ICON : BORDER_COLOR_ICON);
		colourAttack.setIcon(borderless ? NO_BORDER_COLOR_ICON : BORDER_COLOR_ICON);
		colourHunt.setIcon(borderless ? NO_BORDER_COLOR_ICON : BORDER_COLOR_ICON);
		colourInteraction.setIcon(borderless ? NO_BORDER_COLOR_ICON : BORDER_COLOR_ICON);
	}

	private void openColourPickerSpawn()
	{
		Color color = marker.getSpawnColour() == null ? config.defaultColourSpawn() : marker.getSpawnColour();
		RuneliteColorPicker colourPicker = getColourPicker(color, " - Spawn point colour");
		colourPicker.setOnColorChange(c ->
		{
			marker.setSpawnColour(c);
			updateColourIndicators();
		});
		colourPicker.setVisible(true);
	}

	private void openColourPickerWander()
	{
		Color color = marker.getWanderColour() == null ? config.defaultColourWander() : marker.getWanderColour();
		RuneliteColorPicker colourPicker = getColourPicker(color, " - Wander range colour");
		colourPicker.setOnColorChange(c ->
		{
			marker.setWanderColour(c);
			updateColourIndicators();
		});
		colourPicker.setVisible(true);
	}

	private void openColourPickerMax()
	{
		Color color = marker.getMaxColour() == null ? config.defaultColourMax() : marker.getMaxColour();
		RuneliteColorPicker colourPicker = getColourPicker(color, " - Max range colour");
		colourPicker.setOnColorChange(c ->
		{
			marker.setMaxColour(c);
			updateColourIndicators();
		});
		colourPicker.setVisible(true);
	}

	private void openColourPickerAggression()
	{
		Color color = marker.getAggressionColour() == null ? config.defaultColourAggression() : marker.getAggressionColour();
		RuneliteColorPicker colourPicker = getColourPicker(color, " - Aggression range colour");
		colourPicker.setOnColorChange(c ->
		{
			marker.setAggressionColour(c);
			updateColourIndicators();
		});
		colourPicker.setVisible(true);
	}

	private void openColourPickerRetreatInteraction()
	{
		Color color = marker.getRetreatInteractionColour() == null ?
			config.defaultColourRetreatInteraction() : marker.getRetreatInteractionColour();
		RuneliteColorPicker colourPicker = getColourPicker(color, " - Retreat interaction range colour");
		colourPicker.setOnColorChange(c ->
		{
			marker.setRetreatInteractionColour(c);
			updateColourIndicators();
		});
		colourPicker.setVisible(true);
	}

	private void openColourPickerAttack()
	{
		Color color = marker.getAttackColour() == null ? config.defaultColourAttack() : marker.getAttackColour();
		RuneliteColorPicker colourPicker = getColourPicker(color, " - Attack range colour");
		colourPicker.setOnColorChange(c ->
		{
			marker.setAttackColour(c);
			updateColourIndicators();
		});
		colourPicker.setVisible(true);
	}

	private void openColourPickerHunt()
	{
		Color color = marker.getHuntColour() == null ? config.defaultColourHunt() : marker.getHuntColour();
		RuneliteColorPicker colourPicker = getColourPicker(color, " - Hunt range colour");
		colourPicker.setOnColorChange(c ->
		{
			marker.setHuntColour(c);
			updateColourIndicators();
		});
		colourPicker.setVisible(true);
	}

	private void openColourPickerInteraction()
	{
		Color color = marker.getInteractionColour() == null ? config.defaultColourInteraction() : marker.getInteractionColour();
		RuneliteColorPicker colourPicker = getColourPicker(color, " - Interaction range colour");
		colourPicker.setOnColorChange(c ->
		{
			marker.setInteractionColour(c);
			updateColourIndicators();
		});
		colourPicker.setVisible(true);
	}

	private RuneliteColorPicker getColourPicker(Color colour, String text)
	{
		RuneliteColorPicker colourPicker = plugin.getColourPickerManager().create(
			SwingUtilities.windowForComponent(this),
			colour,
			marker.getName() + text,
			false);
		colourPicker.setLocationRelativeTo(this);
		colourPicker.setOnClose(c -> plugin.saveMarkers());
		return colourPicker;
	}
}

package com.radiusmarkers;

import com.google.common.base.Strings;
import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Inject;
import com.google.inject.Provides;
import java.awt.Point;
import java.awt.Polygon;
import java.awt.Rectangle;
import java.awt.Shape;
import java.awt.geom.Ellipse2D;
import java.awt.image.BufferedImage;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import javax.swing.JOptionPane;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import static net.runelite.api.MenuAction.MENU_ACTION_DEPRIORITIZE_OFFSET;
import net.runelite.api.MenuEntry;
import net.runelite.api.NPC;
import net.runelite.api.SpriteID;
import net.runelite.api.Varbits;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;

@PluginDescriptor(
	name = "Radius Markers",
	description = "Highlight NPC radius regions like attack, hunt, max and wander range",
	tags = {"npc", "range", "region", "aggression", "attack", "hunt", "interaction", "max", "retreat", "wander"}
)
public class RadiusMarkerPlugin extends Plugin
{
	public static final String CONFIG_GROUP = "radiusmarkers";
	private static final String CONFIG_KEY = "markers";
	private static final String PLUGIN_NAME = "Radius Markers";
	private static final String ICON_FILE = "panel_icon.png";
	private static final String DEFAULT_MARKER_NAME = "Marker";
	private static final String UPDATE_MARKER = "Update marker";

	@Getter(AccessLevel.PACKAGE)
	private final List<ColourRadiusMarker> markers = new ArrayList<>();

	@Setter(AccessLevel.PACKAGE)
	private ColourRadiusMarker renameMarker = null;

	@Inject
	private Client client;

	@Inject
	private RadiusMarkerConfig config;

	@Inject
	private RadiusMarkerMapOverlay mapOverlay;

	@Inject
	private RadiusMarkerSceneOverlay sceneOverlay;

	@Inject
	private RadiusMarkerMinimapOverlay minimapOverlay;

	@Inject
	private ConfigManager configManager;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private Gson gson;

	@Inject
	private SpriteManager spriteManager;

	@Getter
	@Inject
	private ColorPickerManager colourPickerManager;

	private RadiusMarkerPluginPanel pluginPanel;
	private NavigationButton navigationButton;
	private BufferedImage minimapSpriteFixed;
	private BufferedImage minimapSpriteResizeable;
	private Shape minimapClipFixed;
	private Shape minimapClipResizeable;
	private Rectangle minimapRectangle = new Rectangle();

	@Provides
	RadiusMarkerConfig providesConfig(ConfigManager configManager)
	{
		return configManager.getConfig(RadiusMarkerConfig.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		overlayManager.add(mapOverlay);
		overlayManager.add(sceneOverlay);
		overlayManager.add(minimapOverlay);

		loadMarkers();

		pluginPanel = new RadiusMarkerPluginPanel(client, this, config);
		pluginPanel.rebuild();

		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), ICON_FILE);

		navigationButton = NavigationButton.builder()
			.tooltip(PLUGIN_NAME)
			.icon(icon)
			.priority(5)
			.panel(pluginPanel)
			.build();


		if (!config.hideNavButton())
		{
			clientToolbar.addNavigation(navigationButton);
		}
	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove(mapOverlay);
		overlayManager.remove(sceneOverlay);
		overlayManager.remove(minimapOverlay);

		markers.clear();

		clientToolbar.removeNavigation(navigationButton);

		pluginPanel = null;
		navigationButton = null;
	}

	@Subscribe
	public void onConfigChanged(final ConfigChanged configChanged)
	{
		if (!configChanged.getGroup().equals(CONFIG_GROUP))
		{
			return;
		}
		if (configChanged.getKey().equals("hideNavButton"))
		{
			if (config.hideNavButton())
			{
				clientToolbar.removeNavigation(navigationButton);
			}
			else
			{
				clientToolbar.addNavigation(navigationButton);
			}
		}
	}

	@Subscribe
	public void onMenuEntryAdded(final MenuEntryAdded event)
	{
		int type = event.getType();

		if (type >= MENU_ACTION_DEPRIORITIZE_OFFSET)
		{
			type -= MENU_ACTION_DEPRIORITIZE_OFFSET;
		}

		final MenuAction menuAction = MenuAction.of(type);

		if (MenuAction.EXAMINE_NPC.equals(menuAction) && renameMarker != null)
		{
			final int id = event.getIdentifier();
			final NPC[] cachedNPCs = client.getCachedNPCs();
			final NPC npc = cachedNPCs[id];

			if (npc == null || npc.getName() == null)
			{
				return;
			}

			client.createMenuEntry(-1)
				.setOption(UPDATE_MARKER)
				.setTarget(event.getTarget())
				.setParam0(event.getActionParam0())
				.setParam1(event.getActionParam1())
				.setIdentifier(event.getIdentifier())
				.setType(MenuAction.RUNELITE)
				.onClick(this::updateMarkerInfo);
		}
	}

	private void updateMarkerInfo(MenuEntry entry)
	{
		final NPC[] cachedNPCs = client.getCachedNPCs();
		final NPC npc = cachedNPCs[entry.getIdentifier()];

		if (npc == null || npc.getName() == null || renameMarker == null)
		{
			return;
		}

		renameMarker.getPanel().setMarkerText(npc.getName());
		renameMarker.getPanel().setNpcId(npc.getId());
	}

	private void loadMarkers()
	{
		markers.clear();

		final Collection<RadiusMarker> radiusMarkers = getRadiusMarkers();

		if (radiusMarkers != null)
		{
			final List<ColourRadiusMarker> colourRadiusMarkers = translateToColourRadiusMarker(radiusMarkers);
			markers.addAll(colourRadiusMarkers);
			Collections.sort(markers);
		}
	}

	private Collection<RadiusMarker> getRadiusMarkers()
	{
		String json = configManager.getConfiguration(CONFIG_GROUP, CONFIG_KEY);

		if (Strings.isNullOrEmpty(json))
		{
			return Collections.emptyList();
		}

		try
		{
			List<RadiusMarker> loaded = gson.fromJson(json, new TypeToken<List<RadiusMarker>>(){}.getType());
			loaded.removeIf(RadiusMarker::isInvalid);
			return loaded;
		}
		catch (IllegalStateException | JsonSyntaxException ignore)
		{
			JOptionPane.showConfirmDialog(pluginPanel,
				"The radius markers you are trying to load from your config are malformed",
				"Warning", JOptionPane.OK_CANCEL_OPTION);
			return null;
		}
	}

	private void saveMarkers(Collection<RadiusMarker> markers)
	{
		if (markers == null || markers.isEmpty())
		{
			configManager.unsetConfiguration(CONFIG_GROUP, CONFIG_KEY);
			return;
		}

		String json = gson.toJson(markers);
		configManager.setConfiguration(CONFIG_GROUP, CONFIG_KEY, json);
	}

	public String copyMarkers()
	{
		List<RadiusMarker> markersCopy = new ArrayList<>();

		int regionId = client.getLocalPlayer() == null ? -1 : client.getLocalPlayer().getWorldLocation().getRegionID();
		String searchTerm = pluginPanel.getSearchText().toLowerCase();
		PanelFilter filter = pluginPanel.getPanelFilter();

		for (ColourRadiusMarker marker : markers)
		{
			if (marker.getName().toLowerCase().contains(searchTerm) &&
				(PanelFilter.ALL.equals(filter) ||
				(PanelFilter.REGION.equals(filter) && marker.getWorldPoint().getRegionID() == regionId) ||
				(PanelFilter.VISIBLE.equals(filter) && marker.isVisible()) ||
				(PanelFilter.INVISIBLE.equals(filter) && !marker.isVisible())))
			{
				markersCopy.add(translateToRadiusMarker(marker));
			}
		}

		if (markersCopy.isEmpty())
		{
			return null;
		}

		return gson.toJson(markersCopy);
	}

	public boolean pasteMarkers(String json)
	{
		if (Strings.isNullOrEmpty(json))
		{
			return false;
		}

		List<RadiusMarker> radiusMarkers;
		try
		{
			radiusMarkers = gson.fromJson(json, new TypeToken<List<RadiusMarker>>(){}.getType());
			radiusMarkers.removeIf(RadiusMarker::isInvalid);
		}
		catch (IllegalStateException | JsonSyntaxException ignore)
		{
			JOptionPane.showConfirmDialog(pluginPanel,
				"The radius markers you are trying to import are malformed",
				"Warning", JOptionPane.OK_CANCEL_OPTION);
			return false;
		}
		List<ColourRadiusMarker> outputMarkers = new ArrayList<>();
		List<ColourRadiusMarker> colourRadiusMarkers = translateToColourRadiusMarker(radiusMarkers);

		for (ColourRadiusMarker radiusMarker : colourRadiusMarkers)
		{
			boolean unique = true;
			for (ColourRadiusMarker marker : markers)
			{
				if (marker.getId() == radiusMarker.getId())
				{
					unique = false;
					break;
				}
			}
			if (unique)
			{
				outputMarkers.add(radiusMarker);
			}
		}

		if (outputMarkers.isEmpty())
		{
			return false;
		}

		markers.addAll(outputMarkers);
		Collections.sort(markers);
		saveMarkers();

		return true;
	}

	public boolean exclude(NPC npc)
	{
		return npc == null || npc.getName() == null || npc.getName().isEmpty() || "null".equals(npc.getName());
	}

	private List<ColourRadiusMarker> translateToColourRadiusMarker(Collection<RadiusMarker> markers)
	{
		if (markers.isEmpty())
		{
			return Collections.emptyList();
		}

		return markers.stream().map(ColourRadiusMarker::new).collect(Collectors.toList());
	}

	private RadiusMarker translateToRadiusMarker(ColourRadiusMarker colourRadiusMarker)
	{
		return new RadiusMarker(
			colourRadiusMarker.getId(),
			colourRadiusMarker.getName(),
			colourRadiusMarker.isVisible(),
			colourRadiusMarker.isCollapsed(),
			colourRadiusMarker.getZ(),
			colourRadiusMarker.getSpawnX(),
			colourRadiusMarker.getSpawnY(),
			colourRadiusMarker.getSpawnColour(),
			colourRadiusMarker.isSpawnVisible(),
			colourRadiusMarker.getWanderRadius(),
			colourRadiusMarker.getWanderColour(),
			colourRadiusMarker.isWanderVisible(),
			colourRadiusMarker.getMaxRadius(),
			colourRadiusMarker.getMaxColour(),
			colourRadiusMarker.isMaxVisible(),
			colourRadiusMarker.getAggressionColour(),
			colourRadiusMarker.isAggressionVisible(),
			colourRadiusMarker.getRetreatInteractionColour(),
			colourRadiusMarker.isRetreatInteractionVisible(),
			colourRadiusMarker.getNpcId(),
			colourRadiusMarker.getAttackRadius(),
			colourRadiusMarker.getAttackColour(),
			colourRadiusMarker.getAttackType(),
			colourRadiusMarker.isAttackVisible(),
			colourRadiusMarker.getHuntRadius(),
			colourRadiusMarker.getHuntColour(),
			colourRadiusMarker.isHuntVisible(),
			colourRadiusMarker.getInteractionRadius(),
			colourRadiusMarker.getInteractionColour(),
			colourRadiusMarker.isInteractionVisible());
	}

	private ColourRadiusMarker findColourRadiusMarker(RadiusMarker radiusMarker)
	{
		for (final ColourRadiusMarker colourRadiusMarker : markers)
		{
			if (colourRadiusMarker.equals(radiusMarker))
			{
				return colourRadiusMarker;
			}
		}
		return null;
	}

	private Polygon bufferedImageToPolygon(BufferedImage image)
	{
		int outsideColour = -1;
		int previousColour;
		final int width = image.getWidth();
		final int height = image.getHeight();
		List<Point> points = new ArrayList<>();
		for (int y = 0; y < height; y++)
		{
			previousColour = outsideColour;
			for (int x = 0; x < width; x++)
			{
				int colour = image.getRGB(x, y);
				if (x == 0 && y == 0)
				{
					outsideColour = colour;
					previousColour = colour;
				}
				if (colour != outsideColour && previousColour == outsideColour)
				{
					points.add(new Point(x, y));
				}
				if ((colour == outsideColour || x == (width - 1)) && previousColour != outsideColour)
				{
					points.add(0, new Point(x, y));
				}
				previousColour = colour;
			}
		}
		int offsetX = 0;
		int offsetY = 0;
		Widget minimapDrawWidget = getMinimapDrawWidget();
		if (minimapDrawWidget != null)
		{
			offsetX = minimapDrawWidget.getBounds().x;
			offsetY = minimapDrawWidget.getBounds().y;
		}
		Polygon polygon = new Polygon();
		for (Point point : points)
		{
			polygon.addPoint(point.x + offsetX, point.y + offsetY);
		}
		return polygon;
	}

	private Shape getMinimapClipAreaSimple()
	{
		Widget minimapDrawArea = getMinimapDrawWidget();

		if (minimapDrawArea == null || minimapDrawArea.isHidden())
		{
			return null;
		}

		Rectangle bounds = minimapDrawArea.getBounds();

		return new Ellipse2D.Double(bounds.getX(), bounds.getY(), bounds.getWidth(), bounds.getHeight());
	}

	public void saveMarkers()
	{
		List<RadiusMarker> radiusMarkers = new ArrayList<>();

		for (ColourRadiusMarker cm : markers)
		{
			radiusMarkers.add(translateToRadiusMarker(cm));
		}

		saveMarkers(radiusMarkers);
	}

	public ColourRadiusMarker addMarker()
	{
		if (client.getLocalPlayer() == null)
		{
			return null;
		}

		final WorldPoint worldPoint = WorldPoint.fromLocalInstance(client, client.getLocalPlayer().getLocalLocation());

		return findColourRadiusMarker(addMarker(worldPoint));
	}

	public RadiusMarker addMarker(WorldPoint worldPoint)
	{
		final RadiusMarker marker = new RadiusMarker(
			Instant.now().toEpochMilli(),
			DEFAULT_MARKER_NAME + " " + (markers.size() + 1),
			true,
			false,
			worldPoint.getPlane(),
			worldPoint.getX(),
			worldPoint.getY(),
			config.defaultColourSpawn(),
			true,
			config.defaultRadiusWander(),
			config.defaultColourWander(),
			true,
			config.defaultRadiusMax(),
			config.defaultColourMax(),
			true,
			config.defaultColourAggression(),
			true,
			config.defaultColourRetreatInteraction(),
			false,
			0,
			config.defaultRadiusAttack(),
			config.defaultColourAttack(),
			AttackType.MELEE,
			true,
			config.defaultRadiusHunt(),
			config.defaultColourHunt(),
			false,
			config.defaultRadiusInteraction(),
			config.defaultColourInteraction(),
			false);

		List<RadiusMarker> radiusMarkers = new ArrayList<>(getRadiusMarkers());
		if (!radiusMarkers.contains(marker))
		{
			radiusMarkers.add(marker);
		}

		saveMarkers(radiusMarkers);

		loadMarkers();

		pluginPanel.rebuild();

		return marker;
	}

	public void removeMarker(ColourRadiusMarker colourRadiusMarker)
	{
		RadiusMarker radiusMarker = translateToRadiusMarker(colourRadiusMarker);

		List<RadiusMarker> radiusMarkers = new ArrayList<>(getRadiusMarkers());

		radiusMarkers.remove(radiusMarker);

		saveMarkers(radiusMarkers);

		loadMarkers();

		pluginPanel.rebuild();
	}

	public Collection<WorldPoint> getInstanceWorldPoints(WorldPoint worldPointTemplate)
	{
		if (!client.isInInstancedRegion())
		{
			return Collections.singleton(worldPointTemplate);
		}

		return WorldPoint.toLocalInstance(client, worldPointTemplate);
	}

	public Shape getMinimapClipArea()
	{
		Widget minimapWidget = getMinimapDrawWidget();

		if (minimapWidget == null || minimapWidget.isHidden() || !minimapRectangle.equals(minimapRectangle = minimapWidget.getBounds()))
		{
			minimapClipFixed = null;
			minimapClipResizeable = null;
			minimapSpriteFixed = null;
			minimapSpriteResizeable = null;
		}

		if (client.isResized())
		{
			if (minimapClipResizeable != null)
			{
				return minimapClipResizeable;
			}
			if (minimapSpriteResizeable == null)
			{
				minimapSpriteResizeable = spriteManager.getSprite(SpriteID.RESIZEABLE_MODE_MINIMAP_ALPHA_MASK, 0);
			}
			if (minimapSpriteResizeable != null)
			{
				return minimapClipResizeable = bufferedImageToPolygon(minimapSpriteResizeable);
			}
			return getMinimapClipAreaSimple();
		}
		if (minimapClipFixed != null)
		{
			return minimapClipFixed;
		}
		if (minimapSpriteFixed == null)
		{
			minimapSpriteFixed = spriteManager.getSprite(SpriteID.FIXED_MODE_MINIMAP_ALPHA_MASK, 0);
		}
		if (minimapSpriteFixed != null)
		{
			return minimapClipFixed = bufferedImageToPolygon(minimapSpriteFixed);
		}
		return getMinimapClipAreaSimple();
	}

	public Widget getMinimapDrawWidget()
	{
		if (client.isResized())
		{
			if (client.getVarbitValue(Varbits.SIDE_PANELS) == 1)
			{
				return client.getWidget(ComponentID.RESIZABLE_VIEWPORT_BOTTOM_LINE_MINIMAP_DRAW_AREA);
			}
			return client.getWidget(ComponentID.RESIZABLE_VIEWPORT_MINIMAP_DRAW_AREA);
		}
		return client.getWidget(ComponentID.FIXED_VIEWPORT_MINIMAP_DRAW_AREA);
	}
}

package com.radiusmarkers;

import com.google.inject.Inject;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Stroke;
import java.awt.geom.GeneralPath;
import java.util.Collection;
import java.util.List;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

class RadiusMarkerSceneOverlay extends Overlay
{
	private static final int MAX_DRAW_DISTANCE = 32;
	private static final int LOCAL_TILE_SIZE = Perspective.LOCAL_TILE_SIZE;

	private final Client client;
	private final RadiusMarkerConfig config;
	private final RadiusMarkerPlugin plugin;

	private int x;
	private int y;

	@Inject
	private RadiusMarkerSceneOverlay(Client client, RadiusMarkerConfig config, RadiusMarkerPlugin plugin)
	{
		this.client = client;
		this.config = config;
		this.plugin = plugin;
		setPosition(OverlayPosition.DYNAMIC);
		setPriority(Overlay.PRIORITY_LOW);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		final Collection<ColourRadiusMarker> markers = plugin.getMarkers();
		final List<NPC> npcs = client.getNpcs();

		if (markers.isEmpty())
		{
			return null;
		}

		Stroke stroke = new BasicStroke((float) config.borderWidth());

		for (final ColourRadiusMarker marker : markers)
		{
			if (!marker.isVisible())
			{
				continue;
			}

			final boolean excludeCorner = AttackType.MELEE.equals(marker.getAttackType());

			final Collection<WorldPoint> worldPoints = plugin.getInstanceWorldPoints(marker.getWorldPoint());

			for (WorldPoint worldPoint : worldPoints)
			{
				if (worldPoint.getPlane() != client.getPlane())
				{
					continue;
				}

				if (config.includeRetreatInteractionRange() && marker.isRetreatInteractionVisible())
				{
					drawBox(graphics, worldPoint, marker.getRetreatInteractionRadius(),
						marker.getRetreatInteractionColour(), stroke, 1, false);
				}

				if (config.includeAggressionRange() && marker.isAggressionVisible())
				{
					drawBox(graphics, worldPoint, marker.getAggressionRadius(), marker.getAggressionColour(),
						stroke, client.getNpcDefinition(marker.getNpcId()).getSize(), excludeCorner);
				}

				if (config.includeMaxRange() && marker.isMaxVisible())
				{
					drawBox(graphics, worldPoint, marker.getMaxRadius(), marker.getMaxColour(), stroke, 1, false);
				}

				if (config.includeWanderRange() && marker.isWanderVisible())
				{
					drawBox(graphics, worldPoint, marker.getWanderRadius(), marker.getWanderColour(), stroke, 1, false);
				}

				if (marker.isSpawnVisible())
				{
					drawBox(graphics, worldPoint, 0, marker.getSpawnColour(), stroke, 1, false);
				}
			}

			for (NPC npc : npcs)
			{
				if (npc.getId() != marker.getNpcId() || plugin.exclude(npc))
				{
					continue;
				}

				final WorldPoint npcLocation = npc.getWorldLocation();
				final int size = npc.getComposition().getSize();

				if (config.includeInteractionRange() && marker.isInteractionVisible())
				{
					drawBox(graphics, npcLocation, marker.getInteractionRadius(),
						marker.getInteractionColour(), stroke, size, false);
				}

				if (config.includeHuntRange() && marker.isHuntVisible())
				{
					drawBox(graphics, npcLocation, marker.getHuntRadius(), marker.getHuntColour(), stroke, 1, false);
				}

				if (config.includeAttackRange() && marker.isAttackVisible())
				{
					drawBox(graphics, npcLocation, marker.getAttackRadius(), marker.getAttackColour(),
						stroke, size, excludeCorner);
				}
			}
		}

		return null;
	}

	private void drawBox(Graphics2D graphics, WorldPoint worldPoint, int radius,
		Color borderColour, Stroke borderStroke, int size, boolean excludeCorner)
	{
		graphics.setStroke(borderStroke);
		graphics.setColor(borderColour);
		graphics.draw(getSquare(worldPoint, radius, size, excludeCorner));
	}

	private GeneralPath getSquare(final WorldPoint worldPoint, final int radius, final int size, boolean excludeCorner)
	{
		GeneralPath path = new GeneralPath();

		if (client.getLocalPlayer() == null)
		{
			return path;
		}

		final int startX = worldPoint.getX() - radius;
		final int startY = worldPoint.getY() - radius;
		final int z = worldPoint.getPlane();

		final int diameter = 2 * radius + size;

		excludeCorner = excludeCorner && radius > 0;

		x = startX;
		y = startY;

		final WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();

		final int[] xs = new int[4 * diameter + 1];
		final int[] ys = new int[xs.length];

		for (int i = 0; i < xs.length; i++)
		{
			if (i < diameter)
			{
				xs[0 * diameter + i] = startX + i;
				xs[1 * diameter + i] = startX + diameter;
				xs[2 * diameter + i] = startX + diameter - i;
				xs[3 * diameter + i] = startX;
				ys[0 * diameter + i] = startY;
				ys[1 * diameter + i] = startY + i;
				ys[2 * diameter + i] = startY + diameter;
				ys[3 * diameter + i] = startY + diameter - i;
			}
			else if (i == diameter)
			{
				xs[xs.length - 1] = xs[0];
				ys[ys.length - 1] = ys[0];
			}
			if (excludeCorner && i == 0)
			{
				xs[0 * diameter + i] += 1;
				xs[1 * diameter + i] -= 1;
				xs[2 * diameter + i] -= 1;
				xs[3 * diameter + i] += 1;
				ys[0 * diameter + i] += 1;
				ys[1 * diameter + i] += 1;
				ys[2 * diameter + i] -= 1;
				ys[3 * diameter + i] -= 1;
				x = xs[i];
				y = ys[i];
			}

			boolean hasFirst = false;
			if (playerLocation.distanceTo(new WorldPoint(x, y, z)) < MAX_DRAW_DISTANCE)
			{
				hasFirst = moveTo(path, x, y, z);
			}

			x = xs[i];
			y = ys[i];

			if (hasFirst && playerLocation.distanceTo(new WorldPoint(x, y, z)) < MAX_DRAW_DISTANCE)
			{
				lineTo(path, x, y, z);
			}
		}

		return path;
	}

	private boolean moveTo(GeneralPath path, final int x, final int y, final int z)
	{
		Point point = XYToPoint(x, y, z);
		if (point != null)
		{
			path.moveTo(point.getX(), point.getY());
			return true;
		}
		return false;
	}

	private void lineTo(GeneralPath path, final int x, final int y, final int z)
	{
		Point point = XYToPoint(x, y, z);
		if (point != null)
		{
			path.lineTo(point.getX(), point.getY());
		}
	}

	private Point XYToPoint(int x, int y, int z)
	{
		LocalPoint localPoint = LocalPoint.fromWorld(client, x, y);

		if (localPoint == null)
		{
			return null;
		}

		return Perspective.localToCanvas(
			client,
			new LocalPoint(localPoint.getX() - LOCAL_TILE_SIZE / 2, localPoint.getY() - LOCAL_TILE_SIZE / 2),
			z);
	}
}

package com.radiusmarkers;

enum PanelFilter
{
	ALL,
	REGION,
	VISIBLE,
	INVISIBLE;

	private static final PanelFilter[] FILTERS = values();

	public PanelFilter next()
	{
		return FILTERS[(this.ordinal() + 1) % FILTERS.length];
	}
}

package com.radiusmarkers;

import java.awt.Color;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.coords.WorldPoint;

/**
 * Used to denote marked tiles, radiuses and their colours.
 * Note: This is not used for serialization of radius markers; see {@link RadiusMarker}
 */
@Getter
@Setter
class ColourRadiusMarker implements Comparable<ColourRadiusMarker>
{
	static final int RETREAT_INTERACTION_RANGE = 11;

	private RadiusMarkerPanel panel;

	private long id;

	private String name;
	private boolean visible;
	private boolean collapsed;

	private final int z;

	private int spawnX;
	private int spawnY;
	private Color spawnColour;
	private boolean spawnVisible;

	private int wanderRadius;
	private Color wanderColour;
	private boolean wanderVisible;

	private int maxRadius;
	private Color maxColour;
	private boolean maxVisible;

	private int aggressionRadius;
	private Color aggressionColour;
	private boolean aggressionVisible;

	private int retreatInteractionRadius;
	private Color retreatInteractionColour;
	private boolean retreatInteractionVisible;

	private int npcId;

	private int attackRadius;
	private Color attackColour;
	private AttackType attackType;
	private boolean attackVisible;

	private int huntRadius;
	private Color huntColour;
	private boolean huntVisible;

	private int interactionRadius;
	private Color interactionColour;
	private boolean interactionVisible;

	ColourRadiusMarker(RadiusMarker radiusMarker)
	{
		this.id = radiusMarker.getId();

		this.name = radiusMarker.getName() == null ? "Marker" : radiusMarker.getName();
		this.visible = radiusMarker.isVisible();
		this.collapsed = radiusMarker.isCollapsed();

		this.z = radiusMarker.getZ();
		this.spawnX = radiusMarker.getSpawnX();
		this.spawnY = radiusMarker.getSpawnY();
		this.spawnColour = radiusMarker.getSpawnColour();
		this.spawnVisible = radiusMarker.isSpawnVisible();

		this.wanderRadius = radiusMarker.getWanderRadius();
		this.wanderColour = radiusMarker.getWanderColour();
		this.wanderVisible = radiusMarker.isWanderVisible();

		this.maxRadius = radiusMarker.getMaxRadius();
		this.maxColour = radiusMarker.getMaxColour();
		this.maxVisible = radiusMarker.isMaxVisible();

		this.aggressionRadius = radiusMarker.getMaxRadius() + radiusMarker.getAttackRadius();
		this.aggressionColour = radiusMarker.getAggressionColour();
		this.aggressionVisible = radiusMarker.isAggressionVisible();

		this.retreatInteractionRadius = radiusMarker.getMaxRadius() + RETREAT_INTERACTION_RANGE;
		this.retreatInteractionColour = radiusMarker.getRetreatInteractionColour();
		this.retreatInteractionVisible = radiusMarker.isRetreatInteractionVisible();

		this.npcId = radiusMarker.getNpcId();

		this.attackRadius = radiusMarker.getAttackRadius();
		this.attackColour = radiusMarker.getAttackColour();
		this.attackType = radiusMarker.getAttackType();
		this.attackVisible = radiusMarker.isAttackVisible();

		this.huntRadius = radiusMarker.getHuntRadius();
		this.huntColour = radiusMarker.getHuntColour();
		this.huntVisible = radiusMarker.isHuntVisible();

		this.interactionRadius = radiusMarker.getInteractionRadius();
		this.interactionColour = radiusMarker.getInteractionColour();
		this.interactionVisible = radiusMarker.isInteractionVisible();
	}

	public void setMaxRadius(int maxRadius)
	{
		this.maxRadius = maxRadius;
		aggressionRadius = maxRadius + attackRadius;
		retreatInteractionRadius = maxRadius + RETREAT_INTERACTION_RANGE;
	}

	public void setAttackRadius(int attackRadius)
	{
		this.attackRadius = attackRadius;
		aggressionRadius = maxRadius + attackRadius;
	}

	public WorldPoint getWorldPoint()
	{
		return new WorldPoint(spawnX, spawnY, z);
	}

	@Override
	public int compareTo(ColourRadiusMarker other)
	{
		return this.name.compareTo(other.name);
	}

	public boolean equals(RadiusMarker other)
	{
		return id == other.getId();
	}
}

package com.radiusmarkers;

import com.google.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.geom.GeneralPath;
import java.util.Collection;
import java.util.List;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

class RadiusMarkerMinimapOverlay extends Overlay
{
	private final Client client;
	private final RadiusMarkerConfig config;
	private final RadiusMarkerPlugin plugin;

	@Inject
	RadiusMarkerMinimapOverlay(Client client, RadiusMarkerConfig config, RadiusMarkerPlugin plugin)
	{
		this.client = client;
		this.config = config;
		this.plugin = plugin;

		setPosition(OverlayPosition.DYNAMIC);
		setPriority(Overlay.PRIORITY_LOW);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (config.showMinimap())
		{
			drawMinimap(graphics);
		}
		return null;
	}

	private void drawMinimap(Graphics2D graphics)
	{
		graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);
		graphics.setClip(plugin.getMinimapClipArea());

		final List<ColourRadiusMarker> markers = plugin.getMarkers();
		final List<NPC> npcs = client.getNpcs();

		for (final ColourRadiusMarker marker : markers)
		{
			if (!marker.isVisible())
			{
				continue;
			}

			final boolean excludeCorner = AttackType.MELEE.equals(marker.getAttackType());

			final Collection<WorldPoint> worldPoints = plugin.getInstanceWorldPoints(marker.getWorldPoint());

			for (WorldPoint worldPoint : worldPoints)
			{
				if (config.includeRetreatInteractionRange() && marker.isRetreatInteractionVisible())
				{
					drawSquare(graphics, worldPoint, marker.getRetreatInteractionColour(),
						marker.getRetreatInteractionRadius(), 1, false);
				}

				if (config.includeAggressionRange() && marker.isAggressionVisible())
				{
					drawSquare(graphics, worldPoint, marker.getAggressionColour(),
						marker.getAggressionRadius(), client.getNpcDefinition(marker.getNpcId()).getSize(), excludeCorner);
				}

				if (config.includeMaxRange() && marker.isMaxVisible())
				{
					drawSquare(graphics, worldPoint, marker.getMaxColour(), marker.getMaxRadius(), 1, false);
				}

				if (config.includeWanderRange() && marker.isWanderVisible())
				{
					drawSquare(graphics, worldPoint, marker.getWanderColour(), marker.getWanderRadius(), 1, false);
				}

				if (marker.isSpawnVisible())
				{
					drawSquare(graphics, worldPoint, marker.getSpawnColour(), 0, 1, false);
				}
			}

			for (NPC npc : npcs)
			{
				if (npc.getId() != marker.getNpcId() || plugin.exclude(npc))
				{
					continue;
				}

				final WorldPoint npcLocation = npc.getWorldLocation();
				final int size = npc.getComposition().getSize();

				if (config.includeInteractionRange() && marker.isInteractionVisible())
				{
					drawSquare(graphics, npcLocation, marker.getInteractionColour(),
						marker.getInteractionRadius(), size, false);
				}

				if (config.includeHuntRange() && marker.isHuntVisible())
				{
					drawSquare(graphics, npcLocation, marker.getHuntColour(), marker.getHuntRadius(), 1, false);
				}

				if (config.includeAttackRange() && marker.isAttackVisible())
				{
					drawSquare(graphics, npcLocation, marker.getAttackColour(),
						marker.getAttackRadius(), size, excludeCorner);
				}
			}
		}
	}

	private void drawSquare(Graphics2D graphics, WorldPoint center, Color color,
		int radius, int size, boolean excludeCorner)
	{
		if (center.getPlane() != client.getPlane())
		{
			return;
		}

		final WorldPoint southWest = center.dx(-radius).dy(-radius);
		final int diameter = 2 * radius + size;

		graphics.setColor(color);

		GeneralPath path = new GeneralPath();
		if (radius > 0 && excludeCorner)
		{
			updateLine(path, new WorldPoint[]
			{
				southWest.dx(1).dy(1), southWest.dx(1), southWest.dx(diameter - 1), southWest.dx(diameter - 1).dy(1)
			});
			updateLine(path, new WorldPoint[]
			{
				southWest.dx(diameter - 1).dy(1), southWest.dx(diameter).dy(1),
				southWest.dx(diameter).dy(diameter - 1), southWest.dx(diameter - 1).dy(diameter - 1)
			});
			updateLine(path, new WorldPoint[]
			{
				southWest.dx(1).dy(1), southWest.dy(1), southWest.dy(diameter - 1), southWest.dx(1).dy(diameter - 1)
			});
			updateLine(path, new WorldPoint[]
			{
				southWest.dx(1).dy(diameter - 1), southWest.dx(1).dy(diameter),
				southWest.dx(diameter - 1).dy(diameter), southWest.dx(diameter - 1).dy(diameter - 1)
			});
		}
		else
		{
			updateLine(path, new WorldPoint[] { southWest, southWest.dx(diameter) });
			updateLine(path, new WorldPoint[] { southWest.dx(diameter), southWest.dx(diameter).dy(diameter) });
			updateLine(path, new WorldPoint[] { southWest, southWest.dy(diameter) });
			updateLine(path, new WorldPoint[] { southWest.dy(diameter), southWest.dx(diameter).dy(diameter) });
		}
		graphics.draw(path);
	}

	private void updateLine(GeneralPath path, WorldPoint[] worldPoints)
	{
		for (int i = 1; i < worldPoints.length; i++)
		{
			Point previous = worldToMinimap(worldPoints[i - 1]);
			boolean hasFirst = false;
			if (previous != null)
			{
				path.moveTo(previous.getX(), previous.getY());
				hasFirst = true;
			}
			Point current = worldToMinimap(worldPoints[i]);
			if (hasFirst && current != null)
			{
				path.lineTo(current.getX(), current.getY());
			}
		}
	}

	private Point worldToMinimap(final WorldPoint worldPoint)
	{
		if (client.getLocalPlayer() == null)
		{
			return null;
		}

		final WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();
		final LocalPoint localLocation = client.getLocalPlayer().getLocalLocation();
		final LocalPoint playerLocalPoint = LocalPoint.fromWorld(client, playerLocation);

		if (playerLocalPoint == null)
		{
			return null;
		}

		final int offsetX = playerLocalPoint.getX() - localLocation.getX();
		final int offsetY = playerLocalPoint.getY() - localLocation.getY();

		final int dx = worldPoint.getX() - playerLocation.getX();
		final int dy = worldPoint.getY() - playerLocation.getY();

		final double tileSize = client.getMinimapZoom();

		final int x = (int) (dx * tileSize + offsetX * tileSize / Perspective.LOCAL_TILE_SIZE - tileSize / 2);
		final int y = (int) (dy * tileSize + offsetY * tileSize / Perspective.LOCAL_TILE_SIZE - tileSize / 2 + 1);

		final int angle = client.getCameraYawTarget() & 0x7FF;

		final int sin = Perspective.SINE[angle];
		final int cos = Perspective.COSINE[angle];

		final Widget minimapDrawWidget = plugin.getMinimapDrawWidget();
		if (minimapDrawWidget == null || minimapDrawWidget.isHidden())
		{
			return null;
		}

		final int xx = y * sin + cos * x >> 16;
		final int yy = sin * x - y * cos >> 16;

		final Point loc = minimapDrawWidget.getCanvasLocation();
		final int minimapX = loc.getX() + xx + minimapDrawWidget.getWidth() / 2;
		final int minimapY = loc.getY() + yy + minimapDrawWidget.getHeight() / 2;

		return new Point(minimapX, minimapY);
	}
}

package com.radiusmarkers;

import java.awt.Color;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup(RadiusMarkerPlugin.CONFIG_GROUP)
public interface RadiusMarkerConfig extends Config
{
	@ConfigSection(
		name = "Marker features",
		description = "Customize the marker range parameters to be displayed in the panel",
		position = 0
	)
	String markerFeaturesSection = "markerFeaturesSection";

	@ConfigItem(
		keyName = "includeWanderRange",
		name = "Include wander range",
		description = "Whether the markers should have the wander range parameter",
		position = 1,
		section = markerFeaturesSection
	)
	default boolean includeWanderRange()
	{
		return true;
	}

	@ConfigItem(
		keyName = "includeMaxRange",
		name = "Include max range",
		description = "Whether the markers should have the max range parameter",
		position = 2,
		section = markerFeaturesSection
	)
	default boolean includeMaxRange()
	{
		return true;
	}

	@ConfigItem(
		keyName = "includeAggressionRange",
		name = "Include aggression range",
		description = "Whether the markers should have the aggression range parameter",
		position = 3,
		section = markerFeaturesSection
	)
	default boolean includeAggressionRange()
	{
		return true;
	}

	@ConfigItem(
		keyName = "includeRetreatInteractionRange",
		name = "Include retreat interaction range",
		description = "Whether the markers should have the retreat interaction range parameter",
		position = 4,
		section = markerFeaturesSection
	)
	default boolean includeRetreatInteractionRange()
	{
		return false;
	}

	@ConfigItem(
		keyName = "includeAttackRange",
		name = "Include attack range",
		description = "Whether the markers should have the attack range parameter",
		position = 5,
		section = markerFeaturesSection
	)
	default boolean includeAttackRange()
	{
		return true;
	}

	@ConfigItem(
		keyName = "includeHuntRange",
		name = "Include hunt range",
		description = "Whether the markers should have the hunt range parameter",
		position = 6,
		section = markerFeaturesSection
	)
	default boolean includeHuntRange()
	{
		return false;
	}

	@ConfigItem(
		keyName = "includeInteractionRange",
		name = "Include interaction range",
		description = "Whether the markers should have the interaction range parameter",
		position = 7,
		section = markerFeaturesSection
	)
	default boolean includeInteractionRange()
	{
		return false;
	}

	@ConfigSection(
		name = "Default radiuses",
		description = "Default radius values",
		position = 8
	)
	String defaultRadiusSection = "defaultRadiusSection";

	@ConfigItem(
		keyName = "defaultRadiusWander",
		name = "Wander radius",
		description = "Default NPC wander range radius",
		position = 9,
		section = defaultRadiusSection
	)
	default int defaultRadiusWander()
	{
		return 5;
	}

	@ConfigItem(
		keyName = "defaultRadiusMax",
		name = "Max radius",
		description = "Default NPC max range radius",
		position = 10,
		section = defaultRadiusSection
	)
	default int defaultRadiusMax()
	{
		return 7;
	}

	@ConfigItem(
		keyName = "defaultRadiusAttack",
		name = "Attack radius",
		description = "Default NPC attack range radius",
		position = 11,
		section = defaultRadiusSection
	)
	default int defaultRadiusAttack()
	{
		return 1;
	}

	@ConfigItem(
		keyName = "defaultRadiusHunt",
		name = "Hunt radius",
		description = "Default NPC hunt range radius",
		position = 12,
		section = defaultRadiusSection
	)
	default int defaultRadiusHunt()
	{
		return 1;
	}

	@ConfigItem(
		keyName = "defaultRadiusInteraction",
		name = "Interaction radius",
		description = "Default NPC interaction range radius",
		position = 13,
		section = defaultRadiusSection
	)
	default int defaultRadiusInteraction()
	{
		return 1;
	}

	@ConfigSection(
		name = "Default colours",
		description = "Default radius colour values",
		position = 14
	)
	String defaultColourSection = "defaultColourSection";

	@Alpha
	@ConfigItem(
		keyName = "defaultColourSpawn",
		name = "Spawn point",
		description = "Default NPC spawn tile colour",
		position = 15,
		section = defaultColourSection
	)
	default Color defaultColourSpawn()
	{
		return Color.CYAN;
	}

	@Alpha
	@ConfigItem(
		keyName = "defaultColourWander",
		name = "Wander range",
		description = "Default NPC wander range colour",
		position = 16,
		section = defaultColourSection
	)
	default Color defaultColourWander()
	{
		return Color.YELLOW;
	}

	@Alpha
	@ConfigItem(
		keyName = "defaultColourMax",
		name = "Max range",
		description = "Default NPC max range colour",
		position = 17,
		section = defaultColourSection
	)
	default Color defaultColourMax()
	{
		return Color.MAGENTA;
	}

	@Alpha
	@ConfigItem(
		keyName = "defaultColourAggression",
		name = "Aggression range",
		description = "Default NPC aggression range colour",
		position = 18,
		section = defaultColourSection
	)
	default Color defaultColourAggression()
	{
		return Color.RED;
	}

	@Alpha
	@ConfigItem(
		keyName = "defaultColourRetreatInteraction",
		name = "Retreat interaction range",
		description = "Default NPC retreat interaction range colour",
		position = 19,
		section = defaultColourSection
	)
	default Color defaultColourRetreatInteraction()
	{
		return Color.BLUE;
	}

	@Alpha
	@ConfigItem(
		keyName = "defaultColourAttack",
		name = "Attack range",
		description = "Default NPC attack range colour",
		position = 20,
		section = defaultColourSection
	)
	default Color defaultColourAttack()
	{
		return new Color(127, 0, 0);
	}

	@Alpha
	@ConfigItem(
		keyName = "defaultColourHunt",
		name = "Hunt range",
		description = "Default NPC hunt range colour",
		position = 21,
		section = defaultColourSection
	)
	default Color defaultColourHunt()
	{
		return new Color(255, 127, 0);
	}

	@Alpha
	@ConfigItem(
		keyName = "defaultColourInteraction",
		name = "Interaction range",
		description = "Default NPC interaction range colour",
		position = 22,
		section = defaultColourSection
	)
	default Color defaultColourInteraction()
	{
		return new Color(0, 200, 0);
	}

	@ConfigItem(
		keyName = "borderWidth",
		name = "Border width",
		description = "Radius marker border width",
		position = 23
	)
	default int borderWidth()
	{
		return 3;
	}

	@ConfigItem(
		keyName = "showMinimap",
		name = "Show on minimap",
		description = "Show radius markers on the minimap",
		position = 24
	)
	default boolean showMinimap()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showWorldMap",
		name = "Show on world map",
		description = "Show radius markers on the world map",
		position = 25
	)
	default boolean showWorldMap()
	{
		return true;
	}

	@ConfigItem(
		keyName = "hideNavButton",
		name = "Hide side panel button",
		description = "Whether to hide the side panel button to reduce clutter when not needing to modify markers",
		position = 26
	)
	default boolean hideNavButton()
	{
		return false;
	}
}

package com.radiusmarkers;

import java.applet.Applet;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.io.IOException;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.client.util.ImageUtil;

class RadiusMarkerPluginPanel extends PluginPanel
{
	private static final ImageIcon COPY_ICON;
	private static final ImageIcon COPY_HOVER_ICON;
	private static final ImageIcon PASTE_ICON;
	private static final ImageIcon PASTE_HOVER_ICON;
	private static final ImageIcon ADD_ICON;
	private static final ImageIcon ADD_HOVER_ICON;

	private static final ImageIcon[] FILTER_ICONS;
	private static final String[] FILTER_TEXT = {"ALL", "R", "", ""};
	private static final String[] FILTER_DESCRIPTIONS;

	private final JLabel copyMarkers = new JLabel(COPY_ICON);
	private final JLabel pasteMarkers = new JLabel(PASTE_ICON);
	private final JLabel markerAdd = new JLabel(ADD_ICON);
	private final JLabel title = new JLabel();
	private final JLabel filter = new JLabel(FILTER_ICONS[0]);
	private final IconTextField searchBar = new IconTextField();
	private final PluginErrorPanel noMarkersPanel = new PluginErrorPanel();
	private final JPanel markerView = new JPanel();
	private final JPanel searchPanel = new JPanel(new BorderLayout());

	private final Client client;
	private final RadiusMarkerPlugin plugin;
	private final RadiusMarkerConfig config;

	@Getter
	private PanelFilter panelFilter = PanelFilter.ALL;

	static
	{
		final BufferedImage copyIcon = ImageUtil.loadImageResource(RadiusMarkerPlugin.class, "copy_icon.png");
		COPY_ICON = new ImageIcon(copyIcon);
		COPY_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(copyIcon, 0.53f));

		final BufferedImage pasteIcon = ImageUtil.loadImageResource(RadiusMarkerPlugin.class, "paste_icon.png");
		PASTE_ICON = new ImageIcon(pasteIcon);
		PASTE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(pasteIcon, 0.53f));

		final BufferedImage addIcon = ImageUtil.loadImageResource(RadiusMarkerPlugin.class, "add_icon.png");
		ADD_ICON = new ImageIcon(addIcon);
		ADD_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(addIcon, 0.53f));

		final BufferedImage visibleImg = ImageUtil.loadImageResource(RadiusMarkerPlugin.class, "visible_icon.png");
		final BufferedImage invisibleImg = ImageUtil.loadImageResource(RadiusMarkerPlugin.class, "invisible_icon.png");
		final BufferedImage regionIcon = ImageUtil.loadImageResource(RadiusMarkerPlugin.class, "region_icon.png");

		FILTER_ICONS = new ImageIcon[]
		{
			new ImageIcon(ImageUtil.alphaOffset(visibleImg, 0.0f)),
			new ImageIcon(regionIcon),
			new ImageIcon(visibleImg),
			new ImageIcon(invisibleImg)
		};

		FILTER_DESCRIPTIONS = new String[]
		{
			"<html>Filter:<br>Listing all markers</html>",
			"<html>Filter:<br>Listing only markers in the current region</html>",
			"<html>Filter:<br>Listing only visible markers</html>",
			"<html>Filter:<br>Listing only hidden markers</html>"
		};
	}

	public RadiusMarkerPluginPanel(Client client, RadiusMarkerPlugin plugin, RadiusMarkerConfig config)
	{
		this.client = client;
		this.plugin = plugin;
		this.config = config;

		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(10, 10, 10, 10));

		JPanel northPanel = new JPanel(new BorderLayout());
		northPanel.setBorder(new EmptyBorder(1, 0, 10, 0));

		JPanel titlePanel = new JPanel(new BorderLayout());
		titlePanel.setBorder(new EmptyBorder(1, 3, 10, 7));

		JPanel markerButtons = new JPanel(new FlowLayout(FlowLayout.RIGHT, 7, 3));

		searchPanel.setBorder(new EmptyBorder(1, 0, 0, 0));

		searchBar.setIcon(IconTextField.Icon.SEARCH);
		searchBar.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		searchBar.setHoverBackgroundColor(ColorScheme.DARKER_GRAY_HOVER_COLOR);
		searchBar.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 43 - filter.getWidth(), 24));
		searchBar.addActionListener(e -> rebuild());
		searchBar.addClearListener(this::rebuild);
		searchBar.addKeyListener(new KeyAdapter()
		{
			@Override
			public void keyPressed(KeyEvent e)
			{
				if (e.getKeyCode() == KeyEvent.VK_ESCAPE)
				{
					searchBar.setText("");
					rebuild();
				}
			}
		});

		filter.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		filter.setOpaque(true);
		filter.setPreferredSize(new Dimension(28, 24));
		filter.setText(FILTER_TEXT[0]);
		filter.setToolTipText(FILTER_DESCRIPTIONS[0]);
		filter.setHorizontalTextPosition(JLabel.CENTER);
		filter.setFont(FontManager.getRunescapeSmallFont());
		filter.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				panelFilter = panelFilter.next();
				filter.setText(FILTER_TEXT[panelFilter.ordinal()]);
				filter.setIcon(FILTER_ICONS[panelFilter.ordinal()]);
				filter.setToolTipText(FILTER_DESCRIPTIONS[panelFilter.ordinal()]);
				rebuild();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				filter.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				filter.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			}
		});

		title.setText("Radius Markers");
		title.setForeground(Color.WHITE);

		titlePanel.add(title, BorderLayout.WEST);
		titlePanel.add(markerButtons, BorderLayout.EAST);

		searchPanel.add(searchBar, BorderLayout.WEST);
		searchPanel.add(filter, BorderLayout.EAST);

		northPanel.add(titlePanel, BorderLayout.NORTH);
		northPanel.add(searchPanel, BorderLayout.CENTER);

		JPanel centerPanel = new JPanel(new BorderLayout());
		centerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		markerView.setLayout(new BoxLayout(markerView, BoxLayout.Y_AXIS));
		markerView.setBackground(ColorScheme.DARK_GRAY_COLOR);

		noMarkersPanel.setVisible(false);

		markerView.add(noMarkersPanel);

		copyMarkers.setToolTipText("Export all searched or filtered markers to your clipboard");
		copyMarkers.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				copyMarkers();
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				copyMarkers.setIcon(COPY_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				copyMarkers.setIcon(COPY_ICON);
			}
		});

		pasteMarkers.setToolTipText("Import markers from your clipboard");
		pasteMarkers.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				pasteMarkers();
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				pasteMarkers.setIcon(PASTE_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				pasteMarkers.setIcon(PASTE_ICON);
			}
		});

		markerAdd.setToolTipText("Add new radius marker");
		markerAdd.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				addMarker();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				markerAdd.setIcon(ADD_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				markerAdd.setIcon(ADD_ICON);
			}
		});

		markerButtons.add(pasteMarkers);
		markerButtons.add(copyMarkers);
		markerButtons.add(markerAdd);

		centerPanel.add(markerView, BorderLayout.NORTH);

		add(northPanel, BorderLayout.NORTH);
		add(centerPanel, BorderLayout.CENTER);
	}

	public void rebuild()
	{
		markerView.removeAll();

		int regionId = client.getLocalPlayer() == null ? -1 : client.getLocalPlayer().getWorldLocation().getRegionID();

		for (final ColourRadiusMarker marker : plugin.getMarkers())
		{
			if (marker.getName().toLowerCase().contains(getSearchText().toLowerCase()) &&
				(PanelFilter.ALL.equals(panelFilter) ||
				(PanelFilter.REGION.equals(panelFilter) && marker.getWorldPoint().getRegionID() == regionId) ||
				(PanelFilter.VISIBLE.equals(panelFilter) && marker.isVisible()) ||
				(PanelFilter.INVISIBLE.equals(panelFilter) && !marker.isVisible())))
			{
				markerView.add(new RadiusMarkerPanel(plugin, config, marker));
				markerView.add(Box.createRigidArea(new Dimension(0, 10)));
			}
		}

		boolean empty = markerView.getComponentCount() == 0;
		noMarkersPanel.setContent("Radius Markers",
			"Click the '+' button to add a radius marker at the feet of your character.");
		noMarkersPanel.setVisible(empty);
		searchPanel.setVisible(!empty);
		if (empty && plugin.getMarkers().size() > 0)
		{
			noMarkersPanel.setContent("Radius Markers",
				"No radius markers are available for the current search term and/or selected filter.");
			searchPanel.setVisible(true);
		}

		markerView.add(noMarkersPanel);

		repaint();
		revalidate();
	}

	public String getSearchText()
	{
		return searchBar.getText();
	}

	private void addMarker()
	{
		noMarkersPanel.setVisible(false);
		searchPanel.setVisible(true);
		final ColourRadiusMarker marker = plugin.addMarker();
		SwingUtilities.invokeLater(() ->
		{
			if (marker != null && marker.getPanel() != null)
			{
				Rectangle markerPosition = marker.getPanel().getBounds();
				markerPosition.setLocation((int) markerPosition.getX(), (int) markerPosition.getY() - 10 -
					(int) markerPosition.getHeight() / 2 + ((Applet) client).getParent().getHeight());
				scrollRectToVisible(markerPosition);
			}
		});
	}

	private void copyMarkers()
	{
		if (plugin.copyMarkers() != null)
		{
			Toolkit.getDefaultToolkit().getSystemClipboard().setContents(new StringSelection(plugin.copyMarkers()), null);
		}
	}

	private void pasteMarkers()
	{
		final String clipboardText;
		try
		{
			clipboardText = Toolkit.getDefaultToolkit().getSystemClipboard().getData(DataFlavor.stringFlavor).toString();
		}
		catch (IOException | UnsupportedFlavorException ignore)
		{
			return;
		}

		if (plugin.pasteMarkers(clipboardText))
		{
			noMarkersPanel.setVisible(false);
			searchPanel.setVisible(true);
			rebuild();
		}
	}
}

package com.radiusmarkers;

import com.google.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.geom.Area;
import java.util.List;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Point;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.worldmap.WorldMap;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.worldmap.WorldMapOverlay;

class RadiusMarkerMapOverlay extends Overlay
{
	private final Client client;
	private final RadiusMarkerConfig config;
	private final RadiusMarkerPlugin plugin;

	@Inject
	private WorldMapOverlay worldMapOverlay;

	@Inject
	RadiusMarkerMapOverlay(Client client, RadiusMarkerConfig config, RadiusMarkerPlugin plugin)
	{
		this.client = client;
		this.config = config;
		this.plugin = plugin;

		setPosition(OverlayPosition.DYNAMIC);
		setPriority(Overlay.PRIORITY_LOW);
		setLayer(OverlayLayer.MANUAL);
		drawAfterLayer(ComponentID.WORLD_MAP_MAPVIEW);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (config.showWorldMap() && client.getWidget(ComponentID.WORLD_MAP_MAPVIEW) != null)
		{
			drawWorldMap(graphics);
		}
		return null;
	}

	private void drawWorldMap(Graphics2D graphics)
	{
		final Widget worldMapView = client.getWidget(ComponentID.WORLD_MAP_MAPVIEW);
		if (worldMapView == null)
		{
			return;
		}
		final Rectangle bounds = worldMapView.getBounds();
		if (bounds == null)
		{
			return;
		}
		final Area mapClipArea = getWorldMapClipArea(bounds);

		final List<ColourRadiusMarker> markers = plugin.getMarkers();
		final List<NPC> npcs = client.getNpcs();

		for (final ColourRadiusMarker marker : markers)
		{
			if (!marker.isVisible())
			{
				continue;
			}

			final boolean excludeCorner = AttackType.MELEE.equals(marker.getAttackType());

			final WorldPoint worldPoint = marker.getWorldPoint();

			if (config.includeRetreatInteractionRange() && marker.isRetreatInteractionVisible())
			{
				drawSquare(graphics, worldPoint, marker.getRetreatInteractionColour(), mapClipArea,
					marker.getRetreatInteractionRadius(), 1, false);
			}

			if (config.includeAggressionRange() && marker.isAggressionVisible())
			{
				drawSquare(graphics, worldPoint, marker.getAggressionColour(), mapClipArea,
					marker.getAggressionRadius(), client.getNpcDefinition(marker.getNpcId()).getSize(), excludeCorner);
			}

			if (config.includeMaxRange() && marker.isMaxVisible())
			{
				drawSquare(graphics, worldPoint, marker.getMaxColour(), mapClipArea,
					marker.getMaxRadius(), 1, false);
			}

			if (config.includeWanderRange() && marker.isWanderVisible())
			{
				drawSquare(graphics, worldPoint, marker.getWanderColour(), mapClipArea,
					marker.getWanderRadius(), 1, false);
			}

			if (marker.isSpawnVisible())
			{
				drawSquare(graphics, worldPoint, marker.getSpawnColour(), mapClipArea, 0, 1, false);
			}

			for (NPC npc : npcs)
			{
				if (npc.getId() != marker.getNpcId() || plugin.exclude(npc))
				{
					continue;
				}

				final WorldPoint npcLocation = npc.getWorldLocation();
				final int size = npc.getComposition().getSize();

				if (config.includeInteractionRange() && marker.isInteractionVisible())
				{
					drawSquare(graphics, npcLocation, marker.getInteractionColour(), mapClipArea,
						marker.getInteractionRadius(), size, false);
				}

				if (config.includeHuntRange() && marker.isHuntVisible())
				{
					drawSquare(graphics, npcLocation, marker.getHuntColour(), mapClipArea,
						marker.getHuntRadius(), 1, false);
				}

				if (config.includeAttackRange() && marker.isAttackVisible())
				{
					drawSquare(graphics, npcLocation, marker.getAttackColour(), mapClipArea,
						marker.getAttackRadius(), size, excludeCorner);
				}
			}
		}
	}

	private void drawSquare(Graphics2D graphics, WorldPoint worldPoint, Color color, Area mapClipArea,
		int radius, int size, boolean excludeCorner)
	{
		final Point start = mapWorldPointToGraphicsPoint(
			worldPoint.getX() - radius, worldPoint.getY() + radius + size - 1);
		final Point end = mapWorldPointToGraphicsPoint(
			worldPoint.getX() + radius + size, worldPoint.getY() - (radius + 1));

		if (start == null || end == null)
		{
			return;
		}

		float pixelsPerTile = client.getWorldMap().getWorldMapZoom();
		final int tileSize = (int) pixelsPerTile;

		int x = start.getX();
		int y = start.getY();
		final int width = end.getX() - x - 1;
		final int height = end.getY() - y - 1;
		x = x - tileSize / 2;
		y = y - tileSize / 2 + 1;

		graphics.setColor(color);
		graphics.setClip(mapClipArea);

		Area square = new Area(new Rectangle(x, y, width, height));
		if (radius > 0 && excludeCorner)
		{
			Area corners = new Area(new Rectangle(x, y, tileSize, tileSize));
			corners.add(new Area(new Rectangle(x, y + height - tileSize, tileSize, tileSize)));
			corners.add(new Area(new Rectangle(x + width - tileSize, y, tileSize, tileSize)));
			corners.add(new Area(new Rectangle(x + width - tileSize, y + height - tileSize, tileSize, tileSize)));
			square.subtract(corners);
		}

		graphics.draw(square);
	}

	private Area getWorldMapClipArea(Rectangle baseRectangle)
	{
		final Widget overview = client.getWidget(ComponentID.WORLD_MAP_OVERVIEW_MAP);
		final Widget surfaceSelector = client.getWidget(ComponentID.WORLD_MAP_SURFACE_SELECTOR);

		Area clipArea = new Area(baseRectangle);

		if (overview != null && !overview.isHidden())
		{
			clipArea.subtract(new Area(overview.getBounds()));
		}
		if (surfaceSelector != null && !surfaceSelector.isHidden())
		{
			clipArea.subtract(new Area(surfaceSelector.getBounds()));
		}

		return clipArea;
	}

	private Point mapWorldPointToGraphicsPoint(int worldPointX, int worldPointY)
	{
		WorldMap worldMap = client.getWorldMap();

		float pixelsPerTile = worldMap.getWorldMapZoom();

		Widget map = client.getWidget(ComponentID.WORLD_MAP_MAPVIEW);
		if (map != null)
		{
			Rectangle worldMapRect = map.getBounds();

			int widthInTiles = (int) Math.ceil(worldMapRect.getWidth() / pixelsPerTile);
			int heightInTiles = (int) Math.ceil(worldMapRect.getHeight() / pixelsPerTile);

			Point worldMapPosition = worldMap.getWorldMapPosition();

			//Offset in tiles from anchor sides
			int yTileMax = worldMapPosition.getY() - heightInTiles / 2;
			int yTileOffset = (yTileMax - worldPointY - 1) * -1;
			int xTileOffset = worldPointX + widthInTiles / 2 - worldMapPosition.getX();

			int xGraphDiff = ((int) (xTileOffset * pixelsPerTile));
			int yGraphDiff = (int) (yTileOffset * pixelsPerTile);

			//Center on tile.
			yGraphDiff -= pixelsPerTile - Math.ceil(pixelsPerTile / 2);
			xGraphDiff += pixelsPerTile - Math.ceil(pixelsPerTile / 2);

			yGraphDiff = worldMapRect.height - yGraphDiff;
			yGraphDiff += (int) worldMapRect.getY();
			xGraphDiff += (int) worldMapRect.getX();

			return new Point(xGraphDiff, yGraphDiff);
		}
		return null;
	}
}

package com.radiusmarkers;

enum AttackType
{
	MELEE,
	HALBERD,
	MAGIC,
	RANGED
}

package com.radiusmarkers;

import java.awt.Color;
import lombok.Value;

/**
 * Used for serialization of radius markers.
 */
@Value
class RadiusMarker
{
	long id;

	String name;
	boolean visible;
	boolean collapsed;

	int z;

	int spawnX;
	int spawnY;
	Color spawnColour;
	boolean spawnVisible;

	int wanderRadius;
	Color wanderColour;
	boolean wanderVisible;

	int maxRadius;
	Color maxColour;
	boolean maxVisible;

	Color aggressionColour;
	boolean aggressionVisible;

	Color retreatInteractionColour;
	boolean retreatInteractionVisible;

	int npcId;

	int attackRadius;
	Color attackColour;
	AttackType attackType;
	boolean attackVisible;

	int huntRadius;
	Color huntColour;
	boolean huntVisible;

	int interactionRadius;
	Color interactionColour;
	boolean interactionVisible;

	public static boolean isInvalid(RadiusMarker marker)
	{
		return marker == null
			|| marker.id <= 0
			|| marker.name == null
			|| marker.spawnColour == null
			|| marker.wanderColour == null
			|| marker.maxColour == null
			|| marker.aggressionColour == null
			|| marker.retreatInteractionColour == null
			|| marker.attackColour == null
			|| marker.attackType == null
			|| marker.huntColour == null
			|| marker.interactionColour == null;
	}
}

