package com.coxadditions;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(CoxAdditionsPlugin.class);
		RuneLite.main(args);
	}
}
/*
 * Copyright (c) 2022, Buchus <http://github.com/MoreBuchus>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.coxadditions;

import java.util.Collections;
import java.util.Set;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.config.*;

import java.awt.*;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;

@ConfigGroup("CoxAdditions")
public interface CoxAdditionsConfig extends Config
{
	@ConfigSection(
		name = "Olm",
		description = "Olm Plugins",
		position = 0,
		closedByDefault = true
	)
	String olmSection = "olm";

	@ConfigSection(
		name = "Rooms",
		description = "Cox Room Options",
		position = 1,
		closedByDefault = true
	)
	String roomSection = "rooms";

	@ConfigSection(
		name = "Prep",
		description = "Cox Prep Options",
		position = 2,
		closedByDefault = true
	)
	String prepSection = "prep";

	@ConfigSection(
		name = "Font",
		description = "Font Options",
		position = 3,
		closedByDefault = true
	)
	String fontSection = "font";

	//------------------------------------------------------------//
	// Olm Section
	//------------------------------------------------------------//
	@ConfigItem(
		name = "Olm Side Highlight",
		keyName = "olmSide",
		description = "Highlights a tile indicating which side olm will spawn on - disappears when he pops up",
		position = 0,
		section = olmSection
	)
	default olmSideMode olmSide()
	{
		return olmSideMode.CENTER_TILE;
	}

	@ConfigItem(
		name = "Olm Side Color Mode",
		keyName = "olmSideColorMode",
		description = "Color = Olm Side Color, Phase = Color of the Olm phase (final phase is Olm Side Color)",
		position = 1,
		section = olmSection
	)
	default olmSideColorMode olmSideColorMode()
	{
		return olmSideColorMode.COLOR;
	}

	@Alpha
	@ConfigItem(
		name = "Olm Side Color",
		keyName = "olmSideColor",
		description = "Configures the color of the Olm side highlight",
		position = 2,
		section = olmSection
	)
	default Color olmSideColor()
	{
		return Color.RED;
	}

	@ConfigItem(
		name = "Olm Hands Health",
		keyName = "olmHandsHealth",
		description = "Puts an overlay on Olm's hands showing their current HP",
		position = 3,
		section = olmSection
	)
	default olmHandsHealthMode olmHandsHealth()
	{
		return olmHandsHealthMode.OFF;
	}

	@ConfigItem(
		name = "Replace Olm Orbs",
		keyName = "replaceOrbs",
		description = "Replaces Olm orbs with Warden attacks.",
		position = 4,
		section = olmSection
	)
	default boolean replaceOrbs()
	{
		return false;
	}

	@ConfigItem(
		name = "—————— Phase ——————",
		keyName = "olm divider",
		description = "",
		position = 5,
		section = olmSection
	)
	void olmDivider();

	@ConfigItem(
		name = "Olm Phase Highlight",
		keyName = "olmPhaseHighlight",
		description = "Highlights Olm head the color of the phase indicated in the chat box (Red = Flame, Green = Acid, Purple = Crystal)",
		position = 6,
		section = olmSection
	)
	default boolean olmPhaseHighlight()
	{
		return false;
	}

	@ConfigItem(
		name = "Show Phase Panel",
		keyName = "olmPhasePanel",
		description = "Displays Olm phase in an infobox",
		position = 7,
		section = olmSection
	)
	default boolean olmPhasePanel()
	{
		return false;
	}

	@Alpha
	@ConfigItem(
		name = "Final Phase Color",
		keyName = "olmHighlightColor",
		description = "Configures the color of the Olm phase highlight",
		position = 8,
		section = olmSection
	)
	default Color olmHighlightColor()
	{
		return Color.CYAN;
	}

	@Range(max = 255)
	@ConfigItem(
		name = "Olm Phase Fill Opacity",
		keyName = "olmHighlightFill",
		description = "Highlight fill opacity for Olm phase highlight",
		position = 9,
		section = olmSection
	)
	default int olmHighlightFill()
	{
		return 30;
	}

	@Range(min = 1, max = 5)
	@ConfigItem(
		name = "Olm Outline Width",
		keyName = "olmThiCC",
		description = "Outline width for Olm phase highlight",
		position = 10,
		section = olmSection
	)
	default double olmWidth()
	{
		return 2;
	}

	@ConfigItem(
		name = "Olm Line Type",
		keyName = "olmLines",
		description = "Sets the tile outline to regular, dashed, or corners only for Olm",
		position = 11,
		section = olmSection
	)
	default lineType olmLines()
	{
		return lineType.REG;
	}

	//------------------------------------------------------------//
	// Room Section
	//------------------------------------------------------------//
	@ConfigItem(
		name = "Instance Timer",
		keyName = "instanceTimer",
		description = "Instance timer for starting a raid.",
		position = 0,
		section = roomSection
	)
	default instanceTimerMode instanceTimer()
	{
		return instanceTimerMode.OVERHEAD;
	}

	@ConfigItem(
		name = "Left Click Leave CC",
		keyName = "leftClickLeave",
		description = "Left click leave corp simulator",
		position = 1,
		section = roomSection
	)
	default boolean leftClickLeave()
	{
		return false;
	}

	@ConfigItem(
		name = "CC Warning",
		keyName = "ccWarning",
		description = "Highlights the entrance to CoX. Red = not in a CC, Yellow = in a CC, but no party made.",
		position = 2,
		section = roomSection
	)
	default boolean ccWarning()
	{
		return false;
	}

	@ConfigItem(
		name = "Hotkey",
		keyName = "hotkey",
		description = "Configures the hotkey used for hotkey configs in Cox Additions",
		position = 3,
		section = roomSection
	)
	default Keybind hotkey()
	{
		return new Keybind(KeyEvent.VK_CONTROL, InputEvent.CTRL_DOWN_MASK);
	}

	@ConfigItem(
		name = "Hotkey Swap Private Chest",
		keyName = "hotkeySwapBank",
		description = "Switches your CoX chest from shared to private when holding the hotkey",
		position = 4,
		section = roomSection
	)
	default boolean hotkeySwapBank()
	{
		return false;
	}

	@ConfigItem(
		name = "Prayer Enh. Timer",
		keyName = "detailedPrayerEnhance",
		description = "Displays a detailed prayer enhance timer in CoX",
		position = 5,
		section = roomSection
	)
	default enhanceMode detailedPrayerEnhance()
	{
		return enhanceMode.OFF;
	}

	@ConfigItem(
		name = "Raids Pots Status Overlay",
		keyName = "raidsPotsStatusOverlay",
		description = "Displays how many overload and enhance ticks each player has left. Must be in party to see other players",
		position = 6,
		section = roomSection
	)
	default boolean raidsPotsStatusOverlay()
	{
		return false;
	}

	@ConfigItem(
		name = "Pots Height",
		keyName = "raidsPotsHeight",
		description = "The height at which to display the Raids Pots Status Overlay",
		position = 7,
		section = roomSection
	)
	default RaidsPotsLoc raidsPotsHeight()
	{
		return RaidsPotsLoc.CENTER;
	}

	@ConfigItem(
		name = "Raids Pots Icon Size",
		keyName = "raidsPotsIconSize",
		description = "Changes the size of the raids pots icon",
		position = 8,
		section = roomSection
	)
	default int raidsPotsIconSize()
	{
		return 15;
	}

	@ConfigItem(
		name = "Anti-Aliasing",
		keyName = "antiAlias",
		description = "Turns on anti-aliasing for all overlays. Makes them smoother.",
		position = 9,
		section = roomSection
	)
	default boolean antiAlias()
	{
		return true;
	}

	@ConfigItem(
		name = "—————— True Tile ——————",
		keyName = "room divider",
		description = "",
		position = 10,
		section = roomSection
	)
	void roomDivider();

	@ConfigItem(
		name = "True Location List",
		keyName = "tlList",
		description = "NPC's in this list will be highlighted with true location. ONLY works with Cox bosses",
		position = 11,
		section = roomSection
	)
	default String tlList()
	{
		return "";
	}

	@Range(min = 1, max = 5)
	@ConfigItem(
		name = "True Location Width",
		keyName = "tlThiCC",
		description = "Outline width for true location highlight",
		position = 12,
		section = roomSection
	)
	default double tlThiCC()
	{
		return 2;
	}

	@Alpha
	@ConfigItem(
		name = "True Location Color",
		keyName = "tlColor",
		description = "Highlight color for true location",
		position = 13,
		section = roomSection
	)
	default Color tlColor()
	{
		return new Color(207, 138, 253, 255);
	}

	@Alpha
	@ConfigItem(
		name = "True Location Fill Color",
		keyName = "tlFillColor",
		description = "Fill color for true location",
		position = 14,
		section = roomSection
	)
	default Color tlFillColor()
	{
		return new Color(207, 138, 253, 30);
	}

	@ConfigItem(
		name = "True Tile Line Type",
		keyName = "tileLines",
		description = "Sets the true tile outline to regular, dashed, or corners only",
		position = 15,
		section = roomSection
	)
	default lineType tileLines()
	{
		return lineType.REG;
	}

	@ConfigItem(
		name = "—————— Puzzle Rooms ——————",
		keyName = "puzzle divider",
		description = "",
		position = 16,
		section = roomSection
	)
	void puzzleDivider();

	@ConfigItem(
		keyName = "chestGroupsHighlight",
		name = "Highlight Grub Chests",
		description = "CoX CM ONLY - Highlights groups of 4 chests",
		position = 17,
		section = roomSection
	)
	default Set<HighlightChestGroups> chestGroupsHighlight()
	{
		return Collections.emptySet();
	}

	@ConfigItem(
		keyName = "chestGroupsHighlightStyle",
		name = "Chest Highlight Style",
		description = "Selects the highlight style for 'Highlight Grub Chests'",
		position = 18,
		section = roomSection
	)
	default GrubChestStyle chestGroupsHighlightStyle()
	{
		return GrubChestStyle.HULL;
	}

	@ConfigItem(
		keyName = "grubsInfobox",
		name = "Grubs Counter",
		description = "Displays an infobox showing the total amount of cavern grubs collected. Works with party",
		position = 19,
		section = roomSection
	)
	default grubsMode grubsInfobox()
	{
		return grubsMode.OFF;
	}

	@ConfigItem(
		keyName = "grubsAmount",
		name = "Grubs Amount",
		description = "Set to the amount of grubs you/your team want to collect. The cavern grub counter's text will turn green when this number is reached.",
		position = 20,
		section = roomSection
	)
	default int grubsAmount()
	{
		return 30;
	}

	@ConfigItem(
		name = "Hotkey Swap Smash",
		keyName = "hotkeySwapSmash",
		description = "Switches attack and smash when holding the hotkey",
		position = 21,
		section = roomSection
	)
	default boolean hotkeySwapSmash()
	{
		return false;
	}

	@ConfigItem(
		keyName = "iceDemonHp",
		name = "Ice Demon HP",
		description = "Displays Ice Demon HP percent while lighting kindling",
		position = 22,
		section = roomSection
	)
	default boolean iceDemonHp()
	{
		return true;
	}

	@ConfigItem(
		keyName = "swapCoXKeystone",
		name = "Left Click Drop Keystone",
		description = "swaps use with drop for the keystone crystal at tightrope",
		position = 23,
		section = roomSection
	)
	default boolean swapCoXKeystone()
	{
		return false;
	}

	@ConfigItem(
		name = "—————— Combat Rooms ——————",
		keyName = "combat divider",
		description = "",
		position = 24,
		section = roomSection
	)
	void combatDivider();

	@ConfigItem(
		name = "Small Muttadile HP",
		keyName = "smallMuttaHp",
		description = "Displays the health percentage of small Muttadile while meat tree is alive",
		position = 25,
		section = roomSection
	)
	default boolean smallMuttaHp()
	{
		return true;
	}

	@ConfigItem(
		name = "Big Muttadile HP",
		keyName = "bigMuttaHp",
		description = "Displays the health percentage of big Muttadile after the small Muttadile is dead",
		position = 26,
		section = roomSection
	)
	default boolean bigMuttaHp()
	{
		return true;
	}

	@ConfigItem(
		name = "Vanguard HP Infobox",
		keyName = "vangInfobox",
		description = "Displays the hp left on each vanguard",
		position = 27,
		section = roomSection
	)
	default boolean vangInfobox()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showPanel",
		name = "Vanguard Overloads Overlay",
		description = "Shows how many Overloads have been received from Vanguards. Works with party.",
		position = 28,
		section = roomSection
	)
	default boolean showPanel()
	{
		return true;
	}

	@ConfigItem(
		keyName = "overloadChatMessage",
		name = "Overload Dropped Chat Message",
		description = "Prints a chat message when a player receives an Overload from Vanguards. Works with party.",
		position = 29,
		section = roomSection
	)
	default boolean overloadChatMessage()
	{
		return true;
	}

	//------------------------------------------------------------//
	// Prep Section
	//------------------------------------------------------------//
	@ConfigItem(
		name = "CoX Herb Timer",
		keyName = "coxHerbTimer",
		description = "Displays a timer for herb growth",
		position = 1,
		section = prepSection)
	default CoXHerbTimerMode coxHerbTimer()
	{
		return CoXHerbTimerMode.OFF;
	}

	@Alpha
	@ConfigItem(
		name = "CoX Herb Timer Color",
		keyName = "coxHerbTimerColor",
		description = "Sets color of CoX herb timer",
		position = 2,
		section = prepSection)
	default Color coxHerbTimerColor()
	{
		return Color.YELLOW;
	}

	@Range(min = 10, max = 30)
	@ConfigItem(
		name = "CoX Herb Timer Size",
		keyName = "coxHerbTimerSize",
		description = "Sets the size of the CoX herb timer",
		position = 3,
		section = prepSection)
	default int coxHerbTimerSize()
	{
		return 20;
	}

	@ConfigItem(
		name = "—————— Prep ——————",
		keyName = "prep divider",
		description = "",
		position = 4,
		section = prepSection
	)
	void prepDivider();

	@Range(min = 0)
	@ConfigItem(
		keyName = "brews",
		name = "Xeric's Aids",
		description = "How many Xeric's Aids your team wants to make",
		position = 5,
		section = prepSection
	)
	default int brews() {
		return 0;
	}

	@Range(min = 0)
	@ConfigItem(
		keyName = "revites",
		name = "Revites",
		description = "How many Revites your team wants to make",
		position = 6,
		section = prepSection
	)
	default int revites() {
		return 0;
	}

	@Range(min = 0)
	@ConfigItem(
		keyName = "enhances",
		name = "Prayer Enhances",
		description = "How many Prayer Enhances your team wants to make",
		position = 7,
		section = prepSection
	)
	default int enhances() {
		return 0;
	}

	@Range(min = 0)
	@ConfigItem(
		keyName = "overloads",
		name = "Overloads",
		description = "How many Overloads your team wants to make",
		position = 8,
		section = prepSection
	)
	default int overloads() {
		return 0;
	}

	@Range(min = 0)
	@ConfigItem(
		keyName = "extraNox",
		name = "Extra Nox",
		description = "How many extra Noxifer you want to pick",
		position = 9,
		section = prepSection
	)
	default int extraNox() {
		return 0;
	}

	@ConfigItem(
		keyName = "showSecondaries",
		name = "Show Secondaries",
		description = "Toggle whether or not to show secondaries overlay in scavs",
		position = 10,
		section = prepSection
	)
	default boolean showSecondaries() {
		return false;
	}

	@ConfigItem(
		keyName = "showPots",
		name = "Show Pots Made",
		description = "Toggle whether or not to show how many pots you have made in prep",
		position = 11,
		section = prepSection
	)
	default boolean showPots() {
		return false;
	}

	@ConfigItem(
		name = "—————— Chest ——————",
		keyName = "chest divider",
		description = "",
		position = 12,
		section = prepSection
	)
	void bankDivider();

	@ConfigItem(
		name = "Highlight Chest Mode",
		keyName = "highlightChest",
		description = "Highlight items in your private chest based off the lists",
		position = 13,
		section = prepSection
	)
	default HighlightChestMode highlightChest()
	{
		return HighlightChestMode.OFF;
	}

	@ConfigItem(
		name = "Highlight Private Chest Items 1",
		keyName = "highlightChestItems",
		description = "Highlights items in the list in the storage chest. Can be names or ids.",
		position = 14,
		section = prepSection
	)
	default String highlightChestItems()
	{
		return "";
	}

	@Alpha
	@ConfigItem(
		name = "Chest Items Color 1",
		keyName = "highlightChestItemsColor",
		description = "Sets color of highlight chest items",
		position = 15,
		section = prepSection
	)
	default Color highlightChestItemsColor()
	{
		return Color.WHITE;
	}

	@ConfigItem(
		name = "Highlight Private Chest Items 2",
		keyName = "highlightChestItems2",
		description = "Highlights items in the list in the storage chest. Can be names or ids.",
		position = 16,
		section = prepSection
	)
	default String highlightChestItems2()
	{
		return "";
	}

	@Alpha
	@ConfigItem(
		name = "Chest Items Color 2",
		keyName = "highlightChestItemsColor2",
		description = "Sets color of highlight chest items",
		position = 17,
		section = prepSection)
	default Color highlightChestItemsColor2()
	{
		return Color.WHITE;
	}

	//------------------------------------------------------------//
	// Font Section
	//------------------------------------------------------------//
	@ConfigItem(
		name = "Overlay Font Type",
		keyName = "overlayFontType",
		description = "",
		position = 0,
		section = fontSection
	)
	default FontType overlayFontType()
	{
		return FontType.BOLD;
	}

	@ConfigItem(
		name = "Overlay Font Name",
		keyName = "overlayFontName",
		description = "Custom font override for overlays",
		position = 1,
		section = fontSection
	)
	default String overlayFontName()
	{
		return "";
	}

	@ConfigItem(
		name = "Overlay Font Size",
		keyName = "overlayFontSize",
		description = "",
		position = 2,
		section = fontSection
	)
	default int overlayFontSize()
	{
		return 11;
	}

	@ConfigItem(
		name = "Overlay Font Weight",
		keyName = "overlayFontWeight",
		description = "Sets the custom font weight for overlays",
		position = 3,
		section = fontSection
	)
	default FontWeight overlayFontWeight()
	{
		return FontWeight.PLAIN;
	}

	@ConfigItem(
		name = "Overlay Font Background",
		keyName = "overlayFontBackground",
		description = "Puts an outline, shadow, or nothing behind font overlays",
		position = 4,
		section = fontSection
	)
	default background overlayFontBackground()
	{
		return background.SHADOW;
	}

	@ConfigItem(
		name = "—————— Panel ——————",
		keyName = "panel divider",
		description = "",
		position = 5,
		section = fontSection
	)
	void panelDivider();

	@ConfigItem(
		name = "Panel Font Type",
		keyName = "panelFontType",
		description = "",
		position = 6,
		section = fontSection
	)
	default FontType panelFontType()
	{
		return FontType.REGULAR;
	}

	@ConfigItem(
		name = "Panel Font Name",
		keyName = "panelFontName",
		description = "Custom font override for panels/infoboxes",
		position = 7,
		section = fontSection
	)
	default String panelFontName()
	{
		return "";
	}

	@ConfigItem(
		name = "Panel Font Size",
		keyName = "panelFontSize",
		description = "",
		position = 8,
		section = fontSection
	)
	default int panelFontSize()
	{
		return 11;
	}

	@ConfigItem(
		name = "Panel Font Weight",
		keyName = "panelFontWeight",
		description = "Sets the custom font weight for panels/infoboxes",
		position = 9,
		section = fontSection
	)
	default FontWeight panelFontWeight()
	{
		return FontWeight.PLAIN;
	}

	//------------------------------------------------------------//
	// Enums
	//------------------------------------------------------------//
	enum CoXHerbTimerMode
	{
		OFF,
		TEXT,
		PIE
	}

	enum HighlightChestMode
	{
		OFF,
		UNDERLINE,
		OUTLINE
	}

	enum instanceTimerMode
	{
		OFF,
		OVERHEAD,
		INFOBOX
	}

	enum enhanceMode
	{
		OFF,
		TICKS,
		REGEN_CYCLE
	}

	enum olmSideMode
	{
		OFF,
		CENTER_TILE,
		SIZE
	}

	enum olmSideColorMode
	{
		COLOR,
		PHASE
	}

	enum olmHandsHealthMode
	{
		OFF,
		INFOBOX,
		OVERLAY
	}

	enum GrubChestStyle
	{
		HULL,
		OUTLINE,
		TILE,
		CLICKBOX,
		CORNERS
	}

	@Getter
	@RequiredArgsConstructor
	enum HighlightChestGroups
	{
		CHEST_GROUPS_1("Groups 1-4"),
		CHEST_GROUPS_2("Groups 5-7"),
		CHEST_GROUPS_3("Groups 8-10");

		@Getter
		private final String group;

		@Override
		public String toString()
		{
			return group;
		}
	}

	@Getter
	@RequiredArgsConstructor
	enum grubsMode
	{
		OFF("Off"),
		THIEVING("Thieving"),
		BOTH("Thieving/Prep");

		private final String name;

		@Override
		public String toString()
		{
			return name;
		}
	}

	@Getter
	@RequiredArgsConstructor
	enum lineType
	{
		REG("Regular"),
		DASH("Dashed"),
		CORNER("Corners");

		@Getter
		private final String group;

		@Override
		public String toString()
		{
			return group;
		}
	}

	@Getter
	@RequiredArgsConstructor
	enum RaidsPotsLoc
	{
		PRAYER("Above Prayer Icon"),
		HEAD("Head of Player"),
		CENTER("Center of Player"),
		FEET("Bottom of Player");

		@Getter
		private final String location;

		@Override
		public String toString()
		{
			return location;
		}
	}

	@Getter
	@RequiredArgsConstructor
	enum FontType
	{
		SMALL("RS Small"),
		REGULAR("RS Regular"),
		BOLD("RS Bold"),
		CUSTOM("Custom");

		private final String name;

		@Override
		public String toString()
		{
			return name;
		}
	}

	enum FontWeight
	{
		PLAIN(Font.PLAIN),
		BOLD(Font.BOLD),
		ITALIC(Font.ITALIC),
		BOLD_ITALIC(Font.BOLD | Font.ITALIC);

		@Getter
		private final int weight;

		FontWeight(int i)
		{
			weight = i;
		}
	}

	@Getter
	@RequiredArgsConstructor
	enum background
	{
		OFF("None"),
		SHADOW("Shadow"),
		OUTLINE("Outline");

		@Getter
		private final String group;

		@Override
		public String toString()
		{
			return group;
		}
	}
}

package com.coxadditions;

import java.awt.Color;
import lombok.Getter;
import net.runelite.client.util.ColorUtil;

public enum ChestGroup
{
	//Green
	GROUP_1_1(48, 27, 1, ColorUtil.fromHex("#FF25C54F")),
	GROUP_1_2(47, 26, 1, ColorUtil.fromHex("#FF25C54F")),
	GROUP_1_3(49, 24, 1, ColorUtil.fromHex("#FF25C54F")),
	GROUP_1_4(48, 22, 1, ColorUtil.fromHex("#FF25C54F")),

	//White
	GROUP_2_1(48, 21, 2, ColorUtil.fromHex("#FFE0E0E0")),
	GROUP_2_2(50, 20, 2, ColorUtil.fromHex("#FFE0E0E0")),
	GROUP_2_3(50, 17, 2, ColorUtil.fromHex("#FFE0E0E0")),
	GROUP_2_4(47, 18, 2, ColorUtil.fromHex("#FFE0E0E0")),

	//Red
	GROUP_3_1(51, 26, 3, ColorUtil.fromHex("#FFE03C31")),
	GROUP_3_2(53, 25, 3, ColorUtil.fromHex("#FFE03C31")),
	GROUP_3_3(50, 24, 3, ColorUtil.fromHex("#FFE03C31")),
	GROUP_3_4(52, 21, 3, ColorUtil.fromHex("#FFE03C31")),

	//Yellow
	GROUP_4_1(54, 24, 4, ColorUtil.fromHex("#FFF1FF00")),
	GROUP_4_2(56, 24, 4, ColorUtil.fromHex("#FFF1FF00")),
	GROUP_4_3(57, 23, 4, ColorUtil.fromHex("#FFF1FF00")),
	GROUP_4_4(55, 22, 4, ColorUtil.fromHex("#FFF1FF00")),

	//Purple
	GROUP_5_1(50, 15, 5, ColorUtil.fromHex("#FF6A3DFF")),
	GROUP_5_2(54, 14, 5, ColorUtil.fromHex("#FF6A3DFF")),
	GROUP_5_3(52, 12, 5, ColorUtil.fromHex("#FF6A3DFF")),
	GROUP_5_4(50, 13, 5, ColorUtil.fromHex("#FF6A3DFF")),

	//Mint
	GROUP_6_1(46, 11, 6, ColorUtil.fromHex("#FF00FF9A")),
	GROUP_6_2(48, 11, 6, ColorUtil.fromHex("#FF00FF9A")),
	GROUP_6_3(51, 10, 6, ColorUtil.fromHex("#FF00FF9A")),
	GROUP_6_4(49, 8, 6, ColorUtil.fromHex("#FF00FF9A")),
	GROUP_6_5(46, 9, 6, ColorUtil.fromHex("#FF00FF9A")),

	//Light blue
	GROUP_7_1(55, 13, 7, ColorUtil.fromHex("#FF12C1E5")),
	GROUP_7_2(56, 11, 7, ColorUtil.fromHex("#FF12C1E5")),
	GROUP_7_3(54, 10, 7, ColorUtil.fromHex("#FF12C1E5")),
	GROUP_7_4(56, 9, 7, ColorUtil.fromHex("#FF12C1E5")),

	//Orange
	GROUP_8_1(47, 7, 8, ColorUtil.fromHex("#FFFF9000")),
	GROUP_8_2(49, 7, 8, ColorUtil.fromHex("#FFFF9000")),
	GROUP_8_3(47, 5, 8, ColorUtil.fromHex("#FFFF9000")),
	GROUP_8_4(49, 4, 8, ColorUtil.fromHex("#FFFF9000")),

	//Pink
	GROUP_9_1(58, 14, 9, ColorUtil.fromHex("#FFFF4398")),
	GROUP_9_2(60, 14, 9, ColorUtil.fromHex("#FFFF4398")),
	GROUP_9_3(61, 12, 9, ColorUtil.fromHex("#FFFF4398")),
	GROUP_9_4(60, 11, 9, ColorUtil.fromHex("#FFFF4398")),
	GROUP_9_5(57, 11, 9, ColorUtil.fromHex("#FFFF4398")),
	GROUP_9_6(60, 9, 9, ColorUtil.fromHex("#FFFF4398")),
	GROUP_9_7(58, 8, 9, ColorUtil.fromHex("#FFFF4398")),

	//Magenta
	GROUP_10_1(56, 8, 10, ColorUtil.fromHex("#FFB700FF")),
	GROUP_10_2(57, 6, 10, ColorUtil.fromHex("#FFB700FF")),
	GROUP_10_3(54, 6, 10, ColorUtil.fromHex("#FFB700FF")),
	GROUP_10_4(55, 4, 10, ColorUtil.fromHex("#FFB700FF"));

	@Getter
	private final int regionX;
	@Getter
	private final int regionY;
	@Getter
	private final int group;
	@Getter
	private final Color color;

	ChestGroup(int regionX, int regionY, int group, Color color)
	{
		this.regionX = regionX;
		this.regionY = regionY;
		this.group = group;
		this.color = color;
	}
}

/*
 * Copyright (c) 2022, Buchus <http://github.com/MoreBuchus>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.coxadditions;

import com.coxadditions.overlay.CoxAdditionsOverlay;
import com.coxadditions.overlay.CoxHPOverlay;
import com.coxadditions.overlay.CoxItemOverlay;
import com.coxadditions.overlay.CoxPrepOverlay;
import com.coxadditions.overlay.InstanceTimerOverlay;
import com.coxadditions.overlay.OlmHpPanelOverlay;
import com.coxadditions.overlay.OlmPhasePanel;
import com.coxadditions.overlay.OlmSideOverlay;
import com.coxadditions.overlay.RaidsPotsStatusOverlay;
import com.coxadditions.overlay.VangPotsOverlay;
import com.coxadditions.overlay.VanguardInfoBox;
import com.coxadditions.party.PartyGrubsUpdate;
import com.coxadditions.party.PartyOverloadUpdate;
import com.coxadditions.party.PartyRaidsPotsUpdate;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ImmutableSet;
import com.google.inject.Provides;
import java.awt.Font;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.AnimationID;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.GameState;
import net.runelite.api.InstanceTemplates;
import net.runelite.api.InventoryID;
import net.runelite.api.ItemID;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;
import net.runelite.api.Player;
import net.runelite.api.Point;
import net.runelite.api.Projectile;
import net.runelite.api.Skill;
import net.runelite.api.VarPlayer;
import net.runelite.api.Varbits;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.GraphicsObjectCreated;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.NpcChanged;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.api.events.ProjectileMoved;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;
import net.runelite.client.party.PartyService;
import net.runelite.client.party.WSClient;
import net.runelite.client.party.events.UserJoin;
import net.runelite.client.party.events.UserPart;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.Text;
import javax.inject.Inject;
import java.awt.event.KeyEvent;
import java.util.*;
import java.util.function.Predicate;

@PluginDescriptor(
	name = "CoX Additions",
	description = "Additional plugins for the Chambers of Xeric",
	tags = {"xeric", "olm", "chambers", "cox", "buchus"}
)
@Slf4j
public class CoxAdditionsPlugin extends Plugin implements KeyListener
{
	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private CoxAdditionsConfig config;

	@Inject
	private ConfigManager configManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private CoxAdditionsOverlay overlay;

	@Inject
	private OlmSideOverlay olmSideOverlay;

	@Inject
	private CoxItemOverlay itemOverlay;

	@Inject
	private InstanceTimerOverlay instanceTimerOverlay;

	@Inject
	private VanguardInfoBox vanguardInfobox;

	@Inject
	private CoxHPOverlay coxHPOverlay;

	@Inject
	private OlmHpPanelOverlay olmHpPanelOverlay;

	@Inject
	private VangPotsOverlay vangPotsOverlay;

	@Inject
	private OlmPhasePanel phasePanel;

	@Inject
	private CoxPrepOverlay prepOverlay;

	@Inject
	private RaidsPotsStatusOverlay raidsPotsStatusOverlay;

	@Inject
	private InfoBoxManager infoBoxManager;

	@Inject
	private ItemManager itemManager;

	@Inject
	private EventBus eventBus;

	@Inject
	private KeyManager keyManager;

	@Inject
	private PartyService partyService;

	@Inject
	private WSClient wsClient;

	@Getter
	private final ArrayListMultimap<String, Integer> optionIndexes = ArrayListMultimap.create();

	//Prep/Farming
	@Getter
	private GameObject coxHerb1;
	@Getter
	private int coxHerbTimer1;
	@Getter
	private GameObject coxHerb2;
	@Getter
	private int coxHerbTimer2;

	@Getter
	private int totalBuchus = 0;
	@Getter
	private int totalGolpar = 0;
	@Getter
	private int totalNox = 0;

	@Getter
	private int inventoryBuchus = 0;
	@Getter
	private int inventoryGolpar = 0;
	@Getter
	private int inventoryNox = 0;

	@Getter
	private int totalBrews = 0;
	@Getter
	private int totalRevites = 0;
	@Getter
	private int totalEnhances = 0;
	@Getter
	private int totalElders = 0;
	@Getter
	private int totalTwisteds = 0;
	@Getter
	private int totalKodais = 0;
	@Getter
	private int totalOverloads = 0;

	@Getter
	private int inventoryBrews = 0;
	@Getter
	private int inventoryRevites = 0;
	@Getter
	private int inventoryEnhances = 0;
	@Getter
	private int inventoryElders = 0;
	@Getter
	private int inventoryTwisteds = 0;
	@Getter
	private int inventoryKodais = 0;
	@Getter
	private int inventoryOverloads = 0;

	@Getter
	private int pickedJuice = 0;
	@Getter
	private int pickedShrooms = 0;
	@Getter
	private int pickedCicely = 0;

	@Getter
	private boolean pickedHerb = false;
	@Getter
	private boolean potMade = false;

	//Thieving
	@Getter
	private int totalGrubs = 0;
	@Getter
	private int previousGrubs = 0;
	@Getter
	private boolean inThieving = false;
	@Getter
	private boolean inPrep = false;
	@Getter
	private GrubsInfobox grubsInfobox;

	//Prayer Enhance
	@Getter
	private boolean enhanceSipped;
	@Getter
	private int enhanceTicks = -1;
	@Getter
	private int totalEnhCycles = 0;
	@Getter
	private int maxEnhCycles = 0;
	@Getter
	private int enhRegenRate = 0;
	@Getter
	private final int enhVar = 5417;
	@Getter
	private boolean queueEnhUpdate = false;
	@Getter
	private EnhanceInfobox enhanceInfobox;

	//Overload
	@Getter
	private int overloadTicks = -1;
	@Getter
	private int totalOvlCycles = 0;
	@Getter
	private final int ovlVar = 5418;
	@Getter
	private boolean queueOvlUpdate = false;

	@Getter
	private GameState lastGS = null;

	//Party Pots
	@Getter
	private final ArrayList<RaidsPlayers> playersInParty = new ArrayList<>();

	//Instance Timer
	@Getter
	private int instanceTimer = 3;
	@Getter
	private boolean isInstanceTimerRunning = false;

	//Olm
	@Getter
	private LocalPoint olmTile = null;
	@Getter
	private String olmPhase = "";
	@Getter
	private NPC olmHead = null;
	@Getter
	private boolean olmSpawned = false;
	@Getter
	private NPC meleeHand;
	@Getter
	private NPC mageHand;
	@Getter
	private int meleeHandHp = 600;
	@Getter
	private int mageHandHp = 600;
	@Getter
	@Setter
	private int mageHandLastRatio = 100;
	@Getter
	@Setter
	private int mageHandLastHealthScale = 100;
	@Getter
	@Setter
	private int meleeHandLastRatio = 100;
	@Getter
	@Setter
	private int meleeHandLastHealthScale = 100;
	@Getter
	private final Set<Integer> orbIDs = ImmutableSet.of(1341, 1343, 1345);

	//Baby Muttadile
	@Getter
	private boolean smallMuttaAlive = false;
	@Getter
	private NPC smallMutta = null;
	@Getter
	@Setter
	private int lastRatio = 100;
	@Getter
	@Setter
	private int lastHealthScale = 100;

	//Big Muttadile
	@Getter
	private NPC bigMutta = null;
	@Getter
	@Setter
	private int bigMuttaLastRatio = 100;
	@Getter
	@Setter
	private int bigMuttaLastHealthScale = 100;

	//True Tile
	@Getter
	private final List<String> tlList = new ArrayList<>();
	@Getter
	private final List<String> bossList = Arrays.asList(
		"tekton", "jewelled crab", "scavenger beast", "ice demon", "lizardman shaman", "vanguard",
		"vespula", "deathly ranger", "deathly mage", "vasa nistirio", "skeletal mystic", "muttadile");

	//Vanguards
	@Getter
	private final int MAGE = 7529;
	@Getter
	private final int RANGE = 7528;
	@Getter
	private final int MELEE = 7527;
	@Getter
	private final int DOWN = 7526;
	@Getter
	private final ArrayList<Integer> ids = new ArrayList<>();
	@Getter
	private NPC ranger;
	@Getter
	private NPC mager;
	@Getter
	private NPC meleer;
	@Getter
	private boolean inRaid;
	@Getter
	private boolean magerFound;
	@Getter
	private boolean rangerFound;
	@Getter
	private boolean meleeFound;
	@Getter
	private int mageHP = -1;
	@Getter
	private int rangeHP = -1;
	@Getter
	private int meleeHP = -1;
	@Getter
	private float percent;
	@Getter
	private boolean inVangs;
	@Getter
	private int overloadsDropped = 0;

	//Ice Demon
	@Getter
	private NPC iceDemon = null;
	@Getter
	private boolean iceDemonActive = false;

	@Getter
	private final ArrayList<String> chestHighlightIdList = new ArrayList<>();
	@Getter
	private final ArrayList<String> chestHighlightIdList2 = new ArrayList<>();

	@Getter
	private boolean hotkeyHeld;

	@Getter
	Font overlayFont;

	@Getter
	Font panelFont;

	@Provides
	CoxAdditionsConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(CoxAdditionsConfig.class);
	}

	private void reset()
	{
		playersInParty.clear();

		coxHerb1 = null;
		coxHerbTimer1 = 11;
		coxHerb2 = null;
		coxHerbTimer2 = 11;

		totalBuchus = 0;
		totalGolpar = 0;
		totalNox = 0;

		inventoryBuchus = 0;
		inventoryGolpar = 0;
		inventoryNox = 0;

		totalBrews = 0;
		totalRevites = 0;
		totalEnhances = 0;
		totalElders = 0;
		totalTwisteds = 0;
		totalKodais = 0;
		totalOverloads = 0;

		inventoryBrews = 0;
		inventoryRevites = 0;
		inventoryEnhances = 0;
		inventoryElders = 0;
		inventoryTwisteds = 0;
		inventoryKodais = 0;
		inventoryOverloads = 0;

		pickedJuice = 0;
		pickedShrooms = 0;
		pickedCicely = 0;

		pickedHerb = false;
		potMade = false;

		totalGrubs = 0;
		previousGrubs = 0;
		inThieving = false;
		inPrep = false;

		olmTile = null;
		olmPhase = "";
		olmSpawned = false;
		olmHead = null;

		meleeHand = null;
		mageHand = null;
		meleeHandHp = 600;
		mageHandHp = 600;
		mageHandLastRatio = 100;
		mageHandLastHealthScale = 100;
		meleeHandLastRatio = 100;
		meleeHandLastHealthScale = 100;

		smallMuttaAlive = false;
		smallMutta = null;
		lastRatio = 100;
		lastHealthScale = 100;

		bigMutta = null;
		bigMuttaLastRatio = 100;
		bigMuttaLastHealthScale = 100;

		ids.add(MAGE);
		ids.add(RANGE);
		ids.add(MELEE);
		ids.add(DOWN);
		inRaid = false;
		inVangs = false;
		meleeFound = false;
		rangerFound = false;
		magerFound = false;

		iceDemon = null;
		iceDemonActive = false;

		overloadsDropped = 0;

		overlayFont = null;
		panelFont = null;

		if (enhanceInfobox != null)
		{
			infoBoxManager.removeInfoBox(enhanceInfobox);
			enhanceInfobox = null;
		}

		if (grubsInfobox != null)
		{
			infoBoxManager.removeInfoBox(grubsInfobox);
			grubsInfobox = null;
		}
	}

	@Override
	protected void startUp()
	{
		reset();

		tlList.clear();
		for (String str : config.tlList().split(","))
		{
			if (!str.trim().equals(""))
			{
				tlList.add(str.trim().toLowerCase());
			}
		}

		chestHighlightIdList.clear();
		for (String str : config.highlightChestItems().split(","))
		{
			if (!str.trim().equals(""))
			{
				try
				{
					chestHighlightIdList.add(str.trim());
				}
				catch (Exception ex)
				{
					System.out.println(ex.getMessage());
				}
			}
		}

		chestHighlightIdList2.clear();
		for (String str : config.highlightChestItems2().split(","))
		{
			if (!str.trim().equals(""))
			{
				try
				{
					chestHighlightIdList2.add(str.trim());
				}
				catch (Exception ex)
				{
					System.out.println(ex.getMessage());
				}
			}
		}

		enhanceSipped = false;
		enhanceTicks = -1;
		totalEnhCycles = 0;

		keyManager.registerKeyListener(this);
		wsClient.registerMessage(PartyOverloadUpdate.class);
		wsClient.registerMessage(PartyGrubsUpdate.class);
		wsClient.registerMessage(PartyRaidsPotsUpdate.class);
		overlayManager.add(overlay);
		overlayManager.add(olmSideOverlay);
		overlayManager.add(vanguardInfobox);
		overlayManager.add(itemOverlay);
		overlayManager.add(instanceTimerOverlay);
		overlayManager.add(coxHPOverlay);
		overlayManager.add(olmHpPanelOverlay);
		overlayManager.add(vangPotsOverlay);
		overlayManager.add(phasePanel);
		overlayManager.add(prepOverlay);
		overlayManager.add(raidsPotsStatusOverlay);
	}

	@Override
	protected void shutDown()
	{
		reset();
		eventBus.unregister(this);
		keyManager.unregisterKeyListener(this);
		wsClient.unregisterMessage(PartyOverloadUpdate.class);
		wsClient.unregisterMessage(PartyGrubsUpdate.class);
		wsClient.unregisterMessage(PartyRaidsPotsUpdate.class);
		overlayManager.remove(overlay);
		overlayManager.remove(olmSideOverlay);
		overlayManager.remove(vanguardInfobox);
		overlayManager.remove(itemOverlay);
		overlayManager.remove(instanceTimerOverlay);
		overlayManager.remove(coxHPOverlay);
		overlayManager.remove(olmHpPanelOverlay);
		overlayManager.remove(vangPotsOverlay);
		overlayManager.remove(phasePanel);
		overlayManager.remove(prepOverlay);
		overlayManager.remove(raidsPotsStatusOverlay);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged e)
	{
		if (e.getGroup().equals("CoxAdditions"))
		{
			switch (e.getKey())
			{
				case "tlList":
					tlList.clear();
					for (String str : config.tlList().split(","))
					{
						if (!str.trim().equals(""))
						{
							tlList.add(str.trim().toLowerCase());
						}
					}
					break;
				case "highlightChestItems":
					chestHighlightIdList.clear();
					for (String str : config.highlightChestItems().split(","))
					{
						if (!str.trim().equals(""))
						{
							try
							{
								chestHighlightIdList.add(str.trim());
							}
							catch (Exception ex)
							{
								System.out.println(ex.getMessage());
							}
						}
					}
					break;
				case "highlightChestItems2":
					chestHighlightIdList2.clear();
					for (String str : config.highlightChestItems2().split(","))
					{
						if (!str.trim().equals(""))
						{
							try
							{
								chestHighlightIdList2.add(str.trim());
							}
							catch (Exception ex)
							{
								System.out.println(ex.getMessage());
							}
						}
					}
					break;
				case "detailedPrayerEnhance":
					if (config.detailedPrayerEnhance() == CoxAdditionsConfig.enhanceMode.OFF && enhanceInfobox != null)
					{
						removeInfobox("Enhance");
					}
					else
					{
						addInfobox("Enhance");
					}
					break;
				case "grubsInfobox":
					if (config.grubsInfobox() == CoxAdditionsConfig.grubsMode.OFF && grubsInfobox != null)
					{
						removeInfobox("Grubs");
					}
					else
					{
						addInfobox("Grubs");
					}
					break;
				case "overlayFontType":
				case "overlayFontName":
				case "overlayFontSize":
				case "overlayFontWeight":
				case "overlayFontBackground":
					loadFont(true);
					break;
				case "panelFontType":
				case "panelFontName":
				case "panelFontSize":
				case "panelFontWeight":
					loadFont(false);
					break;
			}
		}
	}

	@Subscribe
	private void onChatMessage(ChatMessage e)
	{
		String msg = Text.standardize(e.getMessageNode().getValue());

		if (msg.equalsIgnoreCase("you have been kicked from the channel.") || msg.contains("decided to start the raid without you. sorry.")
			|| msg.equalsIgnoreCase("you are no longer eligible to lead the party.") || msg.equalsIgnoreCase("the raid has begun!"))
		{
			instanceTimer = 5;
			isInstanceTimerRunning = false;
		}
		else if (msg.equalsIgnoreCase("inviting party...") || msg.equalsIgnoreCase("your party has entered the dungeons! come and join them now."))
		{
			instanceTimer = 5;
			isInstanceTimerRunning = true;
		}
		else if (msg.equalsIgnoreCase("the great olm is giving its all. this is its final stand."))
		{
			mageHand = null;
			meleeHand = null;
		}
		else if (msg.equalsIgnoreCase("the great olm rises with the power of crystal."))
		{
			olmPhase = "Crystal";
		}
		else if (msg.equalsIgnoreCase("the great olm rises with the power of acid."))
		{
			olmPhase = "Acid";
		}
		else if (msg.equalsIgnoreCase("the great olm rises with the power of flame."))
		{
			olmPhase = "Flame";
		}
		else if (msg.startsWith("you drink some of your") && inRaid
			&& (msg.contains("overload") || msg.contains("prayer enhance")))
		{
			queueOvlUpdate = msg.contains("overload");
			queueEnhUpdate = msg.contains("prayer enhance");
		}
	}

	@Subscribe
	private void onGameTick(GameTick e)
	{
		if (inRaid)
		{
			if (coxHerb1 != null || coxHerb2 != null)
			{
				if (coxHerb1 != null)
				{
					if (coxHerbTimer1 != 0)
					{
						coxHerbTimer1--;
					}
					else
					{
						coxHerb1 = null;
					}
				}

				if (coxHerb2 != null)
				{
					if (coxHerbTimer2 != 0)
					{
						coxHerbTimer2--;
					}
					else
					{
						coxHerb2 = null;
					}
				}
			}

			List<NPC> npcs = client.getNpcs();
			inVangs = false;
			for (NPC npc : npcs)
			{
				if (!ids.contains(npc.getId()))
				{
					continue;
				}
				inVangs = true;
				int currentId = npc.getId();
				switch (currentId)
				{
					case MAGE:
						percent = (float) npc.getHealthRatio() / npc.getHealthScale() * 100;
						mageHP = (int) percent;
						mager = npc;
						break;
					case RANGE:
						percent = (float) npc.getHealthRatio() / npc.getHealthScale() * 100;
						rangeHP = (int) percent;
						ranger = npc;
						break;
					case MELEE:
						percent = (float) npc.getHealthRatio() / npc.getHealthScale() * 100;
						meleeHP = (int) percent;
						meleer = npc;
						break;
					case DOWN:
						break;
					default:
				}
			}

			if (client.getVarbitValue(enhVar) > 0)
			{
				addInfobox("Enhance");
			}
			else if (client.getVarbitValue(enhVar) == 0)
			{
				removeInfobox("Enhance");
			}
			enhanceTicks--;
			overloadTicks--;

			if (client.getLocalPlayer() != null)
			{
				if (partyService.isInParty() && partyService.getLocalMember() != null)
				{
					//Handle pot data on game tick to not flood party with updates every game tick
					for (RaidsPlayers raider : playersInParty)
					{
						if (raider.isOvlActive())
						{
							raider.updatePotStatus("OVL", raider.getOvlTicks() - 1);
							if (raider.getOvlTicks() < 0)
							{
								raider.setOvlActive(false);
							}
						}

						if (raider.isEnhActive())
						{
							raider.updatePotStatus("ENH", raider.getEnhTicks() - 1);
							if (raider.getEnhTicks() < 0)
							{
								raider.setEnhActive(false);
							}
						}
					}
					playersInParty.removeIf(p -> !p.isEnhActive() && !p.isOvlActive());
				}
				else if (!partyService.isInParty() && !playersInParty.isEmpty())
				{
					playersInParty.clear();
				}
			}

			inPrep = room() == InstanceTemplates.RAIDS_FARMING || room() == InstanceTemplates.RAIDS_FARMING2;
			inThieving = room() == InstanceTemplates.RAIDS_THIEVING;
			if ((config.grubsInfobox() == CoxAdditionsConfig.grubsMode.THIEVING && inThieving) ||
				(config.grubsInfobox() == CoxAdditionsConfig.grubsMode.BOTH && (inThieving || inPrep)))
			{
				addInfobox("Grubs");
			}
			else
			{
				removeInfobox("Grubs");
			}
		}

		if (isInstanceTimerRunning)
		{
			instanceTimer--;
			if (instanceTimer < 0)
			{
				instanceTimer = 3;
			}
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged e)
	{
		if (e.getGameState() == GameState.LOGGING_IN)
		{
			lastGS = e.getGameState();
		}
		else if (e.getGameState() == GameState.LOGGED_IN && lastGS == GameState.LOGGING_IN)
		{
			queueOvlUpdate = true;
			queueEnhUpdate = true;
			lastGS = e.getGameState();
		}
	}

	public void sendPotStatusInfo(int ticks, String pot)
	{
		if (partyService.isInParty() && partyService.getLocalMember() != null)
		{
			partyService.send(new PartyRaidsPotsUpdate(ticks, pot));
		}
	}

	//Add/Update party members to/in the list
	private void addRaidersInParty(long memberID, String memberName, int ticks, String pot)
	{
		if (!memberName.equals("<unknown>"))
		{
			if (playersInParty.stream().noneMatch(p -> p.getId() == memberID && p.getPlayer().equals(memberName)))
			{
				RaidsPlayers raider = new RaidsPlayers(memberName, memberID);
				raider.updatePotStatus(pot, ticks);
				playersInParty.add(raider);
			}
			else
			{
				playersInParty.stream().filter(p -> p.getId() == memberID && p.getPlayer().equals(memberName)).findFirst().ifPresent(rp -> rp.updatePotStatus(pot, ticks));
			}
		}
	}

	@Subscribe
	public void onPartyRaidsPotsUpdate(PartyRaidsPotsUpdate e)
	{
		//Only update for players that are not the local player
		if (partyService.getLocalMember().getMemberId() != e.getMemberId())
		{
			String name = partyService.getMemberById(e.getMemberId()).getDisplayName();
			if (name != null)
			{
				if (e.getTicks() == -73 && e.getPot().equals("DEAD"))
				{
					playersInParty.removeIf(p -> p.getId() == e.getMemberId());
				}
				else
				{
					addRaidersInParty(e.getMemberId(), name, e.getTicks(), e.getPot());
				}
			}
		}
	}

	@Subscribe
	public void onUserJoin(final UserJoin e)
	{
		if (inRaid)
		{
			queueOvlUpdate = overloadTicks > 0;
			queueEnhUpdate = enhanceTicks > 0;
		}
	}

	@Subscribe
	public void onUserPart(final UserPart e)
	{
		//Name is unknown if the player is not logged in -> use ID
		playersInParty.removeIf(p -> p.getId() == e.getMemberId());
	}

	@Subscribe
	private void onGameObjectSpawned(GameObjectSpawned e)
	{
		GameObject obj = e.getGameObject();
		if (inRaid)
		{
			if (obj.getId() >= 29997 && obj.getId() <= 29999)
			{
				if (coxHerb1 == null)
				{
					coxHerb1 = obj;
					coxHerbTimer1 = 11;
				}
				else
				{
					coxHerb2 = obj;
					coxHerbTimer2 = 11;
				}
			}
			else if (obj.getId() >= 30000 && obj.getId() <= 30008)
			{
				if (coxHerb1 == null)
				{
					coxHerb1 = obj;
					coxHerbTimer1 = 11;
				}
				else
				{
					coxHerb2 = obj;
					coxHerbTimer2 = 11;
				}
			}
			else if (obj.getId() == 29745) //Chest with Grubs
			{
				Point p = e.getTile().getSceneLocation();
				int angle = obj.getOrientation() >> 9;
				int chestX = p.getX() + ((angle == 1) ? -1 : ((angle == 3) ? 1 : 0));
				int chestY = p.getY() + ((angle == 0) ? -1 : ((angle == 2) ? 1 : 0));

				if (client.getLocalPlayer() != null)
				{
					WorldPoint wp = client.getLocalPlayer().getWorldLocation();

					if (wp.getX() - client.getBaseX() == chestX && wp.getY() - client.getBaseY() == chestY)
					{
						int grubs = client.getItemContainer(InventoryID.INVENTORY).count(ItemID.CAVERN_GRUBS);

						int delta = grubs - previousGrubs;
						totalGrubs += delta;
						previousGrubs = grubs;

						if (partyService.isInParty() && delta > 0)
						{
							partyService.send(new PartyGrubsUpdate(client.getLocalPlayer().getName(), client.getWorld(), delta));
						}
					}
				}
			}
		}
	}

	@Subscribe
	private void onGameObjectDespawned(GameObjectDespawned e)
	{
		GameObject obj = e.getGameObject();
		if (inRaid)
		{
			if (coxHerb1 != null || coxHerb2 != null)
			{
				if (obj.getId() >= 29997 && obj.getId() <= 30008)
				{
					if (coxHerb1 != null)
					{
						if (obj.getId() == coxHerb1.getId())
						{
							coxHerb1 = null;
						}
						else
						{
							coxHerb2 = null;
						}
					}
					else
					{
						coxHerb2 = null;
					}
				}
			}
		}
	}

	@Subscribe
	public void onAnimationChanged(AnimationChanged e)
	{
		if (e.getActor().getName() != null && client.getLocalPlayer() != null && e.getActor().getName().equals(client.getLocalPlayer().getName()) && inRaid)
		{
			pickedHerb = e.getActor().getAnimation() == AnimationID.FARMING_HARVEST_HERB;
			potMade = e.getActor().getAnimation() == AnimationID.HERBLORE_POTIONMAKING;
		}
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged e)
	{
		if (inRaid)
		{
			int nox = e.getItemContainer().count(ItemID.GRIMY_NOXIFER) + e.getItemContainer().count(ItemID.NOXIFER);
			int golpar = e.getItemContainer().count(ItemID.GRIMY_GOLPAR) + e.getItemContainer().count(ItemID.GOLPAR);
			int buchus = e.getItemContainer().count(ItemID.GRIMY_BUCHU_LEAF) + e.getItemContainer().count(ItemID.BUCHU_LEAF);
			int brews = e.getItemContainer().count(ItemID.XERICS_AID_4_20984);
			int revites = e.getItemContainer().count(ItemID.REVITALISATION_4_20960);
			int enhances = e.getItemContainer().count(ItemID.PRAYER_ENHANCE_4_20972);
			int elders = e.getItemContainer().count(ItemID.ELDER_4_20924);
			int twisteds = e.getItemContainer().count(ItemID.TWISTED_4_20936);
			int kodais = e.getItemContainer().count(ItemID.KODAI_4_20948);
			int overloads = e.getItemContainer().count(ItemID.OVERLOAD_4_20996);
			int grubs = e.getItemContainer().count(ItemID.CAVERN_GRUBS);

			if (e.getContainerId() == 93) //Inventory
			{
				if (pickedHerb)
				{
					if (nox > inventoryNox)
					{
						totalNox++;
					}
					if (golpar > inventoryGolpar)
					{
						totalGolpar++;
					}
					if (buchus > inventoryBuchus)
					{
						totalBuchus++;
					}
				}

				if (potMade)
				{
					if (brews > inventoryBrews)
					{
						totalBrews++;
					}
					if (revites > inventoryRevites)
					{
						totalRevites++;
					}
					if (enhances > inventoryEnhances)
					{
						totalEnhances++;
					}
					if (elders > inventoryElders)
					{
						totalElders++;
					}
					if (twisteds > inventoryTwisteds)
					{
						totalTwisteds++;
					}
					if (kodais > inventoryKodais)
					{
						totalKodais++;
					}
					if (overloads > inventoryOverloads)
					{
						totalOverloads++;
					}
				}

				inventoryNox = nox;
				inventoryGolpar = golpar;
				inventoryBuchus = buchus;
				inventoryBrews = brews;
				inventoryRevites = revites;
				inventoryEnhances = enhances;
				inventoryElders = elders;
				inventoryTwisteds = twisteds;
				inventoryKodais = kodais;
				inventoryOverloads = overloads;
				pickedJuice = e.getItemContainer().count(ItemID.ENDARKENED_JUICE);
				pickedShrooms = e.getItemContainer().count(ItemID.STINKHORN_MUSHROOM);
				pickedCicely = e.getItemContainer().count(ItemID.CICELY);

				previousGrubs = grubs;
			}
		}
	}

	@Subscribe
	public void onPartyGrubsUpdate(PartyGrubsUpdate e)
	{
		Player localPlayer = client.getLocalPlayer();
		String player = e.getPlayer();
		int world = e.getWorld();
		int grubs = e.getGrubs();

		if (localPlayer.getName() != null && !localPlayer.getName().equals(player) && client.getWorld() == world)
		{
			totalGrubs += grubs;
		}
	}

	@Subscribe
	public void onGraphicsObjectCreated(GraphicsObjectCreated e)
	{
		//Ice Demon Pop
		if (inRaid && e.getGraphicsObject().getId() == 188)
		{
			iceDemonActive = true;
		}
	}

	@Subscribe
	private void onNpcSpawned(NpcSpawned e)
	{
		if (inRaid && e.getNpc() != null)
		{
			NPC npc = e.getNpc();
			int id = npc.getId();
			String name = npc.getName();

			switch (id)
			{
				case NpcID.GREAT_OLM_LEFT_CLAW:
				case NpcID.GREAT_OLM_LEFT_CLAW_7555:
					meleeHand = npc;
					break;
				case NpcID.GREAT_OLM_RIGHT_CLAW:
				case NpcID.GREAT_OLM_RIGHT_CLAW_7553:
					mageHand = npc;
					break;
				case NpcID.ICE_DEMON:
					iceDemon = npc;
					break;
				case NpcID.MUTTADILE_7562: //Baby muttadile
					smallMuttaAlive = true;
					smallMutta = npc;
					break;
				case NpcID.MUTTADILE: //Big muttadile in water
				case NpcID.MUTTADILE_7563: //Big muttadile
					bigMutta = npc;
					break;
			}

			if (name != null)
			{
				if (name.equalsIgnoreCase("great olm"))
				{
					olmHead = npc;
					olmSpawned = true;
					if (id == NpcID.GREAT_OLM)
					{
						olmTile = npc.getLocalLocation();
					}
					else if (id == NpcID.GREAT_OLM_7554)
					{
						olmTile = null;
					}
				}
			}
		}
	}

	@Subscribe
	private void onNpcDespawned(NpcDespawned e)
	{
		if (inRaid)
		{
			NPC npc = e.getNpc();
			int id = npc.getId();
			String name = npc.getName();

			switch (id)
			{
				case NpcID.GREAT_OLM_LEFT_CLAW:
				case NpcID.GREAT_OLM_LEFT_CLAW_7555:
					meleeHand = null;
					if (npc.isDead())
					{
						if (mageHand == null)
						{
							olmPhase = "";
						}
						meleeHandHp = 600;
						meleeHandLastHealthScale = 100;
						meleeHandLastRatio = 100;
					}
					break;
				case NpcID.GREAT_OLM_RIGHT_CLAW:
				case NpcID.GREAT_OLM_RIGHT_CLAW_7553:
					mageHand = null;
					if (npc.isDead())
					{
						if (meleeHand == null)
						{
							olmPhase = "";
						}
						mageHandHp = 600;
						mageHandLastHealthScale = 100;
						mageHandLastRatio = 100;
					}
					break;
				case NpcID.ICE_DEMON:
					iceDemon = null;
					break;
				case NpcID.MUTTADILE_7562: //Baby muttadile
					smallMuttaAlive = false;
					smallMutta = null;
					lastHealthScale = 0;
					lastRatio = 0;
					break;
				case NpcID.MUTTADILE: //Big muttadile in water
				case NpcID.MUTTADILE_7563: //Big muttadile
					bigMutta = null;
					bigMuttaLastHealthScale = 0;
					bigMuttaLastRatio = 0;
					break;
			}

			if (name != null)
			{
				if (name.equalsIgnoreCase("great olm"))
				{
					olmHead = null;
					olmSpawned = false;
					if (id == NpcID.GREAT_OLM)
					{
						olmTile = null;
					}

					if (npc.isDead())
					{
						olmPhase = "";
					}
				}
			}
		}
	}

	@Subscribe
	private void onNpcChanged(NpcChanged e)
	{
		if (inRaid)
		{
			NPC npc = e.getNpc();
			int id = npc.getId();

			if (id == NpcID.GREAT_OLM_7554)
			{
				olmTile = null;
			}
		}
	}

	@Subscribe
	private void onActorDeath(ActorDeath e)
	{
		if (inRaid)
		{
			if (e.getActor() instanceof NPC)
			{
				NPC npc = (NPC) e.getActor();

				if (npc.getName() != null)
				{
					if (npc.getName().toLowerCase().contains("great olm (left claw)"))
					{
						meleeHand = null;
						meleeHandHp = 600;
						meleeHandLastHealthScale = 100;
						meleeHandLastRatio = 100;
					}
					else if (npc.getName().toLowerCase().contains("great olm (right claw)"))
					{
						mageHand = null;
						mageHandHp = 600;
						mageHandLastHealthScale = 100;
						mageHandLastRatio = 100;
					}
				}
			}
			else if (e.getActor() instanceof Player)
			{
				if (e.getActor().getName() != null && e.getActor().getName().equals(client.getLocalPlayer().getName()))
				{
					sendPotStatusInfo(-73, "DEAD");
				}
			}
		}
	}

	@Subscribe
	public void onNpcLootReceived(NpcLootReceived e)
	{
		if (e.getNpc().getName() != null && e.getNpc().getName().equalsIgnoreCase("vanguard") && inRaid && client.getLocalPlayer() != null)
		{
			for (ItemStack item : e.getItems())
			{
				if (item.getId() == ItemID.OVERLOAD_4_20996)
				{
					if (partyService.isInParty())
					{
						partyService.send(new PartyOverloadUpdate(client.getLocalPlayer().getName(), client.getWorld()));
					}
					else
					{
						sendVanguardMessage(client.getLocalPlayer().getName(), client.getWorld());
					}
				}
			}
		}
	}

	@Subscribe
	public void onPartyOverloadUpdate(PartyOverloadUpdate e)
	{
		sendVanguardMessage(e.getPlayer(), e.getWorld());
	}

	public void sendVanguardMessage(String player, int world)
	{
		clientThread.invoke(() ->
		{
			if (world == client.getWorld())
			{
				overloadsDropped++;

				if (config.overloadChatMessage())
				{
					String msg = player + " has received: <col=ff0000>1</col> x <col=ff0000>Overload (+)(4)</col>.";
					client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", msg, null);
				}
			}
		});
	}

	private final Predicate<MenuEntry> filterMenuEntries = entry ->
	{
		if (inRaid)
		{
			String option = Text.standardize(entry.getOption()).toLowerCase();

			if (config.leftClickLeave() && option.contains("leave") && entry.getType().getId() == 1007)
			{
				entry.setType(MenuAction.CC_OP);
			}
		}
		return true;
	};

	private void swapMenuEntry(int index, MenuEntry menuEntry)
	{
		String option = Text.removeTags(menuEntry.getOption()).toLowerCase();
		String target = Text.removeTags(menuEntry.getTarget()).toLowerCase();

		if (inRaid)
		{
			if (config.swapCoXKeystone() && target.equals("keystone crystal") && option.equals("use"))
			{
				swap("drop", option, target, index, false);
			}

			if (config.hotkeySwapSmash() && target.contains("jewelled crab") && option.contains("attack"))
			{
				if (hotkeyHeld)
				{
					swap("smash", option, target, index);
				}
			}

			if (config.hotkeySwapBank() && target.contains("storage unit"))
			{
				if (hotkeyHeld)
				{
					if (option.contains("shared"))
					{
						swap("private", option, target, index);
					}
				}
			}
		}
	}

	@Subscribe
	public void onClientTick(ClientTick e)
	{
		if (client.getGameState() == GameState.LOGGED_IN && !client.isMenuOpen())
		{
			MenuEntry[] menuEntries = client.getMenuEntries();
			int idx = 0;
			optionIndexes.clear();

			for (MenuEntry entry : menuEntries)
			{
				String option = Text.removeTags(entry.getOption()).toLowerCase();
				optionIndexes.put(option, idx++);
			}

			idx = 0;
			for (MenuEntry entry : menuEntries)
			{
				swapMenuEntry(idx++, entry);
			}
		}
		client.setMenuEntries(updateMenuEntries(client.getMenuEntries()));
	}

	public int getMaxEnhanceCycles()
	{
		return (int) Math.floor((float) (client.getRealSkillLevel(Skill.PRAYER) / 2) + 31);
	}

	public int getEnhanceRegenRate()
	{
		return (int) Math.floor((float) 500 / getMaxEnhanceCycles());
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged e)
	{
		inRaid = client.getVarbitValue(Varbits.IN_RAID) == 1;

		if (inRaid)
		{
			if ((client.getVarbitValue(enhVar) > 0 && totalEnhCycles == 0) || (client.getVarbitValue(enhVar) != totalEnhCycles))
			{
				maxEnhCycles = getMaxEnhanceCycles();
				enhRegenRate = getEnhanceRegenRate();
				totalEnhCycles = client.getVarbitValue(enhVar);
				enhanceTicks = client.getVarbitValue(enhVar) * getEnhanceRegenRate();
				addInfobox("Enhance");

				if (queueEnhUpdate)
				{
					sendPotStatusInfo(enhanceTicks, "ENH");
					queueEnhUpdate = false;
				}
			}
			else if ((client.getVarbitValue(ovlVar) > 0 && totalOvlCycles == 0) || (client.getVarbitValue(ovlVar) != totalOvlCycles))
			{
				totalOvlCycles = client.getVarbitValue(ovlVar);
				overloadTicks = client.getVarbitValue(ovlVar) * 25;

				if (queueOvlUpdate)
				{
					sendPotStatusInfo(overloadTicks, "OVL");
					queueOvlUpdate = false;
				}
			}
			else
			{
				if (client.getVarpValue(VarPlayer.HP_HUD_NPC_ID) == 7555)
				{
					meleeHandHp = client.getVarbitValue(6099);
				}
				else if (client.getVarpValue(VarPlayer.HP_HUD_NPC_ID) == 7553)
				{
					mageHandHp = client.getVarbitValue(6099);
				}
			}
		}
		else
		{
			playersInParty.clear();

			meleeHand = null;
			mageHand = null;
			meleeHandHp = 600;
			mageHandHp = 600;
			mageHandLastRatio = 100;
			mageHandLastHealthScale = 100;
			meleeHandLastRatio = 100;
			meleeHandLastHealthScale = 100;

			smallMuttaAlive = false;
			lastRatio = 100;
			lastHealthScale = 100;
			smallMutta = null;

			bigMuttaLastRatio = 100;
			bigMuttaLastHealthScale = 100;
			bigMutta = null;

			coxHerb1 = null;
			coxHerbTimer1 = 11;
			coxHerb2 = null;
			coxHerbTimer2 = 11;

			totalBuchus = 0;
			totalGolpar = 0;
			totalNox = 0;

			inventoryBuchus = 0;
			inventoryGolpar = 0;
			inventoryNox = 0;

			totalBrews = 0;
			totalRevites = 0;
			totalEnhances = 0;
			totalElders = 0;
			totalTwisteds = 0;
			totalKodais = 0;
			totalOverloads = 0;

			inventoryBrews = 0;
			inventoryRevites = 0;
			inventoryEnhances = 0;
			inventoryElders = 0;
			inventoryTwisteds = 0;
			inventoryKodais = 0;
			inventoryOverloads = 0;

			pickedJuice = 0;
			pickedShrooms = 0;
			pickedCicely = 0;

			pickedHerb = false;
			potMade = false;

			totalGrubs = 0;
			previousGrubs = 0;
			inThieving = false;
			inPrep = false;
			if (grubsInfobox != null)
			{
				infoBoxManager.removeInfoBox(grubsInfobox);
				grubsInfobox = null;
			}

			inVangs = false;
			meleeFound = false;
			rangerFound = false;
			magerFound = false;

			iceDemon = null;
			iceDemonActive = false;

			overloadsDropped = 0;

			enhanceSipped = false;
			enhanceTicks = -1;
			totalEnhCycles = 0;
			maxEnhCycles = 0;
			enhRegenRate = 0;
			if (enhanceInfobox != null)
			{
				infoBoxManager.removeInfoBox(enhanceInfobox);
				enhanceInfobox = null;
			}
		}
	}

	@Subscribe
	public void onProjectileMoved(ProjectileMoved projectileMoved)
	{
		if (inRaid)
		{
			Projectile p = projectileMoved.getProjectile();

			if (config.replaceOrbs() && orbIDs.contains(p.getId()))
			{
				int newID = -1;

				switch (p.getId())
				{
					case 1341: //Mage Orb
					{
						newID = 2208; //Warden Blue Orb
						break;
					}
					case 1343: //Range Orb
					{
						newID = 2206; //Warden White Arrow
						break;
					}
					case 1345: //Melee Orb
					{
						newID = 2204; //Warden Red Sword
						break;
					}
				}

				if (newID != -1)
				{
					Projectile orb = client.createProjectile(
						newID,
						p.getFloor(),
						p.getX1(), p.getY1(),
						p.getHeight(),
						p.getStartCycle(), p.getEndCycle(),
						p.getSlope(),
						p.getStartHeight(), p.getEndHeight(),
						p.getInteracting(),
						p.getTarget().getX(), p.getTarget().getY());

					client.getProjectiles().addLast(orb);
					p.setEndCycle(0);
				}
			}
		}
	}

	private void swap(String optionA, String optionB, String target, int index)
	{
		swap(optionA, optionB, target, index, true);
	}

	private void swapContains(String optionA, String optionB, String target, int index)
	{
		swap(optionA, optionB, target, index, false);
	}

	private void swap(String optionA, String optionB, String target, int index, boolean strict)
	{
		MenuEntry[] menuEntries = client.getMenuEntries();
		int thisIndex = findIndex(menuEntries, index, optionB, target, strict);
		int optionIdx;

		if (target.contains("*"))
		{
			optionIdx = findIndex(menuEntries, thisIndex, optionA, target.replace("*", ""), strict);
		}
		else
		{
			optionIdx = findIndex(menuEntries, thisIndex, optionA, target, strict);
		}

		if (thisIndex >= 0 && optionIdx >= 0)
		{
			swap(optionIndexes, menuEntries, optionIdx, thisIndex);
		}
	}

	private int findIndex(MenuEntry[] entries, int limit, String option, String target, boolean strict)
	{
		if (strict)
		{
			List<Integer> indexes = optionIndexes.get(option);
			for (int i = indexes.size() - 1; i >= 0; i--)
			{
				int idx = indexes.get(i);
				MenuEntry entry = entries[idx];
				String entryTarget = Text.removeTags(entry.getTarget()).toLowerCase();
				if (idx <= limit && entryTarget.equals(target))
				{
					return idx;
				}
			}
		}
		else
		{
			for (int i = limit; i >= 0; i--)
			{
				MenuEntry entry = entries[i];
				String entryOption = Text.removeTags(entry.getOption()).toLowerCase();
				String entryTarget = Text.removeTags(entry.getTarget()).toLowerCase();
				if (entryOption.contains(option.toLowerCase()) && entryTarget.equals(target))
				{
					return i;
				}
			}
		}
		return -1;
	}

	private void swap(ArrayListMultimap<String, Integer> optionIndexes, MenuEntry[] entries, int index1, int index2)
	{
		MenuEntry entry1 = entries[index1],
			entry2 = entries[index2];
		entries[index1] = entry2;
		entries[index2] = entry1;

		if (entry1.isItemOp() && entry1.getType() == MenuAction.CC_OP_LOW_PRIORITY)
		{
			entry1.setType(MenuAction.CC_OP);
		}

		if (entry2.isItemOp() && entry2.getType() == MenuAction.CC_OP_LOW_PRIORITY)
		{
			entry2.setType(MenuAction.CC_OP);
		}

		client.setMenuEntries(entries);
		optionIndexes.clear();
		int idx = 0;
		for (MenuEntry menuEntry : entries)
		{
			String option = Text.removeTags(menuEntry.getOption()).toLowerCase();
			optionIndexes.put(option, idx++);
		}
	}

	private MenuEntry[] updateMenuEntries(MenuEntry[] menuEntries)
	{
		return Arrays.stream(menuEntries)
			.filter(filterMenuEntries).sorted((o1, o2) -> 0)
			.toArray(MenuEntry[]::new);
	}

	@Override
	public void keyTyped(KeyEvent e)
	{
	}

	public void keyPressed(KeyEvent e)
	{
		if (config.hotkey().matches(e))
		{
			hotkeyHeld = true;
		}
	}

	public void keyReleased(KeyEvent e)
	{
		if (config.hotkey().matches(e))
		{
			hotkeyHeld = false;
		}
	}

	public void addInfobox(String infobox)
	{
		int img;

		switch (infobox)
		{
			case "Enhance":
				enhanceSipped = true;
				if (enhanceInfobox == null && config.detailedPrayerEnhance() != CoxAdditionsConfig.enhanceMode.OFF)
				{
					enhanceInfobox = new EnhanceInfobox(client, this, config);
					img = ItemID.PRAYER_ENHANCE_4_20972;
					enhanceInfobox.setImage(itemManager.getImage(img));
					infoBoxManager.addInfoBox(enhanceInfobox);
				}
				break;
			case "Grubs":
				if (grubsInfobox == null && config.grubsInfobox() != CoxAdditionsConfig.grubsMode.OFF)
				{
					if ((config.grubsInfobox() == CoxAdditionsConfig.grubsMode.THIEVING && inThieving) ||
						(config.grubsInfobox() == CoxAdditionsConfig.grubsMode.BOTH && (inThieving || inPrep)))
					{
						grubsInfobox = new GrubsInfobox(client, this, config);
						img = ItemID.CAVERN_GRUBS;
						grubsInfobox.setImage(itemManager.getImage(img));
						infoBoxManager.addInfoBox(grubsInfobox);
					}
				}
				break;
		}
	}

	public void removeInfobox(String infobox)
	{
		switch (infobox)
		{
			case "Enhance":
				totalEnhCycles = 0;
				enhanceSipped = false;
				infoBoxManager.removeInfoBox(enhanceInfobox);
				enhanceInfobox = null;
				break;
			case "Grubs":
				infoBoxManager.removeInfoBox(grubsInfobox);
				grubsInfobox = null;
				break;
		}
	}

	private InstanceTemplates getCurrentRoom(int x, int y, int z)
	{
		if (client.getGameState() == GameState.LOGGED_IN && inRaid)
		{
			int chunkData = client.getInstanceTemplateChunks()[z][x / 8][y / 8];
			return InstanceTemplates.findMatch(chunkData);
		}
		return null;
	}

	public InstanceTemplates room()
	{
		return getCurrentRoom(client.getLocalPlayer().getLocalLocation().getSceneX(),
			client.getLocalPlayer().getLocalLocation().getSceneY(), client.getPlane());
	}

	public void loadFont(boolean overlay)
	{
		if (overlay)
		{
			switch (config.overlayFontType())
			{
				case SMALL:
					overlayFont = FontManager.getRunescapeSmallFont();
					break;
				case REGULAR:
					overlayFont = FontManager.getRunescapeFont();
					break;
				case BOLD:
					overlayFont = FontManager.getRunescapeBoldFont();
					break;
				case CUSTOM:
					if (!config.overlayFontName().equals(""))
					{
						overlayFont = new Font(config.overlayFontName(), config.overlayFontWeight().getWeight(), config.overlayFontSize());
					}
					break;
			}
		}
		else
		{
			switch (config.panelFontType())
			{
				case SMALL:
					panelFont = FontManager.getRunescapeSmallFont();
					break;
				case REGULAR:
					panelFont = FontManager.getRunescapeFont();
					break;
				case BOLD:
					panelFont = FontManager.getRunescapeBoldFont();
					break;
				case CUSTOM:
					if (!config.panelFontName().equals(""))
					{
						panelFont = new Font(config.panelFontName(), config.panelFontWeight().getWeight(), config.panelFontSize());
					}
					break;
			}
		}
	}
}

package com.coxadditions.party;

import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Value;
import net.runelite.client.party.messages.PartyMemberMessage;

@Value
@AllArgsConstructor
@EqualsAndHashCode(callSuper = true)
public class PartyRaidsPotsUpdate extends PartyMemberMessage
{
	int ticks;
	String pot;
}
package com.coxadditions.party;

import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Value;
import net.runelite.client.party.messages.PartyMemberMessage;

@Value
@AllArgsConstructor
@EqualsAndHashCode(callSuper = true)
public class PartyGrubsUpdate extends PartyMemberMessage
{
	String player;
	int world;
	int grubs;
}
package com.coxadditions.party;

import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Value;
import net.runelite.client.party.messages.PartyMemberMessage;

@Value
@AllArgsConstructor
@EqualsAndHashCode(callSuper = true)
public class PartyOverloadUpdate extends PartyMemberMessage
{
	String player;
	int world;
}

package com.coxadditions.overlay;

import com.coxadditions.CoxAdditionsConfig;
import com.coxadditions.CoxAdditionsPlugin;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.Varbits;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.components.TitleComponent;

public class OlmPhasePanel extends OverlayPanel
{
	private final Client client;
	private final CoxAdditionsPlugin plugin;
	private final CoxAdditionsConfig config;

	@Inject
	public OlmPhasePanel(Client client, CoxAdditionsPlugin plugin, CoxAdditionsConfig config)
	{
		super(plugin);
		this.plugin = plugin;
		this.config = config;
		this.client = client;
	}

	public Dimension render(Graphics2D graphics)
	{
		if (plugin.getPanelFont() == null)
		{
			plugin.loadFont(false);
		}

		panelComponent.getChildren().clear();
		if (config.olmPhasePanel() && this.client.getVarbitValue(Varbits.IN_RAID) == 1 && !plugin.getOlmPhase().equals(""))
		{
			graphics.setFont(plugin.getPanelFont());
			Color color = plugin.getOlmPhase().equals("Acid") ? Color.GREEN : plugin.getOlmPhase().equals("Flame") ? Color.RED : Color.MAGENTA;
			panelComponent.setPreferredSize(new Dimension(graphics.getFontMetrics().stringWidth(plugin.getOlmPhase()) + 3, 0));
			panelComponent.getChildren().add(TitleComponent.builder()
				.color(color)
				.text(plugin.getOlmPhase())
				.build());
		}
		return super.render(graphics);
	}
}

package com.coxadditions.overlay;

import com.coxadditions.CoxAdditionsConfig;
import com.coxadditions.CoxAdditionsPlugin;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.*;
import net.runelite.client.ui.overlay.components.LineComponent;

public class InstanceTimerOverlay extends OverlayPanel
{
	private final Client client;
	private final CoxAdditionsPlugin plugin;
	private final CoxAdditionsConfig config;

	@Inject
	public InstanceTimerOverlay(Client client, CoxAdditionsPlugin plugin, CoxAdditionsConfig config)
	{
		super(plugin);
		this.client = client;
		this.plugin = plugin;
		this.config = config;
		setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
	}

	public Dimension render(Graphics2D graphics)
	{
		if (plugin.getPanelFont() == null)
		{
			plugin.loadFont(false);
		}

		panelComponent.getChildren().clear();
		if (config.instanceTimer() == CoxAdditionsConfig.instanceTimerMode.INFOBOX && plugin.isInstanceTimerRunning() && plugin.isInRaid())
		{
			Color goodTick = new Color(37, 197, 79);
			Color badTick = new Color(224, 60, 49);

			graphics.setFont(plugin.getPanelFont());
			panelComponent.setPreferredSize(new Dimension(graphics.getFontMetrics().stringWidth("Tick:   ") + 15, 0));
			panelComponent.getChildren().add(LineComponent.builder()
				.left("Tick: ")
				.right(String.valueOf(plugin.getInstanceTimer()))
				.rightColor(plugin.getInstanceTimer() == 0 ? goodTick : badTick)
				.build());
		}
		return super.render(graphics);
	}
}


package com.coxadditions.overlay;

import com.coxadditions.CoxAdditionsConfig;
import com.coxadditions.CoxAdditionsPlugin;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import java.util.List;
import net.runelite.api.InstanceTemplates;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.components.LayoutableRenderableEntity;
import net.runelite.client.ui.overlay.components.LineComponent;

public class CoxPrepOverlay extends OverlayPanel
{
	private final CoxAdditionsPlugin plugin;
	private final CoxAdditionsConfig config;

	@Inject
	private CoxPrepOverlay(CoxAdditionsPlugin plugin, CoxAdditionsConfig config)
	{
		this.plugin = plugin;
		this.config = config;
		setPosition(OverlayPosition.TOP_LEFT);
		setPriority(OverlayPriority.HIGH);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (plugin.getPanelFont() == null)
		{
			plugin.loadFont(false);
		}

		graphics.setFont(plugin.getPanelFont());

		List<LayoutableRenderableEntity> elems = panelComponent.getChildren();
		if (plugin.isInPrep())
		{
			if ((config.brews() + config.revites() + config.enhances()) != 0)
			{
				elems.add(LineComponent.builder()
					.leftColor(Color.WHITE)
					.left("Buchu: ")
					.rightColor(plugin.getTotalBuchus() >= (config.brews() + config.revites() + config.enhances())
						? Color.GREEN : Color.WHITE)
					.right(plugin.getTotalBuchus() + "/" + (config.brews() + config.revites() + config.enhances()))
					.build());

				if (config.showPots())
				{
					if (config.brews() > 0)
					{
						elems.add(LineComponent.builder()
							.leftColor(Color.WHITE)
							.left("    Brews: ")
							.rightColor(plugin.getTotalBrews() >= config.brews() ? Color.GREEN : Color.WHITE)
							.right(plugin.getTotalBrews() + "/" + config.brews())
							.build());
					}

					if (config.revites() > 0)
					{
						elems.add(LineComponent.builder()
							.leftColor(Color.WHITE)
							.left("    Revites: ")
							.rightColor(plugin.getTotalRevites() >= config.revites() ? Color.GREEN : Color.WHITE)
							.right(plugin.getTotalRevites() + "/" + config.revites())
							.build());
					}

					if (config.enhances() > 0)
					{
						elems.add(LineComponent.builder()
							.leftColor(Color.WHITE)
							.left("    Enhances: ")
							.rightColor(plugin.getTotalEnhances() >= config.enhances() ? Color.GREEN : Color.WHITE)
							.right(plugin.getTotalEnhances() + "/" + config.enhances())
							.build());
					}
				}
			}

			if (config.overloads() != 0)
			{
				elems.add(LineComponent.builder()
					.leftColor(Color.WHITE)
					.left("Golpar: ")
					.rightColor(plugin.getTotalGolpar() >= (config.overloads() * 3) ? Color.GREEN : Color.WHITE)
					.right(plugin.getTotalGolpar() + "/" + (config.overloads() * 3))
					.build());

				if (config.showPots())
				{
					elems.add(LineComponent.builder()
						.leftColor(Color.WHITE)
						.left("    Elders: ")
						.rightColor(plugin.getTotalElders() >= config.overloads() ? Color.GREEN : Color.WHITE)
						.right(plugin.getTotalElders() + "/" + config.overloads())
						.build());

					elems.add(LineComponent.builder()
						.leftColor(Color.WHITE)
						.left("    Twisteds: ")
						.rightColor(plugin.getTotalTwisteds() >= config.overloads() ? Color.GREEN : Color.WHITE)
						.right(plugin.getTotalTwisteds() + "/" + config.overloads())
						.build());

					elems.add(LineComponent.builder()
						.leftColor(Color.WHITE)
						.left("    Kodais: ")
						.rightColor(plugin.getTotalKodais() >= config.overloads() ? Color.GREEN : Color.WHITE)
						.right(plugin.getTotalKodais() + "/" + config.overloads())
						.build());

				}

				elems.add(LineComponent.builder()
					.leftColor(Color.WHITE)
					.left("Noxifer: ")
					.rightColor(plugin.getTotalNox() >= (config.overloads() + config.extraNox()) ? Color.GREEN : Color.WHITE)
					.right(plugin.getTotalNox() + "/" + (config.overloads() + config.extraNox()))
					.build());

				if (config.showPots())
				{
					elems.add(LineComponent.builder()
						.leftColor(Color.WHITE)
						.left("    Overloads: ")
						.rightColor(plugin.getTotalOverloads() >= config.overloads() ? Color.GREEN : Color.WHITE)
						.right(plugin.getTotalOverloads() + "/" + config.overloads())
						.build());
				}
			}
		}

		if ((plugin.room() == InstanceTemplates.RAIDS_SCAVENGERS || plugin.room() == InstanceTemplates.RAIDS_SCAVENGERS2)
			&& config.showSecondaries())
		{
			if (config.brews() != 0 || config.overloads() != 0)
			{
				elems.add(LineComponent.builder()
					.leftColor(Color.WHITE)
					.left("Juice: ")
					.rightColor(plugin.getPickedJuice() >= (config.brews() + config.overloads()) ? Color.GREEN : Color.WHITE)
					.right(plugin.getPickedJuice() + "/" + (config.brews() + config.overloads()))
					.build());
			}

			if (config.revites() != 0 || config.overloads() != 0)
			{
				elems.add(LineComponent.builder()
					.leftColor(Color.WHITE)
					.left("Shrooms: ")
					.rightColor(plugin.getPickedShrooms() >= (config.revites() + config.overloads()) ? Color.GREEN : Color.WHITE)
					.right(plugin.getPickedShrooms() + "/" + (config.revites() + config.overloads()))
					.build());
			}

			if (config.enhances() != 0 || config.overloads() != 0)
			{
				elems.add(LineComponent.builder()
					.leftColor(Color.WHITE)
					.left("Cicely: ")
					.rightColor(plugin.getPickedCicely() >= (config.enhances() + config.overloads()) ? Color.GREEN : Color.WHITE)
					.right(plugin.getPickedCicely() + "/" + (config.enhances() + config.overloads()))
					.build());
			}
		}
		return super.render(graphics);
	}
}
package com.coxadditions.overlay;

import com.coxadditions.CoxAdditionsConfig;
import com.coxadditions.CoxAdditionsPlugin;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import javax.inject.Inject;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.WidgetItemOverlay;
import net.runelite.client.util.Text;
import net.runelite.client.util.WildcardMatcher;

public class CoxItemOverlay extends WidgetItemOverlay
{
	private final ItemManager itemManager;

	private final CoxAdditionsPlugin plugin;

	private final CoxAdditionsConfig config;

	@Inject
	public CoxItemOverlay(ItemManager itemManager, CoxAdditionsPlugin plugin, CoxAdditionsConfig config)
	{
		this.itemManager = itemManager;
		this.plugin = plugin;
		this.config = config;
		showOnInterfaces(271, 551);
	}

	public void renderItemOverlay(Graphics2D graphics, int itemId, WidgetItem itemWidget)
	{
		if (plugin.isInRaid() && config.highlightChest() != CoxAdditionsConfig.HighlightChestMode.OFF
			&& ((!config.highlightChestItems().equals("") && plugin.getChestHighlightIdList().size() > 0)
			|| (!config.highlightChestItems2().equals("") && plugin.getChestHighlightIdList2().size() > 0)))
		{
			if (plugin.getChestHighlightIdList().contains(String.valueOf(itemId)) || itemNameInList(plugin.getChestHighlightIdList(), itemWidget))
			{
				if (config.highlightChest() == CoxAdditionsConfig.HighlightChestMode.UNDERLINE)
				{
					underlineItem(graphics, itemWidget, config.highlightChestItemsColor());
				}
				else if (config.highlightChest() == CoxAdditionsConfig.HighlightChestMode.OUTLINE)
				{
					highlightItem(graphics, itemId, itemWidget, config.highlightChestItemsColor());
				}
			}
			else if (plugin.getChestHighlightIdList2().contains(String.valueOf(itemId)) || itemNameInList(plugin.getChestHighlightIdList2(), itemWidget))
			{
				if (config.highlightChest() == CoxAdditionsConfig.HighlightChestMode.UNDERLINE)
				{
					underlineItem(graphics, itemWidget, config.highlightChestItemsColor2());
				}
				else if (config.highlightChest() == CoxAdditionsConfig.HighlightChestMode.OUTLINE)
				{
					highlightItem(graphics, itemId, itemWidget, config.highlightChestItemsColor2());
				}
			}
		}
	}

	private void highlightItem(Graphics2D graphics, int itemId, WidgetItem itemWidget, Color color)
	{
		Rectangle bounds = itemWidget.getCanvasBounds();
		BufferedImage outline = itemManager.getItemOutline(itemId, itemWidget.getQuantity(), color);
		graphics.drawImage(outline, (int) bounds.getX(), (int) bounds.getY(), null);
	}

	private void underlineItem(Graphics2D graphics, WidgetItem itemWidget, Color color)
	{
		Rectangle bounds = itemWidget.getCanvasBounds();
		int heightOffSet = (int) bounds.getY() + (int) bounds.getHeight() + 2;
		graphics.setColor(color);
		graphics.drawLine((int) bounds.getX(), heightOffSet, (int) bounds.getX() + (int) bounds.getWidth(), heightOffSet);
	}

	private boolean itemNameInList(ArrayList<String> list, WidgetItem item)
	{
		String itemName = Text.removeTags(item.getWidget().getName().replace('\u00A0', ' ').trim());
		return list.stream().anyMatch(i -> WildcardMatcher.matches(i, itemName) || i.equalsIgnoreCase(itemName));
	}
}

/*
 * Copyright (c) 2022, Buchus <http://github.com/MoreBuchus>
 * Copyright (c) 2022, dey0 <http://github.com/dey0> - CC warning
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.coxadditions.overlay;

import com.coxadditions.ChestGroup;
import com.coxadditions.CoxAdditionsConfig;
import com.coxadditions.CoxAdditionsPlugin;
import java.awt.geom.Point2D;
import net.runelite.api.Point;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.*;
import net.runelite.client.ui.overlay.components.ProgressPieComponent;
import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.*;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;
import net.runelite.client.util.ColorUtil;

@Singleton
public class CoxAdditionsOverlay extends Overlay
{
	private final Client client;
	private final CoxAdditionsPlugin plugin;
	private final CoxAdditionsConfig config;
	private final ModelOutlineRenderer modelOutlineRenderer;
	private final Color NO_FILL = new Color(0, 0, 0, 0);

	@Inject
	private CoxAdditionsOverlay(final Client client, final CoxAdditionsPlugin plugin, final CoxAdditionsConfig config, final ModelOutlineRenderer modelOutlineRenderer)
	{
		this.client = client;
		this.plugin = plugin;
		this.config = config;
		this.modelOutlineRenderer = modelOutlineRenderer;
		setPosition(OverlayPosition.DYNAMIC);
		setPriority(OverlayPriority.HIGH);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (plugin.isInRaid())
		{
			if (plugin.getOverlayFont() == null)
			{
				plugin.loadFont(true);
			}

			if (config.coxHerbTimer() != CoxAdditionsConfig.CoXHerbTimerMode.OFF && (plugin.getCoxHerb1() != null || plugin.getCoxHerb2() != null) && plugin.isInPrep())
			{
				if (config.coxHerbTimer() == CoxAdditionsConfig.CoXHerbTimerMode.TEXT)
				{
					graphics.setFont(plugin.getOverlayFont());
					if (plugin.getCoxHerb1() != null)
					{
						GameObject herb = plugin.getCoxHerb1();
						String text = Integer.toString(plugin.getCoxHerbTimer1());
						Point textLoc = herb.getCanvasTextLocation(graphics, text, 50);
						if (textLoc != null)
						{
							Point pointShadow = new Point(textLoc.getX() + 1, textLoc.getY() + 1);
							Font oldFont = graphics.getFont();
							graphics.setFont(plugin.getOverlayFont());
							OverlayUtil.renderTextLocation(graphics, pointShadow, text, Color.BLACK);
							OverlayUtil.renderTextLocation(graphics, textLoc, text, config.coxHerbTimerColor());
							graphics.setFont(oldFont);
						}
					}

					if (plugin.getCoxHerb2() != null)
					{
						GameObject herb = plugin.getCoxHerb2();
						String text = Integer.toString(plugin.getCoxHerbTimer2());
						Point textLoc = herb.getCanvasTextLocation(graphics, text, 50);
						if (textLoc != null)
						{
							Point pointShadow = new Point(textLoc.getX() + 1, textLoc.getY() + 1);
							Font oldFont = graphics.getFont();
							graphics.setFont(plugin.getOverlayFont());
							OverlayUtil.renderTextLocation(graphics, pointShadow, text, Color.BLACK);
							OverlayUtil.renderTextLocation(graphics, textLoc, text, config.coxHerbTimerColor());
							graphics.setFont(oldFont);
						}
					}
				}
				else if (config.coxHerbTimer() == CoxAdditionsConfig.CoXHerbTimerMode.PIE)
				{
					if (plugin.getCoxHerb1() != null)
					{
						final Point position = plugin.getCoxHerb1().getCanvasLocation(100);
						final ProgressPieComponent progressPie = new ProgressPieComponent();
						progressPie.setDiameter(config.coxHerbTimerSize());
						Color colorFill = new Color(config.coxHerbTimerColor().getRed(), config.coxHerbTimerColor().getGreen(), config.coxHerbTimerColor().getBlue(), 100);
						progressPie.setFill(colorFill);
						progressPie.setBorderColor(config.coxHerbTimerColor());
						progressPie.setPosition(position);
						int ticks = 11 - plugin.getCoxHerbTimer1();
						double progress = 1 - (ticks / 11.0);
						progressPie.setProgress(progress);
						progressPie.render(graphics);
					}

					if (plugin.getCoxHerb2() != null)
					{
						final Point position = plugin.getCoxHerb2().getCanvasLocation(100);
						final ProgressPieComponent progressPie = new ProgressPieComponent();
						progressPie.setDiameter(config.coxHerbTimerSize());
						Color colorFill = new Color(config.coxHerbTimerColor().getRed(), config.coxHerbTimerColor().getGreen(), config.coxHerbTimerColor().getBlue(), 100);
						progressPie.setFill(colorFill);
						progressPie.setBorderColor(config.coxHerbTimerColor());
						progressPie.setPosition(position);
						int ticks = 11 - plugin.getCoxHerbTimer2();
						double progress = 1 - (ticks / 11.0);
						progressPie.setProgress(progress);
						progressPie.render(graphics);
					}
				}
			}

			if (config.instanceTimer() == CoxAdditionsConfig.instanceTimerMode.OVERHEAD && plugin.isInstanceTimerRunning())
			{
				Player player = client.getLocalPlayer();
				if (player != null)
				{
					Point point = player.getCanvasTextLocation(graphics, "#", player.getLogicalHeight() + 60);
					if (point != null)
					{
						Color goodTick = new Color(37, 197, 79);
						Color badTick = new Color(224, 60, 49);

						graphics.setFont(plugin.getOverlayFont());
						OverlayUtil.renderTextLocation(graphics, point, String.valueOf(plugin.getInstanceTimer()), plugin.getInstanceTimer() == 0 ? goodTick : badTick);
					}
				}
			}

			if (!config.tlList().equals(""))
			{
				for (NPC npc : client.getNpcs())
				{
					if (npc.getName() != null && npc.getId() != 8203)
					{
						String bossName = "";

						if (npc.getName().toLowerCase().contains("tekton"))
						{
							bossName = "tekton";
						}
						else if (npc.getName().toLowerCase().contains("jewelled crab"))
						{
							bossName = "jewelled crab";
						}
						else
						{
							bossName = npc.getName().toLowerCase();
						}

						if (plugin.getTlList().contains(bossName))
						{
							NPCComposition comp = npc.getComposition();
							int size = comp.getSize();
							LocalPoint lp = LocalPoint.fromWorld(client, npc.getWorldLocation());
							if (lp != null)
							{
								lp = new LocalPoint(lp.getX() + size * 128 / 2 - 64, lp.getY() + size * 128 / 2 - 64);
								Polygon tilePoly = Perspective.getCanvasTileAreaPoly(client, lp, size);
								switch (config.tileLines())
								{
									case REG:
										renderPoly(graphics, config.tlColor(), config.tlFillColor(), tilePoly, config.tlThiCC());
										break;
									case DASH:
										renderPolygonDashed(graphics, config.tlColor(), config.tlFillColor(), tilePoly, config.tlThiCC(), size);
										break;
									case CORNER:
										renderPolygonCorners(graphics, config.tlColor(), config.tlFillColor(), tilePoly, config.tlThiCC());
										break;
								}
							}
						}
					}
				}
			}

			if (config.olmPhaseHighlight() && plugin.isOlmSpawned() && plugin.getOlmHead() != null)
			{
				NPCComposition comp = plugin.getOlmHead().getComposition();
				int size = comp.getSize();
				LocalPoint lp = plugin.getOlmHead().getLocalLocation();
				if (lp != null)
				{
					Polygon tilePoly = Perspective.getCanvasTileAreaPoly(client, lp, size);
					if (tilePoly != null)
					{
						Color color = config.olmHighlightColor();
						Color fill = ColorUtil.colorWithAlpha(config.olmHighlightColor(), config.olmHighlightFill());
						switch (plugin.getOlmPhase())
						{
							case "Crystal":
								color = ColorUtil.colorWithAlpha(Color.MAGENTA, config.olmHighlightColor().getAlpha());
								fill = ColorUtil.colorWithAlpha(Color.MAGENTA, config.olmHighlightFill());
								break;
							case "Acid":
								color = ColorUtil.colorWithAlpha(Color.GREEN, config.olmHighlightColor().getAlpha());
								fill = ColorUtil.colorWithAlpha(Color.GREEN, config.olmHighlightFill());
								break;
							case "Flame":
								color = ColorUtil.colorWithAlpha(Color.RED, config.olmHighlightColor().getAlpha());
								fill = ColorUtil.colorWithAlpha(Color.RED, config.olmHighlightFill());
								break;
						}

						switch (config.olmLines())
						{
							case REG:
								renderPoly(graphics, color, fill, tilePoly, config.olmWidth());
								break;
							case DASH:
								renderPolygonDashed(graphics, color, fill, tilePoly, config.olmWidth(), size);
								break;
							case CORNER:
								renderPolygonCorners(graphics, color, fill, tilePoly, config.olmWidth());
								break;
						}
					}
				}
			}

			if (plugin.room() == InstanceTemplates.RAIDS_THIEVING && client.getLocalPlayer() != null
				&& WorldPoint.fromLocalInstance(client, client.getLocalPlayer().getLocalLocation()).getRegionID() == 13140)
			{
				Tile[][][] tiles = client.getScene().getTiles();
				for (int x = 0; x < Constants.SCENE_SIZE; ++x)
				{
					for (int y = 0; y < Constants.SCENE_SIZE; ++y)
					{
						Tile tile = tiles[client.getPlane()][x][y];
						if (tile != null && tile.getGameObjects() != null)
						{
							checkObjects:
							for (GameObject obj : tile.getGameObjects())
							{
								for (ChestGroup cg : ChestGroup.values())
								{
									if (obj != null && obj.getId() == 29742 && (cg.getRegionX() == obj.getWorldLocation().getRegionX() && cg.getRegionY() == obj.getWorldLocation().getRegionY())
										&& ((config.chestGroupsHighlight().contains(CoxAdditionsConfig.HighlightChestGroups.CHEST_GROUPS_1) && cg.getGroup() < 5)
										|| (config.chestGroupsHighlight().contains(CoxAdditionsConfig.HighlightChestGroups.CHEST_GROUPS_2) && (cg.getGroup() > 4 && cg.getGroup() < 8))
										|| (config.chestGroupsHighlight().contains(CoxAdditionsConfig.HighlightChestGroups.CHEST_GROUPS_3) && cg.getGroup() > 7)))
									{
										switch (config.chestGroupsHighlightStyle())
										{
											case HULL:
												Shape hull = obj.getConvexHull();
												if (hull != null)
												{
													renderPoly(graphics, cg.getColor(), NO_FILL, hull, 2);
												}
												break;
											case OUTLINE:
												modelOutlineRenderer.drawOutline(obj, 2, cg.getColor(), 4);
												break;
											case TILE:
												Polygon tilePoly = Perspective.getCanvasTilePoly(client, obj.getLocalLocation());
												renderPoly(graphics, cg.getColor(), NO_FILL, tilePoly, 2);
												break;
											case CORNERS:
												Polygon cornerPoly = Perspective.getCanvasTilePoly(client, obj.getLocalLocation());
												renderPolygonCorners(graphics, cg.getColor(), NO_FILL, cornerPoly, 2);
												break;
											case CLICKBOX:
												Shape clickbox = obj.getClickbox();
												if (clickbox != null)
												{
													renderPoly(graphics, cg.getColor(), NO_FILL, clickbox, 2);
												}
												break;
										}
										break checkObjects;
									}
								}
							}
						}
					}
				}
			}
		}
		else
		{
			//Made by De0
			if (config.ccWarning())
			{
				int sceneX = 1232 - client.getBaseX(), sceneY = 3573 - client.getBaseY();
				if (sceneX >= 0 && sceneY >= 0 && sceneX < 104 && sceneY < 104)
				{
					Tile tile = client.getScene().getTiles()[0][sceneX][sceneY];
					if (tile.getGameObjects()[0] != null)
					{
						GameObject obj = tile.getGameObjects()[0];
						if (obj.getId() == ObjectID.CHAMBERS_OF_XERIC)
						{
							Color color = null;
							if (client.getFriendsChatManager() == null)
							{
								color = new Color(255, 0, 0, 50);
							}
							else if (client.getVarpValue(VarPlayer.IN_RAID_PARTY) == -1)
							{
								color = new Color(200, 200, 0, 50);
							}
							Shape clickbox = obj.getClickbox();
							if (color != null && clickbox != null)
							{
								Point mousePos = client.getMouseCanvasPosition();
								if (mousePos != null && clickbox.contains(mousePos.getX(), mousePos.getY()))
								{
									color = color.darker();
								}
								graphics.setColor(color);
								graphics.fill(clickbox);
								graphics.setColor(new Color(color.getRed(), color.getGreen(), color.getBlue()));
								graphics.draw(clickbox);
							}
						}
					}
				}
			}
		}
		return null;
	}

	private void renderPoly(Graphics2D graphics, Color color, Color fill, Shape polygon, double width)
	{
		if (polygon != null)
		{
			graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, config.antiAlias() ? RenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF);
			graphics.setColor(color);
			graphics.setStroke(new BasicStroke((float) width));
			graphics.draw(polygon);
			graphics.setColor(fill);
			graphics.fill(polygon);
		}
	}

	/**
	 * Draws only the corners of tile highlights - Made by Geheur
	 */
	private void renderPolygonCorners(Graphics2D graphics, Color outlineColor, Color fillColor, Shape poly, double width)
	{
		if (poly instanceof Polygon)
		{
			Polygon p = (Polygon) poly;
			graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, config.antiAlias() ? RenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF);
			graphics.setColor(outlineColor);
			graphics.setStroke(new BasicStroke((float) width));

			int divisor = 7;
			for (int i = 0; i < p.npoints; i++)
			{
				int ptx = p.xpoints[i];
				int pty = p.ypoints[i];
				int prev = (i - 1) < 0 ? 3 : (i - 1);
				int next = (i + 1) > 3 ? 0 : (i + 1);
				int ptxN = ((p.xpoints[next]) - ptx) / divisor + ptx;
				int ptyN = ((p.ypoints[next]) - pty) / divisor + pty;
				int ptxP = ((p.xpoints[prev]) - ptx) / divisor + ptx;
				int ptyP = ((p.ypoints[prev]) - pty) / divisor + pty;
				graphics.drawLine(ptx, pty, ptxN, ptyN);
				graphics.drawLine(ptx, pty, ptxP, ptyP);
			}

			graphics.setColor(fillColor);
			graphics.fill(poly);
		}
	}

	/**
	 * Draws the corners and dashed lines along each side of tile highlights - Made by Geheur
	 */
	private void renderPolygonDashed(Graphics2D graphics, Color outlineColor, Color fillColor, Shape poly, double width, int tiles)
	{
		if (poly instanceof Polygon)
		{
			Polygon p = (Polygon) poly;
			graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, config.antiAlias() ? RenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF);
			graphics.setColor(outlineColor);
			graphics.setStroke(new BasicStroke((float) width));

			int divisor = 7 * tiles;
			for (int i = 0; i < p.npoints; i++)
			{
				int ptx = p.xpoints[i];
				int pty = p.ypoints[i];
				int next = (i + 1) > 3 ? 0 : (i + 1);
				int ptxN = (p.xpoints[next]) - ptx;
				int ptyN = (p.ypoints[next]) - pty;
				float length = (float) Point2D.distance(ptx, pty, ptx + ptxN, pty + ptyN);
				float dashLength = length * 2f / divisor;
				float spaceLength = length * 5f / divisor;
				Stroke s = new BasicStroke((float) width, BasicStroke.CAP_SQUARE, BasicStroke.JOIN_MITER, 10, new float[]{dashLength, spaceLength}, dashLength / 2);
				graphics.setStroke(s);
				graphics.drawLine(ptx, pty, ptx + ptxN, pty + ptyN);
			}

			graphics.setColor(fillColor);
			graphics.fill(poly);
		}
	}
}

package com.coxadditions.overlay;

import com.coxadditions.CoxAdditionsConfig;
import com.coxadditions.CoxAdditionsPlugin;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.util.ColorUtil;

public class OlmSideOverlay extends Overlay
{
	private final Client client;
	private final CoxAdditionsConfig config;
	private final CoxAdditionsPlugin plugin;

	@Inject
	public OlmSideOverlay(Client client, CoxAdditionsConfig config, CoxAdditionsPlugin plugin)
	{
		this.client = client;
		this.plugin = plugin;
		this.config = config;
		setPosition(OverlayPosition.DYNAMIC);
		setPriority(OverlayPriority.LOW);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	public Dimension render(Graphics2D graphics)
	{
		if (config.olmSide() != CoxAdditionsConfig.olmSideMode.OFF && plugin.getOlmTile() != null && client.getLocalPlayer() != null)
		{
			Color color = config.olmSideColor();
			if (config.olmSideColorMode() == CoxAdditionsConfig.olmSideColorMode.PHASE)
			{
				switch (plugin.getOlmPhase())
				{
					case "Crystal":
						color = ColorUtil.colorWithAlpha(Color.MAGENTA, config.olmSideColor().getAlpha());
						break;
					case "Acid":
						color = ColorUtil.colorWithAlpha(Color.GREEN, config.olmSideColor().getAlpha());
						break;
					case "Flame":
						color = ColorUtil.colorWithAlpha(Color.RED, config.olmSideColor().getAlpha());
						break;
				}
			}
			drawTile(graphics, plugin.getOlmTile(), color);
		}
		return null;
	}

	protected void drawTile(Graphics2D graphics, LocalPoint lp, Color color)
	{
		if (WorldPoint.fromLocal(client, lp).distanceTo(client.getLocalPlayer().getWorldLocation()) < 32)
		{
			Polygon poly = config.olmSide() == CoxAdditionsConfig.olmSideMode.CENTER_TILE ? Perspective.getCanvasTilePoly(client, lp) : Perspective.getCanvasTileAreaPoly(client, lp, 5);
			if (poly != null)
			{
				graphics.setColor(new Color(color.getRed(), color.getGreen(), color.getBlue(), color.getAlpha()));
				graphics.setStroke(new BasicStroke(1));
				graphics.draw(poly);
				graphics.setColor(new Color(color.getRed(), color.getGreen(), color.getBlue(), 10));
				graphics.fill(poly);
			}
		}
	}
}

package com.coxadditions.overlay;

import com.coxadditions.CoxAdditionsConfig;
import com.coxadditions.CoxAdditionsPlugin;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.InstanceTemplates;
import net.runelite.api.NPC;
import net.runelite.api.Point;
import net.runelite.api.Varbits;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.OverlayUtil;

public class CoxHPOverlay extends Overlay
{
	private final Client client;
	private final CoxAdditionsPlugin plugin;
	private final CoxAdditionsConfig config;

	@Inject
	private CoxHPOverlay(final Client client, final CoxAdditionsPlugin plugin, final CoxAdditionsConfig config)
	{
		this.client = client;
		this.plugin = plugin;
		this.config = config;
		setPosition(OverlayPosition.DYNAMIC);
		setPriority(OverlayPriority.HIGH);
		setLayer(OverlayLayer.UNDER_WIDGETS);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (plugin.getOverlayFont() == null)
		{
			plugin.loadFont(true);
		}

		if (plugin.isInRaid() && client.getLocalPlayer() != null)
		{
			boolean solo = client.getVarbitValue(Varbits.RAID_PARTY_SIZE) == 1;

			if (plugin.room() == InstanceTemplates.RAIDS_MUTTADILES)
			{
				if (config.smallMuttaHp() && plugin.isSmallMuttaAlive() && !plugin.getSmallMutta().isDead())
				{
					NPC smallMutta = plugin.getSmallMutta();
					if (smallMutta.getHealthRatio() > 0 || (plugin.getLastRatio() != 0 && plugin.getLastHealthScale() != 0))
					{
						if (smallMutta.getHealthRatio() > 0)
						{
							plugin.setLastRatio(smallMutta.getHealthRatio());
							plugin.setLastHealthScale(smallMutta.getHealthScale());
						}
						drawHp(graphics, plugin.getSmallMutta(), plugin.getSmallMutta().getLogicalHeight() + 40, plugin.getLastRatio(), plugin.getLastHealthScale(), true);
					}
				}

				if (config.bigMuttaHp() && !plugin.isSmallMuttaAlive() && plugin.getBigMutta() != null)
				{
					NPC bigMutta = plugin.getBigMutta();
					if (bigMutta.getHealthRatio() > 0 || (plugin.getBigMuttaLastRatio() != 0 && plugin.getBigMuttaLastHealthScale() != 0))
					{
						if (bigMutta.getHealthRatio() > 0)
						{
							plugin.setBigMuttaLastRatio(bigMutta.getHealthRatio());
							plugin.setBigMuttaLastHealthScale(bigMutta.getHealthScale());
						}
						drawHp(graphics, plugin.getBigMutta(), plugin.getBigMutta().getLogicalHeight() + 40, plugin.getBigMuttaLastRatio(), plugin.getBigMuttaLastHealthScale(), true);
					}
				}
			}

			if (config.iceDemonHp() && plugin.getIceDemon() != null && !plugin.isIceDemonActive())
			{
				if (plugin.room() == InstanceTemplates.RAIDS_ICE_DEMON)
				{
					if (solo)
					{
						drawHp(graphics, plugin.getIceDemon(), plugin.getIceDemon().getLogicalHeight() + 40, plugin.getIceDemon().getHealthRatio(), plugin.getIceDemon().getHealthScale(), true);
					}
					else
					{
						drawHp(graphics, plugin.getIceDemon(), plugin.getIceDemon().getLogicalHeight() + 40, plugin.getIceDemon().getHealthRatio(), 100, true);
					}
				}
			}

			if (config.olmHandsHealth() == CoxAdditionsConfig.olmHandsHealthMode.OVERLAY && (plugin.getMageHand() != null || plugin.getMeleeHand() != null))
			{
				NPC mageHand = plugin.getMageHand();
				NPC meleeHand = plugin.getMeleeHand();
				if (solo)
				{
					//Hand HP in Solo Raids
					if (mageHand != null && plugin.getMageHandHp() > 0)
					{
						drawHp(graphics, mageHand, -75, plugin.getMageHandHp(), 100, false);
					}
					if (meleeHand != null && plugin.getMeleeHandHp() > 0)
					{
						drawHp(graphics, meleeHand, -75, plugin.getMeleeHandHp(), 100, false);
					}
				}
				else
				{
					//Hand HP in Team Raids
					if (mageHand != null)
					{
						if (mageHand.getHealthRatio() > 0 || (plugin.getMageHandLastRatio() != 0 && plugin.getMageHandLastHealthScale() != 0))
						{
							if (mageHand.getHealthRatio() > 0)
							{
								plugin.setMageHandLastRatio(mageHand.getHealthRatio());
								plugin.setMageHandLastHealthScale(mageHand.getHealthScale());
							}
							drawHp(graphics, mageHand, -75, plugin.getMageHandLastRatio(), plugin.getMageHandLastHealthScale(), true);
						}
					}

					if (meleeHand != null)
					{
						if (meleeHand.getHealthRatio() > 0 || (plugin.getMeleeHandLastRatio() != 0 && plugin.getMeleeHandLastHealthScale() != 0))
						{
							if (plugin.getMeleeHand().getHealthRatio() > 0)
							{
								plugin.setMeleeHandLastRatio(meleeHand.getHealthRatio());
								plugin.setMeleeHandLastHealthScale(meleeHand.getHealthScale());
							}
							drawHp(graphics, meleeHand, -75, plugin.getMeleeHandLastRatio(), plugin.getMeleeHandLastHealthScale(), true);
						}
					}
				}
			}
		}
		return null;
	}

	public Color getHPColor(float hpPercent)
	{
		hpPercent = Math.max(Math.min(100.0F, hpPercent), 0.0F);
		float rMod = 130.0F * hpPercent / 100.0F;
		float gMod = 235.0F * hpPercent / 100.0F;
		float bMod = 125.0F * hpPercent / 100.0F;
		int r = (int) Math.min(255.0F, 255.0F - rMod);
		int g = Math.min(255, (int) (0.0F + gMod));
		int b = Math.min(255, (int) (0.0F + bMod));
		return new Color(r, g, b);
	}

	private void drawHp(Graphics2D graphics, NPC npc, int offset, int ratio, int scale, boolean percent)
	{
		float health = percent ? ((float) ratio / (float) scale * 100) : ratio;
		String text = Float.toString(health);
		text = percent ? text.substring(0, text.indexOf(".")) + "%" : text.substring(0, text.indexOf("."));
		Point point = npc.getCanvasTextLocation(graphics, text, offset);

		if (point != null)
		{
			Font oldFont = graphics.getFont();
			graphics.setFont(plugin.getOverlayFont());
			drawTextBackground(graphics, point, text);
			OverlayUtil.renderTextLocation(graphics, point, text, percent ? getHPColor(health) : getHPColor((float) ratio / 600 * 100));
			graphics.setFont(oldFont);
		}
	}

	private void drawTextBackground(Graphics2D graphics, Point textLoc, String text)
	{
		switch (config.overlayFontBackground())
		{
			case OUTLINE:
			{
				OverlayUtil.renderTextLocation(graphics, new Point(textLoc.getX(), textLoc.getY() + 1), text, Color.BLACK);
				OverlayUtil.renderTextLocation(graphics, new Point(textLoc.getX(), textLoc.getY() - 1), text, Color.BLACK);
				OverlayUtil.renderTextLocation(graphics, new Point(textLoc.getX() + 1, textLoc.getY()), text, Color.BLACK);
				OverlayUtil.renderTextLocation(graphics, new Point(textLoc.getX() - 1, textLoc.getY()), text, Color.BLACK);
				break;
			}
			case SHADOW:
			{
				OverlayUtil.renderTextLocation(graphics, new Point(textLoc.getX() + 1, textLoc.getY() + 1), text, Color.BLACK);
				break;
			}
			default:
				break;
		}
	}
}

package com.coxadditions.overlay;

import com.coxadditions.CoxAdditionsConfig;
import com.coxadditions.CoxAdditionsPlugin;
import com.coxadditions.RaidsPlayers;
import com.google.common.base.Strings;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.api.Perspective;
import net.runelite.api.Player;
import net.runelite.api.Point;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.util.ImageUtil;

public class RaidsPotsStatusOverlay extends Overlay
{
	private final Client client;
	private final CoxAdditionsPlugin plugin;
	private final CoxAdditionsConfig config;

	private final ItemManager itemManager;

	@Inject
	public RaidsPotsStatusOverlay(Client client, CoxAdditionsPlugin plugin, CoxAdditionsConfig config, ItemManager itemManager)
	{
		this.client = client;
		this.plugin = plugin;
		this.config = config;

		this.itemManager = itemManager;

		setPosition(OverlayPosition.DYNAMIC);
		setPriority(OverlayPriority.HIGH);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (config.raidsPotsStatusOverlay() && plugin.isInRaid())
		{
			for (RaidsPlayers raider : plugin.getPlayersInParty())
			{
				for (Player player : client.getPlayers())
				{
					if (player.getName() != null && player.getName().equals(raider.getPlayer()))
					{
						boolean offset = false;
						if (raider.isOvlActive() && raider.getOvlTicks() >= 0)
						{
							drawTimer(graphics, "OVL", raider.getOvlTicks(), player, false);
							offset = true;
						}

						if (raider.isEnhActive() && raider.getEnhTicks() >= 0)
						{
							drawTimer(graphics, "ENH", raider.getEnhTicks(), player, offset);
						}
						break;
					}
				}
			}

			//Handle local player -> does not require party
			if (client.getLocalPlayer() != null && (plugin.getEnhanceTicks() >= 0 || plugin.getOverloadTicks() >= 0))
			{
				boolean offset = false;
				if (plugin.getOverloadTicks() >= 0)
				{
					drawTimer(graphics, "OVL", plugin.getOverloadTicks(), client.getLocalPlayer(), false);
					offset = true;
				}

				if (plugin.getEnhanceTicks() >= 0)
				{
					drawTimer(graphics, "ENH", plugin.getEnhanceTicks(), client.getLocalPlayer(), offset);
				}
			}
		}
		return null;
	}

	public void drawTimer(Graphics2D graphics, String pot, int ticks, Player player, boolean offset)
	{
		int size = config.raidsPotsIconSize();
		graphics.setFont(new Font(Font.SANS_SERIF, Font.BOLD, (int) (0.75d * size)));

		int xOffset = 5 - (size / 2);
		int yOffset = offset ? -(size + 3) : 0;

		int zOffset = player.getLogicalHeight();
		switch (config.raidsPotsHeight())
		{
			case CENTER:
				zOffset = player.getLogicalHeight() / 2;
				break;
			case FEET:
				zOffset = 0;
				break;
			case HEAD:
				zOffset = player.getLogicalHeight() + 60;
				break;
			case PRAYER:
				zOffset = player.getLogicalHeight() + 250;
		}

		Point base = Perspective.localToCanvas(client, player.getLocalLocation(), client.getPlane(), zOffset);
		BufferedImage image = pot.equals("OVL") ? itemManager.getImage(ItemID.OVERLOAD_4_20996) : itemManager.getImage(ItemID.PRAYER_ENHANCE_4);
		image = ImageUtil.resizeImage(image, size, size);

		if (base != null)
		{
			graphics.drawImage(image, base.getX() + xOffset, base.getY() - yOffset, null);
			yOffset -= size;

			String text = String.valueOf(ticks);
			if (!Strings.isNullOrEmpty(text))
			{
				int delta = image.getWidth() + 3;
				Point textPoint = new Point(base.getX() + xOffset + delta + 1, base.getY() - yOffset);

				drawTextBackground(graphics, textPoint, text, pot);
				OverlayUtil.renderTextLocation(graphics, textPoint, text, ticks < 25 ? Color.RED : Color.WHITE);
			}
		}
	}

	private void drawTextBackground(Graphics2D graphics, Point textLoc, String text, String pot)
	{
		Color color = pot.equals("OVL") ? Color.BLACK : Integer.parseInt(text) < 25 ? Color.BLACK : new Color(132, 67, 186);
		switch (config.overlayFontBackground())
		{
			case OUTLINE:
			{
				OverlayUtil.renderTextLocation(graphics, new Point(textLoc.getX(), textLoc.getY() + 1), text, color);
				OverlayUtil.renderTextLocation(graphics, new Point(textLoc.getX(), textLoc.getY() - 1), text, color);
				OverlayUtil.renderTextLocation(graphics, new Point(textLoc.getX() + 1, textLoc.getY()), text, color);
				OverlayUtil.renderTextLocation(graphics, new Point(textLoc.getX() - 1, textLoc.getY()), text, color);
				break;
			}
			case SHADOW:
			{
				OverlayUtil.renderTextLocation(graphics, new Point(textLoc.getX() + 1, textLoc.getY() + 1), text, color);
				break;
			}
			default:
				break;
		}
	}
}

package com.coxadditions.overlay;

import com.coxadditions.CoxAdditionsConfig;
import com.coxadditions.CoxAdditionsPlugin;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Varbits;
import net.runelite.client.ui.overlay.*;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

public class OlmHpPanelOverlay extends OverlayPanel
{
	private final Client client;

	private final CoxAdditionsPlugin plugin;

	private final CoxAdditionsConfig config;

	@Inject
	private OlmHpPanelOverlay(Client client, CoxAdditionsPlugin plugin, CoxAdditionsConfig config)
	{
		this.client = client;
		this.plugin = plugin;
		this.config = config;
	}

	public Dimension render(Graphics2D graphics)
	{
		if (plugin.getPanelFont() == null)
		{
			plugin.loadFont(false);
		}

		if (config.olmHandsHealth() == CoxAdditionsConfig.olmHandsHealthMode.INFOBOX && (plugin.getMageHand() != null || plugin.getMeleeHand() != null))
		{
			graphics.setFont(plugin.getPanelFont());
			panelComponent.getChildren().clear();
			NPC mageHand = plugin.getMageHand();
			NPC meleeHand = plugin.getMeleeHand();
			panelComponent.getChildren().add(TitleComponent.builder()
				.color(Color.PINK)
				.text("Olm Hands HP")
				.build());

			//Solo Hand HP
			if (client.getVarbitValue(Varbits.RAID_PARTY_SIZE) == 1)
			{
				if (mageHand != null && plugin.getMageHandHp() >= 0)
				{
					String mageText = String.valueOf(plugin.getMageHandHp());
					Color mageColor = Color.WHITE;
					if (plugin.getMageHandHp() < 100)
					{
						mageColor = Color.RED;
					}
					panelComponent.getChildren().add(LineComponent.builder()
						.leftColor(Color.CYAN)
						.left("Mage Hand:")
						.rightColor(mageColor)
						.right(mageText)
						.build());
				}

				if (meleeHand != null && plugin.getMeleeHandHp() >= 0)
				{
					String meleeText = String.valueOf(plugin.getMeleeHandHp());
					Color meleeColor = Color.WHITE;
					if (plugin.getMeleeHandHp() < 100)
					{
						meleeColor = Color.RED;
					}
					panelComponent.getChildren().add(LineComponent.builder()
						.leftColor(Color.RED)
						.left("Melee Hand:")
						.rightColor(meleeColor)
						.right(meleeText)
						.build());
				}
			}
			else
			{
				//Team Hands HP
				if (mageHand != null)
				{
					Color mageColor = Color.WHITE;
					String mageText = "";
					if (mageHand.getHealthRatio() > 0 || (plugin.getMageHandLastRatio() != 0 && plugin.getMageHandLastHealthScale() != 0))
					{
						if (mageHand.getHealthRatio() > 0)
						{
							plugin.setMageHandLastRatio(mageHand.getHealthRatio());
							plugin.setMageHandLastHealthScale(mageHand.getHealthScale());
						}

						float floatRatioMage = ((float) plugin.getMageHandLastRatio() / (float) plugin.getMageHandLastHealthScale() * 100);
						if (floatRatioMage <= 20)
						{
							mageColor = Color.RED;
						}
						mageText = Float.toString(floatRatioMage);
						mageText = mageText.substring(0, mageText.indexOf("."));
					}
					panelComponent.getChildren().add(LineComponent.builder()
						.leftColor(Color.CYAN)
						.left("Mage Hand:")
						.rightColor(mageColor)
						.right(mageText + "%")
						.build());
				}
				if (meleeHand != null)
				{
					Color meleeColor = Color.WHITE;
					String meleeText = "";
					if (meleeHand.getHealthRatio() > 0 || (plugin.getMeleeHandLastRatio() != 0 && plugin.getMeleeHandLastHealthScale() != 0))
					{
						if (plugin.getMeleeHand().getHealthRatio() > 0)
						{
							plugin.setMeleeHandLastRatio(meleeHand.getHealthRatio());
							plugin.setMeleeHandLastHealthScale(meleeHand.getHealthScale());
						}

						float floatRatioMelee = ((float) plugin.getMeleeHandLastRatio() / (float) plugin.getMeleeHandLastHealthScale() * 100);
						if (floatRatioMelee <= 20)
						{
							meleeColor = Color.RED;
						}
						meleeText = Float.toString(floatRatioMelee);
						meleeText = meleeText.substring(0, meleeText.indexOf("."));
					}
					panelComponent.getChildren().add(LineComponent.builder()
						.leftColor(Color.RED)
						.left("Melee Hand:")
						.rightColor(meleeColor)
						.right(meleeText + "%")
						.build());
				}
			}
		}
		return super.render(graphics);
	}
}

package com.coxadditions.overlay;

import com.coxadditions.CoxAdditionsConfig;
import com.coxadditions.CoxAdditionsPlugin;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;

import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

public class VanguardInfoBox extends Overlay
{
	private final CoxAdditionsPlugin plugin;
	private final CoxAdditionsConfig config;
	private final PanelComponent panelComponent = new PanelComponent();

	@Inject
	VanguardInfoBox(Client client, CoxAdditionsPlugin plugin, CoxAdditionsConfig config)
	{
		super(plugin);
		setPosition(OverlayPosition.TOP_LEFT);
		setPriority(OverlayPriority.HIGH);
		this.plugin = plugin;
		this.config = config;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!plugin.isInVangs())
		{
			return null;
		}

		if (plugin.getPanelFont() == null)
		{
			plugin.loadFont(false);
		}

		panelComponent.getChildren().clear();

		if (config.vangInfobox())
		{
			graphics.setFont(plugin.getPanelFont());
			panelComponent.getChildren().add(TitleComponent.builder()
				.text("Vanguards")
				.color(Color.pink)
				.build());
			panelComponent.getChildren().add(LineComponent.builder()
				.left("Range")
				.right(Integer.toString(plugin.getRangeHP()))
				.leftColor(Color.green)
				.build());
			panelComponent.getChildren().add(LineComponent.builder()
				.left("Mage")
				.right(Integer.toString(plugin.getMageHP()))
				.leftColor(Color.blue)
				.build());
			panelComponent.getChildren().add(LineComponent.builder()
				.left("Melee")
				.right(Integer.toString(plugin.getMeleeHP()))
				.leftColor(Color.red)
				.build());
			return panelComponent.render(graphics);
		}
		return null;
	}
}

package com.coxadditions.overlay;

import com.coxadditions.CoxAdditionsConfig;
import com.coxadditions.CoxAdditionsPlugin;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.InstanceTemplates;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.components.LineComponent;

public class VangPotsOverlay extends OverlayPanel
{
	private final Client client;

	private final CoxAdditionsConfig config;

	private final CoxAdditionsPlugin plugin;

	@Inject
	private VangPotsOverlay(Client client, CoxAdditionsPlugin plugin, CoxAdditionsConfig config)
	{
		super(plugin);
		this.client = client;
		this.plugin = plugin;
		this.config = config;
		setPosition(OverlayPosition.TOP_LEFT);
		setPriority(OverlayPriority.MED);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	public Dimension render(Graphics2D graphics)
	{
		if (plugin.getPanelFont() == null)
		{
			plugin.loadFont(false);
		}

		if (config.showPanel() && plugin.getOverloadsDropped() > 0 && plugin.isInRaid() && client.getLocalPlayer() != null)
		{
			boolean overlayRooms = (plugin.room() == InstanceTemplates.RAIDS_VANGUARDS || plugin.isInPrep());
			if (plugin.room() != null && overlayRooms)
			{
				graphics.setFont(plugin.getPanelFont());
				panelComponent.getChildren().clear();
				panelComponent.setPreferredSize(new Dimension(graphics.getFontMetrics().stringWidth("Overloads: ") + 20, 0));
				panelComponent.getChildren().add(LineComponent.builder()
					.leftColor(Color.WHITE)
					.left("Overloads: ")
					.right(String.valueOf(plugin.getOverloadsDropped()))
					.build());
			}
		}
		return super.render(graphics);
	}
}

package com.coxadditions;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Data
@AllArgsConstructor
@Getter
@Setter
public class RaidsPlayers
{
	private String player;
	private long id;
	private boolean ovlActive = false;
	private boolean enhActive = false;
	private int ovlTicks;
	private int enhTicks;

	public RaidsPlayers(String player, long id)
	{
		this.player = player;
		this.id = id;
	}

	public void updatePotStatus(String pot, int ticks)
	{
		if (pot.equals("OVL"))
		{
			ovlActive = true;
			ovlTicks = ticks;
		}
		else if (pot.equals("ENH"))
		{
			enhActive = true;
			enhTicks = ticks;
		}
	}
}

package com.coxadditions;

import java.awt.Color;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.infobox.InfoBox;
import net.runelite.client.ui.overlay.infobox.InfoBoxPriority;

public class GrubsInfobox extends InfoBox
{
	private final CoxAdditionsPlugin plugin;
	private final CoxAdditionsConfig config;

	@Inject
	public GrubsInfobox(Client client, CoxAdditionsPlugin plugin, CoxAdditionsConfig config)
	{
		super(null, plugin);
		this.plugin = plugin;
		this.config = config;
		setPriority(InfoBoxPriority.MED);
	}

	@Override
	public String getText()
	{
		return Integer.toString(plugin.getTotalGrubs());
	}

	@Override
	public Color getTextColor()
	{
		if (plugin.getTotalGrubs() >= config.grubsAmount())
		{
			return new Color(26, 204, 6);
		}

		return Color.WHITE;
	}

	@Override
	public String getTooltip()
	{
		return plugin.getTotalGrubs() + " Cavern Grubs";
	}
}

package com.coxadditions;

import net.runelite.api.Client;
import net.runelite.client.ui.overlay.infobox.InfoBox;
import net.runelite.client.ui.overlay.infobox.InfoBoxPriority;

import javax.inject.Inject;
import java.awt.*;

public class EnhanceInfobox extends InfoBox
{
	private final CoxAdditionsPlugin plugin;
	private final CoxAdditionsConfig config;

	@Inject
	public EnhanceInfobox(Client client, CoxAdditionsPlugin plugin, CoxAdditionsConfig config)
	{
		super(null, plugin);
		this.plugin = plugin;
		this.config = config;
		setPriority(InfoBoxPriority.MED);
	}

	@Override
	public String getText()
	{
		String enhanceTime = "";
		if (config.detailedPrayerEnhance() != CoxAdditionsConfig.enhanceMode.OFF)
		{
			if (config.detailedPrayerEnhance() == CoxAdditionsConfig.enhanceMode.REGEN_CYCLE)
			{
				enhanceTime = String.valueOf(plugin.getEnhanceTicks() % plugin.getEnhanceRegenRate() + 1);
			}
			else
			{
				enhanceTime = String.valueOf(plugin.getEnhanceTicks());
			}
		}

		return enhanceTime;
	}

	@Override
	public Color getTextColor()
	{
		if (plugin.getEnhanceTicks() % plugin.getEnhRegenRate() == plugin.getEnhanceRegenRate() - 1)
		{
			return new Color(26, 204, 6);
		}

		return Color.WHITE;
	}

	@Override
	public String getTooltip()
	{
		return "Prayer Enhance";
	}
}

