package com.duckblade.osrs.toa;

import static com.duckblade.osrs.toa.TombsOfAmascutConfig.CONFIG_GROUP;
import static com.duckblade.osrs.toa.TombsOfAmascutConfig.KEY_HET_PICKAXE_MENU_SWAP;
import static com.duckblade.osrs.toa.TombsOfAmascutConfig.KEY_HET_PICKAXE_PREVENT_EXIT;
import static com.duckblade.osrs.toa.TombsOfAmascutConfig.KEY_HP_ORB_MODE;
import static com.duckblade.osrs.toa.TombsOfAmascutConfig.KEY_QUICK_PROCEED_ENABLE_MODE;
import com.duckblade.osrs.toa.features.QuickProceedSwaps;
import com.duckblade.osrs.toa.features.het.pickaxe.DepositPickaxeMode;
import com.duckblade.osrs.toa.features.hporbs.HpOrbMode;
import net.runelite.client.config.ConfigManager;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class ConfigMigrationServiceTest
{

	@Mock
	private ConfigManager configManager;

	@InjectMocks
	private ConfigMigrationService configMigrationService;

	@Test
	void quickProceedFalse()
	{
		when(configManager.getConfiguration(CONFIG_GROUP, "leftClickProceedEnable", Boolean.class)).thenReturn(false);
		configMigrationService.migrateQuickProceedEnable();

		verify(configManager).unsetConfiguration(CONFIG_GROUP, "leftClickProceedEnable");
		verify(configManager).setConfiguration(CONFIG_GROUP, KEY_QUICK_PROCEED_ENABLE_MODE, QuickProceedSwaps.QuickProceedEnableMode.NONE);
		verifyNoMoreInteractions(configManager);
	}

	@Test
	void quickProceedTrue()
	{
		when(configManager.getConfiguration(CONFIG_GROUP, "leftClickProceedEnable", Boolean.class)).thenReturn(true);
		configMigrationService.migrateQuickProceedEnable();

		verify(configManager).unsetConfiguration(CONFIG_GROUP, "leftClickProceedEnable");
		verify(configManager).setConfiguration(CONFIG_GROUP, KEY_QUICK_PROCEED_ENABLE_MODE, QuickProceedSwaps.QuickProceedEnableMode.ALL);
		verifyNoMoreInteractions(configManager);
	}

	@Test
	void quickProceedNull()
	{
		when(configManager.getConfiguration(CONFIG_GROUP, "leftClickProceedEnable", Boolean.class)).thenReturn(null);
		configMigrationService.migrateQuickProceedEnable();

		verifyNoMoreInteractions(configManager);
	}

	@Test
	void hideHpOrbsFalse()
	{
		when(configManager.getConfiguration(CONFIG_GROUP, "hideHpOrbs", Boolean.class)).thenReturn(false);
		configMigrationService.migrateHideHpOrbs();

		verify(configManager).unsetConfiguration(CONFIG_GROUP, "hideHpOrbs");
		verify(configManager).setConfiguration(CONFIG_GROUP, KEY_HP_ORB_MODE, HpOrbMode.ORBS);
		verifyNoMoreInteractions(configManager);
	}

	@Test
	void hideHpOrbsTrue()
	{
		when(configManager.getConfiguration(CONFIG_GROUP, "hideHpOrbs", Boolean.class)).thenReturn(true);
		configMigrationService.migrateHideHpOrbs();

		verify(configManager).unsetConfiguration(CONFIG_GROUP, "hideHpOrbs");
		verify(configManager).setConfiguration(CONFIG_GROUP, KEY_HP_ORB_MODE, HpOrbMode.HIDDEN);
		verifyNoMoreInteractions(configManager);
	}

	@Test
	void hideHpOrbsNull()
	{
		when(configManager.getConfiguration(CONFIG_GROUP, "hideHpOrbs", Boolean.class)).thenReturn(null);
		configMigrationService.migrateHideHpOrbs();

		verifyNoMoreInteractions(configManager);
	}

	@SuppressWarnings("deprecation")
	@Test
	void pickaxeReminderBoth()
	{
		when(configManager.getConfiguration(CONFIG_GROUP, "depositPickaxeMode", DepositPickaxeMode.class)).thenReturn(DepositPickaxeMode.BOTH);
		configMigrationService.migratePickaxeReminder();

		verify(configManager).unsetConfiguration(CONFIG_GROUP, "depositPickaxeMode");
		verify(configManager).setConfiguration(CONFIG_GROUP, KEY_HET_PICKAXE_MENU_SWAP, true);
		verify(configManager).setConfiguration(CONFIG_GROUP, KEY_HET_PICKAXE_PREVENT_EXIT, true);
		verifyNoMoreInteractions(configManager);
	}

	@SuppressWarnings("deprecation")
	@Test
	void pickaxeReminderStatueSwap()
	{
		when(configManager.getConfiguration(CONFIG_GROUP, "depositPickaxeMode", DepositPickaxeMode.class)).thenReturn(DepositPickaxeMode.STATUE_SWAP);
		configMigrationService.migratePickaxeReminder();

		verify(configManager).unsetConfiguration(CONFIG_GROUP, "depositPickaxeMode");
		verify(configManager).setConfiguration(CONFIG_GROUP, KEY_HET_PICKAXE_MENU_SWAP, true);
		verify(configManager).setConfiguration(CONFIG_GROUP, KEY_HET_PICKAXE_PREVENT_EXIT, false);
		verifyNoMoreInteractions(configManager);
	}

	@SuppressWarnings("deprecation")
	@Test
	void pickaxeReminderPreventExit()
	{
		when(configManager.getConfiguration(CONFIG_GROUP, "depositPickaxeMode", DepositPickaxeMode.class)).thenReturn(DepositPickaxeMode.PREVENT_EXIT);
		configMigrationService.migratePickaxeReminder();

		verify(configManager).unsetConfiguration(CONFIG_GROUP, "depositPickaxeMode");
		verify(configManager).setConfiguration(CONFIG_GROUP, KEY_HET_PICKAXE_MENU_SWAP, false);
		verify(configManager).setConfiguration(CONFIG_GROUP, KEY_HET_PICKAXE_PREVENT_EXIT, true);
		verifyNoMoreInteractions(configManager);
	}

	@SuppressWarnings("deprecation")
	@Test
	void pickaxeReminderOff()
	{
		when(configManager.getConfiguration(CONFIG_GROUP, "depositPickaxeMode", DepositPickaxeMode.class)).thenReturn(DepositPickaxeMode.OFF);
		configMigrationService.migratePickaxeReminder();

		verify(configManager).unsetConfiguration(CONFIG_GROUP, "depositPickaxeMode");
		verify(configManager).setConfiguration(CONFIG_GROUP, KEY_HET_PICKAXE_MENU_SWAP, false);
		verify(configManager).setConfiguration(CONFIG_GROUP, KEY_HET_PICKAXE_PREVENT_EXIT, false);
		verifyNoMoreInteractions(configManager);
	}

	@SuppressWarnings("deprecation")
	@Test
	void pickaxeReminderNull()
	{
		when(configManager.getConfiguration(CONFIG_GROUP, "depositPickaxeMode", DepositPickaxeMode.class)).thenReturn(null);
		configMigrationService.migratePickaxeReminder();

		verifyNoMoreInteractions(configManager);
	}

}
package com.duckblade.osrs.toa.features.pointstracker;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.TombsOfAmascutPlugin;
import com.duckblade.osrs.toa.util.RaidRoom;
import com.duckblade.osrs.toa.util.RaidState;
import com.duckblade.osrs.toa.util.RaidStateChanged;
import com.duckblade.osrs.toa.util.RaidStateTracker;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.api.Tile;
import net.runelite.api.TileItem;
import net.runelite.api.events.ItemSpawned;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.PluginMessage;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
public class PointsTrackerTest
{

	@Getter
	static class TestSubscriber
	{
		private PluginMessage captured;

		@Subscribe
		public void onPluginMessage(PluginMessage evt)
		{
			this.captured = evt;
		}
	}

	private EventBus eventBus;
	private TestSubscriber subscriber;

	@Mock
	Client client;

	@Mock
	TombsOfAmascutConfig config;

	@Mock
	PartyPointsTracker partyPointsTracker;

	@Mock
	RaidStateTracker raidStateTracker;

	PointsTracker pointsTracker;

	@BeforeEach
	void setUp()
	{
		subscriber = new TestSubscriber();
		eventBus = new EventBus();
		eventBus.register(subscriber);

		pointsTracker = new PointsTracker(
			eventBus,
			client,
			config,
			partyPointsTracker,
			raidStateTracker
		);
		pointsTracker.startUp();
	}

	@Test
	void testPointsEvent()
	{
		when(partyPointsTracker.isInParty()).thenReturn(true);
		when(partyPointsTracker.getTotalPartyPoints()).thenReturn(600);
		when(config.pointsTrackerAllowExternal()).thenReturn(true);

		RaidStateChanged raidStartEvent = new RaidStateChanged(new RaidState(true, false, null, -1), new RaidState(false, true, RaidRoom.BABA, 1));
		pointsTracker.onRaidStateChanged(raidStartEvent);

		TileItem bigBanana = mock(TileItem.class);
		when(bigBanana.getId()).thenReturn(ItemID.BIG_BANANA);
		ItemSpawned earnPointsEvent = new ItemSpawned(mock(Tile.class), bigBanana);
		pointsTracker.onItemSpawned(earnPointsEvent);

		RaidStateChanged raidEndEvent = new RaidStateChanged(new RaidState(false, true, RaidRoom.WARDENS, 1), new RaidState(false, true, RaidRoom.TOMB, 1));
		pointsTracker.onRaidStateChanged(raidEndEvent);

		PluginMessage pointsEvent = subscriber.getCaptured();
		assertNotNull(pointsEvent);
		assertEquals(TombsOfAmascutPlugin.EVENT_NAMESPACE, pointsEvent.getNamespace());
		assertEquals("raidCompletedPoints", pointsEvent.getName());
		assertEquals(1, pointsEvent.getData().get("version"));
		assertEquals(600, pointsEvent.getData().get("totalPoints"));
		assertEquals(300, pointsEvent.getData().get("personalPoints"));
	}

}

package launcher.debugplugins;

import com.duckblade.osrs.toa.features.het.solver.HetSolution;
import com.duckblade.osrs.toa.features.het.solver.HetSolver;
import com.duckblade.osrs.toa.util.RaidRoom;
import com.duckblade.osrs.toa.util.RaidStateTracker;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Point;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

@Singleton
public class HetSolverDebugOverlay extends OverlayPanel
{

	@Inject
	private HetSolver hetSolver;

	@Inject
	private RaidStateTracker raidStateTracker;

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (raidStateTracker.getCurrentState().getCurrentRoom() != RaidRoom.HET)
		{
			return null;
		}

		getPanelComponent()
			.getChildren()
			.add(TitleComponent.builder()
				.text("Het Debug")
				.build());

		Point puzzleBase = hetSolver.getPuzzleBase();
		addLine("Base:", puzzleBase == null ? "?, ?" : puzzleBase.getX() + ", " + puzzleBase.getY());

		HetSolution solution = hetSolver.getSolution();
		addLine("Solution:", solution == null ? "null" : solution.name());

		for (HetSolution sol : HetSolution.values())
		{
			if (sol.getLastScore() != null)
			{
				addLine(sol.name(), sol.getLastScore().getOverlayString());
			}
		}

		return super.render(graphics);
	}

	private void addLine(String left, String right)
	{
		getPanelComponent()
			.getChildren()
			.add(LineComponent.builder()
				.left(left)
				.right(right)
				.build());
	}
}

package launcher.debugplugins;

import ch.qos.logback.classic.Level;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import ch.qos.logback.classic.Logger;
import net.runelite.client.ui.overlay.OverlayManager;
import org.slf4j.LoggerFactory;

@Singleton
@PluginDescriptor(
	name = "ToA Debug"
)
public class ToaDebugPlugin extends Plugin
{

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private HetSolverDebugOverlay hetSolverDebugOverlay;

	@Inject
	private AkkhaShadowOverridesOverlay shadowOverridesOverlay;

	@Inject
	private EventBus eventBus;

	@Override
	protected void startUp()
	{
		((Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME)).setLevel(Level.WARN);
		((Logger) LoggerFactory.getLogger("com.duckblade.osrs.toa")).setLevel(Level.DEBUG);

		overlayManager.add(hetSolverDebugOverlay);
		overlayManager.add(shadowOverridesOverlay);
		eventBus.register(shadowOverridesOverlay);
	}

	@Override
	protected void shutDown() throws Exception
	{
		((Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME)).setLevel(Level.DEBUG);
		overlayManager.remove(hetSolverDebugOverlay);
		overlayManager.remove(shadowOverridesOverlay);
		eventBus.unregister(shadowOverridesOverlay);
	}
}

package launcher.debugplugins;

import com.duckblade.osrs.toa.util.FontStyle;
import com.duckblade.osrs.toa.util.OverlayUtil;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Set;
import java.util.TreeSet;
import javax.inject.Singleton;
import net.runelite.api.Model;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;
import net.runelite.api.NpcOverrides;
import net.runelite.api.Point;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

@Singleton
public class AkkhaShadowOverridesOverlay extends Overlay
{

	private final Set<NPC> shadows = new TreeSet<>(Comparator.comparing(NPC::getIndex));

	public AkkhaShadowOverridesOverlay()
	{
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned e)
	{
		if (e.getNpc().getId() == NpcID.AKKHAS_SHADOW)
		{
			shadows.add(e.getNpc());
		}
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned e)
	{
		if (e.getNpc().getId() == NpcID.AKKHAS_SHADOW)
		{
			shadows.remove(e.getNpc());
		}
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		shadows.forEach((npc) ->
		{
			{
				final Model m = npc.getModel();
				final String text = "H: " + m.getOverrideHue() + " S: " + m.getOverrideSaturation() + " L: " + m.getOverrideLuminance() + " X: " + m.getOverrideAmount();
				Point point = npc.getCanvasTextLocation(graphics, text, 0);
				if (point != null)
				{
					point = new Point(point.getX(), point.getY() - 20);
					OverlayUtil.renderTextLocation(graphics, point, text, Color.WHITE, 12, FontStyle.PLAIN.getFont(), true);
				}
			}

			NpcOverrides overrides = npc.getModelOverrides();
			if (overrides == null)
			{
				return;
			}

			StringBuilder sb = new StringBuilder();
			if (overrides.getModelIds() != null)
			{
				sb.append("M: ");
				sb.append(Arrays.toString(overrides.getModelIds()));
			}
			if (overrides.getColorToReplaceWith() != null)
			{
				sb.append("C: ");
				sb.append(Arrays.toString(overrides.getColorToReplaceWith()));
			}
			if (overrides.getTextureToReplaceWith() != null)
			{
				sb.append("T: ");
				sb.append(Arrays.toString(overrides.getTextureToReplaceWith()));
			}

			final String text = sb.toString();
			Point point = npc.getCanvasTextLocation(graphics, text, 0);
			if (point != null)
			{
				point = new Point(point.getX(), point.getY() + 20);
				OverlayUtil.renderTextLocation(graphics, point, text, Color.WHITE, 12, FontStyle.PLAIN.getFont(), true);
			}
		});
		return null;
	}
}

package launcher;

import com.duckblade.osrs.toa.TombsOfAmascutPlugin;
import launcher.debugplugins.ToaDebugPlugin;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class TombsOfAmascutPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(TombsOfAmascutPlugin.class, ToaDebugPlugin.class);
		RuneLite.main(args);
	}
}
package com.duckblade.osrs.toa.util;

import java.awt.Color;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum RaidMode
{

	ENTRY_MODE(0, 149, new Color(255, 208, 73)),
	NORMAL(150, 299, new Color(60, 79, 144)),
	EXPERT_MODE(300, Integer.MAX_VALUE, new Color(190, 38, 51)),
	;

	private final int minRaidLevel;
	private final int maxRaidLevel;

	@Getter
	private final Color color;

	public static RaidMode forRaidLevel(int raidLevel)
	{
		for (RaidMode mode : RaidMode.values())
		{
			if (mode.minRaidLevel <= raidLevel && raidLevel <= mode.maxRaidLevel)
			{
				return mode;
			}
		}

		throw new IllegalArgumentException("No raid mode exists for raid level " + raidLevel);
	}

}

package com.duckblade.osrs.toa.util;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum RaidRoom
{

	NEXUS(new int[]{14160}, "Nexus", RaidRoomType.LOBBY),
	CRONDIS(new int[]{15698}, "Crondis", RaidRoomType.PUZZLE),
	ZEBAK(new int[]{15700}, "Zebak", RaidRoomType.BOSS),
	SCABARAS(new int[]{14162}, "Scabaras", RaidRoomType.PUZZLE),
	KEPHRI(new int[]{14164}, "Kephri", RaidRoomType.BOSS),
	APMEKEN(new int[]{15186}, "Apmeken", RaidRoomType.PUZZLE),
	BABA(new int[]{15188}, "Ba-Ba", RaidRoomType.BOSS),
	HET(new int[]{14674}, "Het", RaidRoomType.PUZZLE),
	AKKHA(new int[]{14676}, "Akkha", RaidRoomType.BOSS),
	WARDENS(new int[]{15184, 15696}, "Wardens", RaidRoomType.BOSS),
	TOMB(new int[]{14672}, "Tomb", RaidRoomType.LOBBY),
	;

	public enum RaidRoomType
	{
		LOBBY,
		PUZZLE,
		BOSS,
		;
	}

	private final int[] regionIds;

	@Getter
	private final String displayName;

	@Getter
	private final RaidRoomType roomType;

	public static RaidRoom forRegionId(int region)
	{
		for (RaidRoom r : RaidRoom.values())
		{
			for (int regionId : r.regionIds)
			{
				if (regionId == region)
				{
					return r;
				}
			}
		}

		return null;
	}

	public static RaidRoom forString(String roomName)
	{
		for (RaidRoom r : RaidRoom.values())
		{
			if (r.getDisplayName().equals(roomName))
			{
				return r;
			}
		}

		return null;
	}

	@Override
	public String toString()
	{
		return displayName;
	}
}

package com.duckblade.osrs.toa.util;

import java.awt.Font;
import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public
enum FontStyle
{
	PLAIN("Plain", Font.PLAIN),
	BOLD("Bold", Font.BOLD),
	ITALIC("Italic", Font.ITALIC);

	private final String name;
	private final int font;

	@Override
	public String toString()
	{
		return name;
	}
}

package com.duckblade.osrs.toa.util;

import lombok.Value;

@Value
public class RaidStateChanged
{

	private final RaidState previousState;
	private final RaidState newState;

}

package com.duckblade.osrs.toa.util;

import lombok.Value;

@Value
public class RaidState
{

	private final boolean inLobby;
	private final boolean inRaid;
	private final RaidRoom currentRoom;
	private final int playerCount;

}

package com.duckblade.osrs.toa.util;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import lombok.experimental.UtilityClass;
import net.runelite.api.Point;
import java.awt.Shape;
import java.awt.Stroke;

@UtilityClass
public final class OverlayUtil
{

	public static void drawOutlineAndFill(final Graphics2D graphics2D, final Color outlineColor, final Color fillColor, final float strokeWidth, final Shape shape)
	{
		final Color originalColor = graphics2D.getColor();
		final Stroke originalStroke = graphics2D.getStroke();

		graphics2D.setStroke(new BasicStroke(strokeWidth));
		graphics2D.setColor(outlineColor);
		graphics2D.draw(shape);

		graphics2D.setColor(fillColor);
		graphics2D.fill(shape);

		graphics2D.setColor(originalColor);
		graphics2D.setStroke(originalStroke);
	}

	public static void renderTextLocation(final Graphics2D graphics2D, final Point point, final String text, final Color color, final int size, final int style, final boolean shadow)
	{
		if (text == null || text.isEmpty())
		{
			return;
		}

		final Color origColor = graphics2D.getColor();
		final Font origFont = graphics2D.getFont();

		graphics2D.setFont(new Font(null, style, size));

		if (shadow)
		{
			graphics2D.setColor(Color.BLACK);
			graphics2D.drawString(text, point.getX() + 1, point.getY() + 1);
		}

		graphics2D.setColor(color);
		graphics2D.drawString(text, point.getX(), point.getY());

		graphics2D.setFont(origFont);
		graphics2D.setColor(origColor);
	}

}

package com.duckblade.osrs.toa.util;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum Invocation
{

	TRY_AGAIN(5),
	PERSISTENCE(10),
	SOFTCORE_RUN(15),
	HARDCORE_RUN(25),
	WALK_FOR_IT(10),
	JOG_FOR_IT(15),
	RUN_FOR_IT(20),
	SPRINT_FOR_IT(25),
	NEED_SOME_HELP(15),
	NEED_LESS_HELP(25),
	NO_HELP_NEEDED(40),
	WALK_THE_PATH(50),
	PATHSEEKER(15),
	PATHFINDER(40),
	PATHMASTER(50),
	QUIET_PRAYERS(20),
	DEADLY_PRAYERS(20),
	ON_A_DIET(15),
	DEHYDRATION(30),
	OVERLY_DRAINING(15),
	LIVELY_LARVAE(5),
	MORE_OVERLORDS(15),
	BLOWING_MUD(10),
	MEDIC(15),
	AERIAL_ASSAULT(10),
	NOT_JUST_A_HEAD(15),
	ARTERIAL_SPRAY(10),
	BLOOD_THINNERS(5),
	UPSET_STOMACH(15),
	DOUBLE_TROUBLE(20),
	KEEP_BACK(10),
	STAY_VIGILANT(15),
	FEELING_SPECIAL(20),
	MIND_THE_GAP(10),
	GOTTA_HAVE_FAITH(10),
	JUNGLE_JAPES(5),
	SHAKING_THINGS_UP(10),
	BOULDERDASH(10),
	ANCIENT_HASTE(10),
	ACCELERATION(10),
	PENETRATION(10),
	OVERCLOCKED(10),
	OVERCLOCKED_2(10),
	INSANITY(50),
	;

	@Getter
	private final int raidLevel;

	public int getWidgetIx()
	{
		return ordinal() * 3;
	}

}

package com.duckblade.osrs.toa.util;

import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.Varbits;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class RaidStateTracker implements PluginLifecycleComponent
{

	private static final int REGION_LOBBY = 13454;
	private static final int WIDGET_PARENT_ID = 481;
	private static final int WIDGET_CHILD_ID = 40;

	private static final RaidState DEFAULT_STATE = new RaidState(false, false, null, 0);

	private final Client client;
	private final EventBus eventBus;

	@Getter
	private RaidState currentState = DEFAULT_STATE;

	// delay inRaid = false by 3 ticks to alleviate any unexpected delays between rooms
	private int raidLeaveTicks = 0;

	@Override
	public void startUp()
	{
		eventBus.register(this);
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
	}

	@Subscribe(priority = 5)
	public void onGameTick(GameTick e)
	{
		LocalPoint lp = client.getLocalPlayer().getLocalLocation();
		int region = lp == null ? -1 : WorldPoint.fromLocalInstance(client, lp).getRegionID();

		Widget w = client.getWidget(WIDGET_PARENT_ID, WIDGET_CHILD_ID);

		boolean inLobby = region == REGION_LOBBY;
		RaidRoom currentRoom = RaidRoom.forRegionId(region);
		boolean inRaidRaw = currentRoom != null || (w != null && !w.isHidden());

		raidLeaveTicks = inRaidRaw ? 3 : raidLeaveTicks - 1;
		boolean inRaid = raidLeaveTicks > 0;

		setRaidState(new RaidState(inLobby, inRaid, currentRoom, countPlayers()), false);
	}

	public int getPlayerCount()
	{
		return this.currentState.getPlayerCount();
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged e)
	{
		switch (e.getGameState())
		{
			case LOGGING_IN:
			case HOPPING:
				raidLeaveTicks = 0;
				setRaidState(DEFAULT_STATE, true);
		}
	}

	private void setRaidState(RaidState newValue, boolean forceEvent)
	{
		RaidState previous = currentState;
		currentState = newValue;

		if (forceEvent || !currentState.equals(previous))
		{
			eventBus.post(new RaidStateChanged(previous, currentState));
		}
	}

	private int countPlayers()
	{
		return 1 +
			(client.getVarbitValue(Varbits.TOA_MEMBER_1_HEALTH) != 0 ? 1 : 0) +
			(client.getVarbitValue(Varbits.TOA_MEMBER_2_HEALTH) != 0 ? 1 : 0) +
			(client.getVarbitValue(Varbits.TOA_MEMBER_3_HEALTH) != 0 ? 1 : 0) +
			(client.getVarbitValue(Varbits.TOA_MEMBER_4_HEALTH) != 0 ? 1 : 0) +
			(client.getVarbitValue(Varbits.TOA_MEMBER_5_HEALTH) != 0 ? 1 : 0) +
			(client.getVarbitValue(Varbits.TOA_MEMBER_6_HEALTH) != 0 ? 1 : 0) +
			(client.getVarbitValue(Varbits.TOA_MEMBER_7_HEALTH) != 0 ? 1 : 0);
	}
}
package com.duckblade.osrs.toa.util;

import net.runelite.api.Client;

public enum TimerMode
{

	PRECISE,
	LAX,
	;

	private static final int VARBIT_PRECISE_TIMING = 11866;

	public static TimerMode fromClient(Client c)
	{
		assert c.isClientThread();
		return c.getVarbitValue(VARBIT_PRECISE_TIMING) == 1 ? PRECISE : LAX;
	}

}

package com.duckblade.osrs.toa.util;

import java.util.Set;
import net.runelite.api.Client;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;

public class InventoryUtil
{

	public static boolean containsAny(Client client, Set<Integer> ids)
	{
		ItemContainer inv = client.getItemContainer(InventoryID.INVENTORY);
		return containsAny(inv, ids);
	}

	public static boolean containsAny(ItemContainer inv, Set<Integer> ids)
	{
		if (inv == null)
		{
			return false;
		}

		for (Item item : inv.getItems())
		{
			if (ids.contains(item.getId()))
			{
				return true;
			}
		}

		return false;
	}

}

package com.duckblade.osrs.toa.util;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum HighlightMode
{
	OFF("Off"),
	OUTLINE("Outline"),
	TILE("Tile"),
	TRUE_TILE("True Tile"),
	;

	private final String name;

	@Override
	public String toString()
	{
		return this.name;
	}
}

/*
 * Copyright (c) 2016-2018, Adam <Adam@sigterm.info>
 * Copyright (c) 2018, Jordan Atwood <jordan.atwood423@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.duckblade.osrs.toa.util;

import net.runelite.api.Actor;

public final class NpcUtil
{
	private NpcUtil()
	{
	}

	/**
	 * Calculates Actor's current hitpoints
	 * <p>
	 * Adapted from RuneLite OpponentInfo Plugin
	 *
	 * @param actor the actor
	 * @param maxHp the actor's max hp
	 * @return the actor's current hp, else -1
	 */
	public static int calculateActorHp(final Actor actor, final int maxHp)
	{
		final int scale = actor.getHealthScale();
		final int ratio = actor.getHealthRatio();

		if (scale <= 0 || ratio < 0)
		{
			return -1;
		}

		int health = 0;

		if (ratio > 0)
		{
			int minHealth = 1;
			int maxHealth;

			if (scale > 1)
			{
				if (ratio > 1)
				{
					minHealth = (maxHp * (ratio - 1) + scale - 2) / (scale - 1);
				}

				maxHealth = (maxHp * ratio - 1) / (scale - 1);

				if (maxHealth > maxHp)
				{
					maxHealth = maxHp;
				}
			}
			else
			{
				maxHealth = maxHp;
			}

			health = (minHealth + maxHealth + 1) / 2;
		}

		return health;
	}
}

package com.duckblade.osrs.toa;

import static com.duckblade.osrs.toa.TombsOfAmascutConfig.CONFIG_GROUP;
import static com.duckblade.osrs.toa.TombsOfAmascutConfig.KEY_HET_PICKAXE_MENU_SWAP;
import static com.duckblade.osrs.toa.TombsOfAmascutConfig.KEY_HET_PICKAXE_PREVENT_EXIT;
import static com.duckblade.osrs.toa.TombsOfAmascutConfig.KEY_HP_ORB_MODE;
import static com.duckblade.osrs.toa.TombsOfAmascutConfig.KEY_QUICK_PROCEED_ENABLE_MODE;
import com.duckblade.osrs.toa.features.QuickProceedSwaps;
import com.duckblade.osrs.toa.features.het.pickaxe.DepositPickaxeMode;
import com.duckblade.osrs.toa.features.hporbs.HpOrbMode;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableMap;
import java.util.Collections;
import java.util.Map;
import java.util.function.Function;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.client.config.ConfigManager;

@Singleton
public class ConfigMigrationService
{

	@Inject
	private ConfigManager configManager;

	void migrate()
	{
		migrateQuickProceedEnable();
		migrateHideHpOrbs();
		migratePickaxeReminder();
	}

	@VisibleForTesting
	void migrateQuickProceedEnable()
	{
		migrate(
			"leftClickProceedEnable",
			KEY_QUICK_PROCEED_ENABLE_MODE,
			Boolean.class,
			enabled -> enabled ? QuickProceedSwaps.QuickProceedEnableMode.ALL : QuickProceedSwaps.QuickProceedEnableMode.NONE
		);
	}

	@VisibleForTesting
	void migrateHideHpOrbs()
	{
		migrate(
			"hideHpOrbs",
			KEY_HP_ORB_MODE,
			Boolean.class,
			enabled -> enabled ? HpOrbMode.HIDDEN : HpOrbMode.ORBS
		);
	}

	@SuppressWarnings("deprecation")
	@VisibleForTesting
	void migratePickaxeReminder()
	{
		migrateMany(
			"depositPickaxeMode",
			DepositPickaxeMode.class,
			mode -> ImmutableMap.of(
				KEY_HET_PICKAXE_MENU_SWAP, mode.isSwapStatue(),
				KEY_HET_PICKAXE_PREVENT_EXIT, mode.isSwapExit()
			)
		);
	}

	private <Source, Dest> void migrate(String oldKey, String newKey, Class<Source> sourceType, Function<Source, Dest> migration)
	{
		migrateMany(oldKey, sourceType, s -> Collections.singletonMap(newKey, migration.apply(s)));
	}

	private <Source> void migrateMany(String oldKey, Class<Source> sourceType, Function<Source, Map<String, Object>> migration)
	{
		Source previousEntry = configManager.getConfiguration(CONFIG_GROUP, oldKey, sourceType);
		if (previousEntry != null)
		{
			configManager.unsetConfiguration(CONFIG_GROUP, oldKey);
			Map<String, Object> newEntries = migration.apply(previousEntry);
			newEntries.forEach((k, v) -> configManager.setConfiguration(CONFIG_GROUP, k, v));
		}
	}

}

package com.duckblade.osrs.toa.module;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.util.RaidState;
import com.duckblade.osrs.toa.util.RaidStateChanged;
import com.duckblade.osrs.toa.util.RaidStateTracker;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.util.GameEventManager;

/**
 * Manages all the subcomponents of the plugin
 * so they can register themselves to RuneLite resources
 * e.g. EventBus/OverlayManager/init on startup/etc
 * instead of the TombsOfAmascutPlugin class handling everything.
 */
@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
@Slf4j
public class ComponentManager
{

	private final EventBus eventBus;
	private final GameEventManager gameEventManager;
	private final TombsOfAmascutConfig config;
	private final RaidStateTracker raidStateTracker;
	private final Set<PluginLifecycleComponent> components;

	private final Map<PluginLifecycleComponent, Boolean> states = new HashMap<>();

	public void onPluginStart()
	{
		eventBus.register(this);
		components.forEach(c -> states.put(c, false));
		revalidateComponentStates();
	}

	public void onPluginStop()
	{
		eventBus.unregister(this);
		components.stream()
			.filter(states::get)
			.forEach(this::tryShutDown);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged e)
	{
		if (!TombsOfAmascutConfig.CONFIG_GROUP.equals(e.getGroup()))
		{
			return;
		}

		revalidateComponentStates();
	}

	@Subscribe
	public void onRaidStateChanged(RaidStateChanged e)
	{
		revalidateComponentStates();
	}

	private void revalidateComponentStates()
	{
		RaidState raidState = raidStateTracker.getCurrentState();
		components.forEach(c ->
		{
			boolean shouldBeEnabled = c.isEnabled(config, raidState);
			boolean isEnabled = states.get(c);
			if (shouldBeEnabled == isEnabled)
			{
				return;
			}

			if (shouldBeEnabled)
			{
				tryStartUp(c);
			}
			else
			{
				tryShutDown(c);
			}
		});
	}

	private void tryStartUp(PluginLifecycleComponent component)
	{
		if (states.get(component))
		{
			return;
		}

		if (log.isDebugEnabled())
		{
			log.debug("Enabling ToA plugin component [{}]", component.getClass().getName());
		}

		try
		{
			component.startUp();
			gameEventManager.simulateGameEvents(component);
			states.put(component, true);
		}
		catch (Exception e)
		{
			log.error("Failed to start ToA plugin component [{}]", component.getClass().getName(), e);
		}
	}

	private void tryShutDown(PluginLifecycleComponent component)
	{
		if (!states.get(component))
		{
			return;
		}

		if (log.isDebugEnabled())
		{
			log.debug("Disabling ToA plugin component [{}]", component.getClass().getName());
		}

		try
		{
			component.shutDown();
		}
		catch (Exception e)
		{
			log.error("Failed to cleanly shut down ToA plugin component [{}]", component.getClass().getName());
		}
		finally
		{
			states.put(component, false);
		}
	}

}

package com.duckblade.osrs.toa.module;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.features.CameraShakeDisabler;
import com.duckblade.osrs.toa.features.FadeDisabler;
import com.duckblade.osrs.toa.features.InvocationScreenshot;
import com.duckblade.osrs.toa.features.LeftClickBankAll;
import com.duckblade.osrs.toa.features.SmellingSaltsCooldown;
import com.duckblade.osrs.toa.features.boss.akkha.AkkhaShadowHealth;
import com.duckblade.osrs.toa.features.boss.akkha.AkkhaShadowHealthOverlay;
import com.duckblade.osrs.toa.features.apmeken.ApmekenBaboonIndicator;
import com.duckblade.osrs.toa.features.apmeken.ApmekenBaboonIndicatorOverlay;
import com.duckblade.osrs.toa.features.boss.kephri.swarmer.SwarmerDataManager;
import com.duckblade.osrs.toa.features.boss.kephri.swarmer.SwarmerOverlay;
import com.duckblade.osrs.toa.features.boss.kephri.swarmer.SwarmerPanelManager;
import com.duckblade.osrs.toa.features.het.pickaxe.DepositPickaxeOverlay;
import com.duckblade.osrs.toa.features.het.pickaxe.DepositPickaxePreventEntry;
import com.duckblade.osrs.toa.features.het.solver.HetSolver;
import com.duckblade.osrs.toa.features.het.solver.HetSolverOverlay;
import com.duckblade.osrs.toa.features.hporbs.HpOrbManager;
import com.duckblade.osrs.toa.features.QuickProceedSwaps;
import com.duckblade.osrs.toa.features.apmeken.ApmekenWaveInstaller;
import com.duckblade.osrs.toa.features.het.beamtimer.BeamTimerOverlay;
import com.duckblade.osrs.toa.features.het.beamtimer.BeamTimerTracker;
import com.duckblade.osrs.toa.features.het.pickaxe.DepositPickaxeSwap;
import com.duckblade.osrs.toa.features.invocationpresets.InvocationPresetsManager;
import com.duckblade.osrs.toa.features.PathLevelTracker;
import com.duckblade.osrs.toa.features.pointstracker.PartyPointsTracker;
import com.duckblade.osrs.toa.features.pointstracker.PointsOverlay;
import com.duckblade.osrs.toa.features.pointstracker.PointsTracker;
import com.duckblade.osrs.toa.features.scabaras.SkipObeliskOverlay;
import com.duckblade.osrs.toa.features.scabaras.overlay.AdditionPuzzleSolver;
import com.duckblade.osrs.toa.features.scabaras.overlay.LightPuzzleSolver;
import com.duckblade.osrs.toa.features.scabaras.overlay.MatchingPuzzleSolver;
import com.duckblade.osrs.toa.features.scabaras.overlay.ObeliskPuzzleSolver;
import com.duckblade.osrs.toa.features.scabaras.overlay.ScabarasOverlayManager;
import com.duckblade.osrs.toa.features.scabaras.overlay.SequencePuzzleSolver;
import com.duckblade.osrs.toa.features.scabaras.panel.ScabarasPanelManager;
import com.duckblade.osrs.toa.features.timetracking.SplitsOverlay;
import com.duckblade.osrs.toa.features.timetracking.SplitsTracker;
import com.duckblade.osrs.toa.features.timetracking.TargetTimeManager;
import com.duckblade.osrs.toa.features.tomb.CursedPhalanxDetector;
import com.duckblade.osrs.toa.features.tomb.DryStreakTracker;
import com.duckblade.osrs.toa.features.tomb.SarcophagusRecolorer;
import com.duckblade.osrs.toa.features.tomb.SarcophagusOpeningSoundPlayer;
import com.duckblade.osrs.toa.features.updatenotifier.UpdateNotifier;
import com.duckblade.osrs.toa.util.RaidStateTracker;
import com.google.inject.AbstractModule;
import com.google.inject.Provides;
import com.google.inject.Singleton;
import com.google.inject.multibindings.Multibinder;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;

@Slf4j
public class TombsOfAmascutModule extends AbstractModule
{

	@Override
	protected void configure()
	{
		Multibinder<PluginLifecycleComponent> lifecycleComponents = Multibinder.newSetBinder(binder(), PluginLifecycleComponent.class);
		lifecycleComponents.addBinding().to(AdditionPuzzleSolver.class);
		lifecycleComponents.addBinding().to(AkkhaShadowHealth.class);
		lifecycleComponents.addBinding().to(AkkhaShadowHealthOverlay.class);
		lifecycleComponents.addBinding().to(ApmekenBaboonIndicator.class);
		lifecycleComponents.addBinding().to(ApmekenBaboonIndicatorOverlay.class);
		lifecycleComponents.addBinding().to(ApmekenWaveInstaller.class);
		lifecycleComponents.addBinding().to(BeamTimerOverlay.class);
		lifecycleComponents.addBinding().to(BeamTimerTracker.class);
		lifecycleComponents.addBinding().to(CameraShakeDisabler.class);
		lifecycleComponents.addBinding().to(CursedPhalanxDetector.class);
		lifecycleComponents.addBinding().to(DepositPickaxeOverlay.class);
		lifecycleComponents.addBinding().to(DepositPickaxePreventEntry.class);
		lifecycleComponents.addBinding().to(DepositPickaxeSwap.class);
		lifecycleComponents.addBinding().to(DryStreakTracker.class);
		lifecycleComponents.addBinding().to(FadeDisabler.class);
		lifecycleComponents.addBinding().to(HetSolver.class);
		lifecycleComponents.addBinding().to(HetSolverOverlay.class);
		lifecycleComponents.addBinding().to(HpOrbManager.class);
		lifecycleComponents.addBinding().to(InvocationPresetsManager.class);
		lifecycleComponents.addBinding().to(InvocationScreenshot.class);
		lifecycleComponents.addBinding().to(LeftClickBankAll.class);
		lifecycleComponents.addBinding().to(LightPuzzleSolver.class);
		lifecycleComponents.addBinding().to(MatchingPuzzleSolver.class);
		lifecycleComponents.addBinding().to(ObeliskPuzzleSolver.class);
		lifecycleComponents.addBinding().to(PartyPointsTracker.class);
		lifecycleComponents.addBinding().to(PathLevelTracker.class);
		lifecycleComponents.addBinding().to(PointsOverlay.class);
		lifecycleComponents.addBinding().to(PointsTracker.class);
		lifecycleComponents.addBinding().to(QuickProceedSwaps.class);
		lifecycleComponents.addBinding().to(RaidStateTracker.class);
		lifecycleComponents.addBinding().to(SarcophagusOpeningSoundPlayer.class);
		lifecycleComponents.addBinding().to(SarcophagusRecolorer.class);
		lifecycleComponents.addBinding().to(ScabarasOverlayManager.class);
		lifecycleComponents.addBinding().to(ScabarasPanelManager.class);
		lifecycleComponents.addBinding().to(SequencePuzzleSolver.class);
		lifecycleComponents.addBinding().to(SkipObeliskOverlay.class);
		lifecycleComponents.addBinding().to(SmellingSaltsCooldown.class);
		lifecycleComponents.addBinding().to(SplitsOverlay.class);
		lifecycleComponents.addBinding().to(SplitsTracker.class);
		lifecycleComponents.addBinding().to(SwarmerOverlay.class);
		lifecycleComponents.addBinding().to(SwarmerPanelManager.class);
		lifecycleComponents.addBinding().to(SwarmerDataManager.class);
		lifecycleComponents.addBinding().to(TargetTimeManager.class);
		lifecycleComponents.addBinding().to(UpdateNotifier.class);
	}

	@Provides
	@Singleton
	TombsOfAmascutConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(TombsOfAmascutConfig.class);
	}

}

package com.duckblade.osrs.toa.module;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.util.RaidState;

public interface PluginLifecycleComponent
{

	default boolean isEnabled(TombsOfAmascutConfig config, RaidState raidState)
	{
		return true;
	}

	void startUp();

	void shutDown();

}

package com.duckblade.osrs.toa;

import com.duckblade.osrs.toa.module.ComponentManager;
import com.duckblade.osrs.toa.module.TombsOfAmascutModule;
import com.google.inject.Binder;
import java.io.File;
import com.google.inject.Inject;
import com.google.inject.Injector;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;

@Slf4j
@PluginDescriptor(
	name = "Tombs of Amascut",
	description = "Utilities and information for raiding the Tombs of Amascut.",
	tags = {"toa", "raid", "3", "invocation", "preset"}
)
public class TombsOfAmascutPlugin extends Plugin
{

	public static final String EVENT_NAMESPACE = "tombs-of-amascut";

	public static final File TOA_FOLDER = new File(RuneLite.RUNELITE_DIR, "tombs-of-amascut");

	@Inject
	private Injector injector;

	@Inject
	private ConfigMigrationService configMigrationService;

	private ComponentManager componentManager = null;

	@Override
	public void configure(Binder binder)
	{
		binder.install(new TombsOfAmascutModule());
	}

	@Override
	protected void startUp() throws Exception
	{
		if (!TOA_FOLDER.exists() && !TOA_FOLDER.mkdirs())
		{
			log.warn("Failed to create ToA folder {}", TOA_FOLDER.getAbsolutePath());
		}
		configMigrationService.migrate();

		if (componentManager == null)
		{
			componentManager = injector.getInstance(ComponentManager.class);
		}
		componentManager.onPluginStart();
	}

	@Override
	protected void shutDown() throws Exception
	{
		componentManager.onPluginStop();
	}
}

package com.duckblade.osrs.toa;

import com.duckblade.osrs.toa.features.QuickProceedSwaps.QuickProceedEnableMode;
import com.duckblade.osrs.toa.features.boss.kephri.swarmer.SwarmerFonts;
import com.duckblade.osrs.toa.features.boss.kephri.swarmer.SwarmerPanelManager;
import com.duckblade.osrs.toa.features.hporbs.HpOrbMode;
import com.duckblade.osrs.toa.features.scabaras.ScabarasHelperMode;
import com.duckblade.osrs.toa.features.scabaras.SkipObeliskOverlay;
import com.duckblade.osrs.toa.features.scabaras.overlay.MatchingTileDisplayMode;
import com.duckblade.osrs.toa.features.timetracking.SplitsMode;
import com.duckblade.osrs.toa.features.updatenotifier.UpdateNotifier;
import com.duckblade.osrs.toa.util.FontStyle;
import com.duckblade.osrs.toa.util.HighlightMode;
import java.awt.Color;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;
import net.runelite.client.config.Units;

@ConfigGroup(TombsOfAmascutConfig.CONFIG_GROUP)
public interface TombsOfAmascutConfig extends Config
{

	String CONFIG_GROUP = "tombsofamascut";

	// Sections

	@ConfigSection(
		name = "Miscellaneous",
		description = "Miscellaneous configurations.",
		position = 0,
		closedByDefault = false
	)
	String SECTION_MISCELLANEOUS = "sectionMiscellaneous";

	@ConfigSection(
		name = "Akkha",
		description = "Configuration for Akkha boss room.",
		position = 1,
		closedByDefault = true
	)
	String SECTION_AKKHA = "sectionAkkha";

	@ConfigSection(
		name = "Kephri",
		description = "Configuration for the Kephri room.",
		position = 2,
		closedByDefault = true
	)
	String SECTION_KEPHRI = "sectionKephri";

	@ConfigSection(
		name = "Path of Apmeken",
		description = "Options for the Path of Apmeken.",
		position = 3,
		closedByDefault = true
	)
	String SECTION_APMEKEN = "sectionApmeken";

	@ConfigSection(
		name = "Path of Het",
		description = "Helpers for the Path of Het.",
		position = 4,
		closedByDefault = true
	)
	String SECTION_HET = "sectionHet";

	@ConfigSection(
		name = "Path of Scabaras",
		description = "Options for the puzzles in the Path of Scabaras.",
		position = 5,
		closedByDefault = true
	)
	String SECTION_SCABARAS = "sectionScabaras";

	@ConfigSection(
		name = "Burial Tomb",
		description = "Configuration for the burial tomb.",
		position = 6,
		closedByDefault = true
	)
	String SECTION_BURIAL_TOMB = "sectionBurialTomb";

	@ConfigSection(
		name = "Points Tracker",
		description = "<html>Tracks points for the raid, used in calculating drop chance." +
			"<br/>NOTE: For teams, you MUST use the RuneLite Party plugin to receive team drop chance.</html>",
		position = 7,
		closedByDefault = true
	)
	String SECTION_POINTS_TRACKER = "sectionPointsTracker";

	@ConfigSection(
		name = "Invocation Presets",
		description = "Save presets of invocations to quickly restore your invocations between runs of different types.",
		position = 8,
		closedByDefault = true
	)
	String SECTION_INVOCATION_PRESETS = "invocationPresetsSection";

	@ConfigSection(
		name = "Invocation Screenshot",
		description = "All config options related to the Invocation Screenshot functionality",
		position = 9,
		closedByDefault = true
	)
	String SECTION_INVOCATION_SCREENSHOT = "invocationScreenshotSection";

	@ConfigSection(
		name = "Time Tracking",
		description = "Time tracking and splits.",
		position = 10,
		closedByDefault = true
	)
	String SECTION_TIME_TRACKING = "sectionTimeTracking";

	// Akkha

	@ConfigItem(
		name = "Shadows Hp Overlay",
		description = "Overlay Akkha's Shadows Hp.",
		position = 0,
		keyName = "akkhaShadowHpOverlay",
		section = SECTION_AKKHA
	)
	default boolean akkhaShadowHpOverlay()
	{
		return false;
	}

	@ConfigItem(
		name = "Font Style",
		description = "Font style of text overlay.",
		position = 1,
		keyName = "akkhaFontStyle",
		section = SECTION_AKKHA
	)
	default FontStyle akkhaFontStyle()
	{
		return FontStyle.PLAIN;
	}

	@ConfigItem(
		name = "Font Size",
		description = "Font size of text overlay.",
		position = 2,
		keyName = "akkhaFontSize",
		section = SECTION_AKKHA
	)
	@Units(Units.PIXELS)
	@Range(min = 12)
	default int akkhaFontSize()
	{
		return 12;
	}

	// Kephri
	@ConfigItem(
		keyName = "swarmerOverlay",
		name = "Swarmer Overlay",
		description = "Overlay swarm wave number.",
		position = 0,
		section = SECTION_KEPHRI
	)
	default boolean swarmerOverlay()
	{
		return false;
	}

	@ConfigItem(
			name = "Font Type",
			description = "Type of font",
			position = 1,
			keyName = "fontType",
			section = SECTION_KEPHRI
	)
	default SwarmerFonts swarmerFontType()
	{
		return SwarmerFonts.ARIAL;
	}

	@ConfigItem(
			name = "Use Bold Font",
			description = "Font style of swarm overlay.",
			position = 2,
			keyName = "useBoldFont",
			section = SECTION_KEPHRI
	)
	default boolean useBoldFont()
	{
		return true;
	}

	@ConfigItem(
			name = "Font Size",
			description = "Font size of swarm overlay.",
			position = 3,
			keyName = "swarmerFontSize",
			section = SECTION_KEPHRI
	)
	@Units(Units.PIXELS)
	@Range(min = 12)
	default int swarmerFontSize()
	{
		return 12;
	}

	@ConfigItem(
			name = "Side Panel",
			description = "Show a side panel with summary data for previous raids.",
			position = 4,
			keyName = "swarmerSidePanel",
			section = SECTION_KEPHRI
	)
	default SwarmerPanelManager.PanelMode swarmerSidePanel()
	{
		return SwarmerPanelManager.PanelMode.NEVER;
	}

	@ConfigItem(
			name = "Font Color",
			description = "Font color of swarm overlay.",
			position = 4,
			keyName = "swarmerFontColor",
			section = SECTION_KEPHRI
	)
	default Color swarmerFontColor()
	{
		return Color.WHITE;
	}

	// Apmeken

	@ConfigItem(
		keyName = "apmekenWaveHelper",
		name = "Apmeken Wave Helper",
		description = "When entering the Path of Apmeken, displays a list of the waves in the RuneLite side panel.",
		position = 0,
		section = SECTION_APMEKEN
	)
	default boolean apmekenWaveHelper()
	{
		return true;
	}

	@ConfigItem(
		name = "Baboon Outline",
		description = "Highlight baboons.",
		position = 1,
		keyName = "apmekenBaboonOutline",
		section = SECTION_APMEKEN
	)
	default HighlightMode apmekenBaboonOutline()
	{
		return HighlightMode.OFF;
	}

	@ConfigItem(
		name = "Outline Width",
		description = "Highlight the tiles of the explode radius.",
		position = 2,
		keyName = "apmekenBaboonOutlineWidth",
		section = SECTION_APMEKEN
	)
	default int apmekenBaboonOutlineWidth()
	{
		return 2;
	}

	@ConfigItem(
		name = "Melee Baboon",
		description = "Color to highlight the melee baboon.",
		position = 3,
		keyName = "apemekenBaboonColorMelee",
		section = SECTION_APMEKEN
	)
	@Alpha
	default Color apmekenBaboonColorMelee()
	{
		return new Color(0x40FF0000, true);
	}

	@ConfigItem(
		name = "Range Baboon",
		description = "Color to highlight the range baboon.",
		position = 4,
		keyName = "apemekenBaboonColorRange",
		section = SECTION_APMEKEN
	)
	@Alpha
	default Color apmekenBaboonColorRange()
	{
		return new Color(0x4000FF00, true);
	}

	@ConfigItem(
		name = "Mage Baboon",
		description = "Color to highlight the mage baboon.",
		position = 5,
		keyName = "apemekenBaboonColorMage",
		section = SECTION_APMEKEN
	)
	@Alpha
	default Color apmekenBaboonColorMage()
	{
		return new Color(0x400000FF, true);
	}

	@ConfigItem(
		name = "Shaman Baboon",
		description = "Color to highlight the shaman baboon.",
		position = 6,
		keyName = "apemekenBaboonColorShaman",
		section = SECTION_APMEKEN
	)
	@Alpha
	default Color apmekenBaboonColorShaman()
	{
		return new Color(0x4000FFFF, true);
	}

	@ConfigItem(
		name = "Thrall Baboon",
		description = "Color to highlight the thrall baboon.",
		position = 7,
		keyName = "apemekenBaboonColorThrall",
		section = SECTION_APMEKEN
	)
	@Alpha
	default Color apmekenBaboonColorThrall()
	{
		return new Color(0x0000FFFF, true);
	}

	@ConfigItem(
		name = "Cursed Baboon",
		description = "Color to highlight the cursed baboon.",
		position = 8,
		keyName = "apemekenBaboonColorCursed",
		section = SECTION_APMEKEN
	)
	@Alpha
	default Color apmekenBaboonColorCursed()
	{
		return new Color(0x40FF00FF, true);
	}

	@ConfigItem(
		name = "Volatile Baboon Radius",
		description = "Highlight the tiles of the explode radius.",
		position = 9,
		keyName = "apmekenVolatileBaboonTiles",
		section = SECTION_APMEKEN
	)
	default boolean apmekenVolatileBaboonTiles()
	{
		return false;
	}

	@ConfigItem(
		name = "Volatile Baboon",
		description = "Color to highlight the volatile baboon.",
		position = 10,
		keyName = "apemekenBaboonColorVolatile",
		section = SECTION_APMEKEN
	)
	@Alpha
	default Color apmekenBaboonColorVolatile()
	{
		return new Color(0x40FFC800, true);
	}

	// Het

	@ConfigItem(
		keyName = "hetBeamTimerEnable",
		name = "Beam Timer",
		description = "<html>Display an overlay of when the Caster Statue will fire." +
			"<br/>Click Het's Seal from one tile away when the indicator is GREEN to get an extra damage tick.</html>",
		position = 0,
		section = SECTION_HET
	)
	default boolean hetBeamTimerEnable()
	{
		return true;
	}

	@ConfigItem(
		keyName = "hetSolverEnable",
		name = "Mirror Puzzle Solver",
		description = "Show where to place/clean mirrors for the active puzzle layout.",
		position = 1,
		section = SECTION_HET
	)
	default boolean hetSolverEnable()
	{
		return true;
	}

	String KEY_HET_PICKAXE_MENU_SWAP = "hetPickaxeMenuSwap";

	@ConfigItem(
		keyName = KEY_HET_PICKAXE_MENU_SWAP,
		name = "Deposit-Pickaxe",
		description = "Automatically swap to Deposit-pickaxe when a pickaxe is in your inventory.",
		position = 2,
		section = SECTION_HET
	)
	default boolean hetPickaxeMenuSwap()
	{
		return true;
	}

	String KEY_HET_PICKAXE_PREVENT_EXIT = "hetPickaxePreventExit";

	@ConfigItem(
		keyName = KEY_HET_PICKAXE_PREVENT_EXIT,
		name = "Prevent Room Exit",
		description = "Deprioritize the option to leave the puzzle room until you have deposited your pickaxe in the statue.",
		position = 3,
		section = SECTION_HET
	)
	default boolean hetPickaxePreventExit()
	{
		return false;
	}

	@ConfigItem(
		keyName = "hetPickaxePreventRaidStart",
		name = "Prevent Raid Start",
		description = "Deprioritize the option to enter the raid until you have deposited your pickaxe in the lobby wall cavity.",
		position = 4,
		section = SECTION_HET
	)
	default boolean hetPickaxePreventRaidStart()
	{
		return false;
	}

	@ConfigItem(
		keyName = "hetPickaxePuzzleOverlay",
		name = "Puzzle Room Visual Warning",
		description = "Add a visual warning reminder to deposit your pickaxe at the end of the mirror puzzle room.",
		position = 5,
		section = SECTION_HET
	)
	default boolean hetPickaxePuzzleOverlay()
	{
		return false;
	}

	@ConfigItem(
		keyName = "hetPickaxeLobbyOverlay",
		name = "Lobby Visual Warning",
		description = "Add a visual warning reminder to deposit your pickaxe in the raid lobby.",
		position = 6,
		section = SECTION_HET
	)
	default boolean hetPickaxeLobbyOverlay()
	{
		return false;
	}

	// Scabaras

	@ConfigItem(
		keyName = "scabarasHelperMode",
		name = "Scabaras Helpers",
		description = "Puzzle helpers for the Path of Scabaras (leading to Kephri).",
		position = 0,
		section = SECTION_SCABARAS
	)
	default ScabarasHelperMode scabarasHelperMode()
	{
		return ScabarasHelperMode.OVERLAY;
	}

	@ConfigItem(
		keyName = "scabarasAdditionTileColor",
		name = "Addition Colour",
		description = "Highlight colour for tiles in the addition puzzle." +
			"<br/>Set alpha to 0 to disable.",
		position = 1,
		section = SECTION_SCABARAS
	)
	@Alpha
	default Color scabarasAdditionTileColor()
	{
		return Color.red;
	}

	@ConfigItem(
		keyName = "scabarasLightTileColor",
		name = "Light Flip Colour",
		description = "Highlight colour for tiles in the light flips puzzle." +
			"<br/>Set alpha to 0 to disable.",
		position = 2,
		section = SECTION_SCABARAS
	)
	@Alpha
	default Color scabarasLightTileColor()
	{
		return Color.red;
	}

	@ConfigItem(
		keyName = "scabarasObeliskColor1",
		name = "Obelisk Start",
		description = "Start colour for highlighting the obelisks in the obelisk puzzle." +
			"<br/>Set alpha to 0 to disable.",
		position = 3,
		section = SECTION_SCABARAS
	)
	@Alpha
	default Color scabarasObeliskColorStart()
	{
		return Color.cyan;
	}

	@ConfigItem(
		keyName = "scabarasObeliskColor2",
		name = "Obelisk End",
		description = "End colour for highlighting the obelisks in the obelisk puzzle." +
			"<br/>Set alpha to 0 to disable.",
		position = 4,
		section = SECTION_SCABARAS
	)
	@Alpha
	default Color scabarasObeliskColorEnd()
	{
		return Color.blue;
	}

	@ConfigItem(
		keyName = "scabarasSequenceColor1",
		name = "Sequence Start",
		description = "Start colour for highlighting the tiles in the sequence (simon says) puzzle." +
			"<br/>Set alpha to 0 to disable.",
		position = 5,
		section = SECTION_SCABARAS
	)
	@Alpha
	default Color scabarasSequenceColorStart()
	{
		return Color.cyan;
	}

	@ConfigItem(
		keyName = "scabarasSequenceColor2",
		name = "Sequence End",
		description = "End colour for highlighting the tiles in the sequence (simon says) puzzle." +
			"<br/>Set alpha to 0 to disable.",
		position = 6,
		section = SECTION_SCABARAS
	)
	@Alpha
	default Color scabarasSequenceColorEnd()
	{
		return Color.blue;
	}

	@ConfigItem(
		keyName = "scabarasMatchingDisplayMode",
		name = "Matching Display",
		description = "Whether to show highlight tiles, show names of tiles, or both for the matching puzzle.",
		position = 7,
		section = SECTION_SCABARAS
	)
	default MatchingTileDisplayMode scabarasMatchingDisplayMode()
	{
		return MatchingTileDisplayMode.BOTH;
	}

	@ConfigItem(
		keyName = "scabarasMatchingCompletedOpacity",
		name = "Matched Opacity",
		description = "Opacity (transparency) of completed tiles in the matching puzzle." +
			"<br/>Set to 0 to hide completed tiles completely.",
		position = 8,
		section = SECTION_SCABARAS
	)
	@Range(
		min = 0,
		max = 255
	)
	default int scabarasMatchingCompletedOpacity()
	{
		return 64;
	}

	@ConfigItem(
		keyName = "scabarasHighlightSkipObeliskEntry",
		name = "Show Obelisk Skip",
		description = "Highlight which entrance will skip requiring the obelisk puzzle.",
		position = 9,
		section = SECTION_SCABARAS
	)
	default SkipObeliskOverlay.EnableMode scabarasHighlightSkipObeliskEntry()
	{
		return SkipObeliskOverlay.EnableMode.OFF;
	}

	// Burial Tomb

	@ConfigItem(
		keyName = "leftClickBankAll",
		name = "Bank-all Single Click",
		description = "Allows you to Bank-all loot without requiring a second click on the minimenu.",
		section = SECTION_BURIAL_TOMB,
		position = 0
	)
	default boolean leftClickBankAll()
	{
		return false;
	}

	@ConfigItem(
		keyName = "chestAudioEnable",
		name = "Purple Chest Audio",
		description = "<html>Either disables the feature or plays an audio file whenever the purple chest is opened." +
			"<br/>The custom audio file should be named toa-chest.wav inside the .runelite/tombs-of-amascut folder</html>",
		section = SECTION_BURIAL_TOMB,
		position = 1
	)
	default boolean chestAudioEnable()
	{
		return false;
	}

	String CHEST_AUDIO_VOLUME_KEY = "chestAudioVolume";

	@Range(
		max = 200
	)
	@ConfigItem(
		keyName = CHEST_AUDIO_VOLUME_KEY,
		name = "Audio Volume",
		description = "Adjusts how loud the chest audio is when played. 100 is no change to file volume.",
		section = SECTION_BURIAL_TOMB,
		position = 2
	)
	default int chestAudioVolume()
	{
		return 100;
	}

	String SARCOPHAGUS_RECOLOR_WHITE = "sarcophagusRecolorWhite";

	@ConfigItem(
		name = "Recolour White Chest",
		description = "Recolour the white sarcophagus.",
		position = 3,
		keyName = SARCOPHAGUS_RECOLOR_WHITE,
		section = SECTION_BURIAL_TOMB
	)
	default boolean sarcophagusRecolorWhite()
	{
		return false;
	}

	String SARCOPHAGUS_WHITE_RECOLOR = "sarcophagusWhiteRecolor";

	@ConfigItem(
		name = "White Colour",
		description = "Colour to replace the white sarcophagus.",
		position = 4,
		keyName = SARCOPHAGUS_WHITE_RECOLOR,
		section = SECTION_BURIAL_TOMB
	)
	default Color sarcophagusWhiteRecolor()
	{
		return new Color(237, 177, 23);
	}

	String SARCOPHAGUS_RECOLOR_MY_PURPLE = "sarcophagusRecolorMyPurple";

	@ConfigItem(
		name = "Recolour Purple Chest (Mine)",
		description = "Recolour the purple sarcophagus." +
			"<br>When the loot is mine.",
		position = 5,
		keyName = SARCOPHAGUS_RECOLOR_MY_PURPLE,
		section = SECTION_BURIAL_TOMB
	)
	default boolean sarcophagusRecolorMyPurple()
	{
		return false;
	}

	String SARCOPHAGUS_MY_PURPLE_RECOLOR = "sarcophagusMyPurpleRecolor";

	@ConfigItem(
		name = "Purple Colour (Mine)",
		description = "Colour to replace the purple sarcophagus." +
			"<br>When the loot is mine.",
		position = 6,
		keyName = SARCOPHAGUS_MY_PURPLE_RECOLOR,
		section = SECTION_BURIAL_TOMB
	)
	default Color sarcophagusMyPurpleRecolor()
	{
		return new Color(192, 20, 124);
	}

	String SARCOPHAGUS_RECOLOR_OTHER_PURPLE = "sarcophagusRecolorOtherPurple";

	@ConfigItem(
		name = "Recolour Purple Chest (Other)",
		description = "Recolour the purple sarcophagus." +
			"<br>When the loot is NOT mine.",
		position = 7,
		keyName = SARCOPHAGUS_RECOLOR_OTHER_PURPLE,
		section = SECTION_BURIAL_TOMB
	)
	default boolean sarcophagusRecolorOtherPurple()
	{
		return false;
	}

	String SARCOPHAGUS_OTHER_PURPLE_RECOLOR = "sarcophagusOtherPurpleRecolor";

	@ConfigItem(
		name = "Purple Colour (Other)",
		description = "Colour to replace the purple sarcophagus." +
			"<br>When the loot is NOT mine.",
		position = 8,
		keyName = SARCOPHAGUS_OTHER_PURPLE_RECOLOR,
		section = SECTION_BURIAL_TOMB
	)
	default Color sarcophagusOtherPurpleRecolor()
	{
		return new Color(17, 88, 152);
	}

	@ConfigItem(
		name = "Detect Cursed Phalanx",
		description = "Prevents opening chests if player is carrying a cursed phalanx" +
			"<br>or Osmumten's fang (or).",
		position = 9,
		keyName = "cursedPhalanxDetect",
		section = SECTION_BURIAL_TOMB
	)
	default boolean cursedPhalanxDetect()
	{
		return false;
	}

	@ConfigItem(
		name = "Track Purple Dry Count",
		description = "Show purple dry streak count in chat upon raid completion.",
		position = 10,
		keyName = "trackPurpleDryCount",
		section = SECTION_BURIAL_TOMB
	)
	default boolean trackPurpleDryCount()
	{
		return false;
	}

	// Invocation Presets

	@ConfigItem(
		keyName = "invocationPresetsEnable",
		name = "Enable Presets",
		description = "Allows for saving and restoring of invocation presets. Right-click \"Preset\" button to save/load.",
		section = SECTION_INVOCATION_PRESETS,
		position = 0
	)
	default boolean invocationPresetsEnable()
	{
		return false;
	}

	@ConfigItem(
		keyName = "invocationPresetsScroll",
		name = "Auto-Scroll",
		description = "Automatically scroll to invocations which need to be changed for the current preset.",
		section = SECTION_INVOCATION_PRESETS,
		position = 1
	)
	default boolean invocationPresetsScroll()
	{
		return true;
	}

	// Invocation Screenshot

	@ConfigItem(
		keyName = "invocationScreenshotEnable",
		name = "Enable Screenshot button",
		description = "Adds a button to the ToA Invocation interface that will copy all invocations as an image to your system clipboard",
		section = SECTION_INVOCATION_SCREENSHOT,
		position = 0
	)
	default boolean invocationScreenshotEnable()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showRewardsSection",
		name = "Show Rewards Section",
		description = "<html>Should the rewards section be included<br/>(requires the Reward button to be selected within the interface)</html>",
		section = SECTION_INVOCATION_SCREENSHOT,
		position = 1
	)
	default boolean showRewardsSection()
	{
		return true;
	}

	@ConfigItem(
		keyName = "useResourcePack",
		name = "Use Resource Pack",
		description = "Use Resource Pack Theme for screenshot background",
		section = SECTION_INVOCATION_SCREENSHOT,
		position = 2
	)
	default boolean useResourcePack()
	{
		return true;
	}

	// Points Tracker

	@ConfigItem(
		keyName = "pointsTrackerOverlayEnable",
		name = "Enable Overlay",
		description = "Show points earned within the raid.",
		position = 0,
		section = SECTION_POINTS_TRACKER
	)
	default boolean pointsTrackerOverlayEnable()
	{
		return true;
	}

	@ConfigItem(
		keyName = "pointsTrackerShowRoomPoints",
		name = "Separate Room Points",
		description = "Show points for the current room separate from total points.",
		position = 1,
		section = SECTION_POINTS_TRACKER
	)
	default boolean pointsTrackerShowRoomPoints()
	{
		return false;
	}

	@ConfigItem(
		keyName = "pointsTrackerShowUniqueChance",
		name = "Show Unique %",
		description = "Show unique chance on the overlay.",
		position = 2,
		section = SECTION_POINTS_TRACKER
	)
	default boolean pointsTrackerShowUniqueChance()
	{
		return true;
	}

	@ConfigItem(
		keyName = "pointsTrackerShowPetChance",
		name = "Show Pet %",
		description = "Show pet chance on the overlay.",
		position = 3,
		section = SECTION_POINTS_TRACKER
	)
	default boolean pointsTrackerShowPetChance()
	{
		return false;
	}

	@ConfigItem(
		keyName = "pointsTrackerPostRaidMessage",
		name = "Points Total Message",
		description = "Show the total points in chat after the raid, akin to the Chambers of Xeric.",
		position = 4,
		section = SECTION_POINTS_TRACKER
	)
	default boolean pointsTrackerPostRaidMessage()
	{
		return true;
	}

	@ConfigItem(
		keyName = "pointsTrackerAllowExternal",
		name = "Send to External Plugins",
		description = "Sends the points totals to other locally installed plugins on raid completion." +
			"<br />Disabling this may prevent other plugins from working properly.",
		position = 5,
		section = SECTION_POINTS_TRACKER
	)
	default boolean pointsTrackerAllowExternal()
	{
		return true;
	}

	// Time Tracking

	@ConfigItem(
		keyName = "targetTimeDisplay",
		name = "Target Time in Timer",
		description = "Expand the in-raid timer to also show the target time to beat.",
		position = 0,
		section = SECTION_TIME_TRACKING
	)
	default boolean targetTimeDisplay()
	{
		return true;
	}

	@ConfigItem(
		keyName = "splitsMessage",
		name = "Splits Post-Raid Message",
		description = "Show room splits in a chat message at the end of the raid. Path shows boss completion times, room shows each individual room (can be very long).",
		position = 1,
		section = SECTION_TIME_TRACKING
	)
	default SplitsMode splitsMessage()
	{
		return SplitsMode.OFF;
	}

	@ConfigItem(
		keyName = "splitsOverlay",
		name = "Splits Overlay",
		description = "Show room splits in an on-screen overlay. Path shows boss completion times, room shows each individual room (can be very long).",
		position = 2,
		section = SECTION_TIME_TRACKING
	)
	default SplitsMode splitsOverlay()
	{
		return SplitsMode.OFF;
	}

	// Miscellaneous

	String KEY_QUICK_PROCEED_ENABLE_MODE = "quickProceedEnableMode";

	@ConfigItem(
		keyName = KEY_QUICK_PROCEED_ENABLE_MODE,
		name = "Quick Proceed",
		description = "Left click proceed/begin/leave on Osmumten and quick-enter/quick-use entryways and teleport crystals.",
		position = 0,
		section = SECTION_MISCELLANEOUS
	)
	default QuickProceedEnableMode quickProceedEnableMode()
	{
		return QuickProceedEnableMode.ALL;
	}

	String KEY_HP_ORB_MODE = "hpOrbsMode";

	@ConfigItem(
		keyName = KEY_HP_ORB_MODE,
		name = "HP Orbs",
		description = "Removes HP orbs from the screen or replaces them with health bars.",
		position = 1,
		section = SECTION_MISCELLANEOUS
	)
	default HpOrbMode hpOrbsMode()
	{
		return HpOrbMode.ORBS;
	}

	@ConfigItem(
		keyName = "showUpdateMessages",
		name = "Show Updates",
		description = "Opens a panel describing plugin updates after new features are added to the plugin.",
		position = 3,
		section = SECTION_MISCELLANEOUS
	)
	default boolean showUpdateMessages()
	{
		return true;
	}

	@ConfigItem(
		keyName = "hideFadeTransition",
		name = "Hide Fade Transition",
		description = "Hides the fade transition between loading zones.",
		position = 4,
		section = SECTION_MISCELLANEOUS
	)
	default boolean hideFadeTransition()
	{
		return false;
	}

	@ConfigItem(
		keyName = "smellingSaltsCooldown",
		name = "Salts Cooldown",
		description = "After using Smelling salts, prevents re-using them for this long.",
		position = 5,
		section = SECTION_MISCELLANEOUS
	)
	@Units(Units.SECONDS)
	@Range(
		min = 0,
		max = 480
	)
	default int smellingSaltsCooldown()
	{
		return 15;
	}

	@ConfigItem(
		keyName = "disableCameraShake",
		name = "Disable Camera Shake",
		description = "Disables camera shake effects at P4 Wardens.",
		position = 6,
		section = SECTION_MISCELLANEOUS
	)
	default boolean disableCameraShake()
	{
		return false;
	}

	// Hidden

	@ConfigItem(
		keyName = "updateNotifierLastVersion",
		name = "",
		description = "",
		hidden = true
	)
	default int updateNotifierLastVersion()
	{
		return UpdateNotifier.TARGET_VERSION - 1;
	}

	@ConfigItem(
		keyName = "updateNotifierLastVersion",
		name = "",
		description = "",
		hidden = true
	)
	void updateNotifierLastVersion(int newVersion);

	@ConfigItem(
		keyName = "purpleDryStreakCount",
		name = "",
		description = "",
		hidden = true
	)
	default int getPurpleDryStreakCount()
	{
		return 0;
	}

	@ConfigItem(
		keyName = "purpleDryStreakCount",
		name = "",
		description = "",
		hidden = true
	)
	void setPurpleDryStreakCount(int count);

}

package com.duckblade.osrs.toa.features;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidRoom;
import com.duckblade.osrs.toa.util.RaidState;
import com.duckblade.osrs.toa.util.RaidStateTracker;
import com.google.common.collect.ImmutableSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.MenuEntry;
import net.runelite.api.NpcID;
import net.runelite.api.ObjectID;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class QuickProceedSwaps implements PluginLifecycleComponent
{

	public enum QuickProceedEnableMode
	{
		ALL,
		NOT_CRONDIS,
		NONE,
		;
	}

	private static final Set<Integer> NPC_IDS = ImmutableSet.of(
		NpcID.OSMUMTEN, // post-demi-boss
		NpcID.OSMUMTEN_11690, // pre-warden
		NpcID.OSMUMTEN_11693 // loot room
	);

	private static final Set<Integer> OBJECT_IDS = ImmutableSet.of(
		ObjectID.PATH_OF_CRONDIS,
		ObjectID.PATH_OF_SCABARAS,
		ObjectID.PATH_OF_HET,
		ObjectID.PATH_OF_APMEKEN,
		ObjectID.BARRIER_45135,
		ObjectID.TELEPORT_CRYSTAL_45505, // kephri
		ObjectID.TELEPORT_CRYSTAL_45506, // zebak
		ObjectID.TELEPORT_CRYSTAL_45866, // akkha
		ObjectID.TELEPORT_CRYSTAL_45754, // ba-ba // Quick-Use
		ObjectID.ENTRY_45131, // het
		ObjectID.ENTRY_45337, // scabaras
		ObjectID.ENTRY_45397, // crondis
		ObjectID.ENTRY_45500, // apmeken
		ObjectID.ENTRY_46168 // wardens
	);

	private final EventBus eventBus;
	private final TombsOfAmascutConfig config;
	private final RaidStateTracker raidStateTracker;

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState raidState)
	{
		return raidState.isInRaid() && config.quickProceedEnableMode() != QuickProceedEnableMode.NONE;
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded e)
	{
		// easier to just deprioritize talk-to rather than prioritizing the other options
		MenuEntry me = e.getMenuEntry();
		if (shouldDeprioritize(me))
		{
			me.setDeprioritized(true);
		}
	}

	private boolean shouldDeprioritize(MenuEntry me)
	{
		switch (me.getType())
		{
			case NPC_FIRST_OPTION:
				return me.getOption().equals("Talk-to") &&
					me.getNpc() != null &&
					NPC_IDS.contains(me.getNpc().getId());

			case GAME_OBJECT_FIRST_OPTION:
				final int id = me.getIdentifier();
				final String option = me.getOption();

				if (id == ObjectID.BARRIER_45135 &&
					raidStateTracker.getCurrentState().getCurrentRoom() == RaidRoom.CRONDIS &&
					option.equals("Pass"))
				{
					return config.quickProceedEnableMode() != QuickProceedEnableMode.NOT_CRONDIS;
				}

				return OBJECT_IDS.contains(id) &&
					(option.equals("Enter") || option.equals("Use") || option.equals("Pass"));

			default:
				return false;
		}
	}
}
/**
 * BSD 2-Clause License
 * <p>
 * Copyright (c) 2023, rdutta
 * Copyright (c) 2020, AnkouOSRS
 * All rights reserved.
 * <p>
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * <p>
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 * <p>
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 * <p>
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.duckblade.osrs.toa.features.tomb;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidRoom;
import com.duckblade.osrs.toa.util.RaidState;
import com.google.common.collect.ImmutableSet;
import java.awt.Color;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Model;
import net.runelite.api.WallObject;
import net.runelite.api.events.WallObjectDespawned;
import net.runelite.api.events.WallObjectSpawned;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;

@Slf4j
@Singleton
public class SarcophagusRecolorer implements PluginLifecycleComponent
{

	private static final Set<String> CONFIG_KEYS = ImmutableSet.of(
		TombsOfAmascutConfig.SARCOPHAGUS_RECOLOR_WHITE,
		TombsOfAmascutConfig.SARCOPHAGUS_WHITE_RECOLOR,
		TombsOfAmascutConfig.SARCOPHAGUS_RECOLOR_MY_PURPLE,
		TombsOfAmascutConfig.SARCOPHAGUS_MY_PURPLE_RECOLOR,
		TombsOfAmascutConfig.SARCOPHAGUS_RECOLOR_OTHER_PURPLE,
		TombsOfAmascutConfig.SARCOPHAGUS_OTHER_PURPLE_RECOLOR
	);

	private static final int[] VARBIT_MULTILOC_IDS_CHEST = new int[]{
		14356, 14357, 14358, 14359, 14360, 14370, 14371, 14372
	};

	private static final int VARBIT_VALUE_CHEST_KEY = 2;
	private static final int VARBIT_ID_SARCOPHAGUS = 14373;
	private static final int WALL_OBJECT_ID_SARCOPHAGUS = 46221;

	@Inject
	private EventBus eventBus;
	@Inject
	private Client client;
	@Inject
	private ClientThread clientThread;
	@Inject
	private TombsOfAmascutConfig config;

	private final List<WallObject> wallObjects = new ArrayList<>();

	private int[] defaultFaceColors1;

	private boolean sarcophagusIsPurple;
	private boolean purpleIsMine = true;

	@Override
	public boolean isEnabled(final TombsOfAmascutConfig config, final RaidState raidState)
	{
		return raidState.getCurrentRoom() == RaidRoom.TOMB;
	}

	@Override
	public void startUp()
	{
		clientThread.invokeLater(() ->
		{
			parseVarbits();
			recolor(wallObjects);
		});

		eventBus.register(this);
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
		wallObjects.clear();
		sarcophagusIsPurple = false;
		purpleIsMine = true;
		defaultFaceColors1 = null;
	}

	@Subscribe
	public void onConfigChanged(final ConfigChanged event)
	{
		if (!event.getGroup().equals(TombsOfAmascutConfig.CONFIG_GROUP) || wallObjects.isEmpty())
		{
			return;
		}

		final String key = event.getKey();

		if (CONFIG_KEYS.contains(key))
		{
			clientThread.invokeLater(() -> recolor(wallObjects));
		}
	}

	@Subscribe
	public void onWallObjectSpawned(final WallObjectSpawned event)
	{
		final WallObject wallObject = event.getWallObject();

		if (wallObject.getId() != WALL_OBJECT_ID_SARCOPHAGUS)
		{
			return;
		}

		if (defaultFaceColors1 == null)
		{
			initDefaultFaceColors1(wallObject);
		}

		recolor(wallObject);
		wallObjects.add(wallObject);
	}

	@Subscribe
	public void onWallObjectDespawned(final WallObjectDespawned event)
	{
		final WallObject wallObject = event.getWallObject();

		if (wallObject.getId() == WALL_OBJECT_ID_SARCOPHAGUS)
		{
			wallObjects.remove(wallObject);
		}
	}

	private void parseVarbits()
	{
		sarcophagusIsPurple = client.getVarbitValue(VARBIT_ID_SARCOPHAGUS) % 2 != 0;
		purpleIsMine = true;

		for (final int varbitId : VARBIT_MULTILOC_IDS_CHEST)
		{
			if (client.getVarbitValue(varbitId) == VARBIT_VALUE_CHEST_KEY)
			{
				purpleIsMine = false;
				break;
			}
		}
	}

	private void initDefaultFaceColors1(final WallObject wallObject)
	{
		final Model model = wallObject.getRenderable1().getModel();

		if (model == null)
		{
			return;
		}

		defaultFaceColors1 = model.getFaceColors1().clone();
	}

	private void recolor(final Collection<WallObject> wallObjects)
	{
		for (final WallObject wallObject : wallObjects)
		{
			recolor(wallObject);
		}
	}

	private void recolor(final WallObject wallObject)
	{
		final Model model = wallObject.getRenderable1().getModel();

		if (model == null)
		{
			return;
		}

		final int[] faceColors1 = model.getFaceColors1();

		final Color color;

		if (sarcophagusIsPurple)
		{
			if (purpleIsMine)
			{
				if (!config.sarcophagusRecolorMyPurple())
				{
					resetFaceColors1(faceColors1);
					return;
				}

				color = config.sarcophagusMyPurpleRecolor();
			}
			else
			{
				if (!config.sarcophagusRecolorOtherPurple())
				{
					resetFaceColors1(faceColors1);
					return;
				}

				color = config.sarcophagusOtherPurpleRecolor();
			}
		}
		else
		{
			if (!config.sarcophagusRecolorWhite())
			{
				resetFaceColors1(faceColors1);
				return;
			}

			color = config.sarcophagusWhiteRecolor();
		}

		Arrays.fill(faceColors1, colorToRs2hsb(color));
	}

	private void resetFaceColors1(final int[] faceColors1)
	{
		if (defaultFaceColors1 == null)
		{
			log.error("defaultFaceColors1 was not initialized. Failed to reset faceColors1.");
			return;
		}

		System.arraycopy(defaultFaceColors1, 0, faceColors1, 0, faceColors1.length);
	}

	private static int colorToRs2hsb(final Color color)
	{
		final float[] hsbVals = Color.RGBtoHSB(color.getRed(), color.getGreen(), color.getBlue(), null);

		// "Correct" the brightness level to avoid going to white at full saturation, or having a low brightness at
		// low saturation
		hsbVals[2] -= Math.min(hsbVals[1], hsbVals[2] / 2);

		final int encode_hue = (int) (hsbVals[0] * 63);
		final int encode_saturation = (int) (hsbVals[1] * 7);
		final int encode_brightness = (int) (hsbVals[2] * 127);
		return (encode_hue << 10) + (encode_saturation << 7) + (encode_brightness);
	}

}

package com.duckblade.osrs.toa.features.tomb;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.InventoryUtil;
import com.duckblade.osrs.toa.util.RaidRoom;
import com.duckblade.osrs.toa.util.RaidState;
import com.duckblade.osrs.toa.util.RaidStateTracker;
import com.google.common.collect.ImmutableSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.InventoryID;
import net.runelite.api.ItemID;
import net.runelite.api.MenuEntry;
import net.runelite.api.Varbits;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class CursedPhalanxDetector implements PluginLifecycleComponent
{
	private static final Set<Integer> CURSED_PHALANX_ITEM_IDS = ImmutableSet.of(
		ItemID.CURSED_PHALANX,
		ItemID.OSMUMTENS_FANG_OR
	);

	private boolean isEligibleForKit = true;

	private final EventBus eventBus;
	private final Client client;
	private final RaidStateTracker raidStateTracker;

	@Override
	public boolean isEnabled(final TombsOfAmascutConfig config, final RaidState raidState)
	{
		return raidState.isInRaid() &&
			config.cursedPhalanxDetect();
	}

	@Override
	public void startUp()
	{
		isEligibleForKit = true;
		eventBus.register(this);
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
	}

	@Subscribe
	private void onChatMessage(ChatMessage e)
	{
		if (e.getType() != ChatMessageType.GAMEMESSAGE || !isEligibleForKit)
		{
			return;
		}

		if (e.getMessage().contains("Total deaths"))
		{
			isEligibleForKit = false;
		}
	}

	@Subscribe
	private void onMenuOptionClicked(final MenuOptionClicked event)
	{
		if (!isEligibleForKit ||
			raidStateTracker.getCurrentState().getCurrentRoom() != RaidRoom.TOMB ||
			client.getVarbitValue(Varbits.TOA_RAID_LEVEL) < 500)
		{
			return;
		}

		final MenuEntry menuEntry = event.getMenuEntry();
		if (!menuEntry.getOption().equals("Open"))
		{
			return;
		}

		boolean wearingPhalanx = InventoryUtil.containsAny(client.getItemContainer(InventoryID.EQUIPMENT), CURSED_PHALANX_ITEM_IDS);
		boolean carryingPhalanx = InventoryUtil.containsAny(client.getItemContainer(InventoryID.INVENTORY), CURSED_PHALANX_ITEM_IDS);

		if (wearingPhalanx || carryingPhalanx)
		{
			event.consume();
			client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Remove and/or drop cursed phalanx before doing that.", null);
		}
	}
}

package com.duckblade.osrs.toa.features.tomb;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidRoom;
import com.duckblade.osrs.toa.util.RaidState;
import com.duckblade.osrs.toa.util.RaidStateTracker;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class DryStreakTracker implements PluginLifecycleComponent
{
	private static final int VARBIT_ID_SARCOPHAGUS = 14373;

	private final EventBus eventBus;
	private final Client client;
	private final ClientThread clientThread;
	private final TombsOfAmascutConfig config;
	private final ChatMessageManager chatMessageManager;
	private final RaidStateTracker raidStateTracker;

	private boolean chestOpened;
	private boolean purple;
	private int previousCount;

	@Override
	public boolean isEnabled(final TombsOfAmascutConfig config, final RaidState raidState)
	{
		return config.trackPurpleDryCount() && (raidState.getCurrentRoom() == RaidRoom.TOMB || raidState.isInLobby());
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);

		// TODO: prevent arbitrarily increasing counter by toggling config option
		if (raidStateTracker.getCurrentState().getCurrentRoom() == RaidRoom.TOMB)
		{
			clientThread.invokeLater(() ->
			{
				chestOpened = false;
				purple = client.getVarbitValue(VARBIT_ID_SARCOPHAGUS) % 2 != 0;
				previousCount = config.getPurpleDryStreakCount();
				config.setPurpleDryStreakCount(purple ? 0 : previousCount + 1);
			});
		}
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
	}

	@Subscribe
	public void onWidgetLoaded(final WidgetLoaded widgetLoaded)
	{
		if (chestOpened)
		{
			return;
		}

		if (widgetLoaded.getGroupId() == InterfaceID.TOA_REWARD)
		{
			chestOpened = true;

			final String msg;

			if (purple)
			{
				msg = String.format("<col=800080>Purple</col> Dry Streak Ended: <col=ff0000>%d</col>", previousCount);
			}
			else
			{
				msg = String.format("<col=800080>Purple</col> Dry Streak: <col=ff0000>%d</col>", config.getPurpleDryStreakCount());
			}

			chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.GAMEMESSAGE)
				.runeLiteFormattedMessage(msg)
				.build());
		}
	}
}

/*
 * Copyright (c) 2022, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.duckblade.osrs.toa.features.tomb;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.TombsOfAmascutPlugin;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidState;
import java.io.File;
import java.io.IOException;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.Clip;
import javax.sound.sampled.FloatControl;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.UnsupportedAudioFileException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class SarcophagusOpeningSoundPlayer implements PluginLifecycleComponent
{
	private static final int SARCOPHAGUS_ID = 44934;

	private final EventBus eventBus;
	private final TombsOfAmascutConfig config;

	private Clip clip = null;

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState raidState)
	{
		return config.chestAudioEnable();
	}

	@Override
	public void startUp()
	{
		clip = null;
		eventBus.register(this);
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);

		if (clip != null)
		{
			clip.close();
		}
		clip = null;
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged c)
	{
		if (!c.getGroup().equals(TombsOfAmascutConfig.CONFIG_GROUP))
		{
			return;
		}

		if (c.getKey().equals(TombsOfAmascutConfig.CHEST_AUDIO_VOLUME_KEY))
		{
			// Play clip when changing audio config so they can preview the change
			playClip();
		}
	}

	@Subscribe
	private void onGameObjectSpawned(GameObjectSpawned e)
	{
		if (e.getGameObject().getId() != SARCOPHAGUS_ID)
		{
			return;
		}

		// The sarcophagus spawns as the player starts looting the chest
		playClip();
	}

	private boolean loadClip()
	{
		final File f = new File(TombsOfAmascutPlugin.TOA_FOLDER, "toa-chest.wav");
		if (!f.exists())
		{
			log.warn("ToA chest opening sound file does not exist, expected " + f.getAbsolutePath());
			return false;
		}

		try (AudioInputStream audioInputStream = AudioSystem.getAudioInputStream(f))
		{
			clip = AudioSystem.getClip();
			clip.open(audioInputStream);
			return true;
		}
		catch (UnsupportedAudioFileException | IOException | LineUnavailableException e)
		{
			if (clip.isOpen())
			{
				clip.close();
			}
			clip = null;
			log.warn("Failed to load toa chest audio");
		}
		return false;
	}

	public void playClip()
	{
		if (clip == null || !clip.isOpen())
		{
			if (!loadClip())
			{
				log.warn("Unable to play audio clip");
				return;
			}
		}

		FloatControl volume = (FloatControl) clip.getControl(FloatControl.Type.MASTER_GAIN);
		float gain = 20f * (float) Math.log10(config.chestAudioVolume() / 100f);

		// Ensure the value we pass is between the clips maximum and minimum value to prevent an IllegalArgumentException
		gain = Math.max(Math.min(gain, volume.getMaximum()), volume.getMinimum());
		volume.setValue(gain);

		// Reset audio to starting frame in case its been played or is currently being played
		clip.setFramePosition(0);

		// From RuneLite base client Notifier class:
		// Using loop prevents the clip from not being played sometimes, presumably from a race condition in the underlying line driver
		clip.loop(0);
	}
}

package com.duckblade.osrs.toa.features;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidRoom;
import com.duckblade.osrs.toa.util.RaidState;
import com.duckblade.osrs.toa.util.RaidStateTracker;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class PathLevelTracker implements PluginLifecycleComponent
{
	private static final int CHILD_ID_DEFAULT = 45;
	private static final int CHILD_ID_KEPHRI = 49;
	private static final int CHILD_ID_AKKHA = 51;
	private static final int CHILD_ID_BABA = 53;
	private static final int CHILD_ID_ZEBAK = 55;

	private final EventBus eventBus;
	private final Client client;
	private final RaidStateTracker raidStateTracker;

	@Getter
	private int kephriPathLevel;
	@Getter
	private int akkhaPathLevel;
	@Getter
	private int babaPathLevel;
	@Getter
	private int zebakPathLevel;

	@Override
	public boolean isEnabled(final TombsOfAmascutConfig config, final RaidState raidState)
	{
		return raidState.isInRaid();
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);
		readPathLevels();
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
	}

	@Subscribe
	public void onWidgetLoaded(final WidgetLoaded event)
	{
		final int groupId = event.getGroupId();

		if (groupId == InterfaceID.TOA_RAID)
		{
			readPathLevels();
		}
	}

	private void readPathLevels()
	{
		final RaidRoom raidRoom = raidStateTracker.getCurrentState().getCurrentRoom();

		Widget widget;

		if (raidRoom == RaidRoom.NEXUS)
		{
			if ((widget = client.getWidget(InterfaceID.TOA_RAID, CHILD_ID_KEPHRI)) != null)
			{
				kephriPathLevel = Integer.parseInt(widget.getText());
			}

			if ((widget = client.getWidget(InterfaceID.TOA_RAID, CHILD_ID_AKKHA)) != null)
			{
				akkhaPathLevel = Integer.parseInt(widget.getText());
			}

			if ((widget = client.getWidget(InterfaceID.TOA_RAID, CHILD_ID_BABA)) != null)
			{
				babaPathLevel = Integer.parseInt(widget.getText());
			}

			if ((widget = client.getWidget(InterfaceID.TOA_RAID, CHILD_ID_ZEBAK)) != null)
			{
				zebakPathLevel = Integer.parseInt(widget.getText());
			}
		}
		else
		{
			if ((widget = client.getWidget(InterfaceID.TOA_RAID, CHILD_ID_DEFAULT)) == null)
			{
				return;
			}

			final int pathLevel = Integer.parseInt(widget.getText());

			switch (raidRoom)
			{
				case CRONDIS:
				case ZEBAK:
					zebakPathLevel = pathLevel;
					break;
				case SCABARAS:
				case KEPHRI:
					kephriPathLevel = pathLevel;
					break;
				case APMEKEN:
				case BABA:
					babaPathLevel = pathLevel;
					break;
				case HET:
				case AKKHA:
					akkhaPathLevel = pathLevel;
					break;
				default:
					break;
			}
		}
	}

}

package com.duckblade.osrs.toa.features;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidRoom;
import com.duckblade.osrs.toa.util.RaidState;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Singleton
public class LeftClickBankAll implements PluginLifecycleComponent
{

	private static final String MENU_ENTRY_OPTION = "Bank-all";

	@Inject
	private EventBus eventBus;

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState raidState)
	{
		return config.leftClickBankAll() &&
			(raidState.isInLobby() || raidState.getCurrentRoom() == RaidRoom.TOMB);
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded e)
	{
		if (MENU_ENTRY_OPTION.equals(e.getOption()))
		{
			e.getMenuEntry().setForceLeftClick(true);
		}
	}
}

package com.duckblade.osrs.toa.features.invocationpresets;

import com.duckblade.osrs.toa.util.Invocation;
import com.duckblade.osrs.toa.util.RaidMode;
import java.awt.Color;
import java.util.Arrays;
import java.util.Collections;
import java.util.Set;
import java.util.stream.Collectors;
import lombok.Value;
import net.runelite.client.util.ColorUtil;

@Value
public class InvocationPreset
{

	public static InvocationPreset parse(String serialized)
	{
		String[] parts = serialized.trim().split(";");
		String name = parts[0];

		if (parts.length != 2)
		{
			if (serialized.endsWith(";"))
			{
				return new InvocationPreset(parts[0], Collections.emptySet());
			}
			throw new IllegalArgumentException("Invalid format");
		}

		Set<Invocation> invocations = Arrays.stream(parts[1].split(","))
			.map(Invocation::valueOf)
			.collect(Collectors.toSet());

		return new InvocationPreset(name, invocations);
	}

	private final String name;
	private final Set<Invocation> invocations;

	public String serialize()
	{
		return name + ";" + invocations.stream().map(Invocation::name).collect(Collectors.joining(","));
	}

	public int getRaidLevel()
	{
		return invocations.stream()
			.mapToInt(Invocation::getRaidLevel)
			.sum();
	}

	public String toStringDecorated()
	{
		String nameColorTag = ColorUtil.colorTag(new Color(255, 152, 31));
		String modeTag = ColorUtil.colorTag(RaidMode.forRaidLevel(getRaidLevel()).getColor());
		return nameColorTag + name + " " + modeTag + "(Lvl " + getRaidLevel() + ")" + ColorUtil.CLOSING_COLOR_TAG;
	}

}

package com.duckblade.osrs.toa.features.invocationpresets;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.Invocation;
import com.duckblade.osrs.toa.util.RaidState;
import com.duckblade.osrs.toa.util.RaidStateTracker;
import com.google.common.collect.Sets;
import com.google.common.util.concurrent.Runnables;
import java.awt.Color;
import java.awt.Toolkit;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.io.IOException;
import java.util.Comparator;
import java.util.EnumSet;
import java.util.Set;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.function.Consumer;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.KeyCode;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.ScriptID;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.chatbox.ChatboxPanelManager;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
@Slf4j
public class InvocationPresetsManager implements PluginLifecycleComponent
{

	public static final int WIDGET_ID_INVOCATIONS_PARENT = 774;
	public static final int WIDGET_ID_INVOCATIONS_SCROLLBAR = 51;
	public static final int WIDGET_ID_INVOCATIONS_CHILD = 52;
	public static final int SCRIPT_ID_BUILD_TOA_PARTY_INTERFACE = 6729;
	public static final int SCRIPT_ID_TOA_PARTY_TOGGLE_REWARD_PANEL = 6732;
	private static final String CONFIG_KEY_PRESETS = "presets";

	private final EventBus eventBus;
	private final ConfigManager configManager;

	private final Client client;
	private final TombsOfAmascutConfig config;
	private final ClientThread clientThread;
	private final ChatboxPanelManager chatboxPanelManager;
	private final RaidStateTracker raidStateTracker;

	@Getter
	private Set<Invocation> activeInvocations = EnumSet.noneOf(Invocation.class);

	@Getter
	private InvocationPreset currentPreset = null;

	private final SortedMap<String, InvocationPreset> presets = new TreeMap<>(Comparator.reverseOrder());
	private String originalHeaderText = null;

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState currentState)
	{
		return config.invocationPresetsEnable() &&
			currentState.isInLobby();
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);
		loadPresets();
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
	}

	@Subscribe
	public void onScriptPostFired(ScriptPostFired event)
	{
		// This is run when the party screen is brought up, whenever a tab is changed, and whenever an invocation is clicked
		if (event.getScriptId() == SCRIPT_ID_BUILD_TOA_PARTY_INTERFACE || event.getScriptId() == SCRIPT_ID_TOA_PARTY_TOGGLE_REWARD_PANEL)
		{
			updateCurrentActiveInvocations();
			displayPresetInvocations();
			displayPresetName();
		}
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded e)
	{
		if (!e.getOption().equals("Presets"))
		{
			return;
		}

		boolean deleteMode = client.isKeyPressed(KeyCode.KC_SHIFT);
		presets.values().forEach(preset ->
			{
				Consumer<MenuEntry> onClick = deleteMode ? ignored -> confirmDeletePreset(preset) : ignored -> setCurrentPreset(preset);
				client.createMenuEntry(-1)
					.setType(MenuAction.RUNELITE)
					.setOption(deleteMode ? "<col=ff0000>Delete" : "Load")
					.setTarget(preset.toStringDecorated())
					.onClick(onClick);
			}
		);

		if (currentPreset != null)
		{
			client.createMenuEntry(-1)
				.setType(MenuAction.RUNELITE)
				.setOption("Export")
				.setTarget(currentPreset.toStringDecorated())
				.onClick(ignored -> exportCurrentPreset());
		}

		client.createMenuEntry(-1)
			.setType(MenuAction.RUNELITE)
			.setOption("Import")
			.setTarget("Preset")
			.onClick(ignored -> importPreset());

		client.createMenuEntry(-1)
			.setType(MenuAction.RUNELITE)
			.setOption("Save")
			.setTarget("New Preset")
			.onClick(ignored -> savePreset());

		client.createMenuEntry(-1)
			.setType(MenuAction.RUNELITE)
			.setOption("Close")
			.setTarget("Presets")
			.onClick(ignored -> setCurrentPreset(null));
	}

	private void setCurrentPreset(InvocationPreset preset)
	{
		currentPreset = preset;
		removePresetDisplay();
		displayPresetInvocations();
		displayPresetName();
	}

	public void addPreset(InvocationPreset preset)
	{
		log.debug("Saving new preset {}", preset.serialize());
		presets.put(preset.getName(), preset);
		setCurrentPreset(preset);
		configManager.setConfiguration(TombsOfAmascutConfig.CONFIG_GROUP, CONFIG_KEY_PRESETS + "." + preset.getName(), preset.serialize());

		String message = "Saved preset as " + preset.toStringDecorated() + ". Use Shift+Right-click to delete.";
		client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", message, "", false);
	}

	private void confirmDeletePreset(InvocationPreset preset)
	{
		chatboxPanelManager.openTextMenuInput("Are you sure you want to delete your preset called \"" + preset.getName() + "\"?")
			.option("Yes", () -> clientThread.invoke(() -> deletePreset(preset)))
			.option("No", Runnables::doNothing)
			.build();
	}

	private void deletePreset(InvocationPreset preset)
	{
		log.debug("Deleting preset {}", preset.getName());
		configManager.unsetConfiguration(TombsOfAmascutConfig.CONFIG_GROUP, CONFIG_KEY_PRESETS + "." + preset.getName());
		presets.remove(preset.getName());
		setCurrentPreset(null);
	}

	private void savePreset()
	{
		chatboxPanelManager.openTextInput("Enter new preset name (or existing name to overwrite):")
			.onDone(name ->
			{
				clientThread.invoke(() -> addPreset(new InvocationPreset(name, activeInvocations)));
			})
			.build();
	}

	private void loadPresets()
	{
		for (String key : configManager.getConfigurationKeys(TombsOfAmascutConfig.CONFIG_GROUP + "." + CONFIG_KEY_PRESETS))
		{
			try
			{
				String keySuffix = key.split("\\.", 3)[2];
				String configValue = configManager.getConfiguration(TombsOfAmascutConfig.CONFIG_GROUP, CONFIG_KEY_PRESETS + "." + keySuffix);
				log.debug("Parsing preset config key = {} value = {}", keySuffix, configValue);

				InvocationPreset preset = InvocationPreset.parse(configValue);
				if (!preset.getName().equals(keySuffix))
				{
					log.warn("Mismatched key name from preset name key = {}, name = {}", key, preset.getName());
				}
				InvocationPreset prev = presets.put(preset.getName(), preset);
				if (prev != null)
				{
					log.warn("Config contains duplicate preset name {}", preset.getName());
				}
			}
			catch (Exception e)
			{
				log.error("Failed to parse ToA preset at config key {}", key, e);
			}
		}
	}

	private void importPreset()
	{
		final String clipboardText;
		try
		{
			clipboardText = Toolkit.getDefaultToolkit()
				.getSystemClipboard()
				.getData(DataFlavor.stringFlavor)
				.toString();
		}
		catch (IOException | UnsupportedFlavorException ex)
		{
			client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Unable to read system clipboard.", "", false);
			log.warn("error reading clipboard", ex);
			return;
		}

		try
		{
			InvocationPreset preset = InvocationPreset.parse(clipboardText);
			int presetCount = preset.getInvocations().size();
			chatboxPanelManager.openTextMenuInput("Import preset \"" + preset.getName() + "\" with " + presetCount + " invocations?")
				.option("Yes", () -> clientThread.invoke(() -> addPreset(preset)))
				.option("No", Runnables::doNothing)
				.build();
		}
		catch (Exception e)
		{
			client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Clipboard does not contain a valid invocation preset.", "", false);
			log.warn("Failed to parse invocation preset", e);
		}
	}

	private void exportCurrentPreset()
	{
		if (currentPreset == null)
		{
			return;
		}

		Toolkit.getDefaultToolkit()
			.getSystemClipboard()
			.setContents(new StringSelection(currentPreset.serialize()), null);
		client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Copied preset \"" + currentPreset.getName() + "\" to clipboard.", "", false);
	}

	private void updateCurrentActiveInvocations()
	{
		Widget parent = client.getWidget(WIDGET_ID_INVOCATIONS_PARENT, WIDGET_ID_INVOCATIONS_CHILD);
		if (parent == null || parent.isHidden() || parent.getChildren() == null)
		{
			this.activeInvocations = EnumSet.noneOf(Invocation.class);
			return;
		}

		EnumSet<Invocation> activeCurrent = EnumSet.noneOf(Invocation.class);
		for (Invocation invoc : Invocation.values())
		{
			Widget invocW = parent.getChild(invoc.getWidgetIx());
			if (invocW == null)
			{
				continue;
			}

			Object[] ops = invocW.getOnOpListener();
			if (ops == null || ops.length < 4 || !(ops[3] instanceof Integer))
			{
				continue;
			}

			if ((Integer) ops[3] == 1)
			{
				activeCurrent.add(invoc);
			}
		}

		if (log.isDebugEnabled() && !activeCurrent.equals(activeInvocations))
		{
			Sets.SetView<Invocation> adds = Sets.difference(activeCurrent, activeInvocations);
			Sets.SetView<Invocation> removes = Sets.difference(activeInvocations, activeCurrent);
			log.debug("Invocations changed! Add: {}, Remove: {}", adds, removes);
		}
		this.activeInvocations = activeCurrent;
	}

	private void displayPresetInvocations()
	{
		Widget parent = client.getWidget(WIDGET_ID_INVOCATIONS_PARENT, WIDGET_ID_INVOCATIONS_CHILD);
		InvocationPreset preset = getCurrentPreset();
		if (parent == null || parent.isHidden() || parent.getChildren() == null || preset == null)
		{
			return;
		}

		boolean scrolled = false;
		for (Invocation invoc : Invocation.values())
		{
			Widget invocW = parent.getChild(invoc.getWidgetIx());
			boolean targetState = preset.getInvocations().contains(invoc);
			boolean currentState = (Integer) invocW.getOnOpListener()[3] == 1;
			if (targetState != currentState)
			{
				if (!scrolled)
				{
					scrollToInvocation(invoc);
					scrolled = true;
				}
				Color targetColor = targetState ? Color.green : Color.red;
				invocW.setFilled(false);
				invocW.setTextColor(targetColor.getRGB());
				invocW.setOpacity(0);
			}
		}
	}

	private void displayPresetName()
	{
		Widget container = client.getWidget(774, 3);
		if (container == null || container.isHidden() || container.getChildren() == null || container.getChildren().length < 2)
		{
			return;
		}

		Widget title = container.getChild(1);
		if (title == null)
		{
			return;
		}

		if (title.getText().startsWith("Party of "))
		{
			originalHeaderText = title.getText();
		}

		InvocationPreset preset = getCurrentPreset();
		if (preset == null)
		{
			title.setText(originalHeaderText)
				.setTextColor(0xff981f)
				.revalidate();
			return;
		}

		boolean matching = preset.getInvocations().equals(getActiveInvocations());
		title.setText(preset.getName() + (matching ? "" : " !!!"))
			.setTextColor(matching ? Color.green.getRGB() : Color.red.getRGB())
			.revalidate();
	}

	private void removePresetDisplay()
	{
		// Remove the invocation highlights
		Widget parent = client.getWidget(WIDGET_ID_INVOCATIONS_PARENT, WIDGET_ID_INVOCATIONS_CHILD);
		if (parent != null && !parent.isHidden() && parent.getChildren() != null)
		{
			for (int i = 0; i < parent.getChildren().length; i += 3)
			{
				parent.getChild(i)
					.setOpacity(255)
					.setTextColor(Color.WHITE.getRGB())
					.revalidate();
			}
		}
	}

	private void scrollToInvocation(Invocation invocation)
	{
		if (!config.invocationPresetsScroll())
		{
			return;
		}

		clientThread.invokeLater(() ->
		{
			Widget invocationContainer = client.getWidget(WIDGET_ID_INVOCATIONS_PARENT, WIDGET_ID_INVOCATIONS_CHILD);
			Widget scrollbar = client.getWidget(WIDGET_ID_INVOCATIONS_PARENT, WIDGET_ID_INVOCATIONS_SCROLLBAR);
			if (invocationContainer == null || scrollbar == null)
			{
				return;
			}

			Widget invocW = invocationContainer.getChild(invocation.getWidgetIx());
			if (invocationContainer.getBounds().contains(invocW.getBounds()))
			{
				log.debug("{} already on screen ({} contains {})", invocation, invocationContainer.getBounds(), invocW.getBounds());
				return;
			}
			int newScroll = Math.max(
				0,
				Math.min(
					invocationContainer.getScrollHeight(),
					invocW.getRelativeY() + invocW.getHeight() / 2 - invocationContainer.getHeight() / 2
				)
			);

			client.runScript(
				ScriptID.UPDATE_SCROLLBAR,
				scrollbar.getId(),
				invocationContainer.getId(),
				newScroll
			);
		});
	}
}

package com.duckblade.osrs.toa.features.scabaras;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidRoom;
import com.duckblade.osrs.toa.util.RaidState;
import com.google.common.collect.ImmutableMap;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.Map;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameObject;
import net.runelite.api.ObjectID;
import net.runelite.api.Point;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class SkipObeliskOverlay extends Overlay implements PluginLifecycleComponent
{

	public enum EnableMode
	{
		SOLO_ONLY,
		ALWAYS,
		OFF,
		;
	}

	enum State
	{
		HIGHLIGHT_UPPER,
		HIGHLIGHT_LOWER,
		UNKNOWN,
		;
	}

	private static final int OBELISK_ID = 43876; // imposter as 11698 (inactive), 11699 (active)
	private static final Map<Point, State> QUADRANT_STATES = ImmutableMap.of(
		new Point(36, 57), State.HIGHLIGHT_LOWER, // top left
		new Point(53, 57), State.HIGHLIGHT_UPPER, // top right
		new Point(36, 45), State.HIGHLIGHT_UPPER, // bottom left
		new Point(53, 45), State.HIGHLIGHT_LOWER  // bottom right
	);

	private static final int FLAME_ID = ObjectID.BARRIER_45135;
	private static final Point FLAME_UPPER_HALF_LOC = new Point(28, 54);
	private static final Point FLAME_LOWER_HALF_LOC = new Point(28, 42);

	private final EventBus eventBus;
	private final OverlayManager overlayManager;
	private final ModelOutlineRenderer modelOutlineRenderer;

	private State state = State.UNKNOWN;
	private GameObject flameLower, flameUpper;

	private static final long BAD_RENDER_WARN_COOLDOWN = 10 * 1000;
	private long renderWarnCooldown = System.currentTimeMillis();

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState raidState)
	{
		switch (config.scabarasHighlightSkipObeliskEntry())
		{
			case ALWAYS:
				return raidState.getCurrentRoom() == RaidRoom.SCABARAS;

			case SOLO_ONLY:
				return raidState.getCurrentRoom() == RaidRoom.SCABARAS &&
					raidState.getPlayerCount() == 1;

			default:
				return false;
		}
	}

	@Override
	public void startUp()
	{
		reset();
		eventBus.register(this);
		overlayManager.add(this);
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
		overlayManager.remove(this);
	}

	private void reset()
	{
		state = State.UNKNOWN;
		flameLower = null;
		flameUpper = null;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (state == State.UNKNOWN)
		{
			return null;
		}

		GameObject toHighlight = state == State.HIGHLIGHT_LOWER ? flameLower : flameUpper;
		if (toHighlight == null && renderWarnCooldown < System.currentTimeMillis())
		{
			log.warn("Called to render with state {} but null highlight", state);
			renderWarnCooldown = System.currentTimeMillis() + BAD_RENDER_WARN_COOLDOWN;
			return null;
		}

		modelOutlineRenderer.drawOutline(toHighlight, 3, Color.green, 0);
		return null;
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned e)
	{
		checkForFlame(e.getGameObject());
		checkForObelisk(e.getGameObject());
	}

	@Subscribe
	public void onGameObjectDespawned(GameObjectDespawned e)
	{
		// in some unknown case, maybe unlocked fps only,
		// it's possible to get a render tick before the shutDown clears the references
		// so we should invalidate them early regardless if needed
		if (e.getGameObject().getId() == FLAME_ID
			|| e.getGameObject().getId() == OBELISK_ID)
		{
			reset();
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage e)
	{
		if (e.getMessage().startsWith("Your party failed to complete the challenge"))
		{
			reset();
		}
	}

	private void checkForFlame(GameObject obj)
	{
		if (obj.getId() == FLAME_ID)
		{
			Point scenePoint = obj.getSceneMinLocation(); // size 1 so this works
			log.debug("Found flame spawn ({}) at {}", obj.getId(), scenePoint);
			if (FLAME_UPPER_HALF_LOC.equals(scenePoint))
			{
				flameUpper = obj;
			}
			else if (FLAME_LOWER_HALF_LOC.equals(scenePoint))
			{
				flameLower = obj;
			}
		}
	}

	private void checkForObelisk(GameObject obj)
	{
		if (state != State.UNKNOWN || obj.getId() != OBELISK_ID)
		{
			return;
		}

		log.debug("Found obelisk ({}) spawn at {}", obj.getId(), obj.getSceneMinLocation());
		State derivedState = QUADRANT_STATES.get(obj.getSceneMinLocation());
		if (derivedState != null)
		{
			log.debug("Determined that obelisk puzzle is avoided by {}", state);
			state = derivedState;
		}
	}
}

package com.duckblade.osrs.toa.features.scabaras.overlay;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.features.scabaras.ScabarasHelperMode;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidRoom;
import com.duckblade.osrs.toa.util.RaidState;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.GroundObject;
import net.runelite.api.Point;
import net.runelite.api.Tile;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameTick;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class LightPuzzleSolver implements PluginLifecycleComponent
{

	private static final int GROUND_OBJECT_LIGHT_BACKGROUND = 45344;
	private static final int GAME_OBJECT_LIGHT_ENABLED = 45384;

	private static final Point[] SCENE_COORD_STARTS = {
		new Point(36, 56),
		new Point(36, 44),
		new Point(53, 56),
		new Point(53, 44),
	};

	private static final int[] LIGHTS_PUZZLE_XOR_ARRAY = {
		0B01110101,
		0B10111010,
		0B11001101,
		0B11001110,
		0B01110011,
		0B10110011,
		0B01011101,
		0B10101110,
	};

	private final EventBus eventBus;
	private final Client client;

	private boolean solved;
	private int tileStates = -1; // bitmask northwest to southeast

	@Getter
	private Set<LocalPoint> flips = Collections.emptySet();

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState raidState)
	{
		return config.scabarasHelperMode() == ScabarasHelperMode.OVERLAY &&
			raidState.getCurrentRoom() == RaidRoom.SCABARAS;
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);

		solved = false;
		solve();
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned e)
	{
		if (e.getGameObject().getId() == GAME_OBJECT_LIGHT_ENABLED)
		{
			solved = false;
		}
	}

	@Subscribe
	public void onGameObjectDespawned(GameObjectDespawned e)
	{
		if (e.getGameObject().getId() == GAME_OBJECT_LIGHT_ENABLED)
		{
			solved = false;
		}
	}

	@Subscribe
	public void onGameTick(GameTick e)
	{
		if (!solved)
		{
			solve();
		}
	}

	private void solve()
	{
		solved = true;

		Tile[][] sceneTiles = client.getScene().getTiles()[client.getPlane()];
		Point tl = findStartTile(sceneTiles);
		if (tl == null)
		{
			log.debug("Failed to locate start of light puzzle");
			return;
		}

		this.tileStates = readTileStates(sceneTiles, tl);
		this.flips = findSolution(tl);
	}

	private Point findStartTile(Tile[][] sceneTiles)
	{
		for (Point sceneCoordStart : SCENE_COORD_STARTS)
		{
			Tile startTile = sceneTiles[sceneCoordStart.getX()][sceneCoordStart.getY()];
			GroundObject groundObject = startTile.getGroundObject();
			if (groundObject != null && groundObject.getId() == GROUND_OBJECT_LIGHT_BACKGROUND)
			{
				return sceneCoordStart;
			}
		}

		return null;
	}

	private int readTileStates(Tile[][] sceneTiles, Point topLeft)
	{
		int tileStates = 0;
		for (int i = 0; i < 8; i++)
		{
			// middle of puzzle has no light
			// skip middle tile
			int tileIx = i > 3 ? i + 1 : i;
			int x = tileIx % 3;
			int y = tileIx / 3;
			Tile lightTile = sceneTiles[topLeft.getX() + (x * 2)][topLeft.getY() - (y * 2)];

			boolean active = Arrays.stream(lightTile.getGameObjects())
				.filter(Objects::nonNull)
				.mapToInt(GameObject::getId)
				.anyMatch(id -> id == GAME_OBJECT_LIGHT_ENABLED);

			log.debug("Read light ({}, {}) as active={}", x, y, active);
			if (active)
			{
				tileStates |= 1 << i;
			}
		}

		return tileStates;
	}

	private Set<LocalPoint> findSolution(Point topLeft)
	{
		int xor = 0;
		for (int i = 0; i < 8; i++)
		{
			// invert the state for xor (consider lights out as a 1)
			int mask = 1 << i;
			if ((tileStates & mask) != mask)
			{
				xor ^= LIGHTS_PUZZLE_XOR_ARRAY[i];
			}
		}

		// convert to scene points
		Set<LocalPoint> points = new HashSet<>();
		for (int i = 0; i < 8; i++)
		{
			int mask = 1 << i;
			if ((xor & mask) == mask)
			{
				// skip middle tile
				int tileIx = i > 3 ? i + 1 : i;
				int x = tileIx % 3;
				int y = tileIx / 3;
				points.add(LocalPoint.fromScene(topLeft.getX() + (x * 2), topLeft.getY() - (y * 2)));
			}
		}

		return points;
	}
}

package com.duckblade.osrs.toa.features.scabaras.overlay;

import java.awt.Color;
import lombok.Data;
import net.runelite.api.coords.LocalPoint;

@Data
public class MatchingTile
{

	private final LocalPoint localPoint;
	private final String name;
	private final Color color;
	private boolean matched;

}

package com.duckblade.osrs.toa.features.scabaras.overlay;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.features.scabaras.ScabarasHelperMode;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidRoom;
import com.duckblade.osrs.toa.util.RaidState;
import com.google.common.collect.EvictingQueue;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Tile;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GraphicsObjectCreated;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class SequencePuzzleSolver implements PluginLifecycleComponent
{

	private static final int GROUND_OBJECT_ID = 45340;
	private static final int DISPLAY_GAME_OBJECT_ID = 45341;
	private static final int STEPPED_GAME_OBJECT_ID = 45342;
	private static final int GRAPHICS_OBJECT_RESET = 302;

	private final EventBus eventBus;
	private final Client client;

	@Getter
	private final EvictingQueue<LocalPoint> points = EvictingQueue.create(5);

	@Getter
	private int completedTiles = 0;

	private boolean puzzleFinished = false;
	private int lastDisplayTick = 0;

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState raidState)
	{
		return config.scabarasHelperMode() == ScabarasHelperMode.OVERLAY &&
			raidState.getCurrentRoom() == RaidRoom.SCABARAS;
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);
		reset();
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned e)
	{
		if (puzzleFinished)
		{
			return;
		}

		switch (e.getGameObject().getId())
		{
			case DISPLAY_GAME_OBJECT_ID:
				if (lastDisplayTick == (lastDisplayTick = client.getTickCount()))
				{
					reset();
					puzzleFinished = true;
					return;
				}
				points.add(e.getTile().getLocalLocation());
				completedTiles = 0;
				break;

			case STEPPED_GAME_OBJECT_ID:
				completedTiles++;
				break;
		}
	}

	@Subscribe
	public void onGraphicsObjectCreated(GraphicsObjectCreated e)
	{
		if (e.getGraphicsObject().getId() == GRAPHICS_OBJECT_RESET)
		{
			LocalPoint gLoc = e.getGraphicsObject().getLocation();
			Tile gTile = client.getScene().getTiles()[client.getPlane()][gLoc.getSceneX()][gLoc.getSceneY()];
			if (gTile.getGroundObject() != null && gTile.getGroundObject().getId() == GROUND_OBJECT_ID)
			{
				reset();
			}
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage e)
	{
		if (e.getMessage().startsWith("Your party failed to complete the challenge"))
		{
			reset();
		}
	}

	private void reset()
	{
		puzzleFinished = false;
		points.clear();
		completedTiles = 0;
		lastDisplayTick = 0;
	}
}

package com.duckblade.osrs.toa.features.scabaras.overlay;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.features.scabaras.ScabarasHelperMode;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidRoom;
import com.duckblade.osrs.toa.util.RaidState;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.GroundObject;
import net.runelite.api.Point;
import net.runelite.api.Tile;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameTick;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.Text;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class AdditionPuzzleSolver implements PluginLifecycleComponent
{

	@RequiredArgsConstructor
	@Getter
	enum AdditionTile
	{
		LINE(1, 45345, 45388),
		KNIVES(2, 45346, 45389),
		TRIANGLE(3, 45347, 45390),
		DIAMOND(4, 45348, 45391),
		HAND(5, 45349, 45392),
		BIRD(6, 45350, 45393),
		CROOK(7, 45351, 45386),
		WIGGLE(8, 45352, 45394),
		FOOT(9, 45353, 45395),
		;

		private final int value;
		private final int groundObjectId;
		private final int gameObjectId;
	}

	private static final Set<Integer> GAME_OBJECT_IDS = Arrays.stream(AdditionTile.values())
		.map(AdditionTile::getGameObjectId)
		.collect(Collectors.toSet());

	private static final Point[] SCENE_COORD_STARTS = {
		new Point(36, 56),
		new Point(36, 44),
		new Point(53, 56),
		new Point(53, 44),
	};

	private static final Map<Integer, Set<Integer>> OPTIMAL_SOLUTIONS = ImmutableMap.<Integer, Set<Integer>>builder()
		.put(20, ImmutableSet.of(5, 11, 17))
		.put(21, ImmutableSet.of(10, 11, 17))
		.put(22, ImmutableSet.of(10, 11, 12, 18, 24))
		.put(23, ImmutableSet.of(5, 6, 7, 8, 14))
		.put(24, ImmutableSet.of(5, 11, 17, 23))
		.put(25, ImmutableSet.of(10, 11, 12, 13))
		.put(26, ImmutableSet.of(9, 10, 11, 12, 13))
		.put(27, ImmutableSet.of(5, 6, 7, 8, 4))
		.put(28, ImmutableSet.of(0, 1, 7, 13, 19))
		.put(29, ImmutableSet.of(10, 11, 12, 13, 19))
		.put(30, ImmutableSet.of(10, 11, 12, 13, 14))
		.put(31, ImmutableSet.of(0, 6, 12, 13, 14))
		.put(32, ImmutableSet.of(2, 3, 4, 6, 10))
		.put(33, ImmutableSet.of(4, 5, 6, 7, 8, 9, 14))
		.put(34, ImmutableSet.of(10, 11, 12, 13, 14, 19))
		.put(35, ImmutableSet.of(9, 10, 11, 12, 13, 14, 19))
		.put(36, ImmutableSet.of(0, 1, 2, 3, 4, 9, 14))
		.put(37, ImmutableSet.of(10, 11, 12, 13, 14, 19, 24))
		.put(38, ImmutableSet.of(0, 5, 6, 10, 12, 18, 24))
		.put(39, ImmutableSet.of(2, 3, 4, 7, 10, 11, 12))
		.put(40, ImmutableSet.of(4, 9, 10, 11, 12, 13, 14))
		.put(41, ImmutableSet.of(0, 4, 6, 9, 12, 13, 14))
		.put(42, ImmutableSet.of(0, 5, 9, 10, 11, 12, 13))
		.put(43, ImmutableSet.of(0, 1, 5, 7, 10, 13, 19))
		.put(44, ImmutableSet.of(0, 5, 10, 11, 14, 17, 18))
		.put(45, ImmutableSet.of(0, 1, 2, 3, 4, 5, 10))
		.build();

	private static final Pattern TARGET_NUMBER_PATTERN = Pattern.compile("The number (\\d+) has been hastily chipped into the stone.");

	private final EventBus eventBus;
	private final Client client;

	private boolean solved;
	private Set<Integer> tileStates;
	private int targetNumber;

	@Getter
	private Set<LocalPoint> flips = Collections.emptySet();

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState raidState)
	{
		return config.scabarasHelperMode() == ScabarasHelperMode.OVERLAY &&
			raidState.getCurrentRoom() == RaidRoom.SCABARAS;
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);

		this.targetNumber = 0;
		solved = false;
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned e)
	{
		if (GAME_OBJECT_IDS.contains(e.getGameObject().getId()))
		{
			solved = false;
		}
	}

	@Subscribe
	public void onGameObjectDespawned(GameObjectDespawned e)
	{
		if (GAME_OBJECT_IDS.contains(e.getGameObject().getId()))
		{
			solved = false;
		}
	}

	@Subscribe
	public void onGameTick(GameTick e)
	{
		if (!solved)
		{
			solve();
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage e)
	{
		if (e.getMessage().startsWith("Your party failed to complete the challenge"))
		{
			this.targetNumber = 0;
			solved = false;
			return;
		}

		Matcher matcher = TARGET_NUMBER_PATTERN.matcher(Text.removeTags(e.getMessage()));
		if (!matcher.matches())
		{
			return;
		}

		this.targetNumber = Integer.parseInt(matcher.group(1));
		solve();
	}

	private void solve()
	{
		solved = true;
		if (this.targetNumber < 20)
		{
			return;
		}

		Tile[][] sceneTiles = client.getScene().getTiles()[client.getPlane()];
		Point tl = findStartTile(sceneTiles);
		if (tl == null)
		{
			log.debug("Failed to locate start of addition puzzle");
			return;
		}

		this.tileStates = readTileStates(sceneTiles, tl);
		this.flips = findSolution(tl);
	}

	private Point findStartTile(Tile[][] sceneTiles)
	{
		for (Point sceneCoordStart : SCENE_COORD_STARTS)
		{
			Tile startTile = sceneTiles[sceneCoordStart.getX()][sceneCoordStart.getY()];
			GroundObject groundObject = startTile.getGroundObject();
			if (groundObject != null && groundObject.getId() == AdditionTile.FOOT.getGroundObjectId())
			{
				return sceneCoordStart;
			}
		}

		return null;
	}

	private Set<Integer> readTileStates(Tile[][] sceneTiles, Point topLeft)
	{
		Set<Integer> tileStates = new HashSet<>();
		for (int y = 0; y < 5; y++)
		{
			for (int x = 0; x < 5; x++)
			{
				Tile additionTile = sceneTiles[topLeft.getX() + x][topLeft.getY() - y];
				boolean active = Arrays.stream(additionTile.getGameObjects())
					.filter(Objects::nonNull)
					.mapToInt(GameObject::getId)
					.anyMatch(GAME_OBJECT_IDS::contains);

				if (active)
				{
					tileStates.add(y * 5 + x);
				}
			}
		}

		return tileStates;
	}

	// todo dynamic solving for when the user messes up
	private Set<LocalPoint> findSolution(Point topLeft)
	{
		Set<Integer> remaining = Sets.difference(OPTIMAL_SOLUTIONS.get(targetNumber), this.tileStates);

		return remaining.stream()
			.map(i -> LocalPoint.fromScene(topLeft.getX() + i % 5, topLeft.getY() - i / 5))
			.collect(Collectors.toSet());
	}
}

package com.duckblade.osrs.toa.features.scabaras.overlay;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.features.scabaras.ScabarasHelperMode;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidRoom;
import com.duckblade.osrs.toa.util.RaidState;
import java.util.ArrayList;
import java.util.List;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.NpcChanged;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class ObeliskPuzzleSolver implements PluginLifecycleComponent
{

	private static final int OBELISK_ID_INACTIVE = 11698;
	private static final int OBELISK_ID_ACTIVE = 11699;

	private final EventBus eventBus;

	@Getter
	private int activeObelisks = 0;

	@Getter
	private final List<LocalPoint> obeliskOrder = new ArrayList<>(6);

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState raidState)
	{
		return config.scabarasHelperMode() == ScabarasHelperMode.OVERLAY &&
			raidState.getCurrentRoom() == RaidRoom.SCABARAS;
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);
		activeObelisks = 0;
		obeliskOrder.clear();
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
	}

	@Subscribe
	public void onNpcChanged(NpcChanged e)
	{
		if (e.getNpc().getId() == OBELISK_ID_ACTIVE)
		{
			LocalPoint obeliskTile = e.getNpc().getLocalLocation();
			if (!obeliskOrder.contains(obeliskTile))
			{
				obeliskOrder.add(obeliskTile);
			}

			activeObelisks++;
		}
		else if (e.getNpc().getId() == OBELISK_ID_INACTIVE)
		{
			activeObelisks = 0;
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage e)
	{
		if (e.getMessage().startsWith("Your party failed to complete the challenge"))
		{
			activeObelisks = 0;
			obeliskOrder.clear();
		}
	}
}

package com.duckblade.osrs.toa.features.scabaras.overlay;

public enum MatchingTileDisplayMode
{

	DISABLED,
	TILE,
	NAME,
	BOTH,
	;

}

package com.duckblade.osrs.toa.features.scabaras.overlay;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.features.scabaras.ScabarasHelperMode;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidRoom;
import com.duckblade.osrs.toa.util.RaidState;
import com.google.common.collect.ImmutableMap;
import java.awt.Color;
import java.util.HashMap;
import java.util.Map;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GroundObjectSpawned;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class MatchingPuzzleSolver implements PluginLifecycleComponent
{

	private static final Map<Integer, String> TILE_NAMES = ImmutableMap.<Integer, String>builder().put(45365, "Line") // line
		.put(45366, "Knives") // knives
		.put(45367, "Crook") // crook
		.put(45368, "Diamond") // diamond
		.put(45369, "Hand") // hand
		.put(45370, "Star") // star
		.put(45371, "Bird") // bird
		.put(45372, "W") // wiggle
		.put(45373, "Boot") // boot
		.build();

	private static final Map<Integer, Color> TILE_COLORS = ImmutableMap.<Integer, Color>builder().put(45365, Color.black) // line
		.put(45366, Color.red) // knives
		.put(45367, Color.magenta) // crook
		.put(45368, Color.blue) // diamond
		.put(45369, Color.lightGray) // hand
		.put(45370, Color.cyan) // star
		.put(45371, Color.pink) // bird
		.put(45372, Color.yellow) // wiggle
		.put(45373, Color.green) // boot
		.build();

	private static final Map<Integer, Integer> MATCHED_OBJECT_IDS = ImmutableMap.<Integer, Integer>builder().put(45388, 45365) // line
		.put(45389, 45366) // knives
		.put(45386, 45367) // crook
		.put(45391, 45368) // diamond
		.put(45392, 45369) // hand
		.put(45387, 45370) // star
		.put(45393, 45371) // bird
		.put(45394, 45372) // wiggle
		.put(45395, 45373) // boot
		.build();

	private final EventBus eventBus;

	@Getter
	private final Map<LocalPoint, MatchingTile> discoveredTiles = new HashMap<>(18);

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState raidState)
	{
		return config.scabarasHelperMode() == ScabarasHelperMode.OVERLAY && raidState.getCurrentRoom() == RaidRoom.SCABARAS;
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);
		discoveredTiles.clear();
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
	}

	@Subscribe
	public void onGroundObjectSpawned(GroundObjectSpawned e)
	{
		int id = e.getGroundObject().getId();
		if (TILE_COLORS.containsKey(id))
		{
			LocalPoint lp = e.getGroundObject().getLocalLocation();
			discoveredTiles.put(lp, new MatchingTile(lp, TILE_NAMES.getOrDefault(id, "Unknown"), TILE_COLORS.getOrDefault(id, Color.black)));
		}
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned e)
	{
		int gameId = e.getGameObject().getId();
		if (MATCHED_OBJECT_IDS.containsKey(gameId))
		{
			MatchingTile match = discoveredTiles.get(e.getGameObject().getLocalLocation());
			if (match == null)
			{
				log.debug("Failed to find discovered tile for game object id {}!", gameId);
				return;
			}

			match.setMatched(true);
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage e)
	{
		if (e.getMessage().startsWith("Your party failed to complete the challenge"))
		{
			discoveredTiles.clear();
		}
	}
}

package com.duckblade.osrs.toa.features.scabaras.overlay;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.features.scabaras.ScabarasHelperMode;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidRoom;
import com.duckblade.osrs.toa.util.RaidState;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.ui.overlay.OverlayManager;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class ScabarasOverlayManager implements PluginLifecycleComponent
{

	private final EventBus eventBus;
	private final OverlayManager overlayManager;
	private final ScabarasOverlay scabarasOverlay;

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState currentState)
	{
		return config.scabarasHelperMode() == ScabarasHelperMode.OVERLAY &&
			currentState.getCurrentRoom() == RaidRoom.SCABARAS;
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);
		installOverlay();
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
		removeOverlay();
	}

	private void installOverlay()
	{
		overlayManager.add(scabarasOverlay);
	}

	private void removeOverlay()
	{
		overlayManager.remove(scabarasOverlay);
	}
}

package com.duckblade.osrs.toa.features.scabaras.overlay;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.Rectangle;
import java.util.Collection;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.util.ColorUtil;

@Singleton
public class ScabarasOverlay extends Overlay
{

	private final Client client;
	private final TombsOfAmascutConfig config;
	private final AdditionPuzzleSolver additionPuzzleSolver;
	private final LightPuzzleSolver lightPuzzleSolver;
	private final MatchingPuzzleSolver matchingPuzzleSolver;
	private final ObeliskPuzzleSolver obeliskPuzzleSolver;
	private final SequencePuzzleSolver sequencePuzzleSolver;

	@Inject
	public ScabarasOverlay(
		Client client, TombsOfAmascutConfig config, AdditionPuzzleSolver additionPuzzleSolver, LightPuzzleSolver lightPuzzleSolver,
		MatchingPuzzleSolver matchingPuzzleSolver, ObeliskPuzzleSolver obeliskPuzzleSolver, SequencePuzzleSolver sequencePuzzleSolver
	)
	{
		this.client = client;
		this.config = config;
		this.additionPuzzleSolver = additionPuzzleSolver;
		this.lightPuzzleSolver = lightPuzzleSolver;
		this.matchingPuzzleSolver = matchingPuzzleSolver;
		this.obeliskPuzzleSolver = obeliskPuzzleSolver;
		this.sequencePuzzleSolver = sequencePuzzleSolver;

		setLayer(OverlayLayer.ABOVE_SCENE);
		setPosition(OverlayPosition.DYNAMIC);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		renderLocalPoints(graphics, additionPuzzleSolver.getFlips(), config.scabarasAdditionTileColor());
		renderLocalPoints(graphics, lightPuzzleSolver.getFlips(), config.scabarasLightTileColor());

		renderLocalSequence(
			graphics,
			obeliskPuzzleSolver.getObeliskOrder(),
			obeliskPuzzleSolver.getActiveObelisks(),
			config.scabarasObeliskColorStart(),
			config.scabarasObeliskColorEnd()
		);
		renderLocalSequence(
			graphics,
			sequencePuzzleSolver.getPoints(),
			sequencePuzzleSolver.getCompletedTiles(),
			config.scabarasSequenceColorStart(),
			config.scabarasSequenceColorEnd()
		);

		renderLocalMatching(graphics, matchingPuzzleSolver.getDiscoveredTiles());
		return null;
	}

	private void renderLocalPoints(Graphics2D graphics, Set<LocalPoint> points, Color color)
	{
		for (LocalPoint tile : points)
		{
			Polygon canvasTilePoly = Perspective.getCanvasTilePoly(client, tile);
			if (canvasTilePoly != null)
			{
				OverlayUtil.renderPolygon(graphics, canvasTilePoly, color, new Color(0, 0, 0, Math.min(color.getAlpha(), 50)), new BasicStroke(2));
			}
		}
	}

	private void renderLocalSequence(Graphics2D graphics, Collection<LocalPoint> points, int progress, Color start, Color end)
	{
		int ix = 0;
		for (LocalPoint tile : points)
		{
			Color c = ix < progress ? ColorUtil.colorWithAlpha(Color.gray, start.getAlpha()) : ColorUtil.colorLerp(start, end, ix / 5.0);

			Polygon canvasTilePoly = Perspective.getCanvasTilePoly(client, tile);
			if (canvasTilePoly != null)
			{
				OverlayUtil.renderPolygon(graphics, canvasTilePoly, c, new Color(0, 0, 0, Math.min(c.getAlpha(), 50)), new BasicStroke(2));
				Rectangle bounds = canvasTilePoly.getBounds();
				renderTextLocationAlpha(
					graphics,
					new Point(bounds.x + bounds.width / 2, bounds.y + bounds.height / 2),
					String.valueOf(++ix),
					c
				);
			}
		}
	}

	private void renderLocalMatching(Graphics2D graphics, Map<LocalPoint, MatchingTile> matchingTiles)
	{
		MatchingTileDisplayMode mode = config.scabarasMatchingDisplayMode();
		if (mode == MatchingTileDisplayMode.DISABLED)
		{
			return;
		}

		int matchedOpacity = config.scabarasMatchingCompletedOpacity();
		boolean tile = mode == MatchingTileDisplayMode.TILE || mode == MatchingTileDisplayMode.BOTH;
		boolean name = mode == MatchingTileDisplayMode.NAME || mode == MatchingTileDisplayMode.BOTH;
		matchingTiles.values().forEach(mt ->
		{
			Polygon canvasTilePoly = Perspective.getCanvasTilePoly(client, mt.getLocalPoint());
			if (canvasTilePoly == null)
			{
				return;
			}

			Color color = mt.getColor();
			if (mt.isMatched())
			{
				color = new Color(color.getRed(), color.getGreen(), color.getBlue(), matchedOpacity);
			}

			if (tile)
			{
				OverlayUtil.renderPolygon(graphics, canvasTilePoly, color, new Color(0, 0, 0, Math.min(color.getAlpha(), 50)), new BasicStroke(2));
			}
			if (name)
			{
				Rectangle tileB = canvasTilePoly.getBounds();
				Rectangle txtB = graphics.getFontMetrics().getStringBounds(mt.getName(), graphics).getBounds();
				Point p = new Point(tileB.x + tileB.width / 2 - txtB.width / 2, tileB.y + tileB.height / 2 + txtB.height / 2);
				renderTextLocationAlpha(graphics, p, mt.getName(), color);
			}
		});
	}

	private void renderTextLocationAlpha(Graphics2D graphics, Point p, String text, Color c)
	{
		graphics.setColor(ColorUtil.colorWithAlpha(Color.black, c.getAlpha()));
		graphics.drawString(text, p.getX() + 1, p.getY() + 1);
		graphics.setColor(c);
		graphics.drawString(text, p.getX(), p.getY());
	}

}

package com.duckblade.osrs.toa.features.scabaras;

public enum ScabarasHelperMode
{

	OVERLAY,
	SIDE_PANEL,
	DISABLED,
	;

}

package com.duckblade.osrs.toa.features.scabaras.panel;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.features.scabaras.ScabarasHelperMode;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidRoom;
import com.duckblade.osrs.toa.util.RaidState;
import java.awt.image.BufferedImage;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.SwingUtilities;
import lombok.RequiredArgsConstructor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class ScabarasPanelManager implements PluginLifecycleComponent
{

	private static final BufferedImage PANEL_ICON = ImageUtil.loadImageResource(ScabarasPanelManager.class, "icon.png");

	private final ClientToolbar clientToolbar;
	private final ScabarasPanel scabarasPanel;

	private NavigationButton navButton;

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState currentState)
	{
		return config.scabarasHelperMode() == ScabarasHelperMode.SIDE_PANEL &&
			currentState.getCurrentRoom() == RaidRoom.SCABARAS;
	}

	@Override
	public void startUp()
	{
		if (navButton == null)
		{
			navButton = NavigationButton.builder()
				.icon(PANEL_ICON)
				.panel(scabarasPanel)
				.priority(999)
				.tooltip("Scabaras Tile Puzzle Helper")
				.build();
		}

		openPanel();
	}

	@Override
	public void shutDown()
	{
		removePanel();
	}

	private void openPanel()
	{
		clientToolbar.addNavigation(navButton);
		SwingUtilities.invokeLater(() -> clientToolbar.openPanel(navButton));
	}

	private void removePanel()
	{
		clientToolbar.removeNavigation(navButton);
	}
}

package com.duckblade.osrs.toa.features.scabaras.panel;

import java.awt.image.BufferedImage;
import javax.inject.Singleton;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.SwingConstants;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;

@Singleton
public class ScabarasPanel extends PluginPanel
{

	private static final BufferedImage TILE_PUZZLE_IMAGE = ImageUtil.loadImageResource(ScabarasPanel.class, "tile-puzzle.png");

	public ScabarasPanel()
	{
		setBorder(BorderFactory.createEmptyBorder());
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setAlignmentX(CENTER_ALIGNMENT);

		JLabel header = new JLabel("Orientation is EAST up!");
		header.setAlignmentX(CENTER_ALIGNMENT);
		header.setHorizontalAlignment(SwingConstants.CENTER);
		header.setBorder(BorderFactory.createEmptyBorder(10, 0, 10, 0));
		header.setFont(FontManager.getRunescapeFont().deriveFont(24f));
		add(header);

		JLabel tilesImgLabel = new JLabel(new ImageIcon(TILE_PUZZLE_IMAGE));
		tilesImgLabel.setAlignmentX(CENTER_ALIGNMENT);
		tilesImgLabel.setHorizontalAlignment(SwingConstants.CENTER);
		add(tilesImgLabel);
	}

}

/*
 * Copyright (c) 2022, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.duckblade.osrs.toa.features;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidState;
import java.awt.AlphaComposite;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.SpriteID;
import net.runelite.api.SpritePixels;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageCapture;
import net.runelite.client.util.ImageUploadStyle;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class InvocationScreenshot implements PluginLifecycleComponent
{
	private static final int INVOCATION_GROUP_ID = 774;
	private static final int INVOCATION_TITLE_CHILD_ID = 3;
	private static final int INVOCATION_CONTAINER_CHILD_ID = 52;
	private static final int INVOCATION_RIGHT_SIDE_CONTAINER_CHILD_ID = 57;
	private static final int INVOCATION_INFO_CONTAINER_CHILD_ID = 58;
	private static final int INVOCATION_REWARDS_CONTAINER_CHILD_ID = 87;
	private static final int REWARD_BUTTON_SELECTED_VARC = 1086;

	private static final int TOA_PARTY_WIDGET_SCRIPT_ID = 6617;

	private static final BufferedImage CAMERA_IMG = ImageUtil.loadImageResource(InvocationScreenshot.class, "camera.png");
	private static final int CAMERA_OVERRIDE_SPRITE_IDX = -420;
	private static final int CAMERA_HOVER_OVERRIDE_SPRITE_IDX = -421;

	private final EventBus eventBus;
	private final Client client;
	private final TombsOfAmascutConfig config;
	private final ClientThread clientThread;
	private final SpriteManager spriteManager;
	private final ImageCapture imageCapture;
	private final ItemManager itemManager;

	private Widget button = null;

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState currentState)
	{
		return config.invocationScreenshotEnable();
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);
		clientThread.invokeLater(this::createButton);
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
		button = null;
		removeCameraIconOverride();
	}

	@Subscribe
	public void onScriptPostFired(ScriptPostFired e)
	{
		if (e.getScriptId() != TOA_PARTY_WIDGET_SCRIPT_ID)
		{
			return;
		}

		createButton();
	}

	private void addCameraIconOverride()
	{
		client.getWidgetSpriteCache().reset();
		// Add images to a sprite background so it works with resource packs
		spriteManager.getSpriteAsync(SpriteID.EQUIPMENT_SLOT_TILE, 0, (img) ->
		{
			final BufferedImage cameraImg = overlapImages(CAMERA_IMG, img);
			client.getSpriteOverrides().put(CAMERA_OVERRIDE_SPRITE_IDX, ImageUtil.getImageSpritePixels(cameraImg, client));
		});
		spriteManager.getSpriteAsync(SpriteID.EQUIPMENT_SLOT_SELECTED, 0, (img) ->
		{
			final BufferedImage cameraImg = overlapImages(CAMERA_IMG, img);
			client.getSpriteOverrides().put(CAMERA_HOVER_OVERRIDE_SPRITE_IDX, ImageUtil.getImageSpritePixels(cameraImg, client));
		});
	}

	private void removeCameraIconOverride()
	{
		client.getWidgetSpriteCache().reset();
		client.getSpriteOverrides().remove(CAMERA_OVERRIDE_SPRITE_IDX);
		client.getSpriteOverrides().remove(CAMERA_HOVER_OVERRIDE_SPRITE_IDX);
	}

	private void createButton()
	{
		final Widget parent = client.getWidget(INVOCATION_GROUP_ID, INVOCATION_TITLE_CHILD_ID);
		if (parent == null)
		{
			return;
		}

		final Widget[] children = parent.getDynamicChildren();
		if (children == null || children.length == 0)
		{
			return;
		}

		// Check if the button was already added as the script will fire again once you add it
		for (Widget child : children)
		{
			if (child.equals(button))
			{
				return;
			}
		}
		// Call this again in case the sprite used as the background of the button changed with a recent ResourcePack change
		addCameraIconOverride();

		button = parent.createChild(-1, WidgetType.GRAPHIC);
		button.setOriginalHeight(20);
		button.setOriginalWidth(20);
		button.setOriginalX(430);
		button.setOriginalY(8);
		button.setSpriteId(CAMERA_OVERRIDE_SPRITE_IDX);
		button.setAction(0, "Screenshot Invocations");
		button.setOnOpListener((JavaScriptCallback) (e) -> clientThread.invokeLater(this::screenshot));
		button.setHasListener(true);
		button.revalidate();

		button.setOnMouseOverListener((JavaScriptCallback) (e) -> button.setSpriteId(CAMERA_HOVER_OVERRIDE_SPRITE_IDX));
		button.setOnMouseLeaveListener((JavaScriptCallback) (e) -> button.setSpriteId(CAMERA_OVERRIDE_SPRITE_IDX));
	}

	private void screenshot()
	{
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		client.getWidgetSpriteCache().reset();

		final Widget container = client.getWidget(INVOCATION_GROUP_ID, INVOCATION_CONTAINER_CHILD_ID);
		if (container == null)
		{
			return;
		}

		final Widget[] children = container.getDynamicChildren();
		if (children.length == 0)
		{
			return;
		}

		// Base the height on the first element, including its offset from the top of the page
		int height = children[0].getHeight() + children[0].getRelativeY();
		int y = 0;
		for (Widget invocation : children)
		{
			if (invocation.getRelativeY() > y)
			{
				y = invocation.getRelativeY() + 2; // Ensure at least 2pixels of padding exist between elements
				height = y + invocation.getHeight();
			}
		}

		int width = 287; // Hardcoded minimum width of the interface so that it can be drawn correctly even when on another tab
		boolean rewardButtonSelected = isRewardButtonSelected();
		if (!rewardButtonSelected)
		{
			// If the reward button isn't selected then the correct size can be pulled from the container regardless of the selected tab
			width = container.getWidth();
		}
		else if (config.showRewardsSection())
		{
			final Widget rightSideContainer = client.getWidget(INVOCATION_GROUP_ID, INVOCATION_RIGHT_SIDE_CONTAINER_CHILD_ID);
			assert rightSideContainer != null;
			width += rightSideContainer.getWidth();
		}
		final BufferedImage screenshot = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
		final Graphics graphics = screenshot.getGraphics();

		final BufferedImage background = getSprite(SpriteID.DIALOG_BACKGROUND);
		int x = screenshot.getWidth() / background.getWidth() + 1;
		y = screenshot.getHeight() / background.getHeight() + 1;
		for (int i = 0; i < x; i++)
		{
			for (int z = 0; z < y; z++)
			{
				graphics.drawImage(background, i * background.getWidth(), z * background.getHeight(), null);
			}
		}

		for (final Widget w : children)
		{
			if (w.getType() == WidgetType.RECTANGLE)
			{
				continue;
			}

			drawWidget(graphics, w, w.getRelativeX(), w.getRelativeY());
		}

		if (rewardButtonSelected && config.showRewardsSection())
		{
			final Widget rightSideContainer = client.getWidget(INVOCATION_GROUP_ID, INVOCATION_RIGHT_SIDE_CONTAINER_CHILD_ID);
			assert rightSideContainer != null;

			// Draw Invocation Level/Bar section
			final Widget infoContainer = client.getWidget(INVOCATION_GROUP_ID, INVOCATION_INFO_CONTAINER_CHILD_ID);
			int infoContainerHeight = 5; // default to 5 so there's at least a 5 px gap between these elements
			if (infoContainer != null && infoContainer.getStaticChildren().length > 0)
			{
				infoContainerHeight += infoContainer.getHeight();
				// Move the reward container closer since we don't draw the scrollbar
				Graphics layer = graphics.create(
					rightSideContainer.getRelativeX() - 30,
					rightSideContainer.getRelativeY() - 60,
					rightSideContainer.getWidth(),
					rightSideContainer.getHeight()
				);
				// We want to skip the child elements that draw the border
				Widget[] infoContainerChildren = infoContainer.getStaticChildren();
				infoContainerChildren[0] = null;
				infoContainerChildren[1] = null;

				drawWidgets(layer, infoContainerChildren);
				layer.dispose();
			}

			// Draw reward section
			final Widget rewardsContainer = client.getWidget(INVOCATION_GROUP_ID, INVOCATION_REWARDS_CONTAINER_CHILD_ID);
			if (rewardsContainer != null && rewardsContainer.getDynamicChildren().length > 0)
			{
				// Move the reward container closer since we don't draw the scrollbar
				Graphics layer = graphics.create(
					rightSideContainer.getRelativeX() - 30,
					rightSideContainer.getRelativeY() - 60 + infoContainerHeight,
					rightSideContainer.getWidth(),
					rightSideContainer.getHeight()
				);
				drawWidgets(layer, rewardsContainer.getDynamicChildren());
				layer.dispose();
			}
			else
			{
				log.warn("Couldn't find the invocation rewards container when it should have existed");
			}
		}

		// Convert from ARGB to RGB so it can be stored on the clipboard
		BufferedImage out = toBufferedImageOfType(screenshot, BufferedImage.TYPE_INT_RGB);

		imageCapture.takeScreenshot(out, "invocationscreenshot", "invocations", true, ImageUploadStyle.CLIPBOARD);
		final String message = new ChatMessageBuilder()
			.append(ChatColorType.HIGHLIGHT)
			.append("A screenshot of your current invocations was saved and inserted into your clipboard!")
			.build();
		client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", message, null);
	}

	private void drawWidgets(Graphics graphics, Widget[] widgets)
	{
		for (Widget w : widgets)
		{
			if (w == null)
			{
				continue;
			}

			if (w.getDynamicChildren().length > 0)
			{
				Graphics layer = graphics.create(w.getRelativeX(), w.getRelativeY(), w.getWidth(), w.getHeight());
				drawWidgets(layer, w.getDynamicChildren());
				layer.dispose();
			}
			else
			{
				drawWidget(graphics, w, w.getRelativeX(), w.getRelativeY());
			}
		}
	}

	private void drawWidget(Graphics graphics, Widget child, int x, int y)
	{
		if (child == null || child.getType() == 0)
		{
			return;
		}

		int width = child.getWidth();
		int height = child.getHeight();

		if (child.getSpriteId() > 0)
		{
			SpritePixels sp = getPixels(child.getSpriteId());
			assert sp != null;
			BufferedImage childImage = sp.toBufferedImage();

			if (child.getSpriteTiling())
			{
				Rectangle clips = graphics.getClipBounds();
				graphics.setClip(x, y, child.getWidth(), child.getHeight());

				for (int dx = x; dx < child.getWidth() + x; dx += sp.getMaxWidth())
				{
					for (int dy = y; dy < child.getHeight() + y; dy += sp.getMaxHeight())
					{

						drawAt(graphics, childImage, dx + sp.getOffsetX(), dy + sp.getOffsetY());
					}
				}

				graphics.setClip(clips);
			}
			else
			{
				if (width == childImage.getWidth() && height == childImage.getHeight())
				{
					drawAt(graphics, childImage, x, y);
				}
				else
				{
					drawScaled(graphics, childImage, x, y, width, height);
				}
			}
		}
		else if (child.getItemId() > 0)
		{
			BufferedImage image = itemManager.getImage(itemManager.canonicalize(child.getItemId()), 1, false);
			if (child.getOpacity() > 0)
			{
				image = ImageUtil.alphaOffset(image, child.getOpacity() / 255f);
				// Convert to RGB
				BufferedImage copy = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_RGB);
				Graphics2D g = copy.createGraphics();
				g.setComposite(AlphaComposite.Src);
				g.setColor(new Color(0, 0, 0, child.getOpacity()));
				g.drawImage(image, 0, 0, null);
				g.dispose();
			}
			graphics.drawImage(image, child.getRelativeX(), child.getRelativeY(), null);
		}
		else if (child.getType() == WidgetType.TEXT)
		{
			final String text = Text.removeTags(child.getText());
			Font font = FontManager.getRunescapeSmallFont();

			x = child.getRelativeX();
			y = child.getRelativeY();
			width = child.getWidth();
			height = child.getHeight();

			final Graphics textLayer = graphics.create(x, y, width, height);
			textLayer.setFont(font);

			int xPos = 0;
			int yPos = 0;

			int textWidth = textLayer.getFontMetrics().stringWidth(text);

			if (child.getXTextAlignment() == 1)
			{
				xPos = (width - textWidth) / 2 + 1;
			}

			if (child.getYTextAlignment() == 0)
			{
				yPos = font.getSize() - 3;
			}
			else if (child.getYTextAlignment() == 1)
			{
				yPos = (height + font.getSize()) / 2 - 1;
			}
			else if (child.getYTextAlignment() == 2)
			{
				yPos = height;
			}

			if (child.getTextShadowed())
			{
				textLayer.setColor(Color.BLACK);
				textLayer.drawString(text, xPos, yPos);
				xPos -= 1;
				yPos -= 1;
			}

			textLayer.setColor(new Color(child.getTextColor()));
			textLayer.drawString(text, xPos, yPos);
			textLayer.dispose();
		}
		else if (child.getType() == WidgetType.RECTANGLE || child.getType() == WidgetType.GRAPHIC)
		{
			Color c = new Color(child.getTextColor());
			if (child.getOpacity() > 0)
			{
				c = new Color(c.getRed(), c.getGreen(), c.getBlue(), child.getOpacity());
			}
			graphics.setColor(c);
			final Rectangle r = child.getBounds();
			graphics.drawRect(child.getRelativeX(), child.getRelativeY(), r.width, r.height);
		}
	}

	@Nullable
	private SpritePixels getPixels(int archive)
	{
		if (config.useResourcePack())
		{
			SpritePixels pixels = client.getSpriteOverrides().get(archive);
			if (pixels != null)
			{
				return pixels;
			}
		}

		SpritePixels[] sp = client.getSprites(client.getIndexSprites(), archive, 0);
		assert sp != null;
		return sp[0];
	}

	private BufferedImage getSprite(int id)
	{
		SpritePixels sp = getPixels(id);
		assert sp != null;
		return sp.toBufferedImage();
	}

	private void drawScaled(Graphics graphics, BufferedImage image, int x, int y, int width, int height)
	{
		image = ImageUtil.resizeCanvas(image, width, height);
		graphics.drawImage(image, x, y, null);
	}

	private void drawAt(Graphics graphics, BufferedImage image, int x, int y)
	{
		graphics.drawImage(image, x, y, null);
	}

	private static BufferedImage overlapImages(final BufferedImage foreground, final BufferedImage background)
	{
		final int centeredX = background.getWidth() / 2 - foreground.getWidth() / 2;
		final int centeredY = background.getHeight() / 2 - foreground.getHeight() / 2;

		BufferedImage combined = new BufferedImage(background.getWidth(), background.getHeight(), BufferedImage.TYPE_INT_ARGB);
		Graphics2D g2d = combined.createGraphics();
		g2d.drawImage(background, 0, 0, null);

		g2d.drawImage(foreground, centeredX, centeredY, null);
		g2d.dispose();

		return combined;
	}

	private static BufferedImage toBufferedImageOfType(BufferedImage original, int type)
	{
		if (original == null || original.getType() == type)
		{
			return original;
		}

		BufferedImage out = new BufferedImage(original.getWidth(), original.getHeight(), type);
		Graphics2D g = out.createGraphics();
		g.setComposite(AlphaComposite.Src);
		g.drawImage(original, 0, 0, null);
		g.dispose();

		return out;
	}

	private boolean isRewardButtonSelected()
	{
		return client.getVarcIntValue(REWARD_BUTTON_SELECTED_VARC) == 0;
	}
}

package com.duckblade.osrs.toa.features;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidState;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Varbits;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class SmellingSaltsCooldown implements PluginLifecycleComponent
{

	private final EventBus eventBus;
	private final Client client;
	private final TombsOfAmascutConfig config;

	private long lastSalt;
	private int lastSaltVarb;
	private boolean clickConsumeQueued;

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState raidState)
	{
		return raidState.isInRaid()
			&& config.smellingSaltsCooldown() > 0;
	}

	@Override
	public void startUp()
	{
		clickConsumeQueued = false;
		lastSalt = 0;
		eventBus.register(this);
		lastSaltVarb = client.getVarbitValue(Varbits.BUFF_STAT_BOOST);
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged e)
	{
		if (e.getVarbitId() == Varbits.BUFF_STAT_BOOST)
		{
			if (e.getValue() > lastSaltVarb)
			{
				log.debug("Detected salt consumption");
				lastSalt = e.getValue();
				lastSalt = System.currentTimeMillis();
			}
			lastSaltVarb = e.getValue();
		}
	}

	@Subscribe
	public void onGameTick(GameTick e)
	{
		if (clickConsumeQueued)
		{
			client.addChatMessage(
				ChatMessageType.GAMEMESSAGE,
				"",
				"You are already boosted by smelling salts!",
				null
			);
			clickConsumeQueued = false;
		}
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked e)
	{
		if (e.getMenuTarget().contains("Smelling salts")
			&& e.getMenuOption().equals("Crush"))
		{
			long now = System.currentTimeMillis();
			if (now - lastSalt < (config.smellingSaltsCooldown() * 1000L))
			{
				// delay the blocking chat message until the next game tick to feel a bit more authentic (and less spammy)
				clickConsumeQueued = true;
				e.consume();
			}
		}
	}
}

package com.duckblade.osrs.toa.features.boss.kephri.swarmer;

import lombok.Data;
import net.runelite.api.NPC;

@Data
public class SwarmNpc
{
	private final NPC npc;
	private final int waveSpawned;
}
package com.duckblade.osrs.toa.features.boss.kephri.swarmer;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class SwarmerRoomData
{

	private int down;
	private int wave;
	private int leaks;

}

package com.duckblade.osrs.toa.features.boss.kephri.swarmer;

import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Font;
import java.util.Comparator;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.DefaultListCellRenderer;
import javax.swing.DefaultListModel;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import net.runelite.client.ui.PluginPanel;

@Singleton
public class SwarmerPanel extends PluginPanel
{
	private static final String[] LEAKS_COLUMN_NAMES = {"Down", "Wave", "Leaks"};

	private static final Color textColor = Color.WHITE;
	private static final Color tableColor1 = new Color(0x1F1F1F);
	private static final Color tableColor2 = new Color(0x2D2D2D);

	private final SwarmerDataManager swarmerDataManager;

	private final DefaultListModel<String> raidsListModel;
	private final DefaultTableModel leaksTableModel;

	private String loadedRaidData;
	private String selectedRaid;

	@Inject
	SwarmerPanel(SwarmerDataManager swarmerDataManager)
	{
		super(false);
		this.swarmerDataManager = swarmerDataManager;

		Font tableTitleFont = new Font(SwarmerFonts.REGULAR.toString(), Font.PLAIN, 18);
		Font tableFont = new Font(SwarmerFonts.VERDANA.toString(), Font.PLAIN, 12);

		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		add(Box.createVerticalStrut(20));

		JPanel recentRaidsPanel = new JPanel();
		recentRaidsPanel.setLayout(new BoxLayout(recentRaidsPanel, BoxLayout.Y_AXIS));

		JLabel recentRaidsLabel = new JLabel("Recent Raids");
		recentRaidsLabel.setForeground(textColor);
		recentRaidsLabel.setFont(tableTitleFont);
		recentRaidsLabel.setHorizontalAlignment(SwingConstants.CENTER);
		recentRaidsLabel.setAlignmentX(CENTER_ALIGNMENT);
		recentRaidsPanel.add(recentRaidsLabel);
		recentRaidsPanel.add(Box.createVerticalStrut(5));

		raidsListModel = new DefaultListModel<>();
		JList<String> raidsList = new JList<>(raidsListModel);
		raidsList.setBackground(tableColor1);
		raidsList.setForeground(textColor);
		raidsList.setFont(tableFont);
		raidsList.setSelectionBackground(tableColor2);
		raidsList.setSelectionForeground(textColor);
		raidsList.addListSelectionListener(e ->
		{
			if (!e.getValueIsAdjusting())
			{
				String selectedRaid = raidsList.getSelectedValue();
				if (selectedRaid != null)
				{
					this.selectedRaid = selectedRaid;
					loadRaidData(selectedRaid);
				}
			}
		});
		raidsList.setCellRenderer(new DefaultListCellRenderer()
		{
			@Override
			public Component getListCellRendererComponent(JList<?> list, Object value, int index, boolean isSelected, boolean cellHasFocus)
			{
				JLabel label = (JLabel) super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
				label.setHorizontalAlignment(SwingConstants.CENTER);
				label.setBackground(value.equals(selectedRaid) ? tableColor2 : tableColor1);
				label.setPreferredSize(new Dimension(label.getPreferredSize().width, 25));
				return label;
			}
		});

		recentRaidsPanel.add(new JScrollPane(raidsList));
		add(recentRaidsPanel);
		add(Box.createVerticalStrut(20));

		JPanel leaksPanel = new JPanel();
		leaksPanel.setLayout(new BoxLayout(leaksPanel, BoxLayout.Y_AXIS));

		JLabel leaksLabel = new JLabel("Leaks");
		leaksLabel.setForeground(textColor);
		leaksLabel.setFont(tableTitleFont);
		leaksLabel.setHorizontalAlignment(SwingConstants.CENTER);
		leaksLabel.setAlignmentX(CENTER_ALIGNMENT);
		leaksPanel.add(leaksLabel);
		leaksPanel.add(Box.createVerticalStrut(5));

		leaksTableModel = new DefaultTableModel()
		{
			@Override
			public boolean isCellEditable(int row, int column)
			{
				return false;
			}
		};
		JTable leaksTable = new JTable(leaksTableModel);
		leaksTable.setRowSelectionAllowed(false);
		leaksTable.setColumnSelectionAllowed(false);
		leaksTable.setCellSelectionEnabled(false);
		leaksTable.setBackground(tableColor1);
		leaksTable.setForeground(textColor);
		leaksTable.setGridColor(tableColor1);
		leaksTable.setFont(tableFont);

		DefaultTableCellRenderer leaksCellRenderer = new DefaultTableCellRenderer()
		{
			@Override
			public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column)
			{
				Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
				c.setBackground(row % 2 == 0 ? tableColor1 : tableColor2);
				c.setForeground(textColor);
				return c;
			}
		};
		leaksCellRenderer.setHorizontalAlignment(SwingConstants.CENTER);
		leaksTable.setDefaultRenderer(Object.class, leaksCellRenderer);

		JScrollPane leaksScrollPane = new JScrollPane(leaksTable);
		leaksScrollPane.setPreferredSize(new Dimension(100, 400));

		leaksPanel.add(leaksScrollPane);
		add(leaksPanel);
		add(Box.createVerticalStrut(20));
	}

	public void loadRaidData(String raid)
	{
		if (raid == null || raid.equals(loadedRaidData))
		{
			return;
		}

		// set this early to prevent multi-clicks from possibly beating out the execution of the read.
		loadedRaidData = raid;
		swarmerDataManager.getRaidData(raid)
			.thenAccept(raidDataList -> SwingUtilities.invokeLater(() ->
			{
				Object[][] newData = raidDataList.stream()
					.sorted(Comparator.comparing(SwarmerRoomData::getDown)
						.thenComparing(SwarmerRoomData::getWave))
					.map(row -> new Object[]{row.getDown(), row.getWave(), row.getLeaks()})
					.toArray(Object[][]::new);
				leaksTableModel.setDataVector(newData, LEAKS_COLUMN_NAMES);
			}));
	}

	public void updateRecentRaids()
	{
		swarmerDataManager.getRaidList()
			.thenAccept(raids -> SwingUtilities.invokeLater(() ->
			{
				raidsListModel.clear();
				raidsListModel.addAll(raids);
			}));
	}

}

package com.duckblade.osrs.toa.features.boss.kephri.swarmer;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidRoom;
import com.duckblade.osrs.toa.util.RaidState;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.Shape;
import java.awt.font.FontRenderContext;
import java.awt.font.TextLayout;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;
import net.runelite.api.Point;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.NpcSpawned;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPosition;

@Slf4j
@Singleton
public class SwarmerOverlay extends Overlay implements PluginLifecycleComponent
{
	private static final int ANIMATION_KEPHRI_DOWN = 9579;
	private static final int ANIMATION_KEPHRI_UP = 9581;
	private static final int ANIMATION_SWARM_LEAK = 9607;
	private static final int ANIMATION_SWARM_DEATH = 9608;

	private static final String ROOM_ENDED_MESSAGE = "Challenge complete: Kephri.";
	private static final String ROOM_FAIL_MESSAGE = "Your party failed to complete";

	private final Client client;
	private final EventBus eventBus;
	private final OverlayManager overlayManager;
	private final TombsOfAmascutConfig config;
	private final SwarmerDataManager swarmerDataManager;
	private final SwarmerPanel swarmerPanel;

	private final Map<Integer, SwarmNpc> aliveSwarms = new HashMap<>();
	private final Map<Integer, Map<Integer, Integer>> leaks = new HashMap<>();

	private int waveNumber;
	private int kephriDownCount;

	private boolean isKephriDowned;
	private int lastSpawnTick;

	@Inject
	public SwarmerOverlay(Client client, EventBus eventBus, OverlayManager overlayManager, TombsOfAmascutConfig config, SwarmerDataManager swarmerDataManager, SwarmerPanel swarmerPanel)
	{
		this.client = client;
		this.eventBus = eventBus;
		this.overlayManager = overlayManager;
		this.config = config;
		this.swarmerDataManager = swarmerDataManager;
		this.swarmerPanel = swarmerPanel;

		setPriority(Overlay.PRIORITY_HIGH);
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState raidState)
	{
		return config.swarmerOverlay()
			&& raidState.getCurrentRoom() == RaidRoom.KEPHRI;
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);
		overlayManager.add(this);
		reset();
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
		overlayManager.remove(this);
		reset();
	}

	private void reset()
	{
		leaks.clear();
		aliveSwarms.clear();
		isKephriDowned = false;
		lastSpawnTick = -1;
		waveNumber = 0;
		kephriDownCount = 0;
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned event)
	{
		final NPC npc = event.getNpc();
		final int npcId = npc.getId();

		if (isKephriDowned && npcId == NpcID.SCARAB_SWARM_11723)
		{
			int thisTick = client.getTickCount();
			if (lastSpawnTick != thisTick)
			{
				waveNumber++;
				lastSpawnTick = thisTick;
			}

			SwarmNpc swarm = new SwarmNpc(npc, waveNumber);
			aliveSwarms.put(npc.getIndex(), swarm);
		}
	}

	@Subscribe
	public void onAnimationChanged(AnimationChanged e)
	{
		if (!(e.getActor() instanceof NPC))
		{
			return;
		}

		NPC npc = ((NPC) e.getActor());
		if (npc.getId() == NpcID.SCARAB_SWARM_11723)
		{
			handleSwarmAnimationChanged(npc);
		}
		else if (npc.getId() == NpcID.KEPHRI || npc.getId() == NpcID.KEPHRI_11720)
		{
			handleKephriAnimationChanged(npc);
		}
	}

	private void handleSwarmAnimationChanged(NPC npc)
	{
		SwarmNpc swarm = aliveSwarms.get(npc.getIndex());
		if (swarm == null)
		{
			return;
		}

		if (npc.getAnimation() == ANIMATION_SWARM_LEAK)
		{
			aliveSwarms.remove(npc.getIndex());
			leaks.compute(kephriDownCount, (downs, waveMap) ->
			{
				Map<Integer, Integer> waveLeaks = waveMap != null ? waveMap : new HashMap<>();
				waveLeaks.compute(swarm.getWaveSpawned(), (wave, count) -> count != null ? count + 1 : 1);
				return waveLeaks;
			});
		}
		else if (npc.getAnimation() == ANIMATION_SWARM_DEATH)
		{
			aliveSwarms.remove(npc.getIndex());
		}
	}

	private void handleKephriAnimationChanged(NPC npc)
	{
		if (!isKephriDowned && npc.getAnimation() == ANIMATION_KEPHRI_DOWN)
		{
			isKephriDowned = true;
			kephriDownCount++;
			waveNumber = 0;
			aliveSwarms.clear();
		}
		else if (isKephriDowned && npc.getAnimation() == ANIMATION_KEPHRI_UP)
		{
			isKephriDowned = false;
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (!event.getType().equals(ChatMessageType.GAMEMESSAGE))
		{
			return;
		}

		if (event.getMessage().startsWith(ROOM_ENDED_MESSAGE))
		{
			List<SwarmerRoomData> swarmData = new ArrayList<>();
			for (Map.Entry<Integer, Map<Integer, Integer>> e : leaks.entrySet())
			{
				int down = e.getKey();
				for (Map.Entry<Integer, Integer> f : e.getValue().entrySet())
				{
					int wave = f.getKey();
					int leaks = f.getValue();
					swarmData.add(new SwarmerRoomData(down, wave, leaks));
				}
			}
			swarmerDataManager.saveRaidData(swarmData)
				.thenRun(() ->
				{
					if (config.swarmerSidePanel() != SwarmerPanelManager.PanelMode.NEVER)
					{
						swarmerPanel.updateRecentRaids();
					}
				});
		}

		if (event.getMessage().startsWith(ROOM_FAIL_MESSAGE))
		{
			reset();
		}
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		graphics.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
		aliveSwarms.values()
			.stream()
			.collect(Collectors.groupingBy(swarm -> swarm.getNpc().getWorldLocation()))
			.values()
			.forEach(tileSwarms ->
			{
				int stackOffset = 0;
				for (SwarmNpc swarm : tileSwarms)
				{
					this.draw(graphics, swarm, stackOffset);
					stackOffset += graphics.getFontMetrics().getHeight();
				}
			});
		return null;
	}

	private void draw(Graphics2D graphics, SwarmNpc swarmer, int offset)
	{
		String text = String.valueOf(swarmer.getWaveSpawned());

		Point canvasTextLocation = swarmer.getNpc().getCanvasTextLocation(graphics, text, 0);
		if (canvasTextLocation == null)
		{
			return;
		}
		int x = canvasTextLocation.getX();
		int y = canvasTextLocation.getY() + offset;

		Font font = new Font(config.swarmerFontType().toString(), config.useBoldFont() ? Font.BOLD : Font.PLAIN, config.swarmerFontSize());
		FontRenderContext frc = graphics.getFontRenderContext();
		TextLayout tl = new TextLayout(text, font, frc);
		Shape outline = tl.getOutline(null);
		graphics.translate(x, y);
		graphics.setStroke(new BasicStroke(3));
		graphics.setColor(Color.BLACK);
		graphics.draw(outline);
		graphics.setColor(config.swarmerFontColor());
		graphics.fill(outline);
		graphics.translate(-x, -y);
	}
}

package com.duckblade.osrs.toa.features.boss.kephri.swarmer;

import lombok.Getter;

@Getter
public enum SwarmerFonts
{
	REGULAR("RS Regular"),
	ARIAL("Arial"),
	CAMBRIA("Cambria"),
	ROCKWELL("Rockwell"),
	SEGOE_UI("Segoe Ui"),
	TIMES_NEW_ROMAN("Times New Roman"),
	VERDANA("Verdana"),
	DIALOG("DIALOG"),
	RUNESCAPE("RuneScape");

	private final String name;

	public String toString()
	{
		return this.name;
	}

	SwarmerFonts(String name)
	{
		this.name = name;
	}

}

package com.duckblade.osrs.toa.features.boss.kephri.swarmer;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidState;
import java.awt.image.BufferedImage;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.SwingUtilities;
import lombok.RequiredArgsConstructor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class SwarmerPanelManager implements PluginLifecycleComponent
{

	public enum PanelMode
	{
		ALWAYS,
		AT_TOA,
		NEVER,
		;
	}

	private static final BufferedImage PANEL_ICON = ImageUtil.loadImageResource(SwarmerPanelManager.class, "icon.png");

	private final ClientToolbar clientToolbar;
	private final SwarmerPanel swarmerPanel;

	private NavigationButton navButton;

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState raidState)
	{
		switch (config.swarmerSidePanel())
		{
			case ALWAYS:
				return true;

			case AT_TOA:
				return raidState.isInLobby() || raidState.isInRaid();

			case NEVER:
			default:
				return false;
		}
	}

	@Override
	public void startUp()
	{
		SwingUtilities.invokeLater(() ->
		{
			navButton = NavigationButton.builder()
				.tooltip("Swarmer")
				.icon(PANEL_ICON)
				.priority(999)
				.panel(swarmerPanel)
				.build();
			clientToolbar.addNavigation(navButton);
			swarmerPanel.updateRecentRaids();
		});
	}

	@Override
	public void shutDown()
	{
		clientToolbar.removeNavigation(navButton);
	}
}

package com.duckblade.osrs.toa.features.boss.kephri.swarmer;

import com.duckblade.osrs.toa.TombsOfAmascutPlugin;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.google.common.util.concurrent.ThreadFactoryBuilder;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import java.io.File;
import java.io.FileReader;
import java.lang.reflect.Type;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.text.SimpleDateFormat;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class SwarmerDataManager implements PluginLifecycleComponent
{

	private static final int MAX_RECENT_RAIDS = 10;
	public static final Path SWARMS_DIRECTORY = new File(TombsOfAmascutPlugin.TOA_FOLDER, "kephri-swarms").toPath();

	private final Gson gson;

	private ExecutorService executor;

	@Override
	public void startUp()
	{
		executor = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder().setNameFormat("ToA-SwarmerDataManager-%d").build());
	}

	@Override
	public void shutDown()
	{
		executor.shutdown();
	}

	public CompletableFuture<List<String>> getRaidList()
	{
		return CompletableFuture.supplyAsync(() ->
		{
			try
			{
				if (!Files.exists(SWARMS_DIRECTORY))
				{
					return Collections.emptyList();
				}

				try (Stream<Path> files = Files.list(SWARMS_DIRECTORY))
				{
					return files.filter(f -> f.getFileName().toString().endsWith(".json"))
						.sorted(Comparator.reverseOrder())
						.limit(MAX_RECENT_RAIDS)
						.map(f -> f.getFileName().toString().replace(".json", ""))
						.map(s -> s.replace('_', ':'))
						.collect(Collectors.toList());
				}
			}
			catch (Exception ignored)
			{
			}

			return Collections.emptyList();
		}, executor);
	}

	public CompletableFuture<List<SwarmerRoomData>> getRaidData(String raidUnsafe)
	{
		return CompletableFuture.supplyAsync(() ->
		{
			String raid = raidUnsafe.replace(':', '_');

			if (!Files.exists(SWARMS_DIRECTORY))
			{
				return Collections.emptyList();
			}
			if (!Files.exists(SWARMS_DIRECTORY.resolve(raid + ".json")))
			{
				return Collections.emptyList();
			}

			try (FileReader reader = new FileReader(SWARMS_DIRECTORY.resolve(raid + ".json").toFile()))
			{
				Type listType = new TypeToken<List<SwarmerRoomData>>()
				{
				}.getType();
				return gson.fromJson(reader, listType);
			}
			catch (Exception ignored)
			{
				return Collections.emptyList();
			}
		}, executor);
	}

	public CompletableFuture<Void> saveRaidData(List<SwarmerRoomData> raidDataList)
	{
		return CompletableFuture.runAsync(() ->
		{
			String raidName = new SimpleDateFormat("yyyy-MM-dd HH_mm_ss").format(new Date());
			try
			{
				if (!Files.exists(SWARMS_DIRECTORY))
				{
					Files.createDirectories(SWARMS_DIRECTORY);
				}
				Files.writeString(
					SWARMS_DIRECTORY.resolve(raidName + ".json"),
					gson.toJson(raidDataList),
					StandardOpenOption.CREATE,
					StandardOpenOption.TRUNCATE_EXISTING
				);
			}
			catch (Exception ignored)
			{
			}
		});
	}
}
package com.duckblade.osrs.toa.features.boss.akkha;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.features.PathLevelTracker;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.NpcUtil;
import com.duckblade.osrs.toa.util.RaidRoom;
import com.duckblade.osrs.toa.util.RaidState;
import com.duckblade.osrs.toa.util.RaidStateTracker;
import java.util.HashMap;
import java.util.Map;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;
import net.runelite.api.Varbits;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class AkkhaShadowHealth implements PluginLifecycleComponent
{
	private static final int BASE_HP_AKKHAS_SHADOW = 70;

	private final EventBus eventBus;
	private final Client client;
	private final PathLevelTracker pathLevelTracker;
	private final RaidStateTracker raidStateTracker;

	@Getter(AccessLevel.PACKAGE)
	private final Map<NPC, Integer> akkhasShadows = new HashMap<>();

	@Getter(AccessLevel.PACKAGE)
	private int akkhasShadowMaxHp;

	@Override
	public boolean isEnabled(final TombsOfAmascutConfig config, final RaidState raidState)
	{
		return raidState.getCurrentRoom() == RaidRoom.AKKHA;
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);
		updateAkkhasShadowMaxHp();
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
		reset();
	}

	private void reset()
	{
		akkhasShadows.clear();
		akkhasShadowMaxHp = 0;
	}

	@Subscribe
	private void onGameTick(final GameTick event)
	{
		akkhasShadows.entrySet().forEach(e ->
		{
			NPC npc = e.getKey();
			if (npc.getModel() != null && npc.getModel().getOverrideAmount() != 0)
			{
				// inactive state uses model overrides to "white-out" the npc
				e.setValue(-1);
				return;
			}

			final int trueHp = NpcUtil.calculateActorHp(e.getKey(), akkhasShadowMaxHp);
			if (trueHp != -1)
			{
				e.setValue(trueHp);
			}
		});
	}

	@Subscribe
	private void onNpcSpawned(final NpcSpawned event)
	{
		final NPC npc = event.getNpc();

		if (npc.getId() == NpcID.AKKHAS_SHADOW)
		{
			akkhasShadows.put(npc, akkhasShadowMaxHp);
		}
	}

	@Subscribe
	private void onNpcDespawned(final NpcDespawned event)
	{
		final NPC npc = event.getNpc();

		if (npc.getId() == NpcID.AKKHAS_SHADOW)
		{
			akkhasShadows.remove(npc);
		}
	}

	private void updateAkkhasShadowMaxHp()
	{
		// Calculate max hp manually as NPCManager does not have this information
		int hp = BASE_HP_AKKHAS_SHADOW;

		final int raidLevelFactor = 4 * client.getVarbitValue(Varbits.TOA_RAID_LEVEL) / 10;
		hp += hp * raidLevelFactor / 100;

		final int pathLevel = pathLevelTracker.getAkkhaPathLevel();
		if (pathLevel > 0)
		{
			// first level is 8%, others are 5%
			final int pathLevelFactor = 3 + 5 * pathLevel;
			hp += hp * pathLevelFactor / 100;
		}

		final int partySize = raidStateTracker.getPlayerCount();
		if (partySize >= 2)
		{
			int partyFactor = 9 * (partySize == 3 ? 2 : 1);
			if (partySize >= 4)
			{
				partyFactor += 6 * (partySize - 3);
			}
			hp += hp * partyFactor / 10;
		}

		// rounding
		if (hp > 100)
		{
			final int roundTo = hp > 300 ? 10 : 5;
			hp = ((hp + (roundTo / 2)) / roundTo) * roundTo;
		}

		akkhasShadowMaxHp = hp;
	}
}

package com.duckblade.osrs.toa.features.boss.akkha;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.OverlayUtil;
import com.duckblade.osrs.toa.util.RaidState;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Point;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPosition;

@Singleton
public class AkkhaShadowHealthOverlay extends Overlay implements PluginLifecycleComponent
{
	private final TombsOfAmascutConfig config;
	private final OverlayManager overlayManager;
	private final AkkhaShadowHealth akkhaShadowHealth;

	@Inject
	protected AkkhaShadowHealthOverlay(
		final TombsOfAmascutConfig config,
		final OverlayManager overlayManager,
		final AkkhaShadowHealth akkhaShadowHealth
	)
	{
		this.config = config;
		this.overlayManager = overlayManager;
		this.akkhaShadowHealth = akkhaShadowHealth;

		setPriority(Overlay.PRIORITY_HIGH);
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public boolean isEnabled(final TombsOfAmascutConfig config, final RaidState raidState)
	{
		return akkhaShadowHealth.isEnabled(config, raidState) && config.akkhaShadowHpOverlay();
	}

	@Override
	public void startUp()
	{
		overlayManager.add(this);
	}

	@Override
	public void shutDown()
	{
		overlayManager.remove(this);
	}

	@Override
	public Dimension render(final Graphics2D graphics2D)
	{
		akkhaShadowHealth.getAkkhasShadows().forEach((npc, hp) ->
		{
			if (hp > 0)
			{
				final String text = Integer.toString(hp);

				final Point point = npc.getCanvasTextLocation(graphics2D, text, 0);

				if (point != null)
				{
					OverlayUtil.renderTextLocation(graphics2D, point, text, Color.WHITE, config.akkhaFontSize(),
						config.akkhaFontStyle().getFont(), true);
				}
			}
		});

		return null;
	}
}
package com.duckblade.osrs.toa.features.timetracking;

import com.duckblade.osrs.toa.util.RaidRoom;
import lombok.Value;

@Value
public class Split
{

	RaidRoom room;
	String split;

}

package com.duckblade.osrs.toa.features.timetracking;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidRoom;
import com.duckblade.osrs.toa.util.RaidState;
import java.awt.Color;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.ColorUtil;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class SplitsTracker implements PluginLifecycleComponent
{

	private static final String ROOM_COMPLETE_PREFIX = "Challenge complete";
	private static final Pattern ROOM_COMPLETE_PATTERN =
		Pattern.compile("Challenge complete: (?:Path of )?([A-Za-z-]+).*Total:.*?([0-9]+:[.0-9]+).*");
	private static final Pattern WARDENS_COMPLETE_PATTERN =
		Pattern.compile("Challenge complete: The (Wardens).*?completion time:.*?([0-9]+:[.0-9]+).*");

	private final EventBus eventBus;

	private final TombsOfAmascutConfig config;
	private final Client client;

	private final List<Split> splits = new ArrayList<>(9);

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState raidState)
	{
		// always track, conditionally display
		return raidState.isInRaid();
	}

	@Override
	public void startUp()
	{
		splits.clear();
		eventBus.register(this);
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
	}

	@Subscribe
	public void onChatMessage(ChatMessage e)
	{
		if (e.getType() != ChatMessageType.GAMEMESSAGE)
		{
			return;
		}

		String msg = e.getMessage();
		if (!msg.startsWith(ROOM_COMPLETE_PREFIX))
		{
			return;
		}

		Matcher m;
		if (!(m = WARDENS_COMPLETE_PATTERN.matcher(msg)).matches() &&
			!(m = ROOM_COMPLETE_PATTERN.matcher(msg)).matches())
		{
			return;
		}

		RaidRoom room = RaidRoom.forString(m.group(1));
		String split = m.group(2);
		if (room == null)
		{
			log.warn("Failed to find room {} for completion string {}", m.group(1), e.getMessage());
			return;
		}

		splits.add(new Split(room, split));

		if (room == RaidRoom.WARDENS && config.splitsMessage() != SplitsMode.OFF)
		{
			client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", buildSplitsMessages(), "", false);
		}
	}

	public List<Split> getSplits()
	{
		return Collections.unmodifiableList(splits);
	}

	private String buildSplitsMessages()
	{
		SplitsMode splitsMode = config.splitsMessage();

		StringBuilder sb = new StringBuilder();
		sb.append("ToA Splits<br>");
		for (Split s : getSplits())
		{
			if (splitsMode.includesRoom(s.getRoom()))
			{
				sb.append(s.getRoom());
				sb.append(": ");
				sb.append(ColorUtil.wrapWithColorTag(s.getSplit(), Color.red));
				sb.append("<br>");
			}
		}

		return sb.toString();
	}

}

package com.duckblade.osrs.toa.features.timetracking;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidRoom;
import com.duckblade.osrs.toa.util.RaidState;
import com.duckblade.osrs.toa.util.RaidStateTracker;
import com.duckblade.osrs.toa.util.TimerMode;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

@Slf4j
@Singleton
public class SplitsOverlay extends OverlayPanel implements PluginLifecycleComponent
{

	private final OverlayManager overlayManager;

	private final TargetTimeManager targetTimeManager;
	private final SplitsTracker splitsTracker;
	private final RaidStateTracker raidStateTracker;
	private final Client client;

	private SplitsMode splitsMode;

	@Inject
	public SplitsOverlay(OverlayManager overlayManager, TargetTimeManager targetTimeManager, SplitsTracker splitsTracker, RaidStateTracker raidStateTracker, Client client)
	{
		this.overlayManager = overlayManager;
		this.targetTimeManager = targetTimeManager;
		this.splitsTracker = splitsTracker;
		this.raidStateTracker = raidStateTracker;
		this.client = client;

		setPosition(OverlayPosition.BOTTOM_LEFT);
	}

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState raidState)
	{
		this.splitsMode = config.splitsOverlay();
		return splitsMode != SplitsMode.OFF && raidState.isInRaid();
	}

	@Override
	public void startUp()
	{
		overlayManager.add(this);
	}

	@Override
	public void shutDown()
	{
		overlayManager.remove(this);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		getPanelComponent().getChildren()
			.add(TitleComponent.builder()
				.text("ToA Splits")
				.build());

		RaidRoom currentRoom = raidStateTracker.getCurrentState().getCurrentRoom();
		boolean hasCurrentTime = false;
		for (Split s : splitsTracker.getSplits())
		{
			if (splitsMode.includesRoom(s.getRoom()))
			{
				hasCurrentTime = hasCurrentTime || currentRoom == s.getRoom();
				addLine(s.getRoom().toString(), s.getSplit());
			}
		}

		String currentName;
		if (!hasCurrentTime && (currentName = splitsMode.nextSplit(currentRoom)) != null)
		{
			addLine(currentName, currentTimerValue());
		}

		String targetTime = targetTimeManager.getTargetTime();
		if (targetTime != null)
		{
			addLine("Target", targetTime);
		}

		return super.render(graphics);
	}

	private void addLine(String left, String right)
	{
		getPanelComponent()
			.getChildren()
			.add(LineComponent.builder()
				.left(left)
				.right(right)
				.build());
	}

	private String currentTimerValue()
	{
		Widget w = client.getWidget(TargetTimeManager.WIDGET_TIMER);
		String text;
		if (w == null || (text = w.getText()) == null)
		{
			return TimerMode.fromClient(client) == TimerMode.PRECISE
				? "--:--.--"
				: "--:--";
		}

		return text.split("/")[0].trim();
	}
}

package com.duckblade.osrs.toa.features.timetracking;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidState;
import com.duckblade.osrs.toa.util.RaidStateChanged;
import com.duckblade.osrs.toa.util.TimerMode;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ChatLineBuffer;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.MessageNode;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.Text;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class TargetTimeManager implements PluginLifecycleComponent
{

	private static final int SCRIPT_TOA_TIME_UPDATE_TIMER = 6581;
	static final int WIDGET_TIMER = WidgetUtil.packComponentId(481, 46);

	private static final String NO_TARGET_TIME_PREFIX = "You enter the Tombs of Amascut";
	private static final String TARGET_TIME_PREFIX = "Overall time to beat:";
	private static final Pattern TARGET_TIME_PATTERN = Pattern.compile("Overall time to beat: (\\d\\d):\\d\\d(?:\\.\\d\\d)?");

	private final EventBus eventBus;
	private final Client client;

	private int mins;

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState currentState)
	{
		return config.targetTimeDisplay();
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);

		// scan for target time in history
		ChatLineBuffer gameMessages = client.getChatLineMap().get(ChatMessageType.GAMEMESSAGE.getType());
		if (gameMessages != null)
		{
			for (int i = 0; i < gameMessages.getLength(); i++)
			{
				MessageNode line = gameMessages.getLines()[i];
				if (NO_TARGET_TIME_PREFIX.equals(Text.removeTags(line.getValue())))
				{
					return;
				}

				if (checkMessage(Text.removeTags(line.getValue())))
				{
					return;
				}
			}
		}
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
	}

	@Subscribe
	public void onChatMessage(ChatMessage e)
	{
		if (e.getType() != ChatMessageType.GAMEMESSAGE)
		{
			return;
		}

		checkMessage(Text.removeTags(e.getMessage()));
	}

	@Subscribe
	public void onRaidStateChanged(RaidStateChanged e)
	{
		if (!e.getNewState().isInRaid())
		{
			mins = -1;
		}
	}

	@Subscribe
	public void onScriptPostFired(ScriptPostFired e)
	{
		if (e.getScriptId() == SCRIPT_TOA_TIME_UPDATE_TIMER && getTargetTime() != null)
		{
			Widget timer = client.getWidget(WIDGET_TIMER);
			if (timer == null || timer.getText().contains("/"))
			{
				return;
			}

			timer.setText(timer.getText() + " / " + getTargetTime());

			// resize two fairly high up parent containers to prevent clipping
			Widget resize1 = timer.getParent().getParent().getParent();
			Widget resize2 = resize1.getParent();
			resize1.setSize(200, resize1.getHeight());
			resize2.setSize(200, resize2.getHeight());

			// propagate resizes backwards from parents since it uses negative width mode
			// parents need to have updated their width for children to derive correct width
			timer.getParent().getParent().getParent().getParent().revalidate(); // 3
			timer.getParent().getParent().getParent().revalidate(); // 5
			timer.getParent().getParent().revalidate(); // 39
			timer.getParent().revalidate(); // 40
			timer.revalidate(); // 46
		}
	}

	private boolean checkMessage(String msg)
	{
		if (!msg.startsWith(TARGET_TIME_PREFIX))
		{
			return false;
		}

		Matcher m = TARGET_TIME_PATTERN.matcher(msg);
		if (!m.find())
		{
			return false;
		}

		mins = Integer.parseInt(m.group(1));
		return true;
	}

	public String getTargetTime()
	{
		return mins != -1
			? formatTargetTime(TimerMode.fromClient(client), mins)
			: null;
	}

	private static String formatTargetTime(TimerMode timerMode, int mins)
	{
		return timerMode == TimerMode.PRECISE
			? String.format("%02d:00.00", mins)
			: String.format("%02d:00", mins);
	}
}

package com.duckblade.osrs.toa.features.timetracking;

import com.duckblade.osrs.toa.util.RaidRoom;

public enum SplitsMode
{

	OFF,
	ROOM,
	PATH,
	;

	boolean includesRoom(RaidRoom r)
	{
		if (this == OFF || r.getRoomType() == RaidRoom.RaidRoomType.LOBBY)
		{
			return false;
		}

		return this == ROOM ||
			r.getRoomType() == RaidRoom.RaidRoomType.BOSS;
	}

	String nextSplit(RaidRoom r)
	{
		if (this == OFF || r == null || r.getRoomType() == RaidRoom.RaidRoomType.LOBBY)
		{
			return null;
		}

		if (this == ROOM)
		{
			return r.toString();
		}

		switch (r)
		{
			case CRONDIS:
			case ZEBAK:
				return RaidRoom.ZEBAK.toString();

			case SCABARAS:
			case KEPHRI:
				return RaidRoom.KEPHRI.toString();

			case APMEKEN:
			case BABA:
				return RaidRoom.BABA.toString();

			case HET:
			case AKKHA:
				return RaidRoom.AKKHA.toString();

			case WARDENS:
				return RaidRoom.WARDENS.toString();
		}

		return null;
	}

}

package com.duckblade.osrs.toa.features;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidState;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Singleton
public class FadeDisabler implements PluginLifecycleComponent
{
	@Inject
	private EventBus eventBus;

	@Override
	public boolean isEnabled(final TombsOfAmascutConfig config, final RaidState raidState)
	{
		return config.hideFadeTransition() && (raidState.isInLobby() || raidState.isInRaid());
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
	}

	@Subscribe
	private void onScriptPreFired(final ScriptPreFired event)
	{
		// https://github.com/RuneStar/cs2-scripts/blob/master/scripts/%5Bclientscript%2Cfade_overlay%5D.cs2
		if (event.getScriptId() == 948)
		{
			event.getScriptEvent().getArguments()[4] = 255; // transparency (default=0)
			event.getScriptEvent().getArguments()[5] = 0; // duration? (default=50)
		}
	}
}

package com.duckblade.osrs.toa.features;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidRoom;
import com.duckblade.osrs.toa.util.RaidState;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class CameraShakeDisabler implements PluginLifecycleComponent
{

	private final Client client;

	private boolean wasDisabled;

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState raidState)
	{
		return config.disableCameraShake() && raidState.getCurrentRoom() == RaidRoom.WARDENS;
	}

	@Override
	public void startUp()
	{
		wasDisabled = client.isCameraShakeDisabled();
		client.setCameraShakeDisabled(true);
	}

	@Override
	public void shutDown()
	{
		if (wasDisabled)
		{
			client.setCameraShakeDisabled(false);
		}
	}
}

package com.duckblade.osrs.toa.features.updatenotifier;

import java.util.List;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.SwingConstants;
import net.runelite.client.ui.PluginPanel;

public class UpdateNotifierPanel extends PluginPanel
{

	UpdateNotifierPanel(List<String> updates, Runnable acknowledgeCallback)
	{
		super(true);

		setBorder(BorderFactory.createEmptyBorder(20, 5, 0, 5));
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

		JLabel content = new JLabel();
		content.setText(buildHtml(updates));
		content.setHorizontalAlignment(SwingConstants.CENTER);
		content.setAlignmentX(CENTER_ALIGNMENT);
		content.setBorder(BorderFactory.createEmptyBorder(0, 0, 20, 0));
		add(content);

		JButton acknowledge = new JButton("Close");
		acknowledge.addActionListener(ignored -> acknowledgeCallback.run());
		acknowledge.setAlignmentX(CENTER_ALIGNMENT);
		add(acknowledge);
	}

	private static String buildHtml(List<String> updates)
	{
		StringBuilder sb = new StringBuilder();
		sb.append("<html>");

		sb.append("<h1 style=\"width: 1%; margin: 0 auto;\">ToA\u00A0Plugin\u00A0Updates</h1>");
		sb.append("<br/><br/>");

		sb.append("<ul style=\"list-style-type: disc; margin: 0px 15px;\">");
		for (String update : updates)
		{
			sb.append("<li>");
			sb.append(update);
			sb.append("</li>");
			sb.append("<br/>");
		}
		sb.append("</ul><br/>");

		sb.append("<em>With all updates, please check the plugin config to enable or disable features you wish to use.</em>");

		sb.append("</html>");
		return sb.toString();
	}
}

package com.duckblade.osrs.toa.features.updatenotifier;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidState;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.SwingUtilities;
import lombok.RequiredArgsConstructor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class UpdateNotifier implements PluginLifecycleComponent
{

	public static final int TARGET_VERSION = 9;
	private static final BufferedImage PANEL_ICON = ImageUtil.loadImageResource(UpdateNotifier.class, "icon.png");

	private final ClientToolbar clientToolbar;
	private final TombsOfAmascutConfig config;

	private NavigationButton navButton;

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState raidState)
	{
		return config.showUpdateMessages() &&
			config.updateNotifierLastVersion() < TARGET_VERSION &&
			raidState.isInLobby();
	}

	@Override
	public void startUp()
	{
		SwingUtilities.invokeLater(() ->
		{
			navButton = NavigationButton.builder()
				.tooltip("ToA Plugin Updates")
				.priority(999)
				.icon(PANEL_ICON)
				.panel(new UpdateNotifierPanel(getUpdates(), () ->
				{
					config.updateNotifierLastVersion(TARGET_VERSION);
					clientToolbar.removeNavigation(navButton);
				}))
				.build();

			clientToolbar.addNavigation(navButton);

			SwingUtilities.invokeLater(() -> clientToolbar.openPanel(navButton));
		});
	}

	@Override
	public void shutDown()
	{
		SwingUtilities.invokeLater(() -> clientToolbar.removeNavigation(navButton));
	}

	private List<String> getUpdates()
	{
		List<String> updates = new ArrayList<>();

		if (config.updateNotifierLastVersion() < 3)
		{
			updates.add("<strong>A bug was fixed that prevented this update panel from appearing. If this is your first time seeing it, some of the below changes might be things you've already been using for a while!</strong>");
		}

		switch (config.updateNotifierLastVersion())
		{
			case 0:
				updates.add("A set of puzzle solvers for the Path of Scabaras have been added, which will overlay solutions for you.");
				updates.add("The Path of Het's Deposit-pickaxe swap can now remove the option to enter the next room until you have deposited your pickaxe.");
				updates.add("Plugin-based invocation presets have been readded, but are disabled by default.");
				updates.add("You can now add a custom sound to play when the purple loot chest is opened, e.g. the Legend of Zelda chest loot jingle. Check the config descriptions or plugin README for instructions (thanks @TheStonedTurtle!).");

			case 1:
				updates.add("A points tracker has been added to determine points earned in raids, as well as the unique rate from those points. Calculating points for groups requires players to be in a RuneLite party.");

			case 2:
				updates.add("The Path of Het helper will now display an indicator of when the next beam will fire. Click the seal when it is green from one tile away to get an extra damage tick.");
				updates.add("Some bugs have been fixed with the points tracker. Please continue to report further issues on GitHub!");

			case 3:
				updates.add("The Quick-Proceed swaps can now be set to NOT_CRONDIS, to allow team synchronization on that puzzle without disabling swaps for the entire raid.");
				updates.add("HP Orbs can be toggled off with a new config option.");
				updates.add("The loot chest Bank-all option can be toggled to no longer require two clicks.");
				updates.add("The loot sarcophagus flame colours can now be recoloured (thanks @rdutta!).");
				updates.add("The Scabaras addition puzzle routes now use more optimal paths (thanks @PowContent!).");

			case 4:
				updates.add("HP orbs can now be replaced by health bars a la ToB Health Bars.");
				updates.add("The NOT_CRONDIS option for Quick-proceed swaps will no longer prevent quick entry on the door to the boss.");
				updates.add("An indicator for which puzzle entrance to use to skip the obelisk puzzle can be enabled under Scabaras options.");

			case 5:
				updates.add("Added support for room and path time splits.");
				updates.add("Added a visual overlay deposit-pickaxe reminder for both the puzzle room and pre-raid lobby.");
				updates.add("Fixed a myriad of bugs in points tracking, health bar formatting, and error handling.");

			case 6:
				updates.add("The Path of Het mirror puzzle now has a full overlay solver.");

			case 7:
				updates.add("This is a big update, so first a special thanks to @rdutta for submitting many features! Some config options have been moved into new sections.");
				updates.add("<strong>(Miscellaneous -> Hide Fade Transition)</strong> can remove the fade to black between rooms. Visual artifacts that are normally hidden may be visible.");
				updates.add("<strong>(Akkha -> Shadows Hp Overlay)</strong> can provide a numerical HP overlay on each shadow.");
				updates.add("<strong>(Burial Tomb -> Detect Cursed Phalanx)</strong> can now prevent you from opening the loot chest on raid level 500+ if you have a cursed phalanx equipped or in your inventory.");
				updates.add("<strong>(Burial Tomb -> Track Purple Dry Count)</strong> can provide a chat message indicating how many raids you have gone without seeing a unique drop.");
				updates.add("<strong>(Path of Apmeken -> Baboon Outline)</strong> can automatically highlight each baboon type a unique colour.");
				updates.add("<strong>(Path of Apmeken -> Volatile Baboon Tile)</strong> can draw a 3x3 box around volatile baboons.");
				updates.add("The Path of Het solver will no longer continue to show the solution when the seal is weakened.");
				updates.add("The points tracker has been updated to account for deaths more accurately. If you have Separate Room Points enabled, you will begin to see that room points are preserved after wipes, this is intentional and accounted for.");

			case 8:
				updates.add("<strong>(Kephri -> Swarmer Overlay)</strong>Spawn numbers can be added to the Kephri swarms. Thanks @FiveNine!");
				updates.add("Fixed a bug that was causing the Salts Cooldown feature to erroneously prevent salting.");
		}

		return updates;
	}
}

/*
 * Copyright (c) 2020, Trevor <https://github.com/Trevor159/runelite-external-plugins/blob/b9d58dd864ce33a23b34eac91865bdb1521a379a/LICENSE>
 * Copyright (c) 2023, LlemonDuck <napkinorton@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.duckblade.osrs.toa.features.hporbs;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.google.common.base.Strings;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.Varbits;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.ProgressBarComponent;

public class HealthBarsOverlay extends OverlayPanel
{

	@Inject
	private Client client;

	@Inject
	private TombsOfAmascutConfig config;

	@Inject
	public HealthBarsOverlay(Client client, TombsOfAmascutConfig config)
	{
		this.client = client;
		this.config = config;

		panelComponent.setGap(new Point(0, 3));
		if (getPreferredPosition() == null)
		{
			setPreferredPosition(OverlayPosition.TOP_LEFT);
		}
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (config.hpOrbsMode() != HpOrbMode.HEALTH_BARS)
		{
			return null;
		}

		// solo raid
		if (Strings.isNullOrEmpty(client.getVarcStrValue(1100)))
		{
			String playerName = client.getVarcStrValue(1099);
			double hpFactor = hpFactor(client.getVarbitValue(Varbits.TOA_MEMBER_0_HEALTH) - 1);
			panelComponent.getChildren().add(buildHpBar(playerName, hpFactor));

			return super.render(graphics);
		}

		DoubleHpBarComponent current = new DoubleHpBarComponent();
		for (int i = 0; i < 8; i++)
		{
			String playerName = client.getVarcStrValue(1099 + i);
			double hpFactor = hpFactor(client.getVarbitValue(Varbits.TOA_MEMBER_0_HEALTH + i) - 1);
			if (Strings.isNullOrEmpty(playerName))
			{
				continue;
			}

			if (i % 2 == 0)
			{
				current.setCenterLabel1(playerName);
				current.setValue1(hpFactor);
				panelComponent.getChildren().add(current);
			}
			else
			{
				current.setCenterLabel2(playerName);
				current.setValue2(hpFactor);
				current = new DoubleHpBarComponent();
			}
		}

		return super.render(graphics);
	}

	private static double hpFactor(int hpVarb)
	{
		return (double) Math.max(hpVarb, 0) / 26.0;
	}

	private ProgressBarComponent buildHpBar(String name, double hpFactor)
	{
		ProgressBarComponent hpBar = new ProgressBarComponent();
		hpBar.setBackgroundColor(new Color(102, 15, 16, 230));
		hpBar.setForegroundColor(new Color(0, 146, 54, 230));
		hpBar.setLabelDisplayMode(ProgressBarComponent.LabelDisplayMode.TEXT_ONLY);
		hpBar.setCenterLabel(name);
		hpBar.setValue(hpFactor);
		hpBar.setMinimum(0);
		hpBar.setMaximum(1);
		hpBar.setPreferredSize(new Dimension(60, 20));
		return hpBar;
	}
}
package com.duckblade.osrs.toa.features.hporbs;

public enum HpOrbMode
{

	ORBS,
	HEALTH_BARS,
	HIDDEN,
	;

}

/*
 * Copyright (c) 2018, Cameron <moberg@tuta.io>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.duckblade.osrs.toa.features.hporbs;

import com.google.common.base.Strings;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import lombok.Getter;
import lombok.Setter;
import net.runelite.client.ui.overlay.components.ComponentConstants;
import net.runelite.client.ui.overlay.components.LayoutableRenderableEntity;
import net.runelite.client.ui.overlay.components.TextComponent;

@Setter
public class DoubleHpBarComponent implements LayoutableRenderableEntity
{

	private double value1;
	private String centerLabel1;
	private double value2;
	private String centerLabel2;
	private Color foregroundColor = new Color(0, 146, 54, 230);
	private Color backgroundColor = new Color(102, 15, 16, 230);
	private Color fontColor = Color.WHITE;
	private Point preferredLocation = new Point();
	private Dimension preferredSize = new Dimension(ComponentConstants.STANDARD_WIDTH, 16);
	private int gap = 3;

	@Getter
	private final Rectangle bounds = new Rectangle();

	@Override
	public Dimension render(Graphics2D graphics)
	{
		final int baseX = preferredLocation.x;
		final int baseY = preferredLocation.y;

		final int totalWidth = preferredSize.width;
		final int totalHeight = Math.max(preferredSize.height, 16);

		final int barWidth = (totalWidth - gap) / 2;

		drawBar(
			graphics,
			centerLabel1,
			value1,
			baseX,
			baseY,
			barWidth,
			totalHeight
		);

		if (!Strings.isNullOrEmpty(centerLabel2))
		{
			drawBar(
				graphics,
				centerLabel2,
				value2,
				baseX + barWidth + gap,
				baseY,
				barWidth,
				totalHeight
			);
		}

		final Dimension dimension = new Dimension(totalWidth, totalHeight);
		bounds.setLocation(preferredLocation);
		bounds.setSize(dimension);
		return dimension;
	}

	private void drawBar(Graphics2D graphics, String name, double value, int baseX, int baseY, int width, int height)
	{
		final FontMetrics metrics = graphics.getFontMetrics();
		if (metrics.stringWidth(name) > width)
		{
			name = trimmedName(metrics, name, width);
		}

		final int progressFill = (int) (width * Math.min(1, value));
		final int progressTextX = baseX + (width - metrics.stringWidth(name)) / 2;
		final int progressTextY = baseY + ((height - metrics.getHeight()) / 2) + metrics.getHeight();

		graphics.setColor(backgroundColor);
		graphics.fillRect(baseX, baseY, width, height);
		graphics.setColor(foregroundColor);
		graphics.fillRect(baseX, baseY, progressFill, height);

		final TextComponent textComponent1 = new TextComponent();
		textComponent1.setPosition(new Point(progressTextX, progressTextY));
		textComponent1.setColor(fontColor);
		textComponent1.setText(name);
		textComponent1.render(graphics);
	}

	private static String trimmedName(FontMetrics metrics, String name, int maxWidth)
	{
		String runningName = name;
		while (metrics.stringWidth(runningName + "...") > maxWidth)
		{
			runningName = runningName.substring(0, runningName.length() - 1);
		}

		return runningName + "...";
	}
}

package com.duckblade.osrs.toa.features.hporbs;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidState;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Client;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.OverlayManager;

@Singleton
public class HpOrbManager implements PluginLifecycleComponent
{

	private static final int BUILD_ORBS_WIDGET_SCRIPT_ID = 6579;
	private static final int WIDGET_ID_ORBS = WidgetUtil.packComponentId(481, 4);

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private EventBus eventBus;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private HealthBarsOverlay healthBarsOverlay;

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState raidState)
	{
		return config.hpOrbsMode() != HpOrbMode.ORBS && raidState.isInRaid();
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);
		clientThread.invokeLater(this::hideOrbs);
		overlayManager.add(healthBarsOverlay);
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
		overlayManager.remove(healthBarsOverlay);
	}

	@Subscribe
	public void onScriptPostFired(ScriptPostFired e)
	{
		if (e.getScriptId() == BUILD_ORBS_WIDGET_SCRIPT_ID)
		{
			hideOrbs();
		}
	}

	private void hideOrbs()
	{
		Widget orbW = client.getWidget(WIDGET_ID_ORBS);
		if (orbW != null)
		{
			orbW.setHidden(true);

			orbW.getParent().setOriginalHeight(95);
			orbW.getParent().revalidate();
		}
	}
}

package com.duckblade.osrs.toa.features.apmeken;

import java.awt.Color;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Getter
public enum Baboon
{

	BRAWLER("Brawler", new Color(169, 107, 94)),
	THROWER("Thrower", new Color(99, 114, 90)),
	MAGE("Mage", new Color(65, 134, 186)),
	SHAMAN("Shaman", new Color(164, 152, 131)),
	THRALL("Thrall", new Color(92, 99, 115)),
	VOLATILE("Volatile", new Color(118, 107, 79)),
	CURSED("Cursed", new Color(64, 149, 126)),
	;

	private final String displayName;
	private final Color color;

}

package com.duckblade.osrs.toa.features.apmeken;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidRoom;
import com.duckblade.osrs.toa.util.RaidState;
import java.util.ArrayList;
import java.util.List;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Actor;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class ApmekenBaboonIndicator implements PluginLifecycleComponent
{
	private final EventBus eventBus;

	@Getter(AccessLevel.PACKAGE)
	private final List<NPC> volatileBaboons = new ArrayList<>();

	@Getter(AccessLevel.PACKAGE)
	private final List<NPC> baboons = new ArrayList<>();

	@Override
	public boolean isEnabled(final TombsOfAmascutConfig config, final RaidState raidState)
	{
		return raidState.getCurrentRoom() == RaidRoom.APMEKEN;
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
		volatileBaboons.clear();
		baboons.clear();
	}

	@Subscribe
	public void onNpcSpawned(final NpcSpawned event)
	{
		final NPC npc = event.getNpc();

		final int id = npc.getId();

		switch (id)
		{
			case NpcID.VOLATILE_BABOON:
				volatileBaboons.add(npc);
			case NpcID.BABOON_BRAWLER:
			case NpcID.BABOON_BRAWLER_11712:
			case NpcID.BABOON_MAGE:
			case NpcID.BABOON_MAGE_11714:
			case NpcID.BABOON_THROWER:
			case NpcID.BABOON_THROWER_11713:
			case NpcID.BABOON_SHAMAN:
			case NpcID.CURSED_BABOON:
			case NpcID.BABOON_THRALL:
				baboons.add(npc);
				break;
			default:
				break;
		}
	}

	@Subscribe
	public void onNpcDespawned(final NpcDespawned event)
	{
		removeNpc(event.getNpc());
	}

	@Subscribe
	public void onActorDeath(final ActorDeath event)
	{
		final Actor actor = event.getActor();

		if (!(actor instanceof NPC))
		{
			return;
		}

		removeNpc((NPC) actor);
	}

	private void removeNpc(final NPC npc)
	{
		final int id = npc.getId();

		switch (id)
		{
			case NpcID.VOLATILE_BABOON:
				volatileBaboons.remove(npc);
			case NpcID.BABOON_BRAWLER:
			case NpcID.BABOON_BRAWLER_11712:
			case NpcID.BABOON_MAGE:
			case NpcID.BABOON_MAGE_11714:
			case NpcID.BABOON_THROWER:
			case NpcID.BABOON_THROWER_11713:
			case NpcID.BABOON_SHAMAN:
			case NpcID.CURSED_BABOON:
			case NpcID.BABOON_THRALL:
				baboons.remove(npc);
				break;
			default:
				break;
		}
	}

}

package com.duckblade.osrs.toa.features.apmeken;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.HighlightMode;
import com.duckblade.osrs.toa.util.OverlayUtil;
import com.duckblade.osrs.toa.util.RaidState;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;
import net.runelite.api.Perspective;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;

@Singleton
public class ApmekenBaboonIndicatorOverlay extends Overlay implements PluginLifecycleComponent
{

	private static final int AREA_SIZE_3X3 = 3;

	private final OverlayManager overlayManager;
	private final ModelOutlineRenderer modelOutlineRenderer;
	private final Client client;
	private final TombsOfAmascutConfig config;
	private final ApmekenBaboonIndicator apmekenBaboonIndicator;

	@Inject
	public ApmekenBaboonIndicatorOverlay(
		final OverlayManager overlayManager,
		final ModelOutlineRenderer modelOutlineRenderer,
		final Client client,
		final TombsOfAmascutConfig config,
		final ApmekenBaboonIndicator apmekenBaboonIndicator
	)
	{
		this.overlayManager = overlayManager;
		this.modelOutlineRenderer = modelOutlineRenderer;
		this.client = client;
		this.config = config;
		this.apmekenBaboonIndicator = apmekenBaboonIndicator;

		setPriority(Overlay.PRIORITY_HIGH);
		setLayer(OverlayLayer.ABOVE_SCENE);
		setPosition(OverlayPosition.DYNAMIC);
	}

	@Override
	public boolean isEnabled(final TombsOfAmascutConfig config, final RaidState raidState)
	{
		return (config.apmekenBaboonOutline() != HighlightMode.OFF || config.apmekenVolatileBaboonTiles()) &&
			apmekenBaboonIndicator.isEnabled(config, raidState);
	}

	@Override
	public void startUp()
	{
		overlayManager.add(this);
	}

	@Override
	public void shutDown()
	{
		overlayManager.remove(this);
	}

	@Override
	public Dimension render(final Graphics2D graphics2D)
	{
		if (config.apmekenBaboonOutline() != HighlightMode.OFF)
		{
			renderBaboonOutline(graphics2D);
		}

		if (config.apmekenVolatileBaboonTiles())
		{
			renderVolatileBaboonTiles(graphics2D);
		}

		return null;
	}

	private void renderBaboonOutline(final Graphics2D graphics2D)
	{
		for (final NPC npc : apmekenBaboonIndicator.getBaboons())
		{
			final Color color;

			switch (npc.getId())
			{
				case NpcID.BABOON_BRAWLER:
				case NpcID.BABOON_BRAWLER_11712:
					color = config.apmekenBaboonColorMelee();
					break;
				case NpcID.BABOON_MAGE:
				case NpcID.BABOON_MAGE_11714:
					color = config.apmekenBaboonColorMage();
					break;
				case NpcID.BABOON_THROWER:
				case NpcID.BABOON_THROWER_11713:
					color = config.apmekenBaboonColorRange();
					break;
				case NpcID.BABOON_SHAMAN:
					color = config.apmekenBaboonColorShaman();
					break;
				case NpcID.CURSED_BABOON:
					color = config.apmekenBaboonColorCursed();
					break;
				case NpcID.BABOON_THRALL:
					color = config.apmekenBaboonColorThrall();
					break;
				case NpcID.VOLATILE_BABOON:
				default:
					continue;
			}

			final Color noAlpha = new Color((0xFF << 24) | color.getRGB(), true);

			Polygon polygon = null;
			switch (config.apmekenBaboonOutline())
			{
				case OUTLINE:
					modelOutlineRenderer.drawOutline(npc, config.apmekenBaboonOutlineWidth(), color, 0);
					break;
				case TILE:
					polygon = npc.getCanvasTilePoly();
					break;
				case TRUE_TILE:
					LocalPoint lp = LocalPoint.fromWorld(npc.getWorldView(), npc.getWorldLocation()); // centered on sw tile
					if (lp != null)
					{
						polygon = Perspective.getCanvasTileAreaPoly(client, lp, 1);
					}
				default:
					break;
			}

			if (polygon != null)
			{
				OverlayUtil.drawOutlineAndFill(graphics2D, noAlpha, color, config.apmekenBaboonOutlineWidth(), polygon);
			}
		}
	}

	private void renderVolatileBaboonTiles(final Graphics2D graphics2D)
	{
		for (final NPC npc : apmekenBaboonIndicator.getVolatileBaboons())
		{
			final LocalPoint localPoint = npc.getLocalLocation();

			if (localPoint == null)
			{
				continue;
			}

			final Polygon polygon = Perspective.getCanvasTileAreaPoly(client, localPoint, AREA_SIZE_3X3);

			if (polygon == null)
			{
				continue;
			}

			final Color color = config.apmekenBaboonColorVolatile();
			final Color noAlpha = new Color((0xFF << 24) | color.getRGB(), true);

			OverlayUtil.drawOutlineAndFill(graphics2D, noAlpha, color, config.apmekenBaboonOutlineWidth(), polygon);
		}
	}

}

package com.duckblade.osrs.toa.features.apmeken;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidRoom;
import com.duckblade.osrs.toa.util.RaidState;
import java.awt.image.BufferedImage;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.SwingUtilities;
import lombok.RequiredArgsConstructor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class ApmekenWaveInstaller implements PluginLifecycleComponent
{

	private static final BufferedImage PANEL_ICON = ImageUtil.loadImageResource(ApmekenWaveInstaller.class, "icon.png");

	private final ClientToolbar clientToolbar;
	private final ApmekenWavePanel apmekenWavePanel;

	private NavigationButton navButton;

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState raidState)
	{
		return config.apmekenWaveHelper() &&
			raidState.getCurrentRoom() == RaidRoom.APMEKEN;
	}

	@Override
	public void startUp()
	{
		if (navButton == null)
		{
			navButton = NavigationButton.builder()
				.icon(PANEL_ICON)
				.panel(apmekenWavePanel)
				.priority(999)
				.tooltip("Apmeken Waves")
				.build();
		}

		openPanel();
	}

	@Override
	public void shutDown()
	{
		removePanel();
	}

	private void openPanel()
	{
		clientToolbar.addNavigation(navButton);
		SwingUtilities.invokeLater(() -> clientToolbar.openPanel(navButton));
	}

	private void removePanel()
	{
		clientToolbar.removeNavigation(navButton);
	}
}

package com.duckblade.osrs.toa.features.apmeken;

import static com.duckblade.osrs.toa.features.apmeken.Baboon.*;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import java.util.List;
import java.util.Map;
import javax.inject.Singleton;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;

@Singleton
public class ApmekenWavePanel extends PluginPanel
{

	private static final List<Map<Baboon, Integer>> WAVES = ImmutableList.of(
		ImmutableMap.of(BRAWLER, 2),
		ImmutableMap.of(THROWER, 1, MAGE, 1),
		ImmutableMap.of(SHAMAN, 1, BRAWLER, 2),
		ImmutableMap.of(THROWER, 2, VOLATILE, 1),
		ImmutableMap.of(MAGE, 2, CURSED, 1),
		ImmutableMap.of(THROWER, 2, SHAMAN, 1, VOLATILE, 1, CURSED, 1),
		ImmutableMap.of(MAGE, 1, SHAMAN, 2, VOLATILE, 1),
		ImmutableMap.of(BRAWLER, 2, SHAMAN, 2, CURSED, 1),
		ImmutableMap.of(BRAWLER, 1, THROWER, 1, SHAMAN, 1, CURSED, 2),
		ImmutableMap.of(SHAMAN, 2, VOLATILE, 3)
	);

	public ApmekenWavePanel()
	{
		setBorder(BorderFactory.createEmptyBorder());
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setAlignmentX(CENTER_ALIGNMENT);

		JLabel headerLabel = new JLabel("Apmeken Waves");
		headerLabel.setBorder(BorderFactory.createEmptyBorder(10, 0, 0, 0));
		headerLabel.setHorizontalAlignment(SwingConstants.CENTER);
		headerLabel.setAlignmentX(CENTER_ALIGNMENT);
		headerLabel.setFont(FontManager.getRunescapeFont().deriveFont(24f));
		add(headerLabel);

		int waveNum = 1;
		for (Map<Baboon, Integer> wave : WAVES)
		{
			JPanel rowPanel = new JPanel();
			rowPanel.setLayout(new BoxLayout(rowPanel, BoxLayout.Y_AXIS));
			rowPanel.setBorder(BorderFactory.createEmptyBorder(10, 0, 0, 0));
			rowPanel.setAlignmentX(CENTER_ALIGNMENT);
			add(rowPanel);

			rowPanel.add(new JLabel("Wave " + waveNum++));
			wave.forEach((baboon, count) ->
			{
				JLabel spawnLabel = new JLabel(count + "x " + baboon.getDisplayName());
				spawnLabel.setHorizontalAlignment(SwingConstants.LEFT);
				spawnLabel.setFont(FontManager.getRunescapeFont());
				spawnLabel.setForeground(baboon.getColor());
				rowPanel.add(spawnLabel);
			});
		}
	}

}

package com.duckblade.osrs.toa.features.pointstracker;

import com.google.gson.annotations.SerializedName;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.party.messages.PartyMemberMessage;

@RequiredArgsConstructor
@Getter
public class PointsMessage extends PartyMemberMessage
{

	@SerializedName("p")
	private final int points;

}

package com.duckblade.osrs.toa.features.pointstracker;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidState;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.PartyChanged;
import net.runelite.client.party.PartyService;
import net.runelite.client.party.WSClient;
import net.runelite.client.party.events.UserJoin;
import net.runelite.client.party.events.UserPart;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class PartyPointsTracker implements PluginLifecycleComponent
{

	private final WSClient wsClient;
	private final EventBus eventBus;
	private final PartyService partyService;
	private final ScheduledExecutorService partySendEs;

	private final Map<Long, Integer> partyPoints = new HashMap<>();

	private final AtomicInteger partySequenceId = new AtomicInteger(0);
	private long partyDontSendUntil = -1;

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState raidState)
	{
		// always track even if not displaying, so that party members get points totals
		return raidState.isInRaid();
	}

	@Override
	public void startUp()
	{
		wsClient.registerMessage(PointsMessage.class);
		eventBus.register(this);
		this.clearPartyPointsMap();
	}

	@Override
	public void shutDown()
	{
		wsClient.unregisterMessage(PointsMessage.class);
		eventBus.unregister(this);
	}

	@Subscribe
	public void onPointsMessage(PointsMessage e)
	{
		partyPoints.put(e.getMemberId(), e.getPoints());
	}

	@Subscribe
	public void onUserJoin(UserJoin e)
	{
		partyPoints.remove(e.getMemberId());
	}

	@Subscribe
	public void onUserPart(UserPart e)
	{
		partyPoints.remove(e.getMemberId());
	}

	@Subscribe
	public void onPartyChanged(PartyChanged e)
	{
		clearPartyPointsMap();
	}

	public void schedulePointsUpdate(int points)
	{
		if (!isInParty())
		{
			return;
		}

		// queue up a points update at the next available deadline (30s after last message)
		final int thisReqId = this.partySequenceId.incrementAndGet();
		partySendEs.schedule(() ->
		{
			// make sure we're still the most recent message
			if (thisReqId != this.partySequenceId.get())
			{
				return;
			}

			sendPointsUpdate(points);
		}, Math.max(0, partyDontSendUntil - System.currentTimeMillis()), TimeUnit.MILLISECONDS);
	}

	public void sendPointsUpdate(int points)
	{
		if (!isInParty())
		{
			return;
		}

		PointsMessage message = new PointsMessage(points);
		partyService.send(message);
		partyDontSendUntil = System.currentTimeMillis() + (30 * 1000);
	}

	public void clearPartyPointsMap()
	{
		partyPoints.clear();
	}

	public int getTotalPartyPoints()
	{
		return partyPoints.values()
			.stream()
			.mapToInt(Integer::intValue)
			.sum();
	}

	public boolean isInParty()
	{
		return partyService.isInParty();
	}
}

package com.duckblade.osrs.toa.features.pointstracker;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.TombsOfAmascutPlugin;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidRoom;
import com.duckblade.osrs.toa.util.RaidState;
import com.duckblade.osrs.toa.util.RaidStateChanged;
import com.duckblade.osrs.toa.util.RaidStateTracker;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import java.awt.Color;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;
import net.runelite.api.Varbits;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.ItemSpawned;
import net.runelite.client.events.PluginMessage;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.ColorUtil;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class PointsTracker implements PluginLifecycleComponent
{

	public static final String EVENT_NAME = "raidCompletedPoints";

	/* I have some insider knowledge here that the blog was describing points earning slightly wrong wrt deaths.
	 * Points are earned to both total and room points at the same time,
	 * rather than being queued up in room points and added onto total after the room.
	 * When dying, you preserve the room points amount toward cap, but subtract 20% from total.
	 * There is no special behaviour when wiping a room; the 20% points lost is intended to account for that.
	 */

	static final NumberFormat POINTS_FORMAT = NumberFormat.getInstance();
	static final NumberFormat PERCENT_FORMAT = new DecimalFormat("#.##%");

	private static final String START_MESSAGE = "You enter the Tombs of Amascut";
	private static final String DEATH_MESSAGE = "You have died";
	private static final String ROOM_FAIL_MESSAGE = "Your party failed to complete";
	private static final String ROOM_FINISH_MESSAGE = "Challenge complete";

	private static final int BASE_POINTS = 5000;
	private static final int MAX_ROOM_POINTS = 20_000;
	private static final int CRONDIS_MAX_ROOM_POINTS = 10_000;

	private static final int MAX_TOTAL_POINTS = 64_000;

	private static final int ANIMATION_ID_WARDEN_DOWN = 9670;

	private static final Map<Integer, Double> DAMAGE_POINTS_FACTORS = ImmutableMap.<Integer, Double>builder()
		.put(NpcID.CORE, 0.0)
		.put(NpcID.CORE_11771, 0.0)
		.put(NpcID.ENERGY_SIPHON, 0.0)
		.put(NpcID.BOULDER_11782, 0.0)
		.put(NpcID.BOULDER_11783, 0.0)
		.put(NpcID.BABOON_BRAWLER, 1.2)
		.put(NpcID.BABOON_BRAWLER_11712, 1.2)
		.put(NpcID.BABOON_THROWER, 1.2)
		.put(NpcID.BABOON_THROWER_11713, 1.2)
		.put(NpcID.BABOON_MAGE, 1.2)
		.put(NpcID.BABOON_MAGE_11714, 1.2)
		.put(NpcID.BABOON_SHAMAN, 1.2)
		.put(NpcID.VOLATILE_BABOON, 1.2)
		.put(NpcID.CURSED_BABOON, 1.2)
		.put(NpcID.BABOON_THRALL, 1.2)
		.put(NpcID.BABA, 2.0)
		.put(NpcID.BABA_11779, 2.0)
		.put(NpcID.BABA_11780, 2.0)
		.put(NpcID.ZEBAK, 1.5)
		.put(NpcID.ZEBAK_11730, 1.5)
		.put(NpcID.ZEBAK_11732, 1.5)
		.put(NpcID.ZEBAK_11733, 1.5)
		.put(NpcID.SPITTING_SCARAB, 0.5)
		.put(NpcID.SOLDIER_SCARAB, 0.5)
		.put(NpcID.ARCANE_SCARAB, 0.5)
		.put(NpcID.HETS_SEAL_WEAKENED, 2.5)
		.put(NpcID.OBELISK_11750, 1.5)
		.put(NpcID.OBELISK_11751, 1.5)
		.put(NpcID.OBELISK_11752, 1.5)
		.put(NpcID.ELIDINIS_WARDEN, 0.0) // non-combat wardens (prevents extra points during p1->p2 transition)
		.put(NpcID.ELIDINIS_WARDEN_11748, 0.0)
		.put(NpcID.TUMEKENS_WARDEN, 0.0)
		.put(NpcID.TUMEKENS_WARDEN_11749, 0.0)
		.put(NpcID.ELIDINIS_WARDEN_11759, 0.0)
		.put(NpcID.TUMEKENS_WARDEN_11760, 0.0)
		.put(NpcID.ELIDINIS_WARDEN_11753, 2.0) // p2 wardens
		.put(NpcID.ELIDINIS_WARDEN_11754, 2.0)
		.put(NpcID.ELIDINIS_WARDEN_11755, 0.0) // downed
		.put(NpcID.TUMEKENS_WARDEN_11756, 2.0)
		.put(NpcID.TUMEKENS_WARDEN_11757, 2.0)
		.put(NpcID.TUMEKENS_WARDEN_11758, 0.0) // downed
		.put(NpcID.ELIDINIS_WARDEN_11761, 2.5) // p3 wardens
		.put(NpcID.ELIDINIS_WARDEN_11763, 2.5)
		.put(NpcID.TUMEKENS_WARDEN_11762, 2.5)
		.put(NpcID.TUMEKENS_WARDEN_11764, 2.5)
		.build();

	// these have a cap at 3 "downs"
	private static final ImmutableSet<Integer> P2_WARDENS = ImmutableSet.of(
		NpcID.ELIDINIS_WARDEN_11753,
		NpcID.ELIDINIS_WARDEN_11754,
		NpcID.ELIDINIS_WARDEN_11755,
		NpcID.TUMEKENS_WARDEN_11756,
		NpcID.TUMEKENS_WARDEN_11757,
		NpcID.TUMEKENS_WARDEN_11758
	);

	private static final ImmutableSet<Integer> MVP_ITEMS = ImmutableSet.of(
		ItemID.FANG_27219,
		ItemID.SCARAB_DUNG,
		ItemID.BIG_BANANA,
		ItemID.ELDRITCH_ASHES
	);

	private final EventBus eventBus;
	private final Client client;
	private final TombsOfAmascutConfig config;
	private final PartyPointsTracker partyPointsTracker;
	private final RaidStateTracker raidStateTracker;

	@Getter
	private int personalRoomPoints;
	private int personalTotalPoints;
	private int nonPartyPoints; // points that are earned once by the entire party
	private final List<Integer> seenMvpItems = new ArrayList<>(4);

	private int teamSize;
	private int raidLevel;
	private int wardenDowns;

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState raidState)
	{
		// always track even if not displaying, so that party members get points totals
		return raidState.isInRaid();
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);

		reset();
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
	}

	@Subscribe
	public void onGameTick(GameTick e)
	{
		raidLevel = client.getVarbitValue(Varbits.TOA_RAID_LEVEL);
	}

	@Subscribe
	public void onRaidStateChanged(RaidStateChanged e)
	{
		teamSize = e.getNewState().getPlayerCount();
		if (e.getPreviousState() == null
			|| e.getPreviousState().getCurrentRoom() == null
			|| e.getPreviousState().getCurrentRoom() == e.getNewState().getCurrentRoom())
		{
			return;
		}

		if (e.getNewState().getCurrentRoom() == RaidRoom.TOMB && config.pointsTrackerAllowExternal())
		{
			// this is used by raid data tracker, ping gh@null-zero (or team) before any changes
			postPointsEvent();
		}

		switch (e.getPreviousState().getCurrentRoom())
		{
			case TOMB:
				if (config.pointsTrackerPostRaidMessage())
				{
					client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", buildPointsMessage(), "", false);
				}
				break;

			// puzzle estimates
			case SCABARAS:
				personalTotalPoints += 300;
				nonPartyPoints += 300;
				updatePersonalPartyPoints(false);
				break;

			case APMEKEN:
				personalTotalPoints += 450;
				nonPartyPoints += 300;
				updatePersonalPartyPoints(false);
				break;

			case CRONDIS:
				personalTotalPoints += 400;
				nonPartyPoints += 300;
				updatePersonalPartyPoints(false);
				break;

			case HET:
			case WARDENS:
				nonPartyPoints += 300;
				break;
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage e)
	{
		if (e.getType() != ChatMessageType.GAMEMESSAGE)
		{
			return;
		}

		if (e.getMessage().startsWith(START_MESSAGE))
		{
			reset();
		}
		else if (e.getMessage().startsWith(DEATH_MESSAGE))
		{
			personalTotalPoints -= (int) Math.max(0.2 * personalTotalPoints, 1000);
			if (personalTotalPoints < 0)
			{
				personalTotalPoints = 0;
			}

			updatePersonalPartyPoints(false);
		}
		else if (e.getMessage().startsWith(ROOM_FAIL_MESSAGE))
		{
			wardenDowns = 0;
		}
		else if (e.getMessage().startsWith(ROOM_FINISH_MESSAGE))
		{
			personalRoomPoints = 0;

			boolean isWardens = e.getMessage().contains("Wardens");
			updatePersonalPartyPoints(isWardens);
		}
	}

	@Subscribe
	public void onHitsplatApplied(HitsplatApplied e)
	{
		if (e.getHitsplat().getAmount() < 1 || !(e.getActor() instanceof NPC))
		{
			return;
		}

		NPC target = (NPC) e.getActor();
		log.debug("Hitsplat type {} damage {} on {}", e.getHitsplat().getHitsplatType(), e.getHitsplat().getAmount(), target.getId());
		if (P2_WARDENS.contains(target.getId()) && wardenDowns > 3)
		{
			return;
		}

		double factor = DAMAGE_POINTS_FACTORS.getOrDefault(target.getId(), 1.0);
		if (e.getHitsplat().isMine())
		{
			int pointsEarned = (int) (e.getHitsplat().getAmount() * factor);
			int roomMax = raidStateTracker.getCurrentState().getCurrentRoom() == RaidRoom.CRONDIS ? CRONDIS_MAX_ROOM_POINTS : MAX_ROOM_POINTS;
			if (personalRoomPoints + pointsEarned > roomMax)
			{
				pointsEarned = roomMax - personalRoomPoints;
			}

			this.personalRoomPoints = Math.min(roomMax, personalRoomPoints + pointsEarned);
			this.personalTotalPoints = Math.min(MAX_TOTAL_POINTS, personalTotalPoints + pointsEarned);

			updatePersonalPartyPoints(false);
		}
	}

	@Subscribe
	public void onItemSpawned(ItemSpawned e)
	{
		if (MVP_ITEMS.contains(e.getItem().getId()) && !seenMvpItems.contains(e.getItem().getId()))
		{
			personalTotalPoints += 300 * teamSize;
			seenMvpItems.add(e.getItem().getId());
			updatePersonalPartyPoints(false);
		}
	}

	@Subscribe
	public void onAnimationChanged(AnimationChanged e)
	{
		if (!(e.getActor() instanceof NPC) || !P2_WARDENS.contains(((NPC) e.getActor()).getId()))
		{
			return;
		}

		if (e.getActor().getAnimation() == ANIMATION_ID_WARDEN_DOWN)
		{
			wardenDowns++;
		}
	}

	public int getPersonalTotalPoints()
	{
		return this.personalTotalPoints - BASE_POINTS;
	}

	public double getPersonalPercent()
	{
		if (raidStateTracker.getPlayerCount() == 1)
		{
			return 1.0;
		}

		return (double) getPersonalTotalPoints() / getTotalPoints();
	}

	public int getTotalPoints()
	{
		if (partyPointsTracker.isInParty())
		{
			return partyPointsTracker.getTotalPartyPoints();
		}
		return getPersonalTotalPoints() + nonPartyPoints;
	}

	public double getUniqueChance()
	{
		return UniqueChanceCalculator.getUniqueChance(raidLevel, getTotalPoints());
	}

	public double getPetChance()
	{
		return UniqueChanceCalculator.getPetChance(raidLevel, getTotalPoints());
	}

	private void reset()
	{
		this.personalTotalPoints = BASE_POINTS;
		this.personalRoomPoints = 0;
		this.nonPartyPoints = 0;
		this.teamSize = 0;
		this.raidLevel = -1;
		this.wardenDowns = 0;
		this.seenMvpItems.clear();

		partyPointsTracker.clearPartyPointsMap();
		updatePersonalPartyPoints(true);
	}

	private void updatePersonalPartyPoints(boolean sendNow)
	{
		int points = getPersonalTotalPoints();
		if (sendNow)
		{
			partyPointsTracker.sendPointsUpdate(points);
		}
		else
		{
			partyPointsTracker.schedulePointsUpdate(points);
		}
	}

	private String buildPointsMessage()
	{
		StringBuilder sb = new StringBuilder();
		sb.append("Total points: ");
		sb.append(ColorUtil.wrapWithColorTag(POINTS_FORMAT.format(getTotalPoints()), Color.red));
		sb.append(", Personal points: ");
		sb.append(ColorUtil.wrapWithColorTag(POINTS_FORMAT.format(getPersonalTotalPoints()), Color.red));
		sb.append(" (");
		sb.append(ColorUtil.wrapWithColorTag(PERCENT_FORMAT.format(getPersonalPercent()), Color.red));
		sb.append(")");
		return sb.toString();
	}

	private void postPointsEvent()
	{
		eventBus.post(new PluginMessage(
			TombsOfAmascutPlugin.EVENT_NAMESPACE,
			EVENT_NAME,
			ImmutableMap.<String, Object>builder()
				.put("version", 1)
				.put("totalPoints", getTotalPoints())
				.put("personalPoints", getPersonalTotalPoints())
				.build()
		));
	}

}

package com.duckblade.osrs.toa.features.pointstracker;

import lombok.experimental.UtilityClass;

@UtilityClass
public class UniqueChanceCalculator
{

	private static final int BASE_RATE_UNIQUE = 10_500;
	private static final int MODIFIER_RAID_LEVEL_UNIQUE = 20;

	private static final int BASE_RATE_PET = 350_000;
	private static final int MODIFIER_RAID_LEVEL_PET = 700;

	private static final int RAID_LEVEL_REDUCE_FLOOR = 400;
	private static final double RAID_LEVEL_REDUCE_FACTOR = 1.0 / 3.0;
	private static final int RAID_LEVEL_MAX = 550;

	private static final double MAX_RATE_UNIQUE = 55;

	public static double getUniqueChance(int raidLevel, int points)
	{
		return getChance(raidLevel, points, BASE_RATE_UNIQUE, MODIFIER_RAID_LEVEL_UNIQUE);
	}

	public static double getPetChance(int raidLevel, int points)
	{
		return getChance(raidLevel, points, BASE_RATE_PET, MODIFIER_RAID_LEVEL_PET);
	}

	private static double getChance(int raidLevel, int points, int baseRate, int modifier)
	{
		int raidLevelModifier = modifier * Math.min(raidLevel, RAID_LEVEL_REDUCE_FLOOR);
		if (raidLevel > RAID_LEVEL_REDUCE_FLOOR)
		{
			raidLevelModifier += (Math.min(raidLevel, RAID_LEVEL_MAX) - RAID_LEVEL_REDUCE_FLOOR) * modifier * RAID_LEVEL_REDUCE_FACTOR;
		}

		double denominator = baseRate - raidLevelModifier;
		return Math.max(0, Math.min(MAX_RATE_UNIQUE, points / denominator));
	}
}

package com.duckblade.osrs.toa.features.pointstracker;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidState;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

@Singleton
public class PointsOverlay extends OverlayPanel implements PluginLifecycleComponent
{

	private final OverlayManager overlayManager;
	private final PointsTracker pointsTracker;
	private final PartyPointsTracker partyPointsTracker;
	private final TombsOfAmascutConfig config;

	@Inject
	public PointsOverlay(OverlayManager overlayManager, TombsOfAmascutConfig config, PointsTracker pointsTracker, PartyPointsTracker partyPointsTracker)
	{
		this.overlayManager = overlayManager;
		this.config = config;
		this.pointsTracker = pointsTracker;
		this.partyPointsTracker = partyPointsTracker;
		setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
	}

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState raidState)
	{
		return config.pointsTrackerOverlayEnable() &&
			raidState.isInRaid();
	}

	@Override
	public void startUp()
	{
		this.overlayManager.add(this);
	}

	@Override
	public void shutDown()
	{
		this.overlayManager.remove(this);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		panelComponent.getChildren().add(
			TitleComponent.builder()
				.text("ToA Points")
				.build()
		);

		addPointsLine("Total:", pointsTracker.getTotalPoints());
		if (partyPointsTracker.isInParty())
		{
			addPointsLine("Personal:", pointsTracker.getPersonalTotalPoints());
		}

		if (config.pointsTrackerShowRoomPoints())
		{
			addPointsLine("Room:", pointsTracker.getPersonalRoomPoints());
		}

		if (config.pointsTrackerShowUniqueChance())
		{
			addChanceLine("Unique:", pointsTracker.getUniqueChance());
		}

		if (config.pointsTrackerShowPetChance())
		{
			addChanceLine("Pet:", pointsTracker.getPetChance());
		}

		return super.render(graphics);
	}

	private void addLine(String left, String right)
	{
		panelComponent.getChildren().add(
			LineComponent.builder()
				.left(left)
				.right(right)
				.build()
		);
	}

	private void addPointsLine(String title, int value)
	{
		addLine(title, PointsTracker.POINTS_FORMAT.format(value));
	}

	private void addChanceLine(String title, double value)
	{
		addLine(title, PointsTracker.PERCENT_FORMAT.format(value / 100));
	}
}

package com.duckblade.osrs.toa.features.het.pickaxe;

import com.duckblade.osrs.toa.util.InventoryUtil;
import com.google.common.collect.ImmutableSet;
import java.util.Set;
import lombok.experimental.UtilityClass;
import net.runelite.api.Client;
import net.runelite.api.InventoryID;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;

@UtilityClass
public class PickaxeUtil
{

	private static final Set<Integer> PICKAXE_IDS = ImmutableSet.of(
		ItemID.BRONZE_PICKAXE,
		ItemID.IRON_PICKAXE,
		ItemID.STEEL_PICKAXE,
		ItemID.BLACK_PICKAXE,
		ItemID.MITHRIL_PICKAXE,
		ItemID.ADAMANT_PICKAXE,
		ItemID.RUNE_PICKAXE,
		ItemID.DRAGON_PICKAXE,
		ItemID.DRAGON_PICKAXE_12797,
		ItemID.DRAGON_PICKAXE_OR,
		ItemID.DRAGON_PICKAXE_OR_25376,
		ItemID.INFERNAL_PICKAXE,
		ItemID.INFERNAL_PICKAXE_OR,
		ItemID.INFERNAL_PICKAXE_UNCHARGED,
		ItemID.INFERNAL_PICKAXE_UNCHARGED_25369,
		ItemID.CRYSTAL_PICKAXE,
		ItemID.CRYSTAL_PICKAXE_23863,
		ItemID.CRYSTAL_PICKAXE_INACTIVE,
		ItemID._3RD_AGE_PICKAXE,
		ItemID.GILDED_PICKAXE,
		ItemID.TRAILBLAZER_PICKAXE
	);

	private static final int VARBIT_PICKAXE_STORAGE = 14440;

	public static boolean hasPickaxe(Client client)
	{

		ItemContainer inv = client.getItemContainer(InventoryID.INVENTORY);
		ItemContainer equip = client.getItemContainer(InventoryID.EQUIPMENT);
		if (inv == null && equip == null)
		{
			return false;
		}

		return (inv != null && InventoryUtil.containsAny(inv, PICKAXE_IDS)) ||
			(equip != null && InventoryUtil.containsAny(equip, PICKAXE_IDS));
	}

	public static boolean pickaxeIsInStorage(Client client)
	{
		return client.getVarbitValue(VARBIT_PICKAXE_STORAGE) != 0;
	}

}

package com.duckblade.osrs.toa.features.het.pickaxe;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidRoom;
import com.duckblade.osrs.toa.util.RaidState;
import com.duckblade.osrs.toa.util.RaidStateTracker;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.MenuEntry;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class DepositPickaxePreventEntry implements PluginLifecycleComponent
{

	private final EventBus eventBus;
	private final Client client;
	private final RaidStateTracker raidStateTracker;

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState currentState)
	{
		return (currentState.getCurrentRoom() == RaidRoom.HET && config.hetPickaxePreventExit()) ||
			(currentState.isInLobby() && config.hetPickaxePreventRaidStart());
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded e)
	{
		// don't lift out isEntry, it's more expensive than room checks
		if (raidStateTracker.getCurrentState().isInLobby())
		{
			if (!PickaxeUtil.pickaxeIsInStorage(client) && isEntry(e.getMenuEntry()))
			{
				e.getMenuEntry().setDeprioritized(true);
			}
		}
		else if (raidStateTracker.getCurrentState().getCurrentRoom() == RaidRoom.HET)
		{
			if (isEntry(e.getMenuEntry()) && PickaxeUtil.hasPickaxe(client))
			{
				e.getMenuEntry().setDeprioritized(true);
			}
		}
	}

	private static boolean isEntry(MenuEntry menuEntry)
	{
		return menuEntry.getOption().contains("Enter") &&
			menuEntry.getTarget().contains("Entry");
	}
}

package com.duckblade.osrs.toa.features.het.pickaxe;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidRoom;
import com.duckblade.osrs.toa.util.RaidState;
import com.duckblade.osrs.toa.util.RaidStateTracker;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.util.IdentityHashMap;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.NullObjectID;
import net.runelite.api.ObjectID;
import net.runelite.api.Point;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

@Singleton
public class DepositPickaxeOverlay extends Overlay implements PluginLifecycleComponent
{

	private static final int OBJECT_AKKHA_ENTRY = ObjectID.ENTRY_45131;
	private static final int OBJECT_RAID_ENTRY = ObjectID.ENTRY_46089;
	private static final int OBJECT_EMPTY_CAVITY = NullObjectID.NULL_49566;
	private static final int OBJECT_STATUE = NullObjectID.NULL_45468;
	private static final Color OVERLAY_COLOR = new Color(225, 163, 12);
	private static final String WARNING_TEXT = "Deposit a pickaxe.";

	private final EventBus eventBus;
	private final OverlayManager overlayManager;
	private final Client client;
	private final RaidStateTracker raidStateTracker;

	private IdentityHashMap<GameObject, Boolean> highlightObjects;
	private GameObject entry;
	private boolean roomComplete;

	@Inject
	public DepositPickaxeOverlay(
		EventBus eventBus,
		OverlayManager overlayManager,
		Client client,
		RaidStateTracker raidStateTracker
	)
	{
		this.eventBus = eventBus;
		this.overlayManager = overlayManager;
		this.client = client;
		this.raidStateTracker = raidStateTracker;

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState raidState)
	{
		return (raidState.getCurrentRoom() == RaidRoom.HET && config.hetPickaxePuzzleOverlay()) ||
			(raidState.isInLobby() && config.hetPickaxeLobbyOverlay());
	}

	@Override
	public void startUp()
	{
		entry = null;
		highlightObjects = new IdentityHashMap<>();
		roomComplete = false;
		eventBus.register(this);
		overlayManager.add(this);
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
		overlayManager.remove(this);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (PickaxeUtil.pickaxeIsInStorage(client))
		{
			return null;
		}

		if (raidStateTracker.getCurrentState().getCurrentRoom() == RaidRoom.HET)
		{
			if (!roomComplete || !PickaxeUtil.hasPickaxe(client))
			{
				return null;
			}
		}

		for (GameObject toHighlight : highlightObjects.keySet())
		{
			Shape hull;
			if ((hull = toHighlight.getConvexHull()) != null)
			{
				OverlayUtil.renderPolygon(graphics, hull, OVERLAY_COLOR);
			}
		}

		Point textPoint;
		if (entry != null && (textPoint = entry.getCanvasTextLocation(graphics, WARNING_TEXT, 0)) != null)
		{
			OverlayUtil.renderTextLocation(graphics, textPoint, WARNING_TEXT, OVERLAY_COLOR);
		}

		return null;
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned e)
	{
		switch (e.getGameObject().getId())
		{
			case OBJECT_EMPTY_CAVITY:
			case OBJECT_STATUE:
				highlightObjects.put(e.getGameObject(), true);
				break;

			case OBJECT_RAID_ENTRY:
			case OBJECT_AKKHA_ENTRY:
				entry = e.getGameObject();
				break;
		}
	}

	@Subscribe
	public void onGameObjectDespawned(GameObjectDespawned e)
	{
		switch (e.getGameObject().getId())
		{
			case OBJECT_EMPTY_CAVITY:
			case OBJECT_STATUE:
				highlightObjects.remove(e.getGameObject());
				break;

			case OBJECT_RAID_ENTRY:
			case OBJECT_AKKHA_ENTRY:
				entry = null;
				break;
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage e)
	{
		if (e.getType() == ChatMessageType.GAMEMESSAGE && e.getMessage().startsWith("Challenge complete"))
		{
			roomComplete = true;
		}
	}

}

package com.duckblade.osrs.toa.features.het.pickaxe;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Getter
@SuppressWarnings("DeprecatedIsStillUsed")
@Deprecated
/**
 * Deprecated: Former config option that has since been converted to separate booleans.
 * Remains in codebase for config migration.
 */
public enum DepositPickaxeMode
{

	OFF(false, false),
	STATUE_SWAP(true, false),
	PREVENT_EXIT(false, true),
	BOTH(true, true),
	;

	private final boolean swapStatue;
	private final boolean swapExit;

}

package com.duckblade.osrs.toa.features.het.pickaxe;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidRoom;
import com.duckblade.osrs.toa.util.RaidState;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.MenuEntry;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class DepositPickaxeSwap implements PluginLifecycleComponent
{

	private final EventBus eventBus;
	private final Client client;

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState currentState)
	{
		return (currentState.getCurrentRoom() == RaidRoom.HET || currentState.isInLobby()) &&
			config.hetPickaxeMenuSwap();
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded e)
	{
		if (isTakePickaxe(e.getMenuEntry()) && PickaxeUtil.hasPickaxe(client))
		{
			e.getMenuEntry().setDeprioritized(true);
		}
	}

	private static boolean isTakePickaxe(MenuEntry menuEntry)
	{
		return menuEntry.getOption().equals("Take-pickaxe") &&
			menuEntry.getTarget().contains("Statue");
	}
}

package com.duckblade.osrs.toa.features.het.solver;

import com.google.common.annotations.VisibleForTesting;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class HetSolutionResult implements Comparable<HetSolutionResult>
{

	private static final int MAX_MIRRORS = 3;
	private static final Comparator<HetSolutionResult> COMPARATOR =
		Comparator.<HetSolutionResult>comparingInt(hs -> hs.completable ? Integer.MIN_VALUE : Integer.MAX_VALUE)
			.thenComparingInt(HetSolutionResult::getMirrorsToMove)
			.thenComparingInt(HetSolutionResult::getWallsToBreak)
			.thenComparingInt(HetSolutionResult::getMirrorsToAlter);

	private boolean completable;
	private int mirrorsToMove;
	private int mirrorsToAlter; // rotate or clean
	private int wallsToBreak;

	private List<HetTileState> incorrectStates;

	public HetSolutionResult(boolean completable, int mirrorsToMove, int mirrorsToAlter, int wallsToBreak, HetTileState wrongState)
	{
		this(
			completable,
			mirrorsToMove,
			mirrorsToAlter,
			wallsToBreak,
			wrongState != null ? Collections.singletonList(wrongState) : Collections.emptyList()
		);
	}

	public void add(HetSolutionResult other)
	{
		this.mirrorsToMove += other.mirrorsToMove;
		this.mirrorsToAlter += other.mirrorsToAlter;
		this.wallsToBreak += other.wallsToBreak;
		this.completable = this.completable && other.completable && (this.mirrorsToMove <= MAX_MIRRORS);
		this.incorrectStates.addAll(other.incorrectStates);
	}

	@Override
	public int compareTo(HetSolutionResult o)
	{
		return COMPARATOR.compare(this, o);
	}

	@VisibleForTesting
	public String getOverlayString()
	{
		if (!this.completable)
		{
			if (this.incorrectStates.isEmpty())
			{
				return " FAIL ???";
			}

			HetTileState lastBadState = this.incorrectStates.get(this.incorrectStates.size() - 1);
			return " FAIL " + lastBadState.getX() + ", " + lastBadState.getY();
		}
		return "M" + mirrorsToMove + " / W" + wallsToBreak + " / A" + mirrorsToAlter;
	}
}

package com.duckblade.osrs.toa.features.het.solver;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidRoom;
import com.duckblade.osrs.toa.util.RaidState;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Polygon;
import java.awt.Shape;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.Perspective;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

@Singleton
public class HetSolverOverlay extends Overlay implements PluginLifecycleComponent
{

	private final OverlayManager overlayManager;
	private final Client client;
	private final HetSolver hetSolver;

	@Inject
	public HetSolverOverlay(OverlayManager overlayManager, Client client, HetSolver hetSolver)
	{
		this.overlayManager = overlayManager;
		this.client = client;
		this.hetSolver = hetSolver;

		setLayer(OverlayLayer.ABOVE_SCENE);
		setPosition(OverlayPosition.DYNAMIC);
	}

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState raidState)
	{
		return config.hetSolverEnable() && raidState.getCurrentRoom() == RaidRoom.HET;
	}

	@Override
	public void startUp()
	{
		overlayManager.add(this);
	}

	@Override
	public void shutDown()
	{
		overlayManager.remove(this);
	}

	@Override
	public Dimension render(Graphics2D g)
	{
		HetSolution sol = hetSolver.getSolution();
		if (sol == null)
		{
			return null;
		}

		// re-evaluate in case the user has caused the solution to now fail, in which case the plugin won't update the solution
		HetSolutionResult res = sol.getScore(hetSolver.getRoomStates());
		for (HetTileState incorrectState : res.getIncorrectStates())
		{
			if (incorrectState.getState() == HetTileState.STATE_EMPTY)
			{
				// highlight whatever object needs to be removed
				GameObject highlightObj = hetSolver.getRoomObjects()[incorrectState.getX()][incorrectState.getY()];
				Shape hull;
				if (highlightObj != null && (hull = highlightObj.getConvexHull()) != null)
				{
					OverlayUtil.renderPolygon(g, hull, Color.red);
				}
				continue;
			}

			if (incorrectState.getState() == HetTileState.STATE_MIRROR_MOVABLE)
			{
				// highlight the tile that needs a mirror
				int sceneX = incorrectState.getX() + hetSolver.getPuzzleBase().getX();
				int sceneY = incorrectState.getY() + hetSolver.getPuzzleBase().getY();
				Polygon tile = Perspective.getCanvasTilePoly(client, LocalPoint.fromScene(sceneX, sceneY));
				if (tile != null)
				{
					OverlayUtil.renderPolygon(g, tile, Color.red);

					Point sw = new Point(tile.xpoints[0], tile.ypoints[0]);
					Point se = new Point(tile.xpoints[1], tile.ypoints[1]);
					Point ne = new Point(tile.xpoints[2], tile.ypoints[2]);
					Point nw = new Point(tile.xpoints[3], tile.ypoints[3]);

					Polygon tri = new Polygon();
					switch (incorrectState.getOrientation())
					{
						case HetTileState.ORIENTATION_NORTH_EAST:
							tri.addPoint(nw.x, nw.y);
							tri.addPoint(ne.x, ne.y);
							tri.addPoint(se.x, se.y);
							break;

						case HetTileState.ORIENTATION_SOUTH_EAST:
							tri.addPoint(sw.x, sw.y);
							tri.addPoint(se.x, se.y);
							tri.addPoint(ne.x, ne.y);
							break;

						case HetTileState.ORIENTATION_SOUTH_WEST:
							tri.addPoint(nw.x, nw.y);
							tri.addPoint(sw.x, sw.y);
							tri.addPoint(se.x, se.y);
							break;

						default:
							tri.addPoint(sw.x, sw.y);
							tri.addPoint(nw.x, nw.y);
							tri.addPoint(ne.x, ne.y);
							break;
					}
					g.setColor(Color.red);
					g.fill(tri);
				}
			}
		}

		return null;
	}
}

package com.duckblade.osrs.toa.features.het.solver;

import com.google.common.collect.ImmutableMap;
import java.util.Collections;
import java.util.Map;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import net.runelite.api.GameObject;
import net.runelite.api.NullObjectID;
import net.runelite.api.ObjectID;
import net.runelite.api.Point;

@Data
@RequiredArgsConstructor
public class HetTileState
{

	public static final int STATE_EMPTY = 0;
	public static final int STATE_MIRROR_MOVABLE = 1;
	public static final int STATE_MIRROR = 2;
	public static final int STATE_MIRROR_DIRTY = 3;
	public static final int STATE_WALL_BROKEN = 4;
	public static final int STATE_WALL_REMOVED = 5;
	public static final int STATE_WALL_STATIC = 6;

	public static final Map<Integer, Integer> OBJECT_ID_TO_STATE = ImmutableMap.<Integer, Integer>builder()
		.put(ObjectID.MIRROR_45455, STATE_MIRROR_MOVABLE)
		.put(ObjectID.MIRROR_45456, STATE_MIRROR)
		.put(ObjectID.MIRROR_DIRTY, STATE_MIRROR_DIRTY)
		.put(ObjectID.BARRIER_45458, STATE_WALL_STATIC)
		.put(ObjectID.BARRIER_45460, STATE_WALL_STATIC)
		.put(ObjectID.BARRIER_45462, STATE_WALL_BROKEN)
		.put(ObjectID.BARRIER_45464, STATE_WALL_BROKEN)
		.put(NullObjectID.NULL_45466, STATE_WALL_REMOVED) // wall mined, but floor rubble remains
		.put(NullObjectID.NULL_29733, STATE_EMPTY) // this object is placed to "clear" previous objects (e.g. mirror picked up, wall despawned)
		.build();

	public static final int ORIENTATION_NORTH_EAST = 0b00;
	public static final int ORIENTATION_SOUTH_EAST = 0b01;
	public static final int ORIENTATION_SOUTH_WEST = 0b10;
	public static final int ORIENTATION_NORTH_WEST = 0b11;

	// x and y in "puzzle-space" where (0, 0) is the bottom left corner of a 21x21 grid encompassing the puzzle space
	private final int x;
	private final int y;
	private final int state;
	private final int orientation;

	public HetTileState(int x, int y, int state)
	{
		this(x, y, state, ORIENTATION_NORTH_EAST);
	}

	public static HetTileState fromGameObject(GameObject o, Point puzzleBase)
	{
		Point p = o.getSceneMinLocation();
		return new HetTileState(
			p.getX() - puzzleBase.getX(),
			p.getY() - puzzleBase.getY(),
			OBJECT_ID_TO_STATE.getOrDefault(o.getId(), STATE_EMPTY),
			(o.getConfig() & 0b11000000) >> 6
		);
	}

	public HetSolutionResult conversionScoreTo(HetTileState other)
	{
		assert other != null;
		assert this.x == other.x;
		assert this.y == other.y;

		if (this.state == other.state)
		{
			// minor hack, i assume `other` will never be a wall
			return this.orientation == other.orientation ? new HetSolutionResult(true, 0, 0, 0, Collections.emptyList()) : new HetSolutionResult(
				true,
				0,
				1,
				0,
				other
			);
		}

		switch (this.state)
		{
			case STATE_WALL_STATIC:
				// we can't convert static walls to anything, obviously
				return new HetSolutionResult(false, 0, 0, 0, other);


			case STATE_MIRROR_DIRTY:
			case STATE_MIRROR:
				// STATE_MIRROR can take the place of a STATE_MIRROR_MOVABLE iff orientation matches
				// and fails the solution in all other cases
				// also, dirty mirrors are never movable, so they handle the same
				HetTileState maybeClean = this.state == STATE_MIRROR_DIRTY ? other : null;
				if (other.state == STATE_MIRROR_MOVABLE && this.orientation == other.orientation)
				{
					return new HetSolutionResult(true, 0, maybeClean == null ? 0 : 1, 0, maybeClean);
				}
				return new HetSolutionResult(false, 0, 0, 0, other);

			case STATE_EMPTY:
			case STATE_WALL_REMOVED:
			case STATE_WALL_BROKEN:
				HetTileState maybeWallRemove = this.state == STATE_WALL_BROKEN ? other : null;
				if (other.state == STATE_EMPTY)
				{
					// tile needs to be clear (but may already be clear)
					return new HetSolutionResult(true, 0, 0, maybeWallRemove == null ? 0 : 1, maybeWallRemove);
				}

				if (other.state == STATE_MIRROR_MOVABLE)
				{
					// mirror needs to be placed here (and maybe a wall cleared first too)
					return new HetSolutionResult(true, 1, 0, maybeWallRemove == null ? 0 : 1, other);
				}

			case STATE_MIRROR_MOVABLE:
				// assumption that other is EMPTY
				// don't count this as a mirror move, only count the destination as one to avoid double count
				return new HetSolutionResult(true, 0, 0, 0, other);

			default:
				// all possible combinations should have now already been reached
				return new HetSolutionResult(false, 0, 0, 0, other);
		}
	}

	// whether to reset the solution state when we see a state of this
	// i.e. is this state a human-actionable state update
	public boolean stateResetsSolution()
	{
		switch (state)
		{
			case STATE_EMPTY:
			case STATE_WALL_REMOVED:
			case STATE_MIRROR_MOVABLE:
			case STATE_MIRROR_DIRTY: // black orbs hitting mirrors can make them dirty
			case STATE_MIRROR: // clean action
				return false;

			// basically just if a wall spawns
			default:
				return true;
		}
	}

}

package com.duckblade.osrs.toa.features.het.solver;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidRoom;
import com.duckblade.osrs.toa.util.RaidState;
import java.util.Arrays;
import java.util.Collections;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameObject;
import net.runelite.api.GameState;
import net.runelite.api.NullObjectID;
import net.runelite.api.ObjectID;
import net.runelite.api.Point;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class HetSolver implements PluginLifecycleComponent
{

	private static final int STATUE_SHIELDED = ObjectID.SHIELDED_STATUE;

	private final EventBus eventBus;
	private final ClientThread clientThread;

	@Getter
	private final HetTileState[][] roomStates = new HetTileState[21][21]; // for determining solution

	@Getter
	private final GameObject[][] roomObjects = new GameObject[21][21]; // for overlay highlighting

	@Getter
	private Point puzzleBase = null; // reference point for coord checks, bottom left corner of 21x21 area inside room

	@Getter
	private HetSolutionResult result;

	@Getter
	private HetSolution solution;

	private boolean solveQueued = false; // we solve at the end of the tick
	private boolean puzzleChurned = false;

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState raidState)
	{
		return config.hetSolverEnable() && raidState.getCurrentRoom() == RaidRoom.HET;
	}

	@Override
	public void startUp()
	{
		clearSolve();
		puzzleBase = null;
		eventBus.register(this);
	}

	@Override
	public void shutDown()
	{
		clearSolve();
		eventBus.unregister(this);
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged e)
	{
		if (e.getGameState() != GameState.LOGGED_IN)
		{
			clearSolve();
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage e)
	{
		if (e.getMessage().startsWith("Your party failed to complete the challenge") || e.getMessage().endsWith("violently!"))
		{
			clearSolve();
		}
		else if (e.getMessage().startsWith("Challenge complete"))
		{
			shutDown();
		}
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned e)
	{
		if (solution == null && e.getGameObject().getId() == NullObjectID.NULL_29733)
		{
			return;
		}

		onGameObjectSpawned(e, true);
	}

	private void onGameObjectSpawned(GameObjectSpawned e, boolean canLoop)
	{
		Point p = e.getGameObject().getSceneMinLocation();
		if (e.getGameObject().getId() == STATUE_SHIELDED)
		{
			puzzleBase = new Point(p.getX() - 12, p.getY() - 9);
			log.debug("Found puzzle base at {}", puzzleBase);
			return;
		}

		if (!HetTileState.OBJECT_ID_TO_STATE.containsKey(e.getGameObject().getId()))
		{
			return;
		}

		if (puzzleBase == null)
		{
			// puzzle base event is probably queued, but this event came in first
			if (canLoop)
			{
				clientThread.invokeLater(() -> onGameObjectSpawned(e, false));
			}
			return;
		}

		// make sure we're actually inside the room boundaries
		p = normalize(p);
		if (p.getX() < 0 || p.getY() < 0 || p.getX() >= roomStates.length || p.getY() >= roomStates[0].length)
		{
			return;
		}

		// it's a relevant object, store it in the state map
		HetTileState hts = HetTileState.fromGameObject(e.getGameObject(), puzzleBase);
		roomStates[p.getX()][p.getY()] = hts;
		roomObjects[p.getX()][p.getY()] = e.getGameObject();

		if (hts.stateResetsSolution())
		{
			puzzleChurned = true;
		}

		// these events are all single-thread so no need for an atomic boolean here
		if (!solveQueued)
		{
			solveQueued = true;
			clientThread.invokeLater(this::solve);
		}
	}

	private void solve()
	{
		solveQueued = false;

		if (puzzleChurned)
		{
			// if the action was from the room spawning in, prevent gradient valley by clearing the preferential solution
			puzzleChurned = false;
			this.result = null;
			this.solution = null;
		}

		// once we've found a solution once, preferentially keep it unless another solution becomes strictly closer
		HetSolutionResult minResult = this.result != null ? this.result : new HetSolutionResult(false, 0, 0, 0, Collections.emptyList());
		HetSolution minSolution = this.solution != null ? this.solution : null;
		for (HetSolution solution : HetSolution.values())
		{
			HetSolutionResult score = solution.getScore(roomStates);
			if (score.compareTo(minResult) < 0)
			{
				minResult = score;
				minSolution = solution;
			}
		}

		if (!minResult.isCompletable())
		{
			log.debug("All solutions were eliminated");
			clearSolve();
			return;
		}

		this.result = minResult;
		this.solution = minSolution;
	}

	private void clearSolve()
	{
		solveQueued = false;
		result = null;
		solution = null;

		// wipe the board
		for (HetTileState[] tileState : roomStates)
		{
			Arrays.fill(tileState, null);
		}
		for (GameObject[] go : roomObjects)
		{
			Arrays.fill(go, null);
		}
	}

	private Point normalize(Point p)
	{
		return new Point(p.getX() - puzzleBase.getX(), p.getY() - puzzleBase.getY());
	}
}

package com.duckblade.osrs.toa.features.het.solver;

import com.google.common.annotations.VisibleForTesting;
import java.util.ArrayList;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum HetSolution
{

	// basically we trace a line through the room checking for all these specific states
	SOLUTION_1(new HetTileState[]{
		new HetTileState(5, 10, HetTileState.STATE_MIRROR_MOVABLE, HetTileState.ORIENTATION_NORTH_EAST),
		new HetTileState(5, 11, HetTileState.STATE_EMPTY),
		new HetTileState(5, 12, HetTileState.STATE_EMPTY),
		new HetTileState(5, 13, HetTileState.STATE_EMPTY),
		new HetTileState(5, 14, HetTileState.STATE_EMPTY),
		new HetTileState(5, 15, HetTileState.STATE_EMPTY),
		new HetTileState(5, 16, HetTileState.STATE_EMPTY),
		new HetTileState(5, 17, HetTileState.STATE_EMPTY),
		new HetTileState(5, 18, HetTileState.STATE_MIRROR_MOVABLE, HetTileState.ORIENTATION_SOUTH_EAST),
		new HetTileState(6, 18, HetTileState.STATE_EMPTY),
		new HetTileState(7, 18, HetTileState.STATE_EMPTY),
		new HetTileState(8, 18, HetTileState.STATE_EMPTY),
		new HetTileState(9, 18, HetTileState.STATE_EMPTY),
		new HetTileState(10, 18, HetTileState.STATE_EMPTY),
		new HetTileState(11, 18, HetTileState.STATE_EMPTY),
		new HetTileState(12, 18, HetTileState.STATE_EMPTY),
		new HetTileState(13, 18, HetTileState.STATE_EMPTY),
		new HetTileState(14, 18, HetTileState.STATE_MIRROR_MOVABLE, HetTileState.ORIENTATION_SOUTH_WEST),
		new HetTileState(14, 17, HetTileState.STATE_EMPTY),
		new HetTileState(14, 16, HetTileState.STATE_EMPTY),
		new HetTileState(14, 15, HetTileState.STATE_EMPTY),
		new HetTileState(14, 14, HetTileState.STATE_EMPTY),
		new HetTileState(14, 13, HetTileState.STATE_EMPTY),
		new HetTileState(14, 12, HetTileState.STATE_EMPTY),
	}),
	SOLUTION_2(new HetTileState[]{
		new HetTileState(5, 10, HetTileState.STATE_MIRROR_MOVABLE, HetTileState.ORIENTATION_SOUTH_EAST),
		new HetTileState(5, 9, HetTileState.STATE_EMPTY),
		new HetTileState(5, 8, HetTileState.STATE_EMPTY),
		new HetTileState(5, 7, HetTileState.STATE_EMPTY),
		new HetTileState(5, 6, HetTileState.STATE_MIRROR_MOVABLE, HetTileState.ORIENTATION_NORTH_EAST),
		new HetTileState(6, 6, HetTileState.STATE_EMPTY),
		new HetTileState(7, 6, HetTileState.STATE_EMPTY),
		new HetTileState(8, 6, HetTileState.STATE_EMPTY),
		new HetTileState(9, 6, HetTileState.STATE_EMPTY),
		new HetTileState(10, 6, HetTileState.STATE_EMPTY),
		new HetTileState(11, 6, HetTileState.STATE_EMPTY),
		new HetTileState(12, 6, HetTileState.STATE_EMPTY),
		new HetTileState(13, 6, HetTileState.STATE_EMPTY),
		new HetTileState(14, 6, HetTileState.STATE_EMPTY),
		new HetTileState(15, 6, HetTileState.STATE_EMPTY),
		new HetTileState(16, 6, HetTileState.STATE_EMPTY),
		new HetTileState(17, 6, HetTileState.STATE_EMPTY),
		new HetTileState(18, 6, HetTileState.STATE_MIRROR_MOVABLE, HetTileState.ORIENTATION_NORTH_WEST),
		new HetTileState(18, 7, HetTileState.STATE_EMPTY),
		new HetTileState(18, 8, HetTileState.STATE_EMPTY),
		new HetTileState(18, 9, HetTileState.STATE_EMPTY),
		new HetTileState(18, 10, HetTileState.STATE_MIRROR_MOVABLE, HetTileState.ORIENTATION_SOUTH_WEST),
		new HetTileState(17, 10, HetTileState.STATE_EMPTY),
		new HetTileState(16, 10, HetTileState.STATE_EMPTY),
		new HetTileState(15, 10, HetTileState.STATE_EMPTY),
	}),
	SOLUTION_3(new HetTileState[]{
		new HetTileState(5, 10, HetTileState.STATE_EMPTY),
		new HetTileState(4, 10, HetTileState.STATE_MIRROR_MOVABLE, HetTileState.ORIENTATION_SOUTH_EAST),
		new HetTileState(4, 9, HetTileState.STATE_EMPTY),
		new HetTileState(4, 8, HetTileState.STATE_EMPTY),
		new HetTileState(4, 7, HetTileState.STATE_EMPTY),
		new HetTileState(4, 6, HetTileState.STATE_EMPTY),
		new HetTileState(4, 5, HetTileState.STATE_EMPTY),
		new HetTileState(4, 4, HetTileState.STATE_EMPTY),
		new HetTileState(4, 3, HetTileState.STATE_EMPTY),
		new HetTileState(4, 2, HetTileState.STATE_MIRROR_MOVABLE, HetTileState.ORIENTATION_NORTH_EAST),
		new HetTileState(5, 2, HetTileState.STATE_EMPTY),
		new HetTileState(6, 2, HetTileState.STATE_EMPTY),
		new HetTileState(7, 2, HetTileState.STATE_EMPTY),
		new HetTileState(8, 2, HetTileState.STATE_EMPTY),
		new HetTileState(9, 2, HetTileState.STATE_EMPTY),
		new HetTileState(10, 2, HetTileState.STATE_EMPTY),
		new HetTileState(11, 2, HetTileState.STATE_EMPTY),
		new HetTileState(12, 2, HetTileState.STATE_EMPTY),
		new HetTileState(13, 2, HetTileState.STATE_MIRROR_MOVABLE, HetTileState.ORIENTATION_NORTH_WEST),
		new HetTileState(13, 3, HetTileState.STATE_EMPTY),
		new HetTileState(13, 4, HetTileState.STATE_EMPTY),
		new HetTileState(13, 5, HetTileState.STATE_EMPTY),
		new HetTileState(13, 6, HetTileState.STATE_EMPTY),
		new HetTileState(13, 7, HetTileState.STATE_EMPTY),
		new HetTileState(13, 8, HetTileState.STATE_EMPTY),
	}),
	SOLUTION_4(new HetTileState[]{
		new HetTileState(5, 10, HetTileState.STATE_EMPTY),
		new HetTileState(4, 10, HetTileState.STATE_EMPTY),
		new HetTileState(3, 10, HetTileState.STATE_MIRROR_MOVABLE, HetTileState.ORIENTATION_SOUTH_EAST),
		new HetTileState(3, 9, HetTileState.STATE_EMPTY),
		new HetTileState(3, 8, HetTileState.STATE_EMPTY),
		new HetTileState(3, 7, HetTileState.STATE_EMPTY),
		new HetTileState(3, 6, HetTileState.STATE_EMPTY),
		new HetTileState(3, 5, HetTileState.STATE_EMPTY),
		new HetTileState(3, 4, HetTileState.STATE_EMPTY),
		new HetTileState(3, 3, HetTileState.STATE_EMPTY),
		new HetTileState(3, 2, HetTileState.STATE_MIRROR_MOVABLE, HetTileState.ORIENTATION_NORTH_EAST),
		new HetTileState(4, 2, HetTileState.STATE_EMPTY),
		new HetTileState(5, 2, HetTileState.STATE_EMPTY),
		new HetTileState(6, 2, HetTileState.STATE_EMPTY),
		new HetTileState(7, 2, HetTileState.STATE_EMPTY),
		new HetTileState(8, 2, HetTileState.STATE_EMPTY),
		new HetTileState(9, 2, HetTileState.STATE_EMPTY),
		new HetTileState(10, 2, HetTileState.STATE_EMPTY),
		new HetTileState(11, 2, HetTileState.STATE_EMPTY),
		new HetTileState(12, 2, HetTileState.STATE_EMPTY),
		new HetTileState(13, 2, HetTileState.STATE_EMPTY),
		new HetTileState(14, 2, HetTileState.STATE_EMPTY),
		new HetTileState(15, 2, HetTileState.STATE_EMPTY),
		new HetTileState(16, 2, HetTileState.STATE_EMPTY),
		new HetTileState(17, 2, HetTileState.STATE_MIRROR_MOVABLE, HetTileState.ORIENTATION_NORTH_WEST),
		new HetTileState(17, 3, HetTileState.STATE_EMPTY),
		new HetTileState(17, 4, HetTileState.STATE_EMPTY),
		new HetTileState(17, 5, HetTileState.STATE_EMPTY),
		new HetTileState(17, 6, HetTileState.STATE_EMPTY),
		new HetTileState(17, 7, HetTileState.STATE_EMPTY),
		new HetTileState(17, 8, HetTileState.STATE_EMPTY),
		new HetTileState(17, 9, HetTileState.STATE_EMPTY),
		new HetTileState(17, 10, HetTileState.STATE_EMPTY),
		new HetTileState(17, 11, HetTileState.STATE_MIRROR_MOVABLE, HetTileState.ORIENTATION_SOUTH_WEST),
		new HetTileState(16, 11, HetTileState.STATE_EMPTY),
		new HetTileState(15, 11, HetTileState.STATE_EMPTY),
	}),
	SOLUTION_5(new HetTileState[]{
		new HetTileState(5, 10, HetTileState.STATE_EMPTY),
		new HetTileState(4, 10, HetTileState.STATE_EMPTY),
		new HetTileState(3, 10, HetTileState.STATE_EMPTY),
		new HetTileState(2, 10, HetTileState.STATE_MIRROR_MOVABLE, HetTileState.ORIENTATION_NORTH_EAST),
		new HetTileState(2, 11, HetTileState.STATE_EMPTY),
		new HetTileState(2, 12, HetTileState.STATE_EMPTY),
		new HetTileState(2, 13, HetTileState.STATE_EMPTY),
		new HetTileState(2, 14, HetTileState.STATE_EMPTY),
		new HetTileState(2, 15, HetTileState.STATE_EMPTY),
		new HetTileState(2, 16, HetTileState.STATE_EMPTY),
		new HetTileState(2, 17, HetTileState.STATE_MIRROR_MOVABLE, HetTileState.ORIENTATION_SOUTH_EAST),
		new HetTileState(3, 17, HetTileState.STATE_EMPTY),
		new HetTileState(4, 17, HetTileState.STATE_EMPTY),
		new HetTileState(5, 17, HetTileState.STATE_EMPTY),
		new HetTileState(6, 17, HetTileState.STATE_EMPTY),
		new HetTileState(7, 17, HetTileState.STATE_EMPTY),
		new HetTileState(8, 17, HetTileState.STATE_EMPTY),
		new HetTileState(9, 17, HetTileState.STATE_EMPTY),
		new HetTileState(10, 17, HetTileState.STATE_EMPTY),
		new HetTileState(11, 17, HetTileState.STATE_EMPTY),
		new HetTileState(12, 17, HetTileState.STATE_EMPTY),
		new HetTileState(13, 17, HetTileState.STATE_MIRROR_MOVABLE, HetTileState.ORIENTATION_SOUTH_WEST),
		new HetTileState(13, 16, HetTileState.STATE_EMPTY),
		new HetTileState(13, 15, HetTileState.STATE_EMPTY),
		new HetTileState(13, 14, HetTileState.STATE_EMPTY),
		new HetTileState(13, 13, HetTileState.STATE_EMPTY),
		new HetTileState(13, 12, HetTileState.STATE_EMPTY),
	}),
	SOLUTION_6(new HetTileState[]{
		new HetTileState(5, 10, HetTileState.STATE_EMPTY),
		new HetTileState(4, 10, HetTileState.STATE_EMPTY),
		new HetTileState(3, 10, HetTileState.STATE_MIRROR_MOVABLE, HetTileState.ORIENTATION_NORTH_EAST),
		new HetTileState(3, 11, HetTileState.STATE_EMPTY),
		new HetTileState(3, 12, HetTileState.STATE_EMPTY),
		new HetTileState(3, 13, HetTileState.STATE_EMPTY),
		new HetTileState(3, 14, HetTileState.STATE_EMPTY),
		new HetTileState(3, 15, HetTileState.STATE_EMPTY),
		new HetTileState(3, 16, HetTileState.STATE_EMPTY),
		new HetTileState(3, 17, HetTileState.STATE_MIRROR_MOVABLE, HetTileState.ORIENTATION_SOUTH_EAST),
		new HetTileState(4, 17, HetTileState.STATE_EMPTY),
		new HetTileState(5, 17, HetTileState.STATE_EMPTY),
		new HetTileState(6, 17, HetTileState.STATE_EMPTY),
		new HetTileState(7, 17, HetTileState.STATE_EMPTY),
		new HetTileState(8, 17, HetTileState.STATE_EMPTY),
		new HetTileState(9, 17, HetTileState.STATE_EMPTY),
		new HetTileState(10, 17, HetTileState.STATE_EMPTY),
		new HetTileState(11, 17, HetTileState.STATE_EMPTY),
		new HetTileState(12, 17, HetTileState.STATE_EMPTY),
		new HetTileState(13, 17, HetTileState.STATE_EMPTY),
		new HetTileState(14, 17, HetTileState.STATE_MIRROR_MOVABLE, HetTileState.ORIENTATION_SOUTH_WEST),
		new HetTileState(14, 16, HetTileState.STATE_EMPTY),
		new HetTileState(14, 15, HetTileState.STATE_EMPTY),
		new HetTileState(14, 14, HetTileState.STATE_EMPTY),
		new HetTileState(14, 13, HetTileState.STATE_EMPTY),
		new HetTileState(14, 12, HetTileState.STATE_EMPTY),
	}),
	SOLUTION_7(new HetTileState[]{
		new HetTileState(5, 10, HetTileState.STATE_MIRROR_MOVABLE, HetTileState.ORIENTATION_NORTH_EAST),
		new HetTileState(5, 11, HetTileState.STATE_EMPTY),
		new HetTileState(5, 12, HetTileState.STATE_EMPTY),
		new HetTileState(5, 13, HetTileState.STATE_MIRROR_MOVABLE, HetTileState.ORIENTATION_SOUTH_EAST),
		new HetTileState(6, 13, HetTileState.STATE_EMPTY),
		new HetTileState(7, 13, HetTileState.STATE_EMPTY),
		new HetTileState(8, 13, HetTileState.STATE_EMPTY),
		new HetTileState(9, 13, HetTileState.STATE_EMPTY),
		new HetTileState(10, 13, HetTileState.STATE_EMPTY),
		new HetTileState(11, 13, HetTileState.STATE_EMPTY),
		new HetTileState(12, 13, HetTileState.STATE_MIRROR_MOVABLE, HetTileState.ORIENTATION_SOUTH_WEST),
		new HetTileState(12, 12, HetTileState.STATE_EMPTY),
	}),
	SOLUTION_8(new HetTileState[]{
		new HetTileState(5, 10, HetTileState.STATE_EMPTY),
		new HetTileState(4, 10, HetTileState.STATE_MIRROR_MOVABLE, HetTileState.ORIENTATION_SOUTH_EAST),
		new HetTileState(4, 9, HetTileState.STATE_EMPTY),
		new HetTileState(4, 8, HetTileState.STATE_EMPTY),
		new HetTileState(4, 7, HetTileState.STATE_EMPTY),
		new HetTileState(4, 6, HetTileState.STATE_EMPTY),
		new HetTileState(4, 5, HetTileState.STATE_EMPTY),
		new HetTileState(4, 4, HetTileState.STATE_EMPTY),
		new HetTileState(4, 3, HetTileState.STATE_MIRROR_MOVABLE, HetTileState.ORIENTATION_NORTH_EAST),
		new HetTileState(5, 3, HetTileState.STATE_EMPTY),
		new HetTileState(6, 3, HetTileState.STATE_EMPTY),
		new HetTileState(7, 3, HetTileState.STATE_EMPTY),
		new HetTileState(8, 3, HetTileState.STATE_EMPTY),
		new HetTileState(9, 3, HetTileState.STATE_EMPTY),
		new HetTileState(10, 3, HetTileState.STATE_EMPTY),
		new HetTileState(11, 3, HetTileState.STATE_EMPTY),
		new HetTileState(12, 3, HetTileState.STATE_EMPTY),
		new HetTileState(13, 3, HetTileState.STATE_MIRROR_MOVABLE, HetTileState.ORIENTATION_NORTH_WEST),
		new HetTileState(13, 4, HetTileState.STATE_EMPTY),
		new HetTileState(13, 5, HetTileState.STATE_EMPTY),
		new HetTileState(13, 6, HetTileState.STATE_EMPTY),
		new HetTileState(13, 7, HetTileState.STATE_EMPTY),
		new HetTileState(13, 8, HetTileState.STATE_EMPTY),
	}),
	SOLUTION_9(new HetTileState[]{
		new HetTileState(5, 10, HetTileState.STATE_MIRROR_MOVABLE, HetTileState.ORIENTATION_SOUTH_EAST),
		new HetTileState(5, 9, HetTileState.STATE_EMPTY),
		new HetTileState(5, 8, HetTileState.STATE_EMPTY),
		new HetTileState(5, 7, HetTileState.STATE_EMPTY),
		new HetTileState(5, 6, HetTileState.STATE_EMPTY),
		new HetTileState(5, 5, HetTileState.STATE_EMPTY),
		new HetTileState(5, 4, HetTileState.STATE_EMPTY),
		new HetTileState(5, 3, HetTileState.STATE_MIRROR_MOVABLE, HetTileState.ORIENTATION_NORTH_EAST),
		new HetTileState(6, 3, HetTileState.STATE_EMPTY),
		new HetTileState(7, 3, HetTileState.STATE_EMPTY),
		new HetTileState(8, 3, HetTileState.STATE_EMPTY),
		new HetTileState(9, 3, HetTileState.STATE_EMPTY),
		new HetTileState(10, 3, HetTileState.STATE_EMPTY),
		new HetTileState(11, 3, HetTileState.STATE_EMPTY),
		new HetTileState(12, 3, HetTileState.STATE_EMPTY),
		new HetTileState(13, 3, HetTileState.STATE_MIRROR_MOVABLE, HetTileState.ORIENTATION_NORTH_WEST),
		new HetTileState(13, 4, HetTileState.STATE_EMPTY),
		new HetTileState(13, 5, HetTileState.STATE_EMPTY),
		new HetTileState(13, 6, HetTileState.STATE_EMPTY),
		new HetTileState(13, 7, HetTileState.STATE_EMPTY),
		new HetTileState(13, 8, HetTileState.STATE_EMPTY),
	}),
	;

	private final HetTileState[] solutionStates;

	@Getter(onMethod_ = @VisibleForTesting)
	private HetSolutionResult lastScore;

	// sum of all conversion scores (number of actions) required
	public HetSolutionResult getScore(HetTileState[][] roomStates)
	{
		HetSolutionResult acc = new HetSolutionResult(true, 0, 0, 0, new ArrayList<>());
		for (HetTileState solutionState : solutionStates)
		{
			// find the matching state
			HetTileState roomState = roomStates[solutionState.getX()][solutionState.getY()];
			if (roomState == null)
			{
				// if the plugin didn't populate this entry then there was no object on that tile
				roomState = new HetTileState(solutionState.getX(), solutionState.getY(), HetTileState.STATE_EMPTY);
			}

			// sanity check the result here, MAX_VALUE indicates it is impossible
			HetSolutionResult score = roomState.conversionScoreTo(solutionState);
			if (!score.isCompletable())
			{
				return (this.lastScore = new HetSolutionResult(false, solutionState.getX(), solutionState.getY(), 0, roomState));
			}

			acc.add(score);
		}

		return (this.lastScore = acc);
	}

}

package com.duckblade.osrs.toa.features.het.beamtimer;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidState;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.ProgressPieComponent;

@Singleton
public class BeamTimerOverlay extends Overlay implements PluginLifecycleComponent
{

	private final OverlayManager overlayManager;
	private final Client client;
	private final BeamTimerTracker beamTimerTracker;

	@Inject
	public BeamTimerOverlay(OverlayManager overlayManager, Client client, BeamTimerTracker beamTimerTracker)
	{
		this.overlayManager = overlayManager;
		this.client = client;
		this.beamTimerTracker = beamTimerTracker;
		setLayer(OverlayLayer.ABOVE_SCENE);
		setPosition(OverlayPosition.DYNAMIC);
	}

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState raidState)
	{
		return beamTimerTracker.isEnabled(config, raidState);
	}

	@Override
	public void startUp()
	{
		overlayManager.add(this);
	}

	@Override
	public void shutDown()
	{
		overlayManager.remove(this);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		GameObject casterStatue = beamTimerTracker.getCasterStatue();
		if (casterStatue == null)
		{
			return null;
		}

		Point canvasPoint = Perspective.localToCanvas(client, casterStatue.getLocalLocation(), client.getPlane());
		if (canvasPoint == null)
		{
			return null;
		}

		double progress = beamTimerTracker.getProgress();
		Color c = progress == 0 ? Color.green : Color.cyan;
		if (progress < 0)
		{
			return null;
		}

		ProgressPieComponent pie = new ProgressPieComponent();
		pie.setPosition(canvasPoint);
		pie.setProgress(1 - progress);
		pie.setBorderColor(c);
		pie.setFill(c);
		return pie.render(graphics);
	}

}

package com.duckblade.osrs.toa.features.het.beamtimer;

import com.duckblade.osrs.toa.TombsOfAmascutConfig;
import com.duckblade.osrs.toa.module.PluginLifecycleComponent;
import com.duckblade.osrs.toa.util.RaidRoom;
import com.duckblade.osrs.toa.util.RaidState;
import com.google.common.collect.ImmutableSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.NpcID;
import net.runelite.api.ObjectID;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GraphicsObjectCreated;
import net.runelite.api.events.NpcChanged;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class BeamTimerTracker implements PluginLifecycleComponent
{

	private static final String CHALLENGE_START_MESSAGE = "Challenge started: Path of Het.";
	private static final String CHALLENGE_COMPLETE_MESSAGE = "Challenge complete: Path of Het.";

	private static final int BEAM_FIRE_RATE_TICKS = 9;

	// at least one of these three is guaranteed to happen
	// there are others for each corner direction
	private static final Set<Integer> BEAM_GRAPHICS_OBJECT_IDS = ImmutableSet.of(
		2114, // horizontal
		2064, // vertical
		2120 // crash (into an object)
	);

	private final EventBus eventBus;
	private final Client client;

	@Getter
	private GameObject casterStatue;

	private int nextFireTick = -1;

	@Override
	public boolean isEnabled(TombsOfAmascutConfig config, RaidState raidState)
	{
		return config.hetBeamTimerEnable() &&
			raidState.getCurrentRoom() == RaidRoom.HET;
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
	}

	@Subscribe
	public void onChatMessage(ChatMessage e)
	{
		if (e.getType() != ChatMessageType.GAMEMESSAGE)
		{
			return;
		}

		if (e.getMessage().equals(CHALLENGE_START_MESSAGE))
		{
			this.nextFireTick = client.getTickCount() + BEAM_FIRE_RATE_TICKS + 1;
		}
		else if (e.getMessage().equals(CHALLENGE_COMPLETE_MESSAGE))
		{
			this.nextFireTick = -1;
		}
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned e)
	{
		if (e.getGameObject().getId() == ObjectID.CASTER_STATUE)
		{
			casterStatue = e.getGameObject();
		}
	}

	@Subscribe
	public void onGraphicsObjectCreated(GraphicsObjectCreated e)
	{
		if (BEAM_GRAPHICS_OBJECT_IDS.contains(e.getGraphicsObject().getId()))
		{
			this.nextFireTick = client.getTickCount() + BEAM_FIRE_RATE_TICKS;
		}
	}

	@Subscribe
	public void onNpcChanged(NpcChanged e)
	{
		if (e.getOld().getId() == NpcID.HETS_SEAL_WEAKENED && e.getNpc().getId() == NpcID.HETS_SEAL_PROTECTED)
		{
			this.nextFireTick = client.getTickCount() + BEAM_FIRE_RATE_TICKS + 1;
		}
		else if (e.getOld().getId() == NpcID.HETS_SEAL_PROTECTED && e.getNpc().getId() == NpcID.HETS_SEAL_WEAKENED)
		{
			this.nextFireTick = -1;
		}
	}

	public double getProgress()
	{
		return (double) (this.nextFireTick - client.getTickCount()) / BEAM_FIRE_RATE_TICKS;
	}

}

