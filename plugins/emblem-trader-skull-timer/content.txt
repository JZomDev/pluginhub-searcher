/*
 * Copyright (c) 2023, Callum Rossiter
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.skulltimer;

import com.google.inject.Provides;
import com.skulltimer.data.CombatInteraction;
import com.skulltimer.enums.CombatStatus;
import com.skulltimer.enums.TimerDurations;
import com.skulltimer.enums.equipment.AttackType;
import com.skulltimer.enums.equipment.ExcludedAnimations;
import com.skulltimer.enums.equipment.WeaponHitDelay;
import com.skulltimer.managers.CombatManager;
import com.skulltimer.managers.EquipmentManager;
import com.skulltimer.managers.LocationManager;
import com.skulltimer.managers.StatusManager;
import com.skulltimer.managers.TimerManager;
import java.time.Instant;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Player;
import net.runelite.api.SkullIcon;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.InteractingChanged;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.OverheadTextChanged;
import net.runelite.api.events.PlayerDespawned;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;

@Slf4j
@PluginDescriptor(
	name = "Skulled Timer",
	description = "Displays a timer when your character receives a skulled status effect."
)
public class SkullTimerPlugin extends Plugin
{
	@Inject
	private Client client;
	@Inject
	private ClientThread clientThread;
	@Inject
	private SkullTimerConfig config;
	@Inject
	private InfoBoxManager infoBoxManager;
	@Inject
	private ItemManager itemManager;

	private StatusManager statusManager;
	private TimerManager timerManager;
	private LocationManager locationManager;
	private EquipmentManager equipmentManager;
	private CombatManager combatManager;

	private int gameTickCounter;
	private boolean hasHitSplatOccurred;

	@Override
	protected void startUp()
	{
		// Initialize the managers and set up the initial state of the plugin
		statusManager = new StatusManager(client);
		timerManager = new TimerManager(this, config, infoBoxManager, itemManager, statusManager);
		locationManager = new LocationManager(client, timerManager);
		equipmentManager = new EquipmentManager(client, timerManager, itemManager);
		combatManager = new CombatManager(client, clientThread, config, timerManager, statusManager, equipmentManager);

		gameTickCounter = 0;
		hasHitSplatOccurred = false;

		// Update the current equipment when the plugin starts
		clientThread.invoke(() -> equipmentManager.updateCurrentEquipment());
	}

	@Override
	protected void shutDown()
	{
		// Remove the timer, save duration remaining
		timerManager.removeTimer(timerManager.getTimer() != null);
	}

	/**
	 * This event is triggered if the player logs in/out, hops worlds, or is teleported to another location (e.g., the Abyss).
	 *
	 * @param gameStateChanged The event that indicates the game state has changed.
	 */
	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		// Check if the player is logged in
		if (gameStateChanged.getGameState() == GameState.LOGGED_IN)
		{
			// If the skull duration is set, there is no active timer, and the player is not in the Abyss
			if (config.skullDuration() != null && timerManager.getTimer() == null && !locationManager.isInAbyss())
			{
				// Add timer with the SkullDuration from the config
				timerManager.addTimer(config.skullDuration());
			}
			// Update current equipment for equipmentManager
			equipmentManager.updateCurrentEquipment();
		}
		// Check if the player is on the login screen or hopping worlds
		else if (gameStateChanged.getGameState() == GameState.LOGIN_SCREEN || gameStateChanged.getGameState() == GameState.HOPPING)
		{
			// Check if timerManager has a timer
			if (timerManager.getTimer() != null)
			{
				// Log the remaining time in minutes
				log.debug("Skull timer paused with {} minutes remaining.", timerManager.getTimer().getRemainingTime().toMinutes());
				// Save the remaining time and remove the timer
				timerManager.removeTimer(true);
			}
			// Clear combat records from combatManager
			combatManager.clearRecords();
		}
	}

	/**
	 * This event is triggered if the player talks to the Emblem Trader.
	 *
	 * @param chatMessage The event that contains the chat message.
	 */
	@Subscribe
	public void onChatMessage(ChatMessage chatMessage)
	{
		//check the message type and content
		if (chatMessage.getType() == ChatMessageType.MESBOX && (chatMessage.getMessage().equalsIgnoreCase("Your PK skull will now last for the full 20 minutes.") ||
		chatMessage.getMessage().equalsIgnoreCase("You are now skulled.")))
		{
			// Add a 20-minute timer when the player receives a skull from the Emblem Trader
			timerManager.addTimer(TimerDurations.TRADER_AND_ITEM_DURATION.getDuration());
		}
	}

	/**
	 * This event is used to remove the skull timer should the icon expire.
	 *
	 * @param gameTick The event that indicates a game tick has occurred.
	 */
	@Subscribe
	public void onGameTick(GameTick gameTick)
	{
		if (combatManager.getAttackRecords().containsKey(gameTickCounter))
		{
			combatManager.onTickOfExpectedHit(gameTickCounter, hasHitSplatOccurred);
			hasHitSplatOccurred = false;
		}

		statusManager.checkSkulledStatus(gameTickCounter);

		gameTickCounter++;

		SkulledTimer skulledTimer = timerManager.getTimer();
		boolean playerHasNoSkullIcon = client.getLocalPlayer().getSkullIcon() == SkullIcon.NONE;

		if (skulledTimer == null)
		{
			return;
		}

		//if the player does not have a skull icon or the timer has expired
		if (Instant.now().isAfter(skulledTimer.getEndTime()))
		{
			log.debug("Removing timer because it has expired. {}", playerHasNoSkullIcon  ? "Player no longer has a skull icon." : "Player still has a skull icon.");
		}
		else if (playerHasNoSkullIcon)
		{
			log.debug("Removing timer because player no longer has a skull icon. Time remaining: {} seconds.", skulledTimer.getRemainingTime().toSeconds());
		}
		else
		{
			return;
		}
		// Remove the timer
		timerManager.removeTimer(false);
	}

	/**
	 * This event is used for item checks.
	 *
	 * @param itemContainerChanged The event that indicates an item container has changed.
	 */
	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged itemContainerChanged)
	{
		// checks to see if the changes made are to the equipment
		if (equipmentManager.getEquipment() != null && itemContainerChanged.getItemContainer() == equipmentManager.getEquipment() &&
			!equipmentManager.getModifiedItemSlotChanges().isEmpty())
		{
			if (client.getLocalPlayer().getSkullIcon() != SkullIcon.NONE)
			{
				equipmentManager.shouldTimerBeStarted(equipmentManager.getModifiedItemSlotChanges());
			}
		}
	}

	/**
	 * This event is used to confirm if the player has been teleported to the Abyss.
	 *
	 * @param overheadTextChanged The event that indicates overhead text has changed.
	 */
	@Subscribe
	public void onOverheadTextChanged(OverheadTextChanged overheadTextChanged)
	{
		if (overheadTextChanged.getActor().getName() != null &&
			overheadTextChanged.getActor().getName().equalsIgnoreCase("Mage of Zamorak") &&
		 	overheadTextChanged.getOverheadText().equalsIgnoreCase("Veniens! Sallakar! Rinnesset!"))
		{
			//sets one of the conditions to add the abyss timer.
			locationManager.setHasBeenTeleportedIntoAbyss(true);
		}
	}

	/**
	 * This event is triggered when an interaction changes in PVP scenarios
	 *
	 * @param interactingChanged The event that indicates an interaction has changed.
	 */
	@Subscribe
	public void onInteractingChanged(InteractingChanged interactingChanged)
	{
		//if the player is not in the wilderness then skip
		if (!locationManager.isInWilderness())
		{
			return;
		}

		Actor target = interactingChanged.getTarget();
		Actor source = interactingChanged.getSource();

		if (!(source instanceof Player))
		{
			return;
		}

		String sourceName = source.getName();

		boolean isTargetLocalPlayer = target instanceof Player && target.getName() != null &&
			target.getName().equalsIgnoreCase(client.getLocalPlayer().getName());

		combatManager.onPlayerInteractionChange(sourceName, isTargetLocalPlayer);
	}

	/**
	 * This event is triggered when a hitsplat is applied to an actor.
	 *
	 * @param hitsplatApplied The event that indicates a hitsplat has been applied.
	 */
	@Subscribe
	public void onHitsplatApplied(HitsplatApplied hitsplatApplied)
	{
		//if the local player is not in the wilderness or if the player hit is the local player
		if (!locationManager.isInWilderness() || hitsplatApplied.getActor() == null ||
			hitsplatApplied.getActor().getName() == null || !(hitsplatApplied.getActor() instanceof Player))
		{
			return;
		}

		Player playerHit = (Player) hitsplatApplied.getActor();
		Player localPlayer = client.getLocalPlayer();

		if (playerHit.getName().equalsIgnoreCase(localPlayer.getName()))
		{
			hasHitSplatOccurred = true;
		}
		//if the player attacks a player in the wilderness, and they have a skull icon
		else if (hitsplatApplied.getHitsplat().isMine())
		{
			combatManager.onTargetHitsplat(playerHit, gameTickCounter);
		}
	}

	/**
	 * This event is triggered when an animation changes for an actor.
	 *
	 * @param animationChanged The event that indicates an animation has changed.
	 */
	@Subscribe
	public void onAnimationChanged(AnimationChanged animationChanged)
	{
		Actor actor = animationChanged.getActor();

		if (!locationManager.isInWilderness() || !(actor instanceof Player) || actor.getName() == null ||
			actor.getName().equalsIgnoreCase(client.getLocalPlayer().getName()) || actor.getAnimation() == ExcludedAnimations.IDLE.getId())
		{
			return;
		}

		Player player = (Player) actor;

		if (ExcludedAnimations.isExcluded(player.getAnimation()))
		{
			log.debug("Animation is excluded. Ending animation processing.");
			return;
		}

		int distance = locationManager.calculateDistanceBetweenPlayers(client.getLocalPlayer(), player);
		WeaponHitDelay weaponHitDelay = equipmentManager.getWeaponHitDelay(player);

		if (weaponHitDelay == null)
		{
			log.warn("Weapon does not exist in weapons table.");
		} else
		{
			int hitDelay = weaponHitDelay.calculateHitDelay(distance);
			AttackType attackType = weaponHitDelay.getAttackType();

			if (combatManager.addExpectedHitTick(player.getName(), gameTickCounter + hitDelay, attackType))
			{
				log.debug("Player {} has attacked from distance {} with a hit delay of {} (current tick: {}, attack type: {}). Attack has been recorded.", player.getName(), distance, hitDelay, gameTickCounter, attackType);
			}
		}
	}

	/**
	 * This event is triggered when a player despawns.
	 *
	 * @param playerDespawned The event that indicates a player has despawned.
	 */
	@Subscribe
	public void onPlayerDespawned(PlayerDespawned playerDespawned)
	{
		Player player = playerDespawned.getPlayer();

		if (player == null || player.getName() == null || !combatManager.getCombatRecords().containsKey(player.getName()))
		{
			return;
		}

		String playerName = player.getName();
		CombatInteraction combatInteraction = combatManager.getCombatRecords().get(playerName);

		if (combatInteraction.getCombatStatus() == CombatStatus.DEAD)
		{
			log.debug("Player {} despawned. Target has been set to dead status.", playerName);
		}
		else if (combatInteraction.isAttacker())
		{
			log.debug("Player {} despawned but was attacker. Player status remains attacker.", playerName);
		}
		else if (locationManager.hasPlayerLoggedOut(player))
		{
			log.debug("Player {} has logged out. Target has been set to logged out.", playerName);
			combatInteraction.setCombatStatus(CombatStatus.LOGGED_OUT);
		}
		else if (combatInteraction.hasRetaliated())
		{
			log.debug("Player {} was in combat. Target has been set to inactive.", playerName);
			combatInteraction.setCombatStatus(CombatStatus.INACTIVE);
		}
		else
		{
			log.debug("Player {} combat status set to unknown.", playerName);
			combatInteraction.setCombatStatus(CombatStatus.UNCERTAIN);
		}
	}

	/**
	 * This event is triggered when an actor dies.
	 *
	 * @param actorDeath The event that indicates an actor has died.
	 */
	@Subscribe
	public void onActorDeath(ActorDeath actorDeath)
	{
		if (actorDeath.getActor() instanceof Player && actorDeath.getActor().getName() != null)
		{
			String playerName = actorDeath.getActor().getName();
			//if the local player is the one who is killed, then remove all attacker logs (as this is reset)
			if (playerName.equalsIgnoreCase(client.getLocalPlayer().getName()))
			{
				log.debug("Player {} has died, resetting combat records.", playerName);
				combatManager.clearRecords();
			//if the player has killed their target, update their status
			}
			else if (combatManager.getCombatRecords().containsKey(playerName))
			{
				log.debug("Player {} has died, updating combat status to dead.", playerName);
				CombatInteraction combatInteraction = combatManager.getCombatRecords().get(playerName);
				if (combatInteraction != null)
				{
					combatInteraction.setCombatStatus(CombatStatus.DEAD);
				}
			}
		}
	}

	/**
	 * This event is triggered when the configuration changes.
	 *
	 * @param configChanged The event that indicates the configuration has changed.
	 */
	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged)
	{
		//config options that should not affect the timer (other plugin configurations or duration for the skull)
		if (configChanged.getGroup() == null || configChanged.getKey() == null ||
			!configChanged.getGroup().equalsIgnoreCase("Skull Timer") || configChanged.getKey().equalsIgnoreCase("skullDuration"))
		{
			return;
		}

		if (timerManager.getTimer() != null && client.getGameState() == GameState.LOGGED_IN)
		{
			timerManager.addTimer(timerManager.getTimer().getRemainingTime());
		}
	}

	/**
	 * Provides the configuration for the Skull Timer plugin.
	 *
	 * @param configManager The configuration manager.
	 * @return The Skull Timer configuration.
	 */
	@Provides
	SkullTimerConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(SkullTimerConfig.class);
	}
}

/*
 * Copyright (c) 2023, Callum Rossiter
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.skulltimer.data;

import com.skulltimer.enums.equipment.AttackType;

import java.util.Objects;
import lombok.Data;

@Data
public class ExpectedHit
{
	private final String playerName;
	private final AttackType attackType;

	/**
	 * A boolean to check if the weapon type used to attack
	 * @return {@code true} if the attack type can splash (i.e. magic). Otherwise, returns {@code false}.
	 */
	public boolean doesApplySplash()
	{
		return attackType == AttackType.MAGIC;
	}

	@Override
	public boolean equals(Object o)
	{
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;

		ExpectedHit that = (ExpectedHit) o;
		return Objects.equals(playerName, that.playerName);
	}

	@Override
	public int hashCode()
	{
		return Objects.hash(playerName);
	}
}

/*
 * Copyright (c) 2023, Callum Rossiter
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.skulltimer.data;

import com.skulltimer.enums.CombatStatus;
import lombok.Data;

/**
 * An object representing a record of a combat (a player that the local player has attacked/been attacked by) interaction with the local player.
 */
@Data
public class CombatInteraction
{
	private CombatStatus combatStatus = CombatStatus.ATTACKED;

	/**
	 * A method to determine if the player has retaliated against the local player.
	 * @return {@code true} if the players {@link CombatStatus} is either {@code RETALIATED}, {@code INACTIVE} or
	 * {@code ATTACKER}. Otherwise, returns {@code false}.
	 */
	public boolean hasRetaliated()
	{
		return combatStatus == CombatStatus.RETALIATED ||
			combatStatus == CombatStatus.INACTIVE ||
			combatStatus == CombatStatus.ATTACKER;
	}

	/**
	 * A method to determine if the player was the instigator of the combat interaction.
	 * @return {@code true} if the player started the fight. Otherwise, returns {@code false}.
	 */
	public boolean isAttacker()
	{
		return combatStatus == CombatStatus.ATTACKER;
	}
}

/*
 * Copyright (c) 2023, Callum Rossiter
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.skulltimer;

import java.awt.Color;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.time.Duration;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import javax.imageio.ImageIO;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ItemID;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.Timer;

@Slf4j
public class SkulledTimer extends Timer
{
	private final ItemManager itemManager;
	private final Color textColour;
	private final Color warningColour;

	public SkulledTimer(Duration duration, ItemManager itemManager, SkullTimerConfig skullTimerConfig, SkullTimerPlugin plugin)
	{
		super(duration.toMillis(), ChronoUnit.MILLIS, itemManager.getImage(ItemID.SKULL), plugin);
		this.itemManager = itemManager;

		super.setImage(getTimerIcon());

		String tooltipText = "Time left until your character becomes unskulled.";

		this.textColour = skullTimerConfig.textColour();
		this.warningColour = skullTimerConfig.warningTextColour();
		this.setTooltip(tooltipText);

	}

	public Duration getRemainingTime()
	{
		return Duration.between(Instant.now(), getEndTime());
	}

	public Color getTextColor()
	{
		if (getRemainingTime().getSeconds() <= 30)
		{
			return warningColour;
		}
		else
		{
			return textColour;
		}
	}

	public BufferedImage getTimerIcon()
	{
		try (InputStream stream = SkulledTimer.class.getResourceAsStream("/timericon.png"))
		{
			if (stream == null)
			{
				log.debug("Stream is null, using default icon.");
				return itemManager.getImage(ItemID.SKULL);
			}
			return ImageIO.read(stream);
		} catch (IOException e)
		{
			log.debug("Cannot find timer icon, using default.");
			return itemManager.getImage(ItemID.SKULL);
		}
	}
}

/*
 * Copyright (c) 2023, Callum Rossiter
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.skulltimer.enums;

import java.time.Duration;
import lombok.Getter;

/**
 * An enumeration of skull events that provide different timers.
 */
@Getter
public enum TimerDurations
{
	TRADER_AND_ITEM_DURATION(Duration.ofMinutes(20)),
	ABYSS_DURATION(Duration.ofMinutes(10)),
	PVP_DURATION(Duration.ofMinutes(20));

	private final Duration duration;

	TimerDurations(Duration duration)
	{
		this.duration = duration;
	}
}

/*
 * Copyright (c) 2023, Callum Rossiter
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.skulltimer.enums.equipment;

import java.util.HashMap;
import java.util.Map;
import lombok.Getter;
import net.runelite.api.ItemID;

/**
 * A list of weapons that can be used by players. This list contains the ItemID, the animations the weapon uses special attacks (if required) and the hit delays for the special attack.
 * All of this information and ordering comes from the <a href="https://oldschool.runescape.wiki">Old School RuneScape Wiki</a>, specifically from this <a href="https://oldschool.runescape.wiki/w/Weapons/Types">page</a>.
 */
@Getter
public enum Weapons
{
	/*MELEE*/
	//TWO-HANDED SWORDS
	_3RD_AGE_LONGSWORD(ItemID._3RD_AGE_LONGSWORD, WeaponHitDelay.MELEE_STANDARD),
	ADAMANT_2H_SWORD(ItemID.ADAMANT_2H_SWORD, WeaponHitDelay.MELEE_STANDARD),
	ANCIENT_GODSWORD(ItemID.ANCIENT_GODSWORD, WeaponHitDelay.MELEE_STANDARD),
	ARMADYL_GODSWORD(ItemID.ARMADYL_GODSWORD, WeaponHitDelay.MELEE_STANDARD),
	ARMADYL_GODSWORD_OR(ItemID.ARMADYL_GODSWORD_OR, WeaponHitDelay.MELEE_STANDARD),
	ARMADYL_GODSWORD_DEADMAN(ItemID.ARMADYL_GODSWORD_DEADMAN, WeaponHitDelay.MELEE_STANDARD),
	BANDOS_GODSWORD(ItemID.BANDOS_GODSWORD, WeaponHitDelay.MELEE_STANDARD),
	BANDOS_GODSWORD_OR(ItemID.BANDOS_GODSWORD_OR, WeaponHitDelay.MELEE_STANDARD),
	BLACK_2H_SWORD(ItemID.BLACK_2H_SWORD, WeaponHitDelay.MELEE_STANDARD),
	BRONZE_2H_SWORD(ItemID.BRONZE_2H_SWORD, WeaponHitDelay.MELEE_STANDARD),
	COLOSSAL_BLADE(ItemID.COLOSSAL_BLADE, WeaponHitDelay.MELEE_STANDARD),
	CORRUPTED_ARMADYL_GODSWORD(ItemID.CORRUPTED_ARMADYL_GODSWORD, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_2H_SWORD(ItemID.DRAGON_2H_SWORD, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_2H_SWORD_CR(ItemID.DRAGON_2H_SWORD_CR, WeaponHitDelay.MELEE_STANDARD),
	GIANT_BRONZE_DAGGER(ItemID.GIANT_BRONZE_DAGGER, WeaponHitDelay.MELEE_STANDARD),
	GILDED_2H_SWORD(ItemID.GILDED_2H_SWORD, WeaponHitDelay.MELEE_STANDARD),
	IRON_2H_SWORD(ItemID.IRON_2H_SWORD, WeaponHitDelay.MELEE_STANDARD),
	MITHRIL_2H_SWORD(ItemID.MITHRIL_2H_SWORD, WeaponHitDelay.MELEE_STANDARD),
	RUNE_2H_SWORD(ItemID.RUNE_2H_SWORD, WeaponHitDelay.MELEE_STANDARD),
	SARADOMIN_GODSWORD(ItemID.SARADOMIN_GODSWORD, WeaponHitDelay.MELEE_STANDARD),
	SARADOMIN_GODSWORD_OR(ItemID.SARADOMIN_GODSWORD_OR, WeaponHitDelay.MELEE_STANDARD),
	SARADOMIN_SWORD(ItemID.SARADOMIN_SWORD, WeaponHitDelay.MELEE_STANDARD),
	SARADOMIN_BLESSED_SWORD(ItemID.SARADOMINS_BLESSED_SWORD, WeaponHitDelay.MELEE_STANDARD),
	SHADOW_SWORD(ItemID.SHADOW_SWORD, WeaponHitDelay.MELEE_STANDARD),
	SPATULA(ItemID.SPATULA, WeaponHitDelay.MELEE_STANDARD),
	STEEL_2H_SWORD(ItemID.STEEL_2H_SWORD, WeaponHitDelay.MELEE_STANDARD),
	THE_DOGSWORD(ItemID.THE_DOGSWORD, WeaponHitDelay.MELEE_STANDARD),
	WHITE_2H_SWORD(ItemID.WHITE_2H_SWORD, WeaponHitDelay.MELEE_STANDARD),
	ZAMORAK_GODSWORD(ItemID.ZAMORAK_GODSWORD, WeaponHitDelay.MELEE_STANDARD),
	ZAMORAK_GODSWORD_OR(ItemID.ZAMORAK_GODSWORD_OR, WeaponHitDelay.MELEE_STANDARD),

	//AXES AND BATTLEAXES
	_3RD_AGE_AXE(ItemID._3RD_AGE_AXE, WeaponHitDelay.MELEE_STANDARD),
	_3RD_AGE_FELLING_AXE(ItemID._3RD_AGE_FELLING_AXE, WeaponHitDelay.MELEE_STANDARD),
	ADAMANT_AXE(ItemID.ADAMANT_AXE, WeaponHitDelay.MELEE_STANDARD),
	ADAMANT_FELLING_AXE(ItemID.ADAMANT_FELLING_AXE, WeaponHitDelay.MELEE_STANDARD),
	ADAMANT_BATTLEAXE(ItemID.ADAMANT_BATTLEAXE, WeaponHitDelay.MELEE_STANDARD),
	BLACK_AXE(ItemID.BLACK_AXE, WeaponHitDelay.MELEE_STANDARD),
	BLACK_BATTLE_AXE(ItemID.BLACK_BATTLEAXE, WeaponHitDelay.MELEE_STANDARD),
	BLACK_FELLING_AXE(ItemID.BLACK_FELLING_AXE, WeaponHitDelay.MELEE_STANDARD),
	BLESSED_AXE(ItemID.BLESSED_AXE, WeaponHitDelay.MELEE_STANDARD),
	BRONZE_AXE(ItemID.BRONZE_AXE, WeaponHitDelay.MELEE_STANDARD),
	BRONZE_BATTLEAXE(ItemID.BRONZE_BATTLEAXE, WeaponHitDelay.MELEE_STANDARD),
	BRONZE_FELLING_AXE(ItemID.BRONZE_FELLING_AXE, WeaponHitDelay.MELEE_STANDARD),
	CRYSTAL_AXE(ItemID.CRYSTAL_AXE, WeaponHitDelay.MELEE_STANDARD),
	CRYSTAL_FELLING_AXE(ItemID.CRYSTAL_FELLING_AXE, WeaponHitDelay.MELEE_STANDARD),
	DHAROKS_GREAT_AXE(ItemID.DHAROKS_GREATAXE, WeaponHitDelay.MELEE_STANDARD),
	DHAROKS_GREATAXE_25516(ItemID.DHAROKS_GREATAXE_25516, WeaponHitDelay.MELEE_STANDARD),
	DHAROKS_GREATAXE_100(ItemID.DHAROKS_GREATAXE_100, WeaponHitDelay.MELEE_STANDARD),
	DHAROKS_GREATAXE_75(ItemID.DHAROKS_GREATAXE_75, WeaponHitDelay.MELEE_STANDARD),
	DHAROKS_GREATAXE_50(ItemID.DHAROKS_GREATAXE_50, WeaponHitDelay.MELEE_STANDARD),
	DHAROKS_GREATAXE_25(ItemID.DHAROKS_GREATAXE_25, WeaponHitDelay.MELEE_STANDARD),
	DHAROKS_GREATAXE_0(ItemID.DHAROKS_GREATAXE_0, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_AXE(ItemID.DRAGON_AXE, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_AXE_OR(ItemID.DRAGON_AXE_OR, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_BATTLEAXE(ItemID.DRAGON_BATTLEAXE, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_BATTLEAXE_CR(ItemID.DRAGON_BATTLEAXE_CR, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_FELLING_AXE(ItemID.DRAGON_FELLING_AXE, WeaponHitDelay.MELEE_STANDARD),
	ECHO_AXE(ItemID.ECHO_AXE, WeaponHitDelay.MELEE_STANDARD),
	GILDED_AXE(ItemID.GILDED_AXE, WeaponHitDelay.MELEE_STANDARD),
	INFERNAL_AXE(ItemID.INFERNAL_AXE, WeaponHitDelay.MELEE_STANDARD),
	INFERNAL_AXE_OR(ItemID.INFERNAL_AXE_OR, WeaponHitDelay.MELEE_STANDARD),
	IRON_AXE(ItemID.IRON_AXE, WeaponHitDelay.MELEE_STANDARD),
	IRON_BATTLEAXE(ItemID.IRON_BATTLEAXE, WeaponHitDelay.MELEE_STANDARD),
	IRON_FELLING_AXE(ItemID.IRON_FELLING_AXE, WeaponHitDelay.MELEE_STANDARD),
	LEAFBLADED_BATTLEAXE(ItemID.LEAFBLADED_BATTLEAXE, WeaponHitDelay.MELEE_STANDARD),
	MITHRIL_AXE(ItemID.MITHRIL_AXE, WeaponHitDelay.MELEE_STANDARD),
	MITHRIL_FELLING_AXE(ItemID.MITHRIL_FELLING_AXE, WeaponHitDelay.MELEE_STANDARD),
	MITHRIL_BATTLEAXE(ItemID.MITHRIL_BATTLEAXE, WeaponHitDelay.MELEE_STANDARD),
	RUNE_AXE(ItemID.RUNE_AXE, WeaponHitDelay.MELEE_STANDARD),
	RUNE_BATTLE_AXE(ItemID.RUNE_BATTLEAXE, WeaponHitDelay.MELEE_STANDARD),
	RUNE_FELLING_AXE(ItemID.RUNE_FELLING_AXE, WeaponHitDelay.MELEE_STANDARD),
	SOULREAPER_AXE(ItemID.SOULREAPER_AXE, WeaponHitDelay.MELEE_STANDARD),
	STEEL_AXE(ItemID.STEEL_AXE, WeaponHitDelay.MELEE_STANDARD),
	STEEL_FELLING_AXE(ItemID.STEEL_FELLING_AXE, WeaponHitDelay.MELEE_STANDARD),
	STEEL_BATTLEAXE(ItemID.STEEL_BATTLEAXE, WeaponHitDelay.MELEE_STANDARD),
	WHITE_BATTLEAXE(ItemID.WHITE_BATTLEAXE, WeaponHitDelay.MELEE_STANDARD),
	ZOMBIE_AXE(ItemID.ZOMBIE_AXE, WeaponHitDelay.MELEE_STANDARD),

	//BANNERS
	BANNER(ItemID.BANNER, WeaponHitDelay.MELEE_STANDARD),
	BANNER_8652(ItemID.BANNER_8652, WeaponHitDelay.MELEE_STANDARD),
	BANNER_8654(ItemID.BANNER_8654, WeaponHitDelay.MELEE_STANDARD),
	BANNER_8656(ItemID.BANNER_8656, WeaponHitDelay.MELEE_STANDARD),
	BANNER_8658(ItemID.BANNER_8658, WeaponHitDelay.MELEE_STANDARD),
	BANNER_8660(ItemID.BANNER_8660, WeaponHitDelay.MELEE_STANDARD),
	BANNER_8662(ItemID.BANNER_8662, WeaponHitDelay.MELEE_STANDARD),
	BANNER_8664(ItemID.BANNER_8664, WeaponHitDelay.MELEE_STANDARD),
	BANNER_8666(ItemID.BANNER_8666, WeaponHitDelay.MELEE_STANDARD),
	BANNER_8668(ItemID.BANNER_8668, WeaponHitDelay.MELEE_STANDARD),
	BANNER_8670(ItemID.BANNER_8670, WeaponHitDelay.MELEE_STANDARD),
	BANNER_8672(ItemID.BANNER_8672, WeaponHitDelay.MELEE_STANDARD),
	BANNER_8674(ItemID.BANNER_8674, WeaponHitDelay.MELEE_STANDARD),
	BANNER_8676(ItemID.BANNER_8676, WeaponHitDelay.MELEE_STANDARD),
	BANNER_8678(ItemID.BANNER_8678, WeaponHitDelay.MELEE_STANDARD),
	BANNER_8680(ItemID.BANNER_8680, WeaponHitDelay.MELEE_STANDARD),
	BRONZE_FIST_FLAG(ItemID.BRONZE_FIST_FLAG, WeaponHitDelay.MELEE_STANDARD),
	CLAN_VEXILLUM(ItemID.CLAN_VEXILLUM, WeaponHitDelay.MELEE_STANDARD),
	CUTTHROAT_FLAG(ItemID.CUTTHROAT_FLAG, WeaponHitDelay.MELEE_STANDARD),
	GILDED_SMILE_FLAG(ItemID.GILDED_SMILE_FLAG, WeaponHitDelay.MELEE_STANDARD),
	GREEN_BANNER(ItemID.GREEN_BANNER, WeaponHitDelay.MELEE_STANDARD),
	LUCKY_SHOT_FLAG(ItemID.LUCKY_SHOT_FLAG, WeaponHitDelay.MELEE_STANDARD),
	PHASMATYS_FLAG(ItemID.PHASMATYS_FLAG, WeaponHitDelay.MELEE_STANDARD),
	PROTEST_BANNER(ItemID.PROTEST_BANNER, WeaponHitDelay.MELEE_STANDARD),
	RAGING_ECHOS_BANNER(ItemID.RAGING_ECHOES_BANNER, WeaponHitDelay.MELEE_STANDARD),
	SARADOMIN_BANNER(ItemID.SARADOMIN_BANNER, WeaponHitDelay.MELEE_STANDARD),
	SHATTERED_BANNER(ItemID.SHATTERED_BANNER, WeaponHitDelay.MELEE_STANDARD),
	TRAILBLAZER_BANNER(ItemID.TRAILBLAZER_BANNER, WeaponHitDelay.MELEE_STANDARD),
	TRAILBLAZER_RELOADED_BANNER(ItemID.TRAILBLAZER_RELOADED_BANNER, WeaponHitDelay.MELEE_STANDARD),
	TREASURE_FLAG(ItemID.TREASURE_FLAG, WeaponHitDelay.MELEE_STANDARD),
	TWISTED_BANNER(ItemID.TWISTED_BANNER, WeaponHitDelay.MELEE_STANDARD),
	ZAMORAK_BANNER(ItemID.ZAMORAK_BANNER, WeaponHitDelay.MELEE_STANDARD),

	//BLUNT
	_10TH_BIRTHDAY_BANNER(ItemID._10TH_BIRTHDAY_BALLOONS, WeaponHitDelay.MELEE_STANDARD),
	_24_CARAT_SWORD(ItemID._24CARAT_SWORD, WeaponHitDelay.MELEE_STANDARD),
	ADAMANT_STAFF_OF_COLLECTION(ItemID.ADAMANT_STAFF_OF_COLLECTION, WeaponHitDelay.MELEE_STANDARD),
	ADAMANT_WARHAMMER(ItemID.ADAMANT_WARHAMMER, WeaponHitDelay.MELEE_STANDARD),
	ASSORTED_FLOWERS(ItemID.ASSORTED_FLOWERS, WeaponHitDelay.MELEE_STANDARD),
	BARRONITE_MACE(ItemID.BARRONITE_MACE, WeaponHitDelay.MELEE_STANDARD),
	BIRTHDAY_BALLOONS(ItemID.BIRTHDAY_BALLOONS, WeaponHitDelay.MELEE_STANDARD),
	BIRTHDAY_CAKE(ItemID.BIRTHDAY_CAKE, WeaponHitDelay.MELEE_STANDARD),
	BLACK_FLOWERS(ItemID.BLACK_FLOWERS, WeaponHitDelay.MELEE_STANDARD),
	BLACK_STAFF_OF_COLLECTION(ItemID.BLACK_STAFF_OF_COLLECTION, WeaponHitDelay.MELEE_STANDARD),
	BLACK_WARHAMMER(ItemID.BLACK_WARHAMMER, WeaponHitDelay.MELEE_STANDARD),
	BLUE_FLOWERS(ItemID.BLUE_FLOWERS, WeaponHitDelay.MELEE_STANDARD),
	BONE_CLUB(ItemID.BONE_CLUB, WeaponHitDelay.MELEE_STANDARD),
	BRONZE_STAFF_OF_COLLECTION(ItemID.BRONZE_STAFF_OF_COLLECTION, WeaponHitDelay.MELEE_STANDARD),
	BRONZE_WARHAMMER(ItemID.BRONZE_WARHAMMER, WeaponHitDelay.MELEE_STANDARD),
	CANDY_CANE(ItemID.CANDY_CANE, WeaponHitDelay.MELEE_STANDARD),
	CARROT_SWORD(ItemID.CARROT_SWORD, WeaponHitDelay.MELEE_STANDARD),
	CLUELESS_SCROLL(ItemID.CLUELESS_SCROLL, WeaponHitDelay.MELEE_STANDARD),
	CRIER_BELL(ItemID.CRIER_BELL, WeaponHitDelay.MELEE_STANDARD),
	CURSED_BANANA(ItemID.CURSED_BANANA, WeaponHitDelay.MELEE_STANDARD),
	CURSED_GOBLIN_HAMMER(ItemID.CURSED_GOBLIN_HAMMER, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_CANDLE_DAGGER(ItemID.DRAGON_CANDLE_DAGGER, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_STAFF_OF_COLLECTION(ItemID.DRAGON_STAFF_OF_COLLECTION, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_WARHAMMER(ItemID.DRAGON_WARHAMMER, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_WARHAMMER_CR(ItemID.DRAGON_WARHAMMER_CR, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_WARHAMMER_OR(ItemID.DRAGON_WARHAMMER_OR, WeaponHitDelay.MELEE_STANDARD),
	DRAMEN_STAFF(ItemID.DRAMEN_STAFF, WeaponHitDelay.MELEE_STANDARD),
	EASTER_BASKET(ItemID.EASTER_BASKET, WeaponHitDelay.MELEE_STANDARD),
	EEK(ItemID.EEK, WeaponHitDelay.MELEE_STANDARD),
	ELDER_MAUL(ItemID.ELDER_MAUL, WeaponHitDelay.MELEE_STANDARD),
	ELDER_MAUL_OR(ItemID.ELDER_MAUL_OR, WeaponHitDelay.MELEE_STANDARD),
	FINE_MESH_NET(ItemID.FINE_MESH_NET, WeaponHitDelay.MELEE_STANDARD),
	FRYING_PAN(ItemID.FRYING_PAN, WeaponHitDelay.MELEE_STANDARD),
	GADDERHAMMER(ItemID.GADDERHAMMER, WeaponHitDelay.MELEE_STANDARD),
	GIANT_BOULDER(ItemID.GIANT_BOULDER, WeaponHitDelay.MELEE_STANDARD),
	GIANT_EASTER_EGG(ItemID.GIANT_EASTER_EGG, WeaponHitDelay.MELEE_STANDARD),
	GIANT_PRESENT(ItemID.GIANT_PRESENT, WeaponHitDelay.MELEE_STANDARD),
	GILDED_SPADE(ItemID.GILDED_SPADE, WeaponHitDelay.MELEE_STANDARD),
	GILDED_STAFF_OF_COLLECTION(ItemID.GILDED_STAFF_OF_COLLECTION, WeaponHitDelay.MELEE_STANDARD),
	GOLDEN_TENCH(ItemID.GOLDEN_TENCH, WeaponHitDelay.MELEE_STANDARD),
	GRANITE_HAMMER(ItemID.GRANITE_HAMMER, WeaponHitDelay.MELEE_STANDARD),
	GRANITE_MAUL(ItemID.GRANITE_MAUL, WeaponHitDelay.MELEE_STANDARD),
	GRANITE_MAUL_ONE(ItemID.GRANITE_MAUL_24227, WeaponHitDelay.MELEE_STANDARD),
	GRANITE_MAUL_TWO(ItemID.GRANITE_MAUL_12848, WeaponHitDelay.MELEE_STANDARD),
	GRANITE_MAUL_THREE(ItemID.GRANITE_MAUL_24225, WeaponHitDelay.MELEE_STANDARD),
	GRANITE_MAUL_FOUR(ItemID.GRANITE_MAUL_20557, WeaponHitDelay.MELEE_STANDARD),
	HALLOWED_HAMMER(ItemID.HALLOWED_HAMMER, WeaponHitDelay.MELEE_STANDARD),
	HAM_JOINT(ItemID.HAM_JOINT, WeaponHitDelay.MELEE_STANDARD),
	HAND_FAN(ItemID.HAND_FAN, WeaponHitDelay.MELEE_STANDARD),
	HAUNTED_WINE_BOTTLE(ItemID.HAUNTED_WINE_BOTTLE, WeaponHitDelay.MELEE_STANDARD),
	HEAVY_CASKET(ItemID.HEAVY_CASKET, WeaponHitDelay.MELEE_STANDARD),
	HILL_GIANT_CLUB(ItemID.HILL_GIANT_CLUB, WeaponHitDelay.MELEE_STANDARD),
	HUNTING_KNIFE(ItemID.HUNTING_KNIFE, WeaponHitDelay.MELEE_STANDARD),
	IMCANDO_HAMMER(ItemID.IMCANDO_HAMMER, WeaponHitDelay.MELEE_STANDARD),
	IRON_STAFF_OF_COLLECTION(ItemID.IRON_STAFF_OF_COLLECTION, WeaponHitDelay.MELEE_STANDARD),
	IRON_WARHAMMER(ItemID.IRON_WARHAMMER, WeaponHitDelay.MELEE_STANDARD),
	LARGE_SPADE(ItemID.LARGE_SPADE, WeaponHitDelay.MELEE_STANDARD),
	LOVE_CROSSBOW(ItemID.LOVE_CROSSBOW, WeaponHitDelay.MELEE_STANDARD),
	MAPLE_BLACKJACK(ItemID.MAPLE_BLACKJACK, WeaponHitDelay.MELEE_STANDARD),
	MAPLE_BLACKJACK_D(ItemID.MAPLE_BLACKJACKD, WeaponHitDelay.MELEE_STANDARD),
	MAPLE_BLACKJACK_O(ItemID.MAPLE_BLACKJACKO, WeaponHitDelay.MELEE_STANDARD),
	MEAT_TENDERISER(ItemID.MEAT_TENDERISER, WeaponHitDelay.MELEE_STANDARD),
	MITHRIL_STAFF_OF_COLLECTION(ItemID.MITHRIL_STAFF_OF_COLLECTION, WeaponHitDelay.MELEE_STANDARD),
	MIXED_FLOWERS(ItemID.MIXED_FLOWERS, WeaponHitDelay.MELEE_STANDARD),
	MOUSE_TOY(ItemID.MOUSE_TOY, WeaponHitDelay.MELEE_STANDARD),
	MYSTIC_CARDS(ItemID.MYSTIC_CARDS, WeaponHitDelay.MELEE_STANDARD),
	NUNCHAKU(ItemID.NUNCHAKU, WeaponHitDelay.MELEE_STANDARD),
	NUTCRACKER_STAFF_SWEET(ItemID.SWEET_NUTCRACKER_STAFF, WeaponHitDelay.MELEE_STANDARD),
	NUTCRACKER_STAFF_FESTIVE(ItemID.FESTIVE_NUTCRACKER_STAFF, WeaponHitDelay.MELEE_STANDARD),
	OAK_BLACKJACK(ItemID.OAK_BLACKJACK, WeaponHitDelay.MELEE_STANDARD),
	OAK_BLACKJACK_D(ItemID.OAK_BLACKJACKD, WeaponHitDelay.MELEE_STANDARD),
	OAK_BLACKJACK_O(ItemID.OAK_BLACKJACKO, WeaponHitDelay.MELEE_STANDARD),
	ORANGE_FLOWERS(ItemID.ORANGE_FLOWERS, WeaponHitDelay.MELEE_STANDARD),
	PROP_SWORD(ItemID.PROP_SWORD, WeaponHitDelay.MELEE_STANDARD),
	PURPLE_FLOWERS(ItemID.PURPLE_FLOWERS, WeaponHitDelay.MELEE_STANDARD),
	RAGING_ECHOS_ADAMANT_TROPHY(ItemID.RAGING_ECHOES_ADAMANT_TROPHY, WeaponHitDelay.MELEE_STANDARD),
	RAGING_ECHOS_DRAGON_TROPHY(ItemID.RAGING_ECHOES_DRAGON_TROPHY, WeaponHitDelay.MELEE_STANDARD),
	RAGING_ECHOS_RUNE_TROPHY(ItemID.RAGING_ECHOES_RUNE_TROPHY, WeaponHitDelay.MELEE_STANDARD),
	RAT_POLE(ItemID.RAT_POLE, WeaponHitDelay.MELEE_STANDARD),
	RED_FLOWERS(ItemID.RED_FLOWERS, WeaponHitDelay.MELEE_STANDARD),
	ROLLING_PIN(ItemID.ROLLING_PIN, WeaponHitDelay.MELEE_STANDARD),
	RUBBER_CHICKEN(ItemID.RUBBER_CHICKEN, WeaponHitDelay.MELEE_STANDARD),
	RUNE_STAFF_OF_COLLECTION(ItemID.RUNE_STAFF_OF_COLLECTION, WeaponHitDelay.MELEE_STANDARD),
	RUNE_WARHAMMER(ItemID.RUNE_WARHAMMER, WeaponHitDelay.MELEE_STANDARD),
	SEVERED_LEG(ItemID.SEVERED_LEG, WeaponHitDelay.MELEE_STANDARD),
	SHATTERED_RELICS_ADAMANT_TROPHY(ItemID.SHATTERED_RELICS_ADAMANT_TROPHY, WeaponHitDelay.MELEE_STANDARD),
	SHATTERED_RELICS_BRONZE_TROPHY(ItemID.SHATTERED_RELICS_BRONZE_TROPHY, WeaponHitDelay.MELEE_STANDARD),
	SHATTERED_RELICS_DRAGON_TROPHY(ItemID.SHATTERED_RELICS_DRAGON_TROPHY, WeaponHitDelay.MELEE_STANDARD),
	SHATTERED_RELICS_IRON_TROPHY(ItemID.SHATTERED_RELICS_IRON_TROPHY, WeaponHitDelay.MELEE_STANDARD),
	SHATTERED_RELICS_MITHRIL_TROPHY(ItemID.SHATTERED_RELICS_MITHRIL_TROPHY, WeaponHitDelay.MELEE_STANDARD),
	SHATTERED_RELICS_RUNE_TROPHY(ItemID.SHATTERED_RELICS_RUNE_TROPHY, WeaponHitDelay.MELEE_STANDARD),
	SHATTERED_RELICS_STEEL_TROPHY(ItemID.SHATTERED_RELICS_STEEL_TROPHY, WeaponHitDelay.MELEE_STANDARD),
	SKELETON_LANTERN(ItemID.SKELETON_LANTERN, WeaponHitDelay.MELEE_STANDARD),
	STALE_BAGUETTE(ItemID.STALE_BAGUETTE, WeaponHitDelay.MELEE_STANDARD),
	STATIUSS_WARHAMMER(ItemID.STATIUSS_WARHAMMER, WeaponHitDelay.MELEE_STANDARD),
	STATIUSS_WARHAMMER_BH(ItemID.STATIUSS_WARHAMMER_BH, WeaponHitDelay.MELEE_STANDARD),
	STEEL_STAFF_OF_COLLECTION(ItemID.STEEL_STAFF_OF_COLLECTION, WeaponHitDelay.MELEE_STANDARD),
	TORAGS_HAMMERS(ItemID.TORAGS_HAMMERS, WeaponHitDelay.MELEE_STANDARD),
	TORAGS_HAMMERS_100(ItemID.TORAGS_HAMMERS_100, WeaponHitDelay.MELEE_STANDARD),
	TORAGS_HAMMERS_75(ItemID.TORAGS_HAMMERS_75, WeaponHitDelay.MELEE_STANDARD),
	TORAGS_HAMMERS_50(ItemID.TORAGS_HAMMERS_50, WeaponHitDelay.MELEE_STANDARD),
	TORAGS_HAMMERS_25(ItemID.TORAGS_HAMMERS_25, WeaponHitDelay.MELEE_STANDARD),
	TORAGS_HAMMERS_0(ItemID.TORAGS_HAMMERS_0, WeaponHitDelay.MELEE_STANDARD),
	TRAILBLAZER_ADAMANT_TROPHY(ItemID.TRAILBLAZER_ADAMANT_TROPHY, WeaponHitDelay.MELEE_STANDARD),
	TRAILBLAZER_BRONZE_TROPHY(ItemID.TRAILBLAZER_BRONZE_TROPHY, WeaponHitDelay.MELEE_STANDARD),
	TRAILBLAZER_DRAGON_TROPHY(ItemID.TRAILBLAZER_DRAGON_TROPHY, WeaponHitDelay.MELEE_STANDARD),
	TRAILBLAZER_IRON_TROPHY(ItemID.TRAILBLAZER_IRON_TROPHY, WeaponHitDelay.MELEE_STANDARD),
	TRAILBLAZER_MITHRIL_TROPHY(ItemID.TRAILBLAZER_MITHRIL_TROPHY, WeaponHitDelay.MELEE_STANDARD),
	TRAILBLAZER_RUNE_TROPHY(ItemID.TRAILBLAZER_RUNE_TROPHY, WeaponHitDelay.MELEE_STANDARD),
	TRAILBLAZER_STEEL_TROPHY(ItemID.TRAILBLAZER_STEEL_TROPHY, WeaponHitDelay.MELEE_STANDARD),
	TRAILBLAZER_RELOADED_ADAMANT_TROPHY(ItemID.TRAILBLAZER_RELOADED_ADAMANT_TROPHY, WeaponHitDelay.MELEE_STANDARD),
	TRAILBLAZER_RELOADED_RUNE_TROPHY(ItemID.TRAILBLAZER_RELOADED_RUNE_TROPHY, WeaponHitDelay.MELEE_STANDARD),
	TRAILBLAZER_RELOADED_DRAGON_TROPHY(ItemID.TRAILBLAZER_RELOADED_DRAGON_TROPHY, WeaponHitDelay.MELEE_STANDARD),
	TROLLWEISS(ItemID.TROLLWEISS, WeaponHitDelay.MELEE_STANDARD),
	TWISTED_ADAMANT_TROPHY(ItemID.TWISTED_ADAMANT_TROPHY, WeaponHitDelay.MELEE_STANDARD),
	TWISTED_BRONZE_TROPHY(ItemID.TWISTED_BRONZE_TROPHY, WeaponHitDelay.MELEE_STANDARD),
	TWISTED_DRAGON_TROPHY(ItemID.TWISTED_DRAGON_TROPHY, WeaponHitDelay.MELEE_STANDARD),
	TWISTED_IRON_TROPHY(ItemID.TWISTED_IRON_TROPHY, WeaponHitDelay.MELEE_STANDARD),
	TWISTED_MITHRIL_TROPHY(ItemID.TWISTED_MITHRIL_TROPHY, WeaponHitDelay.MELEE_STANDARD),
	TWISTED_RUNE_TROPHY(ItemID.TWISTED_RUNE_TROPHY, WeaponHitDelay.MELEE_STANDARD),
	TWISTED_STEEL_TROPHY(ItemID.TWISTED_STEEL_TROPHY, WeaponHitDelay.MELEE_STANDARD),
	TZHAAR_KET_EM(ItemID.TZHAARKETEM, WeaponHitDelay.MELEE_STANDARD),
	TZHAAR_KET_OM(ItemID.TZHAARKETOM, WeaponHitDelay.MELEE_STANDARD),
	TZHAAR_KET_OM_T(ItemID.TZHAARKETOM_T, WeaponHitDelay.MELEE_STANDARD),
	UNDEAD_CHICKEN(ItemID.UNDEAD_CHICKEN, WeaponHitDelay.MELEE_STANDARD),
	WHITE_FLOWERS(ItemID.WHITE_FLOWERS, WeaponHitDelay.MELEE_STANDARD),
	WHITE_WARHAMMER(ItemID.WHITE_WARHAMMER, WeaponHitDelay.MELEE_STANDARD),
	WILLOW_BLACKJACK(ItemID.WILLOW_BLACKJACK, WeaponHitDelay.MELEE_STANDARD),
	WILLOW_BLACKJACK_D(ItemID.WILLOW_BLACKJACKD, WeaponHitDelay.MELEE_STANDARD),
	WILLOW_BLACKJACK_O(ItemID.WILLOW_BLACKJACKO, WeaponHitDelay.MELEE_STANDARD),
	YELLOW_FLOWERS(ItemID.YELLOW_FLOWERS, WeaponHitDelay.MELEE_STANDARD),
	ZOMBIE_HEAD_A(ItemID.ZOMBIE_HEAD, WeaponHitDelay.MELEE_STANDARD),
	ZOMBIE_HEAD_B(ItemID.ZOMBIE_HEAD_19912, WeaponHitDelay.MELEE_STANDARD),

	//BLUDGEON, BULWARKS, CLAWS AND PARTISANS
	ABYSSAL_BLUDGEON(ItemID.ABYSSAL_BLUDGEON, WeaponHitDelay.MELEE_STANDARD),
	DINHS_BLAZING_BULWARK(ItemID.DINHS_BLAZING_BULWARK, 0, WeaponHitDelay.MELEE_STANDARD, WeaponHitDelay.OTHER_SHIELD_SPECIALS),
	DINHS_BULWARK(ItemID.DINHS_BULWARK, 0, WeaponHitDelay.MELEE_STANDARD, WeaponHitDelay.OTHER_SHIELD_SPECIALS),
	ADAMANT_CLAWS(ItemID.ADAMANT_CLAWS, WeaponHitDelay.MELEE_STANDARD),
	BEACH_BOXING_GLOVES(ItemID.BEACH_BOXING_GLOVES, WeaponHitDelay.MELEE_STANDARD),
	BEACH_BOXING_GLOVES_A(ItemID.BEACH_BOXING_GLOVES_11706, WeaponHitDelay.MELEE_STANDARD),
	BLACK_CLAWS(ItemID.BLACK_CLAWS, WeaponHitDelay.MELEE_STANDARD),
	BOXING_GLOVES(ItemID.BOXING_GLOVES, WeaponHitDelay.MELEE_STANDARD),
	BOXING_GLOVES_A(ItemID.BOXING_GLOVES_7673, WeaponHitDelay.MELEE_STANDARD),
	BRONZE_CLAWS(ItemID.BRONZE_CLAWS, WeaponHitDelay.MELEE_STANDARD),
	BURNING_CLAWS(ItemID.BURNING_CLAWS, 0, WeaponHitDelay.MELEE_STANDARD, WeaponHitDelay.MELEE_DELAYED_SPECIAL),
	CORRUPTED_DRAGON_CLAWS(ItemID.CORRUPTED_DRAGON_CLAWS, 0, WeaponHitDelay.MELEE_STANDARD, WeaponHitDelay.MELEE_DELAYED_SPECIAL),
	DRAGON_CLAWS(ItemID.DRAGON_CLAWS, 0, WeaponHitDelay.MELEE_STANDARD, WeaponHitDelay.MELEE_DELAYED_SPECIAL),
	DRAGON_CLAWS_LMS(ItemID.DRAGON_CLAWS_20784, 0, WeaponHitDelay.MELEE_STANDARD, WeaponHitDelay.MELEE_DELAYED_SPECIAL),
	DRAGON_CLAWS_CR(ItemID.DRAGON_CLAWS_CR, 0, WeaponHitDelay.MELEE_STANDARD, WeaponHitDelay.MELEE_DELAYED_SPECIAL),
	DRAGON_CLAWS_OR(ItemID.DRAGON_CLAWS_OR, 0, WeaponHitDelay.MELEE_STANDARD, WeaponHitDelay.MELEE_DELAYED_SPECIAL),
	IRON_CLAWS(ItemID.IRON_CLAWS, WeaponHitDelay.MELEE_STANDARD),
	MITHRIL_CLAWS(ItemID.MITHRIL_CLAWS, WeaponHitDelay.MELEE_STANDARD),
	RUNE_CLAWS(ItemID.RUNE_CLAWS, WeaponHitDelay.MELEE_STANDARD),
	STEEL_CLAWS(ItemID.STEEL_CLAWS, WeaponHitDelay.MELEE_STANDARD),
	WHITE_CLAWS(ItemID.WHITE_CLAWS, WeaponHitDelay.MELEE_STANDARD),
	KERIS_PARTISAN(ItemID.KERIS_PARTISAN, WeaponHitDelay.MELEE_STANDARD),
	KERIS_PARTISAN_OF_BREACHING(ItemID.KERIS_PARTISAN_OF_BREACHING, WeaponHitDelay.MELEE_STANDARD),
	KERIS_PARTISAN_OF_CORRUPTION(ItemID.KERIS_PARTISAN_OF_CORRUPTION, WeaponHitDelay.MELEE_STANDARD),
	KERIS_PARTISAN_OF_THE_SUN(ItemID.KERIS_PARTISAN_OF_THE_SUN, WeaponHitDelay.MELEE_STANDARD),

	//PICKAXES
	_3RD_AGE_PICKAXE(ItemID._3RD_AGE_PICKAXE, WeaponHitDelay.MELEE_STANDARD),
	ADAMANT_PICKAXE(ItemID.ADAMANT_PICKAXE, WeaponHitDelay.MELEE_STANDARD),
	BLACK_PICKAXE(ItemID.BLACK_PICKAXE, WeaponHitDelay.MELEE_STANDARD),
	BRONZE_PICKAXE(ItemID.BRONZE_PICKAXE, WeaponHitDelay.MELEE_STANDARD),
	CRYSTAL_PICKAXE(ItemID.CRYSTAL_PICKAXE, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_PICKAXE(ItemID.DRAGON_PICKAXE, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_PICKAXE_OR(ItemID.DRAGON_PICKAXE_OR, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_PICKAXE_UPGRADED_A(ItemID.DRAGON_PICKAXE_12797, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_PICKAXE_UPGRADED_B(ItemID.DRAGON_PICKAXE_OR_25376, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_PICKAXE_UPGRADED_C(ItemID.DRAGON_PICKAXE_OR_30351, WeaponHitDelay.MELEE_STANDARD),
	GILDED_PICKAXE(ItemID.GILDED_PICKAXE, WeaponHitDelay.MELEE_STANDARD),
	INFERNAL_PICKAXE(ItemID.INFERNAL_PICKAXE, WeaponHitDelay.MELEE_STANDARD),
	INFERNAL_PICKAXE_OR(ItemID.INFERNAL_PICKAXE_OR, WeaponHitDelay.MELEE_STANDARD),
	INFERNAL_PICKAXE_OR_A(ItemID.INFERNAL_PICKAXE_OR_30345, WeaponHitDelay.MELEE_STANDARD),
	IRON_PICKAXE(ItemID.IRON_PICKAXE, WeaponHitDelay.MELEE_STANDARD),
	MITHRIL_PICKAXE(ItemID.MITHRIL_PICKAXE, WeaponHitDelay.MELEE_STANDARD),
	RUNE_PICKAXE(ItemID.RUNE_PICKAXE, WeaponHitDelay.MELEE_STANDARD),
	STEEL_PICKAXE(ItemID.STEEL_PICKAXE, WeaponHitDelay.MELEE_STANDARD),

	//POLEARMS
	ADAMANT_HALBERD(ItemID.ADAMANT_HALBERD, WeaponHitDelay.MELEE_STANDARD),
	BLACK_HALBERD(ItemID.BLACK_HALBERD, WeaponHitDelay.MELEE_STANDARD),
	BRONZE_HALBERD(ItemID.BRONZE_HALBERD, WeaponHitDelay.MELEE_STANDARD),
	CRYSTAL_HALBERD(ItemID.CRYSTAL_HALBERD, WeaponHitDelay.MELEE_STANDARD),
	CRYSTAL_HALBERD_110(ItemID.CRYSTAL_HALBERD_110, WeaponHitDelay.MELEE_STANDARD),
	CRYSTAL_HALBERD_210(ItemID.CRYSTAL_HALBERD_210, WeaponHitDelay.MELEE_STANDARD),
	CRYSTAL_HALBERD_310(ItemID.CRYSTAL_HALBERD_310, WeaponHitDelay.MELEE_STANDARD),
	CRYSTAL_HALBERD_410(ItemID.CRYSTAL_HALBERD_410, WeaponHitDelay.MELEE_STANDARD),
	CRYSTAL_HALBERD_510(ItemID.CRYSTAL_HALBERD_510, WeaponHitDelay.MELEE_STANDARD),
	CRYSTAL_HALBERD_610(ItemID.CRYSTAL_HALBERD_610, WeaponHitDelay.MELEE_STANDARD),
	CRYSTAL_HALBERD_710(ItemID.CRYSTAL_HALBERD_710, WeaponHitDelay.MELEE_STANDARD),
	CRYSTAL_HALBERD_810(ItemID.CRYSTAL_HALBERD_810, WeaponHitDelay.MELEE_STANDARD),
	CRYSTAL_HALBERD_910(ItemID.CRYSTAL_HALBERD_910, WeaponHitDelay.MELEE_STANDARD),
	CRYSTAL_HALBERD_110_I(ItemID.CRYSTAL_HALBERD_110_I, WeaponHitDelay.MELEE_STANDARD),
	CRYSTAL_HALBERD_210_I(ItemID.CRYSTAL_HALBERD_210_I, WeaponHitDelay.MELEE_STANDARD),
	CRYSTAL_HALBERD_310_I(ItemID.CRYSTAL_HALBERD_310_I, WeaponHitDelay.MELEE_STANDARD),
	CRYSTAL_HALBERD_410_I(ItemID.CRYSTAL_HALBERD_410_I, WeaponHitDelay.MELEE_STANDARD),
	CRYSTAL_HALBERD_510_I(ItemID.CRYSTAL_HALBERD_510_I, WeaponHitDelay.MELEE_STANDARD),
	CRYSTAL_HALBERD_610_I(ItemID.CRYSTAL_HALBERD_610_I, WeaponHitDelay.MELEE_STANDARD),
	CRYSTAL_HALBERD_710_I(ItemID.CRYSTAL_HALBERD_710_I, WeaponHitDelay.MELEE_STANDARD),
	CRYSTAL_HALBERD_810_I(ItemID.CRYSTAL_HALBERD_810_I, WeaponHitDelay.MELEE_STANDARD),
	CRYSTAL_HALBERD_910_I(ItemID.CRYSTAL_HALBERD_910_I, WeaponHitDelay.MELEE_STANDARD),
	CRYSTAL_HALBERD_24125(ItemID.CRYSTAL_HALBERD_24125, WeaponHitDelay.MELEE_STANDARD),
	CRYSTAL_HALBERD_FULL(ItemID.CRYSTAL_HALBERD_FULL, WeaponHitDelay.MELEE_STANDARD),
	CRYSTAL_HALBERD_FULL_I(ItemID.CRYSTAL_HALBERD_FULL_I, WeaponHitDelay.MELEE_STANDARD),
	NEW_CRYSTAL_HALBERD_FULL(ItemID.NEW_CRYSTAL_HALBERD_FULL, WeaponHitDelay.MELEE_STANDARD),
	NEW_CRYSTAL_HALBERD_FULL_I(ItemID.NEW_CRYSTAL_HALBERD_FULL_I, WeaponHitDelay.MELEE_STANDARD),
	NEW_CRYSTAL_HALBERD_FULL_I_16892(ItemID.NEW_CRYSTAL_HALBERD_FULL_I_16892, WeaponHitDelay.MELEE_STANDARD),
	NEW_CRYSTAL_HALBERD_FULL_16893(ItemID.NEW_CRYSTAL_HALBERD_FULL_16893, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_HALBERD(ItemID.DRAGON_HALBERD, WeaponHitDelay.MELEE_STANDARD),
	IRON_HALBERD(ItemID.IRON_HALBERD, WeaponHitDelay.MELEE_STANDARD),
	MITHRIL_HALBERD(ItemID.MITHRIL_HALBERD, WeaponHitDelay.MELEE_STANDARD),
	NOXIOUS_HALBERD(ItemID.NOXIOUS_HALBERD, WeaponHitDelay.MELEE_STANDARD),
	RUNE_HALBERD(ItemID.RUNE_HALBERD, WeaponHitDelay.MELEE_STANDARD),
	STEEL_HALBERD(ItemID.STEEL_HALBERD, WeaponHitDelay.MELEE_STANDARD),
	WHITE_HALBERD(ItemID.WHITE_HALBERD, WeaponHitDelay.MELEE_STANDARD),

	//POLESTAFF
	ARCEUUS_BANNER(ItemID.ARCEUUS_BANNER, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_CANE(ItemID.DRAGON_CANE, WeaponHitDelay.MELEE_STANDARD),
	GUTHIX_MJOLNIR(ItemID.GUTHIX_MJOLNIR, WeaponHitDelay.MELEE_STANDARD),
	HOSIDIUS_BANNER(ItemID.HOSIDIUS_BANNER, WeaponHitDelay.MELEE_STANDARD),
	LOVAKENGJ_BANNER(ItemID.LOVAKENGJ_BANNER, WeaponHitDelay.MELEE_STANDARD),
	PHARAOHS_SCEPTRE(ItemID.PHARAOHS_SCEPTRE, WeaponHitDelay.MELEE_STANDARD),
	PISCARILIUS_BANNER(ItemID.PISCARILIUS_BANNER, WeaponHitDelay.MELEE_STANDARD),
	ROYAL_SCEPTRE(ItemID.ROYAL_SCEPTRE, WeaponHitDelay.MELEE_STANDARD),
	SARADOMIN_MJOLNIR(ItemID.SARADOMIN_MJOLNIR, WeaponHitDelay.MELEE_STANDARD),
	SHAYZIEN_BANNER(ItemID.SHAYZIEN_BANNER, WeaponHitDelay.MELEE_STANDARD),
	WESTERN_BANNER(ItemID.WESTERN_BANNER, WeaponHitDelay.MELEE_STANDARD),
	WESTERN_BANNER_1(ItemID.WESTERN_BANNER_1, WeaponHitDelay.MELEE_STANDARD),
	WESTERN_BANNER_2(ItemID.WESTERN_BANNER_2, WeaponHitDelay.MELEE_STANDARD),
	WESTERN_BANNER_3(ItemID.WESTERN_BANNER_3, WeaponHitDelay.MELEE_STANDARD),
	WESTERN_BANNER_4(ItemID.WESTERN_BANNER_4, WeaponHitDelay.MELEE_STANDARD),
	ZAMORAK_MJOLNIR(ItemID.ZAMORAK_MJOLNIR, WeaponHitDelay.MELEE_STANDARD),

	//SYCTHES
	CORRUPTED_SCYTHE_OF_VITUR(ItemID.CORRUPTED_SCYTHE_OF_VITUR, WeaponHitDelay.MELEE_STANDARD),
	HOLY_SCYTHE_OF_VITUR(ItemID.HOLY_SCYTHE_OF_VITUR, WeaponHitDelay.MELEE_STANDARD),
	SANGUINE_SCYTHE_OF_VITUR(ItemID.SANGUINE_SCYTHE_OF_VITUR, WeaponHitDelay.MELEE_STANDARD),
	SCYTHE(ItemID.SCYTHE, WeaponHitDelay.MELEE_STANDARD),
	SCYTHE_OF_VITUR(ItemID.SCYTHE_OF_VITUR, WeaponHitDelay.MELEE_STANDARD),

	//SLASH SWORDS
	ADAMANT_LONGSWORD(ItemID.ADAMANT_LONGSWORD, WeaponHitDelay.MELEE_STANDARD),
	ADAMANT_SCIMITAR(ItemID.ADAMANT_SCIMITAR, WeaponHitDelay.MELEE_STANDARD),
	AMYS_SAW(ItemID.AMYS_SAW, WeaponHitDelay.MELEE_STANDARD),
	ARCLIGHT(ItemID.ARCLIGHT, WeaponHitDelay.MELEE_STANDARD),
	BLACK_LONGSWORD(ItemID.BLACK_LONGSWORD, WeaponHitDelay.MELEE_STANDARD),
	BLACK_SCIMITAR(ItemID.BLACK_SCIMITAR, WeaponHitDelay.MELEE_STANDARD),
	BLADE_OF_SAELDOR(ItemID.BLADE_OF_SAELDOR, WeaponHitDelay.MELEE_STANDARD),
	BLADE_OF_SAELDOR_C(ItemID.BLADE_OF_SAELDOR_C, WeaponHitDelay.MELEE_STANDARD),
	BLADE_OF_SAELDOR_C_25872(ItemID.BLADE_OF_SAELDOR_C_25872, WeaponHitDelay.MELEE_STANDARD),
	BLADE_OF_SAELDOR_C_25876(ItemID.BLADE_OF_SAELDOR_C_25876, WeaponHitDelay.MELEE_STANDARD),
	BLADE_OF_SAELDOR_C_24553(ItemID.BLADE_OF_SAELDOR_C_24553, WeaponHitDelay.MELEE_STANDARD),
	BLADE_OF_SAELDOR_C_25874(ItemID.BLADE_OF_SAELDOR_C_25874, WeaponHitDelay.MELEE_STANDARD),
	BLADE_OF_SAELDOR_C_25870(ItemID.BLADE_OF_SAELDOR_C_25870, WeaponHitDelay.MELEE_STANDARD),
	BLADE_OF_SAELDOR_C_25878(ItemID.BLADE_OF_SAELDOR_C_25878, WeaponHitDelay.MELEE_STANDARD),
	BLADE_OF_SAELDOR_C_25880(ItemID.BLADE_OF_SAELDOR_C_25880, WeaponHitDelay.MELEE_STANDARD),
	BLADE_OF_SAELDOR_C_25882(ItemID.BLADE_OF_SAELDOR_C_25882, WeaponHitDelay.MELEE_STANDARD),
	BLISTERWOOD_SICKLE(ItemID.BLISTERWOOD_SICKLE, WeaponHitDelay.MELEE_STANDARD),
	BLURITE_SWORD(ItemID.BLURITE_SWORD, WeaponHitDelay.MELEE_STANDARD),
	BRINE_SABRE(ItemID.BRINE_SABRE, WeaponHitDelay.MELEE_STANDARD),
	BRONZE_LONGSWORD(ItemID.BRONZE_LONGSWORD, WeaponHitDelay.MELEE_STANDARD),
	BRONZE_SCIMITAR(ItemID.BRONZE_SCIMITAR, WeaponHitDelay.MELEE_STANDARD),
	CLEAVER(ItemID.CLEAVER, WeaponHitDelay.MELEE_STANDARD),
	CORRUPTED_VOIDWAKER(ItemID.CORRUPTED_VOIDWAKER, WeaponHitDelay.MELEE_STANDARD),
	DARKLIGHT(ItemID.DARKLIGHT, WeaponHitDelay.MELEE_STANDARD),
	DECORATIVE_SWORD(ItemID.DECORATIVE_SWORD, WeaponHitDelay.MELEE_STANDARD),
	DECORATIVE_SWORD_4503(ItemID.DECORATIVE_SWORD_4503, WeaponHitDelay.MELEE_STANDARD),
	DECORATIVE_SWORD_4508(ItemID.DECORATIVE_SWORD_4508, WeaponHitDelay.MELEE_STANDARD),
	DECORATIVE_SWORD_L(ItemID.DECORATIVE_SWORD_L, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_LONGSWORD(ItemID.DRAGON_LONGSWORD, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_LONGSWORD_BH(ItemID.DRAGON_LONGSWORD_BH, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_LONGSWORD_CR(ItemID.DRAGON_LONGSWORD_CR, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_SCIMITAR(ItemID.DRAGON_SCIMITAR, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_SCIMITAR_CR(ItemID.DRAGON_SCIMITAR_CR, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_SCIMITAR_OR(ItemID.DRAGON_SCIMITAR_OR, WeaponHitDelay.MELEE_STANDARD),
	EMBERLIGHT(ItemID.EMBERLIGHT, WeaponHitDelay.MELEE_STANDARD),
	EMERALD_SICKLE_B(ItemID.EMERALD_SICKLE_B, WeaponHitDelay.MELEE_STANDARD),
	ENCHANTED_EMERALD_SICKLE_B(ItemID.ENCHANTED_EMERALD_SICKLE_B, WeaponHitDelay.MELEE_STANDARD),
	ENCHANTED_RUBY_SICKLE_B(ItemID.ENCHANTED_RUBY_SICKLE_B, WeaponHitDelay.MELEE_STANDARD),
	EXCALIBUR(ItemID.EXCALIBUR, WeaponHitDelay.MELEE_STANDARD),
	FREMENNIK_BLADE(ItemID.FREMENNIK_BLADE, WeaponHitDelay.MELEE_STANDARD),
	GILDED_SCIMITAR(ItemID.GILDED_SCIMITAR, WeaponHitDelay.MELEE_STANDARD),
	GRANITE_LONGSWORD(ItemID.GRANITE_LONGSWORD, WeaponHitDelay.MELEE_STANDARD),
	HARRYS_CUTLASS(ItemID.HARRYS_CUTLASS, WeaponHitDelay.MELEE_STANDARD),
	IRON_LONGSWORD(ItemID.IRON_LONGSWORD, WeaponHitDelay.MELEE_STANDARD),
	IRON_SCIMITAR(ItemID.IRON_SCIMITAR, WeaponHitDelay.MELEE_STANDARD),
	IRON_SICKLE(ItemID.IRON_SICKLE, WeaponHitDelay.MELEE_STANDARD),
	JADE_MACHETE(ItemID.JADE_MACHETE, WeaponHitDelay.MELEE_STANDARD),
	KATANA(ItemID.KATANA, WeaponHitDelay.MELEE_STANDARD),
	LUCKY_CUTLASS(ItemID.LUCKY_CUTLASS, WeaponHitDelay.MELEE_STANDARD),
	MACHETE(ItemID.MACHETE, WeaponHitDelay.MELEE_STANDARD),
	MITHRIL_LONGSWORD(ItemID.MITHRIL_LONGSWORD, WeaponHitDelay.MELEE_STANDARD),
	MITHRIL_SCIMITAR(ItemID.MITHRIL_SCIMITAR, WeaponHitDelay.MELEE_STANDARD),
	OPAL_MACHETE(ItemID.OPAL_MACHETE, WeaponHitDelay.MELEE_STANDARD),
	RED_TOPAZ_MACHETE(ItemID.RED_TOPAZ_MACHETE, WeaponHitDelay.MELEE_STANDARD),
	RUBY_SICKLE_B(ItemID.RUBY_SICKLE_B, WeaponHitDelay.MELEE_STANDARD),
	RUNE_LONGSWORD(ItemID.RUNE_LONGSWORD, WeaponHitDelay.MELEE_STANDARD),
	RUNE_SCIMITAR(ItemID.RUNE_SCIMITAR, WeaponHitDelay.MELEE_STANDARD),
	RUNE_SCIMITAR_20402(ItemID.RUNE_SCIMITAR_20402, WeaponHitDelay.MELEE_STANDARD),
	RUNE_SCIMITAR_23334(ItemID.RUNE_SCIMITAR_23334, WeaponHitDelay.MELEE_STANDARD),
	RUNE_SCIMITAR_23330(ItemID.RUNE_SCIMITAR_23330, WeaponHitDelay.MELEE_STANDARD),
	RUNE_SCIMITAR_26262(ItemID.RUNE_SCIMITAR_26262, WeaponHitDelay.MELEE_STANDARD),
	RUNE_SCIMITAR_23332(ItemID.RUNE_SCIMITAR_23332, WeaponHitDelay.MELEE_STANDARD),
	SILVER_SICKLE(ItemID.SILVER_SICKLE, WeaponHitDelay.MELEE_STANDARD),
	SILVER_SICKLE_B(ItemID.SILVER_SICKLE_B, WeaponHitDelay.MELEE_STANDARD),
	SILVERLIGHT(ItemID.SILVERLIGHT, WeaponHitDelay.MELEE_STANDARD),
	SKEWER(ItemID.SKEWER, WeaponHitDelay.MELEE_STANDARD),
	STARTER_SWORD(ItemID.STARTER_SWORD, WeaponHitDelay.MELEE_STANDARD),
	STEEL_LONGSWORD(ItemID.STEEL_LONGSWORD, WeaponHitDelay.MELEE_STANDARD),
	STEEL_SCIMITAR(ItemID.STEEL_SCIMITAR, WeaponHitDelay.MELEE_STANDARD),
	SULPHUR_BLADES(ItemID.SULPHUR_BLADES, WeaponHitDelay.MELEE_STANDARD),
	THUNDER_KHOPESH(ItemID.THUNDER_KHOPESH, WeaponHitDelay.MELEE_STANDARD),
	TOKTZXILEK(ItemID.TOKTZXILEK, WeaponHitDelay.MELEE_STANDARD),
	VESTAS_BLIGHTED_LONGSWORD(ItemID.VESTAS_BLIGHTED_LONGSWORD, WeaponHitDelay.MELEE_STANDARD),
	VESTAS_LONGSWORD(ItemID.VESTAS_LONGSWORD, WeaponHitDelay.MELEE_STANDARD),
	VESTAS_LONGSWORD_23615(ItemID.VESTAS_LONGSWORD_23615, WeaponHitDelay.MELEE_STANDARD),
	VESTAS_LONGSWORD_BH(ItemID.VESTAS_LONGSWORD_BH, WeaponHitDelay.MELEE_STANDARD),
	VOIDWAKER(ItemID.VOIDWAKER, WeaponHitDelay.MELEE_STANDARD),
	VOIDWAKER_DEADMAN(ItemID.VOIDWAKER_DEADMAN, WeaponHitDelay.MELEE_STANDARD),
	VOIDWAKER_27869(ItemID.VOIDWAKER_27869, WeaponHitDelay.MELEE_STANDARD),
	WHITE_LONGSWORD(ItemID.WHITE_LONGSWORD, WeaponHitDelay.MELEE_STANDARD),
	WHITE_SCIMITAR(ItemID.WHITE_SCIMITAR, WeaponHitDelay.MELEE_STANDARD),
	WOODEN_SPOON(ItemID.WOODEN_SPOON, WeaponHitDelay.MELEE_STANDARD),

	//SPEARS
	ADAMANT_HASTA(ItemID.ADAMANT_HASTA, WeaponHitDelay.MELEE_STANDARD),
	ADAMANT_HASTAKP(ItemID.ADAMANT_HASTAKP, WeaponHitDelay.MELEE_STANDARD),
	ADAMANT_HASTAP(ItemID.ADAMANT_HASTAP, WeaponHitDelay.MELEE_STANDARD),
	ADAMANT_HASTAP_11410(ItemID.ADAMANT_HASTAP_11410, WeaponHitDelay.MELEE_STANDARD),
	ADAMANT_HASTAP_11412(ItemID.ADAMANT_HASTAP_11412, WeaponHitDelay.MELEE_STANDARD),
	ADAMANT_SPEAR(ItemID.ADAMANT_SPEAR, WeaponHitDelay.MELEE_STANDARD),
	ADAMANT_SPEARKP(ItemID.ADAMANT_SPEARKP, WeaponHitDelay.MELEE_STANDARD),
	ADAMANT_SPEARP(ItemID.ADAMANT_SPEARP, WeaponHitDelay.MELEE_STANDARD),
	ADAMANT_SPEARP_5712(ItemID.ADAMANT_SPEARP_5712, WeaponHitDelay.MELEE_STANDARD),
	ADAMANT_SPEARP_5726(ItemID.ADAMANT_SPEARP_5726, WeaponHitDelay.MELEE_STANDARD),
	ANGER_SPEAR(ItemID.ANGER_SPEAR, WeaponHitDelay.MELEE_STANDARD),
	BLACK_SPEAR(ItemID.BLACK_SPEAR, WeaponHitDelay.MELEE_STANDARD),
	BLACK_SPEARKP(ItemID.BLACK_SPEARKP, WeaponHitDelay.MELEE_STANDARD),
	BLACK_SPEARP(ItemID.BLACK_SPEARP, WeaponHitDelay.MELEE_STANDARD),
	BLACK_SPEARP_5734(ItemID.BLACK_SPEARP_5734, WeaponHitDelay.MELEE_STANDARD),
	BLACK_SPEARP_5736(ItemID.BLACK_SPEARP_5736, WeaponHitDelay.MELEE_STANDARD),
	BONE_SPEAR(ItemID.BONE_SPEAR, WeaponHitDelay.MELEE_STANDARD),
	BRONZE_HASTA(ItemID.BRONZE_HASTA, WeaponHitDelay.MELEE_STANDARD),
	BRONZE_HASTAKP(ItemID.BRONZE_HASTAKP, WeaponHitDelay.MELEE_STANDARD),
	BRONZE_HASTAP(ItemID.BRONZE_HASTAP, WeaponHitDelay.MELEE_STANDARD),
	BRONZE_HASTAP_11382(ItemID.BRONZE_HASTAP_11382, WeaponHitDelay.MELEE_STANDARD),
	BRONZE_HASTAP_11384(ItemID.BRONZE_HASTAP_11384, WeaponHitDelay.MELEE_STANDARD),
	BRONZE_SPEAR(ItemID.BRONZE_SPEAR, WeaponHitDelay.MELEE_STANDARD),
	BRONZE_SPEARKP(ItemID.BRONZE_SPEARKP, WeaponHitDelay.MELEE_STANDARD),
	BRONZE_SPEARP(ItemID.BRONZE_SPEARP, WeaponHitDelay.MELEE_STANDARD),
	BRONZE_SPEARP_5704(ItemID.BRONZE_SPEARP_5704, WeaponHitDelay.MELEE_STANDARD),
	BRONZE_SPEARP_5718(ItemID.BRONZE_SPEARP_5718, WeaponHitDelay.MELEE_STANDARD),
	BUTTERFLY_NET(ItemID.BUTTERFLY_NET, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_HASTA(ItemID.DRAGON_HASTA, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_HASTAKP(ItemID.DRAGON_HASTAKP, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_HASTAP(ItemID.DRAGON_HASTAP, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_HASTAP_22737(ItemID.DRAGON_HASTAP_22737, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_HASTAP_22740(ItemID.DRAGON_HASTAP_22740, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_HUNTER_LANCE(ItemID.DRAGON_HUNTER_LANCE, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_SPEAR(ItemID.DRAGON_SPEAR, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_SPEAR_CR(ItemID.DRAGON_SPEAR_CR, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_SPEAR_PCR(ItemID.DRAGON_SPEAR_PCR, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_SPEAR_PCR_28045(ItemID.DRAGON_SPEAR_PCR_28045, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_SPEAR_PCR_28047(ItemID.DRAGON_SPEAR_PCR_28047, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_SPEARKP(ItemID.DRAGON_SPEARKP, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_SPEARP(ItemID.DRAGON_SPEARP, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_SPEARP_5716(ItemID.DRAGON_SPEARP_5716, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_SPEARP_5730(ItemID.DRAGON_SPEARP_5730, WeaponHitDelay.MELEE_STANDARD),
	GILDED_HASTA(ItemID.GILDED_HASTA, WeaponHitDelay.MELEE_STANDARD),
	GILDED_SPEAR(ItemID.GILDED_SPEAR, WeaponHitDelay.MELEE_STANDARD),
	GUTHANS_WARSPEAR(ItemID.GUTHANS_WARSPEAR, WeaponHitDelay.MELEE_STANDARD),
	GUTHANS_WARSPEAR_100(ItemID.GUTHANS_WARSPEAR_100, WeaponHitDelay.MELEE_STANDARD),
	GUTHANS_WARSPEAR_75(ItemID.GUTHANS_WARSPEAR_75, WeaponHitDelay.MELEE_STANDARD),
	GUTHANS_WARSPEAR_50(ItemID.GUTHANS_WARSPEAR_50, WeaponHitDelay.MELEE_STANDARD),
	GUTHANS_WARSPEAR_25(ItemID.GUTHANS_WARSPEAR_25, WeaponHitDelay.MELEE_STANDARD),
	GUTHANS_WARSPEAR_0(ItemID.GUTHANS_WARSPEAR_0, WeaponHitDelay.MELEE_STANDARD),
	IRON_HASTA(ItemID.IRON_HASTA, WeaponHitDelay.MELEE_STANDARD),
	IRON_HASTAKP(ItemID.IRON_HASTAKP, WeaponHitDelay.MELEE_STANDARD),
	IRON_HASTAP(ItemID.IRON_HASTAP, WeaponHitDelay.MELEE_STANDARD),
	IRON_HASTAP_11389(ItemID.IRON_HASTAP_11389, WeaponHitDelay.MELEE_STANDARD),
	IRON_HASTAP_11391(ItemID.IRON_HASTAP_11391, WeaponHitDelay.MELEE_STANDARD),
	IRON_SPEAR(ItemID.IRON_SPEAR, WeaponHitDelay.MELEE_STANDARD),
	IRON_SPEARKP(ItemID.IRON_SPEARKP, WeaponHitDelay.MELEE_STANDARD),
	IRON_SPEARP(ItemID.IRON_SPEARP, WeaponHitDelay.MELEE_STANDARD),
	IRON_SPEARP_5706(ItemID.IRON_SPEARP_5706, WeaponHitDelay.MELEE_STANDARD),
	IRON_SPEARP_5720(ItemID.IRON_SPEARP_5720, WeaponHitDelay.MELEE_STANDARD),
	LEAFBLADED_SPEAR(ItemID.LEAFBLADED_SPEAR, WeaponHitDelay.MELEE_STANDARD),
	MAGIC_BUTTERFLY_NET(ItemID.MAGIC_BUTTERFLY_NET, WeaponHitDelay.MELEE_STANDARD),
	MERFOLK_TRIDENT(ItemID.MERFOLK_TRIDENT, WeaponHitDelay.MELEE_STANDARD),
	MITHRIL_HASTA(ItemID.MITHRIL_HASTA, WeaponHitDelay.MELEE_STANDARD),
	MITHRIL_HASTAKP(ItemID.MITHRIL_HASTAKP, WeaponHitDelay.MELEE_STANDARD),
	MITHRIL_HASTAP(ItemID.MITHRIL_HASTAP, WeaponHitDelay.MELEE_STANDARD),
	MITHRIL_HASTAP_11403(ItemID.MITHRIL_HASTAP_11403, WeaponHitDelay.MELEE_STANDARD),
	MITHRIL_HASTAP_11405(ItemID.MITHRIL_HASTAP_11405, WeaponHitDelay.MELEE_STANDARD),
	MITHRIL_SPEAR(ItemID.MITHRIL_SPEAR, WeaponHitDelay.MELEE_STANDARD),
	MITHRIL_SPEARKP(ItemID.MITHRIL_SPEARKP, WeaponHitDelay.MELEE_STANDARD),
	MITHRIL_SPEARP(ItemID.MITHRIL_SPEARP, WeaponHitDelay.MELEE_STANDARD),
	MITHRIL_SPEARP_5710(ItemID.MITHRIL_SPEARP_5710, WeaponHitDelay.MELEE_STANDARD),
	MITHRIL_SPEARP_5724(ItemID.MITHRIL_SPEARP_5724, WeaponHitDelay.MELEE_STANDARD),
	NOOSE_WAND(ItemID.NOOSE_WAND, WeaponHitDelay.MELEE_STANDARD),
	RUNE_HASTA(ItemID.RUNE_HASTA, WeaponHitDelay.MELEE_STANDARD),
	RUNE_HASTAKP(ItemID.RUNE_HASTAKP, WeaponHitDelay.MELEE_STANDARD),
	RUNE_HASTAP(ItemID.RUNE_HASTAP, WeaponHitDelay.MELEE_STANDARD),
	RUNE_HASTAP_11417(ItemID.RUNE_HASTAP_11417, WeaponHitDelay.MELEE_STANDARD),
	RUNE_HASTAP_11419(ItemID.RUNE_HASTAP_11419, WeaponHitDelay.MELEE_STANDARD),
	RUNE_SPEAR(ItemID.RUNE_SPEAR, WeaponHitDelay.MELEE_STANDARD),
	RUNE_SPEARKP(ItemID.RUNE_SPEARKP, WeaponHitDelay.MELEE_STANDARD),
	RUNE_SPEARP(ItemID.RUNE_SPEARP, WeaponHitDelay.MELEE_STANDARD),
	RUNE_SPEARP_5714(ItemID.RUNE_SPEARP_5714, WeaponHitDelay.MELEE_STANDARD),
	RUNE_SPEARP_5728(ItemID.RUNE_SPEARP_5728, WeaponHitDelay.MELEE_STANDARD),
	STEEL_HASTA(ItemID.STEEL_HASTA, WeaponHitDelay.MELEE_STANDARD),
	STEEL_HASTAKP(ItemID.STEEL_HASTAKP, WeaponHitDelay.MELEE_STANDARD),
	STEEL_HASTAP(ItemID.STEEL_HASTAP, WeaponHitDelay.MELEE_STANDARD),
	STEEL_HASTAP_11396(ItemID.STEEL_HASTAP_11396, WeaponHitDelay.MELEE_STANDARD),
	STEEL_HASTAP_11398(ItemID.STEEL_HASTAP_11398, WeaponHitDelay.MELEE_STANDARD),
	STEEL_SPEAR(ItemID.STEEL_SPEAR, WeaponHitDelay.MELEE_STANDARD),
	STEEL_SPEARKP(ItemID.STEEL_SPEARKP, WeaponHitDelay.MELEE_STANDARD),
	STEEL_SPEARP(ItemID.STEEL_SPEARP, WeaponHitDelay.MELEE_STANDARD),
	STEEL_SPEARP_5708(ItemID.STEEL_SPEARP_5708, WeaponHitDelay.MELEE_STANDARD),
	STEEL_SPEARP_5722(ItemID.STEEL_SPEARP_5722, WeaponHitDelay.MELEE_STANDARD),
	VESTAS_SPEAR(ItemID.VESTAS_SPEAR, WeaponHitDelay.MELEE_STANDARD),
	VESTAS_SPEAR_BH(ItemID.VESTAS_SPEAR_BH, WeaponHitDelay.MELEE_STANDARD),
	ZAMORAKIAN_HASTA(ItemID.ZAMORAKIAN_HASTA, WeaponHitDelay.MELEE_STANDARD),
	ZAMORAKIAN_SPEAR(ItemID.ZAMORAKIAN_SPEAR, WeaponHitDelay.MELEE_STANDARD),

	//SPIKED
	ADAMANT_CANE(ItemID.ADAMANT_CANE, WeaponHitDelay.MELEE_STANDARD),
	ADAMANT_MACE(ItemID.ADAMANT_MACE, WeaponHitDelay.MELEE_STANDARD),
	ANCIENT_MACE(ItemID.ANCIENT_MACE, WeaponHitDelay.MELEE_STANDARD),
	ANGER_MACE(ItemID.ANGER_MACE, WeaponHitDelay.MELEE_STANDARD),
	BARRELCHEST_ANCHOR(ItemID.BARRELCHEST_ANCHOR, WeaponHitDelay.MELEE_STANDARD),
	BARRELCHEST_ANCHOR_10888(ItemID.BARRELCHEST_ANCHOR_10888, WeaponHitDelay.MELEE_STANDARD),
	BARRELCHEST_ANCHOR_BH(ItemID.BARRELCHEST_ANCHOR_BH, WeaponHitDelay.MELEE_STANDARD),
	BLACK_CANE(ItemID.BLACK_CANE, WeaponHitDelay.MELEE_STANDARD),
	BLACK_MACE(ItemID.BLACK_MACE, WeaponHitDelay.MELEE_STANDARD),
	BONE_MACE(ItemID.BONE_MACE, WeaponHitDelay.MELEE_STANDARD),
	BRONZE_MACE(ItemID.BRONZE_MACE, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_MACE(ItemID.DRAGON_MACE, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_MACE_BH(ItemID.DRAGON_MACE_BH, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_MACE_CR(ItemID.DRAGON_MACE_CR, WeaponHitDelay.MELEE_STANDARD),
	DUAL_MACUAHUITL(ItemID.DUAL_MACUAHUITL, WeaponHitDelay.MELEE_STANDARD),
	DUAL_MACUAHUITL_29850(ItemID.DUAL_MACUAHUITL_29850, WeaponHitDelay.MELEE_STANDARD),
	GLACIAL_TEMOTLI(ItemID.GLACIAL_TEMOTLI, WeaponHitDelay.MELEE_STANDARD),
	INQUISITORS_MACE(ItemID.INQUISITORS_MACE, WeaponHitDelay.MELEE_STANDARD),
	INQUISITORS_MACE_27198(ItemID.INQUISITORS_MACE_27198, WeaponHitDelay.MELEE_STANDARD),
	IRON_MACE(ItemID.IRON_MACE, WeaponHitDelay.MELEE_STANDARD),
	MITHRIL_MACE(ItemID.MITHRIL_MACE, WeaponHitDelay.MELEE_STANDARD),
	RAGING_ECHOES_CANE(ItemID.RAGING_ECHOES_CANE, WeaponHitDelay.MELEE_STANDARD),
	RUNE_CANE(ItemID.RUNE_CANE, WeaponHitDelay.MELEE_STANDARD),
	RUNE_MACE(ItemID.RUNE_MACE, WeaponHitDelay.MELEE_STANDARD),
	SARACHNIS_CUDGEL(ItemID.SARACHNIS_CUDGEL, WeaponHitDelay.MELEE_STANDARD),
	SHATTERED_CANE(ItemID.SHATTERED_CANE, WeaponHitDelay.MELEE_STANDARD),
	STEEL_MACE(ItemID.STEEL_MACE, WeaponHitDelay.MELEE_STANDARD),
	TRAILBLAZER_CANE(ItemID.TRAILBLAZER_CANE, WeaponHitDelay.MELEE_STANDARD),
	TRAILBLAZER_RELOADED_TORCH(ItemID.TRAILBLAZER_RELOADED_TORCH, WeaponHitDelay.MELEE_STANDARD),
	TWISTED_CANE(ItemID.TWISTED_CANE, WeaponHitDelay.MELEE_STANDARD),
	URSINE_CHAINMACE(ItemID.URSINE_CHAINMACE, WeaponHitDelay.MELEE_STANDARD),
	URSINE_CHAINMACE_U(ItemID.URSINE_CHAINMACE_U, WeaponHitDelay.MELEE_STANDARD),
	VERACS_FLAIL(ItemID.VERACS_FLAIL, WeaponHitDelay.MELEE_STANDARD),
	VERACS_FLAIL_100(ItemID.VERACS_FLAIL_100, WeaponHitDelay.MELEE_STANDARD),
	VERACS_FLAIL_50(ItemID.VERACS_FLAIL_50, WeaponHitDelay.MELEE_STANDARD),
	VERACS_FLAIL_25(ItemID.VERACS_FLAIL_25, WeaponHitDelay.MELEE_STANDARD),
	VERACS_FLAIL_0(ItemID.VERACS_FLAIL_0, WeaponHitDelay.MELEE_STANDARD),
	VERACS_FLAIL_27189(ItemID.VERACS_FLAIL_27189, WeaponHitDelay.MELEE_STANDARD),
	VIGGORAS_CHAINMACE(ItemID.VIGGORAS_CHAINMACE, WeaponHitDelay.MELEE_STANDARD),
	VIGGORAS_CHAINMACE_U(ItemID.VIGGORAS_CHAINMACE_U, WeaponHitDelay.MELEE_STANDARD),
	WHITE_MACE(ItemID.WHITE_MACE, WeaponHitDelay.MELEE_STANDARD),

	//STAB SWORDS
	ABYSSAL_DAGGER(ItemID.ABYSSAL_DAGGER, WeaponHitDelay.MELEE_STANDARD),
	ABYSSAL_DAGGER_BH(ItemID.ABYSSAL_DAGGER_BH, WeaponHitDelay.MELEE_STANDARD),
	ABYSSAL_DAGGER_BHP(ItemID.ABYSSAL_DAGGER_BHP, WeaponHitDelay.MELEE_STANDARD),
	ABYSSAL_DAGGER_BHP_27865(ItemID.ABYSSAL_DAGGER_BHP_27865, WeaponHitDelay.MELEE_STANDARD),
	ABYSSAL_DAGGER_P(ItemID.ABYSSAL_DAGGER_P, WeaponHitDelay.MELEE_STANDARD),
	ABYSSAL_DAGGER_BHP_27867(ItemID.ABYSSAL_DAGGER_BHP_27867, WeaponHitDelay.MELEE_STANDARD),
	ABYSSAL_DAGGER_P_13269(ItemID.ABYSSAL_DAGGER_P_13269, WeaponHitDelay.MELEE_STANDARD),
	ABYSSAL_DAGGER_P_13271(ItemID.ABYSSAL_DAGGER_P_13271, WeaponHitDelay.MELEE_STANDARD),
	ADAMANT_DAGGER(ItemID.ADAMANT_DAGGER, WeaponHitDelay.MELEE_STANDARD),
	ADAMANT_DAGGERP(ItemID.ADAMANT_DAGGERP, WeaponHitDelay.MELEE_STANDARD),
	ADAMANT_DAGGERP_5676(ItemID.ADAMANT_DAGGERP_5676, WeaponHitDelay.MELEE_STANDARD),
	ADAMANT_DAGGERP_5694(ItemID.ADAMANT_DAGGERP_5694, WeaponHitDelay.MELEE_STANDARD),
	ADAMANT_SWORD(ItemID.ADAMANT_SWORD, WeaponHitDelay.MELEE_STANDARD),
	ANGER_SWORD(ItemID.ANGER_SWORD, WeaponHitDelay.MELEE_STANDARD),
	BARBTAIL_HARPOON(ItemID.BARBTAIL_HARPOON, WeaponHitDelay.MELEE_STANDARD),
	BLACK_DAGGER(ItemID.BLACK_DAGGER, WeaponHitDelay.MELEE_STANDARD),
	BLACK_DAGGERP(ItemID.BLACK_DAGGERP, WeaponHitDelay.MELEE_STANDARD),
	BLACK_DAGGERP_5682(ItemID.BLACK_DAGGERP_5682, WeaponHitDelay.MELEE_STANDARD),
	BLACK_DAGGERP_5700(ItemID.BLACK_DAGGERP_5700, WeaponHitDelay.MELEE_STANDARD),
	BLACK_SWORD(ItemID.BLACK_SWORD, WeaponHitDelay.MELEE_STANDARD),
	BONE_DAGGER(ItemID.BONE_DAGGER, WeaponHitDelay.MELEE_STANDARD),
	BONE_DAGGER_P(ItemID.BONE_DAGGER_P, WeaponHitDelay.MELEE_STANDARD),
	BONE_DAGGER_P_8876(ItemID.BONE_DAGGER_P_8876, WeaponHitDelay.MELEE_STANDARD),
	BONE_DAGGER_P_8878(ItemID.BONE_DAGGER_P_8878, WeaponHitDelay.MELEE_STANDARD),
	BRONZE_DAGGER(ItemID.BRONZE_DAGGER, WeaponHitDelay.MELEE_STANDARD),
	BRONZE_DAGGERP(ItemID.BRONZE_DAGGERP, WeaponHitDelay.MELEE_STANDARD),
	BRONZE_DAGGERP_5670(ItemID.BRONZE_DAGGERP_5670, WeaponHitDelay.MELEE_STANDARD),
	BRONZE_DAGGERP_5688(ItemID.BRONZE_DAGGERP_5688, WeaponHitDelay.MELEE_STANDARD),
	BRONZE_SWORD(ItemID.BRONZE_SWORD, WeaponHitDelay.MELEE_STANDARD),
	CATTLEPROD(ItemID.CATTLEPROD, WeaponHitDelay.MELEE_STANDARD),
	CRYSTAL_HARPOON(ItemID.CRYSTAL_HARPOON, WeaponHitDelay.MELEE_STANDARD),
	DARK_DAGGER(ItemID.DARK_DAGGER, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_DAGGER(ItemID.DRAGON_DAGGER, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_DAGGER_20407(ItemID.DRAGON_DAGGER_20407, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_DAGGER_CR(ItemID.DRAGON_DAGGER_CR, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_DAGGER_PCR(ItemID.DRAGON_DAGGER_PCR, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_DAGGER_PCR_28023(ItemID.DRAGON_DAGGER_PCR_28023, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_DAGGER_PCR_28025(ItemID.DRAGON_DAGGER_PCR_28025, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_DAGGERP(ItemID.DRAGON_DAGGERP, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_DAGGERP_5680(ItemID.DRAGON_DAGGERP_5680, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_DAGGERP_5698(ItemID.DRAGON_DAGGERP_5698, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_HARPOON(ItemID.DRAGON_HARPOON, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_HARPOON_OR(ItemID.DRAGON_HARPOON_OR, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_HARPOON_OR_30349(ItemID.DRAGON_HARPOON_OR_30349, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_SWORD(ItemID.DRAGON_SWORD, WeaponHitDelay.MELEE_STANDARD),
	DRAGON_SWORD_CR(ItemID.DRAGON_SWORD_CR, WeaponHitDelay.MELEE_STANDARD),
	DUAL_SAI(ItemID.DUAL_SAI, WeaponHitDelay.MELEE_STANDARD),
	EGG_WHISK(ItemID.EGG_WHISK, WeaponHitDelay.MELEE_STANDARD),
	GHRAZI_RAPIER(ItemID.GHRAZI_RAPIER, WeaponHitDelay.MELEE_STANDARD),
	GHRAZI_RAPIER_23628(ItemID.GHRAZI_RAPIER_23628, WeaponHitDelay.MELEE_STANDARD),
	GLOWING_DAGGER(ItemID.GLOWING_DAGGER, WeaponHitDelay.MELEE_STANDARD),
	HOLY_GHRAZI_RAPIER(ItemID.HOLY_GHRAZI_RAPIER, WeaponHitDelay.MELEE_STANDARD),
	INFERNAL_HARPOON(ItemID.INFERNAL_HARPOON, WeaponHitDelay.MELEE_STANDARD),
	INFERNAL_HARPOON_OR(ItemID.INFERNAL_HARPOON_OR, WeaponHitDelay.MELEE_STANDARD),
	INFERNAL_HARPOON_OR_30342(ItemID.INFERNAL_HARPOON_OR_30342, WeaponHitDelay.MELEE_STANDARD),
	IRON_DAGGER(ItemID.IRON_DAGGER, WeaponHitDelay.MELEE_STANDARD),
	IRON_DAGGERP(ItemID.IRON_DAGGERP, WeaponHitDelay.MELEE_STANDARD),
	IRON_DAGGERP_5668(ItemID.IRON_DAGGERP_5668, WeaponHitDelay.MELEE_STANDARD),
	IRON_DAGGERP_5686(ItemID.IRON_DAGGERP_5686, WeaponHitDelay.MELEE_STANDARD),
	IRON_SWORD(ItemID.IRON_SWORD, WeaponHitDelay.MELEE_STANDARD),
	KERIS(ItemID.KERIS, WeaponHitDelay.MELEE_STANDARD),
	KERISP(ItemID.KERISP, WeaponHitDelay.MELEE_STANDARD),
	KERISP_10583(ItemID.KERISP_10583, WeaponHitDelay.MELEE_STANDARD),
	KERISP_10584(ItemID.KERISP_10584, WeaponHitDelay.MELEE_STANDARD),
	KILLERS_KNIFE(ItemID.KILLERS_KNIFE, WeaponHitDelay.MELEE_STANDARD),
	KITCHEN_KNIFE(ItemID.KITCHEN_KNIFE, WeaponHitDelay.MELEE_STANDARD),
	LEAFBLADED_SWORD(ItemID.LEAFBLADED_SWORD, WeaponHitDelay.MELEE_STANDARD),
	MAGIC_SECATEURS(ItemID.MAGIC_SECATEURS, WeaponHitDelay.MELEE_STANDARD),
	MITHRIL_DAGGER(ItemID.MITHRIL_DAGGER, WeaponHitDelay.MELEE_STANDARD),
	MITHRIL_DAGGERP(ItemID.MITHRIL_DAGGERP, WeaponHitDelay.MELEE_STANDARD),
	MITHRIL_DAGGERP_5674(ItemID.MITHRIL_DAGGERP_5674, WeaponHitDelay.MELEE_STANDARD),
	MITHRIL_DAGGERP_5692(ItemID.MITHRIL_DAGGERP_5692, WeaponHitDelay.MELEE_STANDARD),
	MITHRIL_SWORD(ItemID.MITHRIL_SWORD, WeaponHitDelay.MELEE_STANDARD),
	OSMUMTENS_FANG(ItemID.OSMUMTENS_FANG, WeaponHitDelay.MELEE_STANDARD),
	OSMUMTENS_FANG_OR(ItemID.OSMUMTENS_FANG_OR, WeaponHitDelay.MELEE_STANDARD),
	RAPIER(ItemID.RAPIER, WeaponHitDelay.MELEE_STANDARD),
	RUNE_DAGGER(ItemID.RUNE_DAGGER, WeaponHitDelay.MELEE_STANDARD),
	RUNE_DAGGERP(ItemID.RUNE_DAGGERP, WeaponHitDelay.MELEE_STANDARD),
	RUNE_DAGGERP_5678(ItemID.RUNE_DAGGERP_5678, WeaponHitDelay.MELEE_STANDARD),
	RUNE_DAGGERP_5696(ItemID.RUNE_DAGGERP_5696, WeaponHitDelay.MELEE_STANDARD),
	RUNE_SWORD(ItemID.RUNE_SWORD, WeaponHitDelay.MELEE_STANDARD),
	SPORK(ItemID.SPORK, WeaponHitDelay.MELEE_STANDARD),
	STEEL_DAGGER(ItemID.STEEL_DAGGER, WeaponHitDelay.MELEE_STANDARD),
	STEEL_DAGGERP(ItemID.STEEL_DAGGERP, WeaponHitDelay.MELEE_STANDARD),
	STEEL_DAGGERP_5672(ItemID.STEEL_DAGGERP_5672, WeaponHitDelay.MELEE_STANDARD),
	STEEL_DAGGERP_5690(ItemID.STEEL_DAGGERP_5690, WeaponHitDelay.MELEE_STANDARD),
	STEEL_SWORD(ItemID.STEEL_SWORD, WeaponHitDelay.MELEE_STANDARD),
	SUNLIGHT_SPEAR(ItemID.SUNLIGHT_SPEAR, WeaponHitDelay.MELEE_STANDARD),
	SWIFT_BLADE(ItemID.SWIFT_BLADE, WeaponHitDelay.MELEE_STANDARD),
	TOKTZXILAK(ItemID.TOKTZXILAK, WeaponHitDelay.MELEE_STANDARD),
	TRAINING_SWORD(ItemID.TRAINING_SWORD, WeaponHitDelay.MELEE_STANDARD),
	WHITE_DAGGER(ItemID.WHITE_DAGGER, WeaponHitDelay.MELEE_STANDARD),
	WHITE_DAGGERP(ItemID.WHITE_DAGGERP, WeaponHitDelay.MELEE_STANDARD),
	WHITE_DAGGERP_6595(ItemID.WHITE_DAGGERP_6595, WeaponHitDelay.MELEE_STANDARD),
	WHITE_DAGGERP_6597(ItemID.WHITE_DAGGERP_6597, WeaponHitDelay.MELEE_STANDARD),
	WILDERNESS_SWORD(ItemID.WILDERNESS_SWORD, WeaponHitDelay.MELEE_STANDARD),
	WILDERNESS_SWORD_1(ItemID.WILDERNESS_SWORD_1, WeaponHitDelay.MELEE_STANDARD),
	WILDERNESS_SWORD_2(ItemID.WILDERNESS_SWORD_2, WeaponHitDelay.MELEE_STANDARD),
	WILDERNESS_SWORD_3(ItemID.WILDERNESS_SWORD_3, WeaponHitDelay.MELEE_STANDARD),
	WILDERNESS_SWORD_4(ItemID.WILDERNESS_SWORD_4, WeaponHitDelay.MELEE_STANDARD),
	WOLFBANE(ItemID.WOLFBANE, WeaponHitDelay.MELEE_STANDARD),
	WOODEN_SWORD(ItemID.WOODEN_SWORD, WeaponHitDelay.MELEE_STANDARD),

	//UNARMED
	ALE_OF_THE_GODS(ItemID.ALE_OF_THE_GODS, WeaponHitDelay.MELEE_STANDARD),
	ANCIENT_GORILLA_GREEGREE(ItemID.ANCIENT_GORILLA_GREEGREE, WeaponHitDelay.MELEE_STANDARD),
	BEARDED_GORILLA_GREEGREE(ItemID.BEARDED_GORILLA_GREEGREE, WeaponHitDelay.MELEE_STANDARD),
	BRUMA_TORCH(ItemID.BRUMA_TORCH, WeaponHitDelay.MELEE_STANDARD),
	BUTLERS_TRAY(ItemID.BUTLERS_TRAY, WeaponHitDelay.MELEE_STANDARD),
	CHAOTIC_HANDEGG(ItemID.CHAOTIC_HANDEGG, WeaponHitDelay.MELEE_STANDARD),
	CORMORANTS_GLOVE(ItemID.CORMORANTS_GLOVE, WeaponHitDelay.MELEE_STANDARD),
	CRATE_WITH_ZANIK(ItemID.CRATE_WITH_ZANIK, WeaponHitDelay.MELEE_STANDARD),
	CRYSTAL_GRAIL(ItemID.CRYSTAL_GRAIL, WeaponHitDelay.MELEE_STANDARD),
	ENCHANTED_LYRE(ItemID.ENCHANTED_LYRE, WeaponHitDelay.MELEE_STANDARD),
	ENCHANTED_LYRE1(ItemID.ENCHANTED_LYRE1, WeaponHitDelay.MELEE_STANDARD),
	ENCHANTED_LYRE2(ItemID.ENCHANTED_LYRE2, WeaponHitDelay.MELEE_STANDARD),
	ENCHANTED_LYRE3(ItemID.ENCHANTED_LYRE3, WeaponHitDelay.MELEE_STANDARD),
	ENCHANTED_LYRE4(ItemID.ENCHANTED_LYRE4, WeaponHitDelay.MELEE_STANDARD),
	ENCHANTED_LYRE5(ItemID.ENCHANTED_LYRE5, WeaponHitDelay.MELEE_STANDARD),
	ENCHANTED_LYREI(ItemID.ENCHANTED_LYREI, WeaponHitDelay.MELEE_STANDARD),
	FALCONERS_GLOVE(ItemID.FALCONERS_GLOVE, WeaponHitDelay.MELEE_STANDARD),
	GNOMEBALL(ItemID.GNOMEBALL, WeaponHitDelay.MELEE_STANDARD),
	GOBLIN_PAINT_CANNON(ItemID.GOBLIN_PAINT_CANNON, WeaponHitDelay.MELEE_STANDARD),
	GORILLA_GREEGREE(ItemID.GORILLA_GREEGREE, WeaponHitDelay.MELEE_STANDARD),
	HEATPROOF_VESSEL(ItemID.HEATPROOF_VESSEL, WeaponHitDelay.MELEE_STANDARD),
	ODDSKULL(ItemID.ODDSKULL, WeaponHitDelay.MELEE_STANDARD),
	OILY_PEARL_FISHING_ROD(ItemID.OILY_PEARL_FISHING_ROD, WeaponHitDelay.MELEE_STANDARD),
	PEACEFUL_HANDEGG(ItemID.PEACEFUL_HANDEGG, WeaponHitDelay.MELEE_STANDARD),
	PEARL_BARBARIAN_ROD(ItemID.PEARL_BARBARIAN_ROD, WeaponHitDelay.MELEE_STANDARD),
	PEARL_FISHING_ROD(ItemID.PEARL_FISHING_ROD, WeaponHitDelay.MELEE_STANDARD),
	PEARL_FLY_FISHING_ROD(ItemID.PEARL_FLY_FISHING_ROD, WeaponHitDelay.MELEE_STANDARD),
	PET_ROCK(ItemID.PET_ROCK, WeaponHitDelay.MELEE_STANDARD),
	PREFORM(ItemID.PREFORM, WeaponHitDelay.MELEE_STANDARD),
	PUGEL(ItemID.PUGEL, WeaponHitDelay.MELEE_STANDARD),
	SKIS(ItemID.SKIS, WeaponHitDelay.MELEE_STANDARD),
	SLED(ItemID.SLED, WeaponHitDelay.MELEE_STANDARD),
	SLED_4084(ItemID.SLED_4084, WeaponHitDelay.MELEE_STANDARD),
	SLED_25282(ItemID.SLED_25282, WeaponHitDelay.MELEE_STANDARD),
	SNOWBALL(ItemID.SNOWBALL, WeaponHitDelay.MELEE_STANDARD),
	ZOMBIE_MONKEY_GREEGREE(ItemID.ZOMBIE_MONKEY_GREEGREE, WeaponHitDelay.MELEE_STANDARD),
	ZOMBIE_MONKEY_GREEGREE_4030(ItemID.ZOMBIE_MONKEY_GREEGREE_4030, WeaponHitDelay.MELEE_STANDARD),

	//WHIPS
	ABYSSAL_TENTACLE(ItemID.ABYSSAL_TENTACLE, WeaponHitDelay.MELEE_STANDARD),
	ABYSSAL_TENTACLE_OR(ItemID.ABYSSAL_TENTACLE_OR, WeaponHitDelay.MELEE_STANDARD),
	ABYSSAL_WHIP(ItemID.ABYSSAL_WHIP, WeaponHitDelay.MELEE_STANDARD),
	ABYSSAL_WHIP_4178(ItemID.ABYSSAL_WHIP_4178, WeaponHitDelay.MELEE_STANDARD),
	ABYSSAL_WHIP_20405(ItemID.ABYSSAL_WHIP_20405, WeaponHitDelay.MELEE_STANDARD),
	ABYSSAL_WHIP_OR(ItemID.ABYSSAL_WHIP_OR, WeaponHitDelay.MELEE_STANDARD),
	FROZEN_ABYSSAL_WHIP(ItemID.FROZEN_ABYSSAL_WHIP, WeaponHitDelay.MELEE_STANDARD),
	VOLCANIC_ABYSSAL_WHIP(ItemID.VOLCANIC_ABYSSAL_WHIP, WeaponHitDelay.MELEE_STANDARD),

	/*RANGED*/
	_3RD_AGE_BOW(ItemID._3RD_AGE_BOW, WeaponHitDelay.RANGED_STANDARD),
	BONE_SHORTBOW(ItemID.BONE_SHORTBOW, WeaponHitDelay.RANGED_STANDARD),
	BOW_OF_FAERDHINEN(ItemID.BOW_OF_FAERDHINEN, WeaponHitDelay.RANGED_STANDARD),
	BOW_OF_FAERDHINEN_27187(ItemID.BOW_OF_FAERDHINEN_27187, WeaponHitDelay.RANGED_STANDARD),
	BOW_OF_FAERDHINEN_C(ItemID.BOW_OF_FAERDHINEN_C, WeaponHitDelay.RANGED_STANDARD),
	BOW_OF_FAERDHINEN_C_25869(ItemID.BOW_OF_FAERDHINEN_C_25869, WeaponHitDelay.RANGED_STANDARD),
	BOW_OF_FAERDHINEN_C_25884(ItemID.BOW_OF_FAERDHINEN_C_25884, WeaponHitDelay.RANGED_STANDARD),
	BOW_OF_FAERDHINEN_C_25886(ItemID.BOW_OF_FAERDHINEN_C_25886, WeaponHitDelay.RANGED_STANDARD),
	BOW_OF_FAERDHINEN_C_25888(ItemID.BOW_OF_FAERDHINEN_C_25888, WeaponHitDelay.RANGED_STANDARD),
	BOW_OF_FAERDHINEN_C_25890(ItemID.BOW_OF_FAERDHINEN_C_25890, WeaponHitDelay.RANGED_STANDARD),
	BOW_OF_FAERDHINEN_C_25892(ItemID.BOW_OF_FAERDHINEN_C_25892, WeaponHitDelay.RANGED_STANDARD),
	BOW_OF_FAERDHINEN_C_25894(ItemID.BOW_OF_FAERDHINEN_C_25894, WeaponHitDelay.RANGED_STANDARD),
	BOW_OF_FAERDHINEN_C_25896(ItemID.BOW_OF_FAERDHINEN_C_25896, WeaponHitDelay.RANGED_STANDARD),
	COMP_OGRE_BOW(ItemID.COMP_OGRE_BOW, WeaponHitDelay.RANGED_STANDARD),
	CORRUPTED_DARK_BOW(ItemID.CORRUPTED_DARK_BOW, 0, WeaponHitDelay.RANGED_STANDARD, WeaponHitDelay.RANGED_STANDARD),
	CORRUPTED_TWISTED_BOW(ItemID.CORRUPTED_TWISTED_BOW, WeaponHitDelay.RANGED_STANDARD),
	CRAWS_BOW(ItemID.CRAWS_BOW, WeaponHitDelay.RANGED_STANDARD),
	CRYSTAL_BOW(ItemID.CRYSTAL_BOW, WeaponHitDelay.RANGED_STANDARD),
	CRYSTAL_BOW_110(ItemID.CRYSTAL_BOW_110, WeaponHitDelay.RANGED_STANDARD),
	CRYSTAL_BOW_110_I(ItemID.CRYSTAL_BOW_110_I, WeaponHitDelay.RANGED_STANDARD),
	CRYSTAL_BOW_210(ItemID.CRYSTAL_BOW_210, WeaponHitDelay.RANGED_STANDARD),
	CRYSTAL_BOW_210_I(ItemID.CRYSTAL_BOW_210_I, WeaponHitDelay.RANGED_STANDARD),
	CRYSTAL_BOW_310(ItemID.CRYSTAL_BOW_310, WeaponHitDelay.RANGED_STANDARD),
	CRYSTAL_BOW_310_I(ItemID.CRYSTAL_BOW_310_I, WeaponHitDelay.RANGED_STANDARD),
	CRYSTAL_BOW_410(ItemID.CRYSTAL_BOW_410, WeaponHitDelay.RANGED_STANDARD),
	CRYSTAL_BOW_410_I(ItemID.CRYSTAL_BOW_410_I, WeaponHitDelay.RANGED_STANDARD),
	CRYSTAL_BOW_510(ItemID.CRYSTAL_BOW_510, WeaponHitDelay.RANGED_STANDARD),
	CRYSTAL_BOW_510_I(ItemID.CRYSTAL_BOW_510_I, WeaponHitDelay.RANGED_STANDARD),
	CRYSTAL_BOW_610(ItemID.CRYSTAL_BOW_610, WeaponHitDelay.RANGED_STANDARD),
	CRYSTAL_BOW_610_I(ItemID.CRYSTAL_BOW_610_I, WeaponHitDelay.RANGED_STANDARD),
	CRYSTAL_BOW_710(ItemID.CRYSTAL_BOW_710, WeaponHitDelay.RANGED_STANDARD),
	CRYSTAL_BOW_710_I(ItemID.CRYSTAL_BOW_710_I, WeaponHitDelay.RANGED_STANDARD),
	CRYSTAL_BOW_810(ItemID.CRYSTAL_BOW_810, WeaponHitDelay.RANGED_STANDARD),
	CRYSTAL_BOW_810_I(ItemID.CRYSTAL_BOW_810_I, WeaponHitDelay.RANGED_STANDARD),
	CRYSTAL_BOW_910(ItemID.CRYSTAL_BOW_910, WeaponHitDelay.RANGED_STANDARD),
	CRYSTAL_BOW_910_I(ItemID.CRYSTAL_BOW_910_I, WeaponHitDelay.RANGED_STANDARD),
	CRYSTAL_BOW_24123(ItemID.CRYSTAL_BOW_24123, WeaponHitDelay.RANGED_STANDARD),
	CRYSTAL_BOW_FULL(ItemID.CRYSTAL_BOW_FULL, WeaponHitDelay.RANGED_STANDARD),
	CRYSTAL_BOW_FULL_I(ItemID.CRYSTAL_BOW_FULL_I, WeaponHitDelay.RANGED_STANDARD),
	CURSED_GOBLIN_BOW(ItemID.CURSED_GOBLIN_BOW, WeaponHitDelay.RANGED_STANDARD),
	DARK_BOW(ItemID.DARK_BOW, WeaponHitDelay.RANGED_STANDARD),
	DARK_BOW_12765(ItemID.DARK_BOW_12765, WeaponHitDelay.RANGED_STANDARD),
	DARK_BOW_12766(ItemID.DARK_BOW_12766, WeaponHitDelay.RANGED_STANDARD),
	DARK_BOW_12767(ItemID.DARK_BOW_12767, WeaponHitDelay.RANGED_STANDARD),
	DARK_BOW_12768(ItemID.DARK_BOW_12768, WeaponHitDelay.RANGED_STANDARD),
	DARK_BOW_20408(ItemID.DARK_BOW_20408, WeaponHitDelay.RANGED_STANDARD),
	DARK_BOW_BH(ItemID.DARK_BOW_BH, WeaponHitDelay.RANGED_STANDARD),
	DARK_BOW_DEADMAN(ItemID.DARK_BOW_DEADMAN, WeaponHitDelay.RANGED_STANDARD),
	ECHO_VENATOR_BOW(ItemID.ECHO_VENATOR_BOW, WeaponHitDelay.RANGED_STANDARD),
	ECLIPSE_ATLATL(ItemID.ECLIPSE_ATLATL, WeaponHitDelay.RANGED_STANDARD),
	ECLIPSE_ATLATL_29851(ItemID.ECLIPSE_ATLATL_29851, WeaponHitDelay.RANGED_STANDARD),
	LONGBOW(ItemID.LONGBOW, WeaponHitDelay.RANGED_STANDARD),
	MAGIC_COMP_BOW(ItemID.MAGIC_COMP_BOW, WeaponHitDelay.RANGED_STANDARD),
	MAGIC_LONGBOW(ItemID.MAGIC_LONGBOW, WeaponHitDelay.RANGED_STANDARD),
	MAGIC_SHORTBOW(ItemID.MAGIC_SHORTBOW, WeaponHitDelay.RANGED_STANDARD),
	MAGIC_SHORTBOW_I(ItemID.MAGIC_SHORTBOW_I, WeaponHitDelay.RANGED_STANDARD),
	MAGIC_SHORTBOW_20558(ItemID.MAGIC_SHORTBOW_20558, WeaponHitDelay.RANGED_STANDARD),
	MAPLE_LONGBOW(ItemID.MAPLE_LONGBOW, WeaponHitDelay.RANGED_STANDARD),
	MAPLE_SHORTBOW(ItemID.MAPLE_SHORTBOW, WeaponHitDelay.RANGED_STANDARD),
	MAPLE_SHORTBOW_20403(ItemID.MAPLE_SHORTBOW_20403, WeaponHitDelay.RANGED_STANDARD),
	OAK_LONGBOW(ItemID.OAK_LONGBOW, WeaponHitDelay.RANGED_STANDARD),
	OAK_SHORTBOW(ItemID.OAK_SHORTBOW, WeaponHitDelay.RANGED_STANDARD),
	OGRE_BOW(ItemID.OGRE_BOW, WeaponHitDelay.RANGED_STANDARD),
	RAIN_BOW(ItemID.RAIN_BOW, WeaponHitDelay.RANGED_STANDARD),
	SCORCHING_BOW(ItemID.SCORCHING_BOW, WeaponHitDelay.RANGED_STANDARD),
	SEERCULL(ItemID.SEERCULL, WeaponHitDelay.RANGED_STANDARD),
	SHORTBOW(ItemID.SHORTBOW, WeaponHitDelay.RANGED_STANDARD),
	SIGNED_OAK_BOW(ItemID.SIGNED_OAK_BOW, WeaponHitDelay.RANGED_STANDARD),
	STARTER_BOW(ItemID.STARTER_BOW, WeaponHitDelay.RANGED_STANDARD),
	TRAINING_BOW(ItemID.TRAINING_BOW, WeaponHitDelay.RANGED_STANDARD),
	TWISTED_BOW(ItemID.TWISTED_BOW, WeaponHitDelay.RANGED_STANDARD),
	VENATOR_BOW(ItemID.VENATOR_BOW, WeaponHitDelay.RANGED_STANDARD),
	WEBWEAVER_BOW(ItemID.WEBWEAVER_BOW, 0, WeaponHitDelay.RANGED_STANDARD, WeaponHitDelay.RANGED_WEBWEAVER_SPECIAL),
	WILLOW_COMP_BOW(ItemID.WILLOW_COMP_BOW, WeaponHitDelay.RANGED_STANDARD),
	WILLOW_LONGBOW(ItemID.WILLOW_LONGBOW, WeaponHitDelay.RANGED_STANDARD),
	WILLOW_SHORTBOW(ItemID.WILLOW_SHORTBOW, WeaponHitDelay.RANGED_STANDARD),
	YEW_COMP_BOW(ItemID.YEW_COMP_BOW, WeaponHitDelay.RANGED_STANDARD),
	YEW_LONGBOW(ItemID.YEW_LONGBOW, WeaponHitDelay.RANGED_STANDARD),
	YEW_SHORTBOW(ItemID.YEW_SHORTBOW, WeaponHitDelay.RANGED_STANDARD),
	YEW_SHORTBOW_20401(ItemID.YEW_SHORTBOW_20401, WeaponHitDelay.RANGED_STANDARD),
	ZARYTE_BOW(ItemID.ZARYTE_BOW, WeaponHitDelay.RANGED_STANDARD),
	ZARYTE_BOW_26239(ItemID.ZARYTE_BOW_26239, WeaponHitDelay.RANGED_STANDARD),

	//CHINCHOMPAS
	BLACK_CHINCHOMPA(ItemID.BLACK_CHINCHOMPA, WeaponHitDelay.RANGED_THROWN),
	CHINCHOMPA(ItemID.CHINCHOMPA, WeaponHitDelay.RANGED_THROWN),
	RED_CHINCHOMPA(ItemID.RED_CHINCHOMPA, WeaponHitDelay.RANGED_THROWN),

	//CROSSBOWS
	ADAMANT_CROSSBOW(ItemID.ADAMANT_CROSSBOW, WeaponHitDelay.RANGED_STANDARD),
	ARMADYL_CROSSBOW(ItemID.ARMADYL_CROSSBOW, 0, WeaponHitDelay.RANGED_STANDARD, WeaponHitDelay.RANGED_ACB_ZZB_SPECIAL),
	ARMADYL_CROSSBOW_23611(ItemID.ARMADYL_CROSSBOW_23611, 0, WeaponHitDelay.RANGED_STANDARD, WeaponHitDelay.RANGED_ACB_ZZB_SPECIAL),
	BLURITE_CROSSBOW(ItemID.BLURITE_CROSSBOW, WeaponHitDelay.RANGED_STANDARD),
	BRONZE_CROSSBOW(ItemID.BRONZE_CROSSBOW, WeaponHitDelay.RANGED_STANDARD),
	CROSSBOW(ItemID.CROSSBOW, WeaponHitDelay.RANGED_STANDARD),
	DORGESHUUN_CROSSBOW(ItemID.DORGESHUUN_CROSSBOW, WeaponHitDelay.RANGED_STANDARD),
	DRAGON_CROSSBOW(ItemID.DRAGON_CROSSBOW, WeaponHitDelay.RANGED_STANDARD),
	DRAGON_CROSSBOW_CR(ItemID.DRAGON_CROSSBOW_CR, WeaponHitDelay.RANGED_STANDARD),
	DRAGON_HUNTER_CROSSBOW(ItemID.DRAGON_HUNTER_CROSSBOW, WeaponHitDelay.RANGED_STANDARD),
	DRAGON_HUNTER_CROSSBOW_B(ItemID.DRAGON_HUNTER_CROSSBOW_B, WeaponHitDelay.RANGED_STANDARD),
	DRAGON_HUNTER_CROSSBOW_T(ItemID.DRAGON_HUNTER_CROSSBOW_T, WeaponHitDelay.RANGED_STANDARD),
	HEAVY_BALLISTA(ItemID.HEAVY_BALLISTA, WeaponHitDelay.RANGED_BALLISTAE),
	HEAVY_BALLISTA_23630(ItemID.HEAVY_BALLISTA_23630, WeaponHitDelay.RANGED_BALLISTAE),
	HEAVY_BALLISTA_OR(ItemID.HEAVY_BALLISTA_OR, WeaponHitDelay.RANGED_BALLISTAE),
	HUNTERS_CROSSBOW(ItemID.HUNTERS_CROSSBOW, WeaponHitDelay.RANGED_STANDARD),
	HUNTERS_SUNLIGHT_CROSSBOW(ItemID.HUNTERS_SUNLIGHT_CROSSBOW, WeaponHitDelay.RANGED_STANDARD),
	IRON_CROSSBOW(ItemID.IRON_CROSSBOW, WeaponHitDelay.RANGED_STANDARD),
	KARILS_CROSSBOW(ItemID.KARILS_CROSSBOW, WeaponHitDelay.RANGED_STANDARD),
	KARILS_CROSSBOW_100(ItemID.KARILS_CROSSBOW_100, WeaponHitDelay.RANGED_STANDARD),
	KARILS_CROSSBOW_75(ItemID.KARILS_CROSSBOW_75, WeaponHitDelay.RANGED_STANDARD),
	KARILS_CROSSBOW_50(ItemID.KARILS_CROSSBOW_50, WeaponHitDelay.RANGED_STANDARD),
	KARILS_CROSSBOW_25(ItemID.KARILS_CROSSBOW_25, WeaponHitDelay.RANGED_STANDARD),
	KARILS_CROSSBOW_0(ItemID.KARILS_CROSSBOW_0, WeaponHitDelay.RANGED_STANDARD),
	LIGHT_BALLISTA(ItemID.LIGHT_BALLISTA, WeaponHitDelay.RANGED_BALLISTAE),
	LIGHT_BALLISTA_27188(ItemID.LIGHT_BALLISTA_27188, WeaponHitDelay.RANGED_BALLISTAE),
	MITHRIL_CROSSBOW(ItemID.MITHRIL_CROSSBOW, WeaponHitDelay.RANGED_STANDARD),
	PHOENIX_CROSSBOW(ItemID.PHOENIX_CROSSBOW, WeaponHitDelay.RANGED_STANDARD),
	PHOENIX_CROSSBOW_11165(ItemID.PHOENIX_CROSSBOW_11165, WeaponHitDelay.RANGED_STANDARD),
	PHOENIX_CROSSBOW_11167(ItemID.PHOENIX_CROSSBOW_11167, WeaponHitDelay.RANGED_STANDARD),
	RUNE_CROSSBOW(ItemID.RUNE_CROSSBOW, WeaponHitDelay.RANGED_STANDARD),
	RUNE_CROSSBOW_23601(ItemID.RUNE_CROSSBOW_23601, WeaponHitDelay.RANGED_STANDARD),
	RUNE_CROSSBOW_OR(ItemID.RUNE_CROSSBOW_OR, WeaponHitDelay.RANGED_STANDARD),
	STEEL_CROSSBOW(ItemID.STEEL_CROSSBOW, WeaponHitDelay.RANGED_STANDARD),
	ZARYTE_CROSSBOW(ItemID.ZARYTE_CROSSBOW, 0, WeaponHitDelay.RANGED_STANDARD, WeaponHitDelay.RANGED_ACB_ZZB_SPECIAL),
	ZARYTE_CROSSBOW_27186(ItemID.ZARYTE_CROSSBOW_27186, 0, WeaponHitDelay.RANGED_STANDARD, WeaponHitDelay.RANGED_ACB_ZZB_SPECIAL),

	//THROWN
	ADAMANT_DART(ItemID.ADAMANT_DART, WeaponHitDelay.RANGED_THROWN),
	ADAMANT_DARTP(ItemID.ADAMANT_DARTP, WeaponHitDelay.RANGED_THROWN),
	ADAMANT_DARTP_5633(ItemID.ADAMANT_DARTP_5633, WeaponHitDelay.RANGED_THROWN),
	ADAMANT_DARTP_5640(ItemID.ADAMANT_DARTP_5640, WeaponHitDelay.RANGED_THROWN),
	ADAMANT_KNIFE(ItemID.ADAMANT_KNIFE, WeaponHitDelay.RANGED_THROWN),
	ADAMANT_KNIFEP(ItemID.ADAMANT_KNIFEP, WeaponHitDelay.RANGED_THROWN),
	ADAMANT_KNIFEP_5659(ItemID.ADAMANT_KNIFEP_5659, WeaponHitDelay.RANGED_THROWN),
	ADAMANT_KNIFEP_5666(ItemID.ADAMANT_KNIFEP_5666, WeaponHitDelay.RANGED_THROWN),
	ADAMANT_THROWNAXE(ItemID.ADAMANT_THROWNAXE, WeaponHitDelay.RANGED_THROWN),
	AMETHYST_DART(ItemID.AMETHYST_DART, WeaponHitDelay.RANGED_THROWN),
	AMETHYST_DARTP(ItemID.AMETHYST_DARTP, WeaponHitDelay.RANGED_THROWN),
	AMETHYST_DARTP_25855(ItemID.AMETHYST_DARTP_25855, WeaponHitDelay.RANGED_THROWN),
	AMETHYST_DARTP_25857(ItemID.AMETHYST_DARTP_25857, WeaponHitDelay.RANGED_THROWN),
	BLACK_DART(ItemID.BLACK_DART, WeaponHitDelay.RANGED_THROWN),
	BLACK_DARTP(ItemID.BLACK_DARTP, WeaponHitDelay.RANGED_THROWN),
	BLACK_DARTP_5633(ItemID.BLACK_DARTP_5631, WeaponHitDelay.RANGED_THROWN),
	BLACK_DARTP_5640(ItemID.BLACK_DARTP_5638, WeaponHitDelay.RANGED_THROWN),
	BLACK_KNIFE(ItemID.BLACK_KNIFE, WeaponHitDelay.RANGED_THROWN),
	BLACK_KNIFEP(ItemID.BLACK_KNIFEP, WeaponHitDelay.RANGED_THROWN),
	BLACK_KNIFEP_5658(ItemID.BLACK_KNIFEP_5658, WeaponHitDelay.RANGED_THROWN),
	BLACK_KNIFEP_5665(ItemID.BLACK_KNIFEP_5665, WeaponHitDelay.RANGED_THROWN),
	BLAZING_BLOWPIPE(ItemID.BLAZING_BLOWPIPE, 0, WeaponHitDelay.RANGED_THROWN, WeaponHitDelay.RANGED_BLOWPIPE_SPECIAL),
	BRONZE_DART(ItemID.BRONZE_DART, WeaponHitDelay.RANGED_THROWN),
	BRONZE_DARTP(ItemID.BRONZE_DARTP, WeaponHitDelay.RANGED_THROWN),
	BRONZE_DARTP_5628(ItemID.BRONZE_DARTP_5628, WeaponHitDelay.RANGED_THROWN),
	BRONZE_DARTP_5635(ItemID.BRONZE_DARTP_5635, WeaponHitDelay.RANGED_THROWN),
	BRONZE_KNIFE(ItemID.BRONZE_KNIFE, WeaponHitDelay.RANGED_THROWN),
	BRONZE_KNIFEP(ItemID.BRONZE_KNIFEP, WeaponHitDelay.RANGED_THROWN),
	BRONZE_KNIFEP_5654(ItemID.BRONZE_KNIFEP_5654, WeaponHitDelay.RANGED_THROWN),
	BRONZE_KNIFEP_5661(ItemID.BRONZE_KNIFEP_5661, WeaponHitDelay.RANGED_THROWN),
	BRONZE_THROWNAXE(ItemID.BRONZE_THROWNAXE, WeaponHitDelay.RANGED_THROWN),
	DRAGON_DART(ItemID.DRAGON_DART, WeaponHitDelay.RANGED_THROWN),
	DRAGON_DARTP(ItemID.DRAGON_DARTP, WeaponHitDelay.RANGED_THROWN),
	DRAGON_DARTP_11233(ItemID.DRAGON_DARTP_11233, WeaponHitDelay.RANGED_THROWN),
	DRAGON_DARTP_11234(ItemID.DRAGON_DARTP_11234, WeaponHitDelay.RANGED_THROWN),
	DRAGON_KNIFE(ItemID.DRAGON_KNIFE, WeaponHitDelay.RANGED_THROWN),
	DRAGON_KNIFE_22812(ItemID.DRAGON_KNIFE_22812, WeaponHitDelay.RANGED_THROWN),
	DRAGON_KNIFE_22814(ItemID.DRAGON_KNIFE_22814, WeaponHitDelay.RANGED_THROWN),
	DRAGON_KNIFE_27157(ItemID.DRAGON_KNIFE_27157, WeaponHitDelay.RANGED_THROWN),
	DRAGON_KNIFEP(ItemID.DRAGON_KNIFEP, WeaponHitDelay.RANGED_THROWN),
	DRAGON_KNIFEP_22808(ItemID.DRAGON_KNIFEP_22808, WeaponHitDelay.RANGED_THROWN),
	DRAGON_KNIFEP_22810(ItemID.DRAGON_KNIFEP_22810, WeaponHitDelay.RANGED_THROWN),
	DRAGON_THROWNAXE(ItemID.DRAGON_THROWNAXE, WeaponHitDelay.RANGED_THROWN),
	DRYGORE_BLOWPIPE(ItemID.DRYGORE_BLOWPIPE, 0, WeaponHitDelay.RANGED_THROWN, WeaponHitDelay.RANGED_BLOWPIPE_SPECIAL),
	HOLY_WATER(ItemID.HOLY_WATER, WeaponHitDelay.RANGED_THROWN),
	HUNTERS_SPEAR(ItemID.HUNTERS_SPEAR, WeaponHitDelay.RANGED_THROWN),
	IRON_DART(ItemID.IRON_DART, WeaponHitDelay.RANGED_THROWN),
	IRON_DART_P(ItemID.IRON_DART_P, WeaponHitDelay.RANGED_THROWN),
	IRON_DARTP(ItemID.IRON_DARTP, WeaponHitDelay.RANGED_THROWN),
	IRON_DARTP_5636(ItemID.IRON_DARTP_5636, WeaponHitDelay.RANGED_THROWN),
	IRON_KNIFE(ItemID.IRON_KNIFE, WeaponHitDelay.RANGED_THROWN),
	IRON_KNIFEP(ItemID.IRON_KNIFEP, WeaponHitDelay.RANGED_THROWN),
	IRON_KNIFEP_5655(ItemID.IRON_KNIFEP_5655, WeaponHitDelay.RANGED_THROWN),
	IRON_KNIFEP_5662(ItemID.IRON_KNIFEP_5662, WeaponHitDelay.RANGED_THROWN),
	IRON_THROWNAXE(ItemID.IRON_THROWNAXE, WeaponHitDelay.RANGED_THROWN),
	MITHRIL_DART(ItemID.MITHRIL_DART, WeaponHitDelay.RANGED_THROWN),
	MITHRIL_DARTP(ItemID.MITHRIL_DARTP, WeaponHitDelay.RANGED_THROWN),
	MITHRIL_DARTP_5632(ItemID.MITHRIL_DARTP_5632, WeaponHitDelay.RANGED_THROWN),
	MITHRIL_DARTP_5639(ItemID.MITHRIL_DARTP_5639, WeaponHitDelay.RANGED_THROWN),
	MITHRIL_KNIFE(ItemID.MITHRIL_KNIFE, WeaponHitDelay.RANGED_THROWN),
	MITHRIL_KNIFEP(ItemID.MITHRIL_KNIFEP, WeaponHitDelay.RANGED_THROWN),
	MITHRIL_KNIFEP_5657(ItemID.MITHRIL_KNIFEP_5657, WeaponHitDelay.RANGED_THROWN),
	MITHRIL_KNIFEP_5664(ItemID.MITHRIL_KNIFEP_5664, WeaponHitDelay.RANGED_THROWN),
	MITHRIL_THROWNAXE(ItemID.MITHRIL_THROWNAXE, WeaponHitDelay.RANGED_THROWN),
	MORRIGANS_JAVELIN(ItemID.MORRIGANS_JAVELIN, WeaponHitDelay.RANGED_THROWN),
	MORRIGANS_JAVELIN_23619(ItemID.MORRIGANS_JAVELIN_23619, WeaponHitDelay.RANGED_THROWN),
	MORRIGANS_JAVELIN_BH(ItemID.MORRIGANS_JAVELIN_BH, WeaponHitDelay.RANGED_THROWN),
	MORRIGANS_THROWING_AXE(ItemID.MORRIGANS_THROWING_AXE, WeaponHitDelay.RANGED_THROWN),
	MORRIGANS_THROWING_AXE_BH(ItemID.MORRIGANS_THROWING_AXE_BH, WeaponHitDelay.RANGED_THROWN),
	MUD_PIE(ItemID.MUD_PIE, WeaponHitDelay.RANGED_THROWN),
	RUNE_DART(ItemID.RUNE_DART, WeaponHitDelay.RANGED_THROWN),
	RUNE_DARTP(ItemID.RUNE_DARTP, WeaponHitDelay.RANGED_THROWN),
	RUNE_DARTP_5634(ItemID.RUNE_DARTP_5634, WeaponHitDelay.RANGED_THROWN),
	RUNE_DARTP_5641(ItemID.RUNE_DARTP_5641, WeaponHitDelay.RANGED_THROWN),
	RUNE_KNIFE(ItemID.RUNE_KNIFE, WeaponHitDelay.RANGED_THROWN),
	RUNE_KNIFEP(ItemID.RUNE_KNIFEP, WeaponHitDelay.RANGED_THROWN),
	RUNE_KNIFEP_5660(ItemID.RUNE_KNIFEP_5660, WeaponHitDelay.RANGED_THROWN),
	RUNE_KNIFEP_5667(ItemID.RUNE_KNIFEP_5667, WeaponHitDelay.RANGED_THROWN),
	RUNE_THROWNAXE(ItemID.RUNE_THROWNAXE, WeaponHitDelay.RANGED_THROWN),
	STEEL_DART(ItemID.STEEL_DART, WeaponHitDelay.RANGED_THROWN),
	STEEL_DARTP(ItemID.STEEL_DARTP, WeaponHitDelay.RANGED_THROWN),
	STEEL_DARTP_5630(ItemID.STEEL_DARTP_5630, WeaponHitDelay.RANGED_THROWN),
	STEEL_DARTP_5637(ItemID.STEEL_DARTP_5637, WeaponHitDelay.RANGED_THROWN),
	STEEL_KNIFE(ItemID.STEEL_KNIFE, WeaponHitDelay.RANGED_THROWN),
	STEEL_KNIFEP(ItemID.STEEL_KNIFEP, WeaponHitDelay.RANGED_THROWN),
	STEEL_KNIFEP_5656(ItemID.STEEL_KNIFEP_5656, WeaponHitDelay.RANGED_THROWN),
	STEEL_KNIFEP_5663(ItemID.STEEL_KNIFEP_5663, WeaponHitDelay.RANGED_THROWN),
	STEEL_THROWNAXE(ItemID.STEEL_THROWNAXE, WeaponHitDelay.RANGED_THROWN),
	TOKTZXILUL(ItemID.TOKTZXILUL, WeaponHitDelay.RANGED_THROWN),
	TONALZTICS_OF_RALOS(ItemID.TONALZTICS_OF_RALOS, WeaponHitDelay.RANGED_TONALZTICS_OF_RALOS),
	TOXIC_BLOWPIPE(ItemID.TOXIC_BLOWPIPE, 0, WeaponHitDelay.RANGED_THROWN, WeaponHitDelay.RANGED_BLOWPIPE_SPECIAL),

	/*MAGIC*/
	//BLADED STAVES
	BLUE_MOON_SPEAR(ItemID.BLUE_MOON_SPEAR, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	BLUE_MOON_SPEAR_29849(ItemID.BLUE_MOON_SPEAR_29849, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	STAFF_OF_BALANCE(ItemID.STAFF_OF_BALANCE, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	STAFF_OF_LIGHT(ItemID.STAFF_OF_LIGHT, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	STAFF_OF_THE_DEAD(ItemID.STAFF_OF_THE_DEAD, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	STAFF_OF_THE_DEAD_23613(ItemID.STAFF_OF_THE_DEAD_23613, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	TOXIC_STAFF_OF_THE_DEAD(ItemID.TOXIC_STAFF_OF_THE_DEAD, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),

	//POWERED STAVES
	ACCURSED_SCEPTRE(ItemID.ACCURSED_SCEPTRE, WeaponHitDelay.MAGIC_STANDARD),
	ACCURSED_SCEPTRE_U(ItemID.ACCURSED_SCEPTRE_U, WeaponHitDelay.MAGIC_STANDARD),
	BONE_STAFF(ItemID.BONE_STAFF, WeaponHitDelay.MAGIC_STANDARD),
	CORRUPTED_TUMEKENS_SHADOW(ItemID.CORRUPTED_TUMEKENS_SHADOW, WeaponHitDelay.MAGIC_TUMEKENS_SHADOW),
	DAWNBRINGER(ItemID.DAWNBRINGER, WeaponHitDelay.MAGIC_STANDARD),
	HOLY_SANGUINESTI_STAFF(ItemID.HOLY_SANGUINESTI_STAFF, WeaponHitDelay.MAGIC_STANDARD),
	SANGUINESTI_STAFF(ItemID.SANGUINESTI_STAFF, WeaponHitDelay.MAGIC_STANDARD),
	STARTER_STAFF(ItemID.STARTER_STAFF, WeaponHitDelay.MAGIC_STANDARD),
	THAMMARONS_SCEPTRE(ItemID.THAMMARONS_SCEPTRE, WeaponHitDelay.MAGIC_STANDARD),
	THAMMARONS_SCEPTRE_U(ItemID.THAMMARONS_SCEPTRE_U, WeaponHitDelay.MAGIC_STANDARD),
	TRIDENT_OF_THE_SEAS(ItemID.TRIDENT_OF_THE_SEAS, WeaponHitDelay.MAGIC_STANDARD),
	TRIDENT_OF_THE_SEAS_E(ItemID.TRIDENT_OF_THE_SEAS_E, WeaponHitDelay.MAGIC_STANDARD),
	TRIDENT_OF_THE_SEAS_FULL(ItemID.TRIDENT_OF_THE_SEAS_FULL, WeaponHitDelay.MAGIC_STANDARD),
	TRIDENT_OF_THE_SWAMP(ItemID.TRIDENT_OF_THE_SWAMP, WeaponHitDelay.MAGIC_STANDARD),
	TRIDENT_OF_THE_SWAMP_E(ItemID.TRIDENT_OF_THE_SWAMP_E, WeaponHitDelay.MAGIC_STANDARD),
	TUMEKENS_SHADOW(ItemID.TUMEKENS_SHADOW, WeaponHitDelay.MAGIC_TUMEKENS_SHADOW),
	WARPED_SCEPTRE(ItemID.WARPED_SCEPTRE, WeaponHitDelay.MAGIC_STANDARD),

	//STAVES
	_3RD_AGE_DRUIDIC_STAFF(ItemID._3RD_AGE_DRUIDIC_STAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	_3RD_AGE_WAND(ItemID._3RD_AGE_WAND, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	ACCURSED_SCEPTRE_A(ItemID.ACCURSED_SCEPTRE_A, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	AHRIMS_STAFF(ItemID.AHRIMS_STAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	AHRIMS_STAFF_23653(ItemID.AHRIMS_STAFF_23653, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	AHRIMS_STAFF_100(ItemID.AHRIMS_STAFF_100, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	AHRIMS_STAFF_75(ItemID.AHRIMS_STAFF_75, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	AHRIMS_STAFF_50(ItemID.AHRIMS_STAFF_50, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	AHRIMS_STAFF_25(ItemID.AHRIMS_STAFF_25, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	AHRIMS_STAFF_0(ItemID.AHRIMS_STAFF_0, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	AIR_BATTLESTAFF(ItemID.AIR_BATTLESTAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	ANCIENT_CROZIER(ItemID.ANCIENT_CROZIER, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	ANCIENT_SCEPTRE(ItemID.ANCIENT_SCEPTRE, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	ANCIENT_STAFF(ItemID.ANCIENT_STAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	ANCIENT_STAFF_20431(ItemID.ANCIENT_STAFF_20431, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	APPRENTICE_WAND(ItemID.APPRENTICE_WAND, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	APPRENTICE_WAND_20556(ItemID.APPRENTICE_WAND_20556, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	ARMADYL_CROZIER(ItemID.ARMADYL_CROZIER, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	BANDOS_CROZIER(ItemID.BANDOS_CROZIER, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	BATTLESTAFF(ItemID.BATTLESTAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	BEGINNER_WAND(ItemID.BEGINNER_WAND, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	BEGINNER_WAND_20553(ItemID.BEGINNER_WAND_20553, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	BLISTERWOOD_FLAIL(ItemID.BLISTERWOOD_FLAIL, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	BLOOD_ANCIENT_SCEPTRE(ItemID.BLOOD_ANCIENT_SCEPTRE, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	BLOOD_ANCIENT_SCEPTRE_28260(ItemID.BLOOD_ANCIENT_SCEPTRE_28260, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	BLOOD_ANCIENT_SCEPTRE_L(ItemID.BLOOD_ANCIENT_SCEPTRE_L, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	BRYOPHYTAS_STAFF(ItemID.BRYOPHYTAS_STAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	CORRUPTED_VOLATILE_NIGHTMARE_STAFF(ItemID.CORRUPTED_VOLATILE_NIGHTMARE_STAFF, 0, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE, WeaponHitDelay.MAGIC_GRASP_DEMONBANE_NIGHTMARE_STAFF_SPECIALS),
	CURSED_GOBLIN_STAFF(ItemID.CURSED_GOBLIN_STAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	DRAGON_HUNTER_WAND(ItemID.DRAGON_HUNTER_WAND, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	DUST_BATTLESTAFF(ItemID.DUST_BATTLESTAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	ELDRITCH_NIGHTMARE_STAFF(ItemID.ELDRITCH_NIGHTMARE_STAFF, 0, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE, WeaponHitDelay.MAGIC_GRASP_DEMONBANE_NIGHTMARE_STAFF_SPECIALS),
	FIRE_BATTLESTAFF(ItemID.FIRE_BATTLESTAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	GUTHIX_CROZIER(ItemID.GUTHIX_CROZIER, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	GUTHIX_STAFF(ItemID.GUTHIX_STAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	HARMONISED_NIGHTMARE_STAFF(ItemID.HARMONISED_NIGHTMARE_STAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	IBANS_STAFF(ItemID.IBANS_STAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	IBANS_STAFF_1410(ItemID.IBANS_STAFF_1410, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	IBANS_STAFF_U(ItemID.IBANS_STAFF_U, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	ICE_ANCIENT_SCEPTRE(ItemID.ICE_ANCIENT_SCEPTRE, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	IVANDIS_FLAIL(ItemID.IVANDIS_FLAIL, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	KODAI_WAND(ItemID.KODAI_WAND, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	KODAI_WAND_23626(ItemID.KODAI_WAND_23626, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	LAVA_BATTLESTAFF(ItemID.LAVA_BATTLESTAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	LAVA_BATTLESTAFF_21198(ItemID.LAVA_BATTLESTAFF_21198, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	LUNAR_STAFF(ItemID.LUNAR_STAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	LUNAR_STAFF__PT1(ItemID.LUNAR_STAFF__PT1, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	LUNAR_STAFF__PT2(ItemID.LUNAR_STAFF__PT2, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	LUNAR_STAFF__PT3(ItemID.LUNAR_STAFF__PT3, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	MAGIC_STAFF(ItemID.MAGIC_STAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	MASTER_WAND(ItemID.MASTER_WAND, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	MIST_BATTLESTAFF(ItemID.MIST_BATTLESTAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	MUD_BATTLESTAFF(ItemID.MUD_BATTLESTAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	MYSTIC_AIR_STAFF(ItemID.MYSTIC_AIR_STAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	MYSTIC_DUST_STAFF(ItemID.MYSTIC_DUST_STAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	MYSTIC_EARTH_STAFF(ItemID.MYSTIC_EARTH_STAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	MYSTIC_FIRE_STAFF(ItemID.MYSTIC_FIRE_STAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	MYSTIC_LAVA_STAFF(ItemID.MYSTIC_LAVA_STAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	MYSTIC_LAVA_STAFF_21200(ItemID.MYSTIC_LAVA_STAFF_21200, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	MYSTIC_MIST_STAFF(ItemID.MYSTIC_MIST_STAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	MYSTIC_MUD_STAFF(ItemID.MYSTIC_MUD_STAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	MYSTIC_SMOKE_STAFF(ItemID.MYSTIC_SMOKE_STAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	MYSTIC_STEAM_STAFF(ItemID.MYSTIC_STEAM_STAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	MYSTIC_STEAM_STAFF_12796(ItemID.MYSTIC_STEAM_STAFF_12796, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	MYSTIC_WATER_STAFF(ItemID.MYSTIC_WATER_STAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	NIGHTMARE_STAFF(ItemID.NIGHTMARE_STAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	PURGING_STAFF(ItemID.PURGING_STAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	ROD_OF_IVANDIS_1(ItemID.ROD_OF_IVANDIS_1, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	ROD_OF_IVANDIS_2(ItemID.ROD_OF_IVANDIS_2, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	ROD_OF_IVANDIS_3(ItemID.ROD_OF_IVANDIS_3, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	ROD_OF_IVANDIS_4(ItemID.ROD_OF_IVANDIS_4, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	ROD_OF_IVANDIS_5(ItemID.ROD_OF_IVANDIS_5, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	ROD_OF_IVANDIS_6(ItemID.ROD_OF_IVANDIS_6, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	ROD_OF_IVANDIS_7(ItemID.ROD_OF_IVANDIS_7, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	ROD_OF_IVANDIS_8(ItemID.ROD_OF_IVANDIS_8, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	ROD_OF_IVANDIS_9(ItemID.ROD_OF_IVANDIS_9, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	ROD_OF_IVANDIS_10(ItemID.ROD_OF_IVANDIS_10, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	SARADOMIN_CROZIER(ItemID.SARADOMIN_CROZIER, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	SARADOMIN_STAFF(ItemID.SARADOMIN_STAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	SHADOW_ANCIENT_SCEPTRE(ItemID.SHADOW_ANCIENT_SCEPTRE, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	SHADOW_ANCIENT_SCEPTRE_28266(ItemID.SHADOW_ANCIENT_SCEPTRE_28266, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	SHADOW_ANCIENT_SCEPTRE_L(ItemID.SHADOW_ANCIENT_SCEPTRE_L, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	SKULL_SCEPTRE(ItemID.SKULL_SCEPTRE, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	SKULL_SCEPTRE_I(ItemID.SKULL_SCEPTRE_I, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	SLAYERS_STAFF(ItemID.SLAYERS_STAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	SLAYERS_STAFF_E(ItemID.SLAYERS_STAFF_E, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	SMOKE_ANCIENT_SCEPTRE(ItemID.SMOKE_ANCIENT_SCEPTRE, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	SMOKE_ANCIENT_SCEPTRE_28264(ItemID.SMOKE_ANCIENT_SCEPTRE_28264, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	SMOKE_ANCIENT_SCEPTRE_L(ItemID.SMOKE_ANCIENT_SCEPTRE_L, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	SMOKE_BATTLESTAFF(ItemID.SMOKE_BATTLESTAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	STAFF(ItemID.STAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	STAFF_OF_AIR(ItemID.STAFF_OF_AIR, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	STAFF_OF_BOB_THE_CAT(ItemID.STAFF_OF_BOB_THE_CAT, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	STAFF_OF_FIRE(ItemID.STAFF_OF_FIRE, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	STAFF_OF_WATER(ItemID.STAFF_OF_WATER, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	STEAM_BATTLESTAFF(ItemID.STEAM_BATTLESTAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	STEAM_BATTLESTAFF_12795(ItemID.STEAM_BATTLESTAFF_12795, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	TEACHER_WAND(ItemID.TEACHER_WAND, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	THAMMARONS_SCEPTRE_A(ItemID.THAMMARONS_SCEPTRE_A, WeaponHitDelay.MAGIC_STANDARD),
	TOKTZMEJTAL(ItemID.TOKTZMEJTAL, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	TWINFLAME_STAFF(ItemID.TWINFLAME_STAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	VOID_KNIGHT_MACE(ItemID.VOID_KNIGHT_MACE, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	VOID_KNIGHT_MACE_L(ItemID.VOID_KNIGHT_MACE_L, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	VOLATILE_NIGHTMARE_STAFF(ItemID.VOLATILE_NIGHTMARE_STAFF, 0, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE, WeaponHitDelay.MAGIC_GRASP_DEMONBANE_NIGHTMARE_STAFF_SPECIALS),
	VOLATILE_NIGHTMARE_STAFF_25517(ItemID.VOLATILE_NIGHTMARE_STAFF_25517, 0, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE, WeaponHitDelay.MAGIC_GRASP_DEMONBANE_NIGHTMARE_STAFF_SPECIALS),
	VOLATILE_NIGHTMARE_STAFF_DEADMAN(ItemID.VOLATILE_NIGHTMARE_STAFF_DEADMAN, 0, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE, WeaponHitDelay.MAGIC_GRASP_DEMONBANE_NIGHTMARE_STAFF_SPECIALS),
	WATER_BATTLESTAFF(ItemID.WATER_BATTLESTAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	WHITE_MAGIC_STAFF(ItemID.WHITE_MAGIC_STAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	ZAMORAK_CROZIER(ItemID.ZAMORAK_CROZIER, WeaponHitDelay.MAGIC_STANDARD),
	ZAMORAK_STAFF(ItemID.ZAMORAK_STAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	ZURIELS_STAFF(ItemID.ZURIELS_STAFF, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),
	ZURIELS_STAFF_23617(ItemID.ZURIELS_STAFF_23617, WeaponHitDelay.MAGIC_STANDARD),
	ZURIELS_STAFF_BH(ItemID.ZURIELS_STAFF_BH, WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE),

	/*OTHER*/
	BLACK_SALAMANDER(ItemID.BLACK_SALAMANDER, WeaponHitDelay.MELEE_STANDARD),
	ORANGE_SALAMANDER(ItemID.ORANGE_SALAMANDER, WeaponHitDelay.MELEE_STANDARD),
	RED_SALAMANDER(ItemID.RED_SALAMANDER, WeaponHitDelay.MELEE_STANDARD),
	SWAMP_LIZARD(ItemID.SWAMP_LIZARD, WeaponHitDelay.MELEE_STANDARD),
	TECU_SALAMANDER(ItemID.TECU_SALAMANDER, WeaponHitDelay.MELEE_STANDARD),
	NATURES_REPRISAL(ItemID.NATURES_REPRISAL, WeaponHitDelay.MELEE_STANDARD),

	/*FISTS*/
	FISTS(-1, WeaponHitDelay.MELEE_STANDARD);

	private final int weaponID;
	private final int specialAttackAnimation;
	private final WeaponHitDelay standardHitDelay;
	private final WeaponHitDelay specialHitDelay;

	Weapons(int weaponID, int specialAttackAnimation, WeaponHitDelay standardHitDelay, WeaponHitDelay specialHitDelay)
	{
		this.weaponID = weaponID;
		this.specialAttackAnimation = specialAttackAnimation;
		this.standardHitDelay = standardHitDelay;
		this.specialHitDelay = specialHitDelay;
	}

	Weapons(int weaponID, WeaponHitDelay standardHitDelay)
	{
		this.weaponID = weaponID;
		this.specialAttackAnimation = 0;
		this.standardHitDelay = standardHitDelay;
		this.specialHitDelay = WeaponHitDelay.NOT_APPLICABLE;

	}

	//enables the weapons to be looked up at O(1) speed.
	private static final Map<Integer, Weapons> lookup = new HashMap<>();

	static
	{
		for (Weapons weapon : Weapons.values())
		{
			lookup.put(weapon.weaponID, weapon);
		}
	}

	public static Weapons getByItemID(int itemID) {
		return lookup.get(itemID);
	}

	public boolean doesAnimationMatchSpecialAnimation(int animationID)
	{
		return animationID > 0 && animationID == specialAttackAnimation;
	}
}

/*
 * Copyright (c) 2023, Callum Rossiter
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.skulltimer.enums.equipment;

import lombok.Getter;

/**
 * An enum used to calculate when a weapon should expect to see a hit.
 */
@Getter
public enum WeaponHitDelay
{
	MELEE_STANDARD(AttackType.MELEE)
	{
		@Override
		public int calculateHitDelay(int distance)
		{
			return 0;
		}
	},
	MELEE_DELAYED_SPECIAL(AttackType.MELEE)
	{
		@Override
		public int calculateHitDelay(int distance)
		{
			return 1;
		}
	},
	RANGED_STANDARD(AttackType.RANGED)
	{
		@Override
		public int calculateHitDelay(int distance)
		{
			return 1 + (3 + distance / 6);
		}
	},
	RANGED_ACB_ZZB_SPECIAL(AttackType.RANGED)
	{
		@Override
		public int calculateHitDelay(int distance)
		{
			return 2;
		}
	},
	RANGED_WEBWEAVER_SPECIAL(AttackType.RANGED)
	{
		@Override
		public int calculateHitDelay(int distance)
		{
			return 1;
		}
	},
	RANGED_THROWN(AttackType.RANGED)
	{
		@Override
		public int calculateHitDelay(int distance)
		{
			return 1 + (distance / 6);
		}
	},
	RANGED_BLOWPIPE_SPECIAL(AttackType.RANGED)
	{
		@Override
		public int calculateHitDelay(int distance)
		{
			if (distance == 4 || distance == 5) return 2;
			else return 1 + (distance / 6);
		}
	},
	RANGED_BALLISTAE(AttackType.RANGED)
	{
		@Override
		public int calculateHitDelay(int distance)
		{
			if (distance <= 4) return 2;
			else return 3;
		}
	},
	RANGED_TONALZTICS_OF_RALOS(AttackType.RANGED)
	{
		@Override
		public int calculateHitDelay(int distance)
		{
			return 2;
		}
	},
	MAGIC_STANDARD(AttackType.MAGIC)
	{
		@Override
		public int calculateHitDelay(int distance)
		{
			return 1 + (1 + distance / 3);
		}
	},
	MAGIC_STANDARD_WITH_MELEE(AttackType.MELEE)
	{
		@Override
		public int calculateHitDelay(int distance)
		{
			return 0;
		}
	},
	MAGIC_GRASP_DEMONBANE_NIGHTMARE_STAFF_SPECIALS(AttackType.MAGIC)
	{
		@Override
		public int calculateHitDelay(int distance)
		{
			return 2;
		}
	},
	MAGIC_TUMEKENS_SHADOW(AttackType.MAGIC)
	{
		@Override
		public int calculateHitDelay(int distance){
			return 2 + (1 + distance / 3);
		}
	},
	OTHER_SHIELD_SPECIALS(AttackType.MELEE)
	{
		@Override
		public int calculateHitDelay(int distance)
		{
			return 2 + (4 + distance / 6);
		}
	},
	NOT_APPLICABLE(AttackType.OTHER)
	{
		@Override
		public int calculateHitDelay(int distance)
		{
			return 0;
		}
	};

	private final AttackType attackType;
	public abstract int calculateHitDelay(int distance);

	WeaponHitDelay(AttackType attackType)
	{
		this.attackType = attackType;
	}
}

/*
 * Copyright (c) 2023, Callum Rossiter
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.skulltimer.enums.equipment;

import java.util.HashMap;
import java.util.Map;
import lombok.Getter;
import net.runelite.api.AnimationID;

/**
 * A list of animations that should not trigger an animation check.
 *
 * <p>This list maybe incomplete and the enum name may not be the exact weapon type, only the type of weapon/shield the animation corresponded to.</p>
 */

@Getter
public enum ExcludedAnimations
{
	IDLE(AnimationID.IDLE),
	UNARMED(424),
	DEFENDER(4177),
	SHIELD(1156),
	BULWARK(7512),
	_1H_SWORD(388),
	_2H_SWORD(7056),
	STAFF(420),
	HALBERD(430),
	FLAIL(8017),
	CHINCHOMPA(3176),
	WAND(415),
	WHIP(1659),
	TOOLS_PICKAXE_AXE(397),
	DAGGER(378),
	BLUDGEON(1666),
	CHAINMACE(7200),
	MACE(403),
	BATTLEAXE(397),
	BONEMACE(2063),
	ABBYSSAL_DAGGER(3295),
	DRAGON_2H_SWORD(410);


	private static final Map<Integer, ExcludedAnimations> EXCLUDED_MAP = new HashMap<>();

	static
	{
		for (ExcludedAnimations anim : values())
		{
			EXCLUDED_MAP.put(anim.id, anim);
		}
	}

	private final int id;

	ExcludedAnimations(int id)
	{
		this.id = id;
	}

	/**
	 * A method used to check if a given animation ID matches any excluded animation IDs.
	 * @param animationID The animation ID to check.
	 * @return {@code true} if the animation is to be excluded. Otherwise, returns {@code false}.
	 */
	public static boolean isExcluded(int animationID)
	{
		return EXCLUDED_MAP.containsKey(animationID);
	}
}

/*
 * Copyright (c) 2023, Callum Rossiter
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.skulltimer.enums.equipment;

/**
 * An enum for weapon attack types.
 */
public enum AttackType
{
	MELEE,
	RANGED,
	MAGIC,
	OTHER
}

/*
 * Copyright (c) 2023, Callum Rossiter
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.skulltimer.enums.equipment;

import java.util.Set;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

/**
 * A list of spells and their associated animation ID.
 */
@Slf4j
@Getter
public enum SpellAnimations
{
	/*
	 * Without Staff (Standard Spell Book):
	 * 	Strike, bolt, blast (711). Surge (7855),  Wave (727).
	 *  Confuse (716). Weaken (717). Curse, Vulnerability (718).
	 * 	Entangle, Snare, Bind (710).
	 *  Enfeeble (728), Stun (729), Crumble undead (724). Teleblock (1819).
	 *
	 * With Staff (Standard Spell Book):
	 *  Strike, bolt, blast (1162). Surge (7855),  Wave (1167).
	 *  Confuse (1163). Weaken (1164). Curse, Vulnerability (1165).
	 *  Entangle, Snare, Bind (1161).
	 *  Enfeeble (1168), Stun (1169), Crumble undead (1166).
	 *  Iban's Blast (708), God Spells (811), Slayer Dart (1576). Teleblock (1820).
	 *
	 * Ancient and Arceuus Spell Books:
	 *	Rush, Blitz (1978). Burst, Barrage (1979).
	 *  Grasp (8972). Demonbane (8977).
	 *
	 */
	STANDARD_NO_STAFF(WeaponHitDelay.MAGIC_STANDARD, Set.of(711, 7855, 727, 716, 717, 718, 710, 728, 729, 724, 1819)),
	STANDARD_WITH_STAFF(WeaponHitDelay.MAGIC_STANDARD, Set.of(1162, 7855, 1167, 1163, 1164, 1165, 1161, 1168, 1169, 1166, 708, 811, 1576, 1820)),
	ANCIENT(WeaponHitDelay.MAGIC_STANDARD, Set.of(1978, 1979)),
	GRASP_AND_DEMONBANE(WeaponHitDelay.MAGIC_GRASP_DEMONBANE_NIGHTMARE_STAFF_SPECIALS, Set.of(8972, 8977));

	private final WeaponHitDelay weaponHitDelay;
	private final Set<Integer> animationIDs;

	SpellAnimations(WeaponHitDelay weaponHitDelay, Set<Integer> animationIDs)
	{
		this.weaponHitDelay = weaponHitDelay;
		this.animationIDs = animationIDs;
	}

	public static WeaponHitDelay getSpellHitDelay(int animationID)
	{
		for (SpellAnimations animation : SpellAnimations.values())
		{
			if (animation.getAnimationIDs().contains(animationID))
			{
				log.debug("Spell animation found. Hit Delay: {}.", animation.getWeaponHitDelay());
				return animation.getWeaponHitDelay();
			}
		}

		return null;
	}
}

/*
 * Copyright (c) 2023, Callum Rossiter
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.skulltimer.enums.equipment;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

/**
 * A list of weapon categories to be used in place of concrete weapon implementations in the event a weapon type cannot be found.
 */
@Slf4j
@Getter
public enum GenericWeapons
{
	MELEE(WeaponHitDelay.MELEE_STANDARD, Set.of("sword", "axe", "bludgeon", "maul", "jack", "hammer", "bulwark", "claw", "halberd", "banner", "mjolnir", "scythe", "rapier", "machete", "scimitar", "sickle", "spear", "hasta", "dagger", "mace", "club", "harpoon", "whip", "flail", "katana")),
	RANGED(WeaponHitDelay.RANGED_STANDARD, Set.of("bow", "ballista", "chinchompa", "dart", "thrown", "throwing", "pipe")),
	MAGIC(WeaponHitDelay.MAGIC_STANDARD, Set.of("staff", "stave", "wand"));

	private final WeaponHitDelay weaponHitDelay;
	private final Set<String> weaponNameTags;

	//a lookup map to increase lookup speed
	private static final Map<String, WeaponHitDelay> weaponLookupMap = new HashMap<>();

	static
	{
		for (GenericWeapons weapon : GenericWeapons.values())
		{
			for (String tag : weapon.weaponNameTags)
			{
				weaponLookupMap.put(tag, weapon.weaponHitDelay);
			}
		}
	}

	GenericWeapons(WeaponHitDelay weaponHitDelay, Set<String> weaponNameTags)
	{
		this.weaponHitDelay = weaponHitDelay;
		this.weaponNameTags = weaponNameTags;
	}

	/**
	 * A method to get the hit delay for the given weapon name.
	 * @param weaponName The name of the weapon whose hit delay is to be searched for.
	 * @return The corresponding {@link WeaponHitDelay} for the given {@code weaponName}.
	 */
	public static WeaponHitDelay getWeaponTypeHitDelay(String weaponName)
	{
		if (weaponName.isEmpty())
		{
			return null;
		}

		String weaponNameLowerCase = weaponName.toLowerCase();

		for (String key : weaponLookupMap.keySet())
		{
			if (weaponNameLowerCase.contains(key))
			{
				log.debug("Generic weapon type found. Hit Delay: {}.", weaponLookupMap.get(key));
				return weaponLookupMap.get(key);
			}
		}
		return null;
	}
}

/*
 * Copyright (c) 2023, Callum Rossiter
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.skulltimer.enums;

import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

/**
 * An enumeration of locations that provide skulls.
 */
@Getter
public enum WorldAreas
{
	ABYSS(new WorldPoint(3009, 4803, 0), new WorldPoint(3070, 4862, 0));

	private final WorldPoint x;
	private final WorldPoint y;
	WorldAreas(WorldPoint x, WorldPoint y)
	{
		this.x = x;
		this.y = y;
	}
}

/*
 * Copyright (c) 2023, Callum Rossiter
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.skulltimer.enums;

import com.skulltimer.data.CombatInteraction;

/**
 * Represents the possible combat states of a player within a {@link CombatInteraction}.
 */
public enum CombatStatus
{
	ATTACKED,					// The player has been attacked by the local player.
	RETALIATED,					// The player has retaliated against the local player.
	DEAD,						// The player has died.
	UNCERTAIN,					// The players combat status is unknown.
	LOGGED_OUT,					// The player has logged out.
	INACTIVE,					// The player has previously retaliated/attacked, but has since logged out/left the local players view.
	ATTACKER					// The player has attacked the local player.
}

/*
 * Copyright (c) 2023, Callum Rossiter
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.skulltimer.enums;

import lombok.Getter;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;

/**
 * An enumeration of items that provide skull statues when equipped.
 */
@Getter
public enum SkulledItems
{
	AMULET_OF_AVARICE(ItemID.AMULET_OF_AVARICE, EquipmentInventorySlot.AMULET.getSlotIdx(), true),
	CAPE_OF_SKULLS(ItemID.CAPE_OF_SKULLS, EquipmentInventorySlot.CAPE.getSlotIdx(), false);

	private final int itemID;
	private final int itemSlot;
	/** A {@link Boolean} to check if the item provides a skull for an unlimited amount of time while equipped. */
	private final boolean isSkullIndefinite;

	SkulledItems(int itemID, int itemSlot, boolean isSkullIndefinite)
	{
		this.itemID = itemID;
		this.itemSlot = itemSlot;
		this.isSkullIndefinite = isSkullIndefinite;
	}
}

/*
 * Copyright (c) 2023, Callum Rossiter
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.skulltimer.managers;

import com.skulltimer.SkullTimerConfig;
import com.skulltimer.SkulledTimer;
import java.time.Duration;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import com.skulltimer.SkullTimerPlugin;

/**
 * An object that is used to manage the creation and removal of a {@link SkulledTimer} object.
 */
@Slf4j
public class TimerManager
{
	private final SkullTimerConfig config;
	private final InfoBoxManager infoBoxManager;
	private final ItemManager itemManager;
	private final SkullTimerPlugin skullTimerPlugin;
	private final StatusManager statusManager;
	@Getter
	private SkulledTimer timer;

	/**
	 * The constructor for a {@link TimerManager} object.
	 * @param skullTimerPlugin The plugin object.
	 * @param config The configuration file for the {@link SkullTimerPlugin}.
	 * @param infoBoxManager Runelite's {@link InfoBoxManager} object.
	 * @param itemManager Runelite's {@link ItemManager} object.
	 * @param statusManager A manager for tracking the players skulled duration.
	 *
	 */
	public TimerManager(SkullTimerPlugin skullTimerPlugin, SkullTimerConfig config, InfoBoxManager infoBoxManager, ItemManager itemManager, StatusManager statusManager)
	{
		this.skullTimerPlugin = skullTimerPlugin;
		this.config = config;
		this.infoBoxManager = infoBoxManager;
		this.itemManager = itemManager;
		this.statusManager = statusManager;
	}

	/**
	 * A method that creates and adds a timer to the clients infobox. <p>
	 *
	 * If there is an existing timer, it is removed using {@code RemoveTimer}. Checks are also performed to ensure that any
	 * timer created is not negative or that the timer is zero.
	 *
	 * @param timerDuration The {@link Duration} of the timer to be created.
	 */
	public void addTimer(Duration timerDuration) throws IllegalArgumentException
	{
		if (shouldTimerBeUpdated(timerDuration))
		{
			//removes the timer if a timer is already created.
			removeTimer(false);

			if (!timerDuration.isNegative() && !timerDuration.isZero())
			{
				timer = new SkulledTimer(timerDuration, itemManager, config, skullTimerPlugin);

				statusManager.setTimerEndTime(timer.getEndTime());
				infoBoxManager.addInfoBox(timer);
				log.debug("Skull timer started with {} minutes remaining.", getTimer().getRemainingTime().toMinutes());
			}
		}
	}

	/**
	 * A method that removes any existing timer.
	 * @param saveConfig A {@link Boolean} to determine if duration of the existing timer should be saved.
	 *                   If the value passed is {@code true} then the remaining time will be saved in the config file. Otherwise if {@code false}
	 *                   then the existing config will be overwritten with a duration of 0 minutes.
	 */

	public void removeTimer(boolean saveConfig) throws IllegalArgumentException
	{
		// Check if timer has duration remaining (boolean), set timer accordingly
		if (saveConfig)
		{
			log.debug("Saving existing timer duration: {}.", timer.getRemainingTime());
			config.skullDuration(timer.getRemainingTime());
		}
		else
		{
			log.debug("Setting config duration to default.");
			config.skullDuration(Duration.ZERO);
		}

		infoBoxManager.removeIf(t -> t instanceof SkulledTimer);
		timer = null;
		log.debug("Removed skull duration timer.");
	}

	/**
	 * A method used to determine if a new timer should be created by checking to see if the existing timer is lower than the proposed timer.
	 * @param newDuration The new {@link Duration} to replace the existing timers' duration.
	 * @return Returns {@code true} if the new duration is greater than the existing timer or if {@code timer} is null. Returns {@code false} if the new duration is lower than or equal to the old duration.
	 */
	private boolean shouldTimerBeUpdated(Duration newDuration)
	{
		if (timer != null && timer.getRemainingTime().compareTo(newDuration) > 0)
		{
			log.debug("Existing timer {} exceeds the duration of the proposed new timer {}. The timer will not be updated.", timer.getRemainingTime(), newDuration);
			return false;
		}
		return true;
	}
}

/*
 * Copyright (c) 2023, Callum Rossiter
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.skulltimer.managers;

import com.skulltimer.SkulledTimer;
import com.skulltimer.enums.TimerDurations;
import com.skulltimer.enums.WorldAreas;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.SkullIcon;
import net.runelite.api.Varbits;
import net.runelite.api.coords.WorldPoint;

/**
 * An object that is used to check a players world location to identify if a skull timer is required.
 */
@Slf4j
public class LocationManager
{
	private final Client client;
	private final TimerManager timerManager;
	@Setter
	private boolean hasBeenTeleportedIntoAbyss = false;
	private final static int playerRadius = 13;

	/**
	 * The constructor for a {@link LocationManager} object.
	 * @param client Runelite's {@link Client} object.
	 * @param timerManager The manager used to control the creation and deletion of {@link SkulledTimer} objects.
	 */
	public LocationManager(Client client, TimerManager timerManager)
	{
		this.client = client;
		this.timerManager = timerManager;
	}

	/**
	 * A method used to check if the player has been teleported into the abyss. If the player has been teleported into the abyss, a timer will be started.
	 */
	public boolean isInAbyss()
	{
		if (isInArea(WorldAreas.ABYSS.getX(), WorldAreas.ABYSS.getY(), getPlayersLocation()) && hasBeenTeleportedIntoAbyss &&
			client.getLocalPlayer().getSkullIcon() != SkullIcon.NONE)
		{
				hasBeenTeleportedIntoAbyss = false;
				log.debug("Player has been teleported into the abyss. Starting timer.");
				timerManager.addTimer(TimerDurations.ABYSS_DURATION.getDuration());
				return true;
		}
		else
		{
			hasBeenTeleportedIntoAbyss = false;
			return false;
		}
	}

	/**
	 * A method to calculate the distance between two players using the Chebyshev distance formula.
	 * @param playerOne The player to calculate the distance to.
	 * @param playerTwo The player to calculate the distance from.
	 * @return The distance between the two players. If either of the players are {@code null}, then a value of {@code 0} will be returned.
	 */
	public int calculateDistanceBetweenPlayers(Player playerOne, Player playerTwo)
	{
		if (playerOne == null || playerTwo == null) {return 0;}

		WorldPoint worldPointA = playerOne.getWorldLocation();
		WorldPoint worldPointB = playerTwo.getWorldLocation();

		if (worldPointA == null || worldPointB == null) {return 0;}

		return Math.max(
			Math.abs(worldPointA.getX() - worldPointB.getX()),
			Math.abs(worldPointA.getY() - worldPointB.getY())
		);
	}

	/**
	 * A method to check whether the player matches the conditions to be classified when logged out. (i.e. no animation and within the players expected sight.)
	 * @param player The {@link Player} whose location is to be checked.
	 * @return {@code true} if the {@code player} meets the conditions to be considered logging out. {@code false} if they do not.
	 */
	public boolean hasPlayerLoggedOut(Player player)
	{
		WorldPoint localPlayerWorldPoint = getPlayersLocation();

		if (localPlayerWorldPoint == null || player == null || player.getWorldLocation() == null)
		{
			return false;
		}

		WorldPoint playerWorldPoint = player.getWorldLocation();

		WorldPoint radiusPointA = new WorldPoint(localPlayerWorldPoint.getX() + playerRadius, localPlayerWorldPoint.getY() + playerRadius, localPlayerWorldPoint.getPlane());
		WorldPoint radiusPointB = new WorldPoint(localPlayerWorldPoint.getX() - playerRadius, localPlayerWorldPoint.getY() - playerRadius, localPlayerWorldPoint.getPlane());

		return isInArea(radiusPointA, radiusPointB, playerWorldPoint) && player.getAnimation() == -1;
	}

	/**
	 * A method to check to see if the current world point is within the given range.
	 * @param worldPointA The first world point.
	 * @param worldPointB The second world point.
	 * @param currentWorldPoint The world point to be checked.
	 * @return {@code true} if the {@code currentWorldPoint} is within the specified range. {@code false} if null or not within the given location.
	 */
	private boolean isInArea(WorldPoint worldPointA, WorldPoint worldPointB, WorldPoint currentWorldPoint)
	{
		if (worldPointA == null || worldPointB == null || currentWorldPoint == null)
		{
			return false;
		}

		return checkCoordinates(worldPointA.getX(), worldPointB.getX(), currentWorldPoint.getX())
			&& checkCoordinates(worldPointA.getY(), worldPointB.getY(), currentWorldPoint.getY())
			&& checkCoordinates(worldPointA.getPlane(), worldPointB.getPlane(), currentWorldPoint.getPlane());
	}

	/**
	 * A method to check to see if the current coordinate is within the given range.
	 * @param a The first coordinate.
	 * @param b The second coordinate.
	 * @param c The coordinate to be checked.
	 * @return {@code true} if the c coordinate is within the specified range. {@code false} if not.
	 */
	private boolean checkCoordinates(int a, int b, int c)
	{
		int lowest = Math.min(a, b);
		int largest = Math.max(a, b);
		return c >= lowest && c <= largest;
	}

	/**
	 * A method to get the {@link Player}'s location.
	 * @return The {@link Player}'s {@link WorldPoint} if the player is not null. Otherwise, returns {@code null}.
	 */
	private WorldPoint getPlayersLocation()
	{
		Player player = client.getLocalPlayer();

		if (player != null)
		{
			return player.getWorldLocation();
		}

		return null;
	}

	/**
	 * A method used to check if the player is in the wilderness.
	 * @return {@code true} if the player is in the wilderness, {@code false} if not.
	 */
	public boolean isInWilderness(){
		return client.getVarbitValue(Varbits.IN_WILDERNESS) == 1;
	}
}

/*
 * Copyright (c) 2023, Callum Rossiter
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.skulltimer.managers;

import com.skulltimer.SkullTimerConfig;
import com.skulltimer.SkullTimerPlugin;
import com.skulltimer.data.ExpectedHit;
import com.skulltimer.data.CombatInteraction;
import com.skulltimer.enums.CombatStatus;
import com.skulltimer.enums.TimerDurations;
import com.skulltimer.enums.equipment.AttackType;
import com.skulltimer.enums.equipment.WeaponHitDelay;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import com.skulltimer.SkulledTimer;
import net.runelite.api.Client;
import net.runelite.api.GraphicID;
import net.runelite.api.Player;
import net.runelite.api.SkullIcon;
import net.runelite.client.callback.ClientThread;

/**
 * An object that is used to manage combat scenarios to determine if a timer is required to be started.
 */
@Slf4j
public class CombatManager
{
	private final Client client;
	private final ClientThread clientThread;
	private final SkullTimerConfig config;
	private final TimerManager timerManager;
	private final StatusManager statusManager;
	private final EquipmentManager equipmentManager;
	@Getter
	private final HashMap<String, CombatInteraction> combatRecords;
	@Getter
	private final HashSet<String> interactionRecords;
	@Getter
	private final HashMap<Integer, Set<ExpectedHit>> attackRecords;
	/**
	 * The constructor for a {@link CombatManager} object.
	 * @param client Runelite's {@link Client} object.
	 * @param clientThread Runelite's {@link ClientThread} object.
	 * @param config The configuration file for the {@link SkullTimerPlugin}.
	 * @param timerManager The manager used to control the creation and deletion of {@link SkulledTimer} objects.
	 * @param statusManager The manager used to manage the plugins interaction with the player characters status.
	 * @param equipmentManager The manager used to manage events related to the players equipment.
	 *
	 */
	public CombatManager(Client client, ClientThread clientThread, SkullTimerConfig config, TimerManager timerManager, StatusManager statusManager, EquipmentManager equipmentManager)
	{
		this.client = client;
		this.clientThread = clientThread;
		this.config = config;
		this.timerManager = timerManager;
		this.statusManager = statusManager;
		this.equipmentManager = equipmentManager;
		this.combatRecords = new HashMap<>();
		this.interactionRecords = new HashSet<>();
		this.attackRecords = new HashMap<>();
	}

	/**
	 * A method to add/remove a record of any player who interacts with the local player.
	 * @param playerName The name of the player to add to the record.
	 * @param addPlayer A boolean to check if the player should be added or removed from the record.
	 */
	public void onPlayerInteractionChange(String playerName, boolean addPlayer)
	{
		if (addPlayer && interactionRecords.add(playerName)){
			log.debug("Adding {} to interaction records.", playerName);
		} else if (!addPlayer && interactionRecords.remove(playerName)){
			log.debug("Removing {} from interaction records.", playerName);
		}
	}

	/**
	 * A method that is used to update a players {@link CombatInteraction} in the {@code combatRecords}.
	 * @param playerName The name of the player who had this interaction.
	 */
	public void onConfirmedInCombat(String playerName)
	{
		CombatInteraction combatInteraction = combatRecords.get(playerName);

		//if the player does not already exist in the records, create a new record.
		if (combatInteraction == null){
			combatInteraction = new CombatInteraction();
			combatInteraction.setCombatStatus(CombatStatus.ATTACKER);
			combatRecords.put(playerName, combatInteraction);
		}

		//if the interaction is from a player who was in the target records, and they haven't previously responded, update their record
		if (shouldSetStatusToRetaliated(combatInteraction)){
			log.debug("Player {} already exists in target records. Updating target record to retaliated.", playerName);
			combatInteraction.setCombatStatus(CombatStatus.RETALIATED);
			//if the player is not a target then check if they should be classified as an attacker
		} else if (shouldSetStatusToAttacker(combatInteraction)){
			log.debug("Player {} exists in interaction records. Upgrading to attacker.", playerName);
			combatInteraction.setCombatStatus(CombatStatus.ATTACKER);
		}
	}

	/**
	 * A method to determine if the player meets the requirements to be considered an attacker.
	 * @param combatInteraction The {@link CombatInteraction} record if it exists.
	 * @return {@code true} if the player exists in {@code targetRecords} and their {@link CombatStatus} is {@code LOGGED_OUT}. Otherwise, returns {@code false}.
	 */
	private boolean shouldSetStatusToAttacker(CombatInteraction combatInteraction){
		//if the player had previously logged out, then
		return combatInteraction != null && combatInteraction.getCombatStatus() == CombatStatus.LOGGED_OUT;
	}

	/**
	 * A method to determine if the player meets the requirements to be set to the retaliated status.
	 * @param combatInteraction The {@link CombatInteraction} record if it exists.
	 * @return {@code true} if the {@code combatInteraction} is not {@code null} and their {@link CombatStatus} has not been set to {@code RETALIATED}.
	 */
	private boolean shouldSetStatusToRetaliated(CombatInteraction combatInteraction){
		//if the player the local player is targeting has a target interaction, and they have yet to be upgraded
		return combatInteraction != null && !combatInteraction.hasRetaliated();
	}

	/**
	 * A method to determine if the requirements are met to start a timer when the local player attacks another player.
	 *
	 * <p>
	 * The following are possible states the interaction could be in to determine if a timer should be started:
	 * <ol>
	 *     <li>The {@code player} does not exist in either the {@code attackerRecords} or {@code targetRecords}.</li>
	 *     <li>The {@code player} exists in the {@code targetRecords} and their {@link CombatStatus} is {@code DEAD}, {@code LOGGED_OUT} or variant of {@code RETALIATED}.</li>
	 *     <li>The {@code player} {@link CombatStatus} is a variant of {@code UNKNOWN} and the {@code localPlayer}'s {@link SkullIcon} is not {@code NONE}.</li>
	 * </ol>
	 * </p>
	 * @param player The {@link Player} who the hitsplat has been applied to.
	 * @param currentTick The {@link Integer} value representing the current tick number.
	 */
	public void onTargetHitsplat(Player player, int currentTick)
	{
		if (player.getName() == null || player.getName().isEmpty()){
			return;
		}

		String playerName = player.getName();

		if (!combatRecords.containsKey(playerName)) {
			log.debug("Target record created for player {}.", playerName);
			CombatInteraction combatInteraction = new CombatInteraction();
			combatRecords.put(player.getName(), combatInteraction);
			addTimerCheck();
			return;
		}

		CombatInteraction combatInteraction = combatRecords.get(playerName);

		//if the player has died at some point, even if they had retaliated, start a new timer
		if (combatInteraction.getCombatStatus() == CombatStatus.DEAD){
			log.debug("Player {} was previously killed. Starting timer.", playerName);
			combatInteraction.setCombatStatus(CombatStatus.ATTACKED);
			addTimerCheck();
		}

		//if the player has logged out at some point - the player can't attack them unless they retaliated
		else if (combatInteraction.getCombatStatus() == CombatStatus.LOGGED_OUT) {
			log.debug("Player {} was previously logged out. Starting timer.", playerName);
			combatInteraction.setCombatStatus(CombatStatus.ATTACKED);
			addTimerCheck();
		}

		//if the player has their status as uncertain or inactive, perform a further check.
		else if (combatInteraction.getCombatStatus() == CombatStatus.UNCERTAIN || combatInteraction.getCombatStatus() == CombatStatus.INACTIVE) {
			clientThread.invokeAtTickEnd(() -> onUnknownOrInactiveStatus(playerName, combatInteraction, currentTick));
		}

		//if the target has retaliated at any point during the fight, then a new timer will not be started
		else if (!combatInteraction.hasRetaliated()) {
			log.debug("Player {} has not retaliated. Starting timer.", playerName);
			addTimerCheck();
		}
		else
		{
			log.debug("Timer will not be started. {}'s combat status: {}.", playerName, combatInteraction.getCombatStatus());
		}
	}

	/**
	 * A method to try to identify what a players combat status should be set to if possible.
	 * If the local player doesn't have a skull after attacking the target player, the player's combat status is set to retaliated.
	 * If the local player does have a skull which started within the previous possible attack range, the players combat status is set to attacked and a timer is started.
	 * Otherwise, it is difficult to verify the players remaining time and therefore the timer may be inaccurate.
	 * @param targetPlayerName The name of the target player.
	 * @param combatInteraction The combat record associated with the player.
	 * @param currentTick The current tick number.
	 */
	private void onUnknownOrInactiveStatus(String targetPlayerName, CombatInteraction combatInteraction, int currentTick)
	{
		if (combatInteraction == null || currentTick == 0)
		{
			return;
		}

		Player localPlayer = client.getLocalPlayer();

		WeaponHitDelay weaponHitDelay = equipmentManager.getWeaponHitDelay(localPlayer);

		if (weaponHitDelay == null)
		{
			return;
		}

		int worstCaseDistance = 10;
		int worstCaseHitDelay = weaponHitDelay.calculateHitDelay(worstCaseDistance);
		int skullStatusStartTime = statusManager.getSkullIconTickStartTime();

		//checks to ensure that the hit occurred within the longest reasonable time a hit could have occurred.
		boolean isStartTimeWithinWorstCaseHitDelay = (skullStatusStartTime >= (currentTick - worstCaseHitDelay - 1)
			&& skullStatusStartTime <= currentTick);

		log.debug("Player has skull icon: {}. Is within worse case hit delay: {}. Worst case hit delay: {}. skullStatusStartTime: {}. Current tick: {}.",
			statusManager.doesPlayerCurrentlyHaveSkullIcon(), isStartTimeWithinWorstCaseHitDelay, worstCaseHitDelay, skullStatusStartTime, currentTick);

		//if player does not have skulled status - the player be considered retaliated - do not start timer.
		if (!statusManager.doesPlayerCurrentlyHaveSkullIcon())
		{
			log.debug("Player does not have skull. Setting {} status to retaliated.", targetPlayerName);
			combatInteraction.setCombatStatus(CombatStatus.RETALIATED);
		}
		//if the player does have skull status that started within worstCaseHitDelay - the player should be set to 'attacked' and timer started.
		else if (isStartTimeWithinWorstCaseHitDelay)
		{
			log.debug("Skull status started within expected time. Setting {} status to attacked.", targetPlayerName);
			combatInteraction.setCombatStatus(CombatStatus.ATTACKED);
			addTimerCheck();
		}
		//if the player has a skull, but the range is before then it's difficult to verify.
		else
		{
			//the previous combat status is used to determine what has the highest likelihood of being correct.
			CombatStatus combatStatus = combatInteraction.getCombatStatus();
			if (combatStatus == CombatStatus.INACTIVE) 
			{
				log.debug("Cannot verify {}'s status. Not starting timer but remaining inactive.", targetPlayerName);
			}
			else if (combatStatus == CombatStatus.UNCERTAIN)
			{
				log.debug("Cannot verify {}'s status. Starting timer but remaining uncertain.", targetPlayerName);
				addTimerCheck();
			}
		}
	}

	/**
	 * A method that is used to check if a hitsplat or splash has occurred when it was expected to.
	 * @param currentTick The current tick number.
	 * @param didHitSplatOccur A boolean to determine if a hitsplat occurred.
	 */
	public void onTickOfExpectedHit(int currentTick, boolean didHitSplatOccur)
	{
		for (Map.Entry<Integer, Set<ExpectedHit>> tick : getExpectedHits(currentTick).entrySet()){
			for (ExpectedHit hit : tick.getValue()){
				String playerName = hit.getPlayerName();
				int expectedHit = tick.getKey();
				boolean isSplashHit = hit.doesApplySplash() && client.getLocalPlayer().hasSpotAnim(GraphicID.SPLASH);

				//If the hit occurred either now or one tick late (because of the processing order delay), the attack will count as an attack
				if (didHitSplatOccur) {
					log.debug("Expected hit for player {} has occurred (current tick: {})", playerName, currentTick);
					onConfirmedInCombat(playerName);
				}
				//If there was not a hit, but the attack was magic based and splash was applied (and it was still within the expected time), this will also count
				else if (isSplashHit) {
					log.debug("Expected splash for player {} has occurred. (current tick: {}).", playerName, currentTick);
					onConfirmedInCombat(playerName);
				}
				//Due to PID delay, the attack can be delayed, so waiting an extra tick extra prevents premature deletion.
				else if (expectedHit == currentTick){
					log.debug("Expected hit for player {} did not occur (Expected: {} Current: {}).", playerName, expectedHit, currentTick);
				}
				//Remove the record.
				else {
					log.debug("Expected hit for player {} did not occur (Expected: {} Current: {}). Removing record.", playerName, expectedHit, currentTick);
					attackRecords.get(currentTick - 1).remove(hit);
				}
			}
		}
	}

	/**
	 * A method used to set the expected hit value when an attack occurs.
	 * @param playerName The name of the player who started the animation.
	 * @param expectedHitTick The tick number of when the attack can be expected to land.
	 * @param attackType The type of attack style the hit applied.
	 * @return {@code true} if the record was added successfully. Returns {@code false} if the interaction record does not contain the {@code playerName}.
	 */
	public boolean addExpectedHitTick(String playerName, int expectedHitTick, AttackType attackType)
	{
		if (interactionRecords.contains(playerName))
		{
			ExpectedHit expectedHit = new ExpectedHit(playerName, attackType);
			attackRecords.computeIfAbsent(expectedHitTick, r -> new HashSet<>()).add(expectedHit);
			return true;
		}
		return false;
	}

	/**
	 * A method used to get the expected hits on a given tick.
	 * @param currentTick The number of the current tick.
	 * @return A {@link HashMap} containing all {@link ExpectedHit} expected within the {@code currentTick} or {@code currentTick - 1}.
	 */
	private HashMap<Integer, Set<ExpectedHit>> getExpectedHits(int currentTick)
	{
		return attackRecords.entrySet().stream()
			.filter(entry -> entry.getKey() == currentTick || entry.getKey() == currentTick - 1)
			.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (a, b) -> b, HashMap::new));
	}

	/**
	 * A method to determine if a timer should be started.
	 */
	private void addTimerCheck()
	{
		if (config.pvpToggle()){
			timerManager.addTimer(TimerDurations.PVP_DURATION.getDuration());
		}
	}

	/**
	 * A method used to clear the combat records of people who attacked the local player.
	 */
	public void clearRecords()
	{
		log.debug("Clearing records.");
		combatRecords.clear();
		interactionRecords.clear();
	}
}

/*
 * Copyright (c) 2023, Callum Rossiter
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.skulltimer.managers;

import java.time.Duration;
import java.time.Instant;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.SkullIcon;

/**
 * A manager to keep track of when a skull icon is created/removed. This object is primarily created for debugging purposes.
 */
@Slf4j
public class StatusManager
{
	private final Client client;
	private boolean doesPlayerHaveSkullIcon;
	private Instant skullIconStartTime;
	@Getter
	private int skullIconTickStartTime;
	@Setter
	private Instant timerEndTime;
	private final DateTimeFormatter dateTimeFormatter;

	/**
	 * The constructor for a {@link StatusManager} object.
	 * @param client Runelite's {@link Client} object.
	 */
	public StatusManager(Client client)
	{
		this.client = client;
		this.doesPlayerHaveSkullIcon = false;
		this.dateTimeFormatter = DateTimeFormatter.ofPattern("HH:mm:ss").withZone(ZoneOffset.UTC);
	}

	/**
	 * A method used to check the players current status at the moment.
	 * @return {@code true} if the player does have a skull icon, otherwise {@code false}.
	 */
	public boolean doesPlayerCurrentlyHaveSkullIcon()
	{
		return client.getLocalPlayer().getSkullIcon() != SkullIcon.NONE;
	}

	/**
	 * A method used to keep track and log when a skull icon has started or expired.
	 * @param currentTick The {@link Integer} value representing the current tick number.
	 */
	public void checkSkulledStatus(int currentTick)
	{
		//check if there has been a change in status.
		if (doesPlayerHaveSkullIcon == doesPlayerCurrentlyHaveSkullIcon())
		{
			return;
		}

		Instant now = Instant.now();

		if (doesPlayerCurrentlyHaveSkullIcon())
		{
			skullIconStartTime = now;
			skullIconTickStartTime = currentTick;
			log.debug("Skull icon has started: Start time: {} (tick number: {}).", dateTimeFormatter.format(skullIconStartTime), currentTick);
			doesPlayerHaveSkullIcon = true;
		}
		else if (skullIconStartTime != null)
		{
			Duration skulledDuration = Duration.between(skullIconStartTime, now);
			long skulledDurationMinutes = skulledDuration.toMinutes();
			long skulledDurationSeconds = skulledDuration.toSeconds() % 60;

			log.debug("Skull icon has expired. Start time: {}. End time: {}. Duration {} minutes and {} seconds.(tick number: {}).",
				dateTimeFormatter.format(skullIconStartTime),
				dateTimeFormatter.format(now),
				skulledDurationMinutes,
				skulledDurationSeconds,
				currentTick);

			if (timerEndTime != null)
			{
				Duration timerExpiredDuration = Duration.between(timerEndTime, now);
				long timerExpiredMinutes = timerExpiredDuration.toMinutes();
				long timerExpiredSeconds = timerExpiredDuration.toSeconds() % 60;
				int tickDuration = currentTick - skullIconTickStartTime;

				log.debug("Previous timer expired at {} ({} minutes and {} seconds before skulled status. Tick duration: {}).",
					dateTimeFormatter.format(timerEndTime),
					timerExpiredMinutes,
					timerExpiredSeconds,
					tickDuration);
				timerEndTime = null;
			}

			skullIconTickStartTime = 0;
			doesPlayerHaveSkullIcon = false;
		} else {
			log.warn("Skull icon expired, but start time was null.");
		}
	}
}

/*
 * Copyright (c) 2023, Callum Rossiter
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.skulltimer.managers;

import com.skulltimer.SkulledTimer;
import com.skulltimer.enums.SkulledItems;
import com.skulltimer.enums.TimerDurations;
import com.skulltimer.enums.equipment.GenericWeapons;
import com.skulltimer.enums.equipment.SpellAnimations;
import com.skulltimer.enums.equipment.WeaponHitDelay;
import com.skulltimer.enums.equipment.Weapons;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.Player;
import net.runelite.api.kit.KitType;
import net.runelite.client.game.ItemManager;

/**
 * An object that is used to check a players worn equipment to identify if a skull timer is required.
 * <pr> This feature is based on the suggestion and code provided by @juusokarjanlahti (<a href="https://github.com/juusokarjanlahti">GitHub</a>).</pr>
 */
@Slf4j
public class EquipmentManager
{
	private final Client client;
	private final ItemManager itemManager;
	private final TimerManager timerManager;
	/** A {@link HashMap} value that is changed when a player equips an item which provides a skull (e.g. amulet of avarice). */
	private final HashMap<Integer, Item> equippedItems;

	/**
	 * The constructor for a {@link EquipmentManager} object.
	 * @param client Runelite's {@link Client} object.
	 * @param timerManager The manager used to control the creation and deletion of {@link SkulledTimer} objects.
	 * @param itemManager Runelite's {@link ItemManager} object.
	 */
	public EquipmentManager(Client client, TimerManager timerManager, ItemManager itemManager)
	{
		this.client = client;
		this.timerManager = timerManager;
		this.itemManager = itemManager;
		this.equippedItems = new HashMap<>();

		//gets the previously worn items in contained item slots.
		for (SkulledItems items : SkulledItems.values()){
			equippedItems.put(items.getItemSlot(), null);
		}
	}

	/**
	 * A method used to get the equipment inventory {@link ItemContainer}.
	 * @return The {@link ItemContainer} for the {@link Client}'s equipment tab.
	 */
	public ItemContainer getEquipment(){
		return client.getItemContainer(InventoryID.EQUIPMENT);
	}

	/**
	 * A method used to check if a timer should be started by checking for any equipment that would provide a skulled status.
	 *
	 * <p>
	 * There are 5 possible states that the players equipment can be in:<br>
	 * <ol>
	 *     <li>{@code equipment} is null or {@code changedItemSlotIDs} is empty. (No action taken).</li>
	 *     <li>The player is wearing equipment that provides a skulled status indefinitely (Any existing timer is stopped).</li>
	 *     <li>The player is wearing equipment that provides a skull status that is not indefinite and no permanent status equipment has been found (A timer is created).</li>
	 *     <li>The player has previously worn indefinite skulled equipment but it has been unequipped (A timer is created).</li>
	 *     <li>None of the conditions have been met. (No action taken).</li>
	 * </ol>
	 * </p>
	 *
	 * @param changedItemSlotIDs a list of {@link Integer}'s representing the IDs of any item slots that have been changed and need to be checked for skulled items.
	 */
	public void shouldTimerBeStarted(List<Integer> changedItemSlotIDs)
	{
		ItemContainer equipment = getEquipment();

		// Ensure the equipment is not null (e.g., during loading screens)
		if (equipment == null || changedItemSlotIDs.isEmpty()) {
			log.debug("Equipment is null.");
			return;
		}

		//updating the items
		HashMap<Integer, SkulledItems> previousItems = convertToSkulledItems(changedItemSlotIDs);
		log.debug("Previous items: {}", previousItems);

		updateCurrentEquipment();

		HashMap<Integer, SkulledItems> currentItems = convertToSkulledItems(changedItemSlotIDs);
		log.debug("Current items: {}", currentItems);

		//checks to see if the player is wearing an indefinite skull item
		for (Map.Entry<Integer, SkulledItems> entry : currentItems.entrySet()) {
			SkulledItems current = entry.getValue();
			SkulledItems previous = previousItems.get(entry.getKey());

			//checks for indefinite skulls in current items
			if (current != null && current.isSkullIndefinite()) {
				log.debug("Slot {} has an item with an indefinite skull: {}.", entry.getKey(), current);
				timerManager.removeTimer(false);
				return;
			}

			//checks if an indefinite skull was previously worn but is now removed
			else if (previous != null && previous.isSkullIndefinite() && hasNoIndefiniteSkullItem()) {
				log.debug("Slot {} previously had an item with an indefinite skull: {}. Returning true.", entry.getKey(), previous);
				timerManager.addTimer(TimerDurations.TRADER_AND_ITEM_DURATION.getDuration());
				return;
			}

			//checks if the current item provides a skull (but not indefinitely)
			else if (current != null && hasNoIndefiniteSkullItem()) {
				log.debug("Slot {} has an item that provides a temporary skull: {}. Returning true.", entry.getKey(), current);
				timerManager.addTimer(TimerDurations.TRADER_AND_ITEM_DURATION.getDuration());
				return;
			}
		}

		log.debug("No conditions met.");
	}

	/**
	 * A method to update if the player is wearing any armour that would provide a skulled status.
	 */
	public void updateCurrentEquipment()
	{
		ItemContainer equipment = getEquipment();
		// Ensure the equipment is not null (e.g., during loading screens)
		if (equipment == null) {
			return;
		}

		for (Map.Entry<Integer, Item> entry : equippedItems.entrySet()){
			Item item = equipment.getItem(entry.getKey());
			equippedItems.put(entry.getKey(), item);
		}
	}

	/**
	 * A method used to convert items that are tracked by the {@code equippedItems} hashmap into skulled items.
	 * @param itemIDSlots the IDs of the item slots to convert.
	 * @return A {@link HashMap} containing the container ID and {@link SkulledItems}.
	 */
	private HashMap<Integer, SkulledItems> convertToSkulledItems(List<Integer> itemIDSlots){
		HashMap<Integer, SkulledItems> wornItems = new HashMap<>();
		for (Integer itemSlotID: itemIDSlots){
			wornItems.put(itemSlotID, convertToSkulledItem(equippedItems != null && equippedItems.get(itemSlotID) != null
				? equippedItems.get(itemSlotID).getId() : 0));
		}
		return wornItems;
	}

	/**
	 * A method used to convert an itemID into a corresponding {@link SkulledItems} value.
	 * @param itemID The ID of the item to identify.
	 * @return The {@link SkulledItems} value if the item matches. Returns {@code null} if there is no corresponding ID.
	 */
	private SkulledItems convertToSkulledItem(int itemID){
		return Arrays.stream(SkulledItems.values())
			.filter(skulledItems -> skulledItems.getItemID() == itemID)
			.findFirst().orElse(null);
	}

	/**
	 * A method used to track if tracked item slots have changed since last update and then return changed slots.
	 * @return A {@link List} of {@link Integer}s representing the IDs of the changed item slots.
	 */
	public List<Integer> getModifiedItemSlotChanges(){
		List<Integer> managedItemSlotsIDs  = new ArrayList<>();

		for (Map.Entry<Integer, Item> entry : equippedItems.entrySet()){
			Item currentItem = getEquipment().getItem(entry.getKey());

			if (hasItemSlotChanged(entry.getValue(), currentItem)) {
				managedItemSlotsIDs.add(entry.getKey());
				log.debug("Slot id {} has changed. ", entry.getKey());
			}
		}

		log.debug("{} Managed item slots have been changed.", managedItemSlotsIDs.size());

		return managedItemSlotsIDs;
	}

	/**
	 * A method to check if the provided items have changed.
	 * @param previousItem The first item to compare.
	 * @param currentItem The second item to compare.
	 * @return {@code true} if the items have changed. Returns {@code false} if they have not.
	 */
	private boolean hasItemSlotChanged(Item previousItem, Item currentItem){
		return
			//if the player adds an item
			(previousItem == null && currentItem != null) ||
			//if the player has removed an item
			(previousItem != null && currentItem == null) ||
			//if the player has swapped out the item.
			(previousItem != null && currentItem != null && previousItem.getId() != currentItem.getId());
	}

	/**
	 * A method to check if a Player is wearing any items that may provide a skull effect indefinitely.
	 * @return {@code true} if the equipment container is null or no indefinite skull items have been found. Returns {@code false} if
	 * the player is wearing an item that provides an indefinite skulled effect.
	 */
	private boolean hasNoIndefiniteSkullItem(){
		ItemContainer equipment = getEquipment();
		// Ensure the equipment is not null (e.g., during loading screens)
		if (equipment == null) {
			return true;
		}

		List<SkulledItems> indefiniteSkulledItems = Arrays.stream(SkulledItems.values())
			.filter(SkulledItems::isSkullIndefinite).collect(Collectors.toList());

		for (SkulledItems skulledItem : indefiniteSkulledItems){
			Item currentItem = getEquipment().getItem(skulledItem.getItemSlot());

			if (currentItem != null && currentItem.getId() == skulledItem.getItemID()){
				log.debug("Player is currently equipment that provides a permanent skull. Returning false.");
				return false;
			}
		}

		log.debug("Player is not wearing any equipment that provides a permanent skull. Returning false.");
		return true;
	}

	/**
	 * A method used to determine the correct weapon hit delay based on the weapon ID and animation ID.
	 * @param player The player whose {@link WeaponHitDelay} is to be determined.
	 * @return The corresponding {@link WeaponHitDelay}. If the weapon cannot be found, {@code null} is returned instead.
	 */
	public WeaponHitDelay getWeaponHitDelay(Player player){
		int weaponID = getPlayerWeaponID(player);
		int animationID = player.getAnimation();

		//checks to see if the animation matches a spell animation.
		WeaponHitDelay spellHitDelay = SpellAnimations.getSpellHitDelay(animationID);

		//if it does, return the hit delay for that spell.
		if (spellHitDelay != null){
			return spellHitDelay;
		}

		Weapons weapon = Weapons.getByItemID(weaponID);

		if (weapon == null){
			String weaponName = itemManager.getItemComposition(weaponID).getName();
			return GenericWeapons.getWeaponTypeHitDelay(weaponName);
		}

		log.debug("Weapon ID found: {}.", weaponID);

		return (weapon.getSpecialHitDelay() != WeaponHitDelay.NOT_APPLICABLE
			&& weapon.doesAnimationMatchSpecialAnimation(animationID))
			? weapon.getSpecialHitDelay()
			: weapon.getStandardHitDelay();
	}

	/**
	 * A helper method to determine the ID of the weapon the player is using.
	 * @param player The player whose weapon ID is to be found.
	 * @return The weapon ID that the player is currently using.
	 */
	private int getPlayerWeaponID(Player player)
	{
		return player.getPlayerComposition().getEquipmentId(KitType.WEAPON);
	}
}

/*
 * Copyright (c) 2023, Callum Rossiter
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.skulltimer;

import java.awt.Color;
import java.time.Duration;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("Skull Timer")
public interface SkullTimerConfig extends Config
{
	@ConfigSection(
		position = 0,
		name = "General Settings",
		description = "Standard timer configuration settings."
	)
	String settings = "settings";

	@ConfigItem(
		keyName = "textColour",
		name="Text Colour",
		description = "The colour of the countdown text displayed on the timer.",
		section = settings
	)
	default Color textColour() {return Color.WHITE;}

	@ConfigItem(
		keyName = "warningTextColour",
		name="Warning Text Colour",
		description = "The colour of the countdown text displayed on the timer when 30 seconds or less is left on the timer.",
		section = settings
	)
	default Color warningTextColour() {return Color.RED;}

	@ConfigItem(
		keyName = "skullDuration",
		name = "",
		description = "",
		hidden = true
	)
	Duration skullDuration();

	@ConfigItem(
		keyName = "skullDuration",
		name = "",
		description = ""
	)
	void skullDuration(Duration skullDuration);

	@ConfigSection(
		position = 1,
		name = "PVP Settings",
		description = "Settings that affect PVP timers only."
	)
	String experimental = "experimental";

	@ConfigItem(
		keyName = "pvpToggle",
		name="Enable PVP timer",
		description = "Toggles the plugin to track PVP skulls. Please note, this timer may not always be 100% accurate.",
		section = experimental
	)
	default boolean pvpToggle() {return true;}
}
package com.skulltimer;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class SkullTimerPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(SkullTimerPlugin.class);
		RuneLite.main(args);
	}
}
package com.skulltimer.mocks;

import com.skulltimer.SkullTimerConfig;
import com.skulltimer.SkullTimerPlugin;
import com.skulltimer.managers.EquipmentManager;
import com.skulltimer.managers.StatusManager;
import com.skulltimer.managers.TimerManager;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import org.mockito.Mock;

public class TimerMocks
{
	@Mock
	protected Client client;
	@Mock
	protected ClientThread clientThread;
	@Mock
	protected SkullTimerConfig config;
	@Mock
	protected InfoBoxManager infoBoxManager;
	@Mock
	protected ItemManager itemManager;
	@Mock
	protected SkullTimerPlugin skullTimerPlugin;
	@Mock
	protected TimerManager timerManager;
	@Mock
	protected StatusManager statusManager;
	@Mock
	protected EquipmentManager equipmentManager;
}

package com.skulltimer.mocks;

import com.skulltimer.SkullTimerConfig;
import com.skulltimer.SkullTimerPlugin;
import com.skulltimer.SkulledTimer;
import com.skulltimer.managers.CombatManager;
import com.skulltimer.managers.EquipmentManager;
import com.skulltimer.managers.LocationManager;
import com.skulltimer.managers.StatusManager;
import com.skulltimer.managers.TimerManager;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import org.junit.jupiter.api.BeforeEach;
import org.mockito.InjectMocks;
import org.mockito.Mock;


public class PluginMocks
{
	@InjectMocks
	protected SkullTimerPlugin skullTimerPlugin;
	@Mock
	protected Client client;
	@Mock
	protected ClientThread clientThread;
	@Mock
	protected SkullTimerConfig config;
	@Mock
	protected InfoBoxManager infoBoxManager;
	@Mock
	protected ItemManager itemManager;
	@Mock
	protected TimerManager timerManager;
	@Mock
	protected LocationManager locationManager;
	@Mock
	protected EquipmentManager equipmentManager;
	@Mock
	protected CombatManager combatManager;
	@Mock
	protected StatusManager statusManager;
	@Mock
	protected SkulledTimer skulledTimer;

	protected EventBus eventBus;

	@BeforeEach
	public void startUp() throws NoSuchFieldException
	{
		eventBus = new EventBus();
		eventBus.register(skullTimerPlugin);}
}

package com.skulltimer.managers;

import com.skulltimer.mocks.TimerMocks;
import java.time.Duration;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;

@ExtendWith(MockitoExtension.class)
public class TimerManagerTests extends TimerMocks
{
	@InjectMocks
	TimerManager timerManager;

	@Test
	public void startStandardTimer()
	{
		timerManager.addTimer(Duration.ofMinutes(5));
		assertNotNull(timerManager.getTimer());
	}

	@Test
	public void startTimer_WithExistingTimerLessThanReplacement()
	{
		timerManager.addTimer(Duration.ofMinutes(5));
		timerManager.addTimer(Duration.ofMinutes(6));

		assertNotNull(timerManager.getTimer());
		assertEquals(Duration.ofMinutes(6), timerManager.getTimer().getDuration());
	}

	@Test
	public void startTimer_WithExistingTimerGreaterThanReplacement()
	{
		timerManager.addTimer(Duration.ofMinutes(10));
		timerManager.addTimer(Duration.ofMinutes(6));

		assertNotNull(timerManager.getTimer());
		assertEquals(Duration.ofMinutes(10), timerManager.getTimer().getDuration());
	}

	@Test
	public void startTimer_WithNegativeAndZeroTimeDuration()
	{
		timerManager.addTimer(Duration.ofMinutes(-15));
		assertNull(timerManager.getTimer());

		timerManager.addTimer(Duration.ofMinutes(0));
		assertNull(timerManager.getTimer());

		timerManager.addTimer(Duration.ZERO);
		assertNull(timerManager.getTimer());
	}

	@Test
	public void stopTimer()
	{
		timerManager.addTimer(Duration.ofMinutes(12));
		assertNotNull(timerManager.getTimer());
		timerManager.removeTimer(true);
		assertNull(timerManager.getTimer());

		timerManager.addTimer(Duration.ofMinutes(5));
		assertNotNull(timerManager.getTimer());
		timerManager.removeTimer(false);
		assertNull(timerManager.getTimer());
	}

	@Test
	public void stopTimer_Configuration_Saving()
	{
		timerManager.addTimer(Duration.ofMinutes(12));
		timerManager.removeTimer(true);
		verify(config, times(2)).skullDuration(any(Duration.class));
	}

	@Test
	public void stopTimer_Configuration_NotSaving()
	{
		timerManager.addTimer(Duration.ofMinutes(30));
		timerManager.removeTimer(false);
		verify(config, times(2)).skullDuration(Duration.ZERO);
	}
}

package com.skulltimer.managers;

import com.skulltimer.enums.equipment.WeaponHitDelay;
import com.skulltimer.mocks.TimerMocks;
import com.skulltimer.enums.SkulledItems;
import com.skulltimer.enums.TimerDurations;
import java.util.ArrayList;
import java.util.List;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import net.runelite.api.Player;
import net.runelite.api.PlayerComposition;
import net.runelite.api.kit.KitType;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class EquipmentManagerTests extends TimerMocks
{
	@InjectMocks
	EquipmentManager equipmentManager;
	@Mock
	ItemContainer equipment;
	@Mock
	Item amuletMock;
	@Mock
	Item capeMock;
	@Mock
	Item amuletMockTwo;
	@Mock
	Item capeMockTwo;
	@Mock
	ItemComposition itemComposition;
	@Mock
	Player player;
	@Mock
	PlayerComposition playerComposition;

	List<Integer> changedItemIDSlots;

	@BeforeEach
	public void startUp()
	{
		changedItemIDSlots = new ArrayList<>();
	}

	@Test
	public void indefiniteSkullItemEquipped()
	{
		//equipping indefinite skulled item
		when(equipmentManager.getEquipment()).thenReturn(equipment);
		when(equipment.getItem(EquipmentInventorySlot.AMULET.getSlotIdx())).thenReturn(amuletMock);
		when(equipment.getItem(EquipmentInventorySlot.CAPE.getSlotIdx())).thenReturn(null);
		when(amuletMock.getId()).thenReturn(SkulledItems.AMULET_OF_AVARICE.getItemID());

		//checking if the timer be started
		changedItemIDSlots.add(EquipmentInventorySlot.AMULET.getSlotIdx());
		equipmentManager.shouldTimerBeStarted(changedItemIDSlots);
		verify(timerManager, times(0)).addTimer(TimerDurations.TRADER_AND_ITEM_DURATION.getDuration());
		verify(timerManager, times(1)).removeTimer(false);
	}

	@Test
	public void indefiniteSkullItemUnequipped()
	{
		//equipping indefinite skulled item and checking
		when(equipmentManager.getEquipment()).thenReturn(equipment);
		when(equipment.getItem(EquipmentInventorySlot.AMULET.getSlotIdx())).thenReturn(amuletMock);
		when(equipment.getItem(EquipmentInventorySlot.CAPE.getSlotIdx())).thenReturn(null);
		when(amuletMock.getId()).thenReturn(SkulledItems.AMULET_OF_AVARICE.getItemID());
		changedItemIDSlots.add(EquipmentInventorySlot.AMULET.getSlotIdx());
		equipmentManager.shouldTimerBeStarted(changedItemIDSlots);

		//removing item
		when(equipment.getItem(EquipmentInventorySlot.AMULET.getSlotIdx())).thenReturn(null);
		equipmentManager.shouldTimerBeStarted(changedItemIDSlots);

		verify(timerManager, times(1)).addTimer(TimerDurations.TRADER_AND_ITEM_DURATION.getDuration());
	}

	@Test
	public void limitedSkullItemEquipped()
	{
		//equipping item
		when(equipmentManager.getEquipment()).thenReturn(equipment);
		when(equipment.getItem(EquipmentInventorySlot.AMULET.getSlotIdx())).thenReturn(null);
		when(equipment.getItem(EquipmentInventorySlot.CAPE.getSlotIdx())).thenReturn(capeMock);
		when(capeMock.getId()).thenReturn(SkulledItems.CAPE_OF_SKULLS.getItemID());

		//checking if the timer be started
		changedItemIDSlots.add(EquipmentInventorySlot.CAPE.getSlotIdx());
		equipmentManager.shouldTimerBeStarted(changedItemIDSlots);
		verify(timerManager, times(1)).addTimer(TimerDurations.TRADER_AND_ITEM_DURATION.getDuration());
	}

	@Test
	public void limitedSkullItemUnequipped()
	{
		//equipping item
		when(equipmentManager.getEquipment()).thenReturn(equipment);
		when(equipment.getItem(EquipmentInventorySlot.AMULET.getSlotIdx())).thenReturn(null);
		when(equipment.getItem(EquipmentInventorySlot.CAPE.getSlotIdx())).thenReturn(capeMock);
		when(capeMock.getId()).thenReturn(SkulledItems.CAPE_OF_SKULLS.getItemID());
		changedItemIDSlots.add(EquipmentInventorySlot.CAPE.getSlotIdx());
		equipmentManager.shouldTimerBeStarted(changedItemIDSlots);

		verify(timerManager).addTimer(TimerDurations.TRADER_AND_ITEM_DURATION.getDuration());

		//unequipped item
		when(equipment.getItem(EquipmentInventorySlot.CAPE.getSlotIdx())).thenReturn(null);
		equipmentManager.shouldTimerBeStarted(changedItemIDSlots);

		verify(timerManager, times(1)).addTimer(TimerDurations.TRADER_AND_ITEM_DURATION.getDuration());
	}

	@Test
	public void itemAlreadyEquipped()
	{
		//start up and game state changed method
		when(equipmentManager.getEquipment()).thenReturn(equipment);
		equipmentManager.updateCurrentEquipment();
		verify(timerManager, times(0)).addTimer(TimerDurations.TRADER_AND_ITEM_DURATION.getDuration());
	}

	@Test
	public void EquippingPermanentItemAfterLimitedItem()
	{
		//equipping limited skulled effect item
		when(equipmentManager.getEquipment()).thenReturn(equipment);
		when(equipment.getItem(EquipmentInventorySlot.AMULET.getSlotIdx())).thenReturn(null);
		when(equipment.getItem(EquipmentInventorySlot.CAPE.getSlotIdx())).thenReturn(capeMock);
		when(capeMock.getId()).thenReturn(SkulledItems.CAPE_OF_SKULLS.getItemID());
		changedItemIDSlots.add(EquipmentInventorySlot.CAPE.getSlotIdx());
		equipmentManager.shouldTimerBeStarted(changedItemIDSlots);

		verify(timerManager).addTimer(TimerDurations.TRADER_AND_ITEM_DURATION.getDuration());

		//equipping indefinite skulled effect item
		when(equipment.getItem(EquipmentInventorySlot.AMULET.getSlotIdx())).thenReturn(amuletMock);
		when(amuletMock.getId()).thenReturn(SkulledItems.AMULET_OF_AVARICE.getItemID());
		changedItemIDSlots.clear();
		changedItemIDSlots.add(EquipmentInventorySlot.AMULET.getSlotIdx());
		equipmentManager.shouldTimerBeStarted(changedItemIDSlots);

		verify(timerManager).removeTimer(false);
	}

	@Test
	public void EquippingPermanentItemBeforeLimitedItem()
	{
		//equipping indefinite skulled item
		when(equipmentManager.getEquipment()).thenReturn(equipment);
		when(equipment.getItem(EquipmentInventorySlot.AMULET.getSlotIdx())).thenReturn(amuletMock);
		when(equipment.getItem(EquipmentInventorySlot.CAPE.getSlotIdx())).thenReturn(null);
		when(amuletMock.getId()).thenReturn(SkulledItems.AMULET_OF_AVARICE.getItemID());
		changedItemIDSlots.add(EquipmentInventorySlot.AMULET.getSlotIdx());
		equipmentManager.shouldTimerBeStarted(changedItemIDSlots);

		verify(timerManager).removeTimer(false);

		//equipping limited skulled effect item
		when(equipment.getItem(EquipmentInventorySlot.CAPE.getSlotIdx())).thenReturn(capeMock);
		when(capeMock.getId()).thenReturn(SkulledItems.CAPE_OF_SKULLS.getItemID());
		changedItemIDSlots.clear();
		changedItemIDSlots.add(EquipmentInventorySlot.CAPE.getSlotIdx());
		equipmentManager.shouldTimerBeStarted(changedItemIDSlots);

		verify(timerManager, times(0)).addTimer(TimerDurations.TRADER_AND_ITEM_DURATION.getDuration());
	}

	@Test
	public void RemovingBothSkulledEquipment_PermanentFirst()
	{
		//both items have been equipped
		when(equipmentManager.getEquipment()).thenReturn(equipment);
		when(equipment.getItem(EquipmentInventorySlot.AMULET.getSlotIdx())).thenReturn(amuletMock);
		when(equipment.getItem(EquipmentInventorySlot.CAPE.getSlotIdx())).thenReturn(capeMock);
		when(amuletMock.getId()).thenReturn(SkulledItems.AMULET_OF_AVARICE.getItemID());
		when(capeMock.getId()).thenReturn(SkulledItems.CAPE_OF_SKULLS.getItemID());
		equipmentManager.updateCurrentEquipment();

		//removing permanent item
		when(equipment.getItem(EquipmentInventorySlot.AMULET.getSlotIdx())).thenReturn(null);
		changedItemIDSlots.add(EquipmentInventorySlot.AMULET.getSlotIdx());
		equipmentManager.shouldTimerBeStarted(changedItemIDSlots);

		verify(timerManager).addTimer(TimerDurations.TRADER_AND_ITEM_DURATION.getDuration());

		//remove none-permanent item
		when(equipment.getItem(EquipmentInventorySlot.CAPE.getSlotIdx())).thenReturn(null);
		changedItemIDSlots.clear();
		changedItemIDSlots.add(EquipmentInventorySlot.CAPE.getSlotIdx());
		equipmentManager.shouldTimerBeStarted(changedItemIDSlots);

		verify(timerManager).addTimer(TimerDurations.TRADER_AND_ITEM_DURATION.getDuration());
	}

	@Test
	public void RemovingBothSkulledEquipment_NonePermanentFirst()
	{
		//both items have been equipped
		when(equipmentManager.getEquipment()).thenReturn(equipment);
		when(equipment.getItem(EquipmentInventorySlot.AMULET.getSlotIdx())).thenReturn(amuletMock);
		when(equipment.getItem(EquipmentInventorySlot.CAPE.getSlotIdx())).thenReturn(capeMock);
		when(amuletMock.getId()).thenReturn(SkulledItems.AMULET_OF_AVARICE.getItemID());
		when(capeMock.getId()).thenReturn(SkulledItems.CAPE_OF_SKULLS.getItemID());
		equipmentManager.updateCurrentEquipment();

		//removing permanent first
		when(equipment.getItem(EquipmentInventorySlot.AMULET.getSlotIdx())).thenReturn(null);
		changedItemIDSlots.add(EquipmentInventorySlot.AMULET.getSlotIdx());
		equipmentManager.shouldTimerBeStarted(changedItemIDSlots);

		verify(timerManager).addTimer(TimerDurations.TRADER_AND_ITEM_DURATION.getDuration());

		//removing none permanent
		when(equipment.getItem(EquipmentInventorySlot.CAPE.getSlotIdx())).thenReturn(null);
		changedItemIDSlots.clear();
		changedItemIDSlots.add(EquipmentInventorySlot.CAPE.getSlotIdx());
		equipmentManager.shouldTimerBeStarted(changedItemIDSlots);

		verify(timerManager).addTimer(TimerDurations.TRADER_AND_ITEM_DURATION.getDuration());
	}

	@Test
	public void UnequippedBothSlotsOnSameTick()
	{
		//both items have been equipped
		when(equipmentManager.getEquipment()).thenReturn(equipment);
		when(equipment.getItem(EquipmentInventorySlot.AMULET.getSlotIdx())).thenReturn(amuletMock);
		when(equipment.getItem(EquipmentInventorySlot.CAPE.getSlotIdx())).thenReturn(capeMock);
		when(amuletMock.getId()).thenReturn(SkulledItems.AMULET_OF_AVARICE.getItemID());
		when(capeMock.getId()).thenReturn(SkulledItems.CAPE_OF_SKULLS.getItemID());
		equipmentManager.updateCurrentEquipment();

		//unequipped
		when(equipment.getItem(EquipmentInventorySlot.AMULET.getSlotIdx())).thenReturn(null);
		when(equipment.getItem(EquipmentInventorySlot.CAPE.getSlotIdx())).thenReturn(null);
		changedItemIDSlots.add(EquipmentInventorySlot.AMULET.getSlotIdx());
		changedItemIDSlots.add(EquipmentInventorySlot.CAPE.getSlotIdx());

		//method check
		equipmentManager.shouldTimerBeStarted(changedItemIDSlots);
		verify(timerManager, times(1)).addTimer(TimerDurations.TRADER_AND_ITEM_DURATION.getDuration());
	}

	@Test
	public void EquippedBothSlotsOnSameTick()
	{
		//both items have been unequipped
		when(equipmentManager.getEquipment()).thenReturn(equipment);
		when(equipment.getItem(EquipmentInventorySlot.AMULET.getSlotIdx())).thenReturn(null);
		when(equipment.getItem(EquipmentInventorySlot.CAPE.getSlotIdx())).thenReturn(null);
		equipmentManager.updateCurrentEquipment();

		//equipped
		when(equipment.getItem(EquipmentInventorySlot.AMULET.getSlotIdx())).thenReturn(amuletMock);
		when(equipment.getItem(EquipmentInventorySlot.CAPE.getSlotIdx())).thenReturn(capeMock);
		when(amuletMock.getId()).thenReturn(SkulledItems.AMULET_OF_AVARICE.getItemID());
		when(capeMock.getId()).thenReturn(SkulledItems.CAPE_OF_SKULLS.getItemID());
		changedItemIDSlots.add(EquipmentInventorySlot.AMULET.getSlotIdx());
		changedItemIDSlots.add(EquipmentInventorySlot.CAPE.getSlotIdx());

		//method check
		equipmentManager.shouldTimerBeStarted(changedItemIDSlots);
		verify(timerManager, times(1)).removeTimer(false);
	}

	@Test
	public void RemovingPermanent_ThenAddingTemporary()
	{
		//amulet has been equipped
		when(equipmentManager.getEquipment()).thenReturn(equipment);
		when(equipment.getItem(EquipmentInventorySlot.AMULET.getSlotIdx())).thenReturn(amuletMock);
		when(equipment.getItem(EquipmentInventorySlot.CAPE.getSlotIdx())).thenReturn(null);
		when(amuletMock.getId()).thenReturn(SkulledItems.AMULET_OF_AVARICE.getItemID());
		equipmentManager.updateCurrentEquipment();

		//unequipped
		when(equipment.getItem(EquipmentInventorySlot.AMULET.getSlotIdx())).thenReturn(null);
		changedItemIDSlots.add(EquipmentInventorySlot.AMULET.getSlotIdx());

		//method check
		equipmentManager.shouldTimerBeStarted(changedItemIDSlots);
		verify(timerManager, times(1)).addTimer(TimerDurations.TRADER_AND_ITEM_DURATION.getDuration());

		when(equipment.getItem(EquipmentInventorySlot.CAPE.getSlotIdx())).thenReturn(capeMock);
		when(capeMock.getId()).thenReturn(SkulledItems.CAPE_OF_SKULLS.getItemID());
		changedItemIDSlots.clear();
		changedItemIDSlots.add(EquipmentInventorySlot.CAPE.getSlotIdx());
		equipmentManager.shouldTimerBeStarted(changedItemIDSlots);

		verify(timerManager, times(2)).addTimer(TimerDurations.TRADER_AND_ITEM_DURATION.getDuration());
	}

	@Test
	public void SwappingSkulledItemsForOtherItems()
	{
		//both items have been equipped
		when(equipmentManager.getEquipment()).thenReturn(equipment);
		when(equipment.getItem(EquipmentInventorySlot.AMULET.getSlotIdx())).thenReturn(amuletMock);
		when(equipment.getItem(EquipmentInventorySlot.CAPE.getSlotIdx())).thenReturn(capeMock);

		when(amuletMock.getId()).thenReturn(SkulledItems.AMULET_OF_AVARICE.getItemID());
		when(capeMock.getId()).thenReturn(SkulledItems.CAPE_OF_SKULLS.getItemID());
		when(amuletMockTwo.getId()).thenReturn(ItemID.OCCULT_NECKLACE);
		when(capeMockTwo.getId()).thenReturn(ItemID.INFERNAL_CAPE);

		equipmentManager.updateCurrentEquipment();

		//swapping cape first - shouldn't start timer
		when(equipment.getItem(EquipmentInventorySlot.CAPE.getSlotIdx())).thenReturn(capeMockTwo);
		changedItemIDSlots.add(EquipmentInventorySlot.CAPE.getSlotIdx());

		equipmentManager.shouldTimerBeStarted(changedItemIDSlots);
		verify(timerManager, times(0)).addTimer(TimerDurations.TRADER_AND_ITEM_DURATION.getDuration());

		//swapped back
		when(equipment.getItem(EquipmentInventorySlot.CAPE.getSlotIdx())).thenReturn(capeMock);
		equipmentManager.shouldTimerBeStarted(changedItemIDSlots);
		verify(timerManager, times(0)).addTimer(TimerDurations.TRADER_AND_ITEM_DURATION.getDuration());

		//swapping out amulet
		when(equipment.getItem(EquipmentInventorySlot.AMULET.getSlotIdx())).thenReturn(amuletMockTwo);
		changedItemIDSlots.clear();
		changedItemIDSlots.add(EquipmentInventorySlot.AMULET.getSlotIdx());
		equipmentManager.shouldTimerBeStarted(changedItemIDSlots);
		verify(timerManager, times(1)).addTimer(TimerDurations.TRADER_AND_ITEM_DURATION.getDuration());

		//swapping out cape
		when(equipment.getItem(EquipmentInventorySlot.CAPE.getSlotIdx())).thenReturn(capeMockTwo);
		changedItemIDSlots.clear();
		changedItemIDSlots.add(EquipmentInventorySlot.CAPE.getSlotIdx());
		equipmentManager.shouldTimerBeStarted(changedItemIDSlots);
		verify(timerManager, times(1)).addTimer(TimerDurations.TRADER_AND_ITEM_DURATION.getDuration());
	}

	@Test
	public void SwappingOtherItemsForSkulledItems()
	{
		//both items have been equipped
		when(equipmentManager.getEquipment()).thenReturn(equipment);
		when(equipment.getItem(EquipmentInventorySlot.AMULET.getSlotIdx())).thenReturn(amuletMockTwo);
		when(equipment.getItem(EquipmentInventorySlot.CAPE.getSlotIdx())).thenReturn(capeMockTwo);

		when(amuletMock.getId()).thenReturn(ItemID.AMULET_OF_AVARICE);
		when(capeMock.getId()).thenReturn(ItemID.CAPE_OF_SKULLS);
		when(amuletMockTwo.getId()).thenReturn(ItemID.AMULET_OF_GLORY);
		when(capeMockTwo.getId()).thenReturn(ItemID.IMBUED_ZAMORAK_CAPE);
		equipmentManager.updateCurrentEquipment();

		//swapping cape first - should start timer
		when(equipment.getItem(EquipmentInventorySlot.CAPE.getSlotIdx())).thenReturn(capeMock);
		changedItemIDSlots.add(EquipmentInventorySlot.CAPE.getSlotIdx());

		equipmentManager.shouldTimerBeStarted(changedItemIDSlots);
		verify(timerManager, times(1)).addTimer(TimerDurations.TRADER_AND_ITEM_DURATION.getDuration());

		//swapped back
		when(equipment.getItem(EquipmentInventorySlot.CAPE.getSlotIdx())).thenReturn(capeMockTwo);
		equipmentManager.shouldTimerBeStarted(changedItemIDSlots);
		verify(timerManager, times(1)).addTimer(TimerDurations.TRADER_AND_ITEM_DURATION.getDuration());

		//swapping out amulet
		when(equipment.getItem(EquipmentInventorySlot.AMULET.getSlotIdx())).thenReturn(amuletMock);
		changedItemIDSlots.clear();
		changedItemIDSlots.add(EquipmentInventorySlot.AMULET.getSlotIdx());
		equipmentManager.shouldTimerBeStarted(changedItemIDSlots);
		verify(timerManager, times(1)).removeTimer(false);

		//swapping out cape
		when(equipment.getItem(EquipmentInventorySlot.CAPE.getSlotIdx())).thenReturn(capeMockTwo);
		changedItemIDSlots.clear();
		changedItemIDSlots.add(EquipmentInventorySlot.CAPE.getSlotIdx());
		equipmentManager.shouldTimerBeStarted(changedItemIDSlots);
		verify(timerManager, times(1)).addTimer(TimerDurations.TRADER_AND_ITEM_DURATION.getDuration());
	}

	@Test
	public void getWeaponHitDelay_NotSpell()
	{
		when(player.getPlayerComposition()).thenReturn(playerComposition);
		when(playerComposition.getEquipmentId(KitType.WEAPON)).thenReturn(20733);
		when(player.getAnimation()).thenReturn(1);

		assertEquals(WeaponHitDelay.MAGIC_STANDARD_WITH_MELEE, equipmentManager.getWeaponHitDelay(player));
	}

	@Test
	public void getWeaponHitDelay_WithRangedWeapon()
	{
		when(player.getPlayerComposition()).thenReturn(playerComposition);
		when(playerComposition.getEquipmentId(KitType.WEAPON)).thenReturn(11785);
		when(player.getAnimation()).thenReturn(7552);

		assertEquals(WeaponHitDelay.RANGED_STANDARD, equipmentManager.getWeaponHitDelay(player));
	}

	@Test
	public void getWeaponHitDelay_WithSpell()
	{
		when(player.getPlayerComposition()).thenReturn(playerComposition);
		when(playerComposition.getEquipmentId(KitType.WEAPON)).thenReturn(11785);
		when(player.getAnimation()).thenReturn(727);

		assertEquals(WeaponHitDelay.MAGIC_STANDARD, equipmentManager.getWeaponHitDelay(player));
	}

	@Test
	public void getWeaponHitDelay_WithUndefinedWeapon()
	{
		when(player.getPlayerComposition()).thenReturn(playerComposition);
		when(playerComposition.getEquipmentId(KitType.WEAPON)).thenReturn(1);
		when(player.getAnimation()).thenReturn(-1);

		when(itemManager.getItemComposition(1)).thenReturn(itemComposition);
		when(itemComposition.getName()).thenReturn("Armadyl Crossbow");
		assertEquals(WeaponHitDelay.RANGED_STANDARD, equipmentManager.getWeaponHitDelay(player));
	}

	@Test
	public void getWeaponHitDelay_WithUndefinedWeapon_DoesNotExistInGenericWeapons()
	{
		when(player.getPlayerComposition()).thenReturn(playerComposition);
		when(playerComposition.getEquipmentId(KitType.WEAPON)).thenReturn(1);
		when(player.getAnimation()).thenReturn(-1);

		when(itemManager.getItemComposition(1)).thenReturn(itemComposition);
		when(itemComposition.getName()).thenReturn("");
		assertNull(equipmentManager.getWeaponHitDelay(player));
	}
}

package com.skulltimer.managers;

import com.skulltimer.mocks.TimerMocks;
import net.runelite.api.Player;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class StatusManagerTests extends TimerMocks
{
	@InjectMocks
	StatusManager statusManager;
	@Mock
	Player player;

	@BeforeEach
	public void setUp()
	{
		when(client.getLocalPlayer()).thenReturn(player);
	}
}

package com.skulltimer.managers;

import com.skulltimer.data.CombatInteraction;
import com.skulltimer.data.ExpectedHit;
import com.skulltimer.enums.equipment.AttackType;
import com.skulltimer.enums.equipment.WeaponHitDelay;
import com.skulltimer.mocks.TimerMocks;
import com.skulltimer.enums.CombatStatus;
import com.skulltimer.enums.TimerDurations;
import java.time.Duration;
import net.runelite.api.GraphicID;
import net.runelite.api.Player;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Spy;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class CombatManagerTests extends TimerMocks
{
	@Mock
	Player player;
	@Mock
	Player localPlayer;

	CombatInteraction combatInteraction;

	@Spy
	@InjectMocks
	CombatManager combatManager;

	int tickCounter = 0;


	@BeforeEach
	public void startUp()
	{
		when(player.getName()).thenReturn("PlayerOne");
	}

	@Test
	public void playerIsNull()
	{
		when(player.getName()).thenReturn(null);
		combatManager.onTargetHitsplat(player, tickCounter++);
		verify(timerManager, times(0)).addTimer(TimerDurations.PVP_DURATION.getDuration());
	}

	@Test
	public void testUnprovokedAttackOnOtherPlayer()
	{
		when(config.pvpToggle()).thenReturn(true);

		combatManager.onTargetHitsplat(player, tickCounter++);
		verify(timerManager).addTimer(TimerDurations.PVP_DURATION.getDuration());
	}

	@Test
	public void testUnprovokedAttackOnOtherPlayer_WithMultipleHits()
	{
		when(config.pvpToggle()).thenReturn(true);

		combatManager.onTargetHitsplat(player, tickCounter++);
		combatManager.onTargetHitsplat(player, tickCounter++);
		verify(timerManager, times(2)).addTimer(TimerDurations.PVP_DURATION.getDuration());
	}

	@Test
	public void testUnprovokedAttackOnOtherPlayer_WithRetaliatedAttack()
	{
		when(config.pvpToggle()).thenReturn(true);

		//initial attack
		combatManager.onTargetHitsplat(player, tickCounter++);
		//simulated response
		combatManager.onConfirmedInCombat(player.getName());
		//final attack
		combatManager.onTargetHitsplat(player, tickCounter++);

		//because the player attacked back, don't restart timer
		verify(timerManager, times(1)).addTimer(TimerDurations.PVP_DURATION.getDuration());
	}

	@Test
	public void testUnprovokedAttackOnLocalPlayer()
	{
		combatManager.onConfirmedInCombat(player.getName());
		combatManager.onTargetHitsplat(player, tickCounter++);

		//because the player attacked back, don't restart timer
		verify(timerManager, times(0)).addTimer(TimerDurations.PVP_DURATION.getDuration());
		assertEquals(CombatStatus.ATTACKER, combatManager.getCombatRecords().get("PlayerOne").getCombatStatus());
	}

	@Test
	public void testUnprovokedAttackOnLocalPlayer_PlayerHadLoggedOut()
	{
		combatInteraction = new CombatInteraction();
		combatInteraction.setCombatStatus(CombatStatus.LOGGED_OUT);
		combatManager.getCombatRecords().put("PlayerOne", combatInteraction);

		combatManager.onConfirmedInCombat(player.getName());
		combatManager.onTargetHitsplat(player, tickCounter++);

		//because the player had logged out, their attacking record would have been reset, causing them to become the aggressor.
		verify(timerManager, times(0)).addTimer(TimerDurations.PVP_DURATION.getDuration());
	}

	@Test
	public void testUnprovokedAttackOnOtherPlayer_WithPlayerBeingSetToCautious_WithLocalPlayerNotSkulled()
	{
		CombatInteraction interaction = new CombatInteraction();
		interaction.setCombatStatus(CombatStatus.UNCERTAIN);
		combatManager.getCombatRecords().put("PlayerOne", interaction);
		combatManager.onTargetHitsplat(player, tickCounter++);
		verify(timerManager, times(0)).addTimer(TimerDurations.PVP_DURATION.getDuration());
	}

	@Test
	public void testUnprovokedAttackOnOtherPlayer_PlayerHadLoggedOut_WithNoRetaliation()
	{
		when(config.pvpToggle()).thenReturn(true);

		CombatInteraction interaction = new CombatInteraction();
		interaction.setCombatStatus(CombatStatus.LOGGED_OUT);
		combatManager.getCombatRecords().put("PlayerOne", interaction);

		combatManager.onTargetHitsplat(player, tickCounter++);

		//because the player attacked back, don't restart timer
		verify(timerManager, times(1)).addTimer(TimerDurations.PVP_DURATION.getDuration());
	}

	@Test
	public void testUnprovokedAttackOnOtherPlayer_PlayerHadLoggedOut_WithRetaliation()
	{
		CombatInteraction interaction = new CombatInteraction();
		interaction.setCombatStatus(CombatStatus.INACTIVE);
		combatManager.getCombatRecords().put("PlayerOne", interaction);

		combatManager.onTargetHitsplat(player, tickCounter++);
		verify(timerManager, times(0)).addTimer(TimerDurations.PVP_DURATION.getDuration());
	}

	@Test
	public void PVPDisabledTest()
	{
		when(config.pvpToggle()).thenReturn(false);
		combatManager.onTargetHitsplat(player, tickCounter++);

		verify(timerManager, times(0)).addTimer(TimerDurations.PVP_DURATION.getDuration());
		assertEquals(1, combatManager.getCombatRecords().size());
	}

	@Test
	public void targetHasDied()
	{
		when(config.pvpToggle()).thenReturn(true);

		combatInteraction = new CombatInteraction();
		combatInteraction.setCombatStatus(CombatStatus.DEAD);
		combatManager.getCombatRecords().put("PlayerOne", combatInteraction);

		combatManager.onTargetHitsplat(player, tickCounter++);
		verify(timerManager, times(1)).addTimer(TimerDurations.PVP_DURATION.getDuration());
	}

	@Test
	public void targetHasDied_PreviouslyRetaliated()
	{
		when(config.pvpToggle()).thenReturn(true);

		combatInteraction = new CombatInteraction();
		combatInteraction.setCombatStatus(CombatStatus.DEAD);
		combatManager.getCombatRecords().put("PlayerOne", combatInteraction);

		combatManager.onTargetHitsplat(player, tickCounter++);
		verify(timerManager, times(1)).addTimer(TimerDurations.PVP_DURATION.getDuration());

		assertFalse(combatInteraction.hasRetaliated());
	}

	@Test
	public void addExpectedHitTick_WithNullRecord()
	{
		combatManager.addExpectedHitTick(player.getName(), 2, AttackType.OTHER);
	}

	@Test
	public void addExpectedHitTick_WithExistingRecord()
	{
		combatManager.onPlayerInteractionChange(player.getName(), true);
		combatManager.addExpectedHitTick("New Player", 2, AttackType.MAGIC);

		ExpectedHit expectedHit = new ExpectedHit(player.getName(), AttackType.MELEE);
		combatManager.addExpectedHitTick(player.getName(), 2, AttackType.MELEE);

		assertTrue(combatManager.getAttackRecords().get(2).contains(expectedHit));
	}

	@Test
	public void onTickOfExpectedHit_TickNumberLowerThanCurrentTick()
	{
		combatManager.onPlayerInteractionChange(player.getName(), true);
		combatManager.addExpectedHitTick(player.getName(), 2, AttackType.MELEE);
		combatManager.onTickOfExpectedHit(3, true);
		assertEquals(1, combatManager.getCombatRecords().size());
	}

	@Test
	public void onTickOfExpectedHit_TickNumberEqualToCurrentTick()
	{
		combatManager.onPlayerInteractionChange(player.getName(), true);
		combatManager.addExpectedHitTick(player.getName(), 3, AttackType.MELEE);
		combatManager.onTickOfExpectedHit(3, true);

		assertEquals(1, combatManager.getCombatRecords().size());
		verify(combatManager, times(1)).onConfirmedInCombat(player.getName());
	}

	@Test
	public void onTickOfExpectedHit_TickNumberGreaterThanCurrentTick()
	{
		combatManager.onPlayerInteractionChange(player.getName(), true);
		combatManager.addExpectedHitTick(player.getName(), 4, AttackType.MELEE);
		assertEquals(1, combatManager.getAttackRecords().get(4).size());
		verify(combatManager, times(0)).onConfirmedInCombat(player.getName());
	}

	@Test
	public void onTickOfExpectedHitSplat_NoHit()
	{
		combatManager.onPlayerInteractionChange(player.getName(), true);
		combatManager.addExpectedHitTick(player.getName(), 3, AttackType.MELEE);
		combatManager.onTickOfExpectedHit(3, false);

		assertEquals(1, combatManager.getAttackRecords().get(3).size());
		verify(combatManager, times(0)).onConfirmedInCombat(player.getName());
	}

	@Test
	public void onTickOfExpectedHitSplat_NoHit_WithMagicAttack_NoSplash()
	{
		combatManager.onPlayerInteractionChange(player.getName(), true);
		combatManager.addExpectedHitTick(player.getName(), 3, AttackType.MAGIC);
		when(client.getLocalPlayer()).thenReturn(localPlayer);
		when(localPlayer.hasSpotAnim(GraphicID.SPLASH)).thenReturn(false);

		combatManager.onTickOfExpectedHit(3, false);

		assertEquals(1, combatManager.getAttackRecords().get(3).size());
		verify(combatManager, times(0)).onConfirmedInCombat(player.getName());
	}

	@Test
	public void onTickOfExpectedHitSplat_NoHit_WithMagicAttack_WithSplash()
	{
		combatManager.onPlayerInteractionChange(player.getName(), true);
		combatManager.addExpectedHitTick(player.getName(), 3, AttackType.MAGIC);
		when(client.getLocalPlayer()).thenReturn(localPlayer);
		when(localPlayer.hasSpotAnim(GraphicID.SPLASH)).thenReturn(true);

		combatManager.onTickOfExpectedHit(3, false);

		assertEquals(1, combatManager.getAttackRecords().get(3).size());
		verify(combatManager, times(1)).onConfirmedInCombat(player.getName());
	}

	@Test
	public void onUnknownOrInactiveStatus_CurrentTickIsZero()
	{
		CombatInteraction interaction = new CombatInteraction();
		interaction.setCombatStatus(CombatStatus.UNCERTAIN);
		combatManager.getCombatRecords().put("PlayerOne", interaction);

		combatManager.onTargetHitsplat(player, 0);

		assertEquals(CombatStatus.UNCERTAIN, interaction.getCombatStatus());
		verify(equipmentManager, times(0)).getWeaponHitDelay(any(Player.class));
		verify(timerManager, times(0)).addTimer(any(Duration.class));
	}

	@Test
	public void onUnknownOrInactiveStatus_WeaponHitDelayIsNull()
	{
		CombatInteraction interaction = new CombatInteraction();
		interaction.setCombatStatus(CombatStatus.UNCERTAIN);
		combatManager.getCombatRecords().put("PlayerOne", interaction);

		when(client.getLocalPlayer()).thenReturn(localPlayer);
		when(equipmentManager.getWeaponHitDelay(localPlayer)).thenReturn(null);

		combatManager.onTargetHitsplat(player, 2);

		//Running the captured runnable to simulate tick end
		ArgumentCaptor<Runnable> runnableArgumentCaptor = ArgumentCaptor.forClass(Runnable.class);
		verify(clientThread).invokeAtTickEnd(runnableArgumentCaptor.capture());
		runnableArgumentCaptor.getValue().run();

		assertEquals(CombatStatus.UNCERTAIN, interaction.getCombatStatus());
		verify(equipmentManager, times(1)).getWeaponHitDelay(any(Player.class));
		verify(timerManager, times(0)).addTimer(any(Duration.class));
	}

	@Test
	public void onUnknownOrInactiveStatus_PlayerDoesNotHaveSkull()
	{
		CombatInteraction interaction = new CombatInteraction();
		interaction.setCombatStatus(CombatStatus.UNCERTAIN);
		combatManager.getCombatRecords().put("PlayerOne", interaction);

		when(client.getLocalPlayer()).thenReturn(localPlayer);
		//RANGED_STANDARD hit delay should result in 3 ticks with a distance of 10.
		when(equipmentManager.getWeaponHitDelay(localPlayer)).thenReturn(WeaponHitDelay.RANGED_STANDARD);
		when(statusManager.getSkullIconTickStartTime()).thenReturn(37);
		when(statusManager.doesPlayerCurrentlyHaveSkullIcon()).thenReturn(false);

		combatManager.onTargetHitsplat(player, 40);

		//Running the captured runnable to simulate tick end
		ArgumentCaptor<Runnable> runnableArgumentCaptor = ArgumentCaptor.forClass(Runnable.class);
		verify(clientThread).invokeAtTickEnd(runnableArgumentCaptor.capture());
		runnableArgumentCaptor.getValue().run();


		assertEquals(CombatStatus.RETALIATED, interaction.getCombatStatus());
		verify(equipmentManager, times(1)).getWeaponHitDelay(any(Player.class));
		verify(timerManager, times(0)).addTimer(any(Duration.class));
	}

	@Test
	public void onUnknownOrInactiveStatus_PlayerHasSkull_WithinTimeRange()
	{
		CombatInteraction interaction = new CombatInteraction();
		interaction.setCombatStatus(CombatStatus.UNCERTAIN);
		combatManager.getCombatRecords().put("PlayerOne", interaction);

		when(config.pvpToggle()).thenReturn(true);
		when(client.getLocalPlayer()).thenReturn(localPlayer);
		//RANGED_STANDARD hit delay should result in 5 ticks with a distance of 10.
		when(equipmentManager.getWeaponHitDelay(localPlayer)).thenReturn(WeaponHitDelay.RANGED_STANDARD);
		when(statusManager.getSkullIconTickStartTime()).thenReturn(37);
		when(statusManager.doesPlayerCurrentlyHaveSkullIcon()).thenReturn(true);

		combatManager.onTargetHitsplat(player, 40);

		//Running the captured runnable to simulate tick end
		ArgumentCaptor<Runnable> runnableArgumentCaptor = ArgumentCaptor.forClass(Runnable.class);
		verify(clientThread).invokeAtTickEnd(runnableArgumentCaptor.capture());
		runnableArgumentCaptor.getValue().run();

		assertEquals(CombatStatus.ATTACKED, interaction.getCombatStatus());
		verify(equipmentManager, times(1)).getWeaponHitDelay(any(Player.class));
		verify(timerManager, times(1)).addTimer(any(Duration.class));
	}

	@Test
	public void onUnknownOrInactiveStatus_PlayerHasSkull_BelowTimeRange()
	{
		CombatInteraction interaction = new CombatInteraction();
		interaction.setCombatStatus(CombatStatus.UNCERTAIN);
		combatManager.getCombatRecords().put("PlayerOne", interaction);

		when(config.pvpToggle()).thenReturn(true);
		when(client.getLocalPlayer()).thenReturn(localPlayer);
		//RANGED_STANDARD hit delay should result in 5 ticks with a distance of 10.
		when(equipmentManager.getWeaponHitDelay(localPlayer)).thenReturn(WeaponHitDelay.RANGED_STANDARD);
		when(statusManager.getSkullIconTickStartTime()).thenReturn(33);
		when(statusManager.doesPlayerCurrentlyHaveSkullIcon()).thenReturn(true);

		combatManager.onTargetHitsplat(player, 40);

		//Running the captured runnable to simulate tick end
		ArgumentCaptor<Runnable> runnableArgumentCaptor = ArgumentCaptor.forClass(Runnable.class);
		verify(clientThread).invokeAtTickEnd(runnableArgumentCaptor.capture());
		runnableArgumentCaptor.getValue().run();

		assertEquals(CombatStatus.UNCERTAIN, interaction.getCombatStatus());
		verify(equipmentManager, times(1)).getWeaponHitDelay(any(Player.class));
		verify(timerManager, times(1)).addTimer(any(Duration.class));
	}

	@Test
	public void onUnknownOrInactiveStatus_PlayerHasSkull_AboveTimeRange()
	{
		//Under normal circumstances, this shouldn't occur
		CombatInteraction interaction = new CombatInteraction();
		interaction.setCombatStatus(CombatStatus.UNCERTAIN);
		combatManager.getCombatRecords().put("PlayerOne", interaction);

		when(config.pvpToggle()).thenReturn(true);
		when(client.getLocalPlayer()).thenReturn(localPlayer);
		//RANGED_STANDARD hit delay should result in 3 ticks with a distance of 10.
		when(equipmentManager.getWeaponHitDelay(localPlayer)).thenReturn(WeaponHitDelay.RANGED_STANDARD);
		when(statusManager.getSkullIconTickStartTime()).thenReturn(43);
		when(statusManager.doesPlayerCurrentlyHaveSkullIcon()).thenReturn(true);

		combatManager.onTargetHitsplat(player, 40);

		//Running the captured runnable to simulate tick end
		ArgumentCaptor<Runnable> runnableArgumentCaptor = ArgumentCaptor.forClass(Runnable.class);
		verify(clientThread).invokeAtTickEnd(runnableArgumentCaptor.capture());
		runnableArgumentCaptor.getValue().run();

		assertEquals(CombatStatus.UNCERTAIN, interaction.getCombatStatus());
		verify(equipmentManager, times(1)).getWeaponHitDelay(any(Player.class));
		verify(timerManager, times(1)).addTimer(any(Duration.class));
	}

	@Test
	public void onUnknownOrInactiveStatus_PlayerHasSkull_OutsideOfTimeRanged_Inactive()
	{
		CombatInteraction interaction = new CombatInteraction();
		interaction.setCombatStatus(CombatStatus.INACTIVE);
		combatManager.getCombatRecords().put("PlayerOne", interaction);

		when(client.getLocalPlayer()).thenReturn(localPlayer);
		//RANGED_STANDARD hit delay should result in 3 ticks with a distance of 10.
		when(equipmentManager.getWeaponHitDelay(localPlayer)).thenReturn(WeaponHitDelay.RANGED_STANDARD);
		when(statusManager.getSkullIconTickStartTime()).thenReturn(43);
		when(statusManager.doesPlayerCurrentlyHaveSkullIcon()).thenReturn(true);

		combatManager.onTargetHitsplat(player, 400);

		//Running the captured runnable to simulate tick end
		ArgumentCaptor<Runnable> runnableArgumentCaptor = ArgumentCaptor.forClass(Runnable.class);
		verify(clientThread).invokeAtTickEnd(runnableArgumentCaptor.capture());
		runnableArgumentCaptor.getValue().run();

		assertEquals(CombatStatus.INACTIVE, interaction.getCombatStatus());
		verify(equipmentManager, times(1)).getWeaponHitDelay(any(Player.class));
		verify(timerManager, times(0)).addTimer(any(Duration.class));
	}

	@Test
	public void onUnknownOrInactiveStatus_PlayerHasSkull_OutsideOfTimeRanged_Uncertain()
	{
		CombatInteraction interaction = new CombatInteraction();
		interaction.setCombatStatus(CombatStatus.UNCERTAIN);
		combatManager.getCombatRecords().put("PlayerOne", interaction);

		when(config.pvpToggle()).thenReturn(true);
		when(client.getLocalPlayer()).thenReturn(localPlayer);
		//RANGED_STANDARD hit delay should result in 3 ticks with a distance of 10.
		when(equipmentManager.getWeaponHitDelay(localPlayer)).thenReturn(WeaponHitDelay.RANGED_STANDARD);
		when(statusManager.getSkullIconTickStartTime()).thenReturn(43);
		when(statusManager.doesPlayerCurrentlyHaveSkullIcon()).thenReturn(true);

		combatManager.onTargetHitsplat(player, 400);

		//Running the captured runnable to simulate tick end
		ArgumentCaptor<Runnable> runnableArgumentCaptor = ArgumentCaptor.forClass(Runnable.class);
		verify(clientThread).invokeAtTickEnd(runnableArgumentCaptor.capture());
		runnableArgumentCaptor.getValue().run();

		assertEquals(CombatStatus.UNCERTAIN, interaction.getCombatStatus());
		verify(equipmentManager, times(1)).getWeaponHitDelay(any(Player.class));
		verify(timerManager, times(1)).addTimer(any(Duration.class));
	}
}

package com.skulltimer.managers;

import com.skulltimer.mocks.TimerMocks;
import com.skulltimer.enums.TimerDurations;
import net.runelite.api.Player;
import net.runelite.api.SkullIcon;
import net.runelite.api.coords.WorldPoint;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.lenient;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class LocationManagerTests extends TimerMocks
{
	@InjectMocks
	LocationManager locationManager;
	@Mock
	Player player;
	@Mock
	Player localPlayer;
	@Mock
	WorldPoint worldPointA;
	@Mock
	WorldPoint worldPointB;
	@BeforeEach
	public void startUp()
	{
		lenient().when(client.getLocalPlayer()).thenReturn(player);
	}

	@Test
	public void wildernessCheck()
	{
		when(client.getVarbitValue(5963)).thenReturn(0);
		assertFalse(locationManager.isInWilderness());

		when(client.getVarbitValue(5963)).thenReturn(1);
		assertTrue(locationManager.isInWilderness());
	}

	@Test
	public void inAbyss_WithoutTeleport()
	{
		locationManager.setHasBeenTeleportedIntoAbyss(false);
		when(player.getWorldLocation()).thenReturn(new WorldPoint(3019, 4814, 0));
		locationManager.isInAbyss();
		verify(timerManager, times(0)).addTimer(TimerDurations.ABYSS_DURATION.getDuration());
	}

	@Test
	public void inAbyss_WithTeleport()
	{
		locationManager.setHasBeenTeleportedIntoAbyss(true);
		when(player.getWorldLocation()).thenReturn(new WorldPoint(3055, 4860, 0));
		locationManager.isInAbyss();
		verify(timerManager, times(1)).addTimer(TimerDurations.ABYSS_DURATION.getDuration());
	}

	@Test
	public void inAbyss_WithoutSkull()
	{
		when(player.getWorldLocation()).thenReturn(new WorldPoint(3015, 4831, 0));
		lenient().when(player.getSkullIcon()).thenReturn(SkullIcon.NONE);
		locationManager.isInAbyss();
		verify(timerManager, times(0)).addTimer(TimerDurations.ABYSS_DURATION.getDuration());
	}

	@Test
	public void outsideAbyss()
	{
		locationManager.setHasBeenTeleportedIntoAbyss(false);
		when(player.getWorldLocation()).thenReturn(new WorldPoint(2785, 3463, 0));
		locationManager.isInAbyss();
		verify(timerManager, times(0)).addTimer(TimerDurations.ABYSS_DURATION.getDuration());
	}

	@Test
	public void outsideAbyss_WithTeleport()
	{
		locationManager.setHasBeenTeleportedIntoAbyss(true);
		when(player.getWorldLocation()).thenReturn(new WorldPoint(1496, 3040, 0));
		locationManager.isInAbyss();
		verify(timerManager, times(0)).addTimer(TimerDurations.ABYSS_DURATION.getDuration());
	}

	@Test
	public void hasPlayerLoggedOut_InRadius_NoAnimation()
	{
		when(client.getLocalPlayer()).thenReturn(localPlayer);
		when(localPlayer.getWorldLocation()).thenReturn(new WorldPoint(1000, 1000, 1));

		when(player.getWorldLocation()).thenReturn(new WorldPoint(1002, 1004, 1));
		when(player.getAnimation()).thenReturn(-1);

		assertTrue(locationManager.hasPlayerLoggedOut(player));
	}

	@Test
	public void hasPlayerLoggedOut_InRadius_WithAnimation()
	{
		when(client.getLocalPlayer()).thenReturn(localPlayer);
		when(localPlayer.getWorldLocation()).thenReturn(new WorldPoint(1000, 1000, 1));

		when(player.getWorldLocation()).thenReturn(new WorldPoint(1002, 1004, 1));
		when(player.getAnimation()).thenReturn(1);

		assertFalse(locationManager.hasPlayerLoggedOut(player));
	}

	@Test
	public void hasPlayerLoggedOut_OutOfRadius_X()
	{
		when(client.getLocalPlayer()).thenReturn(localPlayer);
		when(localPlayer.getWorldLocation()).thenReturn(new WorldPoint(1000, 1000, 1));

		when(player.getWorldLocation()).thenReturn(new WorldPoint(1020, 1004, 1));

		assertFalse(locationManager.hasPlayerLoggedOut(player));
	}

	@Test
	public void hasPlayerLoggedOut_OutOfRadius_Y()
	{
		when(client.getLocalPlayer()).thenReturn(localPlayer);
		when(localPlayer.getWorldLocation()).thenReturn(new WorldPoint(1000, 1000, 1));

		when(player.getWorldLocation()).thenReturn(new WorldPoint(1002, 800, 1));

		assertFalse(locationManager.hasPlayerLoggedOut(player));
	}

	@Test
	public void hasPlayerLoggedOut_OutOfRadius_XY()
	{
		when(client.getLocalPlayer()).thenReturn(localPlayer);
		when(localPlayer.getWorldLocation()).thenReturn(new WorldPoint(1000, 1000, 1));

		when(player.getWorldLocation()).thenReturn(new WorldPoint(2002, 600, 1));

		assertFalse(locationManager.hasPlayerLoggedOut(player));
	}

	@Test
	public void hasPlayerLoggedOut_PlayerIsNull()
	{
		when(client.getLocalPlayer()).thenReturn(localPlayer);
		when(localPlayer.getWorldLocation()).thenReturn(new WorldPoint(1000, 1000, 1));

		assertFalse(locationManager.hasPlayerLoggedOut(null));
	}

	@Test
	public void hasPlayerLoggedOut_PlayerIsNotNull_WorldPointNull()
	{
		when(client.getLocalPlayer()).thenReturn(localPlayer);
		when(localPlayer.getWorldLocation()).thenReturn(new WorldPoint(1000, 1000, 1));

		when(player.getWorldLocation()).thenReturn(null);

		assertFalse(locationManager.hasPlayerLoggedOut(player));
	}

	@Test
	public void calculateDistanceBetweenPlayers_PlayersAreNull()
	{
		assertEquals(0, locationManager.calculateDistanceBetweenPlayers(null, null));
		assertEquals(0, locationManager.calculateDistanceBetweenPlayers(player, null));
	}

	@Test
	public void calculateDistanceBetweenPlayers_PlayersLocationsAreNull()
	{
		when(player.getWorldLocation()).thenReturn(null);
		assertEquals(0, locationManager.calculateDistanceBetweenPlayers(player, localPlayer));

		when(player.getWorldLocation()).thenReturn(worldPointB);
		when(localPlayer.getWorldLocation()).thenReturn(null);
		assertEquals(0, locationManager.calculateDistanceBetweenPlayers(player, localPlayer));
	}

	@Test
	public void calculateDistanceBetweenPlayers_PlayerIsWithinMeleeRange()
	{
		when(player.getWorldLocation()).thenReturn(worldPointA);
		when(localPlayer.getWorldLocation()).thenReturn(worldPointB);

		when(worldPointA.getX()).thenReturn(10);
		when(worldPointA.getY()).thenReturn(290);

		when(worldPointB.getX()).thenReturn(11);
		when(worldPointB.getY()).thenReturn(291);

		assertEquals(1, locationManager.calculateDistanceBetweenPlayers(player, localPlayer));
	}

	@Test
	public void calculateDistanceBetweenPlayers_PlayerIsWithin_DistantX()
	{
		when(player.getWorldLocation()).thenReturn(worldPointA);
		when(localPlayer.getWorldLocation()).thenReturn(worldPointB);

		when(worldPointA.getX()).thenReturn(10);
		when(worldPointA.getY()).thenReturn(290);

		when(worldPointB.getX()).thenReturn(20);
		when(worldPointB.getY()).thenReturn(291);

		assertEquals(10, locationManager.calculateDistanceBetweenPlayers(player, localPlayer));
	}

	@Test
	public void calculateDistanceBetweenPlayers_PlayerIsWithin_DistantY()
	{
		when(player.getWorldLocation()).thenReturn(worldPointA);
		when(localPlayer.getWorldLocation()).thenReturn(worldPointB);

		when(worldPointA.getX()).thenReturn(10);
		when(worldPointA.getY()).thenReturn(391);

		when(worldPointB.getX()).thenReturn(11);
		when(worldPointB.getY()).thenReturn(291);

		assertEquals(100, locationManager.calculateDistanceBetweenPlayers(player, localPlayer));
	}
}

package com.skulltimer.events;

import com.skulltimer.mocks.PluginMocks;
import net.runelite.api.Hitsplat;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.events.HitsplatApplied;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class HitsplatAppliedEventTest extends PluginMocks
{
	@Mock
	HitsplatApplied hitsplatApplied;
	@Mock
	Player player;
	@Mock
	Player localPlayer;
	@Mock
	NPC npc;
	@Mock
	Hitsplat hitsplat;

	@Test
	public void playerIsNotInWilderness()
	{
		when(locationManager.isInWilderness()).thenReturn(false);
		eventBus.post(hitsplatApplied);
		verify(combatManager, times(0)).onTargetHitsplat(any(Player.class), anyInt());
	}

	@Test
	public void hitSplatOnLocalPlayer()
	{
		when(locationManager.isInWilderness()).thenReturn(true);
		when(hitsplatApplied.getActor()).thenReturn(player);
		when(player.getName()).thenReturn("Player");
		when(client.getLocalPlayer()).thenReturn(player);

		eventBus.post(hitsplatApplied);
		verify(combatManager, times(0)).onTargetHitsplat(any(Player.class), anyInt());
	}

	@Test
	public void hitSplat_NotByPlayer()
	{
		when(locationManager.isInWilderness()).thenReturn(true);
		when(hitsplatApplied.getActor()).thenReturn(player);
		when(hitsplatApplied.getHitsplat()).thenReturn(hitsplat);
		when(hitsplat.isMine()).thenReturn(false);
		when(player.getName()).thenReturn("Player");

		when(client.getLocalPlayer()).thenReturn(localPlayer);
		when(localPlayer.getName()).thenReturn("NotPlayer");

		eventBus.post(hitsplatApplied);
		verify(combatManager, times(0)).onTargetHitsplat(any(Player.class), anyInt());
	}

	@Test
	public void hitSplat_OnNPC()
	{
		when(locationManager.isInWilderness()).thenReturn(true);
		when(hitsplatApplied.getActor()).thenReturn(npc);
		when(npc.getName()).thenReturn("npc");

		eventBus.post(hitsplatApplied);
		verify(combatManager, times(0)).onTargetHitsplat(any(Player.class), anyInt());
	}

	@Test
	public void HitSplatOnPlayer_LocalPlayerHasSkullIcon()
	{
		when(locationManager.isInWilderness()).thenReturn(true);
		when(hitsplatApplied.getActor()).thenReturn(player);
		when(hitsplatApplied.getHitsplat()).thenReturn(hitsplat);
		when(hitsplat.isMine()).thenReturn(true);
		when(player.getName()).thenReturn("Player");

		when(client.getLocalPlayer()).thenReturn(localPlayer);
		when(localPlayer.getName()).thenReturn("NotPlayer");

		eventBus.post(hitsplatApplied);
		verify(combatManager, times(1)).onTargetHitsplat(player, 0);
	}

	@Test
	public void HitSplatOnLocalPlayer()
	{
		when(locationManager.isInWilderness()).thenReturn(true);
		when(localPlayer.getName()).thenReturn("Player");
		when(hitsplatApplied.getActor()).thenReturn(localPlayer);
		when(client.getLocalPlayer()).thenReturn(localPlayer);

		eventBus.post(hitsplatApplied);
		verify(combatManager, times(0)).onTargetHitsplat(player, 0);
	}
}

package com.skulltimer.events;

import com.skulltimer.enums.equipment.AttackType;
import com.skulltimer.enums.equipment.WeaponHitDelay;
import com.skulltimer.mocks.PluginMocks;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.PlayerComposition;
import net.runelite.api.events.AnimationChanged;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class AnimationChangedEventTest extends PluginMocks
{
	@Mock
	AnimationChanged animationChanged;
	@Mock
	Player player;
	@Mock
	Player localPlayer;
	@Mock
	NPC npc;
	@Mock
	PlayerComposition playerComposition;

	@Test
	public void playerIsNotInWilderness()
	{
		when(locationManager.isInWilderness()).thenReturn(false);
		eventBus.post(animationChanged);
		verify(locationManager, times(0)).calculateDistanceBetweenPlayers(any(Player.class), any(Player.class));
	}

	@Test
	public void actorIsNull()
	{
		when(locationManager.isInWilderness()).thenReturn(true);
		when(animationChanged.getActor()).thenReturn(null);

		eventBus.post(animationChanged);
		verify(locationManager, times(0)).calculateDistanceBetweenPlayers(any(Player.class), any(Player.class));
	}

	@Test
	public void actorIsNotPlayerObject()
	{
		when(locationManager.isInWilderness()).thenReturn(true);
		when(animationChanged.getActor()).thenReturn(npc);

		eventBus.post(animationChanged);
		verify(locationManager, times(0)).calculateDistanceBetweenPlayers(any(Player.class), any(Player.class));
	}

	@Test
	public void actorIsLocalPlayer()
	{
		when(locationManager.isInWilderness()).thenReturn(true);
		when(animationChanged.getActor()).thenReturn(localPlayer);
		when(client.getLocalPlayer()).thenReturn(localPlayer);
		when(localPlayer.getName()).thenReturn("LocalPlayer");

		eventBus.post(animationChanged);
		verify(locationManager, times(0)).calculateDistanceBetweenPlayers(any(Player.class), any(Player.class));
	}

	@Test
	public void conditionsMet()
	{
		when(locationManager.isInWilderness()).thenReturn(true);
		when(animationChanged.getActor()).thenReturn(player);
		when(player.getName()).thenReturn("Player");
		when(player.getAnimation()).thenReturn(100);

		when(client.getLocalPlayer()).thenReturn(localPlayer);
		when(localPlayer.getName()).thenReturn("LocalPlayer");

		eventBus.post(animationChanged);
		verify(equipmentManager, times(1)).getWeaponHitDelay(player);
	}

	@Test
	public void conditionsMet_PlayersAreDistanceOfTen()
	{
		when(locationManager.isInWilderness()).thenReturn(true);
		when(animationChanged.getActor()).thenReturn(player);
		when(player.getName()).thenReturn("Player");
		when(player.getAnimation()).thenReturn(100);

		when(client.getLocalPlayer()).thenReturn(localPlayer);
		when(localPlayer.getName()).thenReturn("LocalPlayer");
		when(equipmentManager.getWeaponHitDelay(player)).thenReturn(WeaponHitDelay.MELEE_STANDARD);

		when(locationManager.calculateDistanceBetweenPlayers(client.getLocalPlayer(), player)).thenReturn(10);

		eventBus.post(animationChanged);
		verify(combatManager, times(1)).addExpectedHitTick(player.getName(), 0, AttackType.MELEE);
	}

	@Test
	public void conditionsMet_WeaponIsNUll()
	{
		when(locationManager.isInWilderness()).thenReturn(true);
		when(animationChanged.getActor()).thenReturn(player);
		when(player.getName()).thenReturn("Player");
		when(player.getAnimation()).thenReturn(100);

		when(client.getLocalPlayer()).thenReturn(localPlayer);
		when(localPlayer.getName()).thenReturn("LocalPlayer");

		eventBus.post(animationChanged);
		verify(combatManager, times(0)).addExpectedHitTick(anyString(), anyInt(), any(AttackType.class));
	}

	@Test
	public void excludedAnimation()
	{
		when(locationManager.isInWilderness()).thenReturn(true);
		when(animationChanged.getActor()).thenReturn(player);
		when(player.getName()).thenReturn("Player");
		when(player.getAnimation()).thenReturn(424);

		when(client.getLocalPlayer()).thenReturn(localPlayer);
		when(localPlayer.getName()).thenReturn("LocalPlayer");

		eventBus.post(animationChanged);
		verify(combatManager, times(0)).addExpectedHitTick(anyString(), anyInt(), any(AttackType.class));
	}
}

package com.skulltimer.events;

import com.skulltimer.SkulledTimer;
import com.skulltimer.mocks.PluginMocks;
import java.time.Duration;
import net.runelite.api.GameState;
import net.runelite.client.events.ConfigChanged;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class ConfigChangedEventTest extends PluginMocks
{
	@Mock
	ConfigChanged configChanged;
	@Mock
	SkulledTimer skulledTimer;

	@Test
	public void timerIsNull()
	{
		eventBus.post(configChanged);
		verify(timerManager, never()).addTimer(any(Duration.class));
	}

	@Test
	public void timerIsNotNull()
	{
		when(configChanged.getGroup()).thenReturn("Skull Timer");
		when(configChanged.getKey()).thenReturn("warningTextColour");
		when(timerManager.getTimer()).thenReturn(skulledTimer);
		when(client.getGameState()).thenReturn(GameState.LOGGED_IN);
		eventBus.post(configChanged);
		verify(timerManager, times(1)).addTimer(any(Duration.class));
	}

	@Test
	public void timerIsNotNull_NotLoggedIn()
	{
		when(configChanged.getGroup()).thenReturn("Skull Timer");
		when(configChanged.getKey()).thenReturn("warningTextColour");
		when(timerManager.getTimer()).thenReturn(skulledTimer);
		when(client.getGameState()).thenReturn(GameState.LOGIN_SCREEN);
		eventBus.post(configChanged);
		verify(timerManager, times(0)).addTimer(any(Duration.class));
	}

	@Test
	public void otherConfigGroupChanged()
	{
		when(configChanged.getGroup()).thenReturn("otherPlugin");
		eventBus.post(configChanged);
		verify(timerManager, times(0)).addTimer(any(Duration.class));
	}

	@Test
	public void timerDurationSaved()
	{
		when(configChanged.getGroup()).thenReturn("Skull Timer");
		when(configChanged.getKey()).thenReturn("skullDuration");
		eventBus.post(configChanged);
		verify(timerManager, times(0)).addTimer(any(Duration.class));
	}
}

package com.skulltimer.events;

import com.skulltimer.mocks.PluginMocks;
import java.time.Duration;
import java.time.Instant;
import net.runelite.api.Player;
import net.runelite.api.SkullIcon;
import net.runelite.api.events.GameTick;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.mockito.ArgumentMatchers.anyBoolean;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class GameTickEventTest extends PluginMocks
{
	@Mock
	Player localPlayer;
	@Mock
	GameTick gameTick;

	@BeforeEach
	public void startUp() throws NoSuchFieldException
	{
		super.startUp();
		when(timerManager.getTimer()).thenReturn(skulledTimer);
	}

	@Test
	public void timerExpiresAfterCurrentTime()
	{
		when(client.getLocalPlayer()).thenReturn(localPlayer);
		when(skulledTimer.getEndTime()).thenReturn(Instant.now().plus(Duration.ofMinutes(20)));
		eventBus.post(gameTick);
		verify(timerManager, times(0)).removeTimer(anyBoolean());
	}

	@Test
	public void timerHasExpired()
	{
		when(client.getLocalPlayer()).thenReturn(localPlayer);
		when(localPlayer.getSkullIcon()).thenReturn(SkullIcon.SKULL);
		when(skulledTimer.getEndTime()).thenReturn(Instant.now().minusSeconds(1));
		eventBus.post(gameTick);
		verify(timerManager, times(1)).removeTimer(false);
	}

	@Test
	public void playerSkulledIconHasExpired()
	{
		when(timerManager.getTimer()).thenReturn(skulledTimer);
		when(skulledTimer.getEndTime()).thenReturn(Instant.now().plusSeconds(300));
		when(client.getLocalPlayer()).thenReturn(localPlayer);
		when(localPlayer.getSkullIcon()).thenReturn(SkullIcon.NONE);
		eventBus.post(gameTick);
		verify(timerManager, times(1)).removeTimer(false);
	}
}

package com.skulltimer.events;

import com.skulltimer.mocks.PluginMocks;
import java.time.Duration;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class GameStateChangedEventTest extends PluginMocks
{
	@Mock
	GameStateChanged gameStateChanged;

	@Test
	public void loggingIn_WithNoTimerSaved()
	{
		when(config.skullDuration()).thenReturn(null);

		when(gameStateChanged.getGameState()).thenReturn(GameState.LOGGED_IN);
		eventBus.post(gameStateChanged);
		verify(timerManager, times(0)).addTimer(any(Duration.class));
	}

	@Test
	public void loggingIn_WithTimerSavedButTimerAlreadyExists()
	{
		when(config.skullDuration()).thenReturn(Duration.ofMinutes(20));
		when(timerManager.getTimer()).thenReturn(skulledTimer);

		when(gameStateChanged.getGameState()).thenReturn(GameState.LOGGED_IN);
		eventBus.post(gameStateChanged);
		verify(timerManager, times(0)).addTimer(any(Duration.class));
	}

	@Test
	public void loggingIn_WithTimerSavedButInAbyss()
	{
		when(config.skullDuration()).thenReturn(Duration.ofMinutes(20));
		when(timerManager.getTimer()).thenReturn(null);
		when(locationManager.isInAbyss()).thenReturn(true);

		when(gameStateChanged.getGameState()).thenReturn(GameState.LOGGED_IN);
		eventBus.post(gameStateChanged);
		verify(timerManager, times(0)).addTimer(any(Duration.class));
	}

	@Test
	public void loggingIn_WithSavedConfig_WithNullTimer_WithNotInAbyss()
	{
		when(config.skullDuration()).thenReturn(Duration.ofMinutes(20));
		when(timerManager.getTimer()).thenReturn(null);
		when(locationManager.isInAbyss()).thenReturn(false);

		when(gameStateChanged.getGameState()).thenReturn(GameState.LOGGED_IN);
		eventBus.post(gameStateChanged);
		verify(timerManager, times(1)).addTimer(any(Duration.class));
	}

	@Test
	public void loggingOut_WithValidTimer()
	{
		when(timerManager.getTimer()).thenReturn(skulledTimer);

		when(gameStateChanged.getGameState()).thenReturn(GameState.LOGIN_SCREEN);
		eventBus.post(gameStateChanged);
		verify(timerManager, times(1)).removeTimer(true);
	}

	@Test
	public void loggingOut_WithNullTimer()
	{
		when(timerManager.getTimer()).thenReturn(null);

		when(gameStateChanged.getGameState()).thenReturn(GameState.LOGIN_SCREEN);
		eventBus.post(gameStateChanged);
		verify(timerManager, times(0)).removeTimer(true);
	}

	@Test
	public void worldHopping_WithValidTimer()
	{
		when(timerManager.getTimer()).thenReturn(skulledTimer);

		when(gameStateChanged.getGameState()).thenReturn(GameState.HOPPING);
		eventBus.post(gameStateChanged);
		verify(timerManager, times(1)).removeTimer(true);
	}

	@Test
	public void worldHopping_WithNullTimer()
	{
		when(timerManager.getTimer()).thenReturn(null);

		when(gameStateChanged.getGameState()).thenReturn(GameState.HOPPING);
		eventBus.post(gameStateChanged);
		verify(timerManager, times(0)).removeTimer(true);
	}
}

package com.skulltimer.events;

import com.skulltimer.data.CombatInteraction;
import com.skulltimer.enums.CombatStatus;
import com.skulltimer.mocks.PluginMocks;
import java.util.HashMap;
import net.runelite.api.Player;
import net.runelite.api.events.PlayerDespawned;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class PlayerDespawnedEventTest extends PluginMocks
{
	@Mock
	PlayerDespawned playerDespawned;
	@Mock
	Player player;
	@Mock
	HashMap<String, CombatInteraction> targetRecords;
	@Mock
	CombatInteraction combatInteraction;

	@BeforeEach
	public void startUp() throws NoSuchFieldException
	{
		super.startUp();
		when(playerDespawned.getPlayer()).thenReturn(player);
		when(player.getName()).thenReturn("Player");
		when(combatManager.getCombatRecords()).thenReturn(targetRecords);
	}

	@Test
	public void playerWasNotInRecords()
	{
		when(targetRecords.containsKey("Player")).thenReturn(false);
		eventBus.post(playerDespawned);
		verifyNoMoreInteractions(combatManager);
	}

	@Test
	public void playerWasInRecords_PlayerHasDied()
	{
		when(targetRecords.containsKey("Player")).thenReturn(true);
		when(targetRecords.get("Player")).thenReturn(combatInteraction);
		when(combatInteraction.getCombatStatus()).thenReturn(CombatStatus.DEAD);

		eventBus.post(playerDespawned);
		verifyNoMoreInteractions(combatInteraction);
	}

	@Test
	public void playerWasInRecords_PlayerHasRetaliated()
	{
		when(targetRecords.containsKey("Player")).thenReturn(true);
		when(targetRecords.get("Player")).thenReturn(combatInteraction);
		when(combatInteraction.getCombatStatus()).thenReturn(CombatStatus.RETALIATED);
		when(combatInteraction.hasRetaliated()).thenReturn(true);

		eventBus.post(playerDespawned);
		verify(combatManager.getCombatRecords().get("Player"), times(1)).setCombatStatus(CombatStatus.INACTIVE);
	}

	@Test
	public void playerWasInRecords_PlayerHasNotRetaliated_PlayerIsAlive()
	{
		when(targetRecords.containsKey("Player")).thenReturn(true);
		when(targetRecords.get("Player")).thenReturn(combatInteraction);
		when(combatInteraction.getCombatStatus()).thenReturn(CombatStatus.ATTACKED);
		when(combatInteraction.hasRetaliated()).thenReturn(false);

		eventBus.post(playerDespawned);
		verify(combatManager.getCombatRecords().get("Player"), times(1)).setCombatStatus(CombatStatus.UNCERTAIN);
	}

	@Test
	public void playerLoggedOut_hasNotRetaliated()
	{
		when(targetRecords.containsKey("Player")).thenReturn(true);
		when(targetRecords.get("Player")).thenReturn(combatInteraction);
		when(combatInteraction.getCombatStatus()).thenReturn(CombatStatus.ATTACKED);
		when(locationManager.hasPlayerLoggedOut(player)).thenReturn(true);

		eventBus.post(playerDespawned);
		verify(combatManager.getCombatRecords().get("Player"), times(1)).setCombatStatus(CombatStatus.LOGGED_OUT);
	}

	@Test
	public void playerLoggedOut_hasRetaliated()
	{
		when(targetRecords.containsKey("Player")).thenReturn(true);
		when(targetRecords.get("Player")).thenReturn(combatInteraction);
		when(combatInteraction.hasRetaliated()).thenReturn(true);

		eventBus.post(playerDespawned);
		verify(combatManager.getCombatRecords().get("Player"), times(1)).setCombatStatus(CombatStatus.INACTIVE);
	}
}

package com.skulltimer.events;

import com.skulltimer.enums.TimerDurations;
import com.skulltimer.mocks.PluginMocks;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;


import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class ChatMessageEventTest extends PluginMocks
{
	@Mock
	ChatMessage chatMessage;

	@BeforeEach
	public void startUp() throws NoSuchFieldException
	{
		super.startUp();
		when(chatMessage.getType()).thenReturn(ChatMessageType.MESBOX);
	}

	@Test
	public void EmblemTraderDialogue_Standard()
	{
		when(chatMessage.getMessage()).thenReturn("You are now skulled.");
		eventBus.post(chatMessage);
		verify(timerManager, times(1)).addTimer(TimerDurations.TRADER_AND_ITEM_DURATION.getDuration());
	}

	@Test
	public void EmblemTraderDialogue_Extended()
	{
		when(chatMessage.getMessage()).thenReturn("Your PK skull will now last for the full 20 minutes.");
		eventBus.post(chatMessage);
		verify(timerManager, times(1)).addTimer(TimerDurations.TRADER_AND_ITEM_DURATION.getDuration());
	}

	@Test
	public void MessageEvent_UnrelatedMessage()
	{
		when(chatMessage.getMessage()).thenReturn("A test message");
		eventBus.post(chatMessage);
		verify(timerManager, times(0)).addTimer(TimerDurations.TRADER_AND_ITEM_DURATION.getDuration());
	}

	@Test
	public void MessageEvent_UnrelatedMessageType()
	{
		when(chatMessage.getType()).thenReturn(ChatMessageType.UNKNOWN);
		eventBus.post(chatMessage);
		verify(timerManager, times(0)).addTimer(TimerDurations.TRADER_AND_ITEM_DURATION.getDuration());
	}
}

package com.skulltimer.events;

import com.skulltimer.data.CombatInteraction;
import com.skulltimer.enums.CombatStatus;
import com.skulltimer.mocks.PluginMocks;
import java.util.HashMap;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.events.ActorDeath;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoInteractions;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class ActorDeathEventTest extends PluginMocks
{
	@Mock
	ActorDeath actorDeath;
	@Mock
	Player player;
	@Mock
	Player localPlayer;
	@Mock
	NPC npc;
	@Mock
	HashMap<String, CombatInteraction> targetRecords;
	@Mock
	CombatInteraction combatInteraction;

	@Test
	public void npcDied()
	{
		when(actorDeath.getActor()).thenReturn(npc);
		eventBus.post(actorDeath);
		verifyNoInteractions(combatManager);
	}

	@Test
	public void playerDied_NameIsNull()
	{
		when(actorDeath.getActor()).thenReturn(player);
		when(player.getName()).thenReturn(null);
		eventBus.post(actorDeath);
		verifyNoInteractions(combatManager);
	}

	@Test
	public void localPlayerDied()
	{
		when(actorDeath.getActor()).thenReturn(localPlayer);
		when(client.getLocalPlayer()).thenReturn(localPlayer);
		when(localPlayer.getName()).thenReturn("LocalPlayer");

		eventBus.post(actorDeath);
		verify(combatManager, times(1)).clearRecords();
	}

	@Test
	public void PlayerDied_NotLocalPlayer_InTargetRecords()
	{
		when(actorDeath.getActor()).thenReturn(player);
		when(player.getName()).thenReturn("Player");
		when(client.getLocalPlayer()).thenReturn(localPlayer);
		when(localPlayer.getName()).thenReturn("LocalPlayer");
		when(combatManager.getCombatRecords()).thenReturn(targetRecords);
		when(targetRecords.containsKey("Player")).thenReturn(true);
		when(targetRecords.get("Player")).thenReturn(combatInteraction);

		eventBus.post(actorDeath);
		verify(combatInteraction, times(1)).setCombatStatus(CombatStatus.DEAD);
	}

	@Test
	public void PlayerDied_NotLocalPlayer_NotInTargetRecords()
	{
		when(actorDeath.getActor()).thenReturn(player);
		when(player.getName()).thenReturn("Player");
		when(client.getLocalPlayer()).thenReturn(localPlayer);
		when(localPlayer.getName()).thenReturn("LocalPlayer");
		when(combatManager.getCombatRecords()).thenReturn(targetRecords);
		when(targetRecords.containsKey("Player")).thenReturn(false);

		eventBus.post(actorDeath);
		verifyNoInteractions(combatInteraction);
	}

	@Test
	public void PlayerDied_InTargetRecords_TargetInteractionIsNull()
	{
		when(actorDeath.getActor()).thenReturn(player);
		when(player.getName()).thenReturn("Player");
		when(client.getLocalPlayer()).thenReturn(localPlayer);
		when(localPlayer.getName()).thenReturn("LocalPlayer");
		when(combatManager.getCombatRecords()).thenReturn(targetRecords);
		when(targetRecords.containsKey("Player")).thenReturn(true);
		when(targetRecords.get("Player")).thenReturn(null);

		eventBus.post(actorDeath);
		verifyNoInteractions(combatInteraction);
	}
}

package com.skulltimer.events;

import com.skulltimer.mocks.PluginMocks;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.events.InteractingChanged;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.mockito.ArgumentMatchers.anyBoolean;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class InteractionChangedEventTest extends PluginMocks
{
	@Mock
	InteractingChanged interactingChanged;
	@Mock
	NPC npc;
	@Mock
	Player player;
	@Mock
	Player localPlayer;
	@Mock
	Player newPlayer;

	@Test
	public void playerIsNotInWilderness()
	{
		when(locationManager.isInWilderness()).thenReturn(false);
		eventBus.post(interactingChanged);
		verify(combatManager, times(0)).onPlayerInteractionChange(anyString(), anyBoolean());
	}

	@Test
	public void targetIsNotPlayer()
	{
		when(locationManager.isInWilderness()).thenReturn(true);
		when(interactingChanged.getTarget()).thenReturn(npc);
		eventBus.post(interactingChanged);
		verify(combatManager, times(0)).onPlayerInteractionChange(anyString(), anyBoolean());
	}

	@Test
	public void sourceIsNotPlayer()
	{
		when(locationManager.isInWilderness()).thenReturn(true);
		when(interactingChanged.getTarget()).thenReturn(localPlayer);
		when(interactingChanged.getSource()).thenReturn(npc);
		eventBus.post(interactingChanged);
		verify(combatManager, times(0)).onPlayerInteractionChange(anyString(), anyBoolean());
	}

	@Test
	public void sourceIsLocalPlayer()
	{
		when(player.getName()).thenReturn("OtherPlayer");
		when(localPlayer.getName()).thenReturn("LocalPlayer");
		when(client.getLocalPlayer()).thenReturn(localPlayer);


		when(locationManager.isInWilderness()).thenReturn(true);
		when(interactingChanged.getTarget()).thenReturn(player);
		when(interactingChanged.getSource()).thenReturn(localPlayer);
		eventBus.post(interactingChanged);
		verify(combatManager, times(1)).onPlayerInteractionChange(anyString(), anyBoolean());
	}

	@Test
	public void targetIsLocalPlayer()
	{
		when(localPlayer.getName()).thenReturn("LocalPlayer");
		when(client.getLocalPlayer()).thenReturn(localPlayer);

		when(player.getName()).thenReturn("Player");

		when(locationManager.isInWilderness()).thenReturn(true);
		when(interactingChanged.getTarget()).thenReturn(localPlayer);
		when(interactingChanged.getSource()).thenReturn(player);
		eventBus.post(interactingChanged);
		verify(combatManager, times(1)).onPlayerInteractionChange("Player", true);
	}

	@Test
	public void conditionsMet_PlayerTargetsNPC()
	{
		when(localPlayer.getName()).thenReturn("LocalPlayer");
		when(client.getLocalPlayer()).thenReturn(localPlayer);
		when(player.getName()).thenReturn("Player");

		when(locationManager.isInWilderness()).thenReturn(true);
		when(interactingChanged.getTarget()).thenReturn(localPlayer);
		when(interactingChanged.getSource()).thenReturn(player);
		eventBus.post(interactingChanged);

		verify(combatManager, times(1)).onPlayerInteractionChange("Player", true);

		when(interactingChanged.getTarget()).thenReturn(npc);
		eventBus.post(interactingChanged);
		verify(combatManager, times(1)).onPlayerInteractionChange("Player", false);
	}

	@Test
	public void conditionsMet_PlayerTargetsNewPlayer()
	{
		when(localPlayer.getName()).thenReturn("LocalPlayer");
		when(client.getLocalPlayer()).thenReturn(localPlayer);
		when(player.getName()).thenReturn("Player");
		when(newPlayer.getName()).thenReturn("NewPlayer");

		when(locationManager.isInWilderness()).thenReturn(true);
		when(interactingChanged.getTarget()).thenReturn(localPlayer);
		when(interactingChanged.getSource()).thenReturn(player);
		eventBus.post(interactingChanged);

		verify(combatManager, times(1)).onPlayerInteractionChange("Player", true);

		when(interactingChanged.getTarget()).thenReturn(newPlayer);
		eventBus.post(interactingChanged);
		verify(combatManager, times(1)).onPlayerInteractionChange("Player", false);
	}

	@Test
	public void conditionsMet_PlayerTargetsNull()
	{
		when(localPlayer.getName()).thenReturn("LocalPlayer");
		when(client.getLocalPlayer()).thenReturn(localPlayer);
		when(player.getName()).thenReturn("Player");

		when(locationManager.isInWilderness()).thenReturn(true);
		when(interactingChanged.getTarget()).thenReturn(localPlayer);
		when(interactingChanged.getSource()).thenReturn(player);
		eventBus.post(interactingChanged);

		verify(combatManager, times(1)).onPlayerInteractionChange("Player", true);

		when(interactingChanged.getTarget()).thenReturn(null);
		eventBus.post(interactingChanged);
		verify(combatManager, times(1)).onPlayerInteractionChange("Player", false);
	}
}

package com.skulltimer.events;

import com.skulltimer.mocks.PluginMocks;
import java.util.ArrayList;
import java.util.List;
import net.runelite.api.ItemContainer;
import net.runelite.api.Player;
import net.runelite.api.SkullIcon;
import net.runelite.api.events.ItemContainerChanged;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.mockito.ArgumentMatchers.anyList;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class ItemContainerChangedEventTest extends PluginMocks
{
	@Mock
	ItemContainerChanged itemContainerChanged;
	@Mock
	ItemContainer itemContainer;
	@Mock
	ItemContainer itemContainerTwo;
	@Mock
	Player player;

	List<Integer> changedInventorySlots;

	@BeforeEach
	public void startUp() throws NoSuchFieldException
	{
		super.startUp();
		changedInventorySlots = new ArrayList<>();
	}

	@Test
	public void notLoggedIn_EquipmentUnavailable()
	{
		eventBus.post(itemContainerChanged);
		verify(equipmentManager, times(0)).shouldTimerBeStarted(anyList());
	}

	@Test
	public void notLoggedIn_OtherEquipmentContainerChanged()
	{
		when(itemContainerChanged.getItemContainer()).thenReturn(itemContainerTwo);
		when(equipmentManager.getEquipment()).thenReturn(itemContainer);

		eventBus.post(itemContainerChanged);
		verify(equipmentManager, times(0)).shouldTimerBeStarted(anyList());
	}

	@Test
	public void itemContainerChanged_NoEquipmentHasChanged()
	{
		when(itemContainerChanged.getItemContainer()).thenReturn(itemContainer);
		when(equipmentManager.getEquipment()).thenReturn(itemContainer);

		when(equipmentManager.getModifiedItemSlotChanges()).thenReturn(changedInventorySlots);

		eventBus.post(itemContainerChanged);
		verify(equipmentManager, times(0)).shouldTimerBeStarted(anyList());
	}

	@Test
	public void playerHasSkullIcon()
	{
		changedInventorySlots.add(1);

		when(itemContainerChanged.getItemContainer()).thenReturn(itemContainer);
		when(equipmentManager.getEquipment()).thenReturn(itemContainer);
		when(equipmentManager.getModifiedItemSlotChanges()).thenReturn(changedInventorySlots);

		when(client.getLocalPlayer()).thenReturn(player);
		when(player.getSkullIcon()).thenReturn(SkullIcon.SKULL);

		eventBus.post(itemContainerChanged);
		verify(equipmentManager, times(1)).shouldTimerBeStarted(anyList());
	}

	@Test
	public void playerDoesNotHaveSkullIcon()
	{
		changedInventorySlots.add(1);

		when(itemContainerChanged.getItemContainer()).thenReturn(itemContainer);
		when(equipmentManager.getEquipment()).thenReturn(itemContainer);
		when(equipmentManager.getModifiedItemSlotChanges()).thenReturn(changedInventorySlots);

		when(client.getLocalPlayer()).thenReturn(player);
		when(player.getSkullIcon()).thenReturn(SkullIcon.NONE);

		eventBus.post(itemContainerChanged);
		verify(equipmentManager, times(0)).shouldTimerBeStarted(anyList());
	}
}

