package com.infernostats;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class InfernoStatsPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(InfernoStatsPlugin.class);
		RuneLite.main(args);
	}
}
package com.infernostats;

import com.infernostats.controller.TimerHandler;
import com.infernostats.model.Location;
import com.infernostats.model.Wave;
import com.infernostats.view.TimeFormatting;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

import javax.inject.Inject;
import java.awt.*;
import java.util.*;

public class InfernoStatsOverlay extends OverlayPanel {
	private Wave prevSplitWave;

	private final InfernoStatsPlugin plugin;
	private final InfernoStatsConfig config;

	@Inject
	private InfernoStatsOverlay(InfernoStatsPlugin plugin, InfernoStatsConfig config) {
		super(plugin);

		this.plugin = plugin;
		this.config = config;
		this.prevSplitWave = null;

		setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
		setPriority(OverlayPriority.MED);
	}

	@Override
	public Dimension render(Graphics2D graphics) {
		if (!this.plugin.isInInferno() && !this.plugin.isInFightCaves())
			return null;

		panelComponent.getChildren().clear();

		Wave wave = this.plugin.getCurrentWave();
		if (wave == null)
			return null;

		if (this.plugin.getTimerState() != TimerHandler.TimerState.RUNNING)
			return null;

		String header = "Current Wave: " + wave.getId();
		LinkedHashMap<String, String> contents = new LinkedHashMap<>();

		if (wave.isSplit())
			prevSplitWave = wave;

		if (prevSplitWave != null) {
			if (config.splitTimes()) {
				contents.put("Wave " + prevSplitWave.getId() + " Split: ", TimeFormatting.getSplitTime(prevSplitWave));
			}

			if ((prevSplitWave.getLocation() == Location.INFERNO) &&
				(config.predictedCompletionTime() && prevSplitWave.getPace() != null))
			{
				contents.put("Predicted Time: ", TimeFormatting.formatDuration(prevSplitWave.getPace()));
			}
		}

		panelComponent.getChildren().add(TitleComponent.builder()
				.text(header)
				.color(ColorScheme.BRAND_ORANGE)
				.build());

		panelComponent.setPreferredSize(new Dimension(getMaxWidth(graphics, contents, header) + 10, 0));

		for (Map.Entry<String, String> pair : contents.entrySet()) {
			panelComponent.getChildren().add(
					LineComponent
							.builder()
							.left(pair.getKey())
							.right(pair.getValue())
							.build());
		}

		return super.render(graphics);
	}

	private int getMaxWidth(Graphics2D graphics, HashMap<String, String> contents, String header) {
		if (contents.isEmpty())
			return graphics.getFontMetrics().stringWidth(header);

		Map.Entry<String, String> longestPair =
				Collections.max(contents.entrySet(), Comparator.comparingInt(this::keyValueLength));

		return graphics.getFontMetrics().stringWidth(longestPair.getKey()) +
				graphics.getFontMetrics().stringWidth(longestPair.getValue());
	}

	private int keyValueLength(Map.Entry<String, String> entry) {
		return entry.getKey().length() + entry.getValue().length();
	}

	public void reset() {
		this.prevSplitWave = null;
	}
}

package com.infernostats;

import com.infernostats.controller.TimerHandler;
import lombok.AllArgsConstructor;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup(InfernoStatsConfig.GROUP)
public interface InfernoStatsConfig extends Config {
	String GROUP = "InfernoConfig";

	@ConfigSection(
			name = "Overlays",
			description = "Overlays Section",
			position = 0,
			closedByDefault = true
	)
	String overlays = "overlays";

	@ConfigItem(
			position = 0,
			keyName = "splitsOverlay",
			name = "Splits Overlay",
			description = "Displays an overlay with the wave number and splits/predicted time.",
			section = overlays
	)
	default boolean splitsOverlay() {
		return true;
	}

	@ConfigItem(
			position = 1,
			keyName = "showInfernoTimer",
			name = "Inferno Timer",
			description = "Display elapsed time in the Inferno",
			section = overlays
	)
	default boolean showInfernoTimer() {
		return true;
	}

	@ConfigItem(
			position = 2,
			keyName = "showFightCavesTimer",
			name = "Fight Caves Timer",
			description = "Display elapsed time in the Fight Caves",
			section = overlays
	)
	default boolean showFightCavesTimer() {
		return true;
	}

	@ConfigItem(
			keyName = "tzhaarDuration",
			name = "",
			description = "",
			section = overlays,
			hidden = true
	)
	long tzhaarDuration();

	@ConfigItem(
			keyName = "tzhaarDuration",
			name = "",
			description = "",
			section = overlays
	)
	void tzhaarDuration(long tzhaarDuration);

	@ConfigItem(
			keyName = "tzhaarTimerState",
			name = "",
			description = "",
			section = overlays,
			hidden = true
	)
	TimerHandler.TimerState tzhaarTimerState();

	@ConfigItem(
			keyName = "tzhaarTimerState",
			name = "",
			description = "",
			section = overlays
	)
	void tzhaarTimerState(TimerHandler.TimerState tzhaarTimerState);

	@ConfigSection(
			name = "Wave and Split Times",
			description = "Wave and Split Times Section",
			position = 1,
			closedByDefault = true
	)
	String waveAndSplitTimes = "waveAndSplitTimes";

	@ConfigItem(
			position = 0,
			keyName = "showWaveTimes",
			name = "Wave Times",
			description = "Displays a chat message of the time taken to complete the previous wave",
			section = waveAndSplitTimes
	)
	default boolean waveTimes() {
		return false;
	}

	@ConfigItem(
			position = 1,
			keyName = "showSplitTimes",
			name = "Split Times",
			description = "Displays a chat message of the total time taken to reach the current wave",
			section = waveAndSplitTimes
	)
	default boolean splitTimes() {
		return true;
	}

	@ConfigItem(
			position = 2,
			keyName = "predictedCompletionTime",
			name = "Predicted Time",
			description = "Show predicted completion time",
			section = waveAndSplitTimes
	)
	default boolean predictedCompletionTime() {
		return true;
	}

	@ConfigItem(
			position = 3,
			keyName = "saveWaveTimes",
			name = "Save Wave Times",
			description = "Saves the time of every wave after a run",
			section = waveAndSplitTimes
	)
	default boolean saveWaveTimes() {
		return false;
	}

	@ConfigItem(
			position = 4,
			keyName = "saveSplitTimes",
			name = "Save Split Times",
			description = "Saves the time of every split after a run",
			section = waveAndSplitTimes
	)
	default boolean saveSplitTimes() {
		return true;
	}

	@AllArgsConstructor
	enum FileType {
		TEXT,
		CSV
	}

	@ConfigItem(
			position = 5,
			keyName = "splitsFileType",
			name = "Splits File Type",
			description = "File type to save splits as",
			section = waveAndSplitTimes
	)
	default FileType splitsFileType() {
		return FileType.TEXT;
	}

	@ConfigSection(
			name = "Target Split Times",
			description = "Split times that you wish to achieve",
			position = 2,
			closedByDefault = true
	)
	String targetSplitTimes = "targetSplitTimes";

	@ConfigItem(
			position = 0,
			keyName = "targetSplitTimes",
			name = "Target Split Times",
			description = "Enable Target Split Times",
			section = targetSplitTimes
	)
	default boolean showTargetSplitTimes() {
		return false;
	}

	@ConfigItem(
			position = 1,
			keyName = "targetWave9Split",
			name = "Wave 9",
			description = "Split Target",
			section = targetSplitTimes
	)
	default String targetWave9Split() {
		return "2:55";
	}

	@ConfigItem(
			position = 2,
			keyName = "targetWave18Split",
			name = "Wave 18",
			description = "Split Target",
			section = targetSplitTimes
	)
	default String targetWave18Split() {
		return "7:15";
	}

	@ConfigItem(
			position = 3,
			keyName = "targetWave25Split",
			name = "Wave 25",
			description = "Split Target",
			section = targetSplitTimes
	)
	default String targetWave25Split() {
		return "11:05";
	}

	@ConfigItem(
			position = 4,
			keyName = "targetWave35Split",
			name = "Wave 35",
			description = "Split Target",
			section = targetSplitTimes
	)
	default String targetWave35Split() {
		return "17:58";
	}

	@ConfigItem(
			position = 5,
			keyName = "targetWave42Split",
			name = "Wave 42",
			description = "Split Target",
			section = targetSplitTimes
	)
	default String targetWave42Split() {
		return "23:13";
	}

	@ConfigItem(
			position = 6,
			keyName = "targetWave50Split",
			name = "Wave 50",
			description = "Split Target",
			section = targetSplitTimes
	)
	default String targetWave50Split() {
		return "30:50";
	}

	@ConfigItem(
			position = 7,
			keyName = "targetWave57Split",
			name = "Wave 57",
			description = "Split Target",
			section = targetSplitTimes
	)
	default String targetWave57Split() {
		return "38:06";
	}

	@ConfigItem(
			position = 8,
			keyName = "targetWave60Split",
			name = "Wave 60",
			description = "Split Target",
			section = targetSplitTimes
	)
	default String targetWave60Split() {
		return "41:29";
	}

	@ConfigItem(
			position = 9,
			keyName = "targetWave63Split",
			name = "Wave 63",
			description = "Split Target",
			section = targetSplitTimes
	)
	default String targetWave63Split() {
		return "44:59";
	}

	@ConfigItem(
			position = 10,
			keyName = "targetWave66Split",
			name = "Wave 66",
			description = "Split Target",
			section = targetSplitTimes
	)
	default String targetWave66Split() {
		return "48:41";
	}

	@ConfigItem(
			position = 11,
			keyName = "targetWave67Split",
			name = "Wave 67",
			description = "Split Target",
			section = targetSplitTimes
	)
	default String targetWave67Split() {
		return "49:27";
	}

	@ConfigItem(
			position = 12,
			keyName = "targetWave68Split",
			name = "Wave 68",
			description = "Split Target",
			section = targetSplitTimes
	)
	default String targetWave68Split() {
		return "50:32";
	}

	@ConfigItem(
			position = 13,
			keyName = "targetWave69Split",
			name = "Wave 69",
			description = "Split Target",
			section = targetSplitTimes
	)
	default String targetWave69Split() {
		return "53:06";
	}

	@ConfigSection(
			name = "Idle Ticks",
			description = "Settings around tracking player idle ticks",
			position = 4,
			closedByDefault = true
	)
	String idleTicks = "idleTicks";

	@ConfigItem(
			keyName = "showIdleTicksInSidePanel",
			name = "Show Idle Ticks in Side Panel",
			description = "Show idle ticks in the side panel",
			position = 0,
			section = idleTicks
	)
	default boolean showIdleTicksInSidePanel() {
		return true;
	}

	@ConfigItem(
			keyName = "showIdleTicksInChatbox",
			name = "Show Idle Ticks in Chatbox",
			description = "Show idle ticks in the chat box",
			position = 1,
			section = idleTicks
	)
	default boolean showIdleTicksInChatbox() {
		return false;
	}

	@AllArgsConstructor
	enum URL {
		LINE_OF_SIGHT("https://infernostats.github.io/inferno.html?"),
		TRAINER("https://www.infernotrainer.com/?");

		public final String base;
	}

	@ConfigItem(
			position = 5,
			keyName = "url",
			name = "Wave Tool",
			description = "Tool to use when opening wave spawns"
	)
	default URL url() {
		return URL.LINE_OF_SIGHT;
	}

	@ConfigItem(
			position = 6,
			keyName = "hide",
			name = "Hide when outside of the Inferno",
			description = "Don't show the button in the sidebar when you're not in the Inferno"
	)
	default boolean hide() {
		return false;
	}
}

package com.infernostats.events;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public class TimerStoppedEvent {
}

package com.infernostats.events;

import com.infernostats.model.WaveState;
import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class WaveFinishedEvent {
	WaveState state;
}

package com.infernostats.events;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class TimerStartedEvent {
	int offset;
}

package com.infernostats.events;

import com.infernostats.model.Wave;
import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class WaveStartedEvent {
	Wave wave;
}

package com.infernostats.events;

import com.infernostats.model.WaveState;
import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class RunCompletedEvent {
	WaveState state;
}

package com.infernostats.events;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public class TimerPausedEvent {
}

package com.infernostats;

import com.google.inject.Provides;
import com.infernostats.controller.ChatHandler;
import com.infernostats.controller.TickLossHandler;
import com.infernostats.controller.TimerHandler;
import com.infernostats.controller.WaveHandler;
import com.infernostats.events.*;
import com.infernostats.model.Wave;
import com.infernostats.model.WaveSplit;
import com.infernostats.model.WaveState;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.ImageUtil;
import org.apache.commons.lang3.ArrayUtils;

import javax.inject.Inject;

import java.util.ArrayList;

import static net.runelite.api.ItemID.FIRE_CAPE;
import static net.runelite.api.ItemID.INFERNAL_CAPE;

@PluginDescriptor(
		name = "Inferno Stats",
		description = "Track restoration specials during an inferno attempt.",
		tags = {"combat", "npcs", "overlay"}
)
@Slf4j
public class InfernoStatsPlugin extends Plugin {
	private static final int INFERNO_REGION_ID = 9043;
	private static final int FIGHT_CAVES_REGION_ID = 9551;

	@Getter(AccessLevel.PACKAGE)
	private InfernoStatsPanel panel;

	@Getter(AccessLevel.PACKAGE)
	private NavigationButton navButton;

	@Inject
	private ChatHandler chatHandler;

	@Inject
	private TimerHandler timerHandler;

	@Inject
	private WaveHandler waveHandler;

	@Inject
	private TickLossHandler tickLossHandler;

	@Inject
	private Client client;

	@Inject
	private EventBus eventBus;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private ItemManager itemManager;

	@Inject
	private InfoBoxManager infoBoxManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private InfernoStatsOverlay overlay;

	@Inject
	private InfernoStatsConfig config;

	@Provides
	InfernoStatsConfig getConfig(ConfigManager configManager) {
		return configManager.getConfig(InfernoStatsConfig.class);
	}

	@Override
	protected void startUp() {
		panel = injector.getInstance(InfernoStatsPanel.class);
		navButton = NavigationButton.builder()
				.tooltip("Inferno Stats")
				.icon(ImageUtil.loadImageResource(getClass(), "/blob-square.png"))
				.priority(6)
				.panel(panel)
				.build();

		if (isInInferno() || !config.hide())
			clientToolbar.addNavigation(navButton);

		if (config.splitsOverlay())
			overlayManager.add(overlay);

		WaveSplit.UpdateTargetSplits(this.config);

		eventBus.register(waveHandler);
		eventBus.register(timerHandler);
		eventBus.register(chatHandler);
		eventBus.register(tickLossHandler);

		eventBus.register(TimerStartedEvent.class);
		eventBus.register(TimerPausedEvent.class);
		eventBus.register(TimerStoppedEvent.class);
	}

	@Override
	protected void shutDown() {
		overlayManager.remove(overlay);
		clientToolbar.removeNavigation(navButton);

		eventBus.unregister(TimerStartedEvent.class);
		eventBus.unregister(TimerPausedEvent.class);
		eventBus.unregister(TimerStoppedEvent.class);

		eventBus.unregister(tickLossHandler);
		eventBus.unregister(chatHandler);
		eventBus.unregister(timerHandler);
		eventBus.unregister(waveHandler);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event) {
		if (!event.getGroup().equals(this.config.GROUP))
			return;

		switch (event.getKey())
		{
			case "hide":
				resetNav();
				break;
			case "showInfernoTimer":
			case "showFightCavesTimer":
				createTimer();
				break;
			case "splitsOverlay":
				if (config.splitsOverlay()) {
					overlayManager.add(overlay);
				} else {
					overlayManager.remove(overlay);
				}
		}

		WaveSplit.UpdateTargetSplits(this.config);
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged) {
		switch (gameStateChanged.getGameState()) {
			case LOADING:
				if (timerHandler.getState() == TimerHandler.TimerState.RUNNING)
					if (!isInFightCaves() && !isInInferno()) {
						eventBus.post(new TimerStoppedEvent());
						eventBus.post(new RunCompletedEvent(WaveState.FAILED));
					}
				resetNav();
				break;
			case LOGIN_SCREEN:
			case HOPPING:
				if (timerHandler.getState() == TimerHandler.TimerState.RUNNING)
					eventBus.post(new TimerPausedEvent());
				break;
		}
	}

	@Subscribe
	protected void onGameTick(GameTick e) {
		if (isInInferno() || isInFightCaves())
			this.panel.UpdateWave();
	}

	@Subscribe
	protected void onWaveStartedEvent(WaveStartedEvent e) {
		Wave wave = e.getWave();
		if (wave.getId() == 1)
			this.panel.ClearWaves();
		this.panel.AddWave(wave);
	}

	@Subscribe
	protected void onWaveFinishedEvent(WaveFinishedEvent e) {
		this.panel.UpdateWave();
	}

	@Subscribe
	protected void onRunCompletedEvent(RunCompletedEvent e) {
		Wave wave = this.getCurrentWave();
		wave.setState(e.getState());

		this.panel.UpdateWave();
		this.waveHandler.WriteWaves();
	}

	@Subscribe
	protected void onTimerStartedEvent(TimerStartedEvent e) {
		createTimer();
	}

	@Subscribe
	protected void onTimerStoppedEvent(TimerStoppedEvent e) {
		removeTimer();
		overlay.reset();
	}

	private void resetNav() {
		if (isInInferno() || !config.hide())
			clientToolbar.addNavigation(navButton);
		else
			clientToolbar.removeNavigation(navButton);
	}

	private void createTimer() {
		removeTimer();

		if (config.showFightCavesTimer() && isInFightCaves())
			infoBoxManager.addInfoBox(new InfernoStatsTimer(itemManager.getImage(FIRE_CAPE), this));
		else if (config.showInfernoTimer() && isInInferno())
			infoBoxManager.addInfoBox(new InfernoStatsTimer(itemManager.getImage(INFERNAL_CAPE), this));
	}

	private void removeTimer() {
		infoBoxManager.removeIf(InfernoStatsTimer.class::isInstance);
	}

	public Wave getCurrentWave() {
		return waveHandler.getWave();
	}

	public ArrayList<Wave> getWaves() {
		return waveHandler.getWaves();
	}

	public TimerHandler.TimerState getTimerState() {
		return timerHandler.getState();
	}

	public long getRunDuration() {
		return timerHandler.getDuration();
	}

	public boolean isInInferno() {
		return client.getMapRegions() != null && ArrayUtils.contains(client.getMapRegions(), INFERNO_REGION_ID);
	}

	public boolean isInFightCaves() {
		return client.getMapRegions() != null && ArrayUtils.contains(client.getMapRegions(), FIGHT_CAVES_REGION_ID);
	}
}
package com.infernostats;

import com.infernostats.view.TimeFormatting;
import net.runelite.client.ui.overlay.infobox.InfoBox;

import java.awt.*;
import java.awt.image.BufferedImage;

public class InfernoStatsTimer extends InfoBox {
	private final InfernoStatsPlugin plugin;

	public InfernoStatsTimer(BufferedImage image, InfernoStatsPlugin plugin) {
		super(image, plugin);

		this.plugin = plugin;
	}

	@Override
	public String getText() {
		return getTime();
	}

	@Override
	public String getTooltip() {
		return "Elapsed time: " + getTime();
	}

	@Override
	public Color getTextColor() {
		return Color.WHITE;
	}

	private String getTime() {
		return TimeFormatting.formatGameTicks(this.plugin.getRunDuration());
	}
}

package com.infernostats.controller;

import com.infernostats.InfernoStatsConfig;
import com.infernostats.InfernoStatsPlugin;
import com.infernostats.events.TimerPausedEvent;
import com.infernostats.events.TimerStartedEvent;
import com.infernostats.events.TimerStoppedEvent;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.GameTick;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;

@Slf4j
@Getter
public class TimerHandler {

	public enum TimerState {
		RUNNING,
		PAUSED,
		STOPPED
	}

	private long duration;
	private TimerState state;

	private final InfernoStatsPlugin plugin;
	private final InfernoStatsConfig config;

	@Inject
	protected TimerHandler(InfernoStatsPlugin plugin, InfernoStatsConfig config) {
		this.plugin = plugin;
		this.config = config;
		this.duration = 0;
		this.state = TimerState.STOPPED;
	}

	@Subscribe
	protected void onTimerStartedEvent(TimerStartedEvent e) {
		if (this.state == TimerState.STOPPED)
			this.duration = e.getOffset();
		else
			this.duration += e.getOffset();

		this.state = TimerState.RUNNING;
		this.config.tzhaarTimerState(this.state);
	}

	@Subscribe
	protected void onTimerPausedEvent(TimerPausedEvent e) {
		this.state = TimerState.PAUSED;
		this.config.tzhaarTimerState(this.state);
		this.config.tzhaarDuration(this.duration);
	}

	@Subscribe
	protected void onTimerStoppedEvent(TimerStoppedEvent e) {
		this.state = TimerState.STOPPED;
		this.config.tzhaarTimerState(this.state);
		this.config.tzhaarDuration(this.duration);
	}

	@Subscribe
	protected void onGameTick(GameTick e) {
		if (this.state == TimerState.RUNNING)
			this.duration += 1;
	}
}

package com.infernostats.controller;

import com.google.common.collect.Sets;
import com.infernostats.InfernoStatsConfig;
import com.infernostats.InfernoStatsPlugin;
import com.infernostats.events.WaveStartedEvent;
import com.infernostats.model.Wave;
import com.infernostats.model.WaveState;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.StatChanged;
import net.runelite.api.kit.KitType;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;

import javax.inject.Inject;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

@Slf4j
public class TickLossHandler {
	private Wave wave;
	private int magicXp;
	private int tickDelay;
	private int currChinCount;
	private int prevChinCount;
	private Animation currAnim;
	private Animation prevAnim;
	private Set<Integer> attackableNpcs;

	private static final int SPELLBOOK_VARBIT = 4070;
	private static final Set<TickLossHandler.Animation> blowpipeAnimations = Set.of(
		Animation.BLOWPIPE, Animation.BLOWPIPE_BLAZING);

	@Inject
	private Client client;

	@Inject
	private ItemManager itemManager;

	private final InfernoStatsPlugin plugin;
	private final InfernoStatsConfig config;

	@Inject
	protected TickLossHandler(InfernoStatsPlugin plugin, InfernoStatsConfig config) {
		this.plugin = plugin;
		this.config = config;

		this.magicXp = -1;
		this.tickDelay = 0;
		this.currChinCount = -1;
		this.prevChinCount = -1;

		this.currAnim = Animation.UNKNOWN;
		this.prevAnim = Animation.UNKNOWN;

		this.attackableNpcs = new HashSet<>();
	}

	@Subscribe
	protected void onWaveStartedEvent(WaveStartedEvent e) {
		this.wave = e.getWave();
	}

	@Subscribe
	public void onStatChanged(StatChanged e) {
		if (e.getSkill() != Skill.MAGIC)
			return;

		final int newMagicXp = e.getXp();
		if (newMagicXp == this.magicXp)
			return;

		this.magicXp = newMagicXp;

		// Standard (0), Ancient (1), Lunar (2), Arceuus (3)
		if (this.client.getVarbitValue(SPELLBOOK_VARBIT) != 1)
			return;

		// Ghost barrage occurred
		if (blowpipeAnimations.contains(this.prevAnim))
			this.tickDelay += 5;
	}

	@Subscribe
	protected void onGameTick(GameTick e) {
		if (this.tickDelay > 0)
			this.tickDelay -= 1;

		if (isCooldownActive() || !isWaveActive())
			return;

		Player player = this.client.getLocalPlayer();
		if (player == null)
			return;

		PlayerComposition composition = player.getPlayerComposition();
		if (composition == null)
			return;

		final int weapon = composition.getEquipmentId(KitType.WEAPON);

		this.prevAnim = this.currAnim;
		this.currAnim = Animation.valueOf(player.getAnimation());

		if (!blowpipeAnimations.contains(this.prevAnim) && blowpipeAnimations.contains(this.currAnim)) {
			this.tickDelay = 2;
		} else if (blowpipeAnimations.contains(this.prevAnim) && blowpipeAnimations.contains(this.currAnim)) {
			if (player.getAnimationFrame() == 0)
				this.tickDelay = 2;
		}

		this.tickDelay += getAnimationDelay(this.currAnim, weapon);

		Set<Integer> prevNpcs = attackableNpcs;
		this.attackableNpcs = getNearbyAttackableNpcs();
		if (prevNpcs.size() != 0) {
			Set<Integer> intersection = Sets.intersection(prevNpcs, attackableNpcs);
			if (intersection.size() > 0 && this.tickDelay == 0) {
				this.wave.setIdleTicks(this.wave.getIdleTicks() + 1);
			}
		}
	}

	private boolean isCooldownActive() {
		return this.tickDelay > 1;
	}

	private boolean isWaveActive() {
		return this.wave != null && this.wave.getState() == WaveState.STARTED;
	}

	private Set<Integer> getNearbyAttackableNpcs() {
		Set<Integer> result = new HashSet<>();
		if (!this.client.getNpcs().isEmpty()) {
			this.client.getNpcs().stream().filter(npc -> {
				return !npc.isDead() && isAttackable(npc);
			}).forEach(npc -> result.add(npc.getIndex()));
		}
		return result;
	}

	private boolean isAttackable(NPC npc) {
		for (int i = 0; i < npc.getComposition().getActions().length; ++i) {
			String action = npc.getComposition().getActions()[i];
			if (action != null && action.equals("Attack")) {
				return true;
			}
		}
		return false;
	}

	private int getAnimationDelay(Animation animation, int weapon) {
		switch (animation) {
			case IDLE:
			case THRALL:
			case DEATH_CHARGE:
			case BLOWPIPE:
			case BLOWPIPE_BLAZING:
				switch (weapon) {
					case ItemID.CHINCHOMPA:
					case ItemID.CHINCHOMPA_10033:
					case ItemID.RED_CHINCHOMPA:
					case ItemID.RED_CHINCHOMPA_10034:
					case ItemID.BLACK_CHINCHOMPA:
						break;
					default:
						return 0;
				}

				ItemContainer itemContainer = client.getItemContainer(InventoryID.EQUIPMENT);
				if (itemContainer == null)
					return 0;

				this.prevChinCount = this.currChinCount;
				this.currChinCount = itemContainer.count(weapon);

				if (this.prevChinCount > this.currChinCount)
					return 3;

				return 0;
			case EVENT_RPG:
			case CHINCHOMPA:
			case TRIDENT_SANG:
				return 3;
			case BOW:
				switch (weapon) {
					case ItemID.TWISTED_BOW:
						return 5;
					case ItemID.BOW_OF_FAERDHINEN:
					case ItemID.BOW_OF_FAERDHINEN_C:
					case ItemID.BOW_OF_FAERDHINEN_C_25884:
					case ItemID.BOW_OF_FAERDHINEN_C_25886:
					case ItemID.BOW_OF_FAERDHINEN_C_25888:
					case ItemID.BOW_OF_FAERDHINEN_C_25890:
					case ItemID.BOW_OF_FAERDHINEN_C_25892:
					case ItemID.BOW_OF_FAERDHINEN_C_25894:
					case ItemID.BOW_OF_FAERDHINEN_C_25896:
						return 4;
					default:
						return 3;
				}
			case SURGE:
				return weapon == ItemID.HARMONISED_NIGHTMARE_STAFF ? 4 : 5;
			case STAFF_BASH:
				switch (weapon) {
					case ItemID.BEGINNER_WAND:
					case ItemID.APPRENTICE_WAND:
					case ItemID.TEACHER_WAND:
					case ItemID.MASTER_WAND:
					case ItemID.KODAI_WAND:
					case ItemID._3RD_AGE_WAND:
						return 4;
					default:
						return 5;
				}
			case CLAW_SCRATCH:
			case CLAW_SPEC:
			case RAPIER:
			case INQ_MACE:
				return 4;
			case DINHS:
			case STRIKE_BOLT:
			case BURST_BLITZ:
			case CROSSBOW:
			case SCYTHE:
			case BARRAGE:
				return 5;
			case CHALLY_JAB:
			case CHALLY_SWIPE:
			case CHALLY_SPEC:
				return 7;
			default:
				return 0;
		}
	}

	@Getter
	@AllArgsConstructor
	private enum Animation {
		UNKNOWN(-2),
		IDLE(-1),
		CLAW_SCRATCH(393),
		STAFF_BASH(414),
		PUNCH(422),
		KICK(423),
		BOW(426),
		CHALLY_JAB(428),
		CHALLY_SWIPE(440),
		MSB_SPEC(1074),
		STRIKE_BOLT(1162),
		TRIDENT_SANG(1167),
		CHALLY_SPEC(1203),
		BURST_BLITZ(1379),
		BARRAGE(1979),
		EVENT_RPG(2323),
		INQ_MACE(4503),
		BLOWPIPE(5061),
		DINHS(7511),
		CLAW_SPEC(7514),
		CROSSBOW(7552),
		CHINCHOMPA(7618),
		SURGE(7855),
		SCYTHE(8056),
		RAPIER(8145),
		DEATH_CHARGE(8970),
		THRALL(8973),
		BLOWPIPE_BLAZING(10656);

		private final int id;

		public static Animation valueOf(int id) {
			return Arrays.stream(values())
					.filter(anim -> anim.id == id)
					.findFirst()
					.orElse(UNKNOWN);
		}
	}
}


package com.infernostats.controller;

import com.infernostats.InfernoStatsConfig;
import com.infernostats.InfernoStatsPlugin;
import com.infernostats.events.WaveFinishedEvent;
import com.infernostats.events.WaveStartedEvent;
import com.infernostats.model.Wave;
import com.infernostats.model.Location;
import com.infernostats.model.WaveState;
import com.infernostats.view.TimeFormatting;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.NpcSpawned;
import net.runelite.api.events.StatChanged;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;

import static net.runelite.api.Skill.PRAYER;
import static net.runelite.client.RuneLite.RUNELITE_DIR;

@Slf4j
public class WaveHandler {
	@Getter
	private Wave wave;

	@Getter
	@Setter
	private Location location;

	@Getter
	private final ArrayList<Wave> waves;

	private int prayer;

	@Inject
	private Client client;

	@Inject
	private EventBus eventBus;

	private final InfernoStatsPlugin plugin;
	private final InfernoStatsConfig config;

	@Inject
	protected WaveHandler(InfernoStatsPlugin plugin, InfernoStatsConfig config) {
		this.plugin = plugin;
		this.config = config;
		this.wave = null;
		this.waves = new ArrayList<>();
	}

	@Subscribe
	protected void onGameTick(GameTick e) {
		if ((!this.plugin.isInInferno() && !this.plugin.isInFightCaves()) || this.wave == null)
			return;

		if (this.wave.getState() != WaveState.STARTED)
			return;

		if (this.plugin.getTimerState() == TimerHandler.TimerState.RUNNING)
			this.wave.setDuration(this.wave.getDuration() + 1);

		prayer = client.getBoostedSkillLevel(PRAYER);
	}

	@Subscribe
	public void onStatChanged(StatChanged event) {
		if ((!this.plugin.isInInferno() && !this.plugin.isInFightCaves()) || this.wave == null)
			return;

		if (this.wave.getState() != WaveState.STARTED)
			return;

		if (event.getSkill() != PRAYER)
			return;

		if (event.getBoostedLevel() == prayer - 1)
			wave.setPrayerDrain(wave.getPrayerDrain() + 1);
	}

	@Subscribe(priority = 1)
	protected void onWaveStartedEvent(WaveStartedEvent e) {
		if (this.plugin.isInInferno())
			setLocation(Location.INFERNO);
		else if (this.plugin.isInFightCaves())
			setLocation(Location.FIGHT_CAVES);

		this.wave = e.getWave();
		if (this.wave.getId() == 1)
			waves.clear();
		this.waves.add(this.wave);
	}

	@Subscribe(priority = 1)
	protected void onWaveFinishedEvent(WaveFinishedEvent e) {
		this.wave.setState(e.getState());
	}

	@Subscribe
	protected void onNpcSpawned(NpcSpawned e) {
		final NPC npc = e.getNpc();
		final Actor npcActor = e.getActor();
		final WorldPoint spawnTile = npcActor.getWorldLocation();
		final int npcId = npc.getId();

		if (!this.plugin.isInInferno() || this.wave == null)
			return;

		// ROCKY_SUPPORT is the normal pillar id; ROCKY_SUPPORT_7710 spawns as a pillar falls
		if (npcId == NpcID.ROCKY_SUPPORT || npcId == NpcID.ROCKY_SUPPORT_7710)
			return;

		// We'll ignore nibblers and jads, and zuk spawns off the map
		if (npcId == NpcID.JALNIB || npcId == NpcID.JALTOKJAD || npcId == NpcID.TZKALZUK)
			return;

		// We only want the original wave spawn, not minions or mager respawns
		if (wave.duration().compareTo(Duration.ofSeconds(1)) > 0)
			return;

		wave.addNPC(npc.getName(), spawnTile);
	}

	@Subscribe
	public void onHitsplatApplied(HitsplatApplied event) {
		Actor target = event.getActor();
		Hitsplat hitsplat = event.getHitsplat();

		if ((!this.plugin.isInInferno() && !this.plugin.isInFightCaves()) || this.wave == null)
			return;

		if (!hitsplat.isMine())
			return;

		if (target == this.client.getLocalPlayer()) {
			this.wave.setDamageTaken(this.wave.getDamageTaken() + hitsplat.getAmount());
		} else {
			this.wave.setDamageDealt(this.wave.getDamageDealt() + hitsplat.getAmount());
		}
	}

	public void WriteWaves()
	{
		Player player = client.getLocalPlayer();
		if (player == null)
			return;

		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH-mm-ss");
		String time = formatter.format(LocalDateTime.now());

		if (config.saveWaveTimes()) {
			switch (config.splitsFileType())
			{
				case TEXT:
					toFile(player.getName(), fileName(time, false), toText(false));
					break;
				case CSV:
					toFile(player.getName(), fileName(time, false), toCSV(false));
					break;
			}
		}

		if (config.saveSplitTimes()) {
			switch (config.splitsFileType())
			{
				case TEXT:
					toFile(player.getName(), fileName(time, true), toText(true));
					break;
				case CSV:
					toFile(player.getName(), fileName(time, true), toCSV(true));
					break;
			}
		}
	}

	private void toFile(String username, String filename, String contents) {
		try {
			Path path = null;
			switch (this.wave.getLocation())
			{
				case FIGHT_CAVES:
					path = Files.createDirectories(Paths.get(
						RUNELITE_DIR.getPath(), "inferno-stats", username, "fight-caves"));
					break;
				case INFERNO:
					path = Files.createDirectories(Paths.get(
						RUNELITE_DIR.getPath(), "inferno-stats", username, "inferno"));
					break;
			}
			Files.write(path.resolve(filename), contents.getBytes());
		} catch (IOException ex) {
			log.debug("Error writing file: {}", ex.getMessage());
		}
	}

	private String toText(boolean splitWaves) {
		StringBuilder text = new StringBuilder();
		ArrayList<Wave> waves = this.getWaves();

		if (splitWaves)
		{
			Wave prev = null;
			for (Wave wave : waves) {
				if (!wave.isSplit())
					continue;

				text.append("Wave: ").append(wave.getId())
						.append(", ")
						.append("Split: ").append(TimeFormatting.getSplitTime(wave))
						.append(" ")
						.append("(+").append(TimeFormatting.getSplitDelta(wave, prev)).append(")")
						.append("\n");

				prev = wave;
			}
		}
		else
		{
			for (Wave wave : waves) {
				text.append("Wave: ").append(wave.getId())
						.append(", ")
						.append("Split: ").append(TimeFormatting.getSplitTime(wave))
						.append("\n");
			}
		}

		if (waves.isEmpty()) {
			text.append("Duration (Not Started): N/a");
			return text.toString();
		}

		String duration = TimeFormatting.getCurrentTotalTime(wave);
		switch (wave.getState()) {
			case FINISHED:
			case STARTED:
				text.append("Duration (Unfinished): ").append(duration);
				break;
			case SUCCESS:
				text.append("Duration (Success): ").append(duration);
				break;
			case FAILED:
				text.append("Duration (Failed): ").append(duration);
				break;
		}

		return text.toString();
	}

	private String toCSV(boolean splitWaves) {
		StringBuilder csv = new StringBuilder();

		if (splitWaves) {
			csv.append("wave,split,time,delta,idle\n");

			Wave prev = null;
			for (Wave wave : waves) {
				if (!wave.isSplit())
					continue;

				csv.append(wave.getId())
						.append(",")
						.append(TimeFormatting.getSplitTimeCSV(wave))
						.append(",")
						.append(TimeFormatting.getCurrentWaveTimeCSV(wave))
						.append(",")
						.append(TimeFormatting.getSplitDeltaCSV(wave, prev))
						.append(",")
						.append(wave.getIdleTicks())
						.append("\n");

				prev = wave;
			}
		} else {
			csv.append("wave,split,time,idle\n");

			for (Wave wave : waves) {
				csv.append(wave.getId())
						.append(",")
						.append(TimeFormatting.getSplitTimeCSV(wave))
						.append(",")
						.append(TimeFormatting.getCurrentWaveTimeCSV(wave))
						.append(",")
						.append(wave.getIdleTicks())
						.append("\n");
			}
		}

		return csv.toString();
	}

	private String fileName(String time, boolean splitWaves) {
		String wavesText = (splitWaves ? "Splits" : "Full") + getExtension();

		switch (wave.getState()) {
			case SUCCESS:
				return time + " Successful KC on Wave " + wave.getId() + ", " + wavesText;
			case FAILED:
			default:
				return time + " Failed KC on Wave " + wave.getId() + ", " + wavesText;
		}
	}

	private String getExtension()
	{
		switch (config.splitsFileType())
		{
			case CSV:
				return ".csv";
			default:
			case TEXT:
				return ".txt";
		}
	}
}

package com.infernostats.controller;

import com.infernostats.InfernoStatsConfig;
import com.infernostats.InfernoStatsPlugin;
import com.infernostats.events.*;
import com.infernostats.model.Location;
import com.infernostats.model.Wave;
import com.infernostats.model.WaveSplit;
import com.infernostats.model.WaveState;
import com.infernostats.view.TimeFormatting;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
public class ChatHandler {
	@Inject
	private Client client;

	@Inject
	private EventBus eventBus;

	@Inject
	private ChatMessageManager chatMessageManager;

	private final InfernoStatsPlugin plugin;
	private final InfernoStatsConfig config;

	private static final Pattern TZHAAR_WAVE_MESSAGE = Pattern.compile("Wave: (\\d+)");
	private static final String TZHAAR_WAVE_COMPLETED_MESSAGE = "Wave completed!";
	private static final String TZHAAR_DEFEATED_MESSAGE = "You have been defeated!";
	private static final Pattern TZHAAR_COMPLETED_MESSAGE = Pattern.compile("Your (?:TzTok-Jad|TzKal-Zuk) kill count is:");
	private static final Pattern TZHAAR_PAUSED_MESSAGE = Pattern.compile("The (?:Inferno|Fight Cave) has been paused. You may now log out.");

	@Inject
	protected ChatHandler(InfernoStatsPlugin plugin, InfernoStatsConfig config) {
		this.plugin = plugin;
		this.config = config;
	}

	@Subscribe
	public void onChatMessage(ChatMessage e) {
		final String message = e.getMessage();
		if (e.getType() != ChatMessageType.SPAM && e.getType() != ChatMessageType.GAMEMESSAGE) {
			return;
		}

		if (message.equals(TZHAAR_DEFEATED_MESSAGE)) {
			eventBus.post(new RunCompletedEvent(WaveState.FAILED));
			eventBus.post(new TimerStoppedEvent());
			return;
		}

		if (TZHAAR_COMPLETED_MESSAGE.matcher(message).find()) {
			eventBus.post(new RunCompletedEvent(WaveState.SUCCESS));
			eventBus.post(new TimerStoppedEvent());
			return;
		}

		if (TZHAAR_PAUSED_MESSAGE.matcher(message).find()) {
			eventBus.post(new TimerPausedEvent());
			return;
		}

		if (message.equals(TZHAAR_WAVE_COMPLETED_MESSAGE)) {
			eventBus.post(new WaveFinishedEvent(WaveState.FINISHED));

			if (config.showIdleTicksInChatbox()) {
				final String waveMessage = new ChatMessageBuilder()
						.append(ChatColorType.HIGHLIGHT)
						.append("Idle Ticks: " + this.plugin.getCurrentWave().getIdleTicks())
						.build();

				chatMessageManager.queue(
						QueuedMessage.builder()
								.type(ChatMessageType.CONSOLE)
								.runeLiteFormattedMessage(waveMessage)
								.build());
			}

			if (config.waveTimes()) {
				final String waveMessage = new ChatMessageBuilder()
						.append(ChatColorType.HIGHLIGHT)
						.append("Wave Completed in: " + TimeFormatting.getCurrentWaveTime(this.plugin.getCurrentWave()))
						.build();

				chatMessageManager.queue(
						QueuedMessage.builder()
								.type(ChatMessageType.CONSOLE)
								.runeLiteFormattedMessage(waveMessage)
								.build());
			}

			return;
		}

		Matcher matcher = TZHAAR_WAVE_MESSAGE.matcher(message);
		if (matcher.find()) {
			final int waveId = Integer.parseInt(matcher.group(1));
			Wave wave = new Wave(waveId, this.plugin.getRunDuration());

			if (wave.getId() == 1) {
				wave.setDuration(0);
				if (this.plugin.isInInferno()) {
					// The first wave message is 10 ticks after the timer starts
					eventBus.post(new TimerStartedEvent(10));
				} else if (this.plugin.isInFightCaves()) {
					// Fight caves does not have a delay on the timer
					eventBus.post(new TimerStartedEvent(0));
				} else {
					return;
				}
			} else if (config.tzhaarTimerState() == TimerHandler.TimerState.PAUSED) {
				eventBus.post(new TimerStartedEvent(0));
			}

			if (this.plugin.isInInferno()) {
				wave.setLocation(Location.INFERNO);
			} else if (this.plugin.isInFightCaves()) {
				wave.setLocation(Location.FIGHT_CAVES);
			} else {
				return;
			}

			eventBus.post(new WaveStartedEvent(wave));

			if (config.splitTimes() && wave.isSplit()) {
				final ChatMessageBuilder chatMessageBuilder = new ChatMessageBuilder()
						.append(ChatColorType.HIGHLIGHT)
						.append("Wave Split: ")
						.append(TimeFormatting.formatDuration(wave.start()));

				if (config.showTargetSplitTimes()) {
					chatMessageBuilder.append(WaveSplit.GoalDifference(wave));
				}

				final String splitMessage = chatMessageBuilder.build();

				chatMessageManager.queue(
						QueuedMessage.builder()
								.type(ChatMessageType.CONSOLE)
								.runeLiteFormattedMessage(splitMessage)
								.build());
			}

			if (config.predictedCompletionTime() && wave.isSplit()) {
				if (wave.getLocation() == Location.FIGHT_CAVES)
					return;

				wave.setPace(WaveSplit.PredictedTime(wave));

				final String predictedMessage = new ChatMessageBuilder()
						.append(ChatColorType.HIGHLIGHT)
						.append("Predicted Time: " + TimeFormatting.formatDuration(wave.getPace()))
						.build();

				chatMessageManager.queue(
						QueuedMessage.builder()
								.type(ChatMessageType.CONSOLE)
								.runeLiteFormattedMessage(predictedMessage)
								.build());
			}
		}
	}
}
package com.infernostats.model;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

@Getter
@AllArgsConstructor
public class NPC {
	private final String name;
	private final WorldPoint tile;

	@Override
	public String toString() {
		return name + "@{" + tile.getRegionX() + "," + tile.getRegionY() + "}";
	}
}

package com.infernostats.model;

public enum WaveState {
	STARTED,
	FINISHED,
	FAILED,
	SUCCESS
}

package com.infernostats.model;

import com.google.common.collect.ImmutableMap;
import com.infernostats.InfernoStatsConfig;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Constants;

import java.time.Duration;
import java.util.ArrayList;
import java.util.Arrays;

@Slf4j
public final class WaveSplit {
	private static ArrayList<String> targetSplits;

	public static void UpdateTargetSplits(InfernoStatsConfig config) {
		targetSplits = new ArrayList<>(Arrays.asList(
				config.targetWave9Split(),
				config.targetWave18Split(),
				config.targetWave25Split(),
				config.targetWave35Split(),
				config.targetWave42Split(),
				config.targetWave50Split(),
				config.targetWave57Split(),
				config.targetWave60Split(),
				config.targetWave63Split(),
				config.targetWave66Split(),
				config.targetWave67Split(),
				config.targetWave68Split(),
				config.targetWave69Split()
		));
	}

	private static Duration ParseConfigSplit(Split split) {
		String targetSplit = targetSplits.get(split.ordinal());
		if (targetSplit.equals(""))
			return null;

		String[] time = targetSplit.split(":");
		if (time.length != 2)
			return null;

		// At most we want 9999 minutes and seconds should always be %02d
		if (time[0].length() > 4 || time[1].length() != 2)
			return null;

		int seconds, minutes;
		try {
			minutes = Integer.parseInt(time[0]);
			seconds = Integer.parseInt(time[1]);
		} catch (NumberFormatException e) {
			return null;
		}

		return Duration.ofMinutes(minutes).plusSeconds(seconds);
	}

	public static String GoalDifference(Wave wave) {
		Split split = WaveSplitMap.get(wave.getId());

		Duration configSplit = ParseConfigSplit(split);
		if (configSplit == null)
			return "";

		// Duration.toSeconds() is supported in Java 9
		long waveSplitSeconds = wave.start().toMillis() / 1000;
		long configSplitSeconds = configSplit.toMillis() / 1000;

		int comparison = configSplit.compareTo(wave.start());
		if (comparison > 0) {
			long difference = configSplitSeconds - waveSplitSeconds;
			String minutes = String.valueOf(difference / 60);
			String seconds = String.format("%02d", difference % 60);
			return " (-" + minutes + ":" + seconds + ")";
		} else if (comparison < 0) {
			long difference = waveSplitSeconds - configSplitSeconds;
			String minutes = String.valueOf(difference / 60);
			String seconds = String.format("%02d", difference % 60);
			return " (+" + minutes + ":" + seconds + ")";
		}

		return " (-0)";
	}

	public static Duration PredictedTime(Wave wave) {
		long waveStartMillis = wave.getStart() * Constants.GAME_TICK_LENGTH;
		float percentComplete = percentOfAvgTime(wave, checkPace(wave));
		return Duration.ofMillis((long) (waveStartMillis * (1 / percentComplete)));
	}

	private static Pace checkPace(Wave wave) {
		Split split = WaveSplitMap.get(wave.getId());
		for (Pace pace : Pace.values()) {
			Duration wavePace = splits[split.ordinal()][pace.ordinal()];
			if (wave.start().compareTo(wavePace) > 0) {
				return pace;
			}
		}
		return Pace.SUB45;
	}

	private static float percentOfAvgTime(Wave wave, Pace pace) {
		Split split = WaveSplitMap.get(wave.getId());
		return (float) splits[split.ordinal()][pace.ordinal()].toMillis() /
				splits[Split.FINISH.ordinal()][pace.ordinal()].toMillis();
	}

	public static final ImmutableMap<Integer, Split> WaveSplitMap = ImmutableMap.<Integer, Split>builder()
			.put(9, Split.SPLIT9)
			.put(18, Split.SPLIT18)
			.put(25, Split.SPLIT25)
			.put(35, Split.SPLIT35)
			.put(42, Split.SPLIT42)
			.put(50, Split.SPLIT50)
			.put(57, Split.SPLIT57)
			.put(60, Split.SPLIT60)
			.put(63, Split.SPLIT63)
			.put(66, Split.SPLIT66)
			.put(67, Split.SPLIT67)
			.put(68, Split.SPLIT68)
			.put(69, Split.SPLIT69)
			.build();

	private enum Split {
		SPLIT9,
		SPLIT18,
		SPLIT25,
		SPLIT35,
		SPLIT42,
		SPLIT50,
		SPLIT57,
		SPLIT60,
		SPLIT63,
		SPLIT66,
		SPLIT67,
		SPLIT68,
		SPLIT69,
		FINISH
	}

	private enum Pace {
		SUB75,
		SUB60,
		SUB55,
		SUB50,
		SUB45
	}

	// The spreadsheet represents milliseconds as a fraction of 60.
	// E.g. 3:12:12 = 3 minutes, 12 seconds, 12 fractional milliseconds
	//              = 3 minutes, 12 seconds, 200 milliseconds
	// as (12 / 60) * 1000 = 200
	private static Duration splitTime(int minutes, int seconds, int fractMillis) {
		int milliseconds = fractMillis / 60 * 1000;
		return Duration.ofMinutes(minutes).plusSeconds(seconds).plusMillis(milliseconds);
	}

	private static final Duration[][] splits = {
			{ // Wave 9
					splitTime(3, 12, 57),
					splitTime(2, 48, 45),
					splitTime(2, 38, 42),
					splitTime(2, 34, 59),
					splitTime(2, 21, 0),
			},
			{ // Wave 18
					splitTime(8, 6, 12),
					splitTime(7, 9, 58),
					splitTime(6, 32, 1),
					splitTime(6, 21, 27),
					splitTime(5, 43, 0),
			},
			{ // Wave 25
					splitTime(12, 38, 5),
					splitTime(11, 10, 54),
					splitTime(10, 20, 25),
					splitTime(9, 59, 32),
					splitTime(8, 51, 0),
			},
			{ // Wave 35
					splitTime(19, 59, 27),
					splitTime(17, 51, 11),
					splitTime(16, 18, 36),
					splitTime(15, 49, 34),
					splitTime(14, 1, 0),
			},
			{ // Wave 42
					splitTime(26, 4, 23),
					splitTime(23, 13, 13),
					splitTime(21, 10, 40),
					splitTime(20, 31, 8),
					splitTime(18, 9, 0),
			},
			{ // Wave 50
					splitTime(34, 44, 58),
					splitTime(30, 42, 4),
					splitTime(27, 57, 20),
					splitTime(27, 0, 28),
					splitTime(23, 50, 0),
			},
			{ // Wave 57
					splitTime(43, 6, 49),
					splitTime(37, 53, 26),
					splitTime(34, 21, 23),
					splitTime(33, 5, 17),
					splitTime(29, 8, 0),
			},
			{ // Wave 60
					splitTime(46, 49, 1),
					splitTime(41, 5, 58),
					splitTime(37, 11, 41),
					splitTime(35, 53, 1),
					splitTime(31, 35, 0),
			},
			{ // Wave 63
					splitTime(51, 29, 49),
					splitTime(44, 57, 13),
					splitTime(40, 36, 18),
					splitTime(39, 2, 40),
					splitTime(34, 28, 0),
			},
			{ // Wave 66
					splitTime(56, 2, 37),
					splitTime(48, 36, 32),
					splitTime(43, 53, 21),
					splitTime(42, 6, 38),
					splitTime(37, 13, 0),
			},
			{ // Wave 67
					splitTime(56, 52, 39),
					splitTime(49, 27, 4),
					splitTime(44, 40, 34),
					splitTime(42, 51, 37),
					splitTime(37, 56, 0),
			},
			{ // Wave 68
					splitTime(58, 6, 13),
					splitTime(50, 28, 47),
					splitTime(45, 37, 21),
					splitTime(43, 43, 28),
					splitTime(38, 41, 0),
			},
			{ // Wave 69
					splitTime(61, 14, 23),
					splitTime(53, 3, 33),
					splitTime(48, 11, 44),
					splitTime(46, 9, 11),
					splitTime(40, 53, 0),
			},
			{ // Finish
					splitTime(67, 6, 6),
					splitTime(57, 39, 56),
					splitTime(51, 42, 17),
					splitTime(49, 15, 59),
					splitTime(43, 43, 0),
			},
	};
}

package com.infernostats.model;

import com.google.common.collect.ImmutableSet;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Constants;
import net.runelite.api.coords.WorldPoint;

import java.time.Duration;
import java.util.ArrayList;
import java.util.Set;

@Getter
@Setter
public class Wave {
	private final int id;
	private ArrayList<NPC> npcs;
	private final long start;
	private long duration;
	private int damageTaken;
	private int damageDealt;
	private int prayerDrain;
	private int idleTicks;
	private WaveState state;
	private Duration pace;
	private Location location;

	private static final Set<Integer> SPLIT_WAVES = ImmutableSet.of(
			9, 18, 25, 35, 42, 50, 57, 60, 63, 66, 67, 68, 69
	);

	private static final Set<Integer> FIGHT_CAVE_SPLIT_WAVES = ImmutableSet.of(
			7, 15, 31, 46, 53, 61, 62, 63
	);

	public Wave(int id, long start) {
		this.id = id;
		this.start = start;
		this.duration = 0;
		this.damageTaken = 0;
		this.damageDealt = 0;
		this.prayerDrain = 0;
		this.idleTicks = 0;
		this.state = WaveState.STARTED;
		this.npcs = new ArrayList<>();
		this.pace = null;
	}

	public void addNPC(String name, WorldPoint spawnTile) {
		this.npcs.add(new NPC(name, spawnTile));
	}

	public boolean isSplit() {
		switch (location)
		{
			case FIGHT_CAVES:
				return FIGHT_CAVE_SPLIT_WAVES.contains(this.getId());
			default:
			case INFERNO:
				return SPLIT_WAVES.contains(this.getId());
		}
	}

	public Duration duration() {
		return Duration.ofMillis(this.duration * Constants.GAME_TICK_LENGTH);
	}

	public Duration start() {
		return Duration.ofMillis(this.start * Constants.GAME_TICK_LENGTH);
	}
}

package com.infernostats.model;

public enum Location {
	FIGHT_CAVES,
	INFERNO,
}

package com.infernostats.model;

import lombok.AllArgsConstructor;
import lombok.Getter;

import java.awt.*;

@Getter
@AllArgsConstructor
public class WaveSpawn {
	private final int x;
	private final int y;
	private final int size;
	private final Color color;
}

package com.infernostats;

import com.infernostats.model.Wave;
import com.infernostats.view.*;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.*;

@Getter(AccessLevel.PACKAGE)
public class InfernoStatsPanel extends PluginPanel {
	private WaveStatsPanel waveStatsPanel;

	private final TitlePanel titlePanel = new TitlePanel();
	private final WaveSplitsPanel waveSplitsPanel = new WaveSplitsPanel();
	private final WaveListPanel waveListPanel = new WaveListPanel();
	private final WaveListContainer waveListContainer = new WaveListContainer(waveListPanel);

	private final InfernoStatsPlugin plugin;
	private final InfernoStatsConfig config;

	@Inject
	private InfernoStatsPanel(InfernoStatsPlugin plugin, InfernoStatsConfig config) {
		this.plugin = plugin;
		this.config = config;

		setBackground(ColorScheme.DARK_GRAY_COLOR);

		add(this.titlePanel, BorderLayout.NORTH, 0);
		add(this.waveSplitsPanel, BorderLayout.CENTER, 1);
		add(this.waveListContainer, BorderLayout.SOUTH, 2);

		waveSplitsPanel.setWaves(this.plugin.getWaves());
	}

	void AddWave(Wave wave) {
		SwingUtilities.invokeLater(() ->
		{
			waveStatsPanel = new WaveStatsPanel(config, wave);
			waveListPanel.add(waveStatsPanel, 0);

			updateUI();
		});
	}

	void UpdateWave() {
		if (waveStatsPanel == null)
			return;

		SwingUtilities.invokeLater(() -> waveStatsPanel.update());
	}

	public void ClearWaves() {
		waveListPanel.removeAll();
		waveListPanel.validate();
		waveListPanel.repaint();
	}
}

package com.infernostats.view;

import com.google.common.collect.ImmutableMap;
import com.infernostats.InfernoStatsConfig;
import com.infernostats.model.NPC;
import com.infernostats.model.Wave;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.LinkBrowser;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@Getter
@Setter
public class WaveStatsPanel extends JPanel {
	private Wave wave;
	private String baseURL;

	private String waveURL;
	private JLabel waveNumber;
	private JLabel duration;
	private JLabel damageTaken;
	private JLabel damageDealt;
	private JLabel prayerDrain;
	private JLabel idleTicks;
	private WaveImage imageLabel;
	private JPanel textPanel;

	private InfernoStatsConfig config;

	private static final Border normalBorder = BorderFactory.createCompoundBorder(
			BorderFactory.createMatteBorder(0, 0, 4, 0, ColorScheme.DARK_GRAY_COLOR),
			new EmptyBorder(4, 6, 4, 6));

	private static final Border hoverBorder = BorderFactory.createCompoundBorder(
			BorderFactory.createMatteBorder(0, 0, 4, 0, ColorScheme.DARK_GRAY_COLOR),
			BorderFactory.createCompoundBorder(
					BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_HOVER_COLOR),
					new EmptyBorder(3, 5, 3, 5)));

	public WaveStatsPanel(InfernoStatsConfig config, Wave wave) {
		this.config = config;

		this.wave = wave;
		this.baseURL = config.url().base;
		this.waveURL = generateURL();

		setLayout(new BorderLayout(5, 5));
		setBackground(ColorScheme.DARKER_GRAY_COLOR);
		setBorder(normalBorder);

		JPanel wavePanel = new JPanel();
		wavePanel.setLayout(new BoxLayout(wavePanel, BoxLayout.Y_AXIS));
		wavePanel.setBackground(null);

		JPanel wavePanelTop = new JPanel();
		wavePanelTop.setLayout(new BoxLayout(wavePanelTop, BoxLayout.Y_AXIS));
		wavePanelTop.setBackground(null);

		JPanel waveNumberLine = new JPanel();
		waveNumberLine.setLayout(new BorderLayout());
		waveNumberLine.setBackground(null);

		waveNumber = new JLabel();
		if (wave.isSplit()) {
			waveNumber.setText("Wave " + wave.getId() + " - " + TimeFormatting.getSplitTime(wave));
		} else {
			waveNumber.setText("Wave " + wave.getId());
		}
		waveNumber.setHorizontalAlignment(SwingConstants.CENTER);
		waveNumber.setForeground(Color.WHITE);
		waveNumberLine.add(waveNumber);

		JPanel wavePanelBottom = new JPanel();
		wavePanelBottom.setLayout(new BoxLayout(wavePanelBottom, BoxLayout.X_AXIS));
		wavePanelBottom.setBackground(null);

		textPanel = new JPanel();
		textPanel.setLayout(new BoxLayout(textPanel, BoxLayout.Y_AXIS));
		textPanel.setBackground(null);

		JPanel durationLine = new JPanel();
		durationLine.setLayout(new BorderLayout());
		durationLine.setBackground(null);

		duration = new JLabel();
		duration.setText("Time: 00:00");
		duration.setForeground(Color.WHITE);
		durationLine.add(duration, BorderLayout.WEST);

		JPanel damageTakenLine = new JPanel();
		damageTakenLine.setLayout(new BorderLayout());
		damageTakenLine.setBackground(null);

		damageTaken = new JLabel();
		damageTaken.setText("Damage Taken: 0");
		damageTaken.setForeground(Color.WHITE);
		damageTakenLine.add(damageTaken, BorderLayout.WEST);

		JPanel damageDealtLine = new JPanel();
		damageDealtLine.setLayout(new BorderLayout());
		damageDealtLine.setBackground(null);

		damageDealt = new JLabel();
		damageDealt.setText("Damage Dealt: 0");
		damageDealt.setForeground(Color.WHITE);
		damageDealtLine.add(damageDealt, BorderLayout.WEST);

		JPanel prayerDrainLine = new JPanel();
		prayerDrainLine.setLayout(new BorderLayout());
		prayerDrainLine.setBackground(null);

		prayerDrain = new JLabel();
		prayerDrain.setText("Prayer Drain: 0");
		prayerDrain.setForeground(Color.WHITE);
		prayerDrainLine.add(prayerDrain, BorderLayout.WEST);

		JPanel idleTicksLine = new JPanel();
		idleTicksLine.setLayout(new BorderLayout());
		idleTicksLine.setBackground(null);

		idleTicks = new JLabel();
		idleTicks.setText("Idle Ticks: 0");
		idleTicks.setForeground(Color.WHITE);
		idleTicksLine.add(idleTicks, BorderLayout.WEST);

		textPanel.add(durationLine);
		textPanel.add(damageTakenLine);
		textPanel.add(damageDealtLine);
		textPanel.add(prayerDrainLine);

		if (config.showIdleTicksInSidePanel())
			textPanel.add(idleTicksLine);

		JPanel imagePanel = new JPanel();
		imagePanel.setLayout(new BoxLayout(imagePanel, BoxLayout.Y_AXIS));
		imagePanel.setBackground(null);

		imageLabel = new WaveImage();
		imagePanel.add(imageLabel);

		wavePanelTop.add(waveNumberLine);
		wavePanelBottom.add(textPanel);
		wavePanelBottom.add(imagePanel);

		wavePanel.add(wavePanelTop, BorderLayout.NORTH);
		wavePanel.add(wavePanelBottom, BorderLayout.SOUTH);

		add(wavePanel, BorderLayout.NORTH);

		MouseAdapter waveStatsMouseListener = new MouseAdapter() {
			@Override
			public void mouseEntered(MouseEvent e) {
				setBackground(ColorScheme.DARK_GRAY_COLOR);
				for (Component c : getComponents()) {
					c.setBackground(ColorScheme.DARK_GRAY_COLOR);
				}
				setBorder(hoverBorder);
				setCursor(new Cursor(Cursor.HAND_CURSOR));
			}

			@Override
			public void mouseExited(MouseEvent e) {
				setBackground(ColorScheme.DARKER_GRAY_COLOR);
				for (Component c : getComponents()) {
					c.setBackground(ColorScheme.DARKER_GRAY_COLOR);
				}
				setBorder(normalBorder);
				setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
			}

			@Override
			public void mouseClicked(MouseEvent e) {
				if (e.getButton() == MouseEvent.BUTTON3) {
					return;
				}

				LinkBrowser.browse(waveURL);
			}
		};

		addMouseListener(waveStatsMouseListener);
	}

	public void RedrawWaveSpawn() {
		Map<String, ArrayList<ArrayList<Integer>>> mobs = remapNPCs();
		ImmutableMap<String, Integer> mob_sizes = new ImmutableMap.Builder<String, Integer>()
				.put("Jal-MejRah", 2)
				.put("Jal-Ak", 3)
				.put("Jal-ImKot", 4)
				.put("Jal-Xil", 3)
				.put("Jal-Zek", 4)
				.build();

		ImmutableMap<String, Color> mob_colors = new ImmutableMap.Builder<String, Color>()
				.put("Jal-MejRah", Color.GRAY)
				.put("Jal-Ak", Color.YELLOW)
				.put("Jal-ImKot", Color.ORANGE)
				.put("Jal-Xil", Color.GREEN)
				.put("Jal-Zek", Color.RED)
				.build();

		for (Map.Entry<String, ArrayList<ArrayList<Integer>>> entry : mobs.entrySet()) {
			final String name = entry.getKey();
			final int size = mob_sizes.get(name);
			final ArrayList<ArrayList<Integer>> spawnTiles = entry.getValue();

			for (ArrayList<Integer> spawnTile : spawnTiles) {
				final int x = spawnTile.get(0);
				final int y = spawnTile.get(1);

				imageLabel.drawSpawn(x, y, size, mob_colors.get(name));
			}
		}

		imageLabel.revalidate();
		imageLabel.repaint();
	}

	public String generateURL() {
		Map<String, ArrayList<ArrayList<Integer>>> mobs = remapNPCs();

		// Map in-game names to website parameter names
		ImmutableMap<String, String> npc_names = new ImmutableMap.Builder<String, String>()
				.put("Jal-MejRah", "bat")
				.put("Jal-Ak", "blob")
				.put("Jal-ImKot", "melee")
				.put("Jal-Xil", "ranger")
				.put("Jal-Zek", "mager")
				.build();

		StringBuilder sb = new StringBuilder();

		sb.append(this.baseURL);
		for (Map.Entry<String, ArrayList<ArrayList<Integer>>> entry : mobs.entrySet()) {
			sb.append(npc_names.get(entry.getKey()));
			sb.append("=");
			sb.append(entry.getValue());
			sb.append("&");
		}
		sb.append("copyable");

		return sb.toString().replaceAll("\\s", "");
	}

	private Map<String, ArrayList<ArrayList<Integer>>> remapNPCs() {
		Map<String, ArrayList<ArrayList<Integer>>> mobs = new HashMap<>();

		for (NPC npc : this.wave.getNpcs()) {
			// The SW-most corner region tile is 17,17
			// The SW-most corner website tile is 0, 29
			final int xOffset = 17;

			// The NW-most corner region tile is 17,46
			// The NW-most corner website tile is 0, 0
			final int yOffset = 46;

			final int x = npc.getTile().getRegionX() - xOffset;
			final int y = yOffset - npc.getTile().getRegionY();

			mobs.computeIfAbsent(npc.getName(), k -> new ArrayList<>());
			mobs.get(npc.getName()).add(new ArrayList<>(Arrays.asList(x, y)));
		}

		return mobs;
	}

	public void update() {
		switch (this.getWave().getState()) {
			case FINISHED:
			case STARTED:
				this.getWaveNumber().setForeground(Color.WHITE);
				break;
			case SUCCESS:
				this.getWaveNumber().setForeground(Color.GREEN);
				break;
			case FAILED:
				this.getWaveNumber().setForeground(Color.RED);
				break;
		}

		this.waveURL = this.generateURL();
		this.duration.setText("Time: " + TimeFormatting.getCurrentWaveTime(wave));
		this.damageTaken.setText("Damage Taken: " + this.wave.getDamageTaken());
		this.damageDealt.setText("Damage Dealt: " + this.wave.getDamageDealt());
		this.prayerDrain.setText("Prayer Drain: " + this.wave.getPrayerDrain());
		this.idleTicks.setText("Idle Ticks: " + this.wave.getIdleTicks());
		this.RedrawWaveSpawn();
	}
}

package com.infernostats.view;

import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import java.awt.*;

public class WaveListContainer extends JScrollPane {
	public WaveListContainer(WaveListPanel waveListPanel) {
		super(waveListPanel);

		this.setBackground(ColorScheme.DARK_GRAY_COLOR);
		this.getVerticalScrollBar().setPreferredSize(new Dimension(6, 0));
	}
}

package com.infernostats.view;

import com.infernostats.model.WaveSpawn;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.ArrayList;

public class WaveImage extends JLabel {
	private final ArrayList<WaveSpawn> spawns;

	public WaveImage() {
		int IMAGE_SCALE = 2;
		BufferedImage image = ImageUtil.loadImageResource(getClass(), "/inferno-base.png");
		Image scaledImage = image.getScaledInstance(
				image.getWidth() * IMAGE_SCALE,
				image.getHeight() * IMAGE_SCALE,
				Image.SCALE_DEFAULT
		);
		this.setIcon(new ImageIcon(scaledImage));
		this.spawns = new ArrayList<>();
	}

	public void drawSpawn(int x, int y, int size, Color color) {
		spawns.add(new WaveSpawn(x, y, size, color));
	}

	public void paintComponent(Graphics g) {
		super.paintComponent(g);

		for (WaveSpawn spawn : spawns) {
			g.setColor(spawn.getColor());
			g.fillRect(spawn.getX() * 2, spawn.getY() * 2, spawn.getSize(), spawn.getSize());
		}
	}
}

package com.infernostats.view;

import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;

public class TitlePanel extends JPanel {
	public TitlePanel() {
		setBorder(new EmptyBorder(8, 8, 8, 8));
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JLabel titleLabel = new JLabel();
		titleLabel.setText("Inferno Stats");
		titleLabel.setHorizontalAlignment(SwingConstants.CENTER);
		titleLabel.setForeground(Color.WHITE);
		add(titleLabel);
	}
}

package com.infernostats.view;

import com.infernostats.model.Wave;
import net.runelite.api.Constants;

import java.time.Duration;

public class TimeFormatting {
	public static String getCurrentWaveTime(Wave wave) {
		return formatGameTicks(wave.getDuration());
	}

	public static String getCurrentTotalTime(Wave wave) {
		return formatGameTicks((wave.getStart() + wave.getDuration()));
	}

	public static String getSplitTime(Wave wave) {
		return formatGameTicks(wave.getStart());
	}

	public static String getSplitDelta(Wave wave, Wave prev) {
		if (prev == null)
			return getSplitTime(wave);
		return formatDuration(wave.start().minus(prev.start()));
	}

	public static String getCurrentWaveTimeCSV(Wave wave) {
		return formatGameTicksCSV(wave.getDuration());
	}

	public static String getSplitTimeCSV(Wave wave) {
		return formatGameTicksCSV(wave.getStart());
	}

	public static String getSplitDeltaCSV(Wave wave, Wave prev) {
		if (prev == null)
			return getSplitTimeCSV(wave);
		return formatDurationCSV(wave.start().minus(prev.start()));
	}

	public static String formatGameTicks(long gameTicks) {
		long seconds = Duration.ofMillis(gameTicks * Constants.GAME_TICK_LENGTH).getSeconds();
		return String.format("%02d:%02d", seconds / 60, seconds % 60);
	}

	public static String formatDuration(Duration duration) {
		long seconds = duration.toMillis() / 1000;
		return String.format("%02d:%02d", seconds / 60, seconds % 60);
	}

	public static String formatGameTicksCSV(long gameTicks) {
		long s = Duration.ofMillis(gameTicks * Constants.GAME_TICK_LENGTH).getSeconds();
		return String.format("%02d:%02d:%02d", s / 3600, (s % 3600) / 60, (s % 60));
	}

	public static String formatDurationCSV(Duration duration) {
		long s = duration.toMillis() / 1000;
		return String.format("%02d:%02d:%02d", s / 3600, (s % 3600) / 60, (s % 60));
	}
}

package com.infernostats.view;

import javax.swing.*;

public class WaveListPanel extends JPanel {
	public WaveListPanel() {
		this.setSize(getSize());
		this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
	}
}
package com.infernostats.view;

import com.infernostats.model.Wave;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.datatransfer.StringSelection;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.font.TextAttribute;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

@Slf4j
public class WaveSplitsPanel extends JPanel {
	private final JLabel titleLabel = new JLabel();

	@Setter
	private ArrayList<Wave> waves = null;

	@Inject
	public WaveSplitsPanel() {
		setBorder(new EmptyBorder(2, 8, 2, 8));
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		titleLabel.setText("Copy Wave Splits to Clipboard");
		titleLabel.setHorizontalAlignment(SwingConstants.CENTER);
		titleLabel.setForeground(Color.WHITE);
		add(titleLabel);

		MouseAdapter waveStatsMouseListener = new MouseAdapter() {
			@Override
			public void mouseEntered(MouseEvent e) {
				setUnderline(titleLabel);
				setCursor(new Cursor(Cursor.HAND_CURSOR));
			}

			@Override
			public void mouseExited(MouseEvent e) {
				unsetUnderline(titleLabel);
				setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
			}

			@Override
			public void mouseClicked(MouseEvent e) {
				if (e.getButton() == MouseEvent.BUTTON3) {
					return;
				}

				Toolkit.getDefaultToolkit()
						.getSystemClipboard()
						.setContents(
								new StringSelection(WaveSplitTimes()),
								null
						);
			}
		};

		addMouseListener(waveStatsMouseListener);
	}

	private void setUnderline(JLabel label) {
		Font font = label.getFont();
		Map<TextAttribute, Object> attributes = new HashMap<>(font.getAttributes());
		attributes.put(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_ON);
		label.setFont(font.deriveFont(attributes));
	}

	private void unsetUnderline(JLabel label) {
		Font font = label.getFont();
		Map<TextAttribute, Object> attributes = new HashMap<>(font.getAttributes());
		attributes.put(TextAttribute.UNDERLINE, -1);
		label.setFont(font.deriveFont(attributes));
	}

	public String WaveSplitTimes() {
		StringBuilder splits = new StringBuilder();

		Wave prev = null;
		for (Wave wave : waves) {
			if (!wave.isSplit())
				continue;

			splits.append("Wave: ").append(wave.getId())
					.append(", ")
					.append("Split: ").append(TimeFormatting.getSplitTime(wave))
					.append(" ")
					.append("(+").append(TimeFormatting.getSplitDelta(wave, prev)).append(")")
					.append("\n");

			prev = wave;
		}

		if (waves.isEmpty()) {
			splits.append("Duration (Not Started): N/a");
			return splits.toString();
		}

		Wave wave = waves.get(waves.size() - 1);
		String duration = TimeFormatting.getCurrentTotalTime(wave);

		switch (wave.getState()) {
			case FINISHED:
			case STARTED:
				splits.append("Duration (Unfinished): ").append(duration);
				break;
			case SUCCESS:
				splits.append("Duration (Success): ").append(duration);
				break;
			case FAILED:
				splits.append("Duration (Failed): ").append(duration);
				break;
		}

		return splits.toString();
	}
}
