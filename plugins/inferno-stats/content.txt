package com.infernostats.controller;

import com.infernostats.InfernoStatsConfig;
import com.infernostats.InfernoStatsPlugin;
import com.infernostats.events.*;
import com.infernostats.model.Location;
import com.infernostats.model.Wave;
import com.infernostats.model.WaveSplit;
import com.infernostats.model.WaveState;
import com.infernostats.view.TimeFormatting;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
public class ChatHandler {
  @Inject
  private Client client;

  @Inject
  private EventBus eventBus;

  @Inject
  private ChatMessageManager chatMessageManager;

  private final InfernoStatsPlugin plugin;
  private final InfernoStatsConfig config;

  private static final Pattern TZHAAR_WAVE_MESSAGE = Pattern.compile("Wave: (\\d+)");
  private static final String TZHAAR_WAVE_COMPLETED_MESSAGE = "Wave completed!";
  private static final String TZHAAR_DEFEATED_MESSAGE = "You have been defeated!";
  private static final Pattern TZHAAR_DURATION_MESSAGE =
      Pattern.compile("Duration: (\\d{1,2}):(\\d{2})(?:\\.(\\d{2}))?");
  private static final Pattern TZHAAR_PAUSED_MESSAGE =
      Pattern.compile("The (?:Inferno|Fight Cave) has been paused. You may now log out.");

  @Inject
  protected ChatHandler(InfernoStatsPlugin plugin, InfernoStatsConfig config) {
    this.plugin = plugin;
    this.config = config;
  }

  @Subscribe
  public void onChatMessage(ChatMessage e) {
    final String message = Text.removeTags(e.getMessage());
    if (e.getType() != ChatMessageType.SPAM && e.getType() != ChatMessageType.GAMEMESSAGE) {
      return;
    }

    if (message.equals(TZHAAR_DEFEATED_MESSAGE)) {
      eventBus.post(new RunCompletedEvent(WaveState.FAILED));
      eventBus.post(new TimerStoppedEvent());
      return;
    }

    Matcher durationMatcher = TZHAAR_DURATION_MESSAGE.matcher(message);
    if (durationMatcher.find()) {
      if (plugin.getTimerState() != TimerHandler.TimerState.RUNNING) {
        return;
      }

      final int duration = extractDuration(durationMatcher);
      eventBus.post(new RunCompletedEvent(WaveState.SUCCESS, duration));
      eventBus.post(new TimerStoppedEvent());
      return;
    }

    if (TZHAAR_PAUSED_MESSAGE.matcher(message).find()) {
      eventBus.post(new TimerPausedEvent());
      return;
    }

    if (message.equals(TZHAAR_WAVE_COMPLETED_MESSAGE)) {
      eventBus.post(new WaveFinishedEvent(WaveState.FINISHED));

      if (config.showIdleTicksInChatbox()) {
        final String waveMessage = new ChatMessageBuilder()
            .append(ChatColorType.HIGHLIGHT)
            .append("Idle Ticks: " + this.plugin.getCurrentWave().getIdleTicks())
            .build();

        chatMessageManager.queue(
            QueuedMessage.builder()
                .type(ChatMessageType.CONSOLE)
                .runeLiteFormattedMessage(waveMessage)
                .build());
      }

      if (config.waveTimes()) {
        final String waveMessage = new ChatMessageBuilder()
            .append(ChatColorType.HIGHLIGHT)
            .append("Wave Completed in: " + TimeFormatting.getCurrentWaveTime(this.plugin.getCurrentWave()))
            .build();

        chatMessageManager.queue(
            QueuedMessage.builder()
                .type(ChatMessageType.CONSOLE)
                .runeLiteFormattedMessage(waveMessage)
                .build());
      }

      return;
    }

    Matcher matcher = TZHAAR_WAVE_MESSAGE.matcher(message);
    if (matcher.find()) {
      final int waveId = Integer.parseInt(matcher.group(1));
      Wave wave = new Wave(waveId, this.plugin.getRunDuration());

      if (wave.getId() == 1) {
        wave.setDuration(0);
        if (this.plugin.isInInferno()) {
          // The first wave message is 10 ticks after the timer starts
          eventBus.post(new TimerStartedEvent(10));
        } else if (this.plugin.isInFightCaves()) {
          // Fight caves does not have a delay on the timer
          eventBus.post(new TimerStartedEvent(0));
        } else {
          return;
        }
      } else if (config.tzhaarTimerState() == TimerHandler.TimerState.PAUSED) {
        eventBus.post(new TimerStartedEvent(0));
      }

      if (this.plugin.isInInferno()) {
        wave.setLocation(Location.INFERNO);
      } else if (this.plugin.isInFightCaves()) {
        wave.setLocation(Location.FIGHT_CAVES);
      } else {
        return;
      }

      eventBus.post(new WaveStartedEvent(wave));

      if (config.splitTimes() && wave.isSplit()) {
        final ChatMessageBuilder chatMessageBuilder = new ChatMessageBuilder()
            .append(ChatColorType.HIGHLIGHT)
            .append("Wave Split: ")
            .append(TimeFormatting.formatDuration(wave.start()));

        if (config.showTargetSplitTimes()) {
          chatMessageBuilder.append(WaveSplit.GoalDifference(wave));
        }

        final String splitMessage = chatMessageBuilder.build();

        chatMessageManager.queue(
            QueuedMessage.builder()
                .type(ChatMessageType.CONSOLE)
                .runeLiteFormattedMessage(splitMessage)
                .build());
      }

      if (config.predictedCompletionTime() && wave.isSplit()) {
        if (wave.getLocation() == Location.FIGHT_CAVES)
          return;

        wave.setPace(WaveSplit.PredictedTime(wave));

        final String predictedMessage = new ChatMessageBuilder()
            .append(ChatColorType.HIGHLIGHT)
            .append("Predicted Time: " + TimeFormatting.formatDuration(wave.getPace()))
            .build();

        chatMessageManager.queue(
            QueuedMessage.builder()
                .type(ChatMessageType.CONSOLE)
                .runeLiteFormattedMessage(predictedMessage)
                .build());
      }
    }
  }

  public static int extractDuration(Matcher matcher) {
    int minutes = Integer.parseInt(matcher.group(1));
    int seconds = Integer.parseInt(matcher.group(2));
    int hundredths = matcher.group(3) != null ? Integer.parseInt(matcher.group(3)) : -1;

    double totalSeconds;
    if (hundredths >= 0) {
      // precise timing is turned on
      totalSeconds = minutes * 60 + seconds + hundredths / 100.0;
    } else {
      // imprecise: round up to next valid tick
      totalSeconds = minutes * 60 + seconds;
      double remainder = totalSeconds % TimeFormatting.SECONDS_PER_TICK;
      if (remainder > 0) {
        totalSeconds += (TimeFormatting.SECONDS_PER_TICK - remainder);
      }
    }

    return (int) Math.round(totalSeconds / TimeFormatting.SECONDS_PER_TICK);
  }
}
package com.infernostats.controller;

import com.google.common.collect.Sets;
import com.infernostats.InfernoStatsConfig;
import com.infernostats.InfernoStatsPlugin;
import com.infernostats.events.WaveStartedEvent;
import com.infernostats.model.Wave;
import com.infernostats.model.WaveState;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.StatChanged;
import net.runelite.api.kit.KitType;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;

import javax.inject.Inject;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

@Slf4j
public class TickLossHandler {
	private Wave wave;
	private int magicXp;
	private int tickDelay;
	private int currChinCount;
	private int prevChinCount;
	private Animation currAnim;
	private Animation prevAnim;
	private Set<Integer> attackableNpcs;

	private static final int SPELLBOOK_VARBIT = 4070;
	private static final Set<TickLossHandler.Animation> blowpipeAnimations = Set.of(
		Animation.BLOWPIPE, Animation.BLOWPIPE_BLAZING);

	@Inject
	private Client client;

	@Inject
	private ItemManager itemManager;

	private final InfernoStatsPlugin plugin;
	private final InfernoStatsConfig config;

	@Inject
	protected TickLossHandler(InfernoStatsPlugin plugin, InfernoStatsConfig config) {
		this.plugin = plugin;
		this.config = config;

		this.magicXp = -1;
		this.tickDelay = 0;
		this.currChinCount = -1;
		this.prevChinCount = -1;

		this.currAnim = Animation.UNKNOWN;
		this.prevAnim = Animation.UNKNOWN;

		this.attackableNpcs = new HashSet<>();
	}

	@Subscribe
	protected void onWaveStartedEvent(WaveStartedEvent e) {
		this.wave = e.getWave();
	}

	@Subscribe
	public void onStatChanged(StatChanged e) {
		if (e.getSkill() != Skill.MAGIC)
			return;

		final int newMagicXp = e.getXp();
		if (newMagicXp == this.magicXp)
			return;

		this.magicXp = newMagicXp;

		// Standard (0), Ancient (1), Lunar (2), Arceuus (3)
		if (this.client.getVarbitValue(SPELLBOOK_VARBIT) != 1)
			return;

		// Ghost barrage occurred
		if (blowpipeAnimations.contains(this.prevAnim))
			this.tickDelay += 5;
	}

	@Subscribe
	protected void onGameTick(GameTick e) {
		if (this.tickDelay > 0)
			this.tickDelay -= 1;

		if (isCooldownActive() || !isWaveActive())
			return;

		Player player = this.client.getLocalPlayer();
		if (player == null)
			return;

		PlayerComposition composition = player.getPlayerComposition();
		if (composition == null)
			return;

		final int weapon = composition.getEquipmentId(KitType.WEAPON);

		this.prevAnim = this.currAnim;
		this.currAnim = Animation.valueOf(player.getAnimation());

		if (!blowpipeAnimations.contains(this.prevAnim) && blowpipeAnimations.contains(this.currAnim)) {
			this.tickDelay = 2;
		} else if (blowpipeAnimations.contains(this.prevAnim) && blowpipeAnimations.contains(this.currAnim)) {
			if (player.getAnimationFrame() == 0)
				this.tickDelay = 2;
		}

		this.tickDelay += getAnimationDelay(this.currAnim, weapon);

		Set<Integer> prevNpcs = attackableNpcs;
		this.attackableNpcs = getNearbyAttackableNpcs();
		if (prevNpcs.size() != 0) {
			Set<Integer> intersection = Sets.intersection(prevNpcs, attackableNpcs);
			if (intersection.size() > 0 && this.tickDelay == 0) {
				this.wave.setIdleTicks(this.wave.getIdleTicks() + 1);
			}
		}
	}

	private boolean isCooldownActive() {
		return this.tickDelay > 1;
	}

	private boolean isWaveActive() {
		return this.wave != null && this.wave.getState() == WaveState.STARTED;
	}

	private Set<Integer> getNearbyAttackableNpcs() {
		Set<Integer> result = new HashSet<>();
		if (!this.client.getNpcs().isEmpty()) {
			this.client.getNpcs().stream().filter(npc -> {
				return !npc.isDead() && isAttackable(npc);
			}).forEach(npc -> result.add(npc.getIndex()));
		}
		return result;
	}

	private boolean isAttackable(NPC npc) {
		for (int i = 0; i < npc.getComposition().getActions().length; ++i) {
			String action = npc.getComposition().getActions()[i];
			if (action != null && action.equals("Attack")) {
				return true;
			}
		}
		return false;
	}

	private int getAnimationDelay(Animation animation, int weapon) {
		switch (animation) {
			case IDLE:
			case THRALL:
			case DEATH_CHARGE:
			case BLOWPIPE:
			case BLOWPIPE_BLAZING:
				switch (weapon) {
					case ItemID.CHINCHOMPA:
					case ItemID.CHINCHOMPA_10033:
					case ItemID.RED_CHINCHOMPA:
					case ItemID.RED_CHINCHOMPA_10034:
					case ItemID.BLACK_CHINCHOMPA:
						break;
					default:
						return 0;
				}

				ItemContainer itemContainer = client.getItemContainer(InventoryID.EQUIPMENT);
				if (itemContainer == null)
					return 0;

				this.prevChinCount = this.currChinCount;
				this.currChinCount = itemContainer.count(weapon);

				if (this.prevChinCount > this.currChinCount)
					return 3;

				return 0;
			case EVENT_RPG:
			case CHINCHOMPA:
			case TRIDENT_SANG:
				return 3;
			case BOW:
				switch (weapon) {
					case ItemID.TWISTED_BOW:
						return 5;
					case ItemID.BOW_OF_FAERDHINEN:
					case ItemID.BOW_OF_FAERDHINEN_C:
					case ItemID.BOW_OF_FAERDHINEN_C_25884:
					case ItemID.BOW_OF_FAERDHINEN_C_25886:
					case ItemID.BOW_OF_FAERDHINEN_C_25888:
					case ItemID.BOW_OF_FAERDHINEN_C_25890:
					case ItemID.BOW_OF_FAERDHINEN_C_25892:
					case ItemID.BOW_OF_FAERDHINEN_C_25894:
					case ItemID.BOW_OF_FAERDHINEN_C_25896:
						return 4;
					default:
						return 3;
				}
			case SURGE:
				return weapon == ItemID.HARMONISED_NIGHTMARE_STAFF ? 4 : 5;
			case STAFF_BASH:
				switch (weapon) {
					case ItemID.BEGINNER_WAND:
					case ItemID.APPRENTICE_WAND:
					case ItemID.TEACHER_WAND:
					case ItemID.MASTER_WAND:
					case ItemID.KODAI_WAND:
					case ItemID._3RD_AGE_WAND:
						return 4;
					default:
						return 5;
				}
			case CLAW_SCRATCH:
			case CLAW_SPEC:
			case RAPIER:
			case INQ_MACE:
				return 4;
			case DINHS:
			case STRIKE_BOLT:
			case BURST_BLITZ:
			case CROSSBOW:
			case SCYTHE:
			case BARRAGE:
				return 5;
			case CHALLY_JAB:
			case CHALLY_SWIPE:
			case CHALLY_SPEC:
				return 7;
			default:
				return 0;
		}
	}

	@Getter
	@AllArgsConstructor
	private enum Animation {
		UNKNOWN(-2),
		IDLE(-1),
		CLAW_SCRATCH(393),
		STAFF_BASH(414),
		PUNCH(422),
		KICK(423),
		BOW(426),
		CHALLY_JAB(428),
		CHALLY_SWIPE(440),
		MSB_SPEC(1074),
		STRIKE_BOLT(1162),
		TRIDENT_SANG(1167),
		CHALLY_SPEC(1203),
		BURST_BLITZ(1379),
		BARRAGE(1979),
		EVENT_RPG(2323),
		INQ_MACE(4503),
		BLOWPIPE(5061),
		DINHS(7511),
		CLAW_SPEC(7514),
		CROSSBOW(7552),
		CHINCHOMPA(7618),
		SURGE(7855),
		SCYTHE(8056),
		RAPIER(8145),
		DEATH_CHARGE(8970),
		THRALL(8973),
		BLOWPIPE_BLAZING(10656);

		private final int id;

		public static Animation valueOf(int id) {
			return Arrays.stream(values())
					.filter(anim -> anim.id == id)
					.findFirst()
					.orElse(UNKNOWN);
		}
	}
}


package com.infernostats.controller;

import com.infernostats.InfernoStatsConfig;
import com.infernostats.InfernoStatsPlugin;
import com.infernostats.events.TimerPausedEvent;
import com.infernostats.events.TimerStartedEvent;
import com.infernostats.events.TimerStoppedEvent;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.GameTick;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;

@Slf4j
@Getter
public class TimerHandler {

	public enum TimerState {
		RUNNING,
		PAUSED,
		STOPPED
	}

	private long duration;
	private TimerState state;

	private final InfernoStatsPlugin plugin;
	private final InfernoStatsConfig config;

	@Inject
	protected TimerHandler(InfernoStatsPlugin plugin, InfernoStatsConfig config) {
		this.plugin = plugin;
		this.config = config;
		this.duration = 0;
		this.state = TimerState.STOPPED;
	}

	@Subscribe
	protected void onTimerStartedEvent(TimerStartedEvent e) {
		if (this.state == TimerState.STOPPED)
			this.duration = e.getOffset();
		else
			this.duration += e.getOffset();

		this.state = TimerState.RUNNING;
		this.config.tzhaarTimerState(this.state);
	}

	@Subscribe
	protected void onTimerPausedEvent(TimerPausedEvent e) {
		this.state = TimerState.PAUSED;
		this.config.tzhaarTimerState(this.state);
		this.config.tzhaarDuration(this.duration);
	}

	@Subscribe
	protected void onTimerStoppedEvent(TimerStoppedEvent e) {
		this.state = TimerState.STOPPED;
		this.config.tzhaarTimerState(this.state);
		this.config.tzhaarDuration(this.duration);
	}

	@Subscribe
	protected void onGameTick(GameTick e) {
		if (this.state == TimerState.RUNNING)
			this.duration += 1;
	}
}

package com.infernostats.controller;

import com.infernostats.InfernoStatsConfig;
import com.infernostats.InfernoStatsPlugin;
import com.infernostats.events.WaveFinishedEvent;
import com.infernostats.events.WaveStartedEvent;
import com.infernostats.model.Location;
import com.infernostats.model.Wave;
import com.infernostats.model.WaveState;
import com.infernostats.view.TimeFormatting;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.NpcSpawned;
import net.runelite.api.events.StatChanged;
import net.runelite.api.gameval.NpcID;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;

import static net.runelite.api.Skill.PRAYER;
import static net.runelite.client.RuneLite.RUNELITE_DIR;

@Slf4j
public class WaveHandler {
  @Getter
  private Wave wave;

  @Getter
  @Setter
  private Location location;

  @Getter
  private final ArrayList<Wave> waves;

  private int prayer;

  @Inject
  private Client client;

  @Inject
  private EventBus eventBus;

  private final InfernoStatsPlugin plugin;
  private final InfernoStatsConfig config;

  @Inject
  protected WaveHandler(InfernoStatsPlugin plugin, InfernoStatsConfig config) {
    this.plugin = plugin;
    this.config = config;
    this.wave = null;
    this.waves = new ArrayList<>();
  }

  @Subscribe
  protected void onGameTick(GameTick e) {
    if ((!this.plugin.isInInferno() && !this.plugin.isInFightCaves()) || this.wave == null)
      return;

    if (this.wave.getState() != WaveState.STARTED)
      return;

    if (this.plugin.getTimerState() == TimerHandler.TimerState.RUNNING)
      this.wave.setDuration(this.wave.getDuration() + 1);

    prayer = client.getBoostedSkillLevel(PRAYER);
  }

  @Subscribe
  public void onStatChanged(StatChanged event) {
    if ((!this.plugin.isInInferno() && !this.plugin.isInFightCaves()) || this.wave == null)
      return;

    if (this.wave.getState() != WaveState.STARTED)
      return;

    if (event.getSkill() != PRAYER)
      return;

    if (event.getBoostedLevel() == prayer - 1)
      wave.setPrayerDrain(wave.getPrayerDrain() + 1);
  }

  @Subscribe(priority = 1)
  protected void onWaveStartedEvent(WaveStartedEvent e) {
    if (this.plugin.isInInferno())
      setLocation(Location.INFERNO);
    else if (this.plugin.isInFightCaves())
      setLocation(Location.FIGHT_CAVES);

    this.wave = e.getWave();
    if (this.wave.getId() == 1)
      waves.clear();
    this.waves.add(this.wave);
  }

  @Subscribe(priority = 1)
  protected void onWaveFinishedEvent(WaveFinishedEvent e) {
    this.wave.setState(e.getState());
  }

  @Subscribe
  protected void onNpcSpawned(NpcSpawned e) {
    final NPC npc = e.getNpc();
    final Actor npcActor = e.getActor();
    final WorldPoint spawnTile = npcActor.getWorldLocation();
    final int npcId = npc.getId();

    if (!this.plugin.isInInferno() || this.wave == null)
      return;

    // ROCKY_SUPPORT is the normal pillar id; ROCKY_SUPPORT_7710 spawns as a pillar falls
    if (npcId == NpcID.INFERNO_INVISIBLE_3X3 || npcId == NpcID.INFERNO_SAFESPOT_DYING)
      return;

    // We'll ignore nibblers and jads, and zuk spawns off the map
    if (npcId == NpcID.INFERNO_NIBBLER || npcId == NpcID.INFERNO_JAD || npcId == NpcID.INFERNO_TZKALZUK_PLACEHOLDER)
      return;

    // We only want the original wave spawn, not minions or mager respawns
    if (wave.getDuration() > 2)
      return;

    wave.addNPC(npc.getName(), spawnTile);
  }

  @Subscribe
  public void onHitsplatApplied(HitsplatApplied event) {
    Actor target = event.getActor();
    Hitsplat hitsplat = event.getHitsplat();

    if ((!this.plugin.isInInferno() && !this.plugin.isInFightCaves()) || this.wave == null)
      return;

    if (!hitsplat.isMine())
      return;

    if (target == this.client.getLocalPlayer()) {
      this.wave.setDamageTaken(this.wave.getDamageTaken() + hitsplat.getAmount());
    } else {
      this.wave.setDamageDealt(this.wave.getDamageDealt() + hitsplat.getAmount());
    }
  }

  public void WriteWaves() {
    Player player = client.getLocalPlayer();
    if (player == null)
      return;

    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH-mm-ss");
    String time = formatter.format(LocalDateTime.now());

    if (config.saveWaveTimes()) {
      switch (config.splitsFileType()) {
        case TEXT:
          toFile(player.getName(), fileName(time, false), toText(false));
          break;
        case CSV:
          toFile(player.getName(), fileName(time, false), toCSV(false));
          break;
      }
    }

    if (config.saveSplitTimes()) {
      switch (config.splitsFileType()) {
        case TEXT:
          toFile(player.getName(), fileName(time, true), toText(true));
          break;
        case CSV:
          toFile(player.getName(), fileName(time, true), toCSV(true));
          break;
      }
    }
  }

  private void toFile(String username, String filename, String contents) {
    try {
      Path path = null;
      switch (this.wave.getLocation()) {
        case FIGHT_CAVES:
          path = Files.createDirectories(Paths.get(
              RUNELITE_DIR.getPath(), "inferno-stats", username, "fight-caves"));
          break;
        case INFERNO:
          path = Files.createDirectories(Paths.get(
              RUNELITE_DIR.getPath(), "inferno-stats", username, "inferno"));
          break;
      }
      Files.write(path.resolve(filename), contents.getBytes());
    } catch (IOException ex) {
      log.debug("Error writing file: {}", ex.getMessage());
    }
  }

  private String toText(boolean splitWaves) {
    StringBuilder text = new StringBuilder();
    ArrayList<Wave> waves = this.getWaves();

    if (splitWaves) {
      Wave prev = null;
      for (Wave wave : waves) {
        if (!wave.isSplit())
          continue;

        text.append("Wave: ").append(wave.getId())
            .append(", ")
            .append("Split: ").append(TimeFormatting.getSplitTime(wave))
            .append(" ")
            .append("(+").append(TimeFormatting.getSplitDelta(wave, prev)).append(")")
            .append("\n");

        prev = wave;
      }
    } else {
      for (Wave wave : waves) {
        text.append("Wave: ").append(wave.getId())
            .append(", ")
            .append("Split: ").append(TimeFormatting.getSplitTime(wave))
            .append("\n");
      }
    }

    if (waves.isEmpty()) {
      text.append("Duration (Not Started): N/a");
      return text.toString();
    }

    String duration = TimeFormatting.getCurrentTotalTime(wave);
    switch (wave.getState()) {
      case FINISHED:
      case STARTED:
        text.append("Duration (Unfinished): ").append(duration);
        break;
      case SUCCESS:
        text.append("Duration (Success): ").append(duration);
        break;
      case FAILED:
        text.append("Duration (Failed): ").append(duration);
        break;
    }

    return text.toString();
  }

  private String toCSV(boolean splitWaves) {
    StringBuilder csv = new StringBuilder();

    if (splitWaves) {
      csv.append("wave,split,time,delta,idle\n");

      Wave prev = null;
      for (Wave wave : waves) {
        if (!wave.isSplit())
          continue;

        csv.append(wave.getId())
            .append(",")
            .append(TimeFormatting.getSplitTime(wave))
            .append(",")
            .append(TimeFormatting.getCurrentWaveTime(wave))
            .append(",")
            .append(TimeFormatting.getSplitDelta(wave, prev))
            .append(",")
            .append(wave.getIdleTicks())
            .append("\n");

        prev = wave;
      }
    } else {
      csv.append("wave,split,time,idle\n");

      for (Wave wave : waves) {
        csv.append(wave.getId())
            .append(",")
            .append(TimeFormatting.getSplitTime(wave))
            .append(",")
            .append(TimeFormatting.getCurrentWaveTime(wave))
            .append(",")
            .append(wave.getIdleTicks())
            .append("\n");
      }
    }

    return csv.toString();
  }

  private String fileName(String time, boolean splitWaves) {
    String wavesText = (splitWaves ? "Splits" : "Full") + getExtension();

    switch (wave.getState()) {
      case SUCCESS:
        return time + " Successful KC on Wave " + wave.getId() + ", " + wavesText;
      case FAILED:
      default:
        return time + " Failed KC on Wave " + wave.getId() + ", " + wavesText;
    }
  }

  private String getExtension() {
    switch (config.splitsFileType()) {
      case CSV:
        return ".csv";
      default:
      case TEXT:
        return ".txt";
    }
  }
}

package com.infernostats.events;

import com.infernostats.model.WaveState;
import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
public class RunCompletedEvent {
	WaveState state;
  int duration;

  public RunCompletedEvent(WaveState state) {
    this.state = state;
    this.duration = -1;
  }

  public RunCompletedEvent(WaveState state, int duration) {
    this.state = state;
    this.duration = duration;
  }
}

package com.infernostats.events;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public class TimerPausedEvent {
}

package com.infernostats.events;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class TimerStartedEvent {
	int offset;
}

package com.infernostats.events;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public class TimerStoppedEvent {
}

package com.infernostats.events;

import com.infernostats.model.WaveState;
import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class WaveFinishedEvent {
	WaveState state;
}

package com.infernostats.events;

import com.infernostats.model.Wave;
import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class WaveStartedEvent {
	Wave wave;
}

package com.infernostats;

import com.infernostats.controller.TimerHandler;
import lombok.AllArgsConstructor;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup(InfernoStatsConfig.GROUP)
public interface InfernoStatsConfig extends Config {
	String GROUP = "InfernoConfig";

	@ConfigSection(
			name = "Overlays",
			description = "Overlays Section",
			position = 0,
			closedByDefault = true
	)
	String overlays = "overlays";

	@ConfigItem(
			position = 0,
			keyName = "splitsOverlay",
			name = "Splits Overlay",
			description = "Displays an overlay with the wave number and splits/predicted time.",
			section = overlays
	)
	default boolean splitsOverlay() {
		return true;
	}

	@ConfigItem(
			position = 1,
			keyName = "showInfernoTimer",
			name = "Inferno Timer",
			description = "Display elapsed time in the Inferno",
			section = overlays
	)
	default boolean showInfernoTimer() {
		return true;
	}

	@ConfigItem(
			position = 2,
			keyName = "showFightCavesTimer",
			name = "Fight Caves Timer",
			description = "Display elapsed time in the Fight Caves",
			section = overlays
	)
	default boolean showFightCavesTimer() {
		return true;
	}

	@ConfigItem(
			keyName = "tzhaarDuration",
			name = "",
			description = "",
			section = overlays,
			hidden = true
	)
	long tzhaarDuration();

	@ConfigItem(
			keyName = "tzhaarDuration",
			name = "",
			description = "",
			section = overlays
	)
	void tzhaarDuration(long tzhaarDuration);

	@ConfigItem(
			keyName = "tzhaarTimerState",
			name = "",
			description = "",
			section = overlays,
			hidden = true
	)
	TimerHandler.TimerState tzhaarTimerState();

	@ConfigItem(
			keyName = "tzhaarTimerState",
			name = "",
			description = "",
			section = overlays
	)
	void tzhaarTimerState(TimerHandler.TimerState tzhaarTimerState);

	@ConfigSection(
			name = "Wave and Split Times",
			description = "Wave and Split Times Section",
			position = 1,
			closedByDefault = true
	)
	String waveAndSplitTimes = "waveAndSplitTimes";

	@ConfigItem(
			position = 0,
			keyName = "showWaveTimes",
			name = "Wave Times",
			description = "Displays a chat message of the time taken to complete the previous wave",
			section = waveAndSplitTimes
	)
	default boolean waveTimes() {
		return false;
	}

	@ConfigItem(
			position = 1,
			keyName = "showSplitTimes",
			name = "Split Times",
			description = "Displays a chat message of the total time taken to reach the current wave",
			section = waveAndSplitTimes
	)
	default boolean splitTimes() {
		return true;
	}

	@ConfigItem(
			position = 2,
			keyName = "predictedCompletionTime",
			name = "Predicted Time",
			description = "Show predicted completion time",
			section = waveAndSplitTimes
	)
	default boolean predictedCompletionTime() {
		return true;
	}

	@ConfigItem(
			position = 3,
			keyName = "saveWaveTimes",
			name = "Save Wave Times",
			description = "Saves the time of every wave after a run",
			section = waveAndSplitTimes
	)
	default boolean saveWaveTimes() {
		return false;
	}

	@ConfigItem(
			position = 4,
			keyName = "saveSplitTimes",
			name = "Save Split Times",
			description = "Saves the time of every split after a run",
			section = waveAndSplitTimes
	)
	default boolean saveSplitTimes() {
		return true;
	}

	@AllArgsConstructor
	enum FileType {
		TEXT,
		CSV
	}

	@ConfigItem(
			position = 5,
			keyName = "splitsFileType",
			name = "Splits File Type",
			description = "File type to save splits as",
			section = waveAndSplitTimes
	)
	default FileType splitsFileType() {
		return FileType.TEXT;
	}

	@ConfigSection(
			name = "Target Split Times",
			description = "Split times that you wish to achieve",
			position = 2,
			closedByDefault = true
	)
	String targetSplitTimes = "targetSplitTimes";

	@ConfigItem(
			position = 0,
			keyName = "targetSplitTimes",
			name = "Target Split Times",
			description = "Enable Target Split Times",
			section = targetSplitTimes
	)
	default boolean showTargetSplitTimes() {
		return false;
	}

	@ConfigItem(
			position = 1,
			keyName = "targetWave9Split",
			name = "Wave 9",
			description = "Split Target",
			section = targetSplitTimes
	)
	default String targetWave9Split() {
		return "2:55";
	}

	@ConfigItem(
			position = 2,
			keyName = "targetWave18Split",
			name = "Wave 18",
			description = "Split Target",
			section = targetSplitTimes
	)
	default String targetWave18Split() {
		return "7:15";
	}

	@ConfigItem(
			position = 3,
			keyName = "targetWave25Split",
			name = "Wave 25",
			description = "Split Target",
			section = targetSplitTimes
	)
	default String targetWave25Split() {
		return "11:05";
	}

	@ConfigItem(
			position = 4,
			keyName = "targetWave35Split",
			name = "Wave 35",
			description = "Split Target",
			section = targetSplitTimes
	)
	default String targetWave35Split() {
		return "17:58";
	}

	@ConfigItem(
			position = 5,
			keyName = "targetWave42Split",
			name = "Wave 42",
			description = "Split Target",
			section = targetSplitTimes
	)
	default String targetWave42Split() {
		return "23:13";
	}

	@ConfigItem(
			position = 6,
			keyName = "targetWave50Split",
			name = "Wave 50",
			description = "Split Target",
			section = targetSplitTimes
	)
	default String targetWave50Split() {
		return "30:50";
	}

	@ConfigItem(
			position = 7,
			keyName = "targetWave57Split",
			name = "Wave 57",
			description = "Split Target",
			section = targetSplitTimes
	)
	default String targetWave57Split() {
		return "38:06";
	}

	@ConfigItem(
			position = 8,
			keyName = "targetWave60Split",
			name = "Wave 60",
			description = "Split Target",
			section = targetSplitTimes
	)
	default String targetWave60Split() {
		return "41:29";
	}

	@ConfigItem(
			position = 9,
			keyName = "targetWave63Split",
			name = "Wave 63",
			description = "Split Target",
			section = targetSplitTimes
	)
	default String targetWave63Split() {
		return "44:59";
	}

	@ConfigItem(
			position = 10,
			keyName = "targetWave66Split",
			name = "Wave 66",
			description = "Split Target",
			section = targetSplitTimes
	)
	default String targetWave66Split() {
		return "48:41";
	}

	@ConfigItem(
			position = 11,
			keyName = "targetWave67Split",
			name = "Wave 67",
			description = "Split Target",
			section = targetSplitTimes
	)
	default String targetWave67Split() {
		return "49:27";
	}

	@ConfigItem(
			position = 12,
			keyName = "targetWave68Split",
			name = "Wave 68",
			description = "Split Target",
			section = targetSplitTimes
	)
	default String targetWave68Split() {
		return "50:32";
	}

	@ConfigItem(
			position = 13,
			keyName = "targetWave69Split",
			name = "Wave 69",
			description = "Split Target",
			section = targetSplitTimes
	)
	default String targetWave69Split() {
		return "53:06";
	}

	@ConfigSection(
			name = "Idle Ticks",
			description = "Settings around tracking player idle ticks",
			position = 4,
			closedByDefault = true
	)
	String idleTicks = "idleTicks";

	@ConfigItem(
			keyName = "showIdleTicksInSidePanel",
			name = "Show Idle Ticks in Side Panel",
			description = "Show idle ticks in the side panel",
			position = 0,
			section = idleTicks
	)
	default boolean showIdleTicksInSidePanel() {
		return true;
	}

	@ConfigItem(
			keyName = "showIdleTicksInChatbox",
			name = "Show Idle Ticks in Chatbox",
			description = "Show idle ticks in the chat box",
			position = 1,
			section = idleTicks
	)
	default boolean showIdleTicksInChatbox() {
		return false;
	}

	@AllArgsConstructor
	enum URL {
		LINE_OF_SIGHT("https://infernostats.github.io/inferno.html?"),
		TRAINER("https://www.infernotrainer.com/?");

		public final String base;
	}

	@ConfigItem(
			position = 5,
			keyName = "url",
			name = "Wave Tool",
			description = "Tool to use when opening wave spawns"
	)
	default URL url() {
		return URL.LINE_OF_SIGHT;
	}

	@ConfigItem(
			position = 6,
			keyName = "hide",
			name = "Hide when outside of the Inferno",
			description = "Don't show the button in the sidebar when you're not in the Inferno"
	)
	default boolean hide() {
		return false;
	}
}

package com.infernostats;

import com.infernostats.controller.TimerHandler;
import com.infernostats.model.Location;
import com.infernostats.model.Wave;
import com.infernostats.view.TimeFormatting;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

import javax.inject.Inject;
import java.awt.*;
import java.util.*;

public class InfernoStatsOverlay extends OverlayPanel {
  private Wave prevSplitWave;

  private final InfernoStatsPlugin plugin;
  private final InfernoStatsConfig config;

  @Inject
  private InfernoStatsOverlay(InfernoStatsPlugin plugin, InfernoStatsConfig config) {
    super(plugin);

    this.plugin = plugin;
    this.config = config;
    this.prevSplitWave = null;

    setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
    setPriority(PRIORITY_MED);
  }

  @Override
  public Dimension render(Graphics2D graphics) {
    if (!this.plugin.isInInferno() && !this.plugin.isInFightCaves())
      return null;

    panelComponent.getChildren().clear();

    Wave wave = this.plugin.getCurrentWave();
    if (wave == null)
      return null;

    if (this.plugin.getTimerState() != TimerHandler.TimerState.RUNNING)
      return null;

    String header = "Current Wave: " + wave.getId();
    LinkedHashMap<String, String> contents = new LinkedHashMap<>();

    if (wave.isSplit())
      prevSplitWave = wave;

    if (prevSplitWave != null) {
      if (config.splitTimes()) {
        contents.put("Wave " + prevSplitWave.getId() + " Split: ", TimeFormatting.getSplitTime(prevSplitWave));
      }

      if ((prevSplitWave.getLocation() == Location.INFERNO) &&
          (config.predictedCompletionTime() && prevSplitWave.getPace() != null)) {
        contents.put("Predicted Time: ", TimeFormatting.formatDuration(prevSplitWave.getPace()));
      }
    }

    panelComponent.getChildren().add(TitleComponent.builder()
        .text(header)
        .color(ColorScheme.BRAND_ORANGE)
        .build());

    panelComponent.setPreferredSize(new Dimension(getMaxWidth(graphics, contents, header) + 10, 0));

    for (Map.Entry<String, String> pair : contents.entrySet()) {
      panelComponent.getChildren().add(
          LineComponent
              .builder()
              .left(pair.getKey())
              .right(pair.getValue())
              .build());
    }

    return super.render(graphics);
  }

  private int getMaxWidth(Graphics2D graphics, HashMap<String, String> contents, String header) {
    if (contents.isEmpty())
      return graphics.getFontMetrics().stringWidth(header);

    Map.Entry<String, String> longestPair =
        Collections.max(contents.entrySet(), Comparator.comparingInt(this::keyValueLength));

    return graphics.getFontMetrics().stringWidth(longestPair.getKey()) +
        graphics.getFontMetrics().stringWidth(longestPair.getValue());
  }

  private int keyValueLength(Map.Entry<String, String> entry) {
    return entry.getKey().length() + entry.getValue().length();
  }

  public void reset() {
    this.prevSplitWave = null;
  }
}

package com.infernostats;

import com.infernostats.model.Wave;
import com.infernostats.view.*;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.*;

@Getter(AccessLevel.PACKAGE)
public class InfernoStatsPanel extends PluginPanel {
	private WaveStatsPanel waveStatsPanel;

	private final TitlePanel titlePanel = new TitlePanel();
	private final WaveSplitsPanel waveSplitsPanel = new WaveSplitsPanel();
	private final WaveListPanel waveListPanel = new WaveListPanel();
	private final WaveListContainer waveListContainer = new WaveListContainer(waveListPanel);

	private final InfernoStatsPlugin plugin;
	private final InfernoStatsConfig config;

	@Inject
	private InfernoStatsPanel(InfernoStatsPlugin plugin, InfernoStatsConfig config) {
		this.plugin = plugin;
		this.config = config;

		setBackground(ColorScheme.DARK_GRAY_COLOR);

		add(this.titlePanel, BorderLayout.NORTH, 0);
		add(this.waveSplitsPanel, BorderLayout.CENTER, 1);
		add(this.waveListContainer, BorderLayout.SOUTH, 2);

		waveSplitsPanel.setWaves(this.plugin.getWaves());
	}

	void AddWave(Wave wave) {
		SwingUtilities.invokeLater(() ->
		{
			waveStatsPanel = new WaveStatsPanel(config, wave);
			waveListPanel.add(waveStatsPanel, 0);

			updateUI();
		});
	}

	void UpdateWave() {
		if (waveStatsPanel == null)
			return;

		SwingUtilities.invokeLater(() -> waveStatsPanel.update());
	}

	public void ClearWaves() {
		waveListPanel.removeAll();
		waveListPanel.validate();
		waveListPanel.repaint();
	}
}

package com.infernostats;

import com.google.inject.Provides;
import com.infernostats.controller.ChatHandler;
import com.infernostats.controller.TickLossHandler;
import com.infernostats.controller.TimerHandler;
import com.infernostats.controller.WaveHandler;
import com.infernostats.events.*;
import com.infernostats.model.Wave;
import com.infernostats.model.WaveSplit;
import com.infernostats.model.WaveState;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.WorldView;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.util.ArrayList;

import static net.runelite.api.gameval.ItemID.INFERNAL_CAPE;
import static net.runelite.api.gameval.ItemID.TZHAAR_CAPE_FIRE;

@PluginDescriptor(
    name = "Inferno Stats",
    description = "Track restoration specials during an inferno attempt.",
    tags = {"combat", "npcs", "overlay"}
)
@Slf4j
public class InfernoStatsPlugin extends Plugin {
  private static final int INFERNO_REGION_ID = 9043;
  private static final int FIGHT_CAVES_REGION_ID = 9551;

  @Getter(AccessLevel.PACKAGE)
  private InfernoStatsPanel panel;

  @Getter(AccessLevel.PACKAGE)
  private NavigationButton navButton;

  @Inject
  private ChatHandler chatHandler;

  @Inject
  private TimerHandler timerHandler;

  @Inject
  private WaveHandler waveHandler;

  @Inject
  private TickLossHandler tickLossHandler;

  @Inject
  private Client client;

  @Inject
  private EventBus eventBus;

  @Inject
  private ClientToolbar clientToolbar;

  @Inject
  private ItemManager itemManager;

  @Inject
  private InfoBoxManager infoBoxManager;

  @Inject
  private OverlayManager overlayManager;

  @Inject
  private InfernoStatsOverlay overlay;

  @Inject
  private InfernoStatsConfig config;

  @Provides
  InfernoStatsConfig getConfig(ConfigManager configManager) {
    return configManager.getConfig(InfernoStatsConfig.class);
  }

  @Override
  protected void startUp() {
    panel = injector.getInstance(InfernoStatsPanel.class);
    navButton = NavigationButton.builder()
        .tooltip("Inferno Stats")
        .icon(ImageUtil.loadImageResource(getClass(), "/blob-square.png"))
        .priority(6)
        .panel(panel)
        .build();

    if (isInInferno() || !config.hide())
      clientToolbar.addNavigation(navButton);

    if (config.splitsOverlay())
      overlayManager.add(overlay);

    WaveSplit.UpdateTargetSplits(this.config);

    eventBus.register(waveHandler);
    eventBus.register(timerHandler);
    eventBus.register(chatHandler);
    eventBus.register(tickLossHandler);

    eventBus.register(TimerStartedEvent.class);
    eventBus.register(TimerPausedEvent.class);
    eventBus.register(TimerStoppedEvent.class);
  }

  @Override
  protected void shutDown() {
    overlayManager.remove(overlay);
    clientToolbar.removeNavigation(navButton);

    eventBus.unregister(TimerStartedEvent.class);
    eventBus.unregister(TimerPausedEvent.class);
    eventBus.unregister(TimerStoppedEvent.class);

    eventBus.unregister(tickLossHandler);
    eventBus.unregister(chatHandler);
    eventBus.unregister(timerHandler);
    eventBus.unregister(waveHandler);
  }

  @Subscribe
  public void onConfigChanged(ConfigChanged event) {
    if (!event.getGroup().equals(this.config.GROUP))
      return;

    switch (event.getKey()) {
      case "hide":
        resetNav();
        break;
      case "showInfernoTimer":
      case "showFightCavesTimer":
        createTimer();
        break;
      case "splitsOverlay":
        if (config.splitsOverlay()) {
          overlayManager.add(overlay);
        } else {
          overlayManager.remove(overlay);
        }
    }

    WaveSplit.UpdateTargetSplits(this.config);
  }

  @Subscribe
  public void onGameStateChanged(GameStateChanged gameStateChanged) {
    switch (gameStateChanged.getGameState()) {
      case LOADING:
        if (timerHandler.getState() == TimerHandler.TimerState.RUNNING)
          if (!isInFightCaves() && !isInInferno()) {
            eventBus.post(new TimerStoppedEvent());
            eventBus.post(new RunCompletedEvent(WaveState.FAILED));
          }
        resetNav();
        break;
      case LOGIN_SCREEN:
      case HOPPING:
        if (timerHandler.getState() == TimerHandler.TimerState.RUNNING)
          eventBus.post(new TimerPausedEvent());
        break;
    }
  }

  @Subscribe
  protected void onGameTick(GameTick e) {
    if (isInInferno() || isInFightCaves())
      this.panel.UpdateWave();
  }

  @Subscribe
  protected void onWaveStartedEvent(WaveStartedEvent e) {
    Wave wave = e.getWave();
    if (wave.getId() == 1)
      this.panel.ClearWaves();
    this.panel.AddWave(wave);
  }

  @Subscribe
  protected void onWaveFinishedEvent(WaveFinishedEvent e) {
    this.panel.UpdateWave();
  }

  @Subscribe
  protected void onRunCompletedEvent(RunCompletedEvent e) {
    Wave wave = getCurrentWave();
    wave.setState(e.getState());

    // Set the duration on successful runs to the final time.
    // This is mainly for fight caves which has a variable start time.
    if (e.getDuration() > 0) {
      wave.setDuration(e.getDuration() - wave.getStart());
    }

    this.panel.UpdateWave();
    this.waveHandler.WriteWaves();
  }

  @Subscribe
  protected void onTimerStartedEvent(TimerStartedEvent e) {
    createTimer();
  }

  @Subscribe
  protected void onTimerStoppedEvent(TimerStoppedEvent e) {
    removeTimer();
    overlay.reset();
  }

  private void resetNav() {
    if (isInInferno() || !config.hide())
      clientToolbar.addNavigation(navButton);
    else
      clientToolbar.removeNavigation(navButton);
  }

  private void createTimer() {
    removeTimer();

    if (config.showFightCavesTimer() && isInFightCaves())
      infoBoxManager.addInfoBox(new InfernoStatsTimer(itemManager.getImage(TZHAAR_CAPE_FIRE), this));
    else if (config.showInfernoTimer() && isInInferno())
      infoBoxManager.addInfoBox(new InfernoStatsTimer(itemManager.getImage(INFERNAL_CAPE), this));
  }

  private void removeTimer() {
    infoBoxManager.removeIf(InfernoStatsTimer.class::isInstance);
  }

  public Wave getCurrentWave() {
    return waveHandler.getWave();
  }

  public ArrayList<Wave> getWaves() {
    return waveHandler.getWaves();
  }

  public TimerHandler.TimerState getTimerState() {
    return timerHandler.getState();
  }

  public long getRunDuration() {
    return timerHandler.getDuration();
  }

  public boolean isInInferno() {
    return isInRegion(INFERNO_REGION_ID);
  }

  public boolean isInFightCaves() {
    return isInRegion(FIGHT_CAVES_REGION_ID);
  }

  private boolean isInRegion(int region) {
    WorldView wv = client.getTopLevelWorldView();
    if (wv == null) {
      return false;
    }

    int[] regions = wv.getMapRegions();
    if (regions == null) {
      return false;
    }

    for (int regionId : regions) {
      if (regionId == region) {
        return true;
      }
    }

    return false;
  }
}
package com.infernostats;

import com.infernostats.view.TimeFormatting;
import net.runelite.client.ui.overlay.infobox.InfoBox;

import java.awt.*;
import java.awt.image.BufferedImage;

public class InfernoStatsTimer extends InfoBox {
  private final InfernoStatsPlugin plugin;

  public InfernoStatsTimer(BufferedImage image, InfernoStatsPlugin plugin) {
    super(image, plugin);

    this.plugin = plugin;
  }

  @Override
  public String getText() {
    return getTime();
  }

  @Override
  public String getTooltip() {
    return "Elapsed time: " + getTime();
  }

  @Override
  public Color getTextColor() {
    return Color.WHITE;
  }

  private String getTime() {
    return TimeFormatting.formatTicksShort(plugin.getRunDuration());
  }
}

package com.infernostats.model;

public enum Location {
	FIGHT_CAVES,
	INFERNO,
}

package com.infernostats.model;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

@Getter
@AllArgsConstructor
public class NPC {
	private final String name;
	private final WorldPoint tile;

	@Override
	public String toString() {
		return name + "@{" + tile.getRegionX() + "," + tile.getRegionY() + "}";
	}
}

package com.infernostats.model;

import com.google.common.collect.ImmutableSet;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Constants;
import net.runelite.api.coords.WorldPoint;

import java.time.Duration;
import java.util.ArrayList;
import java.util.Set;

@Getter
@Setter
public class Wave {
  private final int id;
  private ArrayList<NPC> npcs;
  private final long start;
  private long duration;
  private int damageTaken;
  private int damageDealt;
  private int prayerDrain;
  private int idleTicks;
  private WaveState state;
  private Duration pace;
  private Location location;

  private static final Set<Integer> SPLIT_WAVES = ImmutableSet.of(
      9, 18, 25, 35, 42, 50, 57, 60, 63, 66, 67, 68, 69
  );

  private static final Set<Integer> FIGHT_CAVE_SPLIT_WAVES = ImmutableSet.of(
      7, 15, 31, 46, 53, 61, 62, 63
  );

  public Wave(int id, long start) {
    this.id = id;
    this.start = start;
    this.duration = 0;
    this.damageTaken = 0;
    this.damageDealt = 0;
    this.prayerDrain = 0;
    this.idleTicks = 0;
    this.state = WaveState.STARTED;
    this.npcs = new ArrayList<>();
    this.pace = null;
  }

  public void addNPC(String name, WorldPoint spawnTile) {
    this.npcs.add(new NPC(name, spawnTile));
  }

  public boolean isSplit() {
    switch (location) {
      case FIGHT_CAVES:
        return FIGHT_CAVE_SPLIT_WAVES.contains(this.getId());
      default:
      case INFERNO:
        return SPLIT_WAVES.contains(this.getId());
    }
  }

  public Duration start() {
    return Duration.ofMillis(this.start * Constants.GAME_TICK_LENGTH);
  }
}

package com.infernostats.model;

import lombok.AllArgsConstructor;
import lombok.Getter;

import java.awt.*;

@Getter
@AllArgsConstructor
public class WaveSpawn {
	private final int x;
	private final int y;
	private final int size;
	private final Color color;
}

package com.infernostats.model;

import com.google.common.collect.ImmutableMap;
import com.infernostats.InfernoStatsConfig;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Constants;

import java.time.Duration;
import java.util.ArrayList;
import java.util.Arrays;

@Slf4j
public final class WaveSplit {
	private static ArrayList<String> targetSplits;

	public static void UpdateTargetSplits(InfernoStatsConfig config) {
		targetSplits = new ArrayList<>(Arrays.asList(
				config.targetWave9Split(),
				config.targetWave18Split(),
				config.targetWave25Split(),
				config.targetWave35Split(),
				config.targetWave42Split(),
				config.targetWave50Split(),
				config.targetWave57Split(),
				config.targetWave60Split(),
				config.targetWave63Split(),
				config.targetWave66Split(),
				config.targetWave67Split(),
				config.targetWave68Split(),
				config.targetWave69Split()
		));
	}

	private static Duration ParseConfigSplit(Split split) {
		String targetSplit = targetSplits.get(split.ordinal());
		if (targetSplit.equals(""))
			return null;

		String[] time = targetSplit.split(":");
		if (time.length != 2)
			return null;

		// At most we want 9999 minutes and seconds should always be %02d
		if (time[0].length() > 4 || time[1].length() != 2)
			return null;

		int seconds, minutes;
		try {
			minutes = Integer.parseInt(time[0]);
			seconds = Integer.parseInt(time[1]);
		} catch (NumberFormatException e) {
			return null;
		}

		return Duration.ofMinutes(minutes).plusSeconds(seconds);
	}

	public static String GoalDifference(Wave wave) {
		Split split = WaveSplitMap.get(wave.getId());

		Duration configSplit = ParseConfigSplit(split);
		if (configSplit == null)
			return "";

		// Duration.toSeconds() is supported in Java 9
		long waveSplitSeconds = wave.start().toMillis() / 1000;
		long configSplitSeconds = configSplit.toMillis() / 1000;

		int comparison = configSplit.compareTo(wave.start());
		if (comparison > 0) {
			long difference = configSplitSeconds - waveSplitSeconds;
			String minutes = String.valueOf(difference / 60);
			String seconds = String.format("%02d", difference % 60);
			return " (-" + minutes + ":" + seconds + ")";
		} else if (comparison < 0) {
			long difference = waveSplitSeconds - configSplitSeconds;
			String minutes = String.valueOf(difference / 60);
			String seconds = String.format("%02d", difference % 60);
			return " (+" + minutes + ":" + seconds + ")";
		}

		return " (-0)";
	}

	public static Duration PredictedTime(Wave wave) {
		long waveStartMillis = wave.getStart() * Constants.GAME_TICK_LENGTH;
		float percentComplete = percentOfAvgTime(wave, checkPace(wave));
		return Duration.ofMillis((long) (waveStartMillis * (1 / percentComplete)));
	}

	private static Pace checkPace(Wave wave) {
		Split split = WaveSplitMap.get(wave.getId());
		for (Pace pace : Pace.values()) {
			Duration wavePace = splits[split.ordinal()][pace.ordinal()];
			if (wave.start().compareTo(wavePace) > 0) {
				return pace;
			}
		}
		return Pace.SUB45;
	}

	private static float percentOfAvgTime(Wave wave, Pace pace) {
		Split split = WaveSplitMap.get(wave.getId());
		return (float) splits[split.ordinal()][pace.ordinal()].toMillis() /
				splits[Split.FINISH.ordinal()][pace.ordinal()].toMillis();
	}

	public static final ImmutableMap<Integer, Split> WaveSplitMap = ImmutableMap.<Integer, Split>builder()
			.put(9, Split.SPLIT9)
			.put(18, Split.SPLIT18)
			.put(25, Split.SPLIT25)
			.put(35, Split.SPLIT35)
			.put(42, Split.SPLIT42)
			.put(50, Split.SPLIT50)
			.put(57, Split.SPLIT57)
			.put(60, Split.SPLIT60)
			.put(63, Split.SPLIT63)
			.put(66, Split.SPLIT66)
			.put(67, Split.SPLIT67)
			.put(68, Split.SPLIT68)
			.put(69, Split.SPLIT69)
			.build();

	private enum Split {
		SPLIT9,
		SPLIT18,
		SPLIT25,
		SPLIT35,
		SPLIT42,
		SPLIT50,
		SPLIT57,
		SPLIT60,
		SPLIT63,
		SPLIT66,
		SPLIT67,
		SPLIT68,
		SPLIT69,
		FINISH
	}

	private enum Pace {
		SUB75,
		SUB60,
		SUB55,
		SUB50,
		SUB45
	}

	// The spreadsheet represents milliseconds as a fraction of 60.
	// E.g. 3:12:12 = 3 minutes, 12 seconds, 12 fractional milliseconds
	//              = 3 minutes, 12 seconds, 200 milliseconds
	// as (12 / 60) * 1000 = 200
	private static Duration splitTime(int minutes, int seconds, int fractMillis) {
		int milliseconds = fractMillis / 60 * 1000;
		return Duration.ofMinutes(minutes).plusSeconds(seconds).plusMillis(milliseconds);
	}

	private static final Duration[][] splits = {
			{ // Wave 9
					splitTime(3, 12, 57),
					splitTime(2, 48, 45),
					splitTime(2, 38, 42),
					splitTime(2, 34, 59),
					splitTime(2, 21, 0),
			},
			{ // Wave 18
					splitTime(8, 6, 12),
					splitTime(7, 9, 58),
					splitTime(6, 32, 1),
					splitTime(6, 21, 27),
					splitTime(5, 43, 0),
			},
			{ // Wave 25
					splitTime(12, 38, 5),
					splitTime(11, 10, 54),
					splitTime(10, 20, 25),
					splitTime(9, 59, 32),
					splitTime(8, 51, 0),
			},
			{ // Wave 35
					splitTime(19, 59, 27),
					splitTime(17, 51, 11),
					splitTime(16, 18, 36),
					splitTime(15, 49, 34),
					splitTime(14, 1, 0),
			},
			{ // Wave 42
					splitTime(26, 4, 23),
					splitTime(23, 13, 13),
					splitTime(21, 10, 40),
					splitTime(20, 31, 8),
					splitTime(18, 9, 0),
			},
			{ // Wave 50
					splitTime(34, 44, 58),
					splitTime(30, 42, 4),
					splitTime(27, 57, 20),
					splitTime(27, 0, 28),
					splitTime(23, 50, 0),
			},
			{ // Wave 57
					splitTime(43, 6, 49),
					splitTime(37, 53, 26),
					splitTime(34, 21, 23),
					splitTime(33, 5, 17),
					splitTime(29, 8, 0),
			},
			{ // Wave 60
					splitTime(46, 49, 1),
					splitTime(41, 5, 58),
					splitTime(37, 11, 41),
					splitTime(35, 53, 1),
					splitTime(31, 35, 0),
			},
			{ // Wave 63
					splitTime(51, 29, 49),
					splitTime(44, 57, 13),
					splitTime(40, 36, 18),
					splitTime(39, 2, 40),
					splitTime(34, 28, 0),
			},
			{ // Wave 66
					splitTime(56, 2, 37),
					splitTime(48, 36, 32),
					splitTime(43, 53, 21),
					splitTime(42, 6, 38),
					splitTime(37, 13, 0),
			},
			{ // Wave 67
					splitTime(56, 52, 39),
					splitTime(49, 27, 4),
					splitTime(44, 40, 34),
					splitTime(42, 51, 37),
					splitTime(37, 56, 0),
			},
			{ // Wave 68
					splitTime(58, 6, 13),
					splitTime(50, 28, 47),
					splitTime(45, 37, 21),
					splitTime(43, 43, 28),
					splitTime(38, 41, 0),
			},
			{ // Wave 69
					splitTime(61, 14, 23),
					splitTime(53, 3, 33),
					splitTime(48, 11, 44),
					splitTime(46, 9, 11),
					splitTime(40, 53, 0),
			},
			{ // Finish
					splitTime(67, 6, 6),
					splitTime(57, 39, 56),
					splitTime(51, 42, 17),
					splitTime(49, 15, 59),
					splitTime(43, 43, 0),
			},
	};
}

package com.infernostats.model;

public enum WaveState {
	STARTED,
	FINISHED,
	FAILED,
	SUCCESS
}

package com.infernostats.view;

import com.infernostats.model.Wave;
import net.runelite.api.Constants;

import java.time.Duration;

public class TimeFormatting {
  public static final double SECONDS_PER_TICK = (double) Constants.GAME_TICK_LENGTH / 1_000;

  public static String getSplitTime(Wave wave) {
    return formatTicksShort(wave.getStart());
  }

  public static String getCurrentWaveTime(Wave wave) {
    return formatTicksShort(wave.getDuration());
  }

  public static String getCurrentTotalTime(Wave wave) {
    return formatTicks(wave.getStart() + wave.getDuration());
  }

  public static String getSplitDelta(Wave wave, Wave prev) {
    return (prev == null)
        ? formatTicksShort(wave.getStart())
        : formatDuration(wave.start().minus(prev.start()));
  }

  public static String formatTicks(long ticks) {
    double totalSeconds = ticks * SECONDS_PER_TICK;

    int minutes = (int) (totalSeconds / 60);
    int seconds = (int) (totalSeconds % 60);

    int tenths = (int) Math.round((totalSeconds - minutes * 60 - seconds) * 10);

    return String.format("%02d:%02d.%d", minutes, seconds, tenths);
  }

  public static String formatTicksShort(long ticks) {
    double totalSeconds = ticks * SECONDS_PER_TICK;

    int minutes = (int) (totalSeconds / 60);
    int seconds = (int) (totalSeconds % 60);

    return String.format("%02d:%02d", minutes, seconds);
  }

  public static String formatDuration(Duration duration) {
    long seconds = duration.toMillis() / 1000;
    return String.format("%02d:%02d", seconds / 60, seconds % 60);
  }
}

package com.infernostats.view;

import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;

public class TitlePanel extends JPanel {
	public TitlePanel() {
		setBorder(new EmptyBorder(8, 8, 8, 8));
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JLabel titleLabel = new JLabel();
		titleLabel.setText("Inferno Stats");
		titleLabel.setHorizontalAlignment(SwingConstants.CENTER);
		titleLabel.setForeground(Color.WHITE);
		add(titleLabel);
	}
}

package com.infernostats.view;

import com.infernostats.model.WaveSpawn;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.ArrayList;

public class WaveImage extends JLabel {
	private final ArrayList<WaveSpawn> spawns;

	public WaveImage() {
		int IMAGE_SCALE = 2;
		BufferedImage image = ImageUtil.loadImageResource(getClass(), "/inferno-base.png");
		Image scaledImage = image.getScaledInstance(
				image.getWidth() * IMAGE_SCALE,
				image.getHeight() * IMAGE_SCALE,
				Image.SCALE_DEFAULT
		);
		this.setIcon(new ImageIcon(scaledImage));
		this.spawns = new ArrayList<>();
	}

	public void drawSpawn(int x, int y, int size, Color color) {
		spawns.add(new WaveSpawn(x, y, size, color));
	}

	public void paintComponent(Graphics g) {
		super.paintComponent(g);

		for (WaveSpawn spawn : spawns) {
			g.setColor(spawn.getColor());
			g.fillRect(spawn.getX() * 2, spawn.getY() * 2, spawn.getSize(), spawn.getSize());
		}
	}
}

package com.infernostats.view;

import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import java.awt.*;

public class WaveListContainer extends JScrollPane {
	public WaveListContainer(WaveListPanel waveListPanel) {
		super(waveListPanel);

		this.setBackground(ColorScheme.DARK_GRAY_COLOR);
		this.getVerticalScrollBar().setPreferredSize(new Dimension(6, 0));
	}
}

package com.infernostats.view;

import javax.swing.*;

public class WaveListPanel extends JPanel {
	public WaveListPanel() {
		this.setSize(getSize());
		this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
	}
}
package com.infernostats.view;

import com.infernostats.model.Wave;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.datatransfer.StringSelection;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.font.TextAttribute;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

@Slf4j
public class WaveSplitsPanel extends JPanel {
	private final JLabel titleLabel = new JLabel();

	@Setter
	private ArrayList<Wave> waves = null;

	@Inject
	public WaveSplitsPanel() {
		setBorder(new EmptyBorder(2, 8, 2, 8));
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		titleLabel.setText("Copy Wave Splits to Clipboard");
		titleLabel.setHorizontalAlignment(SwingConstants.CENTER);
		titleLabel.setForeground(Color.WHITE);
		add(titleLabel);

		MouseAdapter waveStatsMouseListener = new MouseAdapter() {
			@Override
			public void mouseEntered(MouseEvent e) {
				setUnderline(titleLabel);
				setCursor(new Cursor(Cursor.HAND_CURSOR));
			}

			@Override
			public void mouseExited(MouseEvent e) {
				unsetUnderline(titleLabel);
				setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
			}

			@Override
			public void mouseClicked(MouseEvent e) {
				if (e.getButton() == MouseEvent.BUTTON3) {
					return;
				}

				Toolkit.getDefaultToolkit()
						.getSystemClipboard()
						.setContents(
								new StringSelection(WaveSplitTimes()),
								null
						);
			}
		};

		addMouseListener(waveStatsMouseListener);
	}

	private void setUnderline(JLabel label) {
		Font font = label.getFont();
		Map<TextAttribute, Object> attributes = new HashMap<>(font.getAttributes());
		attributes.put(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_ON);
		label.setFont(font.deriveFont(attributes));
	}

	private void unsetUnderline(JLabel label) {
		Font font = label.getFont();
		Map<TextAttribute, Object> attributes = new HashMap<>(font.getAttributes());
		attributes.put(TextAttribute.UNDERLINE, -1);
		label.setFont(font.deriveFont(attributes));
	}

	public String WaveSplitTimes() {
		StringBuilder splits = new StringBuilder();

		Wave prev = null;
		for (Wave wave : waves) {
			if (!wave.isSplit())
				continue;

			splits.append("Wave: ").append(wave.getId())
					.append(", ")
					.append("Split: ").append(TimeFormatting.getSplitTime(wave))
					.append(" ")
					.append("(+").append(TimeFormatting.getSplitDelta(wave, prev)).append(")")
					.append("\n");

			prev = wave;
		}

		if (waves.isEmpty()) {
			splits.append("Duration (Not Started): N/a");
			return splits.toString();
		}

		Wave wave = waves.get(waves.size() - 1);
		String duration = TimeFormatting.getCurrentTotalTime(wave);

		switch (wave.getState()) {
			case FINISHED:
			case STARTED:
				splits.append("Duration (Unfinished): ").append(duration);
				break;
			case SUCCESS:
				splits.append("Duration (Success): ").append(duration);
				break;
			case FAILED:
				splits.append("Duration (Failed): ").append(duration);
				break;
		}

		return splits.toString();
	}
}
package com.infernostats.view;

import com.google.common.collect.ImmutableMap;
import com.infernostats.InfernoStatsConfig;
import com.infernostats.model.NPC;
import com.infernostats.model.Wave;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.LinkBrowser;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@Getter
@Setter
public class WaveStatsPanel extends JPanel {
	private Wave wave;
	private String baseURL;

	private String waveURL;
	private JLabel waveNumber;
	private JLabel duration;
	private JLabel damageTaken;
	private JLabel damageDealt;
	private JLabel prayerDrain;
	private JLabel idleTicks;
	private WaveImage imageLabel;
	private JPanel textPanel;

	private InfernoStatsConfig config;

	private static final Border normalBorder = BorderFactory.createCompoundBorder(
			BorderFactory.createMatteBorder(0, 0, 4, 0, ColorScheme.DARK_GRAY_COLOR),
			new EmptyBorder(4, 6, 4, 6));

	private static final Border hoverBorder = BorderFactory.createCompoundBorder(
			BorderFactory.createMatteBorder(0, 0, 4, 0, ColorScheme.DARK_GRAY_COLOR),
			BorderFactory.createCompoundBorder(
					BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_HOVER_COLOR),
					new EmptyBorder(3, 5, 3, 5)));

	public WaveStatsPanel(InfernoStatsConfig config, Wave wave) {
		this.config = config;

		this.wave = wave;
		this.baseURL = config.url().base;
		this.waveURL = generateURL();

		setLayout(new BorderLayout(5, 5));
		setBackground(ColorScheme.DARKER_GRAY_COLOR);
		setBorder(normalBorder);

		JPanel wavePanel = new JPanel();
		wavePanel.setLayout(new BoxLayout(wavePanel, BoxLayout.Y_AXIS));
		wavePanel.setBackground(null);

		JPanel wavePanelTop = new JPanel();
		wavePanelTop.setLayout(new BoxLayout(wavePanelTop, BoxLayout.Y_AXIS));
		wavePanelTop.setBackground(null);

		JPanel waveNumberLine = new JPanel();
		waveNumberLine.setLayout(new BorderLayout());
		waveNumberLine.setBackground(null);

		waveNumber = new JLabel();
		if (wave.isSplit()) {
			waveNumber.setText("Wave " + wave.getId() + " - " + TimeFormatting.getSplitTime(wave));
		} else {
			waveNumber.setText("Wave " + wave.getId());
		}
		waveNumber.setHorizontalAlignment(SwingConstants.CENTER);
		waveNumber.setForeground(Color.WHITE);
		waveNumberLine.add(waveNumber);

		JPanel wavePanelBottom = new JPanel();
		wavePanelBottom.setLayout(new BoxLayout(wavePanelBottom, BoxLayout.X_AXIS));
		wavePanelBottom.setBackground(null);

		textPanel = new JPanel();
		textPanel.setLayout(new BoxLayout(textPanel, BoxLayout.Y_AXIS));
		textPanel.setBackground(null);

		JPanel durationLine = new JPanel();
		durationLine.setLayout(new BorderLayout());
		durationLine.setBackground(null);

		duration = new JLabel();
		duration.setText("Time: 00:00");
		duration.setForeground(Color.WHITE);
		durationLine.add(duration, BorderLayout.WEST);

		JPanel damageTakenLine = new JPanel();
		damageTakenLine.setLayout(new BorderLayout());
		damageTakenLine.setBackground(null);

		damageTaken = new JLabel();
		damageTaken.setText("Damage Taken: 0");
		damageTaken.setForeground(Color.WHITE);
		damageTakenLine.add(damageTaken, BorderLayout.WEST);

		JPanel damageDealtLine = new JPanel();
		damageDealtLine.setLayout(new BorderLayout());
		damageDealtLine.setBackground(null);

		damageDealt = new JLabel();
		damageDealt.setText("Damage Dealt: 0");
		damageDealt.setForeground(Color.WHITE);
		damageDealtLine.add(damageDealt, BorderLayout.WEST);

		JPanel prayerDrainLine = new JPanel();
		prayerDrainLine.setLayout(new BorderLayout());
		prayerDrainLine.setBackground(null);

		prayerDrain = new JLabel();
		prayerDrain.setText("Prayer Drain: 0");
		prayerDrain.setForeground(Color.WHITE);
		prayerDrainLine.add(prayerDrain, BorderLayout.WEST);

		JPanel idleTicksLine = new JPanel();
		idleTicksLine.setLayout(new BorderLayout());
		idleTicksLine.setBackground(null);

		idleTicks = new JLabel();
		idleTicks.setText("Idle Ticks: 0");
		idleTicks.setForeground(Color.WHITE);
		idleTicksLine.add(idleTicks, BorderLayout.WEST);

		textPanel.add(durationLine);
		textPanel.add(damageTakenLine);
		textPanel.add(damageDealtLine);
		textPanel.add(prayerDrainLine);

		if (config.showIdleTicksInSidePanel())
			textPanel.add(idleTicksLine);

		JPanel imagePanel = new JPanel();
		imagePanel.setLayout(new BoxLayout(imagePanel, BoxLayout.Y_AXIS));
		imagePanel.setBackground(null);

		imageLabel = new WaveImage();
		imagePanel.add(imageLabel);

		wavePanelTop.add(waveNumberLine);
		wavePanelBottom.add(textPanel);
		wavePanelBottom.add(imagePanel);

		wavePanel.add(wavePanelTop, BorderLayout.NORTH);
		wavePanel.add(wavePanelBottom, BorderLayout.SOUTH);

		add(wavePanel, BorderLayout.NORTH);

		MouseAdapter waveStatsMouseListener = new MouseAdapter() {
			@Override
			public void mouseEntered(MouseEvent e) {
				setBackground(ColorScheme.DARK_GRAY_COLOR);
				for (Component c : getComponents()) {
					c.setBackground(ColorScheme.DARK_GRAY_COLOR);
				}
				setBorder(hoverBorder);
				setCursor(new Cursor(Cursor.HAND_CURSOR));
			}

			@Override
			public void mouseExited(MouseEvent e) {
				setBackground(ColorScheme.DARKER_GRAY_COLOR);
				for (Component c : getComponents()) {
					c.setBackground(ColorScheme.DARKER_GRAY_COLOR);
				}
				setBorder(normalBorder);
				setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
			}

			@Override
			public void mouseClicked(MouseEvent e) {
				if (e.getButton() == MouseEvent.BUTTON3) {
					return;
				}

				LinkBrowser.browse(waveURL);
			}
		};

		addMouseListener(waveStatsMouseListener);
	}

	public void RedrawWaveSpawn() {
		Map<String, ArrayList<ArrayList<Integer>>> mobs = remapNPCs();
		ImmutableMap<String, Integer> mob_sizes = new ImmutableMap.Builder<String, Integer>()
				.put("Jal-MejRah", 2)
				.put("Jal-Ak", 3)
				.put("Jal-ImKot", 4)
				.put("Jal-Xil", 3)
				.put("Jal-Zek", 4)
				.build();

		ImmutableMap<String, Color> mob_colors = new ImmutableMap.Builder<String, Color>()
				.put("Jal-MejRah", Color.GRAY)
				.put("Jal-Ak", Color.YELLOW)
				.put("Jal-ImKot", Color.ORANGE)
				.put("Jal-Xil", Color.GREEN)
				.put("Jal-Zek", Color.RED)
				.build();

		for (Map.Entry<String, ArrayList<ArrayList<Integer>>> entry : mobs.entrySet()) {
			final String name = entry.getKey();
			final int size = mob_sizes.get(name);
			final ArrayList<ArrayList<Integer>> spawnTiles = entry.getValue();

			for (ArrayList<Integer> spawnTile : spawnTiles) {
				final int x = spawnTile.get(0);
				final int y = spawnTile.get(1);

				imageLabel.drawSpawn(x, y, size, mob_colors.get(name));
			}
		}

		imageLabel.revalidate();
		imageLabel.repaint();
	}

	public String generateURL() {
		Map<String, ArrayList<ArrayList<Integer>>> mobs = remapNPCs();

		// Map in-game names to website parameter names
		ImmutableMap<String, String> npc_names = new ImmutableMap.Builder<String, String>()
				.put("Jal-MejRah", "bat")
				.put("Jal-Ak", "blob")
				.put("Jal-ImKot", "melee")
				.put("Jal-Xil", "ranger")
				.put("Jal-Zek", "mager")
				.build();

		StringBuilder sb = new StringBuilder();

		sb.append(this.baseURL);
		for (Map.Entry<String, ArrayList<ArrayList<Integer>>> entry : mobs.entrySet()) {
			sb.append(npc_names.get(entry.getKey()));
			sb.append("=");
			sb.append(entry.getValue());
			sb.append("&");
		}
		sb.append("copyable");

		return sb.toString().replaceAll("\\s", "");
	}

	private Map<String, ArrayList<ArrayList<Integer>>> remapNPCs() {
		Map<String, ArrayList<ArrayList<Integer>>> mobs = new HashMap<>();

		for (NPC npc : this.wave.getNpcs()) {
			// The SW-most corner region tile is 17,17
			// The SW-most corner website tile is 0, 29
			final int xOffset = 17;

			// The NW-most corner region tile is 17,46
			// The NW-most corner website tile is 0, 0
			final int yOffset = 46;

			final int x = npc.getTile().getRegionX() - xOffset;
			final int y = yOffset - npc.getTile().getRegionY();

			mobs.computeIfAbsent(npc.getName(), k -> new ArrayList<>());
			mobs.get(npc.getName()).add(new ArrayList<>(Arrays.asList(x, y)));
		}

		return mobs;
	}

	public void update() {
		switch (this.getWave().getState()) {
			case FINISHED:
			case STARTED:
				this.getWaveNumber().setForeground(Color.WHITE);
				break;
			case SUCCESS:
				this.getWaveNumber().setForeground(Color.GREEN);
				break;
			case FAILED:
				this.getWaveNumber().setForeground(Color.RED);
				break;
		}

		this.waveURL = this.generateURL();
		this.duration.setText("Time: " + TimeFormatting.getCurrentWaveTime(wave));
		this.damageTaken.setText("Damage Taken: " + this.wave.getDamageTaken());
		this.damageDealt.setText("Damage Dealt: " + this.wave.getDamageDealt());
		this.prayerDrain.setText("Prayer Drain: " + this.wave.getPrayerDrain());
		this.idleTicks.setText("Idle Ticks: " + this.wave.getIdleTicks());
		this.RedrawWaveSpawn();
	}
}

package com.infernostats;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class InfernoStatsPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(InfernoStatsPlugin.class);
		RuneLite.main(args);
	}
}
