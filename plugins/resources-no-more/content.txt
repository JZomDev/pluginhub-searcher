package com.resources.ResourcesNoMore;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.Multimap;
import com.google.common.reflect.TypeToken;
import com.google.gson.Gson;
import com.google.inject.Provides;
import javax.inject.Inject;

import joptsimple.internal.Strings;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;

import java.util.*;

import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

@Slf4j
@PluginDescriptor(
	name = "Resources No More"
)
public class ResourcesNoMorePlugin extends Plugin {
    @Getter(AccessLevel.PACKAGE)
    public final Multimap<WorldView, ResourceTile> depletedTrees = ArrayListMultimap.create();

    @Getter(AccessLevel.PACKAGE)
    public final Multimap<WorldView, ResourceTile> depletedRocks = ArrayListMultimap.create();

    public final ArrayList<Tile> treeTiles = new ArrayList<>();
    public final ArrayList<Tile> rockTiles = new ArrayList<>();

    private static final String CONFIG_GROUP = "resourceGroundMarker";
    private static final String ROCK_GROUP = "_Rock";
    private static final String TREE_GROUP = "_Tree";
    private static final String REGION_PREFIX = "resourceRegion_";

    boolean canAddTree = false;
    boolean canAddOre = false;
    boolean canAddTile = false;

    @Inject
    private Gson gson;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private ConfigManager configManager;

    @Inject
    private Client client;

    @Inject
    private ResourcesNoMoreConfig config;

    @Inject
    ResourcesNoMoreOverlay overlay;


    @Override
    protected void startUp() throws Exception {
        log.debug("Loading at start of RNM...");
        overlayManager.add(overlay);
        loadTrees();
        loadRocks();
    }

    @Override
    protected void shutDown() throws Exception {
        log.debug("RNM is shutting down!");
        overlayManager.remove(overlay);
        depletedTrees.clear();
        depletedRocks.clear();
        treeTiles.clear();
        rockTiles.clear();
    }

    @Subscribe
    public void onWorldViewLoaded(WorldViewLoaded event) {
        loadTrees(event.getWorldView());
        loadRocks(event.getWorldView());
    }

    @Subscribe
    public void onWorldViewUnloaded(WorldViewUnloaded event) {
        depletedRocks.removeAll(event.getWorldView());
        depletedTrees.removeAll(event.getWorldView());
        rockTiles.clear();
        treeTiles.clear();
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event)
    {
        if (event.getGameState() == GameState.HOPPING || event.getGameState() == GameState.LOADING)
        {
            treeTiles.clear();
            rockTiles.clear();
        }
    }

    @Subscribe
    public void onChatMessage(ChatMessage event) {
        var chatType = event.getType();
        if (chatType != ChatMessageType.GAMEMESSAGE && chatType != ChatMessageType.SPAM
                && chatType != ChatMessageType.MESBOX) {
            return;
        }

        final String message = event.getMessage();
        if (message.contains("You manage to mine")) {
            canAddOre = true;
        }

        if (message.contains("You get")) {
            canAddTree = true;
        }
    }
    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event)
    {
        if (client.getItemContainer(InventoryID.INVENTORY) == event.getItemContainer())
        {
            canAddTile = true;
        }
    }

    @Subscribe
    public void onGameObjectDespawned(GameObjectDespawned event) {
        if (client.getGameState() != GameState.LOGGED_IN) {
            return;
        }

        final GameObject object = event.getGameObject();

        int regionID = object.getWorldLocation().getRegionID();
        Tile tile = event.getTile();

        if (client.getLocalPlayer().getWorldLocation().distanceTo(event.getTile().getWorldLocation()) > 2)
        {
            return;
        }
        if (canAddTile) {
            if (canAddOre) {
                canAddOre = false;
                List<ResourceTile> depletedRockCollection = new ArrayList<>(getDepletedRocksInRegion(regionID));

                ResourceTile resourceTile = new ResourceTile(regionID, tile.getWorldLocation().getRegionX(), tile.getWorldLocation().getRegionY(), tile.getPlane());
                if (!depletedRockCollection.contains(resourceTile)) {
                    depletedRockCollection.add(resourceTile);
                }

                log.debug(resourceTile.toString());
                String json = gson.toJson(depletedRockCollection);
                configManager.setConfiguration(CONFIG_GROUP + ROCK_GROUP, REGION_PREFIX + regionID, json);
                loadRocks();
            }

            if (canAddTree) {
                canAddTree = false;
                List<ResourceTile> depletedTreeCollection = new ArrayList<>(getDepletedTreesInRegion(regionID));

                ResourceTile resourceTile = new ResourceTile(regionID, tile.getWorldLocation().getRegionX(), tile.getWorldLocation().getRegionY(), tile.getPlane());

                if (!depletedTreeCollection.contains(resourceTile)) {
                    depletedTreeCollection.add(resourceTile);
                }
                log.debug(tile.toString());
                String json = gson.toJson(depletedTreeCollection);
                configManager.setConfiguration(CONFIG_GROUP + TREE_GROUP, REGION_PREFIX + regionID, json);
                loadTrees();
            }
            canAddTile = false;
        }
    }
    @Subscribe
    public void onGameObjectSpawned(GameObjectSpawned event)
    {
        Tile eventTile = event.getTile();
        int region = eventTile.getWorldLocation().getRegionID();
        for (ResourceTile tile : getDepletedRocksInRegion(region))
        {
            WorldPoint point = WorldPoint.fromRegion(tile.regionId, tile.regionX, tile.regionY, tile.z);
            if (eventTile.getWorldLocation().equals(point) && !rockTiles.contains(eventTile))
            {
                rockTiles.add(eventTile);
            }
        }
        for (ResourceTile tile : getDepletedTreesInRegion(region))
        {
            WorldPoint point = WorldPoint.fromRegion(tile.regionId, tile.regionX, tile.regionY, tile.z);
            if (eventTile.getWorldLocation().equals(point) && !treeTiles.contains(eventTile))
            {
                treeTiles.add(eventTile);
            }
        }
    }

    void loadTrees() {
        depletedTrees.clear();

        WorldView wv = client.getTopLevelWorldView();
        if (wv == null) {
            return;
        }

        loadTrees(wv);

        for (WorldEntity we : wv.worldEntities()) {
            loadTrees(we.getWorldView());
        }
    }

    void loadTrees(WorldView wv) {
        depletedTrees.removeAll(wv);

        int[] regions = wv.getMapRegions();
        if (regions == null) {
            return;
        }

        for (int regionId : regions) {
            // load points for region
            log.debug("Loading points for region {}", regionId);
            Collection<ResourceTile> trees = getDepletedTreesInRegion(regionId);
            depletedTrees.putAll(wv, trees);
        }
    }

    void loadRocks() {
        depletedRocks.clear();

        WorldView wv = client.getTopLevelWorldView();
        if (wv == null) {
            return;
        }

        loadRocks(wv);

        for (WorldEntity we : wv.worldEntities()) {
            loadRocks(we.getWorldView());
        }
    }

    void loadRocks(WorldView wv) {
        depletedRocks.removeAll(wv);

        int[] regions = wv.getMapRegions();
        if (regions == null) {
            return;
        }

        for (int regionId : regions) {
            // load points for region
            log.debug("Loading points for region {}", regionId);
            Collection<ResourceTile> rocks = getDepletedRocksInRegion(regionId);
            depletedRocks.putAll(wv, rocks);
        }
    }

    Collection<ResourceTile> getDepletedTreesInRegion(int regionId) {
        String json = configManager.getConfiguration(CONFIG_GROUP + TREE_GROUP, REGION_PREFIX + regionId);
        if (Strings.isNullOrEmpty(json)) {
            return Collections.emptyList();
        }

        return gson.fromJson(json, new TypeToken<List<ResourceTile>>() {
        }.getType());
    }

    Collection<ResourceTile> getDepletedRocksInRegion(int regionId) {
        String json = configManager.getConfiguration(CONFIG_GROUP + ROCK_GROUP, REGION_PREFIX + regionId);
        if (Strings.isNullOrEmpty(json)) {
            return Collections.emptyList();
        }
        return gson.fromJson(json, new TypeToken<List<ResourceTile>>() {
        }.getType());
    }

    @Provides
    ResourcesNoMoreConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(ResourcesNoMoreConfig.class);
    }
}
package com.resources.ResourcesNoMore;


import javax.inject.Inject;
import java.awt.Dimension;
import java.awt.Graphics2D;

import com.google.common.collect.Multimap;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;

import java.awt.*;
import java.util.ArrayList;
import java.util.List;

public class ResourcesNoMoreOverlay extends Overlay
{

    private final Client client;
    private final ResourcesNoMorePlugin plugin;
    private final ResourcesNoMoreConfig config;
    private final ModelOutlineRenderer modelOutlineRenderer;

    @Inject
    ResourcesNoMoreOverlay(Client client, ResourcesNoMorePlugin plugin, ResourcesNoMoreConfig config, ModelOutlineRenderer modelOutlineRenderer) {
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        this.modelOutlineRenderer = modelOutlineRenderer;
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        final int maxDistance = config.maxDistance();
        final Multimap<WorldView, ResourceTile> depletedTrees = plugin.getDepletedTrees();
        final Multimap<WorldView, ResourceTile> depletedRocks = plugin.getDepletedRocks();
        final ArrayList<Tile> treeTiles = plugin.treeTiles;
        final ArrayList<Tile> rockTiles = plugin.rockTiles;
        final Player player = client.getLocalPlayer();
        if (player == null) {
            return null;
        }
        if (config.removeRocks()) {
            for (Tile tile : rockTiles) {
                for(WorldView wV : depletedRocks.keySet())
                {
                    if (wV.contains(tile.getWorldLocation()))
                    {
                        if (player.getWorldLocation().distanceTo(tile.getWorldLocation()) < maxDistance)
                        {
                            renderRocks(graphics, tile);
                        }
                    }
                }
            }
        }
        if (config.removeTrees()) {
            for (Tile tile : treeTiles) {
                for(WorldView wV : depletedTrees.keySet())
                {
                    if (wV.contains(tile.getWorldLocation()))
                    {
                        if (player.getWorldLocation().distanceTo(tile.getWorldLocation()) < maxDistance) {
                            renderTrees(graphics, tile);
                        }
                    }
                }
            }
        }

        return null;
    }

        /*
        Leaving this old abomination in as an example of what you don't do. I was tired and frustrated and settled on a
        working brute force method, but that is not the correct way.
         */
            /*
            for (WorldView worldView : depletedTrees.keySet()) {
                for (final ResourceTile rtile : depletedTrees.get(worldView)) {
                    Scene scene = worldView.getScene();
                    Tile[][][] tiles = scene.getTiles();
                    WorldPoint worldPoint = WorldPoint.fromRegion(rtile.regionId, rtile.regionX, rtile.regionY, rtile.z);
                    int z = worldView.getPlane();

                    if (worldPoint.getPlane() != worldView.getPlane())
                    {
                        continue;
                    }

                    for (int x = 0; x < tiles[z].length; ++x)
                    {
                        for (int y = 0; y < tiles[z][x].length; ++y)
                        {
                            Tile tile = tiles[z][x][y];
                            if (tile == null)
                            {
                                continue;
                            }
                            //for some reason just comparing the world points doesn't actually work? I am at a loss and
                            //now have this abomination:
                            if (worldPoint.getX() == tile.getWorldLocation().getX() && worldPoint.getY() == tile.getWorldLocation().getY() && worldPoint.getPlane() == tile.getPlane())
                            {
                                renderTrees(graphics, tile);
                            }
                        }
                    }
                }
            }
        }

             */

    private void renderRocks ( final Graphics2D graphics, Tile tile)
    {
        GameObject[] gameObjects = tile.getGameObjects();
        if (gameObjects != null) {
            for (GameObject gameObject : gameObjects) {
                if (gameObject != null && gameObject.getSceneMinLocation().equals(tile.getSceneLocation())) {
                    if (!config.removeTiles()) {
                        OverlayUtil.renderTileOverlay(graphics, gameObject, "", config.tileColor());
                    }
                    if (config.outline()) {
                        modelOutlineRenderer.drawOutline(gameObject, 3, config.modelOutlineColor(), 2);
                    }
                }
            }
        }
    }

    private void renderTrees ( final Graphics2D graphics, Tile tile)
    {
        GameObject[] gameObjects = tile.getGameObjects();
        if (gameObjects != null) {
            for (GameObject gameObject : gameObjects) {
                if (gameObject != null && gameObject.getSceneMinLocation().equals(tile.getSceneLocation())) {
                    if (!config.removeTiles()) {
                        OverlayUtil.renderTileOverlay(graphics, gameObject, "", config.tileColor());
                    }
                    if (config.outline()) {
                        modelOutlineRenderer.drawOutline(gameObject, 3, config.modelOutlineColor(), 2);
                    }
                }
            }
        }
    }
}

package com.resources.ResourcesNoMore;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

import java.awt.*;

@ConfigGroup("ResourcesNoMore")
public interface ResourcesNoMoreConfig extends Config
{
	@ConfigItem(
		keyName = "removeRocks",
		name = "Remove Rocks",
		description = "Whether to remove rocks"
	)
	default boolean removeRocks()
	{
		return true;
	}
    @ConfigItem(
            keyName = "removeTree",
            name = "Remove Trees",
            description = "Whether to remove trees"
    )
    default boolean removeTrees()
    {
        return true;
    }
    @ConfigItem(
            keyName = "tileColor",
            name = "Tile Color",
            description = "Color of the bottom tile"
    )
    default Color tileColor()
    {
        return Color.GRAY;
    }

    @ConfigItem(
            keyName = "removeTiles",
            name = "Remove Tile Outline",
            description = "Remove tile outline of depleted objects"
    )
    default boolean removeTiles()
    {
        return false;
    }

    @ConfigItem(
            keyName = "outline",
            name = "Show Object Outline",
            description = "Show outline of depleted objects"
    )
    default boolean outline()
    {
        return true;
    }

    @ConfigItem(
            keyName = "outlineColor",
            name = "Model Outline Color",
            description = "Color around depleted models"
    )
    default Color modelOutlineColor()
    {
        return Color.GRAY;
    }
    @ConfigItem(
            keyName = "maxDistance",
            name = "Max Render Distance",
            description = "Max tiles to render away from the player"
    )
    default int maxDistance()
    {
        return 40;
    }
}

package com.resources.ResourcesNoMore;

import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.Setter;
import lombok.Value;
import net.runelite.api.coords.WorldPoint;


@Value
@EqualsAndHashCode
public class ResourceTile {
    @Getter
    @Setter
    public int regionId;
    @Getter
    @Setter
    public int regionX;
    @Getter
    @Setter
    public int regionY;
    @Getter
    @Setter
    public int z;

    public String toString()
    {
        return regionId + " region, at " + regionX + ", " + regionY + " on plane " + z + ".";
    }

    public ResourceTile(int id, int x, int y, int plane)
    {
        this.regionId = id;
        this.regionX = x;
        this.regionY = y;
        this.z = plane;
    }

}

package com.resources.ResourcesNoMore;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ResourcesNoMorePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(ResourcesNoMorePlugin.class);
		RuneLite.main(args);
	}
}
