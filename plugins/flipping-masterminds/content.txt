package com.flippingmasterminds;

import net.runelite.client.config.ConfigManager;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

public class BuyLimitTracker
{
    private static final long FOUR_HOURS_MS = 4 * 60 * 60 * 1000L;

    private final ConfigManager configManager;
    private final Map<Integer, BuyRecord> records = new HashMap<>();

    public BuyLimitTracker(ConfigManager configManager)
    {
        this.configManager = configManager;
        load();
    }

    /**
     * Record a buy of a specific quantity for an item.
     * Starts a new 4-hour window if the previous one has expired.
     */
    public synchronized void recordBuy(int itemId, int quantity)
    {
        BuyRecord record = records.get(itemId);

        if (record == null || record.isExpired())
        {
            record = new BuyRecord(System.currentTimeMillis(), quantity);
            records.put(itemId, record);
        }
        else
        {
            record.addQuantity(quantity);
        }

        save();
    }

    /**
     * Returns the timestamp (ms) of the first buy in the current 4-hour window.
     * Returns 0 if none exists.
     */
    public synchronized Long getBuyTimestamp(int itemId)
    {
        BuyRecord record = records.get(itemId);
        if (record != null && !record.isExpired())
        {
            return record.getFirstBuyTimestamp();
        }
        return 0L;
    }

    /**
     * Returns total quantity bought in current active window.
     */
    public synchronized int getQuantityBoughtInWindow(int itemId)
    {
        BuyRecord record = records.get(itemId);
        if (record != null && !record.isExpired())
        {
            return record.getQuantityBought();
        }
        return 0;
    }

    /**
     * Returns a map of all non-expired tracked items and their buy data.
     * Automatically removes expired records to prevent memory leaks.
     */
    public synchronized Map<Integer, Map<String, Object>> getAllTracked()
    {
        Map<Integer, Map<String, Object>> trackedData = new HashMap<>();

        // Use an iterator to safely remove elements while looping
        Iterator<Map.Entry<Integer, BuyRecord>> iterator = records.entrySet().iterator();
        boolean removedAny = false;

        while (iterator.hasNext())
        {
            Map.Entry<Integer, BuyRecord> entry = iterator.next();
            BuyRecord record = entry.getValue();

            if (record.isExpired())
            {
                // Remove the expired entry from the map to free memory
                iterator.remove();
                removedAny = true;
            }
            else
            {
                Map<String, Object> itemData = new HashMap<>();
                itemData.put("firstBuyTimestamp", record.getFirstBuyTimestamp());
                itemData.put("quantityBought", record.getQuantityBought());
                trackedData.put(entry.getKey(), itemData);
            }
        }

        if (removedAny)
        {
            save();
        }

        return trackedData;
    }

    /**
     * Load records from config if you want persistence between sessions.
     * For now, this is a no-op placeholder.
     */
    private void load()
    {
        // Placeholder for future persistence logic
    }

    /**
     * Save records to config for persistence.
     * For now, this is a no-op placeholder.
     */
    private void save()
    {
        // Placeholder for future persistence logic
    }

    // =========================
    // Inner BuyRecord Class
    // =========================
    private static class BuyRecord
    {
        private final long firstBuyTimestamp;
        private int quantityBought;

        public BuyRecord(long firstBuyTimestamp, int quantityBought)
        {
            this.firstBuyTimestamp = firstBuyTimestamp;
            this.quantityBought = quantityBought;
        }

        public long getFirstBuyTimestamp()
        {
            return firstBuyTimestamp;
        }

        public int getQuantityBought()
        {
            return quantityBought;
        }

        public void addQuantity(int quantity)
        {
            this.quantityBought += quantity;
        }

        public boolean isExpired()
        {
            return System.currentTimeMillis() - firstBuyTimestamp > FOUR_HOURS_MS;
        }
    }
}
package com.flippingmasterminds;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("flippingmasterminds")
public interface FlippingMastermindsConfig extends Config
{

	@ConfigItem(
			keyName = "apiToken",
			name = "API Token",
			description = "API token for Authorization header (Bearer)"
	)
	default String apiToken()
	{
		return "";
	}
}

package com.flippingmasterminds;

import net.runelite.api.Client;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;

import javax.inject.Inject;
import java.util.*;

public class GrandExchange
{
    private final Client client;
    private final GEDataSender sender;
    private static final String TARGET_URL = "http://api.flippingmasterminds.net/ge"; //"http://127.0.0.1:5000/ge";

    @Inject
    public GrandExchange(Client client, FlippingMastermindsConfig config)
    {
        this.client = client;
        this.sender = new GEDataSender(TARGET_URL, config.apiToken());
    }

    private List<Map<String, Object>> collectOffers()
    {
        List<Map<String, Object>> offers = new ArrayList<>();

        for (int slot = 0; slot < 8; slot++)
        {
            Map<String, Object> data = new HashMap<>();
            GrandExchangeOffer offer = client.getGrandExchangeOffers()[slot];

            data.put("slot", slot);

            if (offer != null && offer.getState() != GrandExchangeOfferState.EMPTY)
            {
                data.put("itemId", offer.getItemId());
                data.put("price", offer.getPrice());
                data.put("totalQuantity", offer.getTotalQuantity());
                data.put("quantitySold", offer.getQuantitySold());
                data.put("state", offer.getState().toString());
            }
            else
            {
                data.put("state", "EMPTY");
                data.put("itemId", -1);
                data.put("quantitySold", 0);
                data.put("totalQuantity", 0);
                data.put("price", 0);
            }

            offers.add(data);
        }

        return offers;
    }

    /**
     * Builds payload with accountHash, playerName, and offers
     */
    private Map<String, Object> buildPayload()
    {
        Map<String, Object> payload = new HashMap<>();

        // If you have account hash & player name from RuneLite, set them here.
        // For now, placeholder values are used.
        payload.put("accountHash", client.getAccountHash()); // requires RuneLite Client API
        payload.put("playerName", client.getLocalPlayer() != null ? client.getLocalPlayer().getName() : "UNKNOWN");
        payload.put("offers", collectOffers());

        return payload;
    }

    public void sendAllOffers()
    {
        Map<String, Object> payload = buildPayload();
        sender.send(payload);
    }

    public void shutdown()
    {
        sender.shutdown();
    }
}

package com.flippingmasterminds;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GrandExchangeOfferChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import okhttp3.*;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStreamReader;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.*;

@Slf4j
@PluginDescriptor(
		name = "Flipping Masterminds",
		description = "Grabs Best/Worst Performing item price changes to analyse the market easily!",
		tags = {"grand exchange", "prices", "flipping", "merching"}
)
public class FlippingMastermindsPlugin extends Plugin
{
	@Inject private Client client;
	@Inject private FlippingMastermindsConfig config;
	@Inject private ClientToolbar clientToolbar;
	@Inject private ConfigManager configManager;
	@Inject private BuyLimitTracker buyLimitTracker;

	private NavigationButton navButton;
	private FlippingMastermindsPanel panel;

	private boolean loggedIn = false;

	@Inject private Gson gson;
	@Inject private OkHttpClient okHttpClient;
	private static final MediaType JSON_MEDIA_TYPE = MediaType.get("application/json; charset=utf-8");
	private static final String TARGET_URL = "http://api.flippingmasterminds.net/ge";

	private long loginTime = 0;
	private static final long LOGIN_IGNORE_WINDOW_MS = 3_000;

	private final ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
	private ScheduledFuture<?> pendingSend = null;
	private final long DEBOUNCE_DELAY_MS = 200;
	private String lastReason = "Slot updated";
	private String lastSentPayload = null;

	private final OfferStateCache[] lastOfferStates = new OfferStateCache[8];

	private ExecutorService executor;
	private Map<Integer, Integer> baselinePrices = new HashMap<>();
	private Map<Integer, Integer> dayPrices = new HashMap<>();
	private Map<Integer, Integer> weekPrices = new HashMap<>();
	private Map<Integer, Integer> monthPrices = new HashMap<>();
	private Map<Integer, Integer> yearPrices = new HashMap<>();
	private Map<Integer, ItemMeta> itemMeta = new HashMap<>();

	private static final String USER_AGENT_HEADER = "Call from FMM Plugin, code owner discord: Lindor.";

	@Override
	protected void startUp()
	{
		log.info("Flipping Masterminds plugin started");

		panel = new FlippingMastermindsPanel();
		BufferedImage icon = null;
		try
		{
			icon = ImageUtil.loadImageResource(getClass(), "/mastermind_logo.png");
		}
		catch (Exception e)
		{
			log.warn("Could not load mastermind_logo.png, using null icon");
		}

		navButton = NavigationButton.builder()
				.tooltip("Flipping Masterminds")
				.icon(icon)
				.priority(5)
				.panel(panel)
				.build();

		clientToolbar.addNavigation(navButton);
		loggedIn = false;

		executor = Executors.newSingleThreadExecutor();
		executor.submit(this::fetchAllData);
	}

	@Override
	protected void shutDown()
	{
		log.info("Flipping Masterminds plugin stopped");
		loggedIn = false;

		if (navButton != null)
		{
			clientToolbar.removeNavigation(navButton);
		}

		// UPDATED: Correctly dispose of the panel to stop the imageLoader thread
		if (panel != null)
		{
			panel.dispose();
		}

		if (executor != null)
		{
			executor.shutdownNow();
		}
		if (pendingSend != null && !pendingSend.isDone())
		{
			pendingSend.cancel(false);
		}
		scheduler.shutdown();
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		if (event.getGameState() == GameState.LOGGED_IN)
		{
			loggedIn = true;
			loginTime = System.currentTimeMillis();
			log.info("Account logged in – Flipping Masterminds GE scanning enabled (cooldown started)");
		}
		else if (event.getGameState() == GameState.LOGIN_SCREEN || event.getGameState() == GameState.HOPPING)
		{
			loggedIn = false;
			log.info("Account logged out – Flipping Masterminds GE scanning disabled");
		}
	}

	@Subscribe
	public void onGrandExchangeOfferChanged(GrandExchangeOfferChanged event)
	{
		if (!loggedIn || config.apiToken().isEmpty())
		{
			return;
		}

		long now = System.currentTimeMillis();
		if (now - loginTime < LOGIN_IGNORE_WINDOW_MS)
		{
			log.debug("Ignoring GE event during login cooldown");
			return;
		}

		GrandExchangeOffer offer = event.getOffer();
		int slot = event.getSlot();

		if (offer.getState() == GrandExchangeOfferState.BUYING || offer.getState() == GrandExchangeOfferState.BOUGHT)
		{
			OfferStateCache oldState = lastOfferStates[slot];
			int newQuantitySold = offer.getQuantitySold();
			int quantityDelta = 0;

			if (oldState != null && oldState.itemId == offer.getItemId())
			{
				if (newQuantitySold > oldState.quantitySold)
				{
					quantityDelta = newQuantitySold - oldState.quantitySold;
				}
			}
			else
			{
				quantityDelta = newQuantitySold;
			}

			if (quantityDelta > 0)
			{
				buyLimitTracker.recordBuy(offer.getItemId(), quantityDelta);
			}
		}

		if (offer.getState() != GrandExchangeOfferState.EMPTY) {
			lastOfferStates[slot] = new OfferStateCache(offer.getItemId(), offer.getQuantitySold());
		} else {
			lastOfferStates[slot] = null;
		}

		lastReason = "Slot updated: " + event.getSlot();
		if (pendingSend != null && !pendingSend.isDone())
		{
			pendingSend.cancel(false);
		}
		pendingSend = scheduler.schedule(() -> sendOffersIfChanged(lastReason), DEBOUNCE_DELAY_MS, TimeUnit.MILLISECONDS);
	}

	private void sendOffersIfChanged(String reason)
	{
		if (client == null || client.getGrandExchangeOffers() == null || client.getLocalPlayer() == null)
		{
			log.info("Client not ready yet.");
			return;
		}

		GrandExchangeOffer[] offers = client.getGrandExchangeOffers();
		List<Map<String, Object>> offerList = new ArrayList<>();

		for (int i = 0; i < offers.length; i++)
		{
			GrandExchangeOffer offer = offers[i];
			Map<String, Object> slotData = new HashMap<>();
			slotData.put("slot", i);

			if (offer == null || offer.getState() == GrandExchangeOfferState.EMPTY)
			{
				slotData.put("state", "EMPTY");
			}
			else
			{
				slotData.put("state", offer.getState().toString());
				slotData.put("itemId", offer.getItemId());
				slotData.put("quantitySold", offer.getQuantitySold());
				slotData.put("totalQuantity", offer.getTotalQuantity());
				slotData.put("price", offer.getPrice());
			}

			offerList.add(slotData);
		}

		List<Map<String, Object>> buyLimitList = new ArrayList<>();
		Map<Integer, Map<String, Object>> tracked = buyLimitTracker.getAllTracked();

		for (Map.Entry<Integer, Map<String, Object>> entry : tracked.entrySet())
		{
			Map<String, Object> record = new HashMap<>();
			record.put("itemId", entry.getKey());
			record.put("quantityBought", entry.getValue().get("quantityBought"));
			record.put("firstBuyTimestamp", entry.getValue().get("firstBuyTimestamp"));
			buyLimitList.add(record);
		}

		String playerName = client.getLocalPlayer().getName();
		long accountHash = client.getAccountHash();

		Map<String, Object> payloadMap = new HashMap<>();
		payloadMap.put("reason", reason);
		payloadMap.put("playerName", playerName);
		payloadMap.put("accountHash", accountHash);
		payloadMap.put("offers", offerList);
		payloadMap.put("buyLimits", buyLimitList);

		String jsonPayload = gson.toJson(payloadMap);

		if (jsonPayload.equals(lastSentPayload))
		{
			return;
		}
		lastSentPayload = jsonPayload;

		RequestBody body = RequestBody.create(JSON_MEDIA_TYPE, jsonPayload);
		Request request = new Request.Builder()
				.url(TARGET_URL)
				.post(body)
				.addHeader("Authorization", "Bearer " + config.apiToken())
				.build();

		okHttpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				log.error("❌ Failed to send GE data", e);
			}

			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				int code = response.code();
				String resp = response.body() != null ? response.body().string() : "";
				response.close();
				log.info("✅ GE data sent for {} | Response {}: {}", playerName, code, resp);
			}
		});
	}

	// =============================
	// Price Fetching Methods (UPDATED to use OkHttpClient)
	// =============================

	private void fetchAllData()
	{
		try
		{
			baselinePrices = fetchLatestPrices("https://prices.runescape.wiki/api/v1/osrs/latest");

			long now = Instant.now().getEpochSecond();
			dayPrices = fetchPrices(makeUrl1h(now, 86400));
			weekPrices = fetchPrices(makeUrl1h(now, 604800));
			monthPrices = fetchPrices(makeUrl24h(now, 2629743));
			yearPrices = fetchPrices(makeUrl24h(now, 31556926));

			itemMeta = fetchItemMeta("https://chisel.weirdgloop.org/gazproj/gazbot/os_dump.json");

			SwingUtilities.invokeLater(() -> panel.updateMovers(
					baselinePrices, dayPrices, weekPrices, monthPrices, yearPrices, itemMeta
			));
		}
		catch (Exception e)
		{
			log.error("❌ Failed to fetch price data", e);
		}
	}

	private String makeUrl1h(long now, long offset)
	{
		long ts = now - offset;
		ts -= ts % 3600;
		return "https://prices.runescape.wiki/api/v1/osrs/1h?timestamp=" + ts;
	}

	private String makeUrl24h(long now, long offset)
	{
		long ts = now - offset;
		ts -= ts % 86400;
		return "https://prices.runescape.wiki/api/v1/osrs/24h?timestamp=" + ts;
	}

	// UPDATED: Uses OkHttpClient instead of HttpURLConnection
	private Map<Integer, Integer> fetchPrices(String urlStr) throws IOException
	{
		Request request = new Request.Builder()
				.url(urlStr)
				.header("User-Agent", USER_AGENT_HEADER)
				.build();

		try (Response response = okHttpClient.newCall(request).execute())
		{
			if (!response.isSuccessful() || response.body() == null)
			{
				throw new IOException("Failed to fetch prices: " + response.code());
			}

			try (InputStreamReader reader = new InputStreamReader(response.body().byteStream()))
			{
				Map<Integer, Integer> map = new HashMap<>();
				var root = gson.fromJson(reader, JsonObject.class);
				var data = root.getAsJsonObject("data");

				for (String key : data.keySet())
				{
					try
					{
						int id = Integer.parseInt(key);
						var obj = data.getAsJsonObject(key);
						if (obj.has("avgHighPrice") && obj.has("avgLowPrice")
								&& !obj.get("avgHighPrice").isJsonNull()
								&& !obj.get("avgLowPrice").isJsonNull())
						{
							int high = obj.get("avgHighPrice").getAsInt();
							int low = obj.get("avgLowPrice").getAsInt();
							int mid = (high + low) / 2;
							map.put(id, mid);
						}
					}
					catch (Exception ignored) {}
				}
				return map;
			}
		}
	}

	// UPDATED: Uses OkHttpClient instead of HttpURLConnection
	private Map<Integer, Integer> fetchLatestPrices(String urlStr) throws IOException
	{
		Request request = new Request.Builder()
				.url(urlStr)
				.header("User-Agent", USER_AGENT_HEADER)
				.build();

		try (Response response = okHttpClient.newCall(request).execute())
		{
			if (!response.isSuccessful() || response.body() == null)
			{
				throw new IOException("Failed to fetch latest prices: " + response.code());
			}

			try (InputStreamReader reader = new InputStreamReader(response.body().byteStream()))
			{
				Map<Integer, Integer> map = new HashMap<>();
				var root = gson.fromJson(reader, JsonObject.class);
				var data = root.getAsJsonObject("data");

				for (String key : data.keySet())
				{
					try
					{
						int id = Integer.parseInt(key);
						var obj = data.getAsJsonObject(key);
						if (obj.has("high") && obj.has("low")
								&& !obj.get("high").isJsonNull()
								&& !obj.get("low").isJsonNull())
						{
							int high = obj.get("high").getAsInt();
							int low = obj.get("low").getAsInt();
							int mid = (high + low) / 2;
							map.put(id, mid);
						}
					}
					catch (Exception ignored) {}
				}
				return map;
			}
		}
	}

	// UPDATED: Uses OkHttpClient instead of HttpURLConnection
	private Map<Integer, ItemMeta> fetchItemMeta(String urlStr) throws IOException
	{
		Request request = new Request.Builder()
				.url(urlStr)
				.header("User-Agent", USER_AGENT_HEADER)
				.build();

		try (Response response = okHttpClient.newCall(request).execute())
		{
			if (!response.isSuccessful() || response.body() == null)
			{
				throw new IOException("Failed to fetch item meta: " + response.code());
			}

			try (InputStreamReader reader = new InputStreamReader(response.body().byteStream()))
			{
				Map<Integer, ItemMeta> map = new HashMap<>();
				var root = gson.fromJson(reader, JsonObject.class);

				for (String key : root.keySet())
				{
					try
					{
						int id = Integer.parseInt(key);
						var obj = root.getAsJsonObject(key);
						String name = obj.has("name") ? obj.get("name").getAsString() : "Item " + id;
						String icon = obj.has("icon") ? obj.get("icon").getAsString() : "";

						String safeIcon = icon.replace(" ", "_")
								.replace("'", "%27")
								.replace("(", "%28")
								.replace(")", "%29");

						String iconUrl = "https://oldschool.runescape.wiki/images/c/c0/" + safeIcon + "?7263b";
						map.put(id, new ItemMeta(id, name, iconUrl));
					}
					catch (Exception ignored) {}
				}
				return map;
			}
		}
	}

	@Provides
	BuyLimitTracker provideBuyLimitTracker(ConfigManager configManager)
	{
		return new BuyLimitTracker(configManager);
	}

	@Provides
	FlippingMastermindsConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(FlippingMastermindsConfig.class);
	}

	private static class OfferStateCache
	{
		int itemId;
		int quantitySold;

		OfferStateCache(int itemId, int quantitySold)
		{
			this.itemId = itemId;
			this.quantitySold = quantitySold;
		}
	}

	public static class ItemMeta
	{
		public final int id;
		public final String name;
		public final String iconUrl;

		public ItemMeta(int id, String name, String iconUrl)
		{
			this.id = id;
			this.name = name;
			this.iconUrl = iconUrl;
		}
	}
}
package com.flippingmasterminds;

import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.LinkBrowser;

import javax.imageio.ImageIO;
import javax.swing.*;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.net.URL;
import java.util.List;
import java.util.*;
import java.util.concurrent.*;

public class FlippingMastermindsPanel extends PluginPanel
{
    private JComboBox<String> timeRangeDropdown;
    private JComboBox<String> performanceDropdown;
    private JTextField minPriceField;
    private JTextField maxPriceField;
    private JButton discordButton;
    private JButton githubButton;
    private JButton wikiosButton;

    private JScrollPane viewportScroll;
    private JPanel paginationPanel;
    private JLabel pageInfoLabel;

    private List<JPanel> resultPages = new ArrayList<>();
    private int currentPage = 0;

    private Map<Integer, Integer> baseline, day, week, month, year;
    private Map<Integer, FlippingMastermindsPlugin.ItemMeta> meta;

    private final ConcurrentMap<Integer, ImageIcon> imageCache = new ConcurrentHashMap<>();
    private final Set<Integer> loadingSet = Collections.newSetFromMap(new ConcurrentHashMap<>());
    private final ExecutorService imageLoader;

    private final ImageIcon placeholderIcon;

    private static final int ITEMS_PER_PAGE = 20;
    private static final int ICON_SIZE = 32;
    private static final int NAME_LIMIT = 20;
    private static final int MAX_PAGES = 10;

    public FlippingMastermindsPanel()
    {
        super();

        imageLoader = Executors.newFixedThreadPool(3, r -> {
            Thread t = new Thread(r, "ge-panel-image-loader");
            t.setDaemon(true);
            return t;
        });

        placeholderIcon = makePlaceholderIcon(ICON_SIZE, ICON_SIZE);

        setLayout(new BorderLayout());
        add(createHeaderPanel(), BorderLayout.NORTH);
        add(createBodyPanel(), BorderLayout.CENTER);
        add(createFooterPanel(), BorderLayout.SOUTH);

        attachFilterListeners();
    }

    private JPanel createHeaderPanel() {
        JPanel headerPanel = new JPanel();
        headerPanel.setLayout(new BoxLayout(headerPanel, BoxLayout.Y_AXIS));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 5));
        buttonPanel.setBorder(BorderFactory.createEmptyBorder(0, 0, 5, 0));

        discordButton = createIconHoverButton("/discord_logo.png", "https://discord.gg/VnsS2PP4Vt", "Join our Discord!");
        githubButton = createIconHoverButton("/github_logo.png", "https://github.com/ca-gray/Flipping-Masterminds", "View on GitHub!");
        wikiosButton = createIconHoverButton("/oswiki_logo.png", "https://prices.runescape.wiki/osrs/", "View Wiki Prices!");

        buttonPanel.add(discordButton);
        buttonPanel.add(githubButton);
        buttonPanel.add(wikiosButton);
        headerPanel.add(buttonPanel);

        JPanel filterPanel = new JPanel();
        filterPanel.setLayout(new GridBagLayout());
        filterPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.anchor = GridBagConstraints.WEST;
        gbc.insets = new Insets(2, 2, 2, 2);
        gbc.gridx = 0; gbc.gridy = 0;

        filterPanel.add(new JLabel("Time Range:"), gbc);
        gbc.gridx++;
        timeRangeDropdown = new JComboBox<>(new String[]{"Day", "Week", "Month", "Year"});
        filterPanel.add(timeRangeDropdown, gbc);

        gbc.gridx = 0; gbc.gridy++;
        filterPanel.add(new JLabel("Performance:"), gbc);
        gbc.gridx++;
        performanceDropdown = new JComboBox<>(new String[]{"Top Performers", "Underperformers"});
        filterPanel.add(performanceDropdown, gbc);

        gbc.gridx = 0; gbc.gridy++;
        filterPanel.add(new JLabel("Min Price:"), gbc);
        gbc.gridx++;
        minPriceField = new JTextField("1", 10);
        filterPanel.add(minPriceField, gbc);

        gbc.gridx = 0; gbc.gridy++;
        filterPanel.add(new JLabel("Max Price:"), gbc);
        gbc.gridx++;
        maxPriceField = new JTextField("2147483647", 10);
        filterPanel.add(maxPriceField, gbc);

        headerPanel.add(filterPanel);
        return headerPanel;
    }

    private JScrollPane createBodyPanel() {
        viewportScroll = new JScrollPane();
        viewportScroll.setBorder(null);
        viewportScroll.setBackground(getBackground());

        JScrollBar verticalScrollBar = viewportScroll.getVerticalScrollBar();
        verticalScrollBar.setPreferredSize(new Dimension(8, 0));
        verticalScrollBar.setUnitIncrement(16);

        return viewportScroll;
    }

    private JPanel createFooterPanel() {
        paginationPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));

        JButton prev = new JButton("<");
        prev.addActionListener(e -> showPage(currentPage - 1));
        paginationPanel.add(prev);

        pageInfoLabel = new JLabel("Page 0 / 0");
        paginationPanel.add(pageInfoLabel);

        JButton next = new JButton(">");
        next.addActionListener(e -> showPage(currentPage + 1));
        paginationPanel.add(next);

        return paginationPanel;
    }

    private void attachFilterListeners() {
        timeRangeDropdown.addActionListener(e -> refreshWithFilters());
        performanceDropdown.addActionListener(e -> refreshWithFilters());
        addDocumentListener(minPriceField, this::refreshWithFilters);
        addDocumentListener(maxPriceField, this::refreshWithFilters);
    }

    public void updateMovers(
            Map<Integer, Integer> baseline,
            Map<Integer, Integer> day,
            Map<Integer, Integer> week,
            Map<Integer, Integer> month,
            Map<Integer, Integer> year,
            Map<Integer, FlippingMastermindsPlugin.ItemMeta> meta)
    {
        this.baseline = baseline;
        this.day = day;
        this.week = week;
        this.month = month;
        this.year = year;
        this.meta = meta;

        rebuildResults();
    }

    private void refreshWithFilters()
    {
        if (baseline != null && meta != null)
        {
            rebuildResults();
        }
    }

    private void rebuildResults()
    {
        String timeRange = safeSelected(timeRangeDropdown, "Day");
        String perf = safeSelected(performanceDropdown, "Top Performers");
        int min = safeParseInt(minPriceField.getText(), 1);
        int max = safeParseInt(maxPriceField.getText(), Integer.MAX_VALUE);

        if (min > max) return;

        Map<Integer, Integer> snapshot;
        switch (timeRange)
        {
            case "Week": snapshot = week; break;
            case "Month": snapshot = month; break;
            case "Year": snapshot = year; break;
            default: snapshot = day;
        }
        if (snapshot == null) snapshot = Collections.emptyMap();

        List<Row> rows = new ArrayList<>();
        for (Map.Entry<Integer, Integer> e : snapshot.entrySet())
        {
            int id = e.getKey();
            int snapPrice = e.getValue();
            int basePrice = baseline.getOrDefault(id, -1);
            if (basePrice <= 0 || snapPrice <= 0) continue;
            if (snapPrice < min || snapPrice > max) continue;

            double changePct = ((double)(basePrice - snapPrice) / snapPrice) * 100.0;
            int changeAbs = basePrice - snapPrice;


            if (perf.equals("Top Performers") && !(changePct > 0.0)) continue;
            if (perf.equals("Underperformers") && !(changePct < 0.0)) continue;

            FlippingMastermindsPlugin.ItemMeta im = meta.get(id);
            if (im == null) continue;

            String displayName = truncateName(im.name);
            rows.add(new Row(id, im.name, displayName, im.iconUrl, changePct, changeAbs));
        }

        rows.sort((a, b) -> perf.equals("Top Performers") ?
                Double.compare(b.changePct, a.changePct) : Double.compare(a.changePct, b.changePct));

        List<JPanel> pages = new ArrayList<>();
        for (int i = 0; i < rows.size(); i += ITEMS_PER_PAGE)
        {
            if (pages.size() >= MAX_PAGES) break;

            JPanel page = new JPanel();
            page.setLayout(new GridLayout(0, 1, 4, 4));
            page.setBackground(getBackground());

            int end = Math.min(i + ITEMS_PER_PAGE, rows.size());
            for (int j = i; j < end; j++)
            {
                Row r = rows.get(j);
                JPanel rowPanel = makeRowPanel(r);
                page.add(rowPanel);
                scheduleImageLoad(r.id, r.iconUrl);
            }
            pages.add(page);
        }

        resultPages = pages;
        showPage(0);
    }

    private JPanel makeRowPanel(Row r)
    {
        JPanel rowPanel = new JPanel(new BorderLayout(8, 4));
        rowPanel.setBackground(new Color(34, 34, 34));
        rowPanel.setBorder(BorderFactory.createEmptyBorder(6, 6, 6, 6));

        JLabel iconLabel = new JLabel();
        iconLabel.setName(String.valueOf(r.id));
        ImageIcon cached = imageCache.get(r.id);
        iconLabel.setIcon(cached != null ? cached : placeholderIcon);
        rowPanel.add(iconLabel, BorderLayout.WEST);

        JPanel textPanel = new JPanel();
        textPanel.setLayout(new BoxLayout(textPanel, BoxLayout.Y_AXIS));
        textPanel.setOpaque(false);

        JLabel nameLabel = new JLabel(r.displayName);
        nameLabel.setForeground(Color.WHITE);
        nameLabel.setToolTipText(r.fullName);
        textPanel.add(nameLabel);

        String absText = (r.changeAbs > 0 ? "+" : "") + formatNumber(r.changeAbs);
        JLabel changeLabel = new JLabel(String.format("%.2f%% (%s)", r.changePct, absText));
        changeLabel.setForeground(r.changeAbs >= 0 ? new Color(0, 192, 0) : new Color(220, 50, 50));
        textPanel.add(changeLabel);

        rowPanel.add(textPanel, BorderLayout.CENTER);

        JButton arrow = new JButton("\uD83C\uDF10");
        arrow.setFocusPainted(false);
        arrow.setContentAreaFilled(false);
        arrow.setBorderPainted(false);
        arrow.setForeground(Color.LIGHT_GRAY);
        arrow.addActionListener(e -> openUrl("https://prices.runescape.wiki/osrs/item/" + r.id));
        rowPanel.add(arrow, BorderLayout.EAST);

        return rowPanel;
    }

    private static String formatNumber(int num)
    {
        double abs = Math.abs(num);
        if (abs >= 1_000_000_000)
            return String.format("%.1fB", num / 1_000_000_000.0);
        if (abs >= 1_000_000)
            return String.format("%.1fM", num / 1_000_000.0);
        if (abs >= 1_000)
            return String.format("%.1fK", num / 1_000.0);
        return String.valueOf(num);
    }

    private JButton createIconHoverButton(String resourcePath, String url, String tooltip)
    {
        JButton button = new JButton();
        try
        {
            URL res = getClass().getResource(resourcePath);
            if (res != null)
            {
                BufferedImage raw = ImageIO.read(res);
                Image scaled = raw.getScaledInstance(24, 24, Image.SCALE_SMOOTH);
                ImageIcon normalIcon = new ImageIcon(scaled);

                button.setIcon(normalIcon);
            }
            else
            {
                button.setText("?");
            }
        }
        catch (IOException e)
        {
            button.setText("?");
        }

        button.setToolTipText(tooltip);
        button.setFocusPainted(false);
        button.setContentAreaFilled(false);
        button.setBorderPainted(false);
        button.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));

        button.addActionListener(ev -> openUrl(url));
        return button;
    }

    private void scheduleImageLoad(int id, String rawIconUrl)
    {
        if (imageCache.containsKey(id) || loadingSet.contains(id)) return;
        if (rawIconUrl == null || rawIconUrl.isEmpty()) return;

        loadingSet.add(id);
        imageLoader.submit(() -> {
            try
            {
                String url = rawIconUrl.startsWith("http") ? rawIconUrl : sanitizeIconUrl(rawIconUrl);
                BufferedImage img = ImageIO.read(new URL(url));
                if (img != null)
                {
                    Image scaled = img.getScaledInstance(ICON_SIZE, ICON_SIZE, Image.SCALE_SMOOTH);
                    imageCache.put(id, new ImageIcon(scaled));
                }
            }
            catch (Exception ignored) { }
            finally { loadingSet.remove(id); }

            SwingUtilities.invokeLater(this::refreshVisibleIcons);
        });
    }

    private void refreshVisibleIcons()
    {
        if (resultPages.isEmpty() || currentPage < 0 || currentPage >= resultPages.size()) return;

        Component view = viewportScroll.getViewport().getView();
        if (view instanceof JPanel)
        {
            JPanel wrapper = (JPanel) view;
            if (wrapper.getComponentCount() > 0 && wrapper.getComponent(0) instanceof JPanel)
            {
                JPanel page = (JPanel) wrapper.getComponent(0);
                for (Component c : page.getComponents())
                {
                    if (c instanceof JPanel)
                    {
                        for (Component child : ((JPanel) c).getComponents())
                        {
                            if (child instanceof JLabel && ((JLabel) child).getName() != null)
                            {
                                JLabel lbl = (JLabel) child;
                                try
                                {
                                    int id = Integer.parseInt(lbl.getName());
                                    ImageIcon icon = imageCache.get(id);
                                    if (icon != null) lbl.setIcon(icon);
                                }
                                catch (NumberFormatException ignored) {}
                            }
                        }
                    }
                }
            }
        }
    }

    private void showPage(int pageIndex)
    {
        final int totalPages = resultPages.size();

        if (totalPages == 0)
        {
            JPanel noResultsPanel = new JPanel(new GridBagLayout());
            noResultsPanel.add(new JLabel("No results found."));
            viewportScroll.setViewportView(noResultsPanel);
            currentPage = 0;
            pageInfoLabel.setText("Page 0 / 0");
        }
        else
        {
            if (pageIndex < 0) {
                currentPage = totalPages - 1;
            } else if (pageIndex >= totalPages) {
                currentPage = 0;
            } else {
                currentPage = pageIndex;
            }

            JPanel contentWrapper = new JPanel(new BorderLayout());
            contentWrapper.setBackground(getBackground());
            contentWrapper.add(resultPages.get(currentPage), BorderLayout.NORTH);
            viewportScroll.setViewportView(contentWrapper);

            pageInfoLabel.setText("Page " + (currentPage + 1) + " / " + totalPages);
        }

        paginationPanel.revalidate();
        paginationPanel.repaint();

        viewportScroll.revalidate();
        viewportScroll.repaint();

        if (totalPages > 0)
        {
            SwingUtilities.invokeLater(() -> viewportScroll.getVerticalScrollBar().setValue(0));
            refreshVisibleIcons();
        }
    }

    // UPDATED: Use LinkBrowser instead of Desktop.getDesktop()
    private void openUrl(String url)
    {
        LinkBrowser.browse(url);
    }

    private static int safeParseInt(String s, int fallback)
    {
        try { return Integer.parseInt(s.trim()); }
        catch (Exception e) { return fallback; }
    }

    private static String safeSelected(JComboBox<String> cb, String fallback)
    {
        Object sel = cb.getSelectedItem();
        return sel == null ? fallback : sel.toString();
    }

    private static ImageIcon makePlaceholderIcon(int w, int h)
    {
        BufferedImage img = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g = img.createGraphics();
        g.setColor(new Color(64, 64, 64));
        g.fillRect(0, 0, w, h);
        g.dispose();
        return new ImageIcon(img);
    }

    private static String truncateName(String name)
    {
        if (name == null) return "";
        if (name.length() <= NAME_LIMIT) return name;
        return name.substring(0, NAME_LIMIT) + "...";
    }

    private String sanitizeIconUrl(String raw)
    {
        String iconUrl = raw.replace(" ", "_")
                .replace("'", "%27")
                .replace("(", "%28")
                .replace(")", "%29");
        return "https://oldschool.runescape.wiki/images/c/c0/" + iconUrl + "?7263b";
    }

    private static void addDocumentListener(JTextField field, Runnable onChange)
    {
        field.getDocument().addDocumentListener(new DocumentListener() {
            public void insertUpdate(DocumentEvent e) { onChange.run(); }
            public void removeUpdate(DocumentEvent e) { onChange.run(); }
            public void changedUpdate(DocumentEvent e) { onChange.run(); }
        });
    }

    public void dispose()
    {
        imageLoader.shutdownNow();
    }

    private static class Row
    {
        final int id;
        final String fullName;
        final String displayName;
        final String iconUrl;
        final double changePct;
        final int changeAbs;

        Row(int id, String fullName, String displayName, String iconUrl, double changePct, int changeAbs)
        {
            this.id = id;
            this.fullName = fullName;
            this.displayName = displayName;
            this.iconUrl = iconUrl;
            this.changePct = changePct;
            this.changeAbs = changeAbs;
        }
    }
}
package com.flippingmasterminds;

import com.google.gson.Gson;
import okhttp3.*;
import com.google.gson.Gson;
import okhttp3.OkHttpClient;
import javax.inject.Inject;

import java.io.IOException;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class GEDataSender
{
    private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");
    @Inject private Gson gson;
    @Inject private OkHttpClient okHttpClient;
    private final String serverUrl;
    private final String apiToken;
    private final BlockingQueue<String> queue = new LinkedBlockingQueue<>();
    private volatile boolean running = true;

    public GEDataSender(String serverUrl, String apiToken)
    {
        this.serverUrl = serverUrl;
        this.apiToken = apiToken;

        Thread worker = new Thread(this::processQueue, "GEDataSender-Worker");
        worker.setDaemon(true);
        worker.start();
    }

    public void send(Object payload)
    {
        String json = gson.toJson(payload);
        queue.offer(json);
    }

    private void processQueue()
    {
        while (running)
        {
            try
            {
                String json = queue.take();
                RequestBody body = RequestBody.create(JSON, json);

                Request.Builder builder = new Request.Builder()
                        .url(serverUrl)
                        .post(body);

                if (apiToken != null && !apiToken.isEmpty())
                {
                    // Flask expects "Authorization: Bearer <token>"
                    builder.addHeader("Authorization", "Bearer " + apiToken);
                }

                Request request = builder.build();

                okHttpClient.newCall(request).enqueue(new Callback()
                {
                    @Override
                    public void onFailure(Call call, IOException e)
                    {
                        queue.offer(json); // retry
                    }

                    @Override
                    public void onResponse(Call call, Response response) throws IOException
                    {
                        if (!response.isSuccessful())
                        {
                            queue.offer(json); // retry
                        }
                        response.close();
                    }
                });
            }
            catch (InterruptedException ignored) { }
        }
    }

    public void shutdown() {
        running = false;
        okHttpClient.dispatcher().executorService().shutdown();
        okHttpClient.connectionPool().evictAll();
        if (okHttpClient.cache() != null) {
            try {
                okHttpClient.cache().close();
            } catch (IOException ignored) {}
        }
    }

}

package com.flippingmasterminds;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class FlippingMastermindsPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(FlippingMastermindsPlugin.class);
		RuneLite.main(args);
	}
}
