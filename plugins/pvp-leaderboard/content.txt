package com.pvp.leaderboard.util;

import com.google.gson.JsonObject;
import com.pvp.leaderboard.service.RankInfo;
import java.awt.Color;
import java.util.HashMap;
import java.util.Map;
import java.util.Arrays;

public class RankUtils
{
    private static final Map<String, Color> RANK_COLORS = new HashMap<>();

    public static final String[][] THRESHOLDS = {
        {"Bronze", "3", "0"}, {"Bronze", "2", "170"}, {"Bronze", "1", "240"},
        {"Iron", "3", "310"}, {"Iron", "2", "380"}, {"Iron", "1", "450"},
        {"Steel", "3", "520"}, {"Steel", "2", "590"}, {"Steel", "1", "660"},
        {"Black", "3", "730"}, {"Black", "2", "800"}, {"Black", "1", "870"},
        {"Mithril", "3", "940"}, {"Mithril", "2", "1010"}, {"Mithril", "1", "1080"},
        {"Adamant", "3", "1150"}, {"Adamant", "2", "1250"}, {"Adamant", "1", "1350"},
        {"Rune", "3", "1450"}, {"Rune", "2", "1550"}, {"Rune", "1", "1650"},
        {"Dragon", "3", "1750"}, {"Dragon", "2", "1850"}, {"Dragon", "1", "1950"},
        {"3rd Age", "0", "2100"}
    };

    static
    {
        RANK_COLORS.put("Bronze", new Color(184, 115, 51));
        RANK_COLORS.put("Iron", new Color(192, 192, 192));
        RANK_COLORS.put("Steel", new Color(154, 162, 166));
        RANK_COLORS.put("Black", Color.GRAY);
        RANK_COLORS.put("Mithril", new Color(59, 167, 214));
        RANK_COLORS.put("Adamant", new Color(26, 139, 111));
        RANK_COLORS.put("Rune", new Color(78, 159, 227));
        RANK_COLORS.put("Dragon", new Color(229, 57, 53));
        RANK_COLORS.put("3rd", new Color(229, 193, 0));
    }

    public static Color getRankColor(String rankName)
    {
        if (rankName == null) return new Color(102, 102, 102);
        String baseName = rankName.split(" ")[0];
        return RANK_COLORS.getOrDefault(baseName, new Color(102, 102, 102));
    }

    public static Color getRankTextColor(String rankName, boolean colorBlindMode)
    {
        if (colorBlindMode) return Color.WHITE;
        return getRankColor(rankName);
    }

    public static String formatTierLabel(String raw)
    {
        if (raw == null) return null;
        String s = raw.trim();
        if (s.equalsIgnoreCase("3rdAge")) return "3rd Age";
        return s.replaceAll("([A-Za-z]+)(\\d+)$", "$1 $2");
    }

    public static boolean isUnrankedOrDefault(JsonObject obj)
    {
        if (obj == null) return true;
        // Check for 0 MMR
        double mmr = 0.0;
        if (obj.has("mmr") && !obj.get("mmr").isJsonNull())
        {
            mmr = obj.get("mmr").getAsDouble();
        }

        // Check for Bronze 3 rank
        String rank = "";
        int div = 0;
        if (obj.has("rank") && !obj.get("rank").isJsonNull())
        {
            rank = obj.get("rank").getAsString();
        }
        if (obj.has("division") && !obj.get("division").isJsonNull())
        {
            div = obj.get("division").getAsInt();
        }

        // If it looks like default initialization (Bronze 3, 0 MMR), treat as unranked
        if (Math.abs(mmr) < 0.001 && "Bronze".equalsIgnoreCase(rank) && div == 3)
        {
            return true;
        }

        return false;
    }

    public static RankInfo rankLabelAndProgressFromMMR(double mmrVal)
    {
        // Do not arbitrarily treat 0 as null; 0 is a valid MMR (Bronze 3).
        // The caller is responsible for determining if data is missing (e.g. JSON missing "mmr" field).

        String[][] thresholds = THRESHOLDS;

        double v = mmrVal;
        String[] curr = thresholds[0];
        for (String[] t : thresholds)
        {
            if (v >= Double.parseDouble(t[2])) curr = t;
            else break;
        }

        int idx = -1;
        for (int i = 0; i < thresholds.length; i++)
        {
            if (thresholds[i][0].equals(curr[0]) && thresholds[i][1].equals(curr[1]) && thresholds[i][2].equals(curr[2]))
            {
                idx = i;
                break;
            }
        }

        String[] next = idx >= 0 && idx < thresholds.length - 1 ? thresholds[idx + 1] : curr;
        double pct = curr[0].equals("3rd Age") ? 100 :
            Math.max(0, Math.min(100, ((v - Double.parseDouble(curr[2])) / Math.max(1, Double.parseDouble(next[2]) - Double.parseDouble(curr[2]))) * 100));

        return new RankInfo(curr[0], Integer.parseInt(curr[1]), pct);
    }

    public static double calculateTierValue(double mmr)
    {
        // 0 MMR is valid (bottom of Bronze 3). Do not short-circuit.
        String[][] thresholds = THRESHOLDS;

        String[] current = thresholds[0];
        for (String[] threshold : thresholds)
        {
            if (mmr >= Double.parseDouble(threshold[2]))
            {
                current = threshold;
            }
            else
            {
                break;
            }
        }

        // Convert to percentage for graph display
        String[] tiers = {"Bronze", "Iron", "Steel", "Black", "Mithril", "Adamant", "Rune", "Dragon", "3rd Age"};
        for (int i = 0; i < tiers.length; i++)
        {
            if (tiers[i].equals(current[0]))
            {
                return (i * 100.0 / tiers.length) + (Integer.parseInt(current[1]) * 10.0 / tiers.length);
            }
        }
        return 0;
    }

    // Encode MMR to rank-scale value (baseIndex*3 + divisionOffset + progress)
    // Returns 0.0 to 24.0+
    public static double calculateContinuousTierValue(double mmr) {
        final String[] ORDER = {"Bronze","Iron","Steel","Black","Mithril","Adamant","Rune","Dragon","3rd Age"};
        double v = mmr;
        String[] curr = THRESHOLDS[0];
        for (String[] t : THRESHOLDS) { if (v >= Double.parseDouble(t[2])) curr = t; else break; }
        
        int idxCurr = -1;
        for (int i = 0; i < THRESHOLDS.length; i++) {
            if (Arrays.equals(THRESHOLDS[i], curr)) { idxCurr = i; break; }
        }
        
        String[] next = THRESHOLDS[Math.min(idxCurr + 1, THRESHOLDS.length - 1)];
        int baseIdx = 0;
        for (int i = 0; i < ORDER.length; i++) { if (ORDER[i].equals(curr[0])) { baseIdx = i; break; } }
        int div = "3rd Age".equals(curr[0]) ? 0 : Integer.parseInt(curr[1]);
        int divOffset = "3rd Age".equals(curr[0]) ? 0 : (3 - div);
        double tierBase = baseIdx * 3 + divOffset;
        if ("3rd Age".equals(curr[0])) return tierBase;
        double span = Math.max(1.0, Double.parseDouble(next[2]) - Double.parseDouble(curr[2]));
        double prog = Math.max(0.0, Math.min(1.0, (v - Double.parseDouble(curr[2])) / span));
        return tierBase + prog;
    }

    public static double calculateProgressFromMMR(double mmr)
    {
        String[][] thresholds = THRESHOLDS;

        String[] current = thresholds[0];
        for (String[] threshold : thresholds)
        {
            if (mmr >= Double.parseDouble(threshold[2]))
            {
                current = threshold;
            }
            else
            {
                break;
            }
        }

        if ("3rd Age".equals(current[0]))
        {
            return 100.0;
        }

        int currentIndex = -1;
        for (int i = 0; i < thresholds.length; i++)
        {
            if (thresholds[i][0].equals(current[0]) && thresholds[i][1].equals(current[1]))
            {
                currentIndex = i;
                break;
            }
        }

        if (currentIndex >= 0 && currentIndex < thresholds.length - 1)
        {
            double currentThreshold = Double.parseDouble(current[2]);
            double nextThreshold = Double.parseDouble(thresholds[currentIndex + 1][2]);
            double span = nextThreshold - currentThreshold;
            return Math.max(0, Math.min(100, ((mmr - currentThreshold) / span) * 100));
        }

        return 0.0;
    }

    public static int getRankIndex(String rank, int division)
    {
        String[][] thresholds = THRESHOLDS;

        for (int i = 0; i < thresholds.length; i++)
        {
            if (thresholds[i][0].equals(rank) && Integer.parseInt(thresholds[i][1]) == division)
            {
                return i;
            }
        }
        return 0;
    }

    public static int getRankOrder(String rank)
    {
        String[] parts = rank.split(" ");
        String baseName = parts[0];
        int division = parts.length > 1 ? Integer.parseInt(parts[1]) : 0;

        int baseOrder;
        switch (baseName) {
            case "Bronze":
                baseOrder = 0;
                break;
            case "Iron":
                baseOrder = 1;
                break;
            case "Steel":
                baseOrder = 2;
                break;
            case "Black":
                baseOrder = 3;
                break;
            case "Mithril":
                baseOrder = 4;
                break;
            case "Adamant":
                baseOrder = 5;
                break;
            case "Rune":
                baseOrder = 6;
                break;
            case "Dragon":
                baseOrder = 7;
                break;
            case "3rd Age":
                baseOrder = 8;
                break;
            default:
                baseOrder = -1;
                break;
        }

        return baseOrder * 10 + (4 - division);
    }
}

package com.pvp.leaderboard.util;

import java.util.Locale;

public final class NameUtils
{
	private NameUtils() {}

	public static String normalizeDisplayName(String name)
	{
		if (name == null)
		{
			return "";
		}
		return name.trim().replaceAll("\\s+", " ");
	}

	public static String canonicalKey(String name)
	{
		String display = normalizeDisplayName(name);
		// Treat names case-insensitively for lookups, caching and API queries
		return display.toLowerCase(Locale.ROOT);
	}
}

package com.pvp.leaderboard.cache;

import com.google.gson.JsonObject;

public class UserStatsCache
{
    private final JsonObject stats;
    private final long timestamp;

    public UserStatsCache(JsonObject stats, long timestamp)
    {
        this.stats = stats;
        this.timestamp = timestamp;
    }

    public JsonObject getStats()
    {
        return stats;
    }

    public long getTimestamp()
    {
        return timestamp;
    }
}


package com.pvp.leaderboard.cache;

import com.google.gson.JsonObject;

public class ShardEntry
{
    private final JsonObject payload;
    private final long timestamp;

    public ShardEntry(JsonObject payload, long timestamp)
    {
        this.payload = payload;
        this.timestamp = timestamp;
    }

    public JsonObject getPayload()
    {
        return payload;
    }

    public long getTimestamp()
    {
        return timestamp;
    }
}


package com.pvp.leaderboard.cache;

public class WorldRankCache
{
    private final int worldRank;
    private final long timestamp;

    public WorldRankCache(int worldRank, long timestamp)
    {
        this.worldRank = worldRank;
        this.timestamp = timestamp;
    }

    public int getWorldRank()
    {
        return worldRank;
    }

    public long getTimestamp()
    {
        return timestamp;
    }
}


package com.pvp.leaderboard.cache;

import com.google.gson.JsonObject;

public class MatchesCacheEntry
{
    private final JsonObject response;
    private final long timestamp;

    public MatchesCacheEntry(JsonObject response, long timestamp)
    {
        this.response = response;
        this.timestamp = timestamp;
    }

    public JsonObject getResponse()
    {
        return response;
    }

    public long getTimestamp()
    {
        return timestamp;
    }
}


package com.pvp.leaderboard.game;

import com.pvp.leaderboard.config.PvPLeaderboardConfig;
import com.pvp.leaderboard.ui.DashboardPanel;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.SwingUtilities;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.MenuAction;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.client.menus.MenuManager;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.Text;

@Slf4j
@Singleton
public class MenuHandler
{
    private final PvPLeaderboardConfig config;
    private final MenuManager menuManager;
    private final ClientToolbar clientToolbar;

    // Dependencies set after startup via init/update
    private DashboardPanel dashboardPanel;
    private NavigationButton navButton;

    @Inject
    public MenuHandler(PvPLeaderboardConfig config, MenuManager menuManager, ClientToolbar clientToolbar)
    {
        this.config = config;
        this.menuManager = menuManager;
        this.clientToolbar = clientToolbar;
    }

    public void init(DashboardPanel dashboardPanel, NavigationButton navButton)
    {
        this.dashboardPanel = dashboardPanel;
        this.navButton = navButton;
        
        refreshMenuOption();
    }

    public void updateNavButton(NavigationButton navButton)
    {
        this.navButton = navButton;
    }

    public void refreshMenuOption()
    {
        try {
            if (config.enablePvpLookupMenu()) {
                menuManager.addPlayerMenuItem("pvp lookup");
            } else {
                menuManager.removePlayerMenuItem("pvp lookup");
            }
        } catch (Exception ignore) {}
    }

    public void shutdown()
    {
        menuManager.removePlayerMenuItem("pvp lookup");
    }

    public void handleMenuOptionClicked(MenuOptionClicked event)
    {
        try
        {
            if (!config.enablePvpLookupMenu()) {
                return;
            }
            if (event.getMenuAction() != MenuAction.RUNELITE_PLAYER) {
                return;
            }
            if (!"pvp lookup".equals(event.getMenuOption())) {
                return;
            }

            String target = event.getMenuTarget();
            if (target == null) {
                return;
            }

            String cleaned = Text.removeTags(target);
            // Remove trailing (level-xxx)
            cleaned = cleaned.replaceAll("\\s*\\(level-\\d+\\)$", "");
            // Remove any parenthetical annotation like (Skill 1234)
            cleaned = cleaned.replaceAll("\\([^)]*\\)", "");
            String playerName = Text.toJagexName(cleaned).replace('\u00A0',' ').trim().replaceAll("\\s+"," ");

            if (dashboardPanel != null) {
                dashboardPanel.loadMatchHistory(playerName);
            }

            // Open plugin side panel
            if (clientToolbar != null && navButton != null) {
                SwingUtilities.invokeLater(() -> clientToolbar.openPanel(navButton));
            }
        }
        catch (Exception e)
        {
             // log.debug("Uncaught exception in handleMenuOptionClicked", e);
        }
    }
}

package com.pvp.leaderboard.game;

import com.pvp.leaderboard.config.PvPLeaderboardConfig;
import com.pvp.leaderboard.service.ClientIdentityService;
import com.pvp.leaderboard.service.CognitoAuthService;
import com.pvp.leaderboard.service.MatchResult;
import com.pvp.leaderboard.service.MatchResultService;
import com.pvp.leaderboard.service.PvPDataService;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ScheduledExecutorService;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.HitsplatID;
import net.runelite.api.Player;
import net.runelite.api.Varbits;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.HitsplatApplied;

@Slf4j
@Singleton
@SuppressWarnings("deprecation")
public class FightMonitor
{
    private final Client client;
    private final PvPLeaderboardConfig config;
    private final ScheduledExecutorService scheduler;
    private final MatchResultService matchResultService;
    private final PvPDataService pvpDataService;
    private final CognitoAuthService cognitoAuthService;
    private final ClientIdentityService clientIdentityService;

    // Dependencies injected via init
    // private DashboardPanel dashboardPanel; 

    // --- Fight State ---
    private boolean inFight = false;
    private boolean wasInMulti = false;
    private int fightStartSpellbook = -1;
    private String opponent = null;
    private volatile String lastExactOpponentName = null;
    private long fightStartTime = 0;

    // Tracks multiple simultaneous fights (per-opponent)
    private final ConcurrentHashMap<String, FightEntry> activeFights = new ConcurrentHashMap<>();
    
    // Damage accounting
    private final ConcurrentHashMap<String, Long> damageFromOpponent = new ConcurrentHashMap<>();
    private final ConcurrentHashMap<String, Long> damageToOpponent = new ConcurrentHashMap<>();
    
    // Tick counters
    private int suppressFightStartTicks = 0;
    private final ConcurrentHashMap<String, Integer> perOpponentSuppressUntilTicks = new ConcurrentHashMap<>();
    private final ConcurrentHashMap<String, Boolean> shardPresence = new ConcurrentHashMap<>();
    
    private volatile int lastCombatActivityTick = 0;
    private static final int OUT_OF_COMBAT_TICKS = 16;
    private int gcTicksCounter = 0;

    // Finalization state
    // (removed unused fields)

    @Inject
    public FightMonitor(
        Client client,
        PvPLeaderboardConfig config,
        ScheduledExecutorService scheduler,
        MatchResultService matchResultService,
        PvPDataService pvpDataService,
        CognitoAuthService cognitoAuthService,
        ClientIdentityService clientIdentityService)
    {
        this.client = client;
        this.config = config;
        this.scheduler = scheduler;
        this.matchResultService = matchResultService;
        this.pvpDataService = pvpDataService;
        this.cognitoAuthService = cognitoAuthService;
        this.clientIdentityService = clientIdentityService;
    }

    public void resetFightState()
    {
        inFight = false;
        wasInMulti = false;
        fightStartSpellbook = -1;
        opponent = null;
        fightStartTime = 0;
        suppressFightStartTicks = 2;
        activeFights.clear();
        damageFromOpponent.clear();
        damageToOpponent.clear();
        lastCombatActivityTick = 0;
        try { log.debug("[Fight] state reset; suppressTicks={}", suppressFightStartTicks); } catch (Exception ignore) {}
    }

    public void handleGameTick(GameTick tick)
    {
        try
        {
            // Handle fight suppression ticks
            if (suppressFightStartTicks > 0)
            {
                suppressFightStartTicks--;
            }

            // Handle per-opponent suppression ticks
            if (!perOpponentSuppressUntilTicks.isEmpty())
            {
                java.util.List<String> toRemove = new java.util.ArrayList<>();
                perOpponentSuppressUntilTicks.forEach((name, ticks) -> {
                    if (ticks <= 1) {
                        toRemove.add(name);
                    } else {
                        perOpponentSuppressUntilTicks.put(name, ticks - 1);
                    }
                });
                toRemove.forEach(perOpponentSuppressUntilTicks::remove);
            }

            // Handle GC (every 33 ticks approx 20s)
            gcTicksCounter++;
            if (gcTicksCounter >= 33)
            {
                gcTicksCounter = 0;
                long now = System.currentTimeMillis();
                activeFights.entrySet().removeIf(e -> {
                    FightEntry fe = e.getValue();
                    if (fe == null) return true;
                    if (!fe.finalized && now - fe.lastActivityMs > 10_000L) {
                        // log.debug("[Fight] expire inactive vs={} lastActivity={}msAgo", e.getKey(), now - fe.lastActivityMs);
                        return true;
                    }
                    return false;
                });
                inFight = !activeFights.isEmpty();
            }

            // Combat window idle check
            int tickNow = client.getTickCount();
            if (tickNow - lastCombatActivityTick > OUT_OF_COMBAT_TICKS && (!damageFromOpponent.isEmpty() || !damageToOpponent.isEmpty()))
            {
                damageFromOpponent.clear();
                damageToOpponent.clear();
                // log.debug("[Fight] window cleared on tick={} (idle>{} ticks)", tickNow, OUT_OF_COMBAT_TICKS);
            }
        }
        catch (Exception e)
        {
            // log.error("Uncaught exception in FightMonitor.onGameTick", e);
        }
    }

    public void handleHitsplatApplied(HitsplatApplied event)
    {
        try
        {
            if (!(event.getActor() instanceof Player)) return;
            if (client == null || config == null) return;

            Player hitPlayer = (Player) event.getActor();
            Player localPlayer = client.getLocalPlayer();
            if (localPlayer == null) return;

            net.runelite.api.Hitsplat hs = event.getHitsplat();
            if (hs == null) return;

            int hitsplatType = hs.getHitsplatType();
            int amt = hs.getAmount();
            boolean isMine = hs.isMine();
            String hitPlayerName = hitPlayer.getName();
            String localPlayerName = localPlayer.getName();

            // log.debug("[Hitsplat] on='{}' amt={} type={} isMine={} localPlayer='{}'", 
            //     hitPlayerName, amt, hitsplatType, isMine, localPlayerName);

            // Only process relevant damage hitsplat types (matching pvp-performance-tracker approach)
            // For non-zero hits, only process relevant hitsplat types
            if (amt > 0)
            {
                if (!(hitsplatType == HitsplatID.DAMAGE_ME
                    || hitsplatType == HitsplatID.DAMAGE_OTHER
                    || hitsplatType == HitsplatID.POISON
                    || hitsplatType == HitsplatID.VENOM))
                {
                    // log.debug("[Hitsplat] SKIPPED - irrelevant type={}", hitsplatType);
                    return;
                }
            }

            // Determine if this should start/continue a fight (only for direct damage, not poison/venom)
            boolean startFromThisHit = (amt > 0) && 
                (hitsplatType == HitsplatID.DAMAGE_ME || hitsplatType == HitsplatID.DAMAGE_OTHER);

            String opponentName = null;
            boolean startNow = false;

            // Key insight from pvp-performance-tracker:
            // - If hitsplat lands on LOCAL PLAYER -> opponent dealt that damage to us
            // - If hitsplat lands on OPPONENT -> we dealt that damage to them
            // This is more reliable than using isMine() which may not work for all damage types

            if (hitPlayer == localPlayer)
            {
                // Hitsplat on us = opponent dealt damage to us
                opponentName = resolveInboundAttacker(localPlayer);
                // log.debug("[Hitsplat] ON US - resolved attacker='{}' amt={}", opponentName, amt);
                if (opponentName != null)
                {
                    lastExactOpponentName = opponentName;
                    if (startFromThisHit) startNow = true;
                }
            }
            else
            {
                // Hitsplat on another player
                if (hitPlayerName == null) return;

                // Check if this player is someone we're actively fighting or interacting with
                boolean isActiveOpponent = activeFights.containsKey(hitPlayerName);
                Player interacting = (Player) localPlayer.getInteracting();
                boolean isCurrentTarget = interacting != null && interacting == hitPlayer;
                Player theirTarget = (Player) hitPlayer.getInteracting();
                boolean isTargetingUs = theirTarget != null && theirTarget == localPlayer;

                // log.debug("[Hitsplat] ON OTHER '{}': isActiveOpp={} isTarget={} targetsUs={} activeFights={}", 
                //     hitPlayerName, isActiveOpponent, isCurrentTarget, isTargetingUs, activeFights.keySet());

                // If the hit player is our active opponent or current target, we dealt that damage
                if (isActiveOpponent || isCurrentTarget || isTargetingUs)
                {
                    opponentName = hitPlayerName;
                    if (startFromThisHit) startNow = true;
                }
                else
                {
                    // log.debug("[Hitsplat] NOT COUNTED - '{}' not recognized as opponent", hitPlayerName);
                }
            }

            // Handle fight start/continuation - do window reset BEFORE adding damage
            boolean validOpp = (opponentName != null && isPlayerOpponent(opponentName));
            if (startNow && opponentName != null && validOpp)
            {
                int tickNow = client.getTickCount();
                
                // Check for combat window reset FIRST, before adding damage
                if (tickNow - lastCombatActivityTick > OUT_OF_COMBAT_TICKS)
                {
                    activeFights.clear();
                    damageFromOpponent.clear();
                    damageToOpponent.clear();
                    // log.debug("[Fight] combat window reset after {} ticks idle", tickNow - lastCombatActivityTick);
                }
                lastCombatActivityTick = tickNow;

                if (opponentName.equals(localPlayer.getName())) return; // Ignore self
                if (suppressFightStartTicks > 0) return;
                if (perOpponentSuppressUntilTicks.containsKey(opponentName)) return;

                touchFight(opponentName);
                inFight = true;
                if (!inFight) startFight(opponentName);
                if (client.getVarbitValue(Varbits.MULTICOMBAT_AREA) == 1) wasInMulti = true;
            }

            // NOW add the damage to maps AFTER window reset check
            if (opponentName != null && amt > 0)
            {
                if (hitPlayer == localPlayer)
                {
                    // Inbound damage
                    damageFromOpponent.merge(opponentName, (long) amt, Long::sum);
                    // log.debug("[Hitsplat] INBOUND DMG: {} dealt {} to us, total from them={}", 
                    //     opponentName, amt, damageFromOpponent.get(opponentName));
                }
                else
                {
                    // Outbound damage
                    damageToOpponent.merge(opponentName, (long) amt, Long::sum);
                    // log.debug("[Hitsplat] OUTBOUND DMG: we dealt {} to {}, total to them={}", 
                    //     amt, opponentName, damageToOpponent.get(opponentName));
                }
            }
        }
        catch (Exception e)
        {
            // log.debug("Uncaught exception in FightMonitor.onHitsplatApplied", e);
        }
    }

    public void handleActorDeath(ActorDeath event)
    {
        try
        {
            if (!(event.getActor() instanceof Player)) return;
            Player player = (Player) event.getActor();
            Player localPlayer = client.getLocalPlayer();

            if (player == localPlayer)
            {
                // Self death
                String killer = findActualKiller(localPlayer);
                if (killer != null) opponent = killer;

                // Pick killer from damage attribution
                if (killer == null) killer = findKillerByDamage();
                if (killer == null) killer = opponent;
                if (killer == null) killer = mostRecentActiveOpponent();

                if (killer != null) endFightFor(killer, "loss");
                else {
                    activeFights.clear(); inFight = false;
                }
            }
            else
            {
                // Other death
                String name = player.getName();
                if (name != null)
                {
                    boolean isEngagedWithLocal = (player.getInteracting() == localPlayer) || (localPlayer.getInteracting() == player);
                    if (activeFights.containsKey(name) || isEngagedWithLocal)
                    {
                        endFightFor(name, "win");
                    }
                }
            }
        }
        catch (Exception e)
        {
            // log.debug("Uncaught exception in FightMonitor.onActorDeath", e);
        }
    }

    private void startFight(String opponentName)
    {
        inFight = true;
        opponent = opponentName;
        wasInMulti = client.getVarbitValue(Varbits.MULTICOMBAT_AREA) == 1;
        fightStartSpellbook = client.getVarbitValue(Varbits.SPELLBOOK);
        fightStartTime = System.currentTimeMillis() / 1000;
        // log.debug("[Fight] startFight opp='{}' world={} startSpell={} multi={}", opponentName, client.getWorld(), fightStartSpellbook, wasInMulti);
    }

    private void endFightFor(String opponentName, String result)
    {
        FightEntry fe = activeFights.remove(opponentName);
        if (fe != null) fe.finalized = true;
        finalizeFight(opponentName, result, fe);
        inFight = !activeFights.isEmpty();
    }

    private void finalizeFight(String opponentName, String result, FightEntry entry)
    {
        final int currentSpellbook = client.getVarbitValue(Varbits.SPELLBOOK);
        final int world = client.getWorld();
        final long now = System.currentTimeMillis() / 1000;
        final String selfName = getLocalPlayerName();
        final String idTokenSafe = cognitoAuthService.getStoredIdToken();

        final long startTs = (entry != null) ? entry.startTs : fightStartTime;
        final int startSb = (entry != null) ? entry.startSpellbook : fightStartSpellbook;
        final boolean wasMulti = (entry != null) ? entry.wasInMulti : wasInMulti;
        // bucket logic removed as unused

        final String resolvedOpponent = (opponentName != null) ? opponentName : "Unknown";
        final long dmgOut = damageToOpponent.getOrDefault(resolvedOpponent, 0L);

        // Debug: Log full damage state
        // log.debug("[Fight] Finalizing: res={} opp='{}' world={} start={} end={} multi={}", result, resolvedOpponent, world, startTs, now, wasMulti);
        // log.debug("[Fight] damageToOpponent map: {}", damageToOpponent);
        // log.debug("[Fight] damageFromOpponent map: {}", damageFromOpponent);
        // log.debug("[Fight] Using dmgOut={} for opponent='{}'", dmgOut, resolvedOpponent);

        // Async Submission
        java.util.concurrent.CompletableFuture.runAsync(() -> {
            try {
                submitMatchResult(result, now, selfName, resolvedOpponent, world, startTs, startSb, currentSpellbook, wasMulti, idTokenSafe, dmgOut);
            } catch (Exception e) {
                log.debug("[MatchSubmit] EXCEPTION in async submission: {}", e.getMessage(), e);
            }
        }, scheduler);

        // Update UI
        // dashboardPanel.getTierLabelByName(resolvedOpponent, bucket); 

        // Suppression
        if (resolvedOpponent != null && !"Unknown".equals(resolvedOpponent)) {
            perOpponentSuppressUntilTicks.put(resolvedOpponent, 5);
        }
        
        // Reset if main fight
        if (entry == null || (opponent != null && opponent.equals(opponentName))) {
            resetFightState();
        }

        // Schedule API refreshes
        scheduleApiRefreshes(resolvedOpponent);
    }

    private void submitMatchResult(String result, long fightEndTime, String playerId, String opponentId, int world,
                                   long fightStartTs, int fightStartSpellbookLocal, int fightEndSpellbookLocal,
                                   boolean wasInMultiLocal, String idTokenLocal, long damageToOpponentLocal)
    {
        MatchResult match = MatchResult.builder()
                .playerId(playerId)
                .opponentId(opponentId)
                .result(result)
                .world(world)
                .fightStartTs(fightStartTs)
                .fightEndTs(fightEndTime)
                .fightStartSpellbook(getSpellbookName(fightStartSpellbookLocal))
                .fightEndSpellbook(getSpellbookName(fightEndSpellbookLocal))
                .wasInMulti(wasInMultiLocal)
                .idToken(idTokenLocal)
                .damageToOpponent(damageToOpponentLocal)
                .clientUniqueId(clientIdentityService.getClientUniqueId())
                .build();

        log.debug("[MatchSubmit] Submitting: player={} opponent={} result={} world={} startTs={} endTs={} dmgOut={} multi={} hasToken={}",
                playerId, opponentId, result, world, fightStartTs, fightEndTime, damageToOpponentLocal, wasInMultiLocal, (idTokenLocal != null && !idTokenLocal.isEmpty()));

        matchResultService.submitMatchResult(match).thenAccept(success -> {
            if (success) {
                log.debug("[MatchSubmit] SUCCESS: match submitted for player={} vs opponent={} result={}", playerId, opponentId, result);
            } else {
                log.debug("[MatchSubmit] FAILED: match submission failed for player={} vs opponent={} result={}", playerId, opponentId, result);
            }
        });
    }

    private void scheduleApiRefreshes(String opponentName) {
         // Always fetch fresh ranks after a fight so players see rank changes immediately
         // API results persist until shard is refreshed (1 hour)
         log.debug("[PostFight] Scheduling API refresh in 15s for self and opponent={}", opponentName);
         scheduler.schedule(() -> {
             try {
                String bucket = "overall";
                String selfName = getLocalPlayerName();
                log.debug("[PostFight] Executing API refresh: self={} opponent={} bucket={}", selfName, opponentName, bucket);
                
                // Refresh self rank using profile API (more reliable) - with retry
                if (selfName != null) {
                    fetchTierWithRetry(selfName, bucket, 3);
                } else {
                    log.debug("[PostFight] selfName is null, skipping self refresh");
                }
                
                // Refresh opponent rank using profile API - with retry
                if (opponentName != null) {
                    fetchTierWithRetry(opponentName, bucket, 3);
                } else {
                    log.debug("[PostFight] opponentName is null, skipping opponent refresh");
                }
             } catch(Exception e){
                log.debug("[PostFight] API refresh exception: {}", e.getMessage());
             }
         }, 15L, java.util.concurrent.TimeUnit.SECONDS);
    }
    
    private void fetchTierWithRetry(String playerName, String bucket, int retriesLeft) {
        log.debug("[PostFight] fetchTierWithRetry called: player={} bucket={} retriesLeft={}", playerName, bucket, retriesLeft);
        pvpDataService.getTierFromProfile(playerName, bucket).thenAccept(tier -> {
            if (tier != null) {
                log.debug("[PostFight] SUCCESS: tier={} for player={}", tier, playerName);
            } else if (retriesLeft > 0) {
                log.debug("[PostFight] tier is null for player={}, retrying ({} left)", playerName, retriesLeft - 1);
                scheduler.schedule(() -> fetchTierWithRetry(playerName, bucket, retriesLeft - 1), 
                    2L, java.util.concurrent.TimeUnit.SECONDS);
            } else {
                log.debug("[PostFight] FAILED: tier is null for player={}, no retries left", playerName);
            }
        }).exceptionally(ex -> {
            if (retriesLeft > 0) {
                log.debug("[PostFight] Exception for player={}: {}, retrying ({} left)", playerName, ex.getMessage(), retriesLeft - 1);
                scheduler.schedule(() -> fetchTierWithRetry(playerName, bucket, retriesLeft - 1), 
                    2L, java.util.concurrent.TimeUnit.SECONDS);
            } else {
                log.debug("[PostFight] FAILED with exception for player={}: {}, no retries left", playerName, ex.getMessage());
            }
            return null;
        });
    }

    private void touchFight(String opponentName)
    {
        if (opponentName == null || opponentName.isEmpty()) return;
        long ts = System.currentTimeMillis() / 1000;
        int sb = client.getVarbitValue(Varbits.SPELLBOOK);
        boolean multi = client.getVarbitValue(Varbits.MULTICOMBAT_AREA) == 1;
        activeFights.compute(opponentName, (k, v) -> {
            if (v == null) return new FightEntry(ts, sb, multi);
            v.lastActivityMs = System.currentTimeMillis();
            return v;
        });

        if (!shardPresence.containsKey(opponentName))
        {
            String bucket = "overall";
            
            // Single call - getShardRankByName handles everything internally
            pvpDataService.getShardRankByName(opponentName, bucket).thenAccept(shardRank -> {
                if (shardRank != null && shardRank.rank > 0) {
                    shardPresence.put(opponentName, Boolean.TRUE);
                } else {
                    shardPresence.putIfAbsent(opponentName, Boolean.FALSE);
                }
            }).exceptionally(ex -> {
                shardPresence.putIfAbsent(opponentName, Boolean.FALSE);
                return null;
            });
        }
    }
    
    // --- Helpers ---

    private String resolveInboundAttacker(Player localPlayer)
    {
        List<Player> players = client.getPlayers();
        if (players != null) {
            for (Player other : players) {
                if (other != null && other != localPlayer && other.getInteracting() == localPlayer) {
                    return other.getName();
                }
            }
        }
        String recent = mostRecentActiveOpponent();
        if (recent != null) return recent;
        return lastExactOpponentName;
    }

    private String mostRecentActiveOpponent()
    {
        long best = -1L; String bestName = null;
        for (Map.Entry<String, FightEntry> e : activeFights.entrySet())
        {
            if (e.getValue() == null) continue;
            long la = e.getValue().lastActivityMs;
            if (la > best) { best = la; bestName = e.getKey(); }
        }
        return bestName;
    }

    private String findKillerByDamage()
    {
        String killer = null; long bestDmg = -1L;
        for (Map.Entry<String, Long> e : damageFromOpponent.entrySet()) {
            long v = (e.getValue() != null ? e.getValue() : 0L);
            if (v > bestDmg) { bestDmg = v; killer = e.getKey(); }
        }
        return killer;
    }

    private String findActualKiller(Player localPlayer)
    {
        List<Player> players = client.getPlayers();
        if (players == null) return null;
        for (Player player : players) {
            if (player != localPlayer && player.getInteracting() == localPlayer) return player.getName();
        }
        return null;
    }

    private boolean isPlayerOpponent(String name)
    {
        if (name == null || "Unknown".equals(name)) return false;
        List<Player> players = client.getPlayers();
        if (players == null) return false;
        for (Player player : players) {
            String pName = player.getName();
            if (pName != null && pName.equals(name)) return true;
        }
        return false;
    }
    
    private String getLocalPlayerName()
    {
        try { return client != null && client.getLocalPlayer() != null ? client.getLocalPlayer().getName() : null; } catch (Exception ignore) { return null; }
    }

    private String getSpellbookName(int spellbook)
    {
        switch (spellbook) {
            case 0: return "Standard";
            case 1: return "Ancient";
            case 2: return "Lunar";
            case 3: return "Arceuus";
            default: return "Unknown";
        }
    }
    
    private static class FightEntry {
        final long startTs;
        final int startSpellbook;
        final boolean wasInMulti;
        volatile long lastActivityMs;
        volatile boolean finalized = false;
        FightEntry(long ts, int sb, boolean multi) {
            startTs = ts;
            startSpellbook = sb;
            wasInMulti = multi;
            lastActivityMs = System.currentTimeMillis();
        }
    }
}

package com.pvp.leaderboard.config;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("PvPLeaderboard")
public interface PvPLeaderboardConfig extends Config
{

	@ConfigItem(
		keyName = "enablePvpLookupMenu",
		name = "Enable 'pvp lookup' right-click",
		description = "Adds the 'pvp lookup' option to player right-click menu"
	)
	default boolean enablePvpLookupMenu()
	{
		return false; 
	}

}

package com.pvp.leaderboard;

import com.google.inject.Provides;
import com.pvp.leaderboard.config.PvPLeaderboardConfig;
import com.pvp.leaderboard.game.FightMonitor;
import com.pvp.leaderboard.game.MenuHandler;
import com.pvp.leaderboard.service.ClientIdentityService;
import com.pvp.leaderboard.service.CognitoAuthService;
import com.pvp.leaderboard.service.PvPDataService;
import com.pvp.leaderboard.ui.DashboardPanel;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import java.awt.image.BufferedImage;
import net.runelite.client.util.ImageUtil;

@Slf4j
@PluginDescriptor(
	name = "PvP Leaderboard"
)
public class PvPLeaderboardPlugin extends Plugin
{
	private static final BufferedImage PANEL_ICON = ImageUtil.loadImageResource(PvPLeaderboardPlugin.class, "panel-icon.png");

	@Inject
	private Client client;

	@Inject
	private PvPLeaderboardConfig config;

	@Inject
	private ClientToolbar clientToolbar;

    @Inject
    private SpriteManager spriteManager;

    @Inject
    private PvPDataService pvpDataService;

    @Inject
    private CognitoAuthService cognitoAuthService;
    
    @Inject
    private ClientIdentityService clientIdentityService;

    @Inject
    private MenuHandler menuHandler;
    
    @Inject
    private FightMonitor fightMonitor;

	private DashboardPanel dashboardPanel;
	private NavigationButton navButton;

    public String getClientUniqueId()
    {
        return clientIdentityService.getClientUniqueId();
    }
    
    // Accessor for DashboardPanel to get local player name for debug logs
    public String getLocalPlayerName()
    {
        try { return client != null && client.getLocalPlayer() != null ? client.getLocalPlayer().getName() : null; } catch (Exception ignore) { return null; }
    }

	@Override
	protected void startUp() throws Exception
	{
        dashboardPanel = new DashboardPanel(config, this, pvpDataService, cognitoAuthService);
        
        // Initialize identity
        clientIdentityService.loadOrGenerateId();

		navButton = NavigationButton.builder()
			.tooltip("PvP Leaderboard")
			.icon(PANEL_ICON)
			.priority(5)
			.panel(dashboardPanel)
			.build();
		clientToolbar.addNavigation(navButton);
        
        // Init menu handler
        menuHandler.init(dashboardPanel, navButton);
	}

	@Override
	protected void shutDown() throws Exception
	{
		menuHandler.shutdown();
		clientToolbar.removeNavigation(navButton);
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event)
    {
        try
        {
            if (event == null) return;
            if (!"PvPLeaderboard".equals(event.getGroup())) return;
            if ("enablePvpLookupMenu".equals(event.getKey()))
            {
                menuHandler.refreshMenuOption();
            }
        }
        catch (Exception e)
        {
            log.error("Uncaught exception in onConfigChanged", e);
        }
    }

    @Subscribe
    public void onMenuOptionClicked(MenuOptionClicked event)
    {
        menuHandler.handleMenuOptionClicked(event);
    }

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		try
		{
			if (gameStateChanged.getGameState() == GameState.LOGGED_IN)
			{
				// Default lookup to local player and populate panel
				try
				{
					if (client.getLocalPlayer() != null && dashboardPanel != null)
					{
						String self = client.getLocalPlayer().getName();
						if (self != null && !self.trim().isEmpty()) {
							dashboardPanel.loadMatchHistory(self);
						}
					}
				}
				catch (Exception ignore) {}
			}
			else if (gameStateChanged.getGameState() == GameState.LOGIN_SCREEN)
			{
				// Fully clear fight state on logout
				fightMonitor.resetFightState();
			}
		}
		catch (Exception e)
		{
			// log.debug("Uncaught exception in onGameStateChanged", e);
		}
	}

    @Subscribe
    public void onGameTick(GameTick tick)
    {
        try
        {
            // Delegate logic to FightMonitor
            fightMonitor.handleGameTick(tick);
        }
        catch (Exception e)
        {
            // log.error("Uncaught exception in onGameTick", e);
        }
    }

	@Subscribe
	public void onHitsplatApplied(HitsplatApplied hitsplatApplied)
	{
        fightMonitor.handleHitsplatApplied(hitsplatApplied);
	}

	@Subscribe
	public void onActorDeath(ActorDeath actorDeath)
	{
        fightMonitor.handleActorDeath(actorDeath);
	}

	@Provides
	PvPLeaderboardConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(PvPLeaderboardConfig.class);
	}

    public Client getClient()
    {
        return client;
    }
}

package com.pvp.leaderboard.ui;

import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.pvp.leaderboard.PvPLeaderboardPlugin;
import com.pvp.leaderboard.config.PvPLeaderboardConfig;
import com.pvp.leaderboard.service.CognitoAuthService;
import com.pvp.leaderboard.service.PvPDataService;
import com.pvp.leaderboard.service.RankInfo;
import com.pvp.leaderboard.service.ShardRank;
import com.pvp.leaderboard.util.RankUtils;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.LinkBrowser;

import javax.swing.*;
import java.awt.*;

public class DashboardPanel extends PluginPanel
{
    private final PvPLeaderboardConfig config;
    private final PvPLeaderboardPlugin plugin; 
    private final PvPDataService pvpDataService;
    private final CognitoAuthService cognitoAuthService;

    // Sub-panels
    private LoginPanel loginPanel;
    private RankProgressPanel rankProgressPanel;
    private PerformanceStatsPanel performanceStatsPanel;
    private MatchHistoryPanel matchHistoryPanel;
    private AdditionalStatsPanel extraStatsPanel;
    private WinRateChartPanel chartPanel;
    
    // Header elements
    private JLabel playerNameLabel;
    private JButton refreshButton;

    // State
    private String currentMatchesPlayerId = null;
    private JsonArray allMatches = null;
    
    private static final int MATCHES_PAGE_SIZE = 100;
    
    public DashboardPanel(PvPLeaderboardConfig config, PvPLeaderboardPlugin plugin, PvPDataService pvpDataService, CognitoAuthService cognitoAuthService)
    {
        this.config = config;
        this.plugin = plugin;
        this.pvpDataService = pvpDataService;
        this.cognitoAuthService = cognitoAuthService;
        
        setLayout(new BorderLayout());
        setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        
        JScrollPane scrollPane = new JScrollPane(createMainPanel());
        scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
        add(scrollPane, BorderLayout.CENTER);
    }
    
    private JPanel createMainPanel()
    {
        JPanel mainPanel = new JPanel();
        mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));
        
        // 1. Community (kept simple here)
        mainPanel.add(createCommunityBox());
        mainPanel.add(Box.createVerticalStrut(12));

        // 2. Auth / Login
        loginPanel = new LoginPanel(cognitoAuthService, this::loadMatchHistory, this::onLoginStateChanged);
        JPanel authContainer = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
        authContainer.add(loginPanel);
        mainPanel.add(authContainer);
        mainPanel.add(Box.createVerticalStrut(16));

        // 3. Profile Header
        mainPanel.add(createProfileHeader());
        mainPanel.add(Box.createVerticalStrut(24));
        
        // 4. Rank Progress
        rankProgressPanel = new RankProgressPanel();
        mainPanel.add(rankProgressPanel);
        mainPanel.add(Box.createVerticalStrut(24));
        
        // 5. Performance Overview
        performanceStatsPanel = new PerformanceStatsPanel();
        mainPanel.add(performanceStatsPanel);
        mainPanel.add(Box.createVerticalStrut(12));
        
        // 6. Additional Stats (Hidden by default)
        extraStatsPanel = new AdditionalStatsPanel();
        extraStatsPanel.setVisible(false);
        try { if (extraStatsPanel != null) extraStatsPanel.setBucket("overall"); } catch (Exception ignore) {}
        mainPanel.add(extraStatsPanel);
        mainPanel.add(Box.createVerticalStrut(24));
        
        // 7. Win Rate Chart
        chartPanel = new WinRateChartPanel();
        JScrollPane chartScroll = new JScrollPane(chartPanel);
        chartScroll.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
        chartScroll.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_NEVER);
        chartScroll.setPreferredSize(new Dimension(0, 220));
        chartScroll.setBorder(BorderFactory.createTitledBorder("Win Rate History"));
        mainPanel.add(chartScroll);
        mainPanel.add(Box.createVerticalStrut(24));

        // 8. Match History
        matchHistoryPanel = new MatchHistoryPanel();
        mainPanel.add(matchHistoryPanel);
        
        return mainPanel;
    }
    
    // --- UI Creation Helpers ---
    
    private JPanel createCommunityBox()
    {
        JPanel box = new JPanel();
        box.setLayout(new BoxLayout(box, BoxLayout.Y_AXIS));
        box.setBorder(BorderFactory.createTitledBorder("Join the community"));
        box.setMaximumSize(new Dimension(220, 60));
        box.setPreferredSize(new Dimension(220, 60));
        JPanel row = new JPanel(new FlowLayout(FlowLayout.LEFT, 2, 0));
        JButton discordBtn = new JButton("Discord");
        discordBtn.setPreferredSize(new Dimension(90, 25));
        discordBtn.setToolTipText("Join our Discord");
        discordBtn.addActionListener(e -> {
            try { LinkBrowser.browse("https://discord.gg/3Ct5CQmCPr"); } catch (Exception ignore) {}
        });
        row.add(discordBtn);
        JButton websiteBtn = new JButton("Website");
        websiteBtn.setPreferredSize(new Dimension(90, 25));
        websiteBtn.setToolTipText("Open the website");
        websiteBtn.addActionListener(e -> {
            try { LinkBrowser.browse("https://devsecopsautomated.com/index.html"); } catch (Exception ignore) {}
        });
        row.add(websiteBtn);
        box.add(row);
        return box;
    }
    
    private JPanel createProfileHeader()
    {
        JPanel header = new JPanel(new BorderLayout());
        JPanel namePanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
        
        playerNameLabel = new JLabel("Player Name");
        playerNameLabel.setFont(playerNameLabel.getFont().deriveFont(Font.BOLD, 18f));
        namePanel.add(playerNameLabel);
        namePanel.add(Box.createHorizontalStrut(8));
        
        refreshButton = new JButton("Refresh");
        refreshButton.setPreferredSize(new Dimension(80, 25));
        refreshButton.addActionListener(e -> handleRefresh());
        namePanel.add(refreshButton);
        
        header.add(namePanel, BorderLayout.NORTH);
        return header;
    }
    
    // --- Actions ---

    private void handleRefresh() {
        if (currentMatchesPlayerId != null && !currentMatchesPlayerId.isEmpty()) {
            loadMatchHistory(currentMatchesPlayerId);
        } else {
            String self = null;
            if (plugin != null) self = plugin.getLocalPlayerName();
            if (self != null) loadMatchHistory(self);
        }
    }
    
    private void onLoginStateChanged() {
        boolean loggedIn = cognitoAuthService.isLoggedIn();
        extraStatsPanel.setVisible(loggedIn);
        // If we just logged in, reload current view to potentially show more info (or self if nothing loaded)
        if (loggedIn) {
            String search = loginPanel.getPluginSearchText();
            if (search != null && !search.isEmpty()) {
                loadMatchHistory(search);
            } else {
                String self = plugin != null ? plugin.getLocalPlayerName() : null;
                if (self != null) {
                    loginPanel.setPluginSearchText(self);
                    loadMatchHistory(self);
                }
            }
        } else {
             // Logged out
             if (currentMatchesPlayerId != null) loadMatchHistory(currentMatchesPlayerId);
        }
    }

    // --- Data Loading ---
    
    public void loadMatchHistory(String playerId)
    {
        currentMatchesPlayerId = normalizePlayerId(playerId);
        playerNameLabel.setText(playerId); // Update header immediately
        
        // Update the search box (needed for pvp lookup right-click menu)
        if (loginPanel != null) {
            loginPanel.setPluginSearchText(playerId);
        }

        resetUiForNewSearch();

        try {
            String normalizedId = currentMatchesPlayerId;
            loadPlayerStats(normalizedId);

            pvpDataService.getPlayerMatches(normalizedId, null, MATCHES_PAGE_SIZE).thenAccept(jsonResponse -> {
                if (jsonResponse == null) return;
                
                        JsonArray matches = jsonResponse.has("matches") && jsonResponse.get("matches").isJsonArray() ? jsonResponse.getAsJsonArray("matches") : new JsonArray();
                // String nextToken = jsonResponse.has("next_token") && !jsonResponse.get("next_token").isJsonNull() ? jsonResponse.get("next_token").getAsString() : null;

                        SwingUtilities.invokeLater(() -> {
                    updateUiWithMatches(matches);
                });
            });
        } catch (Exception ignore) {}
    }

    private void updateUiWithMatches(JsonArray matches) {
        matchHistoryPanel.setMatches(matches);
        chartPanel.setMatches(matches);
        extraStatsPanel.setMatches(matches);
        performanceStatsPanel.updateBreakdown(matches);
        allMatches = matches;
        
        // Update summary stats
        int wins = 0, losses = 0, ties = 0;
        for (int i = 0; i < matches.size(); i++) {
             JsonObject m = matches.get(i).getAsJsonObject();
             String r = m.has("result") ? m.get("result").getAsString().toLowerCase() : "";
             if ("win".equals(r)) wins++;
             else if ("loss".equals(r)) losses++;
             else if ("tie".equals(r)) ties++;
                }
        performanceStatsPanel.updateStats(wins, losses, ties);
        
        updateBucketBarsFromMatches();
    }

    private void resetUiForNewSearch()
            {
        rankProgressPanel.reset();
        performanceStatsPanel.reset();
        matchHistoryPanel.clear();
                chartPanel.setMatches(new JsonArray());
        extraStatsPanel.setMatches(new JsonArray());
        allMatches = null;
    }
    
    private void loadPlayerStats(String playerId)
    {
        try {
            String clientUniqueId = (plugin != null) ? plugin.getClientUniqueId() : null;
            
            pvpDataService.getUserProfile(playerId, clientUniqueId).thenAccept(stats -> {
                if (stats == null) return;
                SwingUtilities.invokeLater(() -> updateProgressBars(stats));
                        });
        } catch (Exception ignore) {}
    }
    
    private void updateProgressBars(JsonObject stats)
    {
        String playerName = null;
        if (stats.has("player_name")) playerName = stats.get("player_name").getAsString();
        else if (stats.has("player_id")) playerName = stats.get("player_id").getAsString();
        
        if (playerName != null) updatePlayerStats(stats, playerName);
    }
    
    private void updatePlayerStats(JsonObject stats, String playerName)
    {
        SwingWorker<Void, Void> worker = new SwingWorker<Void, Void>()
        {
            @Override
            protected Void doInBackground() throws Exception
            {
                // Overall
                applyBucketStatsFromUser(playerName, "overall", stats);
                
                // Buckets
                JsonObject bucketsObj = stats.has("buckets") ? stats.getAsJsonObject("buckets") : null;
                String[] bucketKeys = {"nh", "veng", "multi", "dmm"};
                for (String bucketKey : bucketKeys) {
                    JsonObject bucketObj = (bucketsObj != null && bucketsObj.has(bucketKey)) ? bucketsObj.getAsJsonObject(bucketKey) : null;
                    applyBucketStatsFromUser(playerName, bucketKey, bucketObj);
                }
                return null;
            }
        };
        worker.execute();
    }
    
    private void applyBucketStatsFromUser(String playerName, String bucketKey, JsonObject bucketObj)
    {
        if (bucketObj == null) {
            rankProgressPanel.updateBucket(bucketKey, "", 0, 0, -1);
            return;
        }
        
        String rankLabel = "";
        int division = 0;
        double pct = 0.0;
        
        if (bucketObj.has("mmr")) {
            RankInfo ri = RankUtils.rankLabelAndProgressFromMMR(bucketObj.get("mmr").getAsDouble());
            if (ri != null) { rankLabel = ri.rank; division = ri.division; pct = ri.progress; }
        }
        if (bucketObj.has("rank_progress")) {
             JsonObject rp = bucketObj.getAsJsonObject("rank_progress");
             if (rp.has("progress_to_next_rank_pct")) pct = rp.get("progress_to_next_rank_pct").getAsDouble();
        }
        if (bucketObj.has("rank")) {
             String r = bucketObj.get("rank").getAsString();
             if (!r.isEmpty()) rankLabel = r; // Simple parse if needed
             // Reuse existing RankUtils parsing if complex, simplified here
        }
        if (bucketObj.has("division")) division = bucketObj.get("division").getAsInt();
        
        final String fRank = rankLabel;
        final int fDiv = division;
        final double fPct = pct;
        
        rankProgressPanel.updateBucket(bucketKey, fRank, fDiv, fPct, -1);
        
        if (!"".equals(fRank)) {
            new SwingWorker<Integer, Void>() {
                @Override protected Integer doInBackground() { return getRankNumberFromLeaderboard(playerName, bucketKey); }
                @Override protected void done() {
                     try {
                         int rank = get();
                         if (rank > 0) rankProgressPanel.updateBucket(bucketKey, fRank, fDiv, fPct, rank);
                    } catch (Exception ignore) {}
                }
            }.execute();
            }
    }
    
    private void updateBucketBarsFromMatches() {
        if (allMatches == null || allMatches.size() == 0) return;
        String playerName = playerNameLabel.getText();
        if ("Player Name".equals(playerName)) return;
        
                String[] buckets = {"overall", "nh", "veng", "multi", "dmm"};
        for (String bucket : buckets)
        {
            JsonArray items = new JsonArray();
            for (int i = 0; i < allMatches.size(); i++)
            {
                JsonObject match = allMatches.get(i).getAsJsonObject();
                String matchBucket = match.has("bucket") ? match.get("bucket").getAsString().toLowerCase() : "";
                if (matchBucket.equals(bucket)) items.add(match);
            }
            
            if (items.size() == 0) continue;
            
            // Find latest match by timestamp
            JsonObject latest = null;
            for (int i = 0; i < items.size(); i++)
            {
                JsonObject item = items.get(i).getAsJsonObject();
                if (latest == null || 
                    (item.has("when") && latest.has("when") && 
                     item.get("when").getAsLong() > latest.get("when").getAsLong()))
                {
                    latest = item;
                }
            }
            
            if (latest != null && latest.has("player_mmr"))
            {
                double mmr = latest.get("player_mmr").getAsDouble();
                RankInfo est = RankUtils.rankLabelAndProgressFromMMR(mmr);
                
                String finalRank = latest.has("player_rank") ? latest.get("player_rank").getAsString() : (est != null ? est.rank : "");
                int finalDiv = latest.has("player_division") ? latest.get("player_division").getAsInt() : (est != null ? est.division : 0);
                double pct = (est != null ? est.progress : 0.0);
                
                // Only fetch rank number for currently selected rank bucket
                String currentBucket = "overall";
                if (bucket.equals(currentBucket))
                {
                SwingWorker<Integer, Void> worker = new SwingWorker<Integer, Void>()
                {
                        @Override protected Integer doInBackground() { return getRankNumberFromLeaderboard(playerName, bucket); }
                        @Override protected void done() {
                            try {
                            int rankNumber = get();
                                rankProgressPanel.updateBucket(bucket, finalRank, finalDiv, pct, rankNumber);
                            } catch (Exception e) {
                                rankProgressPanel.updateBucket(bucket, finalRank, finalDiv, pct, -1);
                        }
                    }
                };
                worker.execute();
                } else {
                    rankProgressPanel.updateBucket(bucket, finalRank, finalDiv, pct, -1);
                }
            }
        }
    }

    // --- Helpers ---
    
    public int getRankNumberFromLeaderboard(String playerName, String bucket)
    {
        try {
            String canonBucket = bucket == null ? "overall" : bucket.toLowerCase();
            // Single path - shard contains world_rank
            ShardRank sr = pvpDataService.getShardRankByName(playerName, canonBucket).get();
            return sr != null && sr.rank > 0 ? sr.rank : -1;
        } catch (Exception ignore) { return -1; }
    }

    private static String normalizePlayerId(String name) {
        return name != null ? name.trim().replaceAll("\\s+", " ").toLowerCase() : null;
    }
}

package com.pvp.leaderboard.ui;

import javax.swing.*;
import java.awt.*;

public class RankProgressPanel extends JPanel
{
    private static final int SIDEBAR_SCROLLBAR_RESERVE_PX = 16;
    private static final int PROGRESS_BAR_WIDTH = 200;
    private static final int PROGRESS_BAR_HEIGHT = 16;

    private final JProgressBar[] progressBars;
    private final JLabel[] progressLabels;
    private final String[] buckets = {"Overall", "NH", "Veng", "Multi", "DMM"};

    public RankProgressPanel()
    {
        progressBars = new JProgressBar[5];
        progressLabels = new JLabel[5];

        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        setBorder(BorderFactory.createTitledBorder("Season 0"));

        initUI();
    }

    private void initUI()
    {
        for (int i = 0; i < buckets.length; i++)
        {
            JPanel bucketPanel = new JPanel(new BorderLayout());
            bucketPanel.setBorder(BorderFactory.createEmptyBorder(0, 6, 0, SIDEBAR_SCROLLBAR_RESERVE_PX));
            bucketPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 40));
            
            progressLabels[i] = new JLabel(buckets[i] + " -  (0.0%) ");
            progressLabels[i].setFont(progressLabels[i].getFont().deriveFont(Font.BOLD));
            bucketPanel.add(progressLabels[i], BorderLayout.NORTH);
            
            progressBars[i] = new JProgressBar(0, 100);
            progressBars[i].setValue(0);
            progressBars[i].setStringPainted(true);
            progressBars[i].setString("0%");
            progressBars[i].setPreferredSize(new Dimension(PROGRESS_BAR_WIDTH, PROGRESS_BAR_HEIGHT));
            progressBars[i].setMinimumSize(new Dimension(PROGRESS_BAR_WIDTH, PROGRESS_BAR_HEIGHT));
            progressBars[i].setMaximumSize(new Dimension(PROGRESS_BAR_WIDTH, PROGRESS_BAR_HEIGHT));
            progressBars[i].setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));
            
            JPanel barRow = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
            barRow.setOpaque(false);
            barRow.add(progressBars[i]);
            bucketPanel.add(barRow, BorderLayout.CENTER);
            
            add(bucketPanel);
            if (i < buckets.length - 1) add(Box.createVerticalStrut(8));
        }
    }

    public void updateBucket(String bucket, String rankLabel, int division, double pct, int rankNumber)
    {
        int idx = getBucketIndex(bucket);
        if (idx >= 0 && idx < progressBars.length)
        {
            SwingUtilities.invokeLater(() -> {
                if (progressLabels[idx] != null)
                {
                    String displayRank = rankLabel + (division > 0 ? " " + division : "");
                    String text = buckets[idx] + " - " + displayRank + " (" + Math.round(pct) + "%)";
                    if (rankNumber > 0)
                    {
                        text += " #" + rankNumber;
                    }
                    progressLabels[idx].setText(text);
                }
                if (progressBars[idx] != null)
                {
                    progressBars[idx].setValue((int) pct);
                    progressBars[idx].setString(Math.round(pct) + "%");
                }
            });
        }
    }
    
    public void reset()
    {
        SwingUtilities.invokeLater(() -> {
            for (int i = 0; i < progressLabels.length; i++)
            {
                if (progressLabels[i] != null)
                {
                    progressLabels[i].setText(buckets[i] + " -  (0.0%)");
                }
                if (progressBars[i] != null)
                {
                    progressBars[i].setValue(0);
                    progressBars[i].setString("0%");
                }
            }
        });
    }

    private int getBucketIndex(String bucket)
    {
        if (bucket == null) return -1;
        String b = bucket.toLowerCase();
        if ("overall".equals(b)) return 0;
        if ("nh".equals(b)) return 1;
        if ("veng".equals(b)) return 2;
        if ("multi".equals(b)) return 3;
        if ("dmm".equals(b)) return 4;
        return -1;
    }
}


package com.pvp.leaderboard.ui;

import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.pvp.leaderboard.util.RankUtils;
import javax.swing.*;
import java.awt.*;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.stream.Collectors;

public class AdditionalStatsPanel extends JPanel {
    private final JLabel highestRankLabel = new JLabel("-");
    private final JLabel highestTimeLabel = new JLabel("-");
    private final JLabel lowestRankLabel = new JLabel("-");
    private final JLabel lowestTimeLabel = new JLabel("-");
    private final JButton overallBtn = new JButton("Overall");
    private final JButton nhBtn = new JButton("NH");
    private final JButton vengBtn = new JButton("Veng");
    private final JButton multiBtn = new JButton("Multi");
    private final JButton dmmBtn = new JButton("DMM");
    private final TierGraphPlotPanel graphPlot = new TierGraphPlotPanel();
    private final TierGraphLabelsPanel graphLabels = new TierGraphLabelsPanel();
    private static final Dimension GRAPH_LABELS_SIZE = new Dimension(80, 240);
    private static final Dimension GRAPH_PLOT_SIZE   = new Dimension(160, 240);

    private final SimpleDateFormat fmt = new SimpleDateFormat("M/d/yyyy, h:mm:ss a");
    private String selectedBucket = "overall";
    private JsonArray matches = new JsonArray();

    public AdditionalStatsPanel() {
        setLayout(new BorderLayout());
        setBorder(BorderFactory.createTitledBorder("Additional Stats"));

        JPanel content = new JPanel(new GridBagLayout());
        GridBagConstraints root = new GridBagConstraints();
        root.gridx = 0;
        root.gridy = 0;
        root.anchor = GridBagConstraints.WEST;
        root.fill = GridBagConstraints.HORIZONTAL;
        root.weightx = 1.0;

        JPanel statsRow = new JPanel(new GridLayout(2, 2, 24, 2));
        statsRow.add(makeStat("Highest Rank Defeated", highestRankLabel, highestTimeLabel));
        statsRow.add(makeStat("Lowest Rank Lost To",   lowestRankLabel,  lowestTimeLabel));
        content.add(statsRow, root);
        root.gridy++;

        // no extra controls here; simplified per request

        // Ensure all chips are visible in narrow sidebar by splitting into multiple short rows
        // and forcing the rows to occupy full available width anchored left.
        JPanel chips = new JPanel(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0; gbc.gridy = 0; gbc.anchor = GridBagConstraints.WEST; gbc.fill = GridBagConstraints.NONE; gbc.weightx = 1.0;
        JPanel row1 = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
        JPanel row2 = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
        JPanel row3 = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
        java.util.List<JButton> allChips = Arrays.asList(overallBtn, nhBtn, vengBtn, multiBtn, dmmBtn);
        for (int i = 0; i < allChips.size(); i++) {
            JButton b = allChips.get(i);
            b.setFocusPainted(false);
            b.setMargin(new Insets(2,10,2,10));
            Dimension chip = new Dimension(64, 24);
            b.setPreferredSize(chip);
            b.setMinimumSize(chip);
            b.setMaximumSize(chip);
            Dimension pd = b.getPreferredSize();
            b.setMinimumSize(pd);
            if (i < 2) { row1.add(b); }
            else if (i < 4) { row2.add(b); }
            else { row3.add(b); }
        }
        row1.setAlignmentX(LEFT_ALIGNMENT);
        row2.setAlignmentX(LEFT_ALIGNMENT);
        row3.setAlignmentX(LEFT_ALIGNMENT);
        // Add rows to a filling GridBag to eliminate centering and ensure full-width rows
        chips.add(row1, gbc);
        gbc.gridy = 1; chips.add(row2, gbc);
        gbc.gridy = 2; chips.add(row3, gbc);
        chips.setAlignmentX(LEFT_ALIGNMENT);
        chips.setMaximumSize(new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE));
        overallBtn.addActionListener(e -> setBucket("overall"));
        nhBtn.addActionListener(e -> setBucket("nh"));
        vengBtn.addActionListener(e -> setBucket("veng"));
        multiBtn.addActionListener(e -> setBucket("multi"));
        dmmBtn.addActionListener(e -> setBucket("dmm"));

        // Place chips block in the root content grid to keep it hard-left
        content.add(chips, root);
        root.gridy++;

        // Fixed-size graph (no scrollbars) to fit narrow sidebar
        graphLabels.setPreferredSize(GRAPH_LABELS_SIZE);
        graphPlot.setPreferredSize(GRAPH_PLOT_SIZE);
        JPanel graphRow = new JPanel(new BorderLayout());
        graphRow.add(graphLabels, BorderLayout.WEST);
        graphRow.add(graphPlot, BorderLayout.CENTER);
        content.add(graphRow, root);
        root.gridy++;

        // Add content to BorderLayout.NORTH so everything is anchored to top-left of panel
        add(content, BorderLayout.NORTH);

        updateChipStyles();
    }

    public void setMatches(JsonArray newMatches) {
        this.matches = (newMatches != null) ? newMatches : new JsonArray();
        updateAdditionalStats();
        rebuildSeries();
        updateGraphSize();
    }

    public void setBucket(String bucket) {
        this.selectedBucket = (bucket == null ? "overall" : bucket.toLowerCase(Locale.ROOT));
        updateChipStyles();
        rebuildSeries();
        updateGraphSize();
    }

    private JPanel makeStat(String title, JLabel value, JLabel time) {
        JPanel p = new JPanel();
        p.setLayout(new BoxLayout(p, BoxLayout.Y_AXIS));
        JLabel t = new JLabel(title);
        t.setFont(t.getFont().deriveFont(Font.BOLD, 16f));
        value.setFont(value.getFont().deriveFont(Font.BOLD, 18f));
        time.setForeground(new Color(230, 200, 80));
        p.add(t);
        p.add(Box.createVerticalStrut(4));
        p.add(value);
        p.add(time);
        return p;
    }

    private void updateChipStyles() {
        Map<String, JButton> map = new HashMap<>();
        map.put("overall", overallBtn);
        map.put("nh", nhBtn);
        map.put("veng", vengBtn);
        map.put("multi", multiBtn);
        map.put("dmm", dmmBtn);
        for (Map.Entry<String, JButton> e : map.entrySet()) {
            boolean active = e.getKey().equals(selectedBucket);
            e.getValue().setEnabled(!active);
            e.getValue().setBackground(active ? Color.DARK_GRAY : UIManager.getColor("Panel.background"));
            e.getValue().setForeground(active ? Color.YELLOW : UIManager.getColor("Label.foreground"));
        }
    }

    private void updateAdditionalStats() {
        String bestRank = null; Long bestTs = null;
        String worstRank = null; Long worstTs = null;

        for (int i = 0; i < matches.size(); i++) {
            JsonObject m = matches.get(i).getAsJsonObject();
            String bucket = asStr(m, "bucket").toLowerCase(Locale.ROOT);
            if (!selectedBucket.equals("overall") && !bucket.equals(selectedBucket)) continue;

            String result = asStr(m, "result").toLowerCase(Locale.ROOT);
            long ts = m.has("when") ? (long) Math.floor(m.get("when").getAsDouble()) : 0;

            String oppRank = rankLabel(asStr(m, "opponent_rank"), asInt(m, "opponent_division"));
            if (oppRank.isEmpty()) continue;

            if ("win".equals(result)) {
                if (bestRank == null || RankUtils.getRankOrder(oppRank) > RankUtils.getRankOrder(bestRank)) {
                    bestRank = oppRank; bestTs = ts;
                }
            } else if ("loss".equals(result)) {
                if (worstRank == null || RankUtils.getRankOrder(oppRank) < RankUtils.getRankOrder(worstRank)) {
                    worstRank = oppRank; worstTs = ts;
                }
            }
        }

        highestRankLabel.setText(bestRank != null ? bestRank : "-");
        highestTimeLabel.setText(bestTs != null ? fmt.format(new Date(bestTs * 1000)) : "-");
        lowestRankLabel.setText(worstRank != null ? worstRank : "-");
        lowestTimeLabel.setText(worstTs != null ? fmt.format(new Date(worstTs * 1000)) : "-");
    }

    private void rebuildSeries() {
        java.util.List<JsonObject> items = new ArrayList<>();
        for (int i = 0; i < matches.size(); i++) items.add(matches.get(i).getAsJsonObject());
        // Sort ascending by time like the site (oldest  newest)
        items = items.stream()
                .filter(m -> selectedBucket.equals("overall") || selectedBucket.equalsIgnoreCase(asStr(m, "bucket")))
                .sorted(Comparator.comparingDouble(m -> m.has("when") ? m.get("when").getAsDouble() : 0))
                .limit(1000)
                .collect(Collectors.toList());

        final String want = selectedBucket;
        final int MAX_MMR_DELTA_PER_MATCH = 250;

        // Build raw rank index values (0..24)
        java.util.List<Double> rawY = new ArrayList<>();
        if ("overall".equals(want)) {
            // Weighted overall: NH 0.55, Veng 0.30, Multi 0.05, DMM 0.10 (sums to 1.0)
            final Map<String, Double> weights = new HashMap<>();
            weights.put("nh", 0.55); weights.put("veng", 0.30); weights.put("multi", 0.05); weights.put("dmm", 0.10);
            final Map<String, Double> last = new HashMap<>();
            last.put("nh", 1000.0); last.put("veng", 1000.0); last.put("multi", 1000.0); last.put("dmm", 1000.0);

            for (JsonObject m : items) {
                String b = asStr(m, "bucket").toLowerCase(Locale.ROOT);
                if (weights.containsKey(b)) {
                    Double prev = last.get(b);
                    double mu = resolveMuFromMatch(m, prev);
                    if (Double.isFinite(mu)) {
                        if (!Double.isFinite(prev) || Math.abs(mu - prev) <= MAX_MMR_DELTA_PER_MATCH) {
                            last.put(b, mu);
                        }
                    }
                }
                double overallMu = 0.0;
                for (Map.Entry<String, Double> e : weights.entrySet()) {
                    double mu = last.getOrDefault(e.getKey(), 1000.0);
                    overallMu += mu * e.getValue();
                }
                rawY.add(RankUtils.calculateContinuousTierValue(overallMu));
            }
        } else {
            Double prevMu = null;
            for (JsonObject m : items) {
                double mu = resolveMuFromMatch(m, prevMu);
                double chosen;
                if (Double.isFinite(mu)) {
                    if (prevMu != null && Double.isFinite(prevMu) && Math.abs(mu - prevMu) > MAX_MMR_DELTA_PER_MATCH) chosen = prevMu; else { chosen = mu; prevMu = mu; }
                } else {
                    chosen = (prevMu != null) ? prevMu : 1000.0;
                }
                rawY.add(RankUtils.calculateContinuousTierValue(chosen));
            }
        }

        // Compute visible range snapped to division-3 boundaries (no extra padding)
        double minY = 24.0, maxYv = 0.0;
        for (Double yv : rawY) { if (yv != null && Double.isFinite(yv)) { minY = Math.min(minY, yv); maxYv = Math.max(maxYv, yv); } }
        if (!Double.isFinite(minY)) { minY = 0.0; }
        if (!Double.isFinite(maxYv)) { maxYv = 24.0; }
        double low = Math.max(0, (int)Math.floor(minY / 3.0) * 3);
        double high = Math.min(24, (int)Math.ceil(maxYv / 3.0) * 3);
        if (high <= low) high = Math.min(24, low + 3); // ensure a span
        graphLabels.setVisibleRange(low, high);
        graphPlot.setVisibleRange(low, high);

        // Normalize to 0..100 within the visible range
        java.util.List<Double> series = new ArrayList<>();
        double span = Math.max(1e-6, high - low);
        for (Double yv : rawY) {
            double y = (yv != null && Double.isFinite(yv)) ? yv : low;
            double norm = Math.max(0.0, Math.min(100.0, ((y - low) / span) * 100.0));
            series.add(norm);
        }
        graphPlot.setSeries(series);
        graphLabels.repaint();
    }

    // Choose the post-match MMR for a row when available; otherwise fall back.
    private static double resolveMuFromMatch(JsonObject m, Double prevMu) {
        try {
            // Prefer explicit post-match fields if present
            if (m.has("player_mmr_after") && !m.get("player_mmr_after").isJsonNull()) {
                return m.get("player_mmr_after").getAsDouble();
            }
            if (m.has("player_new_mmr") && !m.get("player_new_mmr").isJsonNull()) {
                return m.get("player_new_mmr").getAsDouble();
            }
            if (m.has("player_mmr") && !m.get("player_mmr").isJsonNull()) {
                return m.get("player_mmr").getAsDouble();
            }
            // Reconstruct from delta if possible
            if (m.has("rating_change") && m.get("rating_change").isJsonObject()) {
                JsonObject rc = m.getAsJsonObject("rating_change");
                if (rc.has("mmr_delta") && !rc.get("mmr_delta").isJsonNull() && prevMu != null) {
                    double delta = rc.get("mmr_delta").getAsDouble();
                    return prevMu + delta;
                }
            }
        } catch (Exception ignore) {}
        return Double.NaN;
    }

    private void updateGraphSize() {
        // Keep fixed sizes to avoid scrollbars in Additional Stats
        graphLabels.setPreferredSize(GRAPH_LABELS_SIZE);
        graphPlot.setPreferredSize(GRAPH_PLOT_SIZE);
        graphLabels.revalidate();
        graphPlot.revalidate();
        graphLabels.repaint();
        graphPlot.repaint();
    }

    private static String asStr(JsonObject o, String k) {
        return (o.has(k) && !o.get(k).isJsonNull()) ? o.get(k).getAsString() : "";
    }
    private static int asInt(JsonObject o, String k) {
        try { return o.has(k) && !o.get(k).isJsonNull() ? o.get(k).getAsInt() : 0; } catch (Exception e) { return 0; }
    }
    

    private static String rankLabel(String rank, int division) {
        if (rank == null || rank.isEmpty()) return "";
        return division > 0 ? (rank + " " + division) : rank;
    }

    // Fixed-width labels + guides panel
    private static class TierGraphLabelsPanel extends JPanel {
        private double vMin = 0.0, vMax = 24.0;
        void setVisibleRange(double a, double b) { this.vMin = a; this.vMax = b; repaint(); }
        @Override protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            Graphics2D g2 = (Graphics2D) g;
            g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
            int w = getWidth(), h = getHeight();
            int top = 20, bottom = 20; int innerH = Math.max(1, h - top - bottom);
            // draw labels for the visible range only, with tier colors
            int start = (int)Math.floor(vMin);
            int end = (int)Math.ceil(vMax);
            for (int gi = start; gi <= end; gi++) {
                double frac = (gi - vMin) / Math.max(1e-6, (vMax - vMin));
                int y = top + innerH - (int) Math.round(frac * innerH);
                g2.setColor(new Color(120,120,120));
                g2.drawLine(0, y, w, y);
                int base = gi / 3; int off = gi % 3; String baseRank = RankUtils.THRESHOLDS[Math.min(base * 3, RankUtils.THRESHOLDS.length - 1)][0];
                // Only render division 3 labels (off==0) and 3rd Age
                if (off == 0) {
                    String label = baseRank.equals("3rd Age") ? baseRank : baseRank + " 3";
                    g2.setColor(RankUtils.getRankColor(baseRank));
                    g2.drawString(label, 2, y + 5);
                }
            }
        }
    }

    // Plot panel that renders the series and full-width guides
    private static class TierGraphPlotPanel extends JPanel {
        private double vMin = 0.0, vMax = 24.0;
        void setVisibleRange(double a, double b) { this.vMin = a; this.vMax = b; repaint(); }
        private java.util.List<Double> series = new ArrayList<>();
        void setSeries(java.util.List<Double> s) { this.series = (s != null) ? s : new ArrayList<>(); repaint(); }
        @Override protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            Graphics2D g2 = (Graphics2D) g;
            g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
            int w = getWidth(), h = getHeight();
            int left = 0, bottom = 20, top = 20, right = 20;
            int innerW = Math.max(1, w - left - right);
            int innerH = Math.max(1, h - top - bottom);

            g2.setColor(new Color(120,120,120));
            int start = (int)Math.floor(vMin);
            int end = (int)Math.ceil(vMax);
            for (int gi = start; gi <= end; gi++) {
                int off = gi % 3;
                if (off != 0) continue; // only draw division 3 guides
                double frac = (gi - vMin) / Math.max(1e-6, (vMax - vMin)); // 0 bottom .. 1 top
                int y = top + innerH - (int) Math.round(frac * innerH);
                g2.drawLine(left, y, left + innerW, y);
            }

            if (series.size() > 1) {
                g2.setColor(Color.WHITE);
                g2.setStroke(new BasicStroke(2f));
                for (int i = 0; i < series.size() - 1; i++) {
                    int x1 = left + (i * innerW / Math.max(1, series.size() - 1));
                    int x2 = left + ((i + 1) * innerW / Math.max(1, series.size() - 1));
                    int y1 = top + innerH - (int) Math.round((series.get(i) / 100.0) * innerH);
                    int y2 = top + innerH - (int) Math.round((series.get(i + 1) / 100.0) * innerH);
                    g2.drawLine(x1, y1, x2, y2);
                }
            } else {
                g2.setColor(Color.GRAY);
                g2.drawString("No tier data available", w / 2 - 60, h / 2);
            }
        }
    }
}

package com.pvp.leaderboard.ui;

import com.google.gson.JsonArray;
import com.google.gson.JsonObject;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.util.HashMap;
import java.util.Map;

public class PerformanceStatsPanel extends JPanel
{
    private JLabel winPercentLabel;
    
    private DefaultTableModel rankBreakdownModel;
    private JTable rankBreakdownTable;

    public PerformanceStatsPanel()
    {
        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        setBorder(BorderFactory.createTitledBorder("Last 100 Game Performance"));
        
        initUI();
    }

    private void initUI()
    {
        JPanel summaryRow = new JPanel(new FlowLayout(FlowLayout.LEFT, 6, 0));
        winPercentLabel = new JLabel("- % Winrate");
        
        Font baseFont = winPercentLabel.getFont();
        Font small = baseFont.deriveFont(Font.PLAIN, Math.max(10f, baseFont.getSize2D() - 1f));
        winPercentLabel.setFont(small);
        
        summaryRow.add(winPercentLabel);
        add(summaryRow);

        // Rank breakdown table
        add(createRankBreakdownTable());
    }

    private JPanel createRankBreakdownTable()
    {
        String[] columns = {"Rank", "Wins", "Losses"};
        rankBreakdownModel = new DefaultTableModel(columns, 0);
        rankBreakdownTable = new JTable(rankBreakdownModel);
        rankBreakdownTable.setEnabled(false);
        
        // Set all columns to the same width
        int columnWidth = 60;
        for (int i = 0; i < rankBreakdownTable.getColumnCount(); i++) {
            rankBreakdownTable.getColumnModel().getColumn(i).setPreferredWidth(columnWidth);
            rankBreakdownTable.getColumnModel().getColumn(i).setMinWidth(columnWidth);
            rankBreakdownTable.getColumnModel().getColumn(i).setMaxWidth(columnWidth);
        }
        rankBreakdownTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
        
        JScrollPane sp = new JScrollPane(rankBreakdownTable);
        sp.setPreferredSize(new Dimension(0, 150)); // Adjusted height
        
        // Wrap in panel to control sizing better if needed
        JPanel p = new JPanel(new BorderLayout());
        p.add(sp, BorderLayout.CENTER);
        p.setPreferredSize(new Dimension(0, 340)); // Match original preferred size
        return p;
    }

    public void updateStats(int wins, int losses, int ties)
    {
        SwingUtilities.invokeLater(() -> {
            int total = wins + losses + ties;
            double winRate = total > 0 ? (double) wins / total * 100 : 0;
            
            winPercentLabel.setText(String.format("%.1f%% Winrate", winRate));
        });
    }

    public void updateBreakdown(JsonArray matches)
    {
        SwingUtilities.invokeLater(() -> {
            if (rankBreakdownModel == null || matches == null) return;
            rankBreakdownModel.setRowCount(0);
            
            Map<String, int[]> stats = new HashMap<>();
            for (int i = 0; i < matches.size(); i++)
            {
                JsonObject m = matches.get(i).getAsJsonObject();
                String result = m.has("result") ? m.get("result").getAsString().toLowerCase() : "";
                String oppRank = m.has("opponent_rank") ? m.get("opponent_rank").getAsString() : "Unranked";
                
                stats.putIfAbsent(oppRank, new int[]{0, 0});
                if ("win".equals(result)) stats.get(oppRank)[0]++;
                else if ("loss".equals(result)) stats.get(oppRank)[1]++;
            }
            
            for (Map.Entry<String, int[]> e : stats.entrySet())
            {
                rankBreakdownModel.addRow(new Object[]{e.getKey(), e.getValue()[0], e.getValue()[1]});
            }
        });
    }

    public void reset()
    {
        updateStats(0, 0, 0);
        SwingUtilities.invokeLater(() -> {
            if (rankBreakdownModel != null) rankBreakdownModel.setRowCount(0);
        });
    }
}


package com.pvp.leaderboard.ui;

import javax.swing.*;
import java.awt.*;
import java.util.List;
import java.util.ArrayList;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;

public class WinRateChartPanel extends JPanel
{
    private List<Double> winRateHistory = new ArrayList<>();

    public WinRateChartPanel()
    {
        setPreferredSize(new Dimension(1024, 280));
    }

    public void setMatches(JsonArray matches)
    {
        this.winRateHistory = calculateWinRateHistory(matches);
        setPreferredSize(new Dimension(Math.max(240, winRateHistory.size() * 5), 200));
        revalidate();
        repaint();
    }

    private List<Double> calculateWinRateHistory(JsonArray matches)
    {
        List<Double> history = new ArrayList<>();
        if (matches == null || matches.size() == 0) return history;

        // Sort by time ascending
        List<JsonObject> sorted = new ArrayList<>();
        for (int i = 0; i < matches.size(); i++) sorted.add(matches.get(i).getAsJsonObject());
        sorted.sort((a, b) -> {
            double ta = a.has("when") ? a.get("when").getAsDouble() : 0;
            double tb = b.has("when") ? b.get("when").getAsDouble() : 0;
            return Double.compare(ta, tb);
        });

        int wins = 0;
        int total = 0;
        for (JsonObject m : sorted)
        {
            String result = m.has("result") ? m.get("result").getAsString().toLowerCase() : "";
            if ("win".equals(result)) wins++;
            if ("win".equals(result) || "loss".equals(result))
            {
                total++;
                if (total >= 10) // Only show after 10 games to avoid noise
                {
                    history.add((double) wins / total * 100.0);
                }
            }
        }
        return history;
    }

    @Override
    protected void paintComponent(Graphics g)
    {
        super.paintComponent(g);
        Graphics2D g2 = (Graphics2D) g;
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        int width = getWidth() - 40;
        int height = getHeight() - 40;

        if (width <= 0 || height <= 0) return;

        // Draw axes
        g2.setColor(Color.LIGHT_GRAY);
        g2.drawLine(20, height + 20, width + 20, height + 20);
        g2.drawLine(20, 20, 20, height + 20);

        // Draw grid lines and Y-axis labels
        g2.setColor(Color.GRAY);
        for (int i = 0; i <= 10; i++)
        {
            int y = 20 + (i * height / 10);
            g2.drawLine(20, y, width + 20, y);
            g2.setColor(Color.WHITE);
            g2.drawString((100 - i * 10) + "%", 2, y + 5);
            g2.setColor(Color.GRAY);
        }

        // Draw X-axis labels and win rate line
        if (winRateHistory != null && winRateHistory.size() > 1)
        {
            // Draw X-axis labels (match numbers)
            g2.setColor(Color.WHITE);
            int maxTicks = Math.min(8, winRateHistory.size());
            for (int i = 0; i < maxTicks; i++)
            {
                int x = 20 + (i * width / (maxTicks - 1));
                int matchNum = winRateHistory.size() - (i * winRateHistory.size() / (maxTicks - 1));
                g2.drawString("#" + matchNum, x - 10, height + 35);
            }

            // Draw win rate line
            g2.setColor(new Color(255, 215, 0)); // Gold color
            g2.setStroke(new BasicStroke(2));
            for (int i = 0; i < winRateHistory.size() - 1; i++)
            {
                int x1 = 20 + (i * width / (winRateHistory.size() - 1));
                int y1 = height + 20 - (int)(winRateHistory.get(i) * height / 100);
                int x2 = 20 + ((i + 1) * width / (winRateHistory.size() - 1));
                int y2 = height + 20 - (int)(winRateHistory.get(i + 1) * height / 100);
                g2.drawLine(x1, y1, x2, y2);
            }
        }
        else
        {
            g2.setColor(Color.GRAY);
            g2.drawString("No match data available", width / 2 - 60, height / 2);
        }
    }
}

package com.pvp.leaderboard.ui;

import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.pvp.leaderboard.util.RankUtils;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.text.SimpleDateFormat;
import java.util.Date;

public class MatchHistoryPanel extends JPanel
{
    private JTable matchHistoryTable;
    private DefaultTableModel tableModel;

    public MatchHistoryPanel()
    {
        setLayout(new BorderLayout());
        setBorder(BorderFactory.createTitledBorder("Match History"));
        
        createTable();
    }

    private void createTable()
    {
        String[] columns = {"Res", "Opponent", "Type", "Match", "Change", "Time"};
        tableModel = new DefaultTableModel(columns, 0);
        matchHistoryTable = new JTable(tableModel);
        matchHistoryTable.setFillsViewportHeight(true);
        matchHistoryTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
        try {
            matchHistoryTable.getColumnModel().getColumn(0).setPreferredWidth(40);
            matchHistoryTable.getColumnModel().getColumn(1).setPreferredWidth(140);
            matchHistoryTable.getColumnModel().getColumn(2).setPreferredWidth(60);
            matchHistoryTable.getColumnModel().getColumn(3).setPreferredWidth(220);
            matchHistoryTable.getColumnModel().getColumn(4).setPreferredWidth(180);
            matchHistoryTable.getColumnModel().getColumn(5).setPreferredWidth(120);
        } catch (Exception ignore) {}

        JScrollPane scrollPane = new JScrollPane(matchHistoryTable);
        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
        scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
        scrollPane.setPreferredSize(new Dimension(0, 300));
        add(scrollPane, BorderLayout.CENTER);
    }

    public void setMatches(JsonArray matches)
    {
        SwingUtilities.invokeLater(() -> {
            tableModel.setRowCount(0);
            if (matches == null) return;

            for (int i = 0; i < matches.size(); i++)
            {
                JsonObject match = matches.get(i).getAsJsonObject();
                String result = match.has("result") ? match.get("result").getAsString() : "";
                String opponent = match.has("opponent_id") ? match.get("opponent_id").getAsString() : "";
                String matchType = match.has("bucket") ? match.get("bucket").getAsString().toUpperCase() : "Unknown";
                String playerRank = computeRank(match, "player_");
                String opponentRank = computeRank(match, "opponent_");
                String matchDisplay = playerRank + " vs " + opponentRank;
                String change = computeRatingChangePlain(match);
                String time = match.has("when") ? formatTime(match.get("when").getAsLong()) : "";
                
                tableModel.addRow(new Object[]{result, opponent, matchType, matchDisplay, change, time});
            }
        });
    }
    
    public void clear()
    {
        SwingUtilities.invokeLater(() -> tableModel.setRowCount(0));
    }

    private String computeRank(JsonObject match, String prefix)
    {
        if (match.has(prefix + "rank"))
        {
            String rank = match.get(prefix + "rank").getAsString();
            int division = match.has(prefix + "division") ? match.get(prefix + "division").getAsInt() : 0;
            return rank + (division > 0 ? " " + division : "");
        }
        return "Unknown";
    }

    private String computeRatingChangePlain(JsonObject match)
    {
        if (match.has("rating_change"))
        {
            JsonObject ratingChange = match.getAsJsonObject("rating_change");
            
            // Prefer actual MMR delta from backend when present
            if (ratingChange.has("mmr_delta"))
            {
                double mmrDelta = ratingChange.get("mmr_delta").getAsDouble();
                String mmrText = String.format("%+.2f MMR", mmrDelta);
                return mmrText; // Simplified for plain text view, or add more details if space allows
            }
            
            // Fallback to progress calculation logic if needed, or simplified
            // Reuse logic from DashboardPanel if we want exact same output:
            
            double progressChange = ratingChange.has("progress_change") ? ratingChange.get("progress_change").getAsDouble() : 0;
            
            // Re-implement simplified delta calculation or just show percentage
            // The original logic was quite complex to handle wrapping.
            // Let's copy the essential part or reuse RankUtils if possible.
            // RankUtils doesn't have "computeRatingChangeText".
            
            
            String fromRank = ratingChange.has("from_rank") ? ratingChange.get("from_rank").getAsString() : "";
            String toRank = ratingChange.has("to_rank") ? ratingChange.get("to_rank").getAsString() : "";
            int fromDiv = ratingChange.has("from_division") ? ratingChange.get("from_division").getAsInt() : 0;
            int toDiv = ratingChange.has("to_division") ? ratingChange.get("to_division").getAsInt() : 0;
            
            double playerMmr = match.has("player_mmr") ? match.get("player_mmr").getAsDouble() : 0;
            double afterProg = RankUtils.calculateProgressFromMMR(playerMmr);
            double beforeProg = afterProg - progressChange;
            
            String fromKey = fromRank + "|" + fromDiv;
            String toKey = toRank + "|" + toDiv;
            if (!fromKey.equals(toKey) && Math.abs(progressChange) > 0)
            {
                String result = match.has("result") ? match.get("result").getAsString().toLowerCase() : "";
                int signShouldBe = "win".equals(result) ? 1 : ("loss".equals(result) ? -1 : (int)Math.signum(progressChange));
                if (Math.signum(progressChange) != signShouldBe)
                {
                    beforeProg = afterProg + (100 - Math.abs(progressChange)) * signShouldBe;
                }
            }
            
            beforeProg = Math.max(0, Math.min(100, beforeProg));
            
            int fromIdx = RankUtils.getRankIndex(fromRank, fromDiv);
            int toIdx = RankUtils.getRankIndex(toRank, toDiv);
            double rawDelta = (afterProg - beforeProg) + (toIdx - fromIdx) * 100;
            
            String result = match.has("result") ? match.get("result").getAsString().toLowerCase() : "";
            if ("tie".equals(result)) return "0% change";
            return String.format("%+.2f%% change", rawDelta);
        }
        return "-";
    }

    private String formatTime(long timestamp)
    {
        return new SimpleDateFormat("MM/dd/yyyy, HH:mm:ss").format(new Date(timestamp * 1000));
    }
}


package com.pvp.leaderboard.ui;

import com.pvp.leaderboard.service.CognitoAuthService;
import javax.swing.*;
import java.awt.*;
import java.net.URI;
import java.net.URLEncoder;
import java.util.function.Consumer;
import net.runelite.client.util.LinkBrowser;

public class LoginPanel extends JPanel
{
    private static final int MAX_PLUGIN_SEARCHES_PER_MINUTE = 10;
    
    private final CognitoAuthService cognitoAuthService;
    private final Consumer<String> onPluginSearch;
    private final Runnable onLoginStateChanged;

    private JTextField websiteSearchField;
    private JTextField pluginSearchField;
    private JButton pluginSearchBtn;
    private JButton loginButton;
    
    private boolean loginInProgress = false;
    private boolean isLoggedIn = false;
    
    // Rate limiting for plugin search (10 per minute)
    private final java.util.Deque<Long> pluginSearchTimestamps = new java.util.ArrayDeque<>();

    public LoginPanel(CognitoAuthService cognitoAuthService, Consumer<String> onPluginSearch, Runnable onLoginStateChanged)
    {
        this.cognitoAuthService = cognitoAuthService;
        this.onPluginSearch = onPluginSearch;
        this.onLoginStateChanged = onLoginStateChanged;

        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        setBorder(BorderFactory.createTitledBorder("Login to view stats in runelite"));
        setMaximumSize(new Dimension(220, 190));
        setPreferredSize(new Dimension(220, 190));

        initUI();
    }

    private void initUI()
    {
        // Website search
        JLabel websiteLabel = new JLabel("Search user on website:");
        websiteLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
        add(websiteLabel);
        
        JPanel websitePanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 2, 0));
        websitePanel.setAlignmentX(Component.LEFT_ALIGNMENT);
        websiteSearchField = new JTextField();
        websiteSearchField.setPreferredSize(new Dimension(120, 25));
        websiteSearchField.addActionListener(e -> searchUserOnWebsite());
        
        JButton websiteSearchBtn = new JButton("Search");
        websiteSearchBtn.setPreferredSize(new Dimension(70, 25));
        websiteSearchBtn.addActionListener(e -> searchUserOnWebsite());
        
        websitePanel.add(websiteSearchField);
        websitePanel.add(websiteSearchBtn);
        add(websitePanel);
        
        add(Box.createVerticalStrut(5));
        
        // Plugin search
        JLabel pluginLabel = new JLabel("Search user on plugin:");
        pluginLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
        add(pluginLabel);
        
        JPanel pluginPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 2, 0));
        pluginPanel.setAlignmentX(Component.LEFT_ALIGNMENT);
        pluginSearchField = new JTextField();
        pluginSearchField.setPreferredSize(new Dimension(120, 25));
        pluginSearchField.addActionListener(e -> searchUserOnPlugin());
        
        pluginSearchBtn = new JButton("Search");
        pluginSearchBtn.setPreferredSize(new Dimension(70, 25));
        pluginSearchBtn.addActionListener(e -> searchUserOnPlugin());
        
        pluginPanel.add(pluginSearchField);
        pluginPanel.add(pluginSearchBtn);
        add(pluginPanel);
        
        add(Box.createVerticalStrut(5));
        
        loginButton = new JButton("Login to view more stats");
        loginButton.setPreferredSize(new Dimension(210, 25));
        loginButton.setMaximumSize(new Dimension(220, 25));
        loginButton.setAlignmentX(Component.LEFT_ALIGNMENT);
        loginButton.addActionListener(e -> handleLogin());
        add(loginButton);
    }

    private boolean isValidUsername(String username)
    {
        if (username == null) return false;
        String trimmed = username.trim();
        if (trimmed.isEmpty() || trimmed.length() > 12) return false;
        // Allow alphanumeric, spaces, underscores, and hyphens (RuneScape username format)
        return trimmed.matches("^[a-zA-Z0-9 _-]+$");
    }
    
    private String normalizeUsername(String username)
    {
        if (username == null) return null;
        // Normalize: trim, lowercase, collapse multiple spaces to single space
        return username.trim().toLowerCase().replaceAll("\\s+", " ");
    }

    private void searchUserOnWebsite()
    {
        String username = websiteSearchField.getText();
        if (username == null || username.trim().isEmpty())
        {
            try { LinkBrowser.browse("https://devsecopsautomated.com/index.html"); } catch (Exception ignore) {}
            return;
        }
        if (!isValidUsername(username)) return;
        try
        {
            String normalizedUsername = normalizeUsername(username);
            String url = "https://devsecopsautomated.com/profile.html?player=" + normalizedUsername;
            LinkBrowser.browse(url);
        }
        catch (Exception ignore) {}
    }

    private void searchUserOnPlugin()
    {
        String username = pluginSearchField.getText();
        if (username == null || username.trim().isEmpty()) return;
        if (!isValidUsername(username)) return;
        
        // Rate limit: 10 searches per minute
        if (!checkPluginSearchRateLimit())
        {
            // Show rate limit feedback briefly
            if (pluginSearchBtn != null)
            {
                pluginSearchBtn.setText("Wait...");
                Timer timer = new Timer(1000, e -> pluginSearchBtn.setText("Search"));
                timer.setRepeats(false);
                timer.start();
            }
            return;
        }
        
        if (onPluginSearch != null)
        {
            // Immediate visual feedback
            String normalizedUsername = normalizeUsername(username);
            pluginSearchField.setText(normalizedUsername);
            
            // Trigger search
            onPluginSearch.accept(normalizedUsername);
        }
    }
    
    private boolean checkPluginSearchRateLimit()
    {
        long now = System.currentTimeMillis();
        long oneMinuteAgo = now - 60_000;
        
        // Remove timestamps older than 1 minute
        while (!pluginSearchTimestamps.isEmpty() && pluginSearchTimestamps.peekFirst() < oneMinuteAgo)
        {
            pluginSearchTimestamps.pollFirst();
        }
        
        // Check if we've exceeded the limit
        if (pluginSearchTimestamps.size() >= MAX_PLUGIN_SEARCHES_PER_MINUTE)
        {
            return false; // Rate limited
        }
        
        // Record this search
        pluginSearchTimestamps.addLast(now);
        return true;
    }

    private void handleLogin()
    {
        if (loginInProgress) { return; }
        if (isLoggedIn)
        {
            // Logout
            setLoggedIn(false);
            clearTokens();
            if (onLoginStateChanged != null) onLoginStateChanged.run();
            return;
        }
        
        // Use Cognito OAuth flow
        try
        {
            setLoginBusy(true);
            cognitoAuthService.login().thenAccept(success -> {
                if (success && cognitoAuthService.isLoggedIn() && cognitoAuthService.getStoredIdToken() != null)
                {
                    SwingUtilities.invokeLater(() -> {
                        setLoginBusy(false);
                        setLoggedIn(true);
                        if (onLoginStateChanged != null) onLoginStateChanged.run();
                    });
                }
                else
                {
                    SwingUtilities.invokeLater(() -> {
                        setLoginBusy(false);
                    });
                }
            }).exceptionally(ex -> {
                SwingUtilities.invokeLater(() -> {
                    setLoginBusy(false);
                });
                return null;
            });
        }
        catch (Exception e)
        {
            setLoginBusy(false);
        }
    }

    private void setLoginBusy(boolean busy)
    {
        loginInProgress = busy;
        try
        {
            if (loginButton != null)
            {
                loginButton.setEnabled(!busy);
                loginButton.setText(busy ? "Logging in..." : (isLoggedIn ? "Logout" : "Login to view more stats"));
            }
            if (websiteSearchField != null) websiteSearchField.setEnabled(!busy);
            if (pluginSearchField != null) pluginSearchField.setEnabled(!busy);
        }
        catch (Exception ignore) {}
    }

    public void setLoggedIn(boolean loggedIn)
    {
        this.isLoggedIn = loggedIn;
        if (loginButton != null)
        {
            loginButton.setText(loggedIn ? "Logout" : "Login to view more stats");
        }
    }
    
    public void setPluginSearchText(String text)
    {
        if (pluginSearchField != null)
        {
            pluginSearchField.setText(text);
        }
    }
    
    public String getPluginSearchText()
    {
        return pluginSearchField != null ? pluginSearchField.getText() : "";
    }

    private void clearTokens() {
        cognitoAuthService.logout();
        isLoggedIn = false;
        if (loginButton != null) loginButton.setText("Login to view stats in runelite");
    }
}


package com.pvp.leaderboard.service;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import lombok.extern.slf4j.Slf4j;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import javax.inject.Inject;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.CompletableFuture;

@Slf4j
public class MatchResultService
{
    private static final String API_URL = "https://l5xya0wf0d.execute-api.us-east-1.amazonaws.com/prod/matchresult";
    private static final String CLIENT_ID = "runelite";
    private static final String PLUGIN_VERSION = "1.0.0";
    // This is meant to be hardcoded and be this value for everyone. New versions of the plugin will update this on the backend so that it doesn't take matches from old clients if there is an incompatibility added.
    private static final String RUNELITE_CLIENT_SECRET = "7f2f6a0e-2c6b-4b1d-9a39-6f2b2a8a1f3c"; 
    private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");

    private final OkHttpClient httpClient;
    private final Gson gson;

    @Inject
    public MatchResultService(OkHttpClient httpClient, Gson gson)
    {
        this.httpClient = httpClient;
        this.gson = gson;
    }

    // Fallback constructor for tests: use RuneLite injector (no fresh clients)
    public MatchResultService()
    {
        this(
            net.runelite.client.RuneLite.getInjector().getInstance(OkHttpClient.class),
            net.runelite.client.RuneLite.getInjector().getInstance(Gson.class)
        );
    }

    /**
     * Validates a RuneScape username format.
     * Valid: alphanumeric, spaces, underscores, hyphens, 1-12 characters
     */
    private boolean isValidRunescapeName(String name)
    {
        if (name == null) return false;
        String trimmed = name.trim();
        if (trimmed.isEmpty() || trimmed.length() > 12) return false;
        return trimmed.matches("^[a-zA-Z0-9 _-]+$");
    }

    public CompletableFuture<Boolean> submitMatchResult(MatchResult match)
    {
        CompletableFuture<Boolean> overall = new CompletableFuture<>();
        try
        {
            // Validate player and opponent names match RuneScape format
            if (!isValidRunescapeName(match.getPlayerId()) || !isValidRunescapeName(match.getOpponentId()))
            {
                log.debug("[Submit] Invalid name format: player='{}' opponent='{}'", match.getPlayerId(), match.getOpponentId());
                overall.complete(false);
                return overall;
            }

            // Preflight diagnostics to understand why server might reject
            try {
                String pLower = match.getPlayerId().trim().replaceAll("\\s+", " ").toLowerCase(java.util.Locale.ROOT);
                String oLower = match.getOpponentId().trim().replaceAll("\\s+", " ").toLowerCase(java.util.Locale.ROOT);
                boolean notSelf = !pLower.equals(oLower);
                boolean timeOk = match.getFightStartTs() > 0 && match.getFightEndTs() > 0 && match.getFightEndTs() >= match.getFightStartTs();
                boolean worldOk = match.getWorld() > 0;
                // log.debug("[Submit] preflight notSelf={} timeOk={} worldOk={} player='{}' opponent='{}' startTs={} endTs={} world={} multi={} dmgOut={}",
                //     notSelf, timeOk, worldOk, match.getPlayerId(), match.getOpponentId(), match.getFightStartTs(), match.getFightEndTs(), match.getWorld(), match.isWasInMulti(), match.getDamageToOpponent());
                // if (!notSelf) { log.debug("[Submit][why] Opponent equals self; likely mis-attribution"); }
                // if (!timeOk) { log.debug("[Submit][why] Invalid timestamps startTs={} endTs={}", match.getFightStartTs(), match.getFightEndTs()); }
                // if (!worldOk) { log.debug("[Submit][why] Invalid world={}", match.getWorld()); }
            } catch (Exception ignore) {}
            
            String dbgPlayer = (match.getPlayerId() != null ? match.getPlayerId() : "<null>");
            String dbgOpponent = (match.getOpponentId() != null ? match.getOpponentId() : "<null>");
            // log.debug("[Submit] begin playerId={} opponentId={} result={} world={} startTs={} endTs={} startSpell={} endSpell={} multi={} authed={}",
            //     dbgPlayer, dbgOpponent, match.getResult(), match.getWorld(), match.getFightStartTs(), match.getFightEndTs(), match.getFightStartSpellbook(), match.getFightEndSpellbook(), match.isWasInMulti(), (match.getIdToken() != null && !match.getIdToken().isEmpty()));

            JsonObject body = new JsonObject();
            body.addProperty("player_id", match.getPlayerId());
            body.addProperty("opponent_id", match.getOpponentId());
            body.addProperty("result", match.getResult());
            body.addProperty("world", match.getWorld());
            body.addProperty("fight_start_ts", match.getFightStartTs());
            body.addProperty("fight_end_ts", match.getFightEndTs());
            body.addProperty("fightStartSpellbook", match.getFightStartSpellbook());
            body.addProperty("fightEndSpellbook", match.getFightEndSpellbook());
            body.addProperty("wasInMulti", match.isWasInMulti());
            body.addProperty("client_id", CLIENT_ID);
            body.addProperty("plugin_version", PLUGIN_VERSION);
            body.addProperty("damage_to_opponent", match.getDamageToOpponent());

            String bodyJson = gson.toJson(body);
            
            log.debug("[MatchAPI] Request body: {}", bodyJson);

            if (match.getIdToken() != null && !match.getIdToken().isEmpty())
            {
                log.debug("[MatchAPI] Using authenticated path (has idToken)");
                submitAuthenticatedFightAsync(bodyJson, match.getIdToken(), match.getClientUniqueId()).whenComplete((ok, ex) -> {
                    if (ex != null)
                    {
                        log.debug("[MatchAPI] Authenticated path exception: {}, falling back to unauth", ex.getMessage());
                        submitUnauthenticatedFightAsync(bodyJson, match.getClientUniqueId()).whenComplete((ok2, ex2) -> {
                            if (ex2 != null) overall.complete(false); else overall.complete(ok2);
                        });
                        return;
                    }
                    if (Boolean.TRUE.equals(ok))
                    {
                        log.debug("[MatchAPI] Authenticated path SUCCESS");
                        overall.complete(true);
                    }
                    else
                    {
                        log.debug("[MatchAPI] Authenticated path failed, falling back to unauth");
                        submitUnauthenticatedFightAsync(bodyJson, match.getClientUniqueId()).whenComplete((ok2, ex2) -> {
                            if (ex2 != null) overall.complete(false); else overall.complete(ok2);
                        });
                    }
                });
            }
            else
            {
                log.debug("[MatchAPI] Using unauthenticated path (no idToken)");
                submitUnauthenticatedFightAsync(bodyJson, match.getClientUniqueId()).whenComplete((ok, ex) -> {
                    if (ex != null) overall.complete(false); else overall.complete(ok);
                });
            }
        }
        catch (Exception e)
        {
            log.debug("[MatchAPI] EXCEPTION during submit: {}", e.getMessage(), e);
            overall.complete(false);
        }
        return overall;
    }

    private CompletableFuture<Boolean> submitAuthenticatedFightAsync(String body, String idToken, String clientUniqueId)
    {
        CompletableFuture<Boolean> future = new CompletableFuture<>();

        Request request = new Request.Builder()
            .url(API_URL)
            .post(RequestBody.create(JSON, body))
            .addHeader("Authorization", "Bearer " + idToken)
            .addHeader("X-Client-Unique-Id", clientUniqueId)
            .build();

        log.debug("[MatchAPI] Auth request to: {}", API_URL);

        httpClient.newCall(request).enqueue(new Callback()
        {
            @Override
            public void onFailure(Call call, IOException e)
            {
                log.debug("[MatchAPI] Auth request NETWORK FAILURE: {}", e.getMessage());
                future.complete(false);
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException
            {
                try (Response res = response)
                {
                    int code = res.code();
                    String reqId = null; try { reqId = res.header("x-amzn-RequestId"); } catch (Exception ignore) {}
                    
                    if (code >= 200 && code < 300)
                    {
                        log.debug("[MatchAPI] Auth response SUCCESS: code={} requestId={}", code, reqId);
                        future.complete(true);
                    }
                    else
                    {
                        String errBody = null;
                        try { okhttp3.ResponseBody err = res.body(); errBody = err != null ? err.string() : null; } catch (Exception ignore) {}
                        log.debug("[MatchAPI] Auth response FAILED: code={} requestId={} body={}", code, reqId, errBody);
                        future.complete(false);
                    }
                }
            }
        });

        return future;
    }

    private CompletableFuture<Boolean> submitUnauthenticatedFightAsync(String body, String clientUniqueId)
    {
        CompletableFuture<Boolean> future = new CompletableFuture<>();
        long timestamp = System.currentTimeMillis() / 1000;
        String signature;
        try
        {
            signature = generateSignature(body, timestamp);
        }
        catch (Exception e)
        {
            log.debug("[MatchAPI] Unauth signature generation FAILED: {}", e.getMessage());
            future.completeExceptionally(e);
            return future;
        }

        Request request = new Request.Builder()
            .url(API_URL)
            .post(RequestBody.create(JSON, body))
            .addHeader("x-client-id", CLIENT_ID)
            .addHeader("x-timestamp", String.valueOf(timestamp))
            .addHeader("x-signature", signature)
            .addHeader("X-Client-Unique-Id", clientUniqueId)
            .build();

        log.debug("[MatchAPI] Unauth request to: {} timestamp={}", API_URL, timestamp);

        httpClient.newCall(request).enqueue(new Callback()
        {
            @Override
            public void onFailure(Call call, IOException e)
            {
                log.debug("[MatchAPI] Unauth request NETWORK FAILURE: {}", e.getMessage());
                future.complete(false);
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException
            {
                try (Response res = response)
                {
                    int code = res.code();
                    String reqId = null; try { reqId = res.header("x-amzn-RequestId"); } catch (Exception ignore) {}
                    
                    if ((code >= 200 && code < 300) || code == 202)
                    {
                        log.debug("[MatchAPI] Unauth response SUCCESS: code={} requestId={}", code, reqId);
                        future.complete(true);
                    }
                    else
                    {
                        String errBody = null;
                        try { okhttp3.ResponseBody err = res.body(); errBody = err != null ? err.string() : null; } catch (Exception ignore) {}
                        log.debug("[MatchAPI] Unauth response FAILED: code={} requestId={} body={}", code, reqId, errBody);
                        future.complete(false);
                    }
                }
            }
        });

        return future;
    }

    private String generateSignature(String body, long timestamp) throws Exception
    {
        String message = "POST\n/matchresult\n" + body + "\n" + timestamp;
        Mac mac = Mac.getInstance("HmacSHA256");
        SecretKeySpec secretKey = new SecretKeySpec(RUNELITE_CLIENT_SECRET.getBytes(StandardCharsets.UTF_8), "HmacSHA256");
        mac.init(secretKey);
        byte[] hash = mac.doFinal(message.getBytes(StandardCharsets.UTF_8));

        StringBuilder hexString = new StringBuilder();
        for (byte b : hash)
        {
            String hex = Integer.toHexString(0xff & b);
            if (hex.length() == 1) hexString.append('0');
            hexString.append(hex);
        }
        return hexString.toString();
    }
}

package com.pvp.leaderboard.service;

import java.io.File;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.UUID;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;

@Slf4j
@Singleton
public class ClientIdentityService
{
    private final ConfigManager configManager;
    private String clientUniqueId;

    @Inject
    public ClientIdentityService(ConfigManager configManager)
    {
        this.configManager = configManager;
    }

    /**
     * Initializes the client ID on startup.
     * Logic: Prefer global file ~/.runelite/pvp-leaderboard.id. If missing, generate and save.
     * Also syncs to RuneLite profile config for backup.
     */
    public void loadOrGenerateId()
    {
        if (clientUniqueId != null) return; // Already loaded

        File globalFile = new File(System.getProperty("user.home"), ".runelite/pvp-leaderboard.id");
        String globalId = null;

        try
        {
            if (globalFile.exists())
            {
                byte[] bytes = Files.readAllBytes(globalFile.toPath());
                globalId = new String(bytes, StandardCharsets.UTF_8).trim();
            }
        }
        catch (Exception e)
        {
            // log.debug("Failed to read global identity file", e);
        }

        String finalId = globalId;
        
        // If disk file missing, try to recover from profile config
        if (finalId == null || finalId.isEmpty())
        {
            String profileId = configManager.getConfiguration("PvPLeaderboard", "clientUniqueId");
            if (profileId != null && !profileId.isEmpty())
            {
                finalId = profileId;
            }
        }
        
        // If still no ID, generate new one
        if (finalId == null || finalId.isEmpty())
        {
            finalId = UUID.randomUUID().toString();
        }
        
        // Save to global file
        try
        {
            File parent = globalFile.getParentFile();
            if (parent != null && !parent.exists())
            {
                parent.mkdirs();
            }
            Files.write(globalFile.toPath(), finalId.getBytes(StandardCharsets.UTF_8));
        }
        catch (Exception e)
        {
            // log.debug("Failed to write global identity file", e);
        }

        // Sync to profile
        String profileId = configManager.getConfiguration("PvPLeaderboard", "clientUniqueId");
        if (!finalId.equals(profileId))
        {
            configManager.setConfiguration("PvPLeaderboard", "clientUniqueId", finalId);
        }

        this.clientUniqueId = finalId;
    }

    public String getClientUniqueId()
    {
        if (clientUniqueId == null) loadOrGenerateId();
        return clientUniqueId;
    }
}

package com.pvp.leaderboard.service;

public class ShardRank
{
    public final String tier;
    public final int rank;

    public ShardRank(String tier, int rank)
    {
        this.tier = tier;
        this.rank = rank;
    }
}

package com.pvp.leaderboard.service;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.JsonSyntaxException;
import com.pvp.leaderboard.cache.MatchesCacheEntry;
import com.pvp.leaderboard.cache.ShardEntry;
import com.pvp.leaderboard.cache.UserStatsCache;
import com.pvp.leaderboard.config.PvPLeaderboardConfig;
import com.pvp.leaderboard.util.RankUtils;
import lombok.extern.slf4j.Slf4j;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import okhttp3.ResponseBody;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j
@Singleton
public class PvPDataService
{
	private static final String API_BASE_URL = "https://l5xya0wf0d.execute-api.us-east-1.amazonaws.com/prod";
    private static final String SHARD_BASE_URL = "https://devsecopsautomated.com/rank_idx";

	private final OkHttpClient okHttpClient;
	private final Gson gson;
	private final PvPLeaderboardConfig config;
	private final ClientIdentityService clientIdentityService;

	// Shard lookup caching
    // Per spec: Shard Files = 60s TTL
	private static final long SHARD_CACHE_EXPIRY_MS = 60L * 1000L; 
    // "Not Found" State = 1 hour TTL
	private static final long MISSING_PLAYER_BACKOFF_MS = 60L * 60L * 1000L;
    // Failed fetch backoff
    private static final long SHARD_FAIL_BACKOFF_MS = 60L * 1000L;

	// In-flight request deduplication for getShardRankByName
	private final ConcurrentHashMap<String, CompletableFuture<ShardRank>> inFlightLookups = new ConcurrentHashMap<>();

	private final Map<String, ShardEntry> shardCache = Collections.synchronizedMap(
		new LinkedHashMap<String, ShardEntry>(128, 0.75f, true)
		{
			@Override
			protected boolean removeEldestEntry(Map.Entry<String, ShardEntry> eldest)
			{
				return size() > 512; // LRU cap
			}
		}
	);

	private final ConcurrentHashMap<String, Long> shardFailUntil = new ConcurrentHashMap<>();
	
    // Negative cache for specific players/accounts to avoid re-checking shards
	private final ConcurrentHashMap<String, Long> missingPlayerUntilMs = new ConcurrentHashMap<>();

    /**
     * Clears the shard negative cache for a player. Call this when API confirms player exists.
     */
    public void clearShardNegativeCache(String playerName) {
        if (playerName == null) return;
        String canonicalName = playerName.trim().replaceAll("\\s+", " ").toLowerCase();
        missingPlayerUntilMs.remove(canonicalName);
        // debug("[Cache] Cleared shard negative cache for {}", canonicalName);
    }

    // User Profile Caching
    private static final long USER_CACHE_TTL_MS = 1L * 60L * 1000L; // 1 minute
    private final ConcurrentHashMap<String, UserStatsCache> userStatsCache = new ConcurrentHashMap<>();

    // Matches Caching
    private static final long MATCHES_CACHE_TTL_MS = 1L * 60L * 1000L; // 1 minute
    private final ConcurrentHashMap<String, MatchesCacheEntry> matchesCache = new ConcurrentHashMap<>();

	@Inject
	public PvPDataService(OkHttpClient okHttpClient, Gson gson, CognitoAuthService authService, PvPLeaderboardConfig config, ClientIdentityService clientIdentityService)
	{
		this.okHttpClient = okHttpClient;
		this.gson = gson;
		this.config = config;
		this.clientIdentityService = clientIdentityService;
	}


	public CompletableFuture<JsonObject> getPlayerMatches(String playerName, String nextToken, int limit)
	{
		CompletableFuture<JsonObject> future = new CompletableFuture<>();

        // Check cache (only for first page, i.e. no nextToken)
        if (nextToken == null || nextToken.isEmpty()) {
            String cacheKey = "matches:" + playerName + ":" + limit;
            MatchesCacheEntry cached = matchesCache.get(cacheKey);
            if (cached != null && System.currentTimeMillis() - cached.getTimestamp() <= MATCHES_CACHE_TTL_MS) {
                future.complete(cached.getResponse().deepCopy());
                return future;
            }
        }

		HttpUrl urlObj = HttpUrl.parse(API_BASE_URL + "/matches");
		if (urlObj == null) {
			future.completeExceptionally(new IOException("Invalid base URL"));
			return future;
		}
		HttpUrl.Builder urlBuilder = urlObj.newBuilder()
			.addQueryParameter("player_id", playerName)
			.addQueryParameter("limit", String.valueOf(limit));

		if (nextToken != null && !nextToken.isEmpty())
		{
			urlBuilder.addQueryParameter("next_token", nextToken);
		}

		Request.Builder requestBuilder = new Request.Builder()
			.url(urlBuilder.build())
			.get();
		
		// Add client UUID header for API authentication/tracking
		String clientUuid = clientIdentityService.getClientUniqueId();
		if (clientUuid != null && !clientUuid.isEmpty())
		{
			requestBuilder.addHeader("X-Client-Unique-Id", clientUuid);
		}
		
		Request request = requestBuilder.build();

		okHttpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
                // Try serving stale cache if available
                if (nextToken == null || nextToken.isEmpty()) {
                    String cacheKey = "matches:" + playerName + ":" + limit;
                    MatchesCacheEntry cached = matchesCache.get(cacheKey);
                    if (cached != null) {
                        future.complete(cached.getResponse().deepCopy());
                        return;
                    }
                }
				future.completeExceptionally(e);
			}

			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				try (Response res = response)
				{
					if (!res.isSuccessful())
					{
                        // Try serving stale cache if available
                        if (nextToken == null || nextToken.isEmpty()) {
                            String cacheKey = "matches:" + playerName + ":" + limit;
                            MatchesCacheEntry cached = matchesCache.get(cacheKey);
                            if (cached != null) {
                                future.complete(cached.getResponse().deepCopy());
                                return;
                            }
                        }
						future.completeExceptionally(new IOException("API call failed with status: " + res.code()));
						return;
					}

					ResponseBody body = res.body();
					if (body == null)
					{
						future.complete(new JsonObject());
						return;
					}

					try
					{
						String bodyString;
						try {
							bodyString = body.string();
						} catch (IOException cacheEx) {
							// Windows cache file locking issue - request succeeded but cache failed
							future.complete(new JsonObject());
							return;
						}
						JsonObject json = gson.fromJson(bodyString, JsonObject.class);
						if (nextToken == null || nextToken.isEmpty()) {
                            String cacheKey = "matches:" + playerName + ":" + limit;
                            matchesCache.put(cacheKey, new MatchesCacheEntry(json.deepCopy(), System.currentTimeMillis()));
                        }
						future.complete(json);
					}
					catch (JsonSyntaxException e)
					{
						future.completeExceptionally(e);
					}
				}
			}
		});

		return future;
	}

	public CompletableFuture<JsonObject> getUserProfile(String playerName, String clientUniqueId)
	{
		return getUserProfile(playerName, clientUniqueId, false);
	}

	public CompletableFuture<JsonObject> getUserProfile(String playerName, String clientUniqueId, boolean forceRefresh)
	{
		CompletableFuture<JsonObject> future = new CompletableFuture<>();
		log.debug("[API] getUserProfile called: player={} forceRefresh={}", playerName, forceRefresh);

		String cacheKey = "user:" + playerName;
		UserStatsCache cached = userStatsCache.get(cacheKey);
		if (!forceRefresh && cached != null && System.currentTimeMillis() - cached.getTimestamp() <= USER_CACHE_TTL_MS) {
			log.debug("[API] getUserProfile: returning cached data for player={}", playerName);
			future.complete(cached.getStats().deepCopy());
			return future;
		}

		HttpUrl urlObj = HttpUrl.parse(API_BASE_URL + "/user");
		if (urlObj == null) {
			log.debug("[API] getUserProfile: invalid base URL");
			future.completeExceptionally(new IOException("Invalid base URL"));
			return future;
		}
		HttpUrl url = urlObj.newBuilder()
			.addQueryParameter("player_id", playerName)
			.build();

		Request.Builder requestBuilder = new Request.Builder().url(url).get();
		
		// Add client UUID header for API authentication/tracking
		String clientUuid = clientIdentityService.getClientUniqueId();
		if (clientUuid != null && !clientUuid.isEmpty())
		{
			requestBuilder.addHeader("X-Client-Unique-Id", clientUuid);
		}
		
		Request request = requestBuilder.build();
		log.debug("[API] getUserProfile: making HTTP request to {}", url);

		okHttpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				log.debug("[API] getUserProfile onFailure: player={} error={}", playerName, e.getMessage());
				UserStatsCache stale = userStatsCache.get(cacheKey);
				if (stale != null) {
					log.debug("[API] getUserProfile: using stale cache on failure for player={}", playerName);
					future.complete(stale.getStats().deepCopy());
					return;
				}
				future.completeExceptionally(e);
			}

			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				try (Response res = response)
				{
					log.debug("[API] getUserProfile onResponse: player={} code={}", playerName, res.code());
					if (!res.isSuccessful())
					{
						if (res.code() == 404) {
							log.debug("[API] getUserProfile: 404 not found for player={}", playerName);
							future.complete(null);
							return;
						}
						log.debug("[API] getUserProfile: HTTP error {} for player={}", res.code(), playerName);
						future.completeExceptionally(new IOException("API error: " + res.code()));
						return;
					}
					ResponseBody body = res.body();
					String bodyString;
					try {
						bodyString = body != null ? body.string() : "{}";
					} catch (IOException cacheEx) {
						log.debug("[API] getUserProfile: cache error during body read for player={}: {}", playerName, cacheEx.getMessage());
						// Windows cache file locking issue - request succeeded but cache failed
						// Try to serve stale cache if available
						UserStatsCache stale = userStatsCache.get(cacheKey);
						if (stale != null) {
							log.debug("[API] getUserProfile: using stale cache after cache error for player={}", playerName);
							future.complete(stale.getStats().deepCopy());
							return;
						}
						log.debug("[API] getUserProfile: no stale cache, returning null for player={}", playerName);
						future.complete(null);
						return;
					}
					log.debug("[API] getUserProfile SUCCESS: player={} bodyLength={}", playerName, bodyString.length());
					log.debug("[API] getUserProfile RESPONSE: player={} body={}", playerName, bodyString);
					JsonObject json = gson.fromJson(bodyString, JsonObject.class);
					userStatsCache.put(cacheKey, new UserStatsCache(json.deepCopy(), System.currentTimeMillis()));
					future.complete(json);
				}
				catch (JsonSyntaxException e)
				{
					log.debug("[API] getUserProfile: JSON parse error for player={}: {}", playerName, e.getMessage());
					future.completeExceptionally(e);
				}
			}
		});

		return future;
	}

    /**
     * Get tier from user profile API using /user endpoint.
     * /user returns: rank (tier name like "Dragon"), division (1-3), buckets (per-bucket data)
     * Returns combined tier string like "Dragon 3" or just "Dragon" if no division.
     */
    public CompletableFuture<String> getTierFromProfile(String playerName, String bucket)
    {
        log.debug("[API] getTierFromProfile called: player={} bucket={}", playerName, bucket);
        
        // Force refresh to get fresh data after a fight, but keep cached data as fallback
        String cacheKey = "user:" + playerName;
        UserStatsCache cachedData = userStatsCache.get(cacheKey);
        log.debug("[API] getTierFromProfile: cachedData exists={}", cachedData != null);
        
        return getUserProfile(playerName, null, true).thenApply(profile -> {
            if (profile == null) {
                log.debug("[API] getTierFromProfile: profile is null for player={}", playerName);
                // Try fallback to cached data if available
                if (cachedData != null) {
                    JsonObject cachedProfile = cachedData.getStats();
                    if (cachedProfile != null) {
                        log.debug("[API] getTierFromProfile: using cached fallback for player={}", playerName);
                        // Try bucket-specific data first
                        if (cachedProfile.has("buckets") && cachedProfile.get("buckets").isJsonObject()) {
                            JsonObject buckets = cachedProfile.getAsJsonObject("buckets");
                            if (buckets.has(bucket) && buckets.get(bucket).isJsonObject()) {
                                JsonObject bucketData = buckets.getAsJsonObject(bucket);
                                String tier = extractTierFromUserResponse(bucketData, playerName, bucket);
                                if (tier != null) {
                                    log.debug("[API] getTierFromProfile: cached bucket tier={} for player={}", tier, playerName);
                                    return tier;
                                }
                            }
                        }
                        // Fallback to top-level
                        String tier = extractTierFromUserResponse(cachedProfile, playerName, "overall");
                        log.debug("[API] getTierFromProfile: cached top-level tier={} for player={}", tier, playerName);
                        return tier;
                    }
                }
                log.debug("[API] getTierFromProfile: no cached data, returning null for player={}", playerName);
                return null;
            }
            
            log.debug("[API] getTierFromProfile: got profile for player={}, keys={}", playerName, profile.keySet());
            
            // Try bucket-specific data first (in "buckets" object)
            if (profile.has("buckets") && profile.get("buckets").isJsonObject()) {
                JsonObject buckets = profile.getAsJsonObject("buckets");
                if (buckets.has(bucket) && buckets.get(bucket).isJsonObject()) {
                    JsonObject bucketData = buckets.getAsJsonObject(bucket);
                    String tier = extractTierFromUserResponse(bucketData, playerName, bucket);
                    if (tier != null) {
                        log.debug("[API] getTierFromProfile SUCCESS: bucket tier={} for player={}", tier, playerName);
                        return tier;
                    }
                }
            }
            
            // Fallback to top-level rank/division fields (for overall bucket)
            String tier = extractTierFromUserResponse(profile, playerName, "overall");
            if (tier != null) {
                log.debug("[API] getTierFromProfile SUCCESS: top-level tier={} for player={}", tier, playerName);
                return tier;
            }
            
            log.debug("[API] getTierFromProfile: no rank found in profile for player={} bucket={}", playerName, bucket);
            return null;
        });
    }
    
    /**
     * Extract tier from /user response object.
     * /user returns "rank" (tier name like "Bronze", "Dragon") and "division" (1, 2, or 3)
     * NOT a "tier" field - that's only in S3 shards.
     */
    private String extractTierFromUserResponse(JsonObject obj, String playerName, String bucket) {
        if (obj == null) return null;
        
        String rank = null;
        int division = 0;
        
        // /user endpoint uses "rank" for tier name (e.g., "Bronze", "Dragon", "3rd Age")
        if (obj.has("rank") && !obj.get("rank").isJsonNull()) {
            rank = obj.get("rank").getAsString();
        }
        // division is 1, 2, or 3
        if (obj.has("division") && !obj.get("division").isJsonNull()) {
            division = obj.get("division").getAsInt();
        }
        
        if (rank != null && !rank.isEmpty()) {
            // Combine rank and division (e.g., "Dragon 3")
            String tier = division > 0 ? rank + " " + division : rank;
            // debug("[API] extractTierFromUserResponse SUCCESS player={} bucket={} tier={}", playerName, bucket, tier);
            return tier;
        }
        return null;
    }

    /**
     * API lookup for post-fight rank refresh (bypasses shards for fresh data).
     * Uses /user endpoint which returns rank and division fields.
     */
	public CompletableFuture<String> getPlayerTier(String playerName, String bucket)
	{
		// debug("[API] getPlayerTier called for player={} bucket={}", playerName, bucket);
        // Delegate to getTierFromProfile which uses /user endpoint correctly
        return getTierFromProfile(playerName, bucket);
	}

	/**
     * Primary Entry Point: Get Rank by Name using the SHA256 Shard Logic
     * Uses in-flight deduplication to prevent multiple concurrent lookups for the same (player, bucket).
     */
	public CompletableFuture<ShardRank> getShardRankByName(String playerName, String bucket)
	{
        if (playerName == null || playerName.trim().isEmpty()) {
            return CompletableFuture.completedFuture(null);
        }

        // 1. Canonicalize Name and bucket (normalize spaces for consistency)
        String canonicalName = playerName.trim().replaceAll("\\s+", " ").toLowerCase();
        String bucketPath = (bucket == null || bucket.isEmpty()) ? "overall" : bucket.toLowerCase();
        
        // Create lookup key for deduplication
        String lookupKey = canonicalName + ":" + bucketPath;
        
        // Check for existing in-flight lookup - if one exists, return it instead of starting a new one
        CompletableFuture<ShardRank> existingLookup = inFlightLookups.get(lookupKey);
        if (existingLookup != null) {
            // debug("[Lookup] Dedup: reusing in-flight lookup for '{}' bucket={}", canonicalName, bucketPath);
            return existingLookup;
        }
        
        // Create new future for this lookup
        CompletableFuture<ShardRank> future = new CompletableFuture<>();
        
        // Try to register as the in-flight lookup (atomic operation)
        CompletableFuture<ShardRank> previousLookup = inFlightLookups.putIfAbsent(lookupKey, future);
        if (previousLookup != null) {
            // Another thread beat us to it - use their future instead
            // debug("[Lookup] Dedup: race detected, reusing in-flight lookup for '{}' bucket={}", canonicalName, bucketPath);
            return previousLookup;
        }
        
        // We own this lookup - make sure to clean up when done
        future.whenComplete((result, ex) -> inFlightLookups.remove(lookupKey, future));
        
        try {
            // Check Negative Cache first (1 hour block)
            Long missingUntil = missingPlayerUntilMs.get(canonicalName);
            if (missingUntil != null && System.currentTimeMillis() < missingUntil) {
                // debug("[Lookup] Negative cache hit for {} (blocked until {})", canonicalName, missingUntil);
                future.complete(null);
                return future;
            }

            // 2. Shard Key = first 2 chars of lowercase name (e.g., "toyco" -> "to")
            String shardKey = canonicalName.length() >= 2 
                ? canonicalName.substring(0, 2).toLowerCase() 
                : canonicalName.toLowerCase();
            String url = SHARD_BASE_URL + "/" + bucketPath + "/" + shardKey + ".json";

            // debug("[Lookup] Player: {} -> Shard: {} -> URL: {}", canonicalName, shardKey, url);

            // 4. Fetch/Get Cached Shard
            getShard(url).thenCompose(shardJson -> {
                if (shardJson == null) {
                    // debug("[Lookup] Shard download failed/empty for {}", url);
                    // THIS: Also mark player as missing for 1 hour when shard doesn't exist
                    missingPlayerUntilMs.put(canonicalName, System.currentTimeMillis() + MISSING_PLAYER_BACKOFF_MS);
                    future.complete(null);
                    return CompletableFuture.completedFuture(null);
                }
                
                // 5. Look for Name in name_rank_info_map
                JsonObject nameMap = shardJson.getAsJsonObject("name_rank_info_map");
                if (nameMap == null || !nameMap.has(canonicalName)) {
                    // debug("[Lookup] Player '{}' NOT FOUND in shard {}", canonicalName, shardKey);
                    // Mark missing (1 Hour TTL)
                    missingPlayerUntilMs.put(canonicalName, System.currentTimeMillis() + MISSING_PLAYER_BACKOFF_MS);
                    future.complete(null);
                    return CompletableFuture.completedFuture(null);
                }
                
                JsonObject entry = nameMap.getAsJsonObject(canonicalName);
                
                // Scenario B: Redirect
                if (entry.has("redirect")) {
                    String accountSha = entry.get("redirect").getAsString();
                    // debug("[Lookup] Redirect found for '{}' -> SHA: {}", canonicalName, accountSha);
                    // FIX: Complete the outer future with the redirect result
                    resolveRedirect(accountSha, bucketPath).thenAccept(result -> {
                        future.complete(result);
                    }).exceptionally(ex -> {
                        future.complete(null);
                        return null;
                    });
                    return CompletableFuture.completedFuture(null);
                }
                
                // Scenario A: Direct Hit
                // debug("[Lookup] Direct hit for '{}'", canonicalName);
                ShardRank rank = parseRankObject(entry);
                future.complete(rank);
                return CompletableFuture.completedFuture(null);
                
            }).exceptionally(ex -> {
                // debug("Exception in getShardRankByName: {}", ex.getMessage());
                future.complete(null);
                return null;
            });
            
        } catch (Exception e) {
            // debug("Error in getShardRankByName: {}", e.getMessage());
            future.complete(null);
        }
		return future;
	}

    /**
     * Helper to resolve Redirect (Account SHA -> Rank Shard)
     * Supports chained redirects with max depth of 10
     */
    private CompletableFuture<ShardRank> resolveRedirect(String accountSha, String bucket) {
        return resolveRedirectWithDepth(accountSha, bucket, 0);
    }

    private CompletableFuture<ShardRank> resolveRedirectWithDepth(String accountSha, String bucket, int depth) {
        CompletableFuture<ShardRank> future = new CompletableFuture<>();
        
        if (depth >= 10) {
            // debug("[Redirect] Max depth (10) reached for {}, aborting", accountSha);
            future.complete(null);
            return future;
        }
        
        if (accountSha == null || accountSha.length() < 2) {
            future.complete(null);
            return future;
        }

        // 1. Calc Shard from SHA (first 2 chars)
        String shardKey = accountSha.substring(0, 2);
        String url = SHARD_BASE_URL + "/" + bucket + "/" + shardKey + ".json";
        
        // debug("[Redirect] depth={} SHA={} -> Shard={}", depth, accountSha, shardKey);

        // 2. Fetch/Get Cached Shard
        getShard(url).thenAccept(shardJson -> {
            if (shardJson == null) {
                future.complete(null);
                return;
            }
            
            // 3. Look in account_rank_info_map
            JsonObject acctMap = shardJson.getAsJsonObject("account_rank_info_map");
            if (acctMap != null && acctMap.has(accountSha)) {
                JsonObject entry = acctMap.getAsJsonObject(accountSha);
                
                // Check for chained redirect
                if (entry.has("redirect")) {
                    String nextSha = entry.get("redirect").getAsString();
                    // debug("[Redirect] Chain redirect to {}", nextSha);
                    resolveRedirectWithDepth(nextSha, bucket, depth + 1)
                        .thenAccept(future::complete);
                    return;
                }
                
                // debug("[Redirect] Found SHA entry at depth {}", depth);
                future.complete(parseRankObject(entry));
            } else {
                // debug("[Redirect] SHA entry NOT FOUND in shard");
                future.complete(null);
            }
        }).exceptionally(ex -> {
            future.complete(null);
            return null;
        });
        
        return future;
    }
    
    private ShardRank parseRankObject(JsonObject o) {
        if (o == null) return null;
        if (RankUtils.isUnrankedOrDefault(o)) return null;

        int idx = o.has("world_rank") && !o.get("world_rank").isJsonNull() ? o.get("world_rank").getAsInt() : -1;
        
        String tier = null;
        if (o.has("tier") && !o.get("tier").isJsonNull()) {
            tier = RankUtils.formatTierLabel(o.get("tier").getAsString());
        }
        
        if (tier == null && o.has("rank")) {
             tier = o.get("rank").getAsString();
        }
        
        if (tier != null && idx > 0) {
            return new ShardRank(tier, idx);
        }
        if (tier != null) return new ShardRank(tier, idx > 0 ? idx : 0);
        
        return null;
    }

	/**
	 * Low-level shard fetch with 60s Cache
	 */
	public CompletableFuture<JsonObject> getShard(String url)
	{
		CompletableFuture<JsonObject> future = new CompletableFuture<>();
        
        long now = System.currentTimeMillis();
        
        // 1. Check Memory Cache
        ShardEntry cached = shardCache.get(url);
        if (cached != null && (now - cached.getTimestamp() < SHARD_CACHE_EXPIRY_MS)) {
            // debug("[Cache] HIT for {}", url);
            future.complete(cached.getPayload());
            return future;
        }
        
        // 2. Check Negative Cache (Fail Until)
        Long failUntil = shardFailUntil.get(url);
        if (failUntil != null && now < failUntil) {
            // debug("[Cache] Negative/Fail HIT for {}", url);
            future.complete(null);
            return future;
        }

        // 3. Download
		Request request = new Request.Builder().url(url).get().build();
		// debug("[Network] Downloading shard: {}", url);

		okHttpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
                // debug("[Network] Fail: {}", e.getMessage());
                shardFailUntil.put(url, System.currentTimeMillis() + SHARD_FAIL_BACKOFF_MS);
				future.completeExceptionally(e);
			}

			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				try (Response res = response)
				{
					if (!res.isSuccessful()) {
                        // debug("[Network] HTTP Error: {}", res.code());
                        shardFailUntil.put(url, System.currentTimeMillis() + SHARD_FAIL_BACKOFF_MS);
						future.complete(null);
						return;
					}
                    
                    ResponseBody body = res.body();
                    if (body == null) {
                        future.complete(new JsonObject());
                        return;
                    }
                    
                    String bodyStr;
                    try {
                        bodyStr = body.string();
                    } catch (IOException cacheEx) {
                        // Windows cache file locking issue - request succeeded but cache failed
                        // Try to serve stale cache if available
                        ShardEntry stale = shardCache.get(url);
                        if (stale != null) {
                            future.complete(stale.getPayload());
                            return;
                        }
                        future.complete(null);
                        return;
                    }
                    JsonObject json = gson.fromJson(bodyStr, JsonObject.class);
                    
                    // Cache Success (60s)
                    shardCache.put(url, new ShardEntry(json, System.currentTimeMillis()));
                    shardFailUntil.remove(url);
                    
                    future.complete(json);
				} catch (Exception e) {
                    // debug("[Network] Parse Error: {}", e.getMessage());
                    future.complete(null);
                }
			}
		});
		return future;
	}

    // Retained for compatibility if needed, but not used by new flow
	public CompletableFuture<ShardRank> getShardRank(String accountHash, String bucket)
	{
		// Map old account-hash based call to the resolveRedirect logic which effectively does SHA->Shard lookup
        // But getShardRank was used when we *only* had account hash.
        // If we want to support that, we can use the resolveRedirect logic.
        return resolveRedirect(accountHash, bucket == null ? "overall" : bucket);
	}

	public CompletableFuture<Integer> getRankNumber(String playerName, String accountHash, String bucket)
	{
		// New logic: Use getShardRankByName which handles everything (name->md5->shard or name->redirect->sha->shard)
        // If we have accountHash, we can try direct SHA lookup (resolveRedirect), but Name lookup is preferred now?
        // Actually, if we have Name, we should use getShardRankByName.
        
        return getShardRankByName(playerName, bucket).thenApply(sr -> {
            if (sr != null) return sr.rank;
            return -1;
        });
	}

    // Helper for deprecated usage if any
	public CompletableFuture<Integer> getRankIndex(String playerId, String bucket)
	{
        // Redirect to new logic
        return getShardRankByName(playerId, bucket).thenApply(sr -> sr != null ? sr.rank : -1);
	}

	public String generateAcctSha(String uuid) throws Exception
	{
		MessageDigest digest = MessageDigest.getInstance("SHA-256");
		byte[] hash = digest.digest(uuid.getBytes(StandardCharsets.UTF_8));
		StringBuilder hexString = new StringBuilder();
		for (byte b : hash)
		{
			String hex = Integer.toHexString(0xff & b);
			if (hex.length() == 1) hexString.append('0');
			hexString.append(hex);
		}
		return hexString.toString();
	}

}

package com.pvp.leaderboard.service;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import net.runelite.client.config.ConfigManager;
import com.sun.net.httpserver.HttpExchange;
import com.sun.net.httpserver.HttpHandler;
import com.sun.net.httpserver.HttpServer;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;

import java.io.*;
import java.net.*;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.util.Base64;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import javax.inject.Inject;
import net.runelite.client.util.LinkBrowser;

public class CognitoAuthService {
    private static final String COGNITO_DOMAIN = "osrs-mmr-a8959e04.auth.us-east-1.amazoncognito.com";
    private static final String CLIENT_ID = "5ho4mj5d17v44s4vavnkmp2mmo";
    private static final String REDIRECT_URI = "http://127.0.0.1:49215/callback";
    private static final int CALLBACK_PORT = 49215;
    
    private final ConfigManager configManager;
    private final OkHttpClient httpClient;
    private final Gson gson;
    private String transientVerifier;
    private String transientState;
    // Local HTTP server for OAuth callback
    private HttpServer httpServer;
    private String accessToken;
    private String idToken;
    private String refreshToken;
    private long tokenExpiry;
    private final ScheduledExecutorService scheduler;
    private ScheduledFuture<?> refreshTask;
    
    @Inject
    public CognitoAuthService(ConfigManager configManager, OkHttpClient httpClient, Gson gson, ScheduledExecutorService scheduler) {
        this.configManager = configManager;
        this.httpClient = httpClient;
        this.gson = gson;
        this.scheduler = scheduler;
    }


    public CompletableFuture<Boolean> login() {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // Generate PKCE
                String verifier = generatePKCEVerifier();
                String challenge = generatePKCEChallenge(verifier);
                if (configManager != null) {
                    configManager.setConfiguration("PvPLeaderboard", "pkce_verifier", verifier);
                } else {
                    transientVerifier = verifier;
                }

                // Start local HTTP server to capture callback
                CompletableFuture<String> codeFuture = new CompletableFuture<>();
                startCallbackServer(codeFuture);

                // Open browser to login with random OAuth state
                String state = generateRandomState();
                if (configManager != null) {
                    configManager.setConfiguration("PvPLeaderboard", "oauth_state", state);
                } else {
                    transientState = state;
                }
                String loginUrl = String.format(
                    "https://%s/login?client_id=%s&response_type=code&scope=openid+email+profile&redirect_uri=%s&code_challenge_method=S256&code_challenge=%s&state=%s",
                    COGNITO_DOMAIN, CLIENT_ID, URLEncoder.encode(REDIRECT_URI, "UTF-8"), challenge, URLEncoder.encode(state, "UTF-8")
                );
                LinkBrowser.browse(loginUrl);

                // Wait for code up to 10s; on timeout, fail silently and allow re-login
                String code = null;
                try {
                    code = codeFuture.get(10, java.util.concurrent.TimeUnit.SECONDS);
                } catch (java.util.concurrent.TimeoutException te) {
                    // Timeout: stop server and return false without UI popups
                    stopCallbackServer();
                    clearTokens();
                    return false;
                }
                stopCallbackServer();
                if (code == null || code.isEmpty()) {
                    // Ensure auth artifacts are cleared on failure
                    clearTokens();
                    return false;
                }
                exchangeCodeForTokens(code.trim());
                ensureRefreshScheduler();
                return true;
            } catch (Exception e) {
                stopCallbackServer();
                clearTokens();
                return false;
            }
        }, scheduler);
    }
    
    private void startCallbackServer(CompletableFuture<String> codeFuture) throws IOException {
        if (httpServer != null) stopCallbackServer();
        InetSocketAddress addr = new InetSocketAddress("127.0.0.1", CALLBACK_PORT);
        httpServer = HttpServer.create(addr, 0);
        httpServer.createContext("/callback", new HttpHandler() {
            @Override
            public void handle(HttpExchange ex) throws IOException {
                try {
                    URI uri = ex.getRequestURI();
                    String query = uri.getRawQuery();
                    String code = extractParam(query, "code");
                    // Validate returned state to mitigate CSRF
                    String state = extractParam(query, "state");
                    String expectedState = null;
                    if (configManager != null) {
                        Object s = configManager.getConfiguration("PvPLeaderboard", "oauth_state");
                        expectedState = s != null ? String.valueOf(s) : null;
                    } else {
                        expectedState = transientState;
                    }
                    boolean stateOk = expectedState != null && expectedState.equals(state);
                    String html = stateOk && code != null && !code.isEmpty()
                        ? "<html><head><title>Login Complete</title></head><body style=\"background:#111;color:#ffcc00;font-family:Arial\"><h2>Login complete</h2><p>You may now return to RuneLite.</p></body></html>"
                        : "<html><head><title>Login Failed</title></head><body style=\"background:#111;color:#ff6666;font-family:Arial\"><h2>Login failed</h2><p>Invalid login state.</p></body></html>";
                    byte[] bytes = html.getBytes(StandardCharsets.UTF_8);
                    ex.getResponseHeaders().set("Content-Type", "text/html; charset=utf-8");
                    ex.sendResponseHeaders(200, bytes.length);
                    try (OutputStream os = ex.getResponseBody()) { os.write(bytes); }
                    if (stateOk && code != null && !code.isEmpty() && !codeFuture.isDone()) {
                        codeFuture.complete(code);
                    } else if (!codeFuture.isDone()) {
                        codeFuture.complete(null);
                    }
                } catch (Exception ignore) {
                    try { if (!codeFuture.isDone()) codeFuture.complete(null); } catch (Exception ignored) {}
                }
            }
        });
        httpServer.start();
    }

    private void stopCallbackServer() {
        try { if (httpServer != null) httpServer.stop(0); } catch (Exception ignore) {}
        httpServer = null;
    }
    
    private void exchangeCodeForTokens(String code) throws Exception {
        String verifier = null;
        if (configManager != null) {
            Object v = configManager.getConfiguration("PvPLeaderboard", "pkce_verifier");
            verifier = v != null ? String.valueOf(v) : null;
        } else {
            verifier = transientVerifier;
        }
        // Form-encode ALL values
        String postData =
            "grant_type=" + URLEncoder.encode("authorization_code", "UTF-8") +
            "&client_id=" + URLEncoder.encode(CLIENT_ID, "UTF-8") +
            "&code=" + URLEncoder.encode(code, "UTF-8") +
            "&redirect_uri=" + URLEncoder.encode(REDIRECT_URI, "UTF-8") +
            "&code_verifier=" + URLEncoder.encode(String.valueOf(verifier), "UTF-8");

        Request req = new Request.Builder()
            .url("https://" + COGNITO_DOMAIN + "/oauth2/token")
            .post(RequestBody.create(MediaType.parse("application/x-www-form-urlencoded"), postData))
            .addHeader("Accept", "application/json")
            .build();

        final java.util.concurrent.CompletableFuture<String> fut = new java.util.concurrent.CompletableFuture<>();
        httpClient.newCall(req).enqueue(new okhttp3.Callback() {
            @Override public void onFailure(okhttp3.Call call, java.io.IOException e) { fut.completeExceptionally(e); }
            @Override public void onResponse(okhttp3.Call call, okhttp3.Response response) throws java.io.IOException {
                try (okhttp3.Response res = response) {
                    if (!res.isSuccessful() || res.body() == null) {
                        fut.completeExceptionally(new IOException("Token exchange failed (status=" + res.code() + ")"));
                        return;
                    }
                    okhttp3.ResponseBody rb = res.body();
                    String body = rb != null ? rb.string() : "";
                    fut.complete(body);
                }
            }
        });
        String response = fut.get(10, java.util.concurrent.TimeUnit.SECONDS);

        JsonObject tokens = gson.fromJson(response, JsonObject.class);
        accessToken = tokens.has("access_token") && !tokens.get("access_token").isJsonNull() ? tokens.get("access_token").getAsString() : null;
        idToken = tokens.has("id_token") && !tokens.get("id_token").isJsonNull() ? tokens.get("id_token").getAsString() : null;
        refreshToken = tokens.has("refresh_token") && !tokens.get("refresh_token").isJsonNull() ? tokens.get("refresh_token").getAsString() : null;
        int expiresIn = tokens.has("expires_in") ? tokens.get("expires_in").getAsInt() : 3600;
        tokenExpiry = System.currentTimeMillis() + (expiresIn * 1000L);

        // Validate ID token claims before proceeding (iss/aud/exp/token_use)
        if (idToken == null || !validateIdTokenClaims(idToken)) {
            clearTokens();
            throw new IOException("Invalid ID token claims");
        }
        
        // Clean up
        if (configManager != null) {
            configManager.unsetConfiguration("PvPLeaderboard", "pkce_verifier");
            configManager.unsetConfiguration("PvPLeaderboard", "oauth_state");
        }
        transientVerifier = null;
        transientState = null;

        // Start/refresh auto refresh loop when we have a refresh token
        ensureRefreshScheduler();
    }
    
    public String getAccessToken() {
        return accessToken;
    }
    

    
    public boolean isLoggedIn() {
        return accessToken != null && System.currentTimeMillis() < tokenExpiry;
    }
    
    public void logout() {
        clearTokens();
    }
    
    public String getStoredIdToken() {
        return idToken;
    }
    
    private String generatePKCEVerifier() {
        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~";
        SecureRandom random = new SecureRandom();
        StringBuilder verifier = new StringBuilder(64);
        for (int i = 0; i < 64; i++) {
            verifier.append(chars.charAt(random.nextInt(chars.length())));
        }
        return verifier.toString();
    }
    
    private String generatePKCEChallenge(String verifier) throws Exception {
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        byte[] hash = digest.digest(verifier.getBytes(StandardCharsets.UTF_8));
        return Base64.getUrlEncoder().withoutPadding().encodeToString(hash).replace('+', '-').replace('/', '_');
    }
    
    private String generateRandomState() {
        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~";
        SecureRandom random = new SecureRandom();
        StringBuilder sb = new StringBuilder(32);
        for (int i = 0; i < 32; i++) {
            sb.append(chars.charAt(random.nextInt(chars.length())));
        }
        return sb.toString();
    }

    private void clearTokens() {
        accessToken = null;
        idToken = null;
        refreshToken = null;
        tokenExpiry = 0;
        try { if (refreshTask != null) { refreshTask.cancel(true); } } catch (Exception ignore) {}
        try { if (configManager != null) configManager.unsetConfiguration("PvPLeaderboard", "pkce_verifier"); } catch (Exception ignore) {}
        try { if (configManager != null) configManager.unsetConfiguration("PvPLeaderboard", "oauth_state"); } catch (Exception ignore) {}
        transientVerifier = null;
        transientState = null;
    }

    private boolean validateIdTokenClaims(String jwt) {
        try {
            String[] parts = jwt.split("\\.");
            if (parts.length < 2) return false;
            String payloadJson = new String(Base64.getUrlDecoder().decode(parts[1]), StandardCharsets.UTF_8);
            JsonObject payload = gson.fromJson(payloadJson, JsonObject.class);

            // Required claims
            String tokenUse = payload.has("token_use") && !payload.get("token_use").isJsonNull() ? payload.get("token_use").getAsString() : null;
            String aud = payload.has("aud") && !payload.get("aud").isJsonNull() ? payload.get("aud").getAsString() : null;
            String iss = payload.has("iss") && !payload.get("iss").isJsonNull() ? payload.get("iss").getAsString() : null;
            long exp = payload.has("exp") && !payload.get("exp").isJsonNull() ? payload.get("exp").getAsLong() : 0L;
            long now = System.currentTimeMillis() / 1000L;

            if (!"id".equalsIgnoreCase(tokenUse)) return false;
            if (aud == null || !aud.equals(CLIENT_ID)) return false;
            if (iss == null || !iss.startsWith("https://cognito-idp.us-east-1.amazonaws.com/")) return false;
            if (exp <= (now - 60)) return false; // allow small skew

            return true;
        } catch (Exception e) {
            return false;
        }
    }

    private synchronized void ensureRefreshScheduler() {
        if (refreshToken == null || refreshToken.isEmpty()) return;
        scheduleNextRefresh();
    }

    private void scheduleNextRefresh() {
        if (scheduler == null) return;
        long now = System.currentTimeMillis();
        // Refresh 60s before expiry; fallback to 55min if expiry unknown
        long target = tokenExpiry > 0 ? (tokenExpiry - 60_000L) : (now + 55L * 60L * 1000L);
        long delayMs = Math.max(5_000L, target - now);
        try { if (refreshTask != null) refreshTask.cancel(true); } catch (Exception ignore) {}
        refreshTask = scheduler.schedule(this::refreshFlow, delayMs, TimeUnit.MILLISECONDS);
    }

    private void refreshFlow() {
        try {
            // If logged out, skip
            if (refreshToken == null || refreshToken.isEmpty()) return;
            // If not close to expiry, reschedule
            long now = System.currentTimeMillis();
            if (tokenExpiry > 0 && now < tokenExpiry - 120_000L) {
                scheduleNextRefresh();
                return;
            }
            refreshWithToken();
        } catch (Exception ignore) {
            // On failure, retry in 2 minutes
            try { if (scheduler != null) scheduler.schedule(this::refreshFlow, 120_000L, TimeUnit.MILLISECONDS); } catch (Exception ignored) {}
            return;
        }
        // On success, schedule next
        scheduleNextRefresh();
    }

    private void refreshWithToken() throws Exception {
        if (refreshToken == null || refreshToken.isEmpty()) throw new IOException("No refresh token");
        String postData =
            "grant_type=" + URLEncoder.encode("refresh_token", "UTF-8") +
            "&client_id=" + URLEncoder.encode(CLIENT_ID, "UTF-8") +
            "&refresh_token=" + URLEncoder.encode(refreshToken, "UTF-8");

        Request req = new Request.Builder()
            .url("https://" + COGNITO_DOMAIN + "/oauth2/token")
            .post(RequestBody.create(MediaType.parse("application/x-www-form-urlencoded"), postData))
            .addHeader("Accept", "application/json")
            .build();

        final java.util.concurrent.CompletableFuture<String> fut = new java.util.concurrent.CompletableFuture<>();
        httpClient.newCall(req).enqueue(new okhttp3.Callback() {
            @Override public void onFailure(okhttp3.Call call, java.io.IOException e) { fut.completeExceptionally(e); }
            @Override public void onResponse(okhttp3.Call call, okhttp3.Response response) throws java.io.IOException {
                try (okhttp3.Response res = response) {
                    if (!res.isSuccessful() || res.body() == null) {
                        fut.completeExceptionally(new IOException("Refresh failed (status=" + res.code() + ")"));
                        return;
                    }
                    okhttp3.ResponseBody rb = res.body();
                    String body = rb != null ? rb.string() : "";
                    fut.complete(body);
                }
            }
        });
        String body = fut.get(10, java.util.concurrent.TimeUnit.SECONDS);

        JsonObject tokens = gson.fromJson(body, JsonObject.class);
        String newAccessToken = tokens.has("access_token") && !tokens.get("access_token").isJsonNull() ? tokens.get("access_token").getAsString() : null;
        String newIdToken = tokens.has("id_token") && !tokens.get("id_token").isJsonNull() ? tokens.get("id_token").getAsString() : null;
        int expiresIn = tokens.has("expires_in") ? tokens.get("expires_in").getAsInt() : 3600;
        if (newAccessToken == null) throw new IOException("No access token in refresh");
        accessToken = newAccessToken;
        if (newIdToken != null) {
            if (!validateIdTokenClaims(newIdToken)) throw new IOException("Invalid refreshed ID token");
            idToken = newIdToken;
        }
        tokenExpiry = System.currentTimeMillis() + (expiresIn * 1000L);
    }

    
    private String extractParam(String query, String param) {
        if (query == null) return null;
        for (String pair : query.split("&")) {
            String[] kv = pair.split("=", 2);
            if (kv.length == 2 && param.equals(kv[0])) {
                try {
                    return URLDecoder.decode(kv[1], "UTF-8");
                } catch (UnsupportedEncodingException e) {
                    return kv[1];
                }
            }
        }
        return null;
    }
}

package com.pvp.leaderboard.service;

public class RankInfo
{
    public final String rank;
    public final int division;
    public final double progress;

    public RankInfo(String rank, int division, double progress)
    {
        this.rank = rank;
        this.division = division;
        this.progress = progress;
    }
}

package com.pvp.leaderboard.service;

import lombok.Builder;
import lombok.Getter;
import lombok.ToString;

@Getter
@Builder
@ToString
public class MatchResult
{
    private final String playerId;
    private final String opponentId;
    private final String result; // "win", "loss", "tie"
    private final int world;
    private final long fightStartTs;
    private final long fightEndTs;
    private final String fightStartSpellbook;
    private final String fightEndSpellbook;
    private final boolean wasInMulti;
    private final String idToken;
    private final long damageToOpponent;
    private final String clientUniqueId;
}

package com.pvp.leaderboard;

import org.junit.Test;
import org.junit.Ignore;

public class MatchResultServiceTest
{
    @Ignore("Network/API tests disabled in unit context; migration to injected clients")
    @Test
    public void testUnauthenticatedMatchSubmission() throws Exception {}

    @Ignore("Network/API tests disabled in unit context; migration to injected clients")
    @Test
    public void testAuthenticatedMatchSubmission() throws Exception {}
}
package com.pvp.leaderboard;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.pvp.leaderboard.config.PvPLeaderboardConfig;
import com.pvp.leaderboard.service.PvPDataService;
import okhttp3.*;
import org.junit.Before;
import org.junit.Test;

import java.io.IOException;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

import static org.junit.Assert.*;

public class PvPDataServiceTest {

    private OkHttpClient okHttpClient;
    private TestInterceptor testInterceptor;
    private PvPLeaderboardConfig config;
    private PvPDataService dataService;
    private final Gson gson = new Gson();

    // Fake data for testing
    private static final String FAKE_PLAYER_ID = "TestPlayer_123";
    private static final String FAKE_UUID = "550e8400-e29b-41d4-a716-446655440000";
    private static final String FAKE_OPPONENT = "BadGuy_999";

    @Before
    public void setUp() {
        testInterceptor = new TestInterceptor();
        okHttpClient = new OkHttpClient.Builder()
                .addInterceptor(testInterceptor)
                .build();
        config = new MockConfig();
        // authService and clientIdentityService are unused in tests, passing null
        dataService = new PvPDataService(okHttpClient, gson, null, config, null);
    }

    @Test
    public void testGetPlayerMatches_Success() throws ExecutionException, InterruptedException, IOException {
        // Prepare fake response
        JsonObject fakeResponseJson = new JsonObject();
        fakeResponseJson.addProperty("player_id", FAKE_PLAYER_ID);
        // Add a fake match
        JsonObject match = new JsonObject();
        match.addProperty("opponent", FAKE_OPPONENT);
        match.addProperty("result", "win");
        match.addProperty("match_id", FAKE_UUID);
        
        com.google.gson.JsonArray matchesArray = new com.google.gson.JsonArray();
        matchesArray.add(match);
        fakeResponseJson.add("matches", matchesArray);

        testInterceptor.setNextResponse(200, gson.toJson(fakeResponseJson));

        // Execute
        CompletableFuture<JsonObject> future = dataService.getPlayerMatches(FAKE_PLAYER_ID, null, 10);
        JsonObject result = future.get();

        // Verify
        assertNotNull(result);
        assertEquals(FAKE_PLAYER_ID, result.get("player_id").getAsString());
        assertEquals(1, result.getAsJsonArray("matches").size());
        assertEquals(FAKE_OPPONENT, result.getAsJsonArray("matches").get(0).getAsJsonObject().get("opponent").getAsString());
        
        // Verify URL parameters
        assertNotNull(testInterceptor.getLastRequest());
        assertTrue(testInterceptor.getLastRequest().url().toString().contains("player_id=" + FAKE_PLAYER_ID));
    }

    @Test
    public void testGetPlayerTier_Success() throws ExecutionException, InterruptedException, IOException {
        // Prepare fake response
        JsonObject fakeTierJson = new JsonObject();
        fakeTierJson.addProperty("player_id", FAKE_PLAYER_ID);
        fakeTierJson.addProperty("tier", "Diamond I");
        fakeTierJson.addProperty("bucket", "nh");

        testInterceptor.setNextResponse(200, gson.toJson(fakeTierJson));

        // Execute
        CompletableFuture<String> future = dataService.getPlayerTier(FAKE_PLAYER_ID, "nh");
        String tier = future.get();

        // Verify
        assertEquals("Diamond I", tier);
    }

    @Test
    public void testGetPlayerTier_NotFound() throws ExecutionException, InterruptedException, IOException {
        testInterceptor.setNextResponse(404, "");

        // Execute
        CompletableFuture<String> future = dataService.getPlayerTier(FAKE_PLAYER_ID, "nh");
        String tier = future.get();

        // Verify
        assertNull(tier);
    }

    @Test
    public void testGetRankIndex_Success() throws ExecutionException, InterruptedException, IOException {
        JsonObject fakeRankJson = new JsonObject();
        fakeRankJson.addProperty("rank", 42);

        testInterceptor.setNextResponse(200, gson.toJson(fakeRankJson));

        // Execute
        CompletableFuture<Integer> future = dataService.getRankIndex(FAKE_PLAYER_ID, "nh");
        Integer rank = future.get();

        assertEquals(42, rank.intValue());
    }

    @Test
    public void testGetUserProfile_Success() throws ExecutionException, InterruptedException, IOException {
        JsonObject fakeProfile = new JsonObject();
        fakeProfile.addProperty("player_id", FAKE_PLAYER_ID);
        fakeProfile.addProperty("mmr", 1500.5);

        testInterceptor.setNextResponse(200, gson.toJson(fakeProfile));

        // Execute
        CompletableFuture<JsonObject> future = dataService.getUserProfile(FAKE_PLAYER_ID, "unique-id");
        JsonObject result = future.get();

        assertNotNull(result);
        assertEquals(FAKE_PLAYER_ID, result.get("player_id").getAsString());
        assertEquals(1500.5, result.get("mmr").getAsDouble(), 0.001);
    }

    @Test
    public void testGenerateAcctSha_ValidFormat() throws Exception {
        // Test SHA256 hash generation for UUID -> acct_sha conversion
        String hash = dataService.generateAcctSha("550e8400-e29b-41d4-a716-446655440000");
        assertNotNull(hash);
        assertEquals(64, hash.length()); // SHA256 produces 64 hex chars
        assertTrue(hash.matches("[0-9a-f]{64}")); // All lowercase hex
        
        // Verify same input produces same hash (deterministic)
        String hash2 = dataService.generateAcctSha("550e8400-e29b-41d4-a716-446655440000");
        assertEquals(hash, hash2);
        
        // Verify different inputs produce different hashes
        String otherHash = dataService.generateAcctSha("660e8400-e29b-41d4-a716-446655440001");
        assertNotEquals(hash, otherHash);
    }

    @Test
    public void testShardKeyFromName_FirstTwoChars() {
        // Verify shard key is first 2 chars of lowercase name, NOT SHA256
        // These match the expected behavior after the shard key change
        assertEquals("to", getShardKeyForName("Toyco"));
        assertEquals("to", getShardKeyForName("toyco"));
        assertEquals("mo", getShardKeyForName("MOH JO JOJO"));
        assertEquals("te", getShardKeyForName("test_account1"));
        assertEquals("a", getShardKeyForName("A")); // Single char edge case
    }
    
    private String getShardKeyForName(String name) {
        // Replicate the shard key logic from PvPDataService.getShardRankByName()
        String canonicalName = name.toLowerCase().trim().replaceAll("\\s+", " ");
        return canonicalName.length() >= 2 
            ? canonicalName.substring(0, 2).toLowerCase() 
            : canonicalName.toLowerCase();
    }

    // -- Mock Classes --

    private class TestInterceptor implements Interceptor {
        private int code;
        private String body;
        private Request lastRequest;

        public void setNextResponse(int code, String body) {
            this.code = code;
            this.body = body;
        }

        public Request getLastRequest() {
            return lastRequest;
        }

        @Override
        public Response intercept(Chain chain) throws IOException {
            lastRequest = chain.request();
            if (code == 0) throw new IOException("No mock response configured");
            
            return new Response.Builder()
                    .request(lastRequest)
                    .protocol(Protocol.HTTP_1_1)
                    .code(code)
                    .message(code == 200 ? "OK" : "Error")
                    .body(ResponseBody.create(MediaType.parse("application/json"), body != null ? body : ""))
                    .build();
        }
    }
    
    private class MockConfig implements PvPLeaderboardConfig {
        @Override
        public boolean enablePvpLookupMenu() { return false; }
    }
}

package com.pvp.leaderboard;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;
import net.runelite.client.plugins.Plugin;

public class PvPLeaderboardPluginTest
{

    public static void main(String[] args) throws Exception
	{
		loadPlugins(PvPLeaderboardPlugin.class);
		RuneLite.main(args);
	}

    @SafeVarargs
    private static void loadPlugins(Class<? extends Plugin>... plugins)
    {
        ExternalPluginManager.loadBuiltin(plugins);
    }
}


