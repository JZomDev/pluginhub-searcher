package com.pvp.leaderboard.util;

import com.google.gson.JsonObject;
import com.pvp.leaderboard.service.RankInfo;
import java.awt.Color;
import java.util.HashMap;
import java.util.Map;
import java.util.Arrays;

public class RankUtils
{
    private static final Map<String, Color> RANK_COLORS = new HashMap<>();

    public static final String[][] THRESHOLDS = {
        {"Bronze", "3", "0"}, {"Bronze", "2", "170"}, {"Bronze", "1", "240"},
        {"Iron", "3", "310"}, {"Iron", "2", "380"}, {"Iron", "1", "450"},
        {"Steel", "3", "520"}, {"Steel", "2", "590"}, {"Steel", "1", "660"},
        {"Black", "3", "730"}, {"Black", "2", "800"}, {"Black", "1", "870"},
        {"Mithril", "3", "940"}, {"Mithril", "2", "1010"}, {"Mithril", "1", "1080"},
        {"Adamant", "3", "1150"}, {"Adamant", "2", "1250"}, {"Adamant", "1", "1350"},
        {"Rune", "3", "1450"}, {"Rune", "2", "1550"}, {"Rune", "1", "1650"},
        {"Dragon", "3", "1750"}, {"Dragon", "2", "1850"}, {"Dragon", "1", "1950"},
        {"3rd Age", "0", "2100"}
    };

    static
    {
        RANK_COLORS.put("Bronze", new Color(184, 115, 51));
        RANK_COLORS.put("Iron", new Color(192, 192, 192));
        RANK_COLORS.put("Steel", new Color(154, 162, 166));
        RANK_COLORS.put("Black", Color.GRAY);
        RANK_COLORS.put("Mithril", new Color(59, 167, 214));
        RANK_COLORS.put("Adamant", new Color(26, 139, 111));
        RANK_COLORS.put("Rune", new Color(78, 159, 227));
        RANK_COLORS.put("Dragon", new Color(229, 57, 53));
        RANK_COLORS.put("3rd", new Color(229, 193, 0));
    }

    public static Color getRankColor(String rankName)
    {
        if (rankName == null) return new Color(102, 102, 102);
        String baseName = rankName.split(" ")[0];
        return RANK_COLORS.getOrDefault(baseName, new Color(102, 102, 102));
    }

    public static Color getRankTextColor(String rankName, boolean colorBlindMode)
    {
        if (colorBlindMode) return Color.WHITE;
        return getRankColor(rankName);
    }

    public static String formatTierLabel(String raw)
    {
        if (raw == null) return null;
        String s = raw.trim();
        if (s.equalsIgnoreCase("3rdAge")) return "3rd Age";
        return s.replaceAll("([A-Za-z]+)(\\d+)$", "$1 $2");
    }

    public static boolean isUnrankedOrDefault(JsonObject obj)
    {
        if (obj == null) return true;
        // Check for 0 MMR
        double mmr = 0.0;
        if (obj.has("mmr") && !obj.get("mmr").isJsonNull())
        {
            mmr = obj.get("mmr").getAsDouble();
        }

        // Check for Bronze 3 rank
        String rank = "";
        int div = 0;
        if (obj.has("rank") && !obj.get("rank").isJsonNull())
        {
            rank = obj.get("rank").getAsString();
        }
        if (obj.has("division") && !obj.get("division").isJsonNull())
        {
            div = obj.get("division").getAsInt();
        }

        // If it looks like default initialization (Bronze 3, 0 MMR), treat as unranked
        if (Math.abs(mmr) < 0.001 && "Bronze".equalsIgnoreCase(rank) && div == 3)
        {
            return true;
        }

        return false;
    }

    public static RankInfo rankLabelAndProgressFromMMR(double mmrVal)
    {
        // Do not arbitrarily treat 0 as null; 0 is a valid MMR (Bronze 3).
        // The caller is responsible for determining if data is missing (e.g. JSON missing "mmr" field).

        String[][] thresholds = THRESHOLDS;

        double v = mmrVal;
        String[] curr = thresholds[0];
        for (String[] t : thresholds)
        {
            if (v >= Double.parseDouble(t[2])) curr = t;
            else break;
        }

        int idx = -1;
        for (int i = 0; i < thresholds.length; i++)
        {
            if (thresholds[i][0].equals(curr[0]) && thresholds[i][1].equals(curr[1]) && thresholds[i][2].equals(curr[2]))
            {
                idx = i;
                break;
            }
        }

        String[] next = idx >= 0 && idx < thresholds.length - 1 ? thresholds[idx + 1] : curr;
        double pct = curr[0].equals("3rd Age") ? 100 :
            Math.max(0, Math.min(100, ((v - Double.parseDouble(curr[2])) / Math.max(1, Double.parseDouble(next[2]) - Double.parseDouble(curr[2]))) * 100));

        return new RankInfo(curr[0], Integer.parseInt(curr[1]), pct);
    }

    public static double calculateTierValue(double mmr)
    {
        // 0 MMR is valid (bottom of Bronze 3). Do not short-circuit.
        String[][] thresholds = THRESHOLDS;

        String[] current = thresholds[0];
        for (String[] threshold : thresholds)
        {
            if (mmr >= Double.parseDouble(threshold[2]))
            {
                current = threshold;
            }
            else
            {
                break;
            }
        }

        // Convert to percentage for graph display
        String[] tiers = {"Bronze", "Iron", "Steel", "Black", "Mithril", "Adamant", "Rune", "Dragon", "3rd Age"};
        for (int i = 0; i < tiers.length; i++)
        {
            if (tiers[i].equals(current[0]))
            {
                return (i * 100.0 / tiers.length) + (Integer.parseInt(current[1]) * 10.0 / tiers.length);
            }
        }
        return 0;
    }

    // Encode MMR to rank-scale value (baseIndex*3 + divisionOffset + progress)
    // Returns 0.0 to 24.0+
    public static double calculateContinuousTierValue(double mmr) {
        final String[] ORDER = {"Bronze","Iron","Steel","Black","Mithril","Adamant","Rune","Dragon","3rd Age"};
        double v = mmr;
        String[] curr = THRESHOLDS[0];
        for (String[] t : THRESHOLDS) { if (v >= Double.parseDouble(t[2])) curr = t; else break; }
        
        int idxCurr = -1;
        for (int i = 0; i < THRESHOLDS.length; i++) {
            if (Arrays.equals(THRESHOLDS[i], curr)) { idxCurr = i; break; }
        }
        
        String[] next = THRESHOLDS[Math.min(idxCurr + 1, THRESHOLDS.length - 1)];
        int baseIdx = 0;
        for (int i = 0; i < ORDER.length; i++) { if (ORDER[i].equals(curr[0])) { baseIdx = i; break; } }
        int div = "3rd Age".equals(curr[0]) ? 0 : Integer.parseInt(curr[1]);
        int divOffset = "3rd Age".equals(curr[0]) ? 0 : (3 - div);
        double tierBase = baseIdx * 3 + divOffset;
        if ("3rd Age".equals(curr[0])) return tierBase;
        double span = Math.max(1.0, Double.parseDouble(next[2]) - Double.parseDouble(curr[2]));
        double prog = Math.max(0.0, Math.min(1.0, (v - Double.parseDouble(curr[2])) / span));
        return tierBase + prog;
    }

    public static double calculateProgressFromMMR(double mmr)
    {
        String[][] thresholds = THRESHOLDS;

        String[] current = thresholds[0];
        for (String[] threshold : thresholds)
        {
            if (mmr >= Double.parseDouble(threshold[2]))
            {
                current = threshold;
            }
            else
            {
                break;
            }
        }

        if ("3rd Age".equals(current[0]))
        {
            return 100.0;
        }

        int currentIndex = -1;
        for (int i = 0; i < thresholds.length; i++)
        {
            if (thresholds[i][0].equals(current[0]) && thresholds[i][1].equals(current[1]))
            {
                currentIndex = i;
                break;
            }
        }

        if (currentIndex >= 0 && currentIndex < thresholds.length - 1)
        {
            double currentThreshold = Double.parseDouble(current[2]);
            double nextThreshold = Double.parseDouble(thresholds[currentIndex + 1][2]);
            double span = nextThreshold - currentThreshold;
            return Math.max(0, Math.min(100, ((mmr - currentThreshold) / span) * 100));
        }

        return 0.0;
    }

    public static int getRankIndex(String rank, int division)
    {
        String[][] thresholds = THRESHOLDS;

        for (int i = 0; i < thresholds.length; i++)
        {
            if (thresholds[i][0].equals(rank) && Integer.parseInt(thresholds[i][1]) == division)
            {
                return i;
            }
        }
        return 0;
    }

    public static int getRankOrder(String rank)
    {
        String[] parts = rank.split(" ");
        String baseName = parts[0];
        int division = parts.length > 1 ? Integer.parseInt(parts[1]) : 0;

        int baseOrder;
        switch (baseName) {
            case "Bronze":
                baseOrder = 0;
                break;
            case "Iron":
                baseOrder = 1;
                break;
            case "Steel":
                baseOrder = 2;
                break;
            case "Black":
                baseOrder = 3;
                break;
            case "Mithril":
                baseOrder = 4;
                break;
            case "Adamant":
                baseOrder = 5;
                break;
            case "Rune":
                baseOrder = 6;
                break;
            case "Dragon":
                baseOrder = 7;
                break;
            case "3rd Age":
                baseOrder = 8;
                break;
            default:
                baseOrder = -1;
                break;
        }

        return baseOrder * 10 + (4 - division);
    }
}

package com.pvp.leaderboard.util;

import java.util.Locale;

public final class NameUtils
{
	private NameUtils() {}

	public static String normalizeDisplayName(String name)
	{
		if (name == null)
		{
			return "";
		}
		return name.trim().replaceAll("\\s+", " ");
	}

	public static String canonicalKey(String name)
	{
		String display = normalizeDisplayName(name);
		// Treat names case-insensitively for lookups, caching and API queries
		return display.toLowerCase(Locale.ROOT);
	}
}

package com.pvp.leaderboard.cache;

import com.google.gson.JsonObject;

public class UserStatsCache
{
    private final JsonObject stats;
    private final long timestamp;

    public UserStatsCache(JsonObject stats, long timestamp)
    {
        this.stats = stats;
        this.timestamp = timestamp;
    }

    public JsonObject getStats()
    {
        return stats;
    }

    public long getTimestamp()
    {
        return timestamp;
    }
}


package com.pvp.leaderboard.cache;

import com.google.gson.JsonObject;

public class ShardEntry
{
    private final JsonObject payload;
    private final long timestamp;

    public ShardEntry(JsonObject payload, long timestamp)
    {
        this.payload = payload;
        this.timestamp = timestamp;
    }

    public JsonObject getPayload()
    {
        return payload;
    }

    public long getTimestamp()
    {
        return timestamp;
    }
}


package com.pvp.leaderboard.cache;

public class WorldRankCache
{
    private final int worldRank;
    private final long timestamp;

    public WorldRankCache(int worldRank, long timestamp)
    {
        this.worldRank = worldRank;
        this.timestamp = timestamp;
    }

    public int getWorldRank()
    {
        return worldRank;
    }

    public long getTimestamp()
    {
        return timestamp;
    }
}


package com.pvp.leaderboard.cache;

import com.google.gson.JsonObject;

public class MatchesCacheEntry
{
    private final JsonObject response;
    private final long timestamp;

    public MatchesCacheEntry(JsonObject response, long timestamp)
    {
        this.response = response;
        this.timestamp = timestamp;
    }

    public JsonObject getResponse()
    {
        return response;
    }

    public long getTimestamp()
    {
        return timestamp;
    }
}


package com.pvp.leaderboard.game;

import com.pvp.leaderboard.config.PvPLeaderboardConfig;
import com.pvp.leaderboard.overlay.RankOverlay;
import com.pvp.leaderboard.ui.DashboardPanel;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.SwingUtilities;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.MenuAction;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.client.menus.MenuManager;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.Text;

@Slf4j
@Singleton
public class MenuHandler
{
    private final PvPLeaderboardConfig config;
    private final MenuManager menuManager;
    private final ClientToolbar clientToolbar;

    // Dependencies set after startup via init/update
    private DashboardPanel dashboardPanel;
    private RankOverlay rankOverlay;
    private NavigationButton navButton;

    @Inject
    public MenuHandler(PvPLeaderboardConfig config, MenuManager menuManager, ClientToolbar clientToolbar)
    {
        this.config = config;
        this.menuManager = menuManager;
        this.clientToolbar = clientToolbar;
    }

    public void init(DashboardPanel dashboardPanel, RankOverlay rankOverlay, NavigationButton navButton)
    {
        this.dashboardPanel = dashboardPanel;
        this.rankOverlay = rankOverlay;
        this.navButton = navButton;
        
        refreshMenuOption();
    }

    public void updateNavButton(NavigationButton navButton)
    {
        this.navButton = navButton;
    }

    public void refreshMenuOption()
    {
        try {
            if (config.enablePvpLookupMenu()) {
                menuManager.addPlayerMenuItem("pvp lookup");
            } else {
                menuManager.removePlayerMenuItem("pvp lookup");
            }
        } catch (Exception ignore) {}
    }

    public void shutdown()
    {
        menuManager.removePlayerMenuItem("pvp lookup");
    }

    public void handleMenuOptionClicked(MenuOptionClicked event)
    {
        try
        {
            if (!config.enablePvpLookupMenu()) {
                return;
            }
            if (event.getMenuAction() != MenuAction.RUNELITE_PLAYER) {
                return;
            }
            if (!"pvp lookup".equals(event.getMenuOption())) {
                return;
            }

            String target = event.getMenuTarget();
            if (target == null) {
                return;
            }

            String cleaned = Text.removeTags(target);
            // Remove trailing (level-xxx)
            cleaned = cleaned.replaceAll("\\s*\\(level-\\d+\\)$", "");
            // Remove any parenthetical annotation like (Skill 1234)
            cleaned = cleaned.replaceAll("\\([^)]*\\)", "");
            // Normalize without converting underscores/hyphens to spaces
            // (RuneScape treats space, underscore, hyphen as equivalent, but we preserve original format)
            String playerName = cleaned.replace('\u00A0', ' ').trim().replaceAll("\\s+", " ");

            if (dashboardPanel != null) {
                dashboardPanel.loadMatchHistory(playerName);
            }

            // Open plugin side panel
            if (clientToolbar != null && navButton != null) {
                SwingUtilities.invokeLater(() -> clientToolbar.openPanel(navButton));
            }
        }
        catch (Exception e)
        {
             // log.debug("Uncaught exception in handleMenuOptionClicked", e);
        }
    }
}

package com.pvp.leaderboard.game;

import com.google.gson.JsonObject;
import com.pvp.leaderboard.config.PvPLeaderboardConfig;
import com.pvp.leaderboard.overlay.RankOverlay;
import com.pvp.leaderboard.service.ClientIdentityService;
import com.pvp.leaderboard.service.CognitoAuthService;
import com.pvp.leaderboard.service.MatchResult;
import com.pvp.leaderboard.service.MatchResultService;
import com.pvp.leaderboard.service.PvPDataService;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.atomic.AtomicLong;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.HitsplatID;
import net.runelite.api.Player;
import net.runelite.api.Varbits;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.client.config.ConfigManager;

@Slf4j
@Singleton
@SuppressWarnings("deprecation")
public class FightMonitor
{
    private final Client client;
    private final PvPLeaderboardConfig config;
    private final ConfigManager configManager;
    private final ScheduledExecutorService scheduler;
    private final MatchResultService matchResultService;
    private final PvPDataService pvpDataService;
    private final CognitoAuthService cognitoAuthService;
    private final ClientIdentityService clientIdentityService;

    // RankOverlay reference for MMR notifications
    private RankOverlay rankOverlay;

    // --- Fight State ---
    private boolean inFight = false;
    private boolean wasInMulti = false;
    private int fightStartSpellbook = -1;
    private String opponent = null;
    private volatile String lastExactOpponentName = null;
    private long fightStartTime = 0;

    // Tracks multiple simultaneous fights (per-opponent) - damage is now tracked per-FightEntry
    private final ConcurrentHashMap<String, FightEntry> activeFights = new ConcurrentHashMap<>();
    
    // Tick counters
    private int suppressFightStartTicks = 0;
    private final ConcurrentHashMap<String, Integer> perOpponentSuppressUntilTicks = new ConcurrentHashMap<>();
    private final ConcurrentHashMap<String, Boolean> shardPresence = new ConcurrentHashMap<>();
    
    private volatile int lastCombatActivityTick = 0;
    private static final int OUT_OF_COMBAT_TICKS = 16;
    private int gcTicksCounter = 0;

    // MMR tracking - no longer using pre-fight profile, using match history API instead

    @Inject
    public FightMonitor(
        Client client,
        PvPLeaderboardConfig config,
        ConfigManager configManager,
        ScheduledExecutorService scheduler,
        MatchResultService matchResultService,
        PvPDataService pvpDataService,
        CognitoAuthService cognitoAuthService,
        ClientIdentityService clientIdentityService)
    {
        this.client = client;
        this.config = config;
        this.configManager = configManager;
        this.scheduler = scheduler;
        this.matchResultService = matchResultService;
        this.pvpDataService = pvpDataService;
        this.cognitoAuthService = cognitoAuthService;
        this.clientIdentityService = clientIdentityService;
    }

    /**
     * Initialize with RankOverlay for MMR change notifications.
     */
    public void init(RankOverlay rankOverlay)
    {
        this.rankOverlay = rankOverlay;
    }

    public void resetFightState()
    {
        inFight = false;
        wasInMulti = false;
        fightStartSpellbook = -1;
        opponent = null;
        fightStartTime = 0;
        suppressFightStartTicks = 2;
        activeFights.clear();
        perOpponentSuppressUntilTicks.clear();
        shardPresence.clear();
        lastCombatActivityTick = 0;
        lastExactOpponentName = null;
        try { log.debug("[Fight] state reset; suppressTicks={}", suppressFightStartTicks); } catch (Exception ignore) {}
    }
    
    /**
     * Clear only a specific fight without affecting other ongoing fights.
     * Used when a fight ends but other multi-combat fights continue.
     */
    private void clearFightFor(String opponentName)
    {
        activeFights.remove(opponentName);
        perOpponentSuppressUntilTicks.put(opponentName, 5);
        shardPresence.remove(opponentName);
        
        // Only reset global state if ALL fights are done
        if (activeFights.isEmpty())
        {
            inFight = false;
            wasInMulti = false;
            fightStartSpellbook = -1;
            opponent = null;
            fightStartTime = 0;
            suppressFightStartTicks = 2;
        }
        else
        {
            inFight = true;
        }
    }

    public void handleGameTick(GameTick tick)
    {
        try
        {
            // Handle fight suppression ticks
            if (suppressFightStartTicks > 0)
            {
                suppressFightStartTicks--;
            }

            // Handle per-opponent suppression ticks
            if (!perOpponentSuppressUntilTicks.isEmpty())
            {
                java.util.List<String> toRemove = new java.util.ArrayList<>();
                perOpponentSuppressUntilTicks.forEach((name, ticks) -> {
                    if (ticks <= 1) {
                        toRemove.add(name);
                    } else {
                        perOpponentSuppressUntilTicks.put(name, ticks - 1);
                    }
                });
                toRemove.forEach(perOpponentSuppressUntilTicks::remove);
            }

            // Handle GC (every 33 ticks approx 20s)
            gcTicksCounter++;
            if (gcTicksCounter >= 33)
            {
                gcTicksCounter = 0;
                long now = System.currentTimeMillis();
                activeFights.entrySet().removeIf(e -> {
                    FightEntry fe = e.getValue();
                    if (fe == null) return true;
                    if (!fe.finalized && now - fe.lastActivityMs > 10_000L) {
                        return true;
                    }
                    return false;
                });
                inFight = !activeFights.isEmpty();
            }

            // Combat window idle check - individual fight expiration is handled by GC above
            // No global damage maps to clear anymore; damage is per-FightEntry
        }
        catch (Exception e)
        {
            // log.error("Uncaught exception in FightMonitor.onGameTick", e);
        }
    }

    public void handleHitsplatApplied(HitsplatApplied event)
    {
        try
        {
            if (!(event.getActor() instanceof Player)) return;
            if (client == null || config == null) return;

            Player hitPlayer = (Player) event.getActor();
            Player localPlayer = client.getLocalPlayer();
            if (localPlayer == null) return;

            net.runelite.api.Hitsplat hs = event.getHitsplat();
            if (hs == null) return;

            int hitsplatType = hs.getHitsplatType();
            int amt = hs.getAmount();
            boolean isMine = hs.isMine();
            String hitPlayerName = hitPlayer.getName();
            String localPlayerName = localPlayer.getName();
            
            // Get hitsplat type name for logging
            String hitsplatTypeName = getHitsplatTypeName(hitsplatType);

            // Only process relevant damage hitsplat types
            if (amt > 0)
            {
                if (!(hitsplatType == HitsplatID.DAMAGE_ME
                    || hitsplatType == HitsplatID.DAMAGE_OTHER
                    || hitsplatType == HitsplatID.POISON
                    || hitsplatType == HitsplatID.VENOM))
                {
                    return;
                }
            }
            
            // Determine if this should start/continue a fight
            // For inbound damage (on us): any damage from opponent starts the fight
            // For outbound damage (on them): only OUR hitsplats count
            boolean isDamageHitsplat = (amt > 0) && 
                (hitsplatType == HitsplatID.DAMAGE_ME || hitsplatType == HitsplatID.DAMAGE_OTHER);
            
            // Check if this is OUR damage - either isMine is true OR hitsplatType is DAMAGE_ME
            // DAMAGE_ME is the red hitsplat type shown specifically for YOUR damage on others
            // We check both because isMine can sometimes be incorrectly false
            boolean isOurDamage = isMine || (hitsplatType == HitsplatID.DAMAGE_ME);

            // Debug log every hitsplat on players (commented out - enable for debugging)
            // boolean isOnUs = (hitPlayer == localPlayer);
            // if (amt > 0) {
            //     log.debug("[Hitsplat] {} on={} amt={} type={} isMine={} isOurDmg={}", 
            //         isOnUs ? "INBOUND" : "OUTBOUND",
            //         hitPlayerName,
            //         amt,
            //         hitsplatTypeName,
            //         isMine,
            //         isOurDamage);
            // }

            String opponentName = null;
            boolean startNow = false;

            if (hitPlayer == localPlayer)
            {
                // Hitsplat on us = opponent dealt damage to us (inbound)
                opponentName = resolveInboundAttacker(localPlayer);
                if (opponentName != null)
                {
                    lastExactOpponentName = opponentName;
                    if (isDamageHitsplat) startNow = true;
                }
            }
            else
            {
                // Hitsplat on another player (outbound)
                if (hitPlayerName == null) return;

                // If this is OUR damage (DAMAGE_ME type), this player is definitely our opponent
                // Don't rely on getInteracting() which can be unreliable in chaotic multi-combat
                if (isOurDamage && isDamageHitsplat)
                {
                    opponentName = hitPlayerName;
                    startNow = true;
                }
                else
                {
                    // For non-damage hitsplats or other players' damage, use targeting checks
                    boolean isActiveOpponent = activeFights.containsKey(hitPlayerName);
                    Player interacting = (Player) localPlayer.getInteracting();
                    boolean isCurrentTarget = interacting != null && interacting == hitPlayer;
                    Player theirTarget = (Player) hitPlayer.getInteracting();
                    boolean isTargetingUs = theirTarget != null && theirTarget == localPlayer;

                    if (isActiveOpponent || isCurrentTarget || isTargetingUs)
                    {
                        opponentName = hitPlayerName;
                    }
                }
            }

            // Handle fight start/continuation
            boolean validOpp = (opponentName != null && isPlayerOpponent(opponentName));
            if (startNow && opponentName != null && validOpp)
            {
                int tickNow = client.getTickCount();

                if (opponentName.equals(localPlayer.getName())) return;
                if (suppressFightStartTicks > 0) return;
                if (perOpponentSuppressUntilTicks.containsKey(opponentName)) return;

                // Check if THIS opponent's fight is stale (no activity for 16+ ticks)
                // If stale, remove only this opponent's fight entry so a fresh one is created
                FightEntry existingFight = activeFights.get(opponentName);
                if (existingFight != null && existingFight.isStale(tickNow, OUT_OF_COMBAT_TICKS))
                {
                    // log.debug("[FightStale] Clearing stale fight for {} (lastTick={} currentTick={} gap={})", 
                    //     opponentName, existingFight.lastActivityTick, tickNow, 
                    //     tickNow - existingFight.lastActivityTick);
                    activeFights.remove(opponentName);
                    existingFight = null;
                }

                boolean isNewFight = (existingFight == null);
                touchFight(opponentName);
                inFight = true;
                if (!inFight) startFight(opponentName);
                
                // Check if LOCAL player is in multi - if so, mark this fight as multi
                // This ensures if YOU ever enter multi during the fight, it counts as multi
                // But if opponent dies in multi while you stayed in singles, it's a singles kill
                boolean localPlayerInMulti = client.getVarbitValue(Varbits.MULTICOMBAT_AREA) == 1;
                if (localPlayerInMulti) {
                    wasInMulti = true;
                    // Also update the per-opponent FightEntry
                    FightEntry fe = activeFights.get(opponentName);
                    if (fe != null) {
                        fe.markMultiIfNeeded(true);
                    }
                }
                
                // if (isNewFight)
                // {
                //     log.debug("[FightStart] NEW fight with opponent={}", opponentName);
                // }
            }

            // Add the damage to per-fight tracking in FightEntry
            if (opponentName != null && amt > 0)
            {
                FightEntry fe = activeFights.get(opponentName);
                if (fe != null)
                {
                    int currentTick = client.getTickCount();
                    
                    if (hitPlayer == localPlayer)
                    {
                        // Damage received from opponent
                        fe.addDamageReceived(amt, currentTick);
                        // log.debug("[DmgTrack] RECEIVED {} from {} (total received: {})", 
                        //     amt, opponentName, fe.damageReceived.get());
                    }
                    else if (isOurDamage)
                    {
                        // Count damage dealt if it's OUR damage (isMine=true OR type=DAMAGE_ME)
                        fe.addDamageDealt(amt, currentTick);
                        // log.debug("[DmgTrack] DEALT {} to {} (total dealt: {}) [isMine={} type={}]", 
                        //     amt, opponentName, fe.damageDealt.get(), isMine, hitsplatTypeName);
                    }
                    // else
                    // {
                    //     // Not our damage - log why we're NOT counting it
                    //     log.debug("[DmgTrack] SKIPPED {} on {} - not our damage (isMine={} type={})", 
                    //         amt, opponentName, isMine, hitsplatTypeName);
                    // }
                }
                // else
                // {
                //     // No FightEntry yet
                //     log.debug("[DmgTrack] NO_ENTRY {} on {} - FightEntry doesn't exist yet", 
                //         amt, hitPlayerName);
                // }
            }
            // else if (amt > 0 && opponentName == null)
            // {
            //     // Hitsplat on player but no opponent resolved
            //     log.debug("[DmgTrack] NO_OPPONENT {} on {} - couldn't resolve as opponent", 
            //         amt, hitPlayerName);
            // }
        }
        catch (Exception e)
        {
            // log.debug("Uncaught exception in FightMonitor.onHitsplatApplied", e);
        }
    }

    public void handleActorDeath(ActorDeath event)
    {
        try
        {
            if (!(event.getActor() instanceof Player)) return;
            Player player = (Player) event.getActor();
            Player localPlayer = client.getLocalPlayer();

            if (player == localPlayer)
            {
                // Self death - find who killed us
                // Priority: whoever dealt the most damage to us gets the kill credit
                // This is the best approximation since the actual killer might have the plugin
                // and would submit the correct result from their side
                String killer = findKillerByDamage();
                
                // Fallbacks if no damage was tracked
                if (killer == null) killer = findActualKiller(localPlayer);
                if (killer == null) killer = opponent;
                if (killer == null) killer = mostRecentActiveOpponent();

                // Log the killer determination for debugging
                // log.debug("[Death] Self death - killer={} (determined by most damage received)", killer);

                // Submit loss against the killer
                if (killer != null)
                {
                    endFightFor(killer, "loss");
                }
                
                // Clear remaining fights without submitting (we died, they didn't kill us)
                for (String remaining : new ArrayList<>(activeFights.keySet()))
                {
                    clearFightFor(remaining);
                }
                
                // Ensure full reset after self-death
                resetFightState();
            }
            else
            {
                // Other player death
                String name = player.getName();
                if (name != null)
                {
                    FightEntry fe = activeFights.get(name);
                    // Only count as a win if we have an active fight AND dealt actual damage
                    // This prevents counting kills where we just clicked on someone but didn't attack
                    if (fe != null && fe.damageDealt.get() > 0)
                    {
                        endFightFor(name, "win");
                    }
                }
            }
        }
        catch (Exception e)
        {
            // log.debug("Uncaught exception in FightMonitor.onActorDeath", e);
        }
    }

    private void startFight(String opponentName)
    {
        inFight = true;
        opponent = opponentName;
        wasInMulti = client.getVarbitValue(Varbits.MULTICOMBAT_AREA) == 1;
        fightStartSpellbook = client.getVarbitValue(Varbits.SPELLBOOK);
        fightStartTime = System.currentTimeMillis() / 1000;
    }

    private void endFightFor(String opponentName, String result)
    {
        FightEntry fe = activeFights.get(opponentName);
        if (fe == null || fe.finalized) return;
        
        // Log final damage totals before finalizing
        // log.debug("[FightEnd] opponent={} result={} FINAL_DMG_DEALT={} FINAL_DMG_RECEIVED={}", 
        //     opponentName, result, fe.damageDealt.get(), fe.damageReceived.get());
        
        fe.finalized = true;
        finalizeFight(opponentName, result, fe);
        clearFightFor(opponentName);  // Use targeted clear instead of resetFightState
    }

    private void finalizeFight(String opponentName, String result, FightEntry entry)
    {
        if (entry == null) return;  // Require valid FightEntry for accurate data
        
        final int currentSpellbook = client.getVarbitValue(Varbits.SPELLBOOK);
        final int world = client.getWorld();
        final long now = System.currentTimeMillis() / 1000;
        final String selfName = getLocalPlayerName();
        final String idTokenSafe = cognitoAuthService.getStoredIdToken();

        // Ensure valid timestamps - never send 0
        // If start wasn't captured, set it to 60 seconds before end
        // If end is somehow 0, set it to 60 seconds after start
        long startTs = entry.startTs;
        long endTs = now;
        
        if (startTs <= 0 && endTs > 0)
        {
            startTs = endTs - 60;
            log.debug("[MatchSubmit] Start timestamp missing, using endTs-60: startTs={}", startTs);
        }
        else if (endTs <= 0 && startTs > 0)
        {
            endTs = startTs + 60;
            log.debug("[MatchSubmit] End timestamp missing, using startTs+60: endTs={}", endTs);
        }
        else if (startTs <= 0 && endTs <= 0)
        {
            // Both missing - use current time and 60 seconds ago
            endTs = System.currentTimeMillis() / 1000;
            startTs = endTs - 60;
            log.debug("[MatchSubmit] Both timestamps missing, using now and now-60: startTs={} endTs={}", startTs, endTs);
        }
        
        final long finalStartTs = startTs;
        final long finalEndTs = endTs;
        final int startSb = entry.startSpellbook;
        final boolean wasMulti = entry.wasInMulti;

        final String resolvedOpponent = (opponentName != null) ? opponentName : "Unknown";
        final long dmgOut = entry.damageDealt.get();  // Read from FightEntry

        // Determine the bucket this fight will be classified as (server-side logic)
        final String startSpellbookName = getSpellbookName(startSb);
        final String endSpellbookName = getSpellbookName(currentSpellbook);
        final String fightBucket = determineBucket(world, wasMulti, startSpellbookName, endSpellbookName);
        
        log.debug("[MatchSubmit] Determined bucket: {} (world={} multi={} startSb={} endSb={})", 
            fightBucket, world, wasMulti, startSpellbookName, endSpellbookName);

        // Determine which bucket to use for API calls
        // If auto-switch is enabled, use the fight bucket; otherwise use the user's manual selection
        final String apiRefreshBucket;
        boolean showBucketInMmr = false;  // Show bucket label in MMR notification when bucket differs
        
        // Check if fight bucket differs from user's current selection
        PvPLeaderboardConfig.RankBucket currentBucket = config.rankBucket();
        PvPLeaderboardConfig.RankBucket fightBucketEnum = bucketStringToEnum(fightBucket);
        boolean fightBucketDiffers = (fightBucketEnum != null && currentBucket != fightBucketEnum);
        
        // Auto-switch leaderboard if enabled - always switch to match fight style
        if (config.autoSwitchBucket())
        {
            log.debug("[AutoSwitch] Check: fightBucket={} currentBucket={} newBucket={}", 
                fightBucket, currentBucket, fightBucketEnum);
            
            if (fightBucketEnum != null)
            {
                // Always switch to the fight bucket, even if user manually changed it
                // This ensures the leaderboard always reflects the current fight style
                if (fightBucketDiffers)
                {
                    log.debug("[AutoSwitch] Switching leaderboard from {} to {}", currentBucket, fightBucketEnum);
                    configManager.setConfiguration("PvPLeaderboard", "rankBucket", fightBucketEnum.name());
                    showBucketInMmr = true;  // Show bucket label since we switched
                }
                else
                {
                    log.debug("[AutoSwitch] Already on correct leaderboard: {}", fightBucketEnum);
                }
            }
            else
            {
                log.debug("[AutoSwitch] Could not map fightBucket '{}' to enum", fightBucket);
            }
            
            // Use fight bucket for API refresh when auto-switch is enabled
            apiRefreshBucket = fightBucket;
        }
        else
        {
            log.debug("[AutoSwitch] Disabled - keeping manual selection: {}", currentBucket);
            // Use user's manual selection for API refresh
            apiRefreshBucket = getConfigBucketKey();
            
            // Show bucket label if fight was in a different bucket than user's selection
            // This informs the user which bucket the MMR change applies to
            if (fightBucketDiffers)
            {
                showBucketInMmr = true;
            }
        }

        // Async Submission
        java.util.concurrent.CompletableFuture.runAsync(() -> {
            try {
                submitMatchResult(result, finalEndTs, selfName, resolvedOpponent, world, finalStartTs, startSb, currentSpellbook, wasMulti, idTokenSafe, dmgOut);
            } catch (Exception e) {
                log.debug("[MatchSubmit] EXCEPTION in async submission: {}", e.getMessage(), e);
            }
        }, scheduler);

        // Schedule API refreshes in 5s (gives backend time to process the match)
        // Uses the determined bucket (fight bucket if auto-switch, manual selection otherwise)
        // Show bucket label in MMR notification when fight bucket differs from user's selection
        scheduleApiRefreshes(resolvedOpponent, apiRefreshBucket, showBucketInMmr);
    }

    private void submitMatchResult(String result, long fightEndTime, String playerId, String opponentId, int world,
                                   long fightStartTs, int fightStartSpellbookLocal, int fightEndSpellbookLocal,
                                   boolean wasInMultiLocal, String idTokenLocal, long damageToOpponentLocal)
    {
        MatchResult match = MatchResult.builder()
                .playerId(playerId)
                .opponentId(opponentId)
                .result(result)
                .world(world)
                .fightStartTs(fightStartTs)
                .fightEndTs(fightEndTime)
                .fightStartSpellbook(getSpellbookName(fightStartSpellbookLocal))
                .fightEndSpellbook(getSpellbookName(fightEndSpellbookLocal))
                .wasInMulti(wasInMultiLocal)
                .idToken(idTokenLocal)
                .damageToOpponent(damageToOpponentLocal)
                .clientUniqueId(clientIdentityService.getClientUniqueId())
                .build();

        log.debug("[MatchSubmit] Submitting: player={} opponent={} result={} world={} startTs={} endTs={} dmgOut={} multi={} hasToken={}",
                playerId, opponentId, result, world, fightStartTs, fightEndTime, damageToOpponentLocal, wasInMultiLocal, (idTokenLocal != null && !idTokenLocal.isEmpty()));

        matchResultService.submitMatchResult(match).thenAccept(success -> {
            if (success) {
                log.debug("[MatchSubmit] SUCCESS: match submitted for player={} vs opponent={} result={}", playerId, opponentId, result);
            } else {
                log.debug("[MatchSubmit] FAILED: match submission failed for player={} vs opponent={} result={}", playerId, opponentId, result);
            }
        });
    }

    private void scheduleApiRefreshes(String opponentName, String displayBucket, boolean showBucketInMmr) {
        log.debug("[PostFight] Scheduling API refresh in 5s for self and opponent={} bucket={} showBucket={}", 
            opponentName, displayBucket, showBucketInMmr);
        
        scheduler.schedule(() -> {
            try {
                String selfName = getLocalPlayerName();
                log.debug("[PostFight] Executing API refresh: self={} opponent={} bucket={}", 
                    selfName, opponentName, displayBucket);
                
                if (selfName != null) {
                    // Refresh rank display using the specified bucket
                    fetchTierWithRetry(selfName, displayBucket, 3);
                    
                    // Get MMR delta from match history (more accurate than profile diff)
                    // First attempt at 5s, second attempt at 15s if first fails (1 retry with 10s delay)
                    // Only show bucket label in notification if we auto-switched
                    if (config.showMmrChangeNotification() && opponentName != null) {
                        fetchMmrDeltaFromMatchHistory(selfName, opponentName, displayBucket, showBucketInMmr, 1);
                    }
                } else {
                    log.debug("[PostFight] selfName is null, skipping self refresh");
                }
                
                // Refresh opponent rank using the same bucket
                if (opponentName != null) {
                    fetchTierWithRetry(opponentName, displayBucket, 3);
                } else {
                    log.debug("[PostFight] opponentName is null, skipping opponent refresh");
                }
                
                // Trigger overlay refresh after API calls complete
                if (rankOverlay != null) {
                    rankOverlay.scheduleSelfRankRefresh(0L);
                }
            } catch(Exception e){
                log.debug("[PostFight] API refresh exception: {}", e.getMessage());
            }
        }, 5L, java.util.concurrent.TimeUnit.SECONDS);
    }

    /**
     * Fetch MMR delta from match history API.
     * This is more accurate than calculating from profile differences.
     * Uses account SHA (UUID hash) to ensure ALL matches are returned even after name changes.
     * First attempt at ~5s after fight, second (final) attempt at ~15s if first fails.
     * 
     * @param showBucketLabel If true, include bucket name in MMR notification (used when auto-switch occurred)
     */
    private void fetchMmrDeltaFromMatchHistory(String selfName, String opponentName, String displayBucket, boolean showBucketLabel, int retriesLeft) {
        log.debug("[PostFight] Fetching MMR delta from match history: self={} opponent={} showBucket={} retriesLeft={}", 
            selfName, opponentName, showBucketLabel, retriesLeft);
        
        // Use account SHA for accurate match history across name changes
        // This ensures MMR delta is correct even if the player changed their name
        String selfAcctSha = pvpDataService.getSelfAcctSha();
        
        // Fetch more matches to handle multi-kill scenarios (up to 10 kills in quick succession)
        // Bypass cache to ensure we get fresh data with the new match
        // Prefer acct-based lookup if available, fallback to name-based
        CompletableFuture<JsonObject> matchesFuture;
        if (selfAcctSha != null && !selfAcctSha.isEmpty()) {
            log.debug("[PostFight] Using acct-based match lookup: acct={}", selfAcctSha.substring(0, 8) + "...");
            matchesFuture = pvpDataService.getPlayerMatchesByAcct(selfAcctSha, null, 15, true);
        } else {
            log.debug("[PostFight] Falling back to name-based match lookup: name={}", selfName);
            matchesFuture = pvpDataService.getPlayerMatches(selfName, null, 15, true);
        }
        
        matchesFuture.thenAccept(response -> {
            if (response != null && response.has("matches") && response.get("matches").isJsonArray()) {
                var matches = response.getAsJsonArray("matches");
                
                // Find the most recent match against this opponent
                for (var element : matches) {
                    if (!element.isJsonObject()) continue;
                    JsonObject match = element.getAsJsonObject();
                    
                    String matchOpponent = match.has("opponent_id") && !match.get("opponent_id").isJsonNull() 
                        ? match.get("opponent_id").getAsString() : null;
                    
                    // Check if this match is against our opponent (case-insensitive)
                    if (matchOpponent != null && matchOpponent.equalsIgnoreCase(opponentName)) {
                        // Found the match - extract MMR delta and bucket
                        if (match.has("rating_change") && match.get("rating_change").isJsonObject()) {
                            JsonObject ratingChange = match.getAsJsonObject("rating_change");
                            
                            if (ratingChange.has("mmr_delta") && !ratingChange.get("mmr_delta").isJsonNull()) {
                                double mmrDelta = ratingChange.get("mmr_delta").getAsDouble();
                                
                                // Get the actual bucket from the match
                                String matchBucket = match.has("bucket") && !match.get("bucket").isJsonNull()
                                    ? match.get("bucket").getAsString() : "nh";
                                
                                // Only show bucket label if we auto-switched to a different bucket
                                String bucketLabel = showBucketLabel ? getBucketDisplayName(matchBucket) : null;
                                
                                // Check result to determine if delta should be negative
                                String result = match.has("result") && !match.get("result").isJsonNull()
                                    ? match.get("result").getAsString() : "win";
                                if ("loss".equalsIgnoreCase(result)) {
                                    mmrDelta = -Math.abs(mmrDelta);
                                }
                                
                                log.debug("[PostFight] Found match in history: opponent={} bucket={} mmrDelta={} result={} bucketLabel={}", 
                                    matchOpponent, matchBucket, mmrDelta, result, bucketLabel);
                                
                                // Trigger the notification
                                if (rankOverlay != null) {
                                    rankOverlay.showMmrDelta(mmrDelta, bucketLabel);
                                }
                                return;
                            }
                        }
                        
                        log.debug("[PostFight] Found match but no rating_change data");
                        return;
                    }
                }
                
                // Match not found yet - retry if we have retries left (retry after 10s so total is ~15s)
                if (retriesLeft > 0) {
                    log.debug("[PostFight] Match not found in history, retrying in 10s ({} left)", retriesLeft - 1);
                    scheduler.schedule(() -> fetchMmrDeltaFromMatchHistory(selfName, opponentName, displayBucket, showBucketLabel, retriesLeft - 1),
                        10L, java.util.concurrent.TimeUnit.SECONDS);
                } else {
                    log.debug("[PostFight] Match not found in history after all retries, skipping MMR notification");
                }
            } else if (retriesLeft > 0) {
                log.debug("[PostFight] No matches in response, retrying in 10s ({} left)", retriesLeft - 1);
                scheduler.schedule(() -> fetchMmrDeltaFromMatchHistory(selfName, opponentName, displayBucket, showBucketLabel, retriesLeft - 1),
                    10L, java.util.concurrent.TimeUnit.SECONDS);
            } else {
                log.debug("[PostFight] Failed to get matches after all retries");
            }
        }).exceptionally(ex -> {
            if (retriesLeft > 0) {
                log.debug("[PostFight] Match history exception: {}, retrying in 10s ({} left)", ex.getMessage(), retriesLeft - 1);
                scheduler.schedule(() -> fetchMmrDeltaFromMatchHistory(selfName, opponentName, displayBucket, showBucketLabel, retriesLeft - 1),
                    10L, java.util.concurrent.TimeUnit.SECONDS);
            } else {
                log.debug("[PostFight] Match history failed after all retries: {}", ex.getMessage());
            }
            return null;
        });
    }

    /**
     * Get the bucket key from user config for API calls.
     */
    private String getConfigBucketKey() {
        if (config == null) return "overall";
        var bucket = config.rankBucket();
        if (bucket == null) return "overall";
        switch (bucket) {
            case NH: return "nh";
            case VENG: return "veng";
            case MULTI: return "multi";
            case DMM: return "dmm";
            case OVERALL:
            default: return "overall";
        }
    }

    /**
     * Extract tier string from user profile response for a specific bucket.
     */
    private String extractTierFromProfile(JsonObject profile, String bucket) {
        if (profile == null) return null;
        
        // Try bucket-specific data first
        if (bucket != null && !bucket.isEmpty() && !"overall".equalsIgnoreCase(bucket)) {
            if (profile.has("buckets") && profile.get("buckets").isJsonObject()) {
                JsonObject buckets = profile.getAsJsonObject("buckets");
                if (buckets.has(bucket) && buckets.get(bucket).isJsonObject()) {
                    JsonObject bucketData = buckets.getAsJsonObject(bucket);
                    String tier = extractTierFromBucketData(bucketData);
                    if (tier != null) return tier;
                }
            }
        }
        
        // Fallback to top-level (overall) data
        return extractTierFromBucketData(profile);
    }

    /**
     * Extract tier from a bucket data object.
     */
    private String extractTierFromBucketData(JsonObject data) {
        if (data == null) return null;
        
        String rank = null;
        int division = 0;
        
        if (data.has("rank") && !data.get("rank").isJsonNull()) {
            rank = data.get("rank").getAsString();
        }
        if (data.has("division") && !data.get("division").isJsonNull()) {
            division = data.get("division").getAsInt();
        }
        
        if (rank != null && !rank.isEmpty()) {
            return division > 0 ? rank + " " + division : rank;
        }
        return null;
    }

    /**
     * Extract MMR from user profile response for a specific bucket.
     */
    private Double extractMmrFromProfile(JsonObject profile, String bucket) {
        return extractDoubleFieldFromProfile(profile, bucket, "mmr");
    }

    /**
     * Extract Sigma (TrueSkill uncertainty) from user profile response for a specific bucket.
     * Each bucket maintains separate TrueSkill values since they act as separate leaderboards.
     */
    private Double extractSigmaFromProfile(JsonObject profile, String bucket) {
        return extractDoubleFieldFromProfile(profile, bucket, "sigma");
    }

    /**
     * Generic helper to extract a Double field from user profile for a specific bucket.
     * Tries bucket-specific data first, falls back to top-level.
     */
    private Double extractDoubleFieldFromProfile(JsonObject profile, String bucket, String fieldName) {
        if (profile == null || fieldName == null) return null;
        
        // Try bucket-specific data first
        if (bucket != null && !bucket.isEmpty() && !"overall".equalsIgnoreCase(bucket)) {
            if (profile.has("buckets") && profile.get("buckets").isJsonObject()) {
                JsonObject buckets = profile.getAsJsonObject("buckets");
                if (buckets.has(bucket) && buckets.get(bucket).isJsonObject()) {
                    JsonObject bucketData = buckets.getAsJsonObject(bucket);
                    if (bucketData.has(fieldName) && !bucketData.get(fieldName).isJsonNull()) {
                        return bucketData.get(fieldName).getAsDouble();
                    }
                }
            }
        }
        
        // Fallback to top-level field
        if (profile.has(fieldName) && !profile.get(fieldName).isJsonNull()) {
            return profile.get(fieldName).getAsDouble();
        }
        return null;
    }
    
    private void fetchTierWithRetry(String playerName, String bucket, int retriesLeft) {
        log.debug("[PostFight] fetchTierWithRetry called: player={} bucket={} retriesLeft={}", playerName, bucket, retriesLeft);
        pvpDataService.getTierFromProfile(playerName, bucket).thenAccept(tier -> {
            if (tier != null) {
                log.debug("[PostFight] SUCCESS: tier={} for player={}", tier, playerName);
                if (rankOverlay != null) {
                    rankOverlay.setRankFromApi(playerName, tier);
                }
            } else if (retriesLeft > 0) {
                log.debug("[PostFight] tier is null for player={}, retrying ({} left)", playerName, retriesLeft - 1);
                scheduler.schedule(() -> fetchTierWithRetry(playerName, bucket, retriesLeft - 1), 
                    2L, java.util.concurrent.TimeUnit.SECONDS);
            } else {
                log.debug("[PostFight] FAILED: tier is null for player={}, no retries left", playerName);
            }
        }).exceptionally(ex -> {
            if (retriesLeft > 0) {
                log.debug("[PostFight] Exception for player={}: {}, retrying ({} left)", playerName, ex.getMessage(), retriesLeft - 1);
                scheduler.schedule(() -> fetchTierWithRetry(playerName, bucket, retriesLeft - 1), 
                    2L, java.util.concurrent.TimeUnit.SECONDS);
            } else {
                log.debug("[PostFight] FAILED with exception for player={}: {}, no retries left", playerName, ex.getMessage());
            }
            return null;
        });
    }

    private void touchFight(String opponentName)
    {
        if (opponentName == null || opponentName.isEmpty()) return;
        long ts = System.currentTimeMillis() / 1000;
        int sb = client.getVarbitValue(Varbits.SPELLBOOK);
        boolean localPlayerInMulti = client.getVarbitValue(Varbits.MULTICOMBAT_AREA) == 1;
        int currentTick = client.getTickCount();
        activeFights.compute(opponentName, (k, v) -> {
            if (v == null) return new FightEntry(ts, sb, localPlayerInMulti, currentTick);
            // Update activity timestamps
            v.lastActivityMs = System.currentTimeMillis();
            v.lastActivityTick = currentTick;
            // If LOCAL player is now in multi, mark this fight as multi
            // (only tracks if WE enter multi, not if opponent enters multi)
            v.markMultiIfNeeded(localPlayerInMulti);
            return v;
        });

        if (!shardPresence.containsKey(opponentName))
        {
            String bucket = "overall";
            
            pvpDataService.getShardRankByName(opponentName, bucket).thenAccept(shardRank -> {
                if (shardRank != null && shardRank.rank > 0) {
                    shardPresence.put(opponentName, Boolean.TRUE);
                } else {
                    shardPresence.putIfAbsent(opponentName, Boolean.FALSE);
                }
            }).exceptionally(ex -> {
                shardPresence.putIfAbsent(opponentName, Boolean.FALSE);
                return null;
            });
        }
    }
    
    // --- Helpers ---

    /**
     * Resolve who attacked us when we receive inbound damage.
     * 
     * CRITICAL: This method should ONLY return existing fight opponents.
     * We do NOT start new fights from inbound damage because:
     * - getInteracting() returns true for non-combat actions (trading, item use, following)
     * - We cannot distinguish player damage from NPC damage by hitsplat alone
     * - If someone attacks us first, THEY will track the fight from their side
     * 
     * New fights are ONLY started via outbound damage (when we attack someone).
     * This ensures we only track fights where we actually participated in combat.
     * 
     * @param localPlayer The local player who received damage
     * @return The name of an existing fight opponent, or null if none found
     */
    private String resolveInboundAttacker(Player localPlayer)
    {
        List<Player> players = client.getPlayers();
        if (players == null) {
            return existingFightAttacker();
        }

        // Only return players we already have an active fight with
        // This ensures inbound damage is only tracked for fights WE initiated via outbound damage
        for (Player other : players) {
            if (other == null || other == localPlayer) continue;
            
            String otherName = other.getName();
            if (otherName != null && activeFights.containsKey(otherName)) {
                // Existing fight opponent - track their damage to us
                return otherName;
            }
        }
        
        // No existing fight opponent found
        // DO NOT identify new attackers from inbound damage - this causes false positives:
        // - Trading partner identified as attacker when we take NPC damage
        // - Player using items on us identified as attacker
        // - Nearby player in multi-combat identified incorrectly
        return null;
    }
    
    /**
     * Get an existing fight attacker from the most recent active fight.
     * Only returns names of players we already have active fights with.
     */
    private String existingFightAttacker()
    {
        String recent = mostRecentActiveOpponent();
        return recent;  // Returns null if no active fights, which is correct
    }

    private String mostRecentActiveOpponent()
    {
        long best = -1L; String bestName = null;
        for (Map.Entry<String, FightEntry> e : activeFights.entrySet())
        {
            if (e.getValue() == null) continue;
            long la = e.getValue().lastActivityMs;
            if (la > best) { best = la; bestName = e.getKey(); }
        }
        return bestName;
    }

    private String findKillerByDamage()
    {
        String killer = null;
        long bestDmg = 0L;  // Must have dealt at least some damage
        
        // Find opponent who dealt most damage to us
        for (Map.Entry<String, FightEntry> e : activeFights.entrySet())
        {
            FightEntry fe = e.getValue();
            if (fe == null) continue;
            long dmgReceived = fe.damageReceived.get();
            // log.debug("[KillerSearch] Candidate: {} dealt {} damage to us", e.getKey(), dmgReceived);
            
            if (dmgReceived > bestDmg)
            {
                bestDmg = dmgReceived;
                killer = e.getKey();
            }
        }
        
        // if (killer != null)
        // {
        //     log.debug("[KillerSearch] Winner: {} with {} damage", killer, bestDmg);
        // }
        return killer;
    }

    private String findActualKiller(Player localPlayer)
    {
        List<Player> players = client.getPlayers();
        if (players == null) return null;
        for (Player player : players) {
            if (player != localPlayer && player.getInteracting() == localPlayer) return player.getName();
        }
        return null;
    }

    private boolean isPlayerOpponent(String name)
    {
        if (name == null || "Unknown".equals(name)) return false;
        List<Player> players = client.getPlayers();
        if (players == null) return false;
        for (Player player : players) {
            String pName = player.getName();
            if (pName != null && pName.equals(name)) return true;
        }
        return false;
    }
    
    private String getLocalPlayerName()
    {
        if (client == null)
        {
            return null;
        }

        try
        {
            var localPlayer = client.getLocalPlayer();
            if (localPlayer == null)
            {
                return null;
            }
            return localPlayer.getName();
        }
        catch (Exception e)
        {
            log.debug("Failed to get local player name", e);
            return null;
        }
    }

    private String getSpellbookName(int spellbook)
    {
        switch (spellbook) {
            case 0: return "Standard";
            case 1: return "Ancient";
            case 2: return "Lunar";
            case 3: return "Arceuus";
            default: return "Unknown";
        }
    }

    /**
     * Get readable name for hitsplat type for debug logging.
     */
    private String getHitsplatTypeName(int type)
    {
        switch (type) {
            case HitsplatID.DAMAGE_ME: return "DAMAGE_ME";
            case HitsplatID.DAMAGE_OTHER: return "DAMAGE_OTHER";
            case HitsplatID.POISON: return "POISON";
            case HitsplatID.VENOM: return "VENOM";
            case HitsplatID.BLOCK_ME: return "BLOCK_ME";
            case HitsplatID.BLOCK_OTHER: return "BLOCK_OTHER";
            case HitsplatID.HEAL: return "HEAL";
            default: return "TYPE_" + type;
        }
    }

    /**
     * Determine the bucket for a fight based on server-side logic.
     * Priority: DMM > Multi > Veng > NH
     * 
     * Multi-combat classification:
     * - If YOU (local player) ever entered multi during the fight, it's a "multi" fight
     * - If you stayed in singles but opponent died in multi, it's still a "singles" kill (NH/Veng)
     * 
     * @param world The world number
     * @param wasInMulti Whether the LOCAL player was ever in multi-combat during this fight
     * @param startSpellbook The spellbook name at fight start
     * @param endSpellbook The spellbook name at fight end
     * @return The bucket name: "dmm", "multi", "veng", or "nh"
     */
    private String determineBucket(int world, boolean wasInMulti, String startSpellbook, String endSpellbook)
    {
        // 1. DMM check - uses cached DMM worlds from PvPDataService
        if (pvpDataService.isDmmWorld(world))
        {
            return "dmm";
        }

        // 2. Multi check
        if (wasInMulti)
        {
            return "multi";
        }

        // 3. Veng check - both start AND end spellbook must be Lunar
        if ("Lunar".equals(startSpellbook) && "Lunar".equals(endSpellbook))
        {
            return "veng";
        }

        // 4. Default to NH
        return "nh";
    }

    /**
     * Convert bucket string to RankBucket enum for config updates.
     */
    private PvPLeaderboardConfig.RankBucket bucketStringToEnum(String bucket)
    {
        if (bucket == null) return null;
        switch (bucket.toLowerCase())
        {
            case "nh": return PvPLeaderboardConfig.RankBucket.NH;
            case "veng": return PvPLeaderboardConfig.RankBucket.VENG;
            case "multi": return PvPLeaderboardConfig.RankBucket.MULTI;
            case "dmm": return PvPLeaderboardConfig.RankBucket.DMM;
            default: return null;
        }
    }

    /**
     * Get the display name for a bucket (capitalized for UI).
     */
    private String getBucketDisplayName(String bucket)
    {
        if (bucket == null) return "NH";
        switch (bucket.toLowerCase())
        {
            case "dmm": return "DMM";
            case "multi": return "Multi";
            case "veng": return "Veng";
            case "nh": return "NH";
            case "overall": return "Overall";
            default: return bucket.toUpperCase();
        }
    }
    
    private static class FightEntry {
        final long startTs;
        final int startSpellbook;
        volatile boolean wasInMulti;  // Mutable: set true if LOCAL player ever enters multi during this fight
        volatile long lastActivityMs;
        volatile int lastActivityTick;  // Track per-opponent combat activity in game ticks
        volatile boolean finalized = false;
        
        // Per-fight damage tracking for multi-combat accuracy
        final AtomicLong damageDealt = new AtomicLong(0);    // Damage we dealt TO this opponent
        final AtomicLong damageReceived = new AtomicLong(0); // Damage we received FROM this opponent
        
        FightEntry(long ts, int sb, boolean multi, int currentTick) {
            startTs = ts;
            startSpellbook = sb;
            wasInMulti = multi;
            lastActivityMs = System.currentTimeMillis();
            lastActivityTick = currentTick;
        }
        
        /**
         * Mark this fight as multi if the local player entered multi-combat area.
         * Only updates to true (never reverts to singles once multi is flagged).
         */
        void markMultiIfNeeded(boolean isInMulti) {
            if (isInMulti && !wasInMulti) {
                wasInMulti = true;
            }
        }
        
        void addDamageDealt(long amount, int currentTick) {
            damageDealt.addAndGet(amount);
            lastActivityMs = System.currentTimeMillis();
            lastActivityTick = currentTick;
        }
        
        void addDamageReceived(long amount, int currentTick) {
            damageReceived.addAndGet(amount);
            lastActivityMs = System.currentTimeMillis();
            lastActivityTick = currentTick;
        }
        
        boolean isStale(int currentTick, int timeout) {
            return (currentTick - lastActivityTick) > timeout;
        }
    }
}

package com.pvp.leaderboard.game;

import lombok.Value;

/**
 * Event fired when a player's rank is updated from the API.
 * Used to communicate rank updates to the overlay system.
 */
@Value
public class PlayerRankEvent
{
    String playerName;
    String bucket;
    String tier;
}


package com.pvp.leaderboard.config;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;

@ConfigGroup("PvPLeaderboard")
public interface PvPLeaderboardConfig extends Config
{
	// ==================== Sections ====================

	@ConfigSection(
		name = "Overlay Settings",
		description = "Settings for the rank overlay display",
		position = 0
	)
	String overlaySection = "overlay";

	@ConfigSection(
		name = "Visual Settings",
		description = "Settings for overlay appearance",
		position = 1
	)
	String visualSection = "visual";

	@ConfigSection(
		name = "Notifications",
		description = "Settings for notifications",
		position = 2
	)
	String notificationSection = "notifications";

	@ConfigSection(
		name = "Other",
		description = "Other settings",
		position = 3
	)
	String otherSection = "other";

	// ==================== Enums ====================

	enum RankDisplayMode
	{
		TEXT
		{
			@Override
			public String toString()
			{
				return "Text";
			}
		},
		RANK_NUMBER
		{
			@Override
			public String toString()
			{
				return "Rank #";
			}
		}
	}

	enum RankBucket
	{
		OVERALL
		{
			@Override
			public String toString()
			{
				return "Overall";
			}
		},
		NH
		{
			@Override
			public String toString()
			{
				return "NH";
			}
		},
		VENG
		{
			@Override
			public String toString()
			{
				return "Veng";
			}
		},
		MULTI
		{
			@Override
			public String toString()
			{
				return "Multi";
			}
		},
		DMM
		{
			@Override
			public String toString()
			{
				return "DMM";
			}
		}
	}

	// ==================== Overlay Settings ====================

	@ConfigItem(
		keyName = "showOwnRank",
		name = "Show your own rank",
		description = "Display your rank above your character",
		section = overlaySection,
		position = 0
	)
	default boolean showOwnRank()
	{
		return true;
	}

	@ConfigItem(
		keyName = "rankDisplayMode",
		name = "Display rank as",
		description = "How to display ranks above players",
		section = overlaySection,
		position = 1
	)
	default RankDisplayMode rankDisplayMode()
	{
		return RankDisplayMode.TEXT;
	}

	@ConfigItem(
		keyName = "rankBucket",
		name = "Rank Bucket",
		description = "Which rank bucket to display",
		section = overlaySection,
		position = 2
	)
	default RankBucket rankBucket()
	{
		return RankBucket.OVERALL;
	}

	@ConfigItem(
		keyName = "autoSwitchBucket",
		name = "Auto-switch Leaderboard",
		description = "Automatically switch leaderboard to match your last fight style (overrides manual selection)",
		section = overlaySection,
		position = 3
	)
	default boolean autoSwitchBucket()
	{
		return true;
	}

	// ==================== Visual Settings ====================

	@ConfigItem(
		keyName = "rankTextSize",
		name = "Rank Text Size",
		description = "Text size for rank display",
		section = visualSection,
		position = 0
	)
	@Range(min = 10, max = 48)
	default int rankTextSize()
	{
		return 10;
	}

	@ConfigItem(
		keyName = "rankOffsetX",
		name = "Rank Offset X",
		description = "Horizontal offset for rank display (pixels)",
		section = visualSection,
		position = 1
	)
	@Range(min = -100, max = 100)
	default int rankOffsetX()
	{
		return 0;
	}

	@ConfigItem(
		keyName = "rankOffsetY",
		name = "Rank Offset Y",
		description = "Vertical offset for rank display (pixels)",
		section = visualSection,
		position = 2
	)
	@Range(min = -100, max = 100)
	default int rankOffsetY()
	{
		return 0;
	}

	@ConfigItem(
		keyName = "colorblindMode",
		name = "Colorblind Mode",
		description = "Makes all rank text white for better visibility",
		section = visualSection,
		position = 3
	)
	default boolean colorblindMode()
	{
		return false;
	}

	// ==================== Notifications ====================

	@ConfigItem(
		keyName = "showMmrChangeNotification",
		name = "Show MMR Change",
		description = "Display MMR gained/lost after fights (XP drop style)",
		section = notificationSection,
		position = 0
	)
	default boolean showMmrChangeNotification()
	{
		return true;
	}

	@ConfigItem(
		keyName = "mmrOffsetX",
		name = "MMR Offset X",
		description = "Horizontal offset for MMR notification (0 = XP drop position)",
		section = notificationSection,
		position = 1
	)
	@Range(min = -500, max = 500)
	default int mmrOffsetX()
	{
		return 0;
	}

	@ConfigItem(
		keyName = "mmrOffsetY",
		name = "MMR Offset Y",
		description = "Vertical offset for MMR notification (0 = XP drop position)",
		section = notificationSection,
		position = 2
	)
	@Range(min = -500, max = 500)
	default int mmrOffsetY()
	{
		return 0;
	}

	@ConfigItem(
		keyName = "mmrDuration",
		name = "MMR Duration",
		description = "How long the MMR notification stays on screen (seconds)",
		section = notificationSection,
		position = 3
	)
	@Range(min = 1, max = 10)
	default int mmrDuration()
	{
		return 3;
	}

	// ==================== Other Settings ====================

	@ConfigItem(
		keyName = "enablePvpLookupMenu",
		name = "Enable 'pvp lookup' right-click",
		description = "Adds the 'pvp lookup' option to player right-click menu",
		section = otherSection,
		position = 0
	)
	default boolean enablePvpLookupMenu()
	{
		return true;
	}
}

package com.pvp.leaderboard;

import com.google.inject.Provides;
import com.pvp.leaderboard.config.PvPLeaderboardConfig;
import com.pvp.leaderboard.game.FightMonitor;
import com.pvp.leaderboard.game.MenuHandler;
import com.pvp.leaderboard.overlay.RankOverlay;
import com.pvp.leaderboard.service.ClientIdentityService;
import com.pvp.leaderboard.service.CognitoAuthService;
import com.pvp.leaderboard.service.PvPDataService;
import com.pvp.leaderboard.ui.DashboardPanel;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import java.awt.image.BufferedImage;
import net.runelite.client.util.ImageUtil;

@Slf4j
@PluginDescriptor(
	name = "PvP Leaderboard"
)
public class PvPLeaderboardPlugin extends Plugin
{
	private static final BufferedImage PANEL_ICON = ImageUtil.loadImageResource(PvPLeaderboardPlugin.class, "panel-icon.png");

	@Inject
	private Client client;

	@Inject
	private PvPLeaderboardConfig config;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private RankOverlay rankOverlay;

	@Inject
	private EventBus eventBus;

	@Inject
	private SpriteManager spriteManager;

	@Inject
	private PvPDataService pvpDataService;

	@Inject
	private CognitoAuthService cognitoAuthService;

	@Inject
	private ClientIdentityService clientIdentityService;

	@Inject
	private MenuHandler menuHandler;

	@Inject
	private FightMonitor fightMonitor;

	private DashboardPanel dashboardPanel;
	private NavigationButton navButton;
	private int pendingSelfRankLookupTicks = -1;

	public String getClientUniqueId()
	{
		return clientIdentityService.getClientUniqueId();
	}

	// Accessor for DashboardPanel to get local player name for debug logs
	public String getLocalPlayerName()
	{
		if (client == null)
		{
			return null;
		}

		try
		{
			var localPlayer = client.getLocalPlayer();
			if (localPlayer == null)
			{
				return null;
			}
			return localPlayer.getName();
		}
		catch (Exception e)
		{
			log.debug("Failed to get local player name", e);
			return null;
		}
	}

	// Helper for overlays to get displayed rank from overlay cache
	public String getDisplayedRankFor(String playerName)
	{
		return rankOverlay != null ? rankOverlay.getCachedRankFor(playerName) : null;
	}

	@Override
	protected void startUp() throws Exception
	{
		dashboardPanel = new DashboardPanel(config, this, pvpDataService, cognitoAuthService);

		// Initialize identity
		clientIdentityService.loadOrGenerateId();

		navButton = NavigationButton.builder()
			.tooltip("PvP Leaderboard")
			.icon(PANEL_ICON)
			.priority(5)
			.panel(dashboardPanel)
			.build();
		clientToolbar.addNavigation(navButton);

		// Register overlay
		overlayManager.add(rankOverlay);

		// Register RankOverlay with EventBus to receive PlayerRankEvent
		eventBus.register(rankOverlay);

		// Init menu handler with RankOverlay
		menuHandler.init(dashboardPanel, rankOverlay, navButton);

		// Init fight monitor with RankOverlay for MMR notifications
		fightMonitor.init(rankOverlay);

		log.debug("PvP Leaderboard started!");
	}

	@Override
	protected void shutDown() throws Exception
	{
		menuHandler.shutdown();
		eventBus.unregister(rankOverlay);
		clientToolbar.removeNavigation(navButton);
		overlayManager.remove(rankOverlay);
		log.debug("PvP Leaderboard stopped!");
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		try
		{
			if (event == null) return;
			if (!"PvPLeaderboard".equals(event.getGroup())) return;

			if ("enablePvpLookupMenu".equals(event.getKey()))
			{
				menuHandler.refreshMenuOption();
				return;
			}

			// Ensure self rank refreshes when bucket or display mode changes
			if ("rankBucket".equals(event.getKey()) || "rankDisplayMode".equals(event.getKey()))
			{
				if (rankOverlay != null)
				{
					rankOverlay.scheduleSelfRankRefresh(0L);
				}
			}
		}
		catch (Exception e)
		{
			log.error("Uncaught exception in onConfigChanged", e);
		}
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event)
	{
		menuHandler.handleMenuOptionClicked(event);
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		try
		{
			if (gameStateChanged.getGameState() == GameState.LOGGED_IN)
			{
				// Only load self data if panel is NOT already viewing someone else
				// This prevents overwriting user's search when they login/hop worlds
				try
				{
					if (client.getLocalPlayer() != null && dashboardPanel != null)
					{
						String self = client.getLocalPlayer().getName();
						if (self != null && !self.trim().isEmpty()) {
							// Only load self if no one is currently being viewed
							// If user searched for another player, don't overwrite it
							dashboardPanel.loadMatchHistoryIfNotViewing(self);
						}
					}

					// Use tick-based scheduling: wait 10 ticks (approx 6.0s) for initial rank overlay sync
					pendingSelfRankLookupTicks = 10;
				}
				catch (Exception ignore) {}
			}
			else if (gameStateChanged.getGameState() == GameState.LOGIN_SCREEN)
			{
				// Fully clear fight state on logout
				fightMonitor.resetFightState();
			}
			else if (gameStateChanged.getGameState() == GameState.HOPPING || gameStateChanged.getGameState() == GameState.LOADING)
			{
				try
				{
					if (rankOverlay != null)
					{
						rankOverlay.resetLookupStateOnWorldHop();
					}
					// Schedule self rank overlay refresh only - don't refresh panel
					pendingSelfRankLookupTicks = 8;
				}
				catch (Exception ignore) {}
			}
		}
		catch (Exception e)
		{
			log.debug("Uncaught exception in onGameStateChanged", e);
		}
	}

	@Subscribe
	public void onGameTick(GameTick tick)
	{
		try
		{
			// Delegate logic to FightMonitor
			fightMonitor.handleGameTick(tick);

			// Handle pending self-rank lookups (tick-based delay logic) - for overlay only
			if (pendingSelfRankLookupTicks > 0)
			{
				pendingSelfRankLookupTicks--;
				if (pendingSelfRankLookupTicks == 0)
				{
					pendingSelfRankLookupTicks = -1;
					if (rankOverlay != null)
					{
						// Check if local player is ready before scheduling, otherwise retry briefly
						if (client.getLocalPlayer() != null)
						{
							rankOverlay.scheduleSelfRankRefresh(0L);
							// Don't refresh dashboard on tick - only refreshes on explicit search or after 1 hour
						}
						else
						{
							// Not ready yet, retry in 5 ticks
							pendingSelfRankLookupTicks = 5;
						}
					}
				}
			}
		}
		catch (Exception e)
		{
			log.debug("Uncaught exception in onGameTick", e);
		}
	}

	@Subscribe
	public void onHitsplatApplied(HitsplatApplied hitsplatApplied)
	{
		fightMonitor.handleHitsplatApplied(hitsplatApplied);
	}

	@Subscribe
	public void onActorDeath(ActorDeath actorDeath)
	{
		fightMonitor.handleActorDeath(actorDeath);
	}

	@Provides
	PvPLeaderboardConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(PvPLeaderboardConfig.class);
	}

	public Client getClient()
	{
		return client;
	}
}

package com.pvp.leaderboard.ui;

import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.pvp.leaderboard.PvPLeaderboardPlugin;
import com.pvp.leaderboard.config.PvPLeaderboardConfig;
import com.pvp.leaderboard.service.CognitoAuthService;
import com.pvp.leaderboard.service.PvPDataService;
import com.pvp.leaderboard.service.RankInfo;
import com.pvp.leaderboard.service.ShardRank;
import com.pvp.leaderboard.util.RankUtils;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.LinkBrowser;

import javax.swing.*;
import java.awt.*;
import java.util.concurrent.CompletableFuture;

public class DashboardPanel extends PluginPanel
{
    private final PvPLeaderboardConfig config;
    private final PvPLeaderboardPlugin plugin; 
    private final PvPDataService pvpDataService;
    private final CognitoAuthService cognitoAuthService;

    // Sub-panels
    private LoginPanel loginPanel;
    private RankProgressPanel rankProgressPanel;
    private PerformanceStatsPanel performanceStatsPanel;
    private MatchHistoryPanel matchHistoryPanel;
    private AdditionalStatsPanel extraStatsPanel;
    private WinRateChartPanel chartPanel;
    
    // Header elements
    private JLabel playerNameLabel;
    private JButton refreshButton;

    // State
    private String currentMatchesPlayerId = null;
    private JsonArray allMatches = null;
    private long lastRefreshTimestamp = 0;
    
    private static final int MATCHES_PAGE_SIZE = 100;
    private static final long STALE_DATA_THRESHOLD_MS = 60L * 60L * 1000L; // 1 hour
    
    public DashboardPanel(PvPLeaderboardConfig config, PvPLeaderboardPlugin plugin, PvPDataService pvpDataService, CognitoAuthService cognitoAuthService)
    {
        this.config = config;
        this.plugin = plugin;
        this.pvpDataService = pvpDataService;
        this.cognitoAuthService = cognitoAuthService;
        
        setLayout(new BorderLayout());
        setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        
        JScrollPane scrollPane = new JScrollPane(createMainPanel());
        scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
        add(scrollPane, BorderLayout.CENTER);
    }
    
    private JPanel createMainPanel()
    {
        JPanel mainPanel = new JPanel();
        mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));
        
        // 1. Community (kept simple here)
        mainPanel.add(createCommunityBox());
        mainPanel.add(Box.createVerticalStrut(12));

        // 2. Auth / Login
        loginPanel = new LoginPanel(cognitoAuthService, this::loadMatchHistory, this::onLoginStateChanged);
        JPanel authContainer = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
        authContainer.add(loginPanel);
        mainPanel.add(authContainer);
        mainPanel.add(Box.createVerticalStrut(16));

        // 3. Profile Header
        mainPanel.add(createProfileHeader());
        mainPanel.add(Box.createVerticalStrut(24));
        
        // 4. Rank Progress
        rankProgressPanel = new RankProgressPanel();
        mainPanel.add(rankProgressPanel);
        mainPanel.add(Box.createVerticalStrut(24));
        
        // 5. Performance Overview
        performanceStatsPanel = new PerformanceStatsPanel();
        mainPanel.add(performanceStatsPanel);
        mainPanel.add(Box.createVerticalStrut(12));
        
        // 6. Additional Stats (Hidden by default)
        extraStatsPanel = new AdditionalStatsPanel();
        extraStatsPanel.setVisible(false);
        try { if (extraStatsPanel != null) extraStatsPanel.setBucket("overall"); } catch (Exception ignore) {}
        mainPanel.add(extraStatsPanel);
        mainPanel.add(Box.createVerticalStrut(24));
        
        // 7. Win Rate Chart
        chartPanel = new WinRateChartPanel();
        JScrollPane chartScroll = new JScrollPane(chartPanel);
        chartScroll.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
        chartScroll.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_NEVER);
        chartScroll.setPreferredSize(new Dimension(0, 220));
        chartScroll.setBorder(BorderFactory.createTitledBorder("Win Rate History"));
        mainPanel.add(chartScroll);
        mainPanel.add(Box.createVerticalStrut(24));

        // 8. Match History
        matchHistoryPanel = new MatchHistoryPanel();
        mainPanel.add(matchHistoryPanel);
        
        return mainPanel;
    }
    
    // --- UI Creation Helpers ---
    
    private JPanel createCommunityBox()
    {
        JPanel box = new JPanel();
        box.setLayout(new BoxLayout(box, BoxLayout.Y_AXIS));
        box.setBorder(BorderFactory.createTitledBorder("Join the community"));
        box.setMaximumSize(new Dimension(220, 60));
        box.setPreferredSize(new Dimension(220, 60));
        JPanel row = new JPanel(new FlowLayout(FlowLayout.LEFT, 2, 0));
        JButton discordBtn = new JButton("Discord");
        discordBtn.setPreferredSize(new Dimension(90, 25));
        discordBtn.setToolTipText("Join our Discord");
        discordBtn.addActionListener(e -> {
            try { LinkBrowser.browse("https://discord.gg/3Ct5CQmCPr"); } catch (Exception ignore) {}
        });
        row.add(discordBtn);
        JButton websiteBtn = new JButton("Website");
        websiteBtn.setPreferredSize(new Dimension(90, 25));
        websiteBtn.setToolTipText("Open the website");
        websiteBtn.addActionListener(e -> {
            try { LinkBrowser.browse("https://devsecopsautomated.com/index.html"); } catch (Exception ignore) {}
        });
        row.add(websiteBtn);
        box.add(row);
        return box;
    }
    
    private JPanel createProfileHeader()
    {
        JPanel header = new JPanel(new BorderLayout());
        JPanel namePanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
        
        playerNameLabel = new JLabel("Player Name");
        playerNameLabel.setFont(playerNameLabel.getFont().deriveFont(Font.BOLD, 18f));
        namePanel.add(playerNameLabel);
        namePanel.add(Box.createHorizontalStrut(8));
        
        refreshButton = new JButton("Refresh");
        refreshButton.setPreferredSize(new Dimension(80, 25));
        refreshButton.addActionListener(e -> handleRefresh());
        namePanel.add(refreshButton);
        
        header.add(namePanel, BorderLayout.NORTH);
        return header;
    }
    
    // --- Actions ---

    private void handleRefresh() {
        if (currentMatchesPlayerId != null && !currentMatchesPlayerId.isEmpty()) {
            loadMatchHistory(currentMatchesPlayerId);
        } else {
            String self = null;
            if (plugin != null) self = plugin.getLocalPlayerName();
            if (self != null) loadMatchHistory(self);
        }
    }
    
    private void onLoginStateChanged() {
        boolean loggedIn = cognitoAuthService.isLoggedIn();
        extraStatsPanel.setVisible(loggedIn);
        // If we just logged in, reload current view to potentially show more info (or self if nothing loaded)
        if (loggedIn) {
            String search = loginPanel.getPluginSearchText();
            if (search != null && !search.isEmpty()) {
                loadMatchHistory(search);
            } else {
                String self = plugin != null ? plugin.getLocalPlayerName() : null;
                if (self != null) {
                    loginPanel.setPluginSearchText(self);
                    loadMatchHistory(self);
                }
            }
        } else {
             // Logged out
             if (currentMatchesPlayerId != null) loadMatchHistory(currentMatchesPlayerId);
        }
    }

    // --- Data Loading ---
    
    /**
     * Loads match history only if this is a new player search or data is stale (>1 hour old).
     * Called from game events - will skip refresh if data is fresh.
     */
    public void loadMatchHistoryIfNeeded(String playerId)
    {
        String normalizedId = normalizePlayerId(playerId);
        boolean isSamePlayer = normalizedId != null && normalizedId.equalsIgnoreCase(currentMatchesPlayerId);
        boolean isDataFresh = (System.currentTimeMillis() - lastRefreshTimestamp) < STALE_DATA_THRESHOLD_MS;
        
        // Skip if same player and data is fresh
        if (isSamePlayer && isDataFresh) {
            return;
        }
        
        loadMatchHistory(playerId);
    }
    
    /**
     * Loads match history only if NO player is currently being viewed.
     * This prevents game events from overwriting a user's active search.
     * Called on login/world hop - will not switch away from user's search.
     */
    public void loadMatchHistoryIfNotViewing(String playerId)
    {
        // If user is already viewing someone (searched for a player), don't overwrite
        if (currentMatchesPlayerId != null && !currentMatchesPlayerId.isEmpty()) {
            return;
        }
        
        // No one currently viewed - load the requested player (usually self)
        loadMatchHistory(playerId);
    }
    
    /**
     * Forces a full refresh of match history. Called from explicit user actions (search, refresh button).
     */
    public void loadMatchHistory(String playerId)
    {
        currentMatchesPlayerId = normalizePlayerId(playerId);
        playerNameLabel.setText(playerId); // Update header immediately
        lastRefreshTimestamp = System.currentTimeMillis();
        
        // Update the search box (needed for pvp lookup right-click menu)
        if (loginPanel != null) {
            loginPanel.setPluginSearchText(playerId);
        }

        resetUiForNewSearch();

        try {
            String normalizedId = currentMatchesPlayerId;
            loadPlayerStats(normalizedId);

            // Determine if this is "self" lookup - use acct-based query for accurate match history
            // across name changes; use name-based query for searching other players
            String selfName = plugin != null ? plugin.getLocalPlayerName() : null;
            String selfNameNormalized = normalizePlayerId(selfName);
            boolean isSelf = selfNameNormalized != null && selfNameNormalized.equalsIgnoreCase(normalizedId);
            
            CompletableFuture<JsonObject> matchesFuture;
            if (isSelf) {
                // Self lookup - use acct SHA for accurate history across name changes
                String selfAcctSha = pvpDataService.getSelfAcctSha();
                if (selfAcctSha != null && !selfAcctSha.isEmpty()) {
                    matchesFuture = pvpDataService.getPlayerMatchesByAcct(selfAcctSha, null, MATCHES_PAGE_SIZE, false);
                } else {
                    // Fallback to name-based if acct SHA not available
                    matchesFuture = pvpDataService.getPlayerMatches(normalizedId, null, MATCHES_PAGE_SIZE);
                }
            } else {
                // Other player lookup - use name-based query
                matchesFuture = pvpDataService.getPlayerMatches(normalizedId, null, MATCHES_PAGE_SIZE);
            }

            matchesFuture.thenAccept(jsonResponse -> {
                if (jsonResponse == null) return;
                
                JsonArray matches = jsonResponse.has("matches") && jsonResponse.get("matches").isJsonArray() ? jsonResponse.getAsJsonArray("matches") : new JsonArray();
                // String nextToken = jsonResponse.has("next_token") && !jsonResponse.get("next_token").isJsonNull() ? jsonResponse.get("next_token").getAsString() : null;

                SwingUtilities.invokeLater(() -> {
                    updateUiWithMatches(matches);
                });
            });
        } catch (Exception ignore) {}
    }

    private void updateUiWithMatches(JsonArray matches) {
        matchHistoryPanel.setMatches(matches);
        chartPanel.setMatches(matches);
        extraStatsPanel.setMatches(matches);
        performanceStatsPanel.updateBreakdown(matches);
        allMatches = matches;
        
        // Update summary stats
        int wins = 0, losses = 0, ties = 0;
        for (int i = 0; i < matches.size(); i++) {
             JsonObject m = matches.get(i).getAsJsonObject();
             String r = m.has("result") ? m.get("result").getAsString().toLowerCase() : "";
             if ("win".equals(r)) wins++;
             else if ("loss".equals(r)) losses++;
             else if ("tie".equals(r)) ties++;
                }
        performanceStatsPanel.updateStats(wins, losses, ties);
        
        updateBucketBarsFromMatches();
    }

    private void resetUiForNewSearch()
            {
        rankProgressPanel.reset();
        performanceStatsPanel.reset();
        matchHistoryPanel.clear();
                chartPanel.setMatches(new JsonArray());
        extraStatsPanel.setMatches(new JsonArray());
        allMatches = null;
    }
    
    private void loadPlayerStats(String playerId)
    {
        try {
            String clientUniqueId = (plugin != null) ? plugin.getClientUniqueId() : null;
            
            pvpDataService.getUserProfile(playerId, clientUniqueId).thenAccept(stats -> {
                if (stats == null) return;
                SwingUtilities.invokeLater(() -> updateProgressBars(stats));
                        });
        } catch (Exception ignore) {}
    }
    
    private void updateProgressBars(JsonObject stats)
    {
        String playerName = null;
        if (stats.has("player_name")) playerName = stats.get("player_name").getAsString();
        else if (stats.has("player_id")) playerName = stats.get("player_id").getAsString();
        
        if (playerName != null) updatePlayerStats(stats, playerName);
    }
    
    private void updatePlayerStats(JsonObject stats, String playerName)
    {
        SwingWorker<Void, Void> worker = new SwingWorker<Void, Void>()
        {
            @Override
            protected Void doInBackground() throws Exception
            {
                // Overall
                applyBucketStatsFromUser(playerName, "overall", stats);
                
                // Buckets
                JsonObject bucketsObj = stats.has("buckets") ? stats.getAsJsonObject("buckets") : null;
                String[] bucketKeys = {"nh", "veng", "multi", "dmm"};
                for (String bucketKey : bucketKeys) {
                    JsonObject bucketObj = (bucketsObj != null && bucketsObj.has(bucketKey)) ? bucketsObj.getAsJsonObject(bucketKey) : null;
                    applyBucketStatsFromUser(playerName, bucketKey, bucketObj);
                }
                return null;
            }
        };
        worker.execute();
    }
    
    private void applyBucketStatsFromUser(String playerName, String bucketKey, JsonObject bucketObj)
    {
        if (bucketObj == null) {
            rankProgressPanel.updateBucket(bucketKey, "", 0, 0, -1);
            return;
        }
        
        String rankLabel = "";
        int division = 0;
        double pct = 0.0;
        
        if (bucketObj.has("mmr")) {
            RankInfo ri = RankUtils.rankLabelAndProgressFromMMR(bucketObj.get("mmr").getAsDouble());
            if (ri != null) { rankLabel = ri.rank; division = ri.division; pct = ri.progress; }
        }
        if (bucketObj.has("rank_progress")) {
             JsonObject rp = bucketObj.getAsJsonObject("rank_progress");
             if (rp.has("progress_to_next_rank_pct")) pct = rp.get("progress_to_next_rank_pct").getAsDouble();
        }
        if (bucketObj.has("rank")) {
             String r = bucketObj.get("rank").getAsString();
             if (!r.isEmpty()) rankLabel = r; // Simple parse if needed
             // Reuse existing RankUtils parsing if complex, simplified here
        }
        if (bucketObj.has("division")) division = bucketObj.get("division").getAsInt();
        
        final String fRank = rankLabel;
        final int fDiv = division;
        final double fPct = pct;
        
        rankProgressPanel.updateBucket(bucketKey, fRank, fDiv, fPct, -1);
        
        if (!"".equals(fRank)) {
            new SwingWorker<Integer, Void>() {
                @Override protected Integer doInBackground() { return getRankNumberFromLeaderboard(playerName, bucketKey); }
                @Override protected void done() {
                     try {
                         int rank = get();
                         if (rank > 0) rankProgressPanel.updateBucket(bucketKey, fRank, fDiv, fPct, rank);
                    } catch (Exception ignore) {}
                }
            }.execute();
            }
    }
    
    private void updateBucketBarsFromMatches() {
        if (allMatches == null || allMatches.size() == 0) return;
        String playerName = playerNameLabel.getText();
        if ("Player Name".equals(playerName)) return;
        
                String[] buckets = {"overall", "nh", "veng", "multi", "dmm"};
        for (String bucket : buckets)
        {
            JsonArray items = new JsonArray();
            for (int i = 0; i < allMatches.size(); i++)
            {
                JsonObject match = allMatches.get(i).getAsJsonObject();
                String matchBucket = match.has("bucket") ? match.get("bucket").getAsString().toLowerCase() : "";
                if (matchBucket.equals(bucket)) items.add(match);
            }
            
            if (items.size() == 0) continue;
            
            // Find latest match by timestamp
            JsonObject latest = null;
            for (int i = 0; i < items.size(); i++)
            {
                JsonObject item = items.get(i).getAsJsonObject();
                if (latest == null || 
                    (item.has("when") && latest.has("when") && 
                     item.get("when").getAsLong() > latest.get("when").getAsLong()))
                {
                    latest = item;
                }
            }
            
            if (latest != null && latest.has("player_mmr"))
            {
                double mmr = latest.get("player_mmr").getAsDouble();
                RankInfo est = RankUtils.rankLabelAndProgressFromMMR(mmr);
                
                String finalRank = latest.has("player_rank") ? latest.get("player_rank").getAsString() : (est != null ? est.rank : "");
                int finalDiv = latest.has("player_division") ? latest.get("player_division").getAsInt() : (est != null ? est.division : 0);
                double pct = (est != null ? est.progress : 0.0);
                
                // Only fetch rank number for currently selected rank bucket
                String currentBucket = "overall";
                if (bucket.equals(currentBucket))
                {
                SwingWorker<Integer, Void> worker = new SwingWorker<Integer, Void>()
                {
                        @Override protected Integer doInBackground() { return getRankNumberFromLeaderboard(playerName, bucket); }
                        @Override protected void done() {
                            try {
                            int rankNumber = get();
                                rankProgressPanel.updateBucket(bucket, finalRank, finalDiv, pct, rankNumber);
                            } catch (Exception e) {
                                rankProgressPanel.updateBucket(bucket, finalRank, finalDiv, pct, -1);
                        }
                    }
                };
                worker.execute();
                } else {
                    rankProgressPanel.updateBucket(bucket, finalRank, finalDiv, pct, -1);
                }
            }
        }
    }

    // --- Helpers ---
    
    public int getRankNumberFromLeaderboard(String playerName, String bucket)
    {
        try {
            String canonBucket = bucket == null ? "overall" : bucket.toLowerCase();
            // Single path - shard contains world_rank
            ShardRank sr = pvpDataService.getShardRankByName(playerName, canonBucket).get();
            return sr != null && sr.rank > 0 ? sr.rank : -1;
        } catch (Exception ignore) { return -1; }
    }

    private static String normalizePlayerId(String name) {
        return name != null ? name.trim().replaceAll("\\s+", " ").toLowerCase() : null;
    }
}

package com.pvp.leaderboard.ui;

import javax.swing.*;
import java.awt.*;

public class RankProgressPanel extends JPanel
{
    private static final int SIDEBAR_SCROLLBAR_RESERVE_PX = 16;
    private static final int PROGRESS_BAR_WIDTH = 200;
    private static final int PROGRESS_BAR_HEIGHT = 16;

    private final JProgressBar[] progressBars;
    private final JLabel[] progressLabels;
    private final String[] buckets = {"Overall", "NH", "Veng", "Multi", "DMM"};

    public RankProgressPanel()
    {
        progressBars = new JProgressBar[5];
        progressLabels = new JLabel[5];

        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        setBorder(BorderFactory.createTitledBorder("Season 0"));

        initUI();
    }

    private void initUI()
    {
        for (int i = 0; i < buckets.length; i++)
        {
            JPanel bucketPanel = new JPanel(new BorderLayout());
            bucketPanel.setBorder(BorderFactory.createEmptyBorder(0, 6, 0, SIDEBAR_SCROLLBAR_RESERVE_PX));
            bucketPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 40));
            
            progressLabels[i] = new JLabel(buckets[i] + " -  (0.0%) ");
            progressLabels[i].setFont(progressLabels[i].getFont().deriveFont(Font.BOLD));
            bucketPanel.add(progressLabels[i], BorderLayout.NORTH);
            
            progressBars[i] = new JProgressBar(0, 100);
            progressBars[i].setValue(0);
            progressBars[i].setStringPainted(true);
            progressBars[i].setString("0%");
            progressBars[i].setPreferredSize(new Dimension(PROGRESS_BAR_WIDTH, PROGRESS_BAR_HEIGHT));
            progressBars[i].setMinimumSize(new Dimension(PROGRESS_BAR_WIDTH, PROGRESS_BAR_HEIGHT));
            progressBars[i].setMaximumSize(new Dimension(PROGRESS_BAR_WIDTH, PROGRESS_BAR_HEIGHT));
            progressBars[i].setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));
            
            JPanel barRow = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
            barRow.setOpaque(false);
            barRow.add(progressBars[i]);
            bucketPanel.add(barRow, BorderLayout.CENTER);
            
            add(bucketPanel);
            if (i < buckets.length - 1) add(Box.createVerticalStrut(8));
        }
    }

    public void updateBucket(String bucket, String rankLabel, int division, double pct, int rankNumber)
    {
        int idx = getBucketIndex(bucket);
        if (idx >= 0 && idx < progressBars.length)
        {
            SwingUtilities.invokeLater(() -> {
                if (progressLabels[idx] != null)
                {
                    String displayRank = rankLabel + (division > 0 ? " " + division : "");
                    String text = buckets[idx] + " - " + displayRank + " (" + Math.round(pct) + "%)";
                    if (rankNumber > 0)
                    {
                        text += " #" + rankNumber;
                    }
                    progressLabels[idx].setText(text);
                }
                if (progressBars[idx] != null)
                {
                    progressBars[idx].setValue((int) pct);
                    progressBars[idx].setString(Math.round(pct) + "%");
                }
            });
        }
    }
    
    public void reset()
    {
        SwingUtilities.invokeLater(() -> {
            for (int i = 0; i < progressLabels.length; i++)
            {
                if (progressLabels[i] != null)
                {
                    progressLabels[i].setText(buckets[i] + " -  (0.0%)");
                }
                if (progressBars[i] != null)
                {
                    progressBars[i].setValue(0);
                    progressBars[i].setString("0%");
                }
            }
        });
    }

    private int getBucketIndex(String bucket)
    {
        if (bucket == null) return -1;
        String b = bucket.toLowerCase();
        if ("overall".equals(b)) return 0;
        if ("nh".equals(b)) return 1;
        if ("veng".equals(b)) return 2;
        if ("multi".equals(b)) return 3;
        if ("dmm".equals(b)) return 4;
        return -1;
    }
}


package com.pvp.leaderboard.ui;

import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.pvp.leaderboard.util.RankUtils;
import javax.swing.*;
import java.awt.*;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.stream.Collectors;

public class AdditionalStatsPanel extends JPanel {
    private final JLabel highestRankLabel = new JLabel("-");
    private final JLabel highestTimeLabel = new JLabel("-");
    private final JLabel lowestRankLabel = new JLabel("-");
    private final JLabel lowestTimeLabel = new JLabel("-");
    private final JButton overallBtn = new JButton("Overall");
    private final JButton nhBtn = new JButton("NH");
    private final JButton vengBtn = new JButton("Veng");
    private final JButton multiBtn = new JButton("Multi");
    private final JButton dmmBtn = new JButton("DMM");
    private final TierGraphPlotPanel graphPlot = new TierGraphPlotPanel();
    private final TierGraphLabelsPanel graphLabels = new TierGraphLabelsPanel();
    private static final Dimension GRAPH_LABELS_SIZE = new Dimension(80, 240);
    private static final Dimension GRAPH_PLOT_SIZE   = new Dimension(160, 240);

    private final SimpleDateFormat fmt = new SimpleDateFormat("M/d/yyyy, h:mm:ss a");
    private String selectedBucket = "overall";
    private JsonArray matches = new JsonArray();

    public AdditionalStatsPanel() {
        setLayout(new BorderLayout());
        setBorder(BorderFactory.createTitledBorder("Additional Stats"));

        JPanel content = new JPanel(new GridBagLayout());
        GridBagConstraints root = new GridBagConstraints();
        root.gridx = 0;
        root.gridy = 0;
        root.anchor = GridBagConstraints.WEST;
        root.fill = GridBagConstraints.HORIZONTAL;
        root.weightx = 1.0;

        JPanel statsRow = new JPanel(new GridLayout(2, 2, 24, 2));
        statsRow.add(makeStat("Highest Rank Defeated", highestRankLabel, highestTimeLabel));
        statsRow.add(makeStat("Lowest Rank Lost To",   lowestRankLabel,  lowestTimeLabel));
        content.add(statsRow, root);
        root.gridy++;

        // no extra controls here; simplified per request

        // Ensure all chips are visible in narrow sidebar by splitting into multiple short rows
        // and forcing the rows to occupy full available width anchored left.
        JPanel chips = new JPanel(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0; gbc.gridy = 0; gbc.anchor = GridBagConstraints.WEST; gbc.fill = GridBagConstraints.NONE; gbc.weightx = 1.0;
        JPanel row1 = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
        JPanel row2 = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
        JPanel row3 = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
        java.util.List<JButton> allChips = Arrays.asList(overallBtn, nhBtn, vengBtn, multiBtn, dmmBtn);
        for (int i = 0; i < allChips.size(); i++) {
            JButton b = allChips.get(i);
            b.setFocusPainted(false);
            b.setMargin(new Insets(2,10,2,10));
            Dimension chip = new Dimension(64, 24);
            b.setPreferredSize(chip);
            b.setMinimumSize(chip);
            b.setMaximumSize(chip);
            Dimension pd = b.getPreferredSize();
            b.setMinimumSize(pd);
            if (i < 2) { row1.add(b); }
            else if (i < 4) { row2.add(b); }
            else { row3.add(b); }
        }
        row1.setAlignmentX(LEFT_ALIGNMENT);
        row2.setAlignmentX(LEFT_ALIGNMENT);
        row3.setAlignmentX(LEFT_ALIGNMENT);
        // Add rows to a filling GridBag to eliminate centering and ensure full-width rows
        chips.add(row1, gbc);
        gbc.gridy = 1; chips.add(row2, gbc);
        gbc.gridy = 2; chips.add(row3, gbc);
        chips.setAlignmentX(LEFT_ALIGNMENT);
        chips.setMaximumSize(new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE));
        overallBtn.addActionListener(e -> setBucket("overall"));
        nhBtn.addActionListener(e -> setBucket("nh"));
        vengBtn.addActionListener(e -> setBucket("veng"));
        multiBtn.addActionListener(e -> setBucket("multi"));
        dmmBtn.addActionListener(e -> setBucket("dmm"));

        // Place chips block in the root content grid to keep it hard-left
        content.add(chips, root);
        root.gridy++;

        // Fixed-size graph (no scrollbars) to fit narrow sidebar
        graphLabels.setPreferredSize(GRAPH_LABELS_SIZE);
        graphPlot.setPreferredSize(GRAPH_PLOT_SIZE);
        JPanel graphRow = new JPanel(new BorderLayout());
        graphRow.add(graphLabels, BorderLayout.WEST);
        graphRow.add(graphPlot, BorderLayout.CENTER);
        content.add(graphRow, root);
        root.gridy++;

        // Add content to BorderLayout.NORTH so everything is anchored to top-left of panel
        add(content, BorderLayout.NORTH);

        updateChipStyles();
    }

    public void setMatches(JsonArray newMatches) {
        this.matches = (newMatches != null) ? newMatches : new JsonArray();
        updateAdditionalStats();
        rebuildSeries();
        updateGraphSize();
    }

    public void setBucket(String bucket) {
        this.selectedBucket = (bucket == null ? "overall" : bucket.toLowerCase(Locale.ROOT));
        updateChipStyles();
        rebuildSeries();
        updateGraphSize();
    }

    private JPanel makeStat(String title, JLabel value, JLabel time) {
        JPanel p = new JPanel();
        p.setLayout(new BoxLayout(p, BoxLayout.Y_AXIS));
        JLabel t = new JLabel(title);
        t.setFont(t.getFont().deriveFont(Font.BOLD, 16f));
        value.setFont(value.getFont().deriveFont(Font.BOLD, 18f));
        time.setForeground(new Color(230, 200, 80));
        p.add(t);
        p.add(Box.createVerticalStrut(4));
        p.add(value);
        p.add(time);
        return p;
    }

    private void updateChipStyles() {
        Map<String, JButton> map = new HashMap<>();
        map.put("overall", overallBtn);
        map.put("nh", nhBtn);
        map.put("veng", vengBtn);
        map.put("multi", multiBtn);
        map.put("dmm", dmmBtn);
        for (Map.Entry<String, JButton> e : map.entrySet()) {
            boolean active = e.getKey().equals(selectedBucket);
            e.getValue().setEnabled(!active);
            e.getValue().setBackground(active ? Color.DARK_GRAY : UIManager.getColor("Panel.background"));
            e.getValue().setForeground(active ? Color.YELLOW : UIManager.getColor("Label.foreground"));
        }
    }

    private void updateAdditionalStats() {
        String bestRank = null; Long bestTs = null;
        String worstRank = null; Long worstTs = null;

        for (int i = 0; i < matches.size(); i++) {
            JsonObject m = matches.get(i).getAsJsonObject();
            String bucket = asStr(m, "bucket").toLowerCase(Locale.ROOT);
            if (!selectedBucket.equals("overall") && !bucket.equals(selectedBucket)) continue;

            String result = asStr(m, "result").toLowerCase(Locale.ROOT);
            long ts = m.has("when") ? (long) Math.floor(m.get("when").getAsDouble()) : 0;

            String oppRank = rankLabel(asStr(m, "opponent_rank"), asInt(m, "opponent_division"));
            if (oppRank.isEmpty()) continue;

            if ("win".equals(result)) {
                if (bestRank == null || RankUtils.getRankOrder(oppRank) > RankUtils.getRankOrder(bestRank)) {
                    bestRank = oppRank; bestTs = ts;
                }
            } else if ("loss".equals(result)) {
                if (worstRank == null || RankUtils.getRankOrder(oppRank) < RankUtils.getRankOrder(worstRank)) {
                    worstRank = oppRank; worstTs = ts;
                }
            }
        }

        highestRankLabel.setText(bestRank != null ? bestRank : "-");
        highestTimeLabel.setText(bestTs != null ? fmt.format(new Date(bestTs * 1000)) : "-");
        lowestRankLabel.setText(worstRank != null ? worstRank : "-");
        lowestTimeLabel.setText(worstTs != null ? fmt.format(new Date(worstTs * 1000)) : "-");
    }

    private void rebuildSeries() {
        java.util.List<JsonObject> items = new ArrayList<>();
        for (int i = 0; i < matches.size(); i++) items.add(matches.get(i).getAsJsonObject());
        // Sort ascending by time like the site (oldest  newest)
        items = items.stream()
                .filter(m -> selectedBucket.equals("overall") || selectedBucket.equalsIgnoreCase(asStr(m, "bucket")))
                .sorted(Comparator.comparingDouble(m -> m.has("when") ? m.get("when").getAsDouble() : 0))
                .limit(1000)
                .collect(Collectors.toList());

        final String want = selectedBucket;
        final int MAX_MMR_DELTA_PER_MATCH = 250;

        // Build raw rank index values (0..24)
        java.util.List<Double> rawY = new ArrayList<>();
        if ("overall".equals(want)) {
            // Weighted overall: NH 0.55, Veng 0.30, Multi 0.05, DMM 0.10 (sums to 1.0)
            final Map<String, Double> weights = new HashMap<>();
            weights.put("nh", 0.55); weights.put("veng", 0.30); weights.put("multi", 0.05); weights.put("dmm", 0.10);
            final Map<String, Double> last = new HashMap<>();
            last.put("nh", 1000.0); last.put("veng", 1000.0); last.put("multi", 1000.0); last.put("dmm", 1000.0);

            for (JsonObject m : items) {
                String b = asStr(m, "bucket").toLowerCase(Locale.ROOT);
                if (weights.containsKey(b)) {
                    Double prev = last.get(b);
                    double mu = resolveMuFromMatch(m, prev);
                    if (Double.isFinite(mu)) {
                        if (!Double.isFinite(prev) || Math.abs(mu - prev) <= MAX_MMR_DELTA_PER_MATCH) {
                            last.put(b, mu);
                        }
                    }
                }
                double overallMu = 0.0;
                for (Map.Entry<String, Double> e : weights.entrySet()) {
                    double mu = last.getOrDefault(e.getKey(), 1000.0);
                    overallMu += mu * e.getValue();
                }
                rawY.add(RankUtils.calculateContinuousTierValue(overallMu));
            }
        } else {
            Double prevMu = null;
            for (JsonObject m : items) {
                double mu = resolveMuFromMatch(m, prevMu);
                double chosen;
                if (Double.isFinite(mu)) {
                    if (prevMu != null && Double.isFinite(prevMu) && Math.abs(mu - prevMu) > MAX_MMR_DELTA_PER_MATCH) chosen = prevMu; else { chosen = mu; prevMu = mu; }
                } else {
                    chosen = (prevMu != null) ? prevMu : 1000.0;
                }
                rawY.add(RankUtils.calculateContinuousTierValue(chosen));
            }
        }

        // Compute visible range snapped to division-3 boundaries (no extra padding)
        double minY = 24.0, maxYv = 0.0;
        for (Double yv : rawY) { if (yv != null && Double.isFinite(yv)) { minY = Math.min(minY, yv); maxYv = Math.max(maxYv, yv); } }
        if (!Double.isFinite(minY)) { minY = 0.0; }
        if (!Double.isFinite(maxYv)) { maxYv = 24.0; }
        double low = Math.max(0, (int)Math.floor(minY / 3.0) * 3);
        double high = Math.min(24, (int)Math.ceil(maxYv / 3.0) * 3);
        if (high <= low) high = Math.min(24, low + 3); // ensure a span
        graphLabels.setVisibleRange(low, high);
        graphPlot.setVisibleRange(low, high);

        // Normalize to 0..100 within the visible range
        java.util.List<Double> series = new ArrayList<>();
        double span = Math.max(1e-6, high - low);
        for (Double yv : rawY) {
            double y = (yv != null && Double.isFinite(yv)) ? yv : low;
            double norm = Math.max(0.0, Math.min(100.0, ((y - low) / span) * 100.0));
            series.add(norm);
        }
        graphPlot.setSeries(series);
        graphLabels.repaint();
    }

    // Choose the post-match MMR for a row when available; otherwise fall back.
    private static double resolveMuFromMatch(JsonObject m, Double prevMu) {
        try {
            // Prefer explicit post-match fields if present
            if (m.has("player_mmr_after") && !m.get("player_mmr_after").isJsonNull()) {
                return m.get("player_mmr_after").getAsDouble();
            }
            if (m.has("player_new_mmr") && !m.get("player_new_mmr").isJsonNull()) {
                return m.get("player_new_mmr").getAsDouble();
            }
            if (m.has("player_mmr") && !m.get("player_mmr").isJsonNull()) {
                return m.get("player_mmr").getAsDouble();
            }
            // Reconstruct from delta if possible
            if (m.has("rating_change") && m.get("rating_change").isJsonObject()) {
                JsonObject rc = m.getAsJsonObject("rating_change");
                if (rc.has("mmr_delta") && !rc.get("mmr_delta").isJsonNull() && prevMu != null) {
                    double delta = rc.get("mmr_delta").getAsDouble();
                    return prevMu + delta;
                }
            }
        } catch (Exception ignore) {}
        return Double.NaN;
    }

    private void updateGraphSize() {
        // Keep fixed sizes to avoid scrollbars in Additional Stats
        graphLabels.setPreferredSize(GRAPH_LABELS_SIZE);
        graphPlot.setPreferredSize(GRAPH_PLOT_SIZE);
        graphLabels.revalidate();
        graphPlot.revalidate();
        graphLabels.repaint();
        graphPlot.repaint();
    }

    private static String asStr(JsonObject o, String k) {
        return (o.has(k) && !o.get(k).isJsonNull()) ? o.get(k).getAsString() : "";
    }
    private static int asInt(JsonObject o, String k) {
        try { return o.has(k) && !o.get(k).isJsonNull() ? o.get(k).getAsInt() : 0; } catch (Exception e) { return 0; }
    }
    

    private static String rankLabel(String rank, int division) {
        if (rank == null || rank.isEmpty()) return "";
        return division > 0 ? (rank + " " + division) : rank;
    }

    // Fixed-width labels + guides panel
    private static class TierGraphLabelsPanel extends JPanel {
        private double vMin = 0.0, vMax = 24.0;
        void setVisibleRange(double a, double b) { this.vMin = a; this.vMax = b; repaint(); }
        @Override protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            Graphics2D g2 = (Graphics2D) g;
            g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
            int w = getWidth(), h = getHeight();
            int top = 20, bottom = 20; int innerH = Math.max(1, h - top - bottom);
            // draw labels for the visible range only, with tier colors
            int start = (int)Math.floor(vMin);
            int end = (int)Math.ceil(vMax);
            for (int gi = start; gi <= end; gi++) {
                double frac = (gi - vMin) / Math.max(1e-6, (vMax - vMin));
                int y = top + innerH - (int) Math.round(frac * innerH);
                g2.setColor(new Color(120,120,120));
                g2.drawLine(0, y, w, y);
                int base = gi / 3; int off = gi % 3; String baseRank = RankUtils.THRESHOLDS[Math.min(base * 3, RankUtils.THRESHOLDS.length - 1)][0];
                // Only render division 3 labels (off==0) and 3rd Age
                if (off == 0) {
                    String label = baseRank.equals("3rd Age") ? baseRank : baseRank + " 3";
                    g2.setColor(RankUtils.getRankColor(baseRank));
                    g2.drawString(label, 2, y + 5);
                }
            }
        }
    }

    // Plot panel that renders the series and full-width guides
    private static class TierGraphPlotPanel extends JPanel {
        private double vMin = 0.0, vMax = 24.0;
        void setVisibleRange(double a, double b) { this.vMin = a; this.vMax = b; repaint(); }
        private java.util.List<Double> series = new ArrayList<>();
        void setSeries(java.util.List<Double> s) { this.series = (s != null) ? s : new ArrayList<>(); repaint(); }
        @Override protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            Graphics2D g2 = (Graphics2D) g;
            g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
            int w = getWidth(), h = getHeight();
            int left = 0, bottom = 20, top = 20, right = 20;
            int innerW = Math.max(1, w - left - right);
            int innerH = Math.max(1, h - top - bottom);

            g2.setColor(new Color(120,120,120));
            int start = (int)Math.floor(vMin);
            int end = (int)Math.ceil(vMax);
            for (int gi = start; gi <= end; gi++) {
                int off = gi % 3;
                if (off != 0) continue; // only draw division 3 guides
                double frac = (gi - vMin) / Math.max(1e-6, (vMax - vMin)); // 0 bottom .. 1 top
                int y = top + innerH - (int) Math.round(frac * innerH);
                g2.drawLine(left, y, left + innerW, y);
            }

            if (series.size() > 1) {
                g2.setColor(Color.WHITE);
                g2.setStroke(new BasicStroke(2f));
                for (int i = 0; i < series.size() - 1; i++) {
                    int x1 = left + (i * innerW / Math.max(1, series.size() - 1));
                    int x2 = left + ((i + 1) * innerW / Math.max(1, series.size() - 1));
                    int y1 = top + innerH - (int) Math.round((series.get(i) / 100.0) * innerH);
                    int y2 = top + innerH - (int) Math.round((series.get(i + 1) / 100.0) * innerH);
                    g2.drawLine(x1, y1, x2, y2);
                }
            } else {
                g2.setColor(Color.GRAY);
                g2.drawString("No tier data available", w / 2 - 60, h / 2);
            }
        }
    }
}

package com.pvp.leaderboard.ui;

import com.google.gson.JsonArray;
import com.google.gson.JsonObject;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.util.HashMap;
import java.util.Map;

public class PerformanceStatsPanel extends JPanel
{
    private JLabel winPercentLabel;
    
    private DefaultTableModel rankBreakdownModel;
    private JTable rankBreakdownTable;

    public PerformanceStatsPanel()
    {
        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        setBorder(BorderFactory.createTitledBorder("Last 100 Game Performance"));
        
        initUI();
    }

    private void initUI()
    {
        JPanel summaryRow = new JPanel(new FlowLayout(FlowLayout.LEFT, 6, 0));
        winPercentLabel = new JLabel("- % Winrate");
        
        Font baseFont = winPercentLabel.getFont();
        Font small = baseFont.deriveFont(Font.PLAIN, Math.max(10f, baseFont.getSize2D() - 1f));
        winPercentLabel.setFont(small);
        
        summaryRow.add(winPercentLabel);
        add(summaryRow);

        // Rank breakdown table
        add(createRankBreakdownTable());
    }

    private JPanel createRankBreakdownTable()
    {
        String[] columns = {"Rank", "Wins", "Losses"};
        rankBreakdownModel = new DefaultTableModel(columns, 0);
        rankBreakdownTable = new JTable(rankBreakdownModel);
        rankBreakdownTable.setEnabled(false);
        
        // Set all columns to the same width
        int columnWidth = 60;
        for (int i = 0; i < rankBreakdownTable.getColumnCount(); i++) {
            rankBreakdownTable.getColumnModel().getColumn(i).setPreferredWidth(columnWidth);
            rankBreakdownTable.getColumnModel().getColumn(i).setMinWidth(columnWidth);
            rankBreakdownTable.getColumnModel().getColumn(i).setMaxWidth(columnWidth);
        }
        rankBreakdownTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
        
        JScrollPane sp = new JScrollPane(rankBreakdownTable);
        sp.setPreferredSize(new Dimension(0, 150)); // Adjusted height
        
        // Wrap in panel to control sizing better if needed
        JPanel p = new JPanel(new BorderLayout());
        p.add(sp, BorderLayout.CENTER);
        p.setPreferredSize(new Dimension(0, 340)); // Match original preferred size
        return p;
    }

    public void updateStats(int wins, int losses, int ties)
    {
        SwingUtilities.invokeLater(() -> {
            int total = wins + losses + ties;
            double winRate = total > 0 ? (double) wins / total * 100 : 0;
            
            winPercentLabel.setText(String.format("%.1f%% Winrate", winRate));
        });
    }

    public void updateBreakdown(JsonArray matches)
    {
        SwingUtilities.invokeLater(() -> {
            if (rankBreakdownModel == null || matches == null) return;
            rankBreakdownModel.setRowCount(0);
            
            Map<String, int[]> stats = new HashMap<>();
            for (int i = 0; i < matches.size(); i++)
            {
                JsonObject m = matches.get(i).getAsJsonObject();
                String result = m.has("result") ? m.get("result").getAsString().toLowerCase() : "";
                String oppRank = m.has("opponent_rank") ? m.get("opponent_rank").getAsString() : "Unranked";
                
                stats.putIfAbsent(oppRank, new int[]{0, 0});
                if ("win".equals(result)) stats.get(oppRank)[0]++;
                else if ("loss".equals(result)) stats.get(oppRank)[1]++;
            }
            
            for (Map.Entry<String, int[]> e : stats.entrySet())
            {
                rankBreakdownModel.addRow(new Object[]{e.getKey(), e.getValue()[0], e.getValue()[1]});
            }
        });
    }

    public void reset()
    {
        updateStats(0, 0, 0);
        SwingUtilities.invokeLater(() -> {
            if (rankBreakdownModel != null) rankBreakdownModel.setRowCount(0);
        });
    }
}


package com.pvp.leaderboard.ui;

import javax.swing.*;
import java.awt.*;
import java.util.List;
import java.util.ArrayList;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;

public class WinRateChartPanel extends JPanel
{
    private List<Double> winRateHistory = new ArrayList<>();

    public WinRateChartPanel()
    {
        setPreferredSize(new Dimension(1024, 280));
    }

    public void setMatches(JsonArray matches)
    {
        this.winRateHistory = calculateWinRateHistory(matches);
        setPreferredSize(new Dimension(Math.max(240, winRateHistory.size() * 5), 200));
        revalidate();
        repaint();
    }

    private List<Double> calculateWinRateHistory(JsonArray matches)
    {
        List<Double> history = new ArrayList<>();
        if (matches == null || matches.size() == 0) return history;

        // Sort by time ascending
        List<JsonObject> sorted = new ArrayList<>();
        for (int i = 0; i < matches.size(); i++) sorted.add(matches.get(i).getAsJsonObject());
        sorted.sort((a, b) -> {
            double ta = a.has("when") ? a.get("when").getAsDouble() : 0;
            double tb = b.has("when") ? b.get("when").getAsDouble() : 0;
            return Double.compare(ta, tb);
        });

        int wins = 0;
        int total = 0;
        for (JsonObject m : sorted)
        {
            String result = m.has("result") ? m.get("result").getAsString().toLowerCase() : "";
            if ("win".equals(result)) wins++;
            if ("win".equals(result) || "loss".equals(result))
            {
                total++;
                if (total >= 10) // Only show after 10 games to avoid noise
                {
                    history.add((double) wins / total * 100.0);
                }
            }
        }
        return history;
    }

    @Override
    protected void paintComponent(Graphics g)
    {
        super.paintComponent(g);
        Graphics2D g2 = (Graphics2D) g;
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        int width = getWidth() - 40;
        int height = getHeight() - 40;

        if (width <= 0 || height <= 0) return;

        // Draw axes
        g2.setColor(Color.LIGHT_GRAY);
        g2.drawLine(20, height + 20, width + 20, height + 20);
        g2.drawLine(20, 20, 20, height + 20);

        // Draw grid lines and Y-axis labels
        g2.setColor(Color.GRAY);
        for (int i = 0; i <= 10; i++)
        {
            int y = 20 + (i * height / 10);
            g2.drawLine(20, y, width + 20, y);
            g2.setColor(Color.WHITE);
            g2.drawString((100 - i * 10) + "%", 2, y + 5);
            g2.setColor(Color.GRAY);
        }

        // Draw X-axis labels and win rate line
        if (winRateHistory != null && winRateHistory.size() > 1)
        {
            // Draw X-axis labels (match numbers)
            g2.setColor(Color.WHITE);
            int maxTicks = Math.min(8, winRateHistory.size());
            for (int i = 0; i < maxTicks; i++)
            {
                int x = 20 + (i * width / (maxTicks - 1));
                int matchNum = winRateHistory.size() - (i * winRateHistory.size() / (maxTicks - 1));
                g2.drawString("#" + matchNum, x - 10, height + 35);
            }

            // Draw win rate line
            g2.setColor(new Color(255, 215, 0)); // Gold color
            g2.setStroke(new BasicStroke(2));
            for (int i = 0; i < winRateHistory.size() - 1; i++)
            {
                int x1 = 20 + (i * width / (winRateHistory.size() - 1));
                int y1 = height + 20 - (int)(winRateHistory.get(i) * height / 100);
                int x2 = 20 + ((i + 1) * width / (winRateHistory.size() - 1));
                int y2 = height + 20 - (int)(winRateHistory.get(i + 1) * height / 100);
                g2.drawLine(x1, y1, x2, y2);
            }
        }
        else
        {
            g2.setColor(Color.GRAY);
            g2.drawString("No match data available", width / 2 - 60, height / 2);
        }
    }
}

package com.pvp.leaderboard.ui;

import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.pvp.leaderboard.util.RankUtils;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.text.SimpleDateFormat;
import java.util.Date;

public class MatchHistoryPanel extends JPanel
{
    private JTable matchHistoryTable;
    private DefaultTableModel tableModel;

    public MatchHistoryPanel()
    {
        setLayout(new BorderLayout());
        setBorder(BorderFactory.createTitledBorder("Match History"));
        
        createTable();
    }

    private void createTable()
    {
        String[] columns = {"Res", "Opponent", "Type", "Match", "Change", "Time"};
        tableModel = new DefaultTableModel(columns, 0);
        matchHistoryTable = new JTable(tableModel);
        matchHistoryTable.setFillsViewportHeight(true);
        matchHistoryTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
        try {
            matchHistoryTable.getColumnModel().getColumn(0).setPreferredWidth(40);
            matchHistoryTable.getColumnModel().getColumn(1).setPreferredWidth(140);
            matchHistoryTable.getColumnModel().getColumn(2).setPreferredWidth(60);
            matchHistoryTable.getColumnModel().getColumn(3).setPreferredWidth(220);
            matchHistoryTable.getColumnModel().getColumn(4).setPreferredWidth(180);
            matchHistoryTable.getColumnModel().getColumn(5).setPreferredWidth(120);
        } catch (Exception ignore) {}

        JScrollPane scrollPane = new JScrollPane(matchHistoryTable);
        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
        scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
        scrollPane.setPreferredSize(new Dimension(0, 300));
        add(scrollPane, BorderLayout.CENTER);
    }

    public void setMatches(JsonArray matches)
    {
        SwingUtilities.invokeLater(() -> {
            tableModel.setRowCount(0);
            if (matches == null) return;

            for (int i = 0; i < matches.size(); i++)
            {
                JsonObject match = matches.get(i).getAsJsonObject();
                String result = match.has("result") ? match.get("result").getAsString() : "";
                String opponent = match.has("opponent_id") ? match.get("opponent_id").getAsString() : "";
                String matchType = match.has("bucket") ? match.get("bucket").getAsString().toUpperCase() : "Unknown";
                String playerRank = computeRank(match, "player_");
                String opponentRank = computeRank(match, "opponent_");
                String matchDisplay = playerRank + " vs " + opponentRank;
                String change = computeRatingChangePlain(match);
                String time = match.has("when") ? formatTime(match.get("when").getAsLong()) : "";
                
                tableModel.addRow(new Object[]{result, opponent, matchType, matchDisplay, change, time});
            }
        });
    }
    
    public void clear()
    {
        SwingUtilities.invokeLater(() -> tableModel.setRowCount(0));
    }

    private String computeRank(JsonObject match, String prefix)
    {
        if (match.has(prefix + "rank"))
        {
            String rank = match.get(prefix + "rank").getAsString();
            int division = match.has(prefix + "division") ? match.get(prefix + "division").getAsInt() : 0;
            return rank + (division > 0 ? " " + division : "");
        }
        return "Unknown";
    }

    private String computeRatingChangePlain(JsonObject match)
    {
        if (match.has("rating_change"))
        {
            JsonObject ratingChange = match.getAsJsonObject("rating_change");
            
            // Prefer actual MMR delta from backend when present
            if (ratingChange.has("mmr_delta"))
            {
                double mmrDelta = ratingChange.get("mmr_delta").getAsDouble();
                String mmrText = String.format("%+.2f MMR", mmrDelta);
                return mmrText; // Simplified for plain text view, or add more details if space allows
            }
            
            // Fallback to progress calculation logic if needed, or simplified
            // Reuse logic from DashboardPanel if we want exact same output:
            
            double progressChange = ratingChange.has("progress_change") ? ratingChange.get("progress_change").getAsDouble() : 0;
            
            // Re-implement simplified delta calculation or just show percentage
            // The original logic was quite complex to handle wrapping.
            // Let's copy the essential part or reuse RankUtils if possible.
            // RankUtils doesn't have "computeRatingChangeText".
            
            
            String fromRank = ratingChange.has("from_rank") ? ratingChange.get("from_rank").getAsString() : "";
            String toRank = ratingChange.has("to_rank") ? ratingChange.get("to_rank").getAsString() : "";
            int fromDiv = ratingChange.has("from_division") ? ratingChange.get("from_division").getAsInt() : 0;
            int toDiv = ratingChange.has("to_division") ? ratingChange.get("to_division").getAsInt() : 0;
            
            double playerMmr = match.has("player_mmr") ? match.get("player_mmr").getAsDouble() : 0;
            double afterProg = RankUtils.calculateProgressFromMMR(playerMmr);
            double beforeProg = afterProg - progressChange;
            
            String fromKey = fromRank + "|" + fromDiv;
            String toKey = toRank + "|" + toDiv;
            if (!fromKey.equals(toKey) && Math.abs(progressChange) > 0)
            {
                String result = match.has("result") ? match.get("result").getAsString().toLowerCase() : "";
                int signShouldBe = "win".equals(result) ? 1 : ("loss".equals(result) ? -1 : (int)Math.signum(progressChange));
                if (Math.signum(progressChange) != signShouldBe)
                {
                    beforeProg = afterProg + (100 - Math.abs(progressChange)) * signShouldBe;
                }
            }
            
            beforeProg = Math.max(0, Math.min(100, beforeProg));
            
            int fromIdx = RankUtils.getRankIndex(fromRank, fromDiv);
            int toIdx = RankUtils.getRankIndex(toRank, toDiv);
            double rawDelta = (afterProg - beforeProg) + (toIdx - fromIdx) * 100;
            
            String result = match.has("result") ? match.get("result").getAsString().toLowerCase() : "";
            if ("tie".equals(result)) return "0% change";
            return String.format("%+.2f%% change", rawDelta);
        }
        return "-";
    }

    private String formatTime(long timestamp)
    {
        return new SimpleDateFormat("MM/dd/yyyy, HH:mm:ss").format(new Date(timestamp * 1000));
    }
}


package com.pvp.leaderboard.ui;

import com.pvp.leaderboard.service.CognitoAuthService;
import javax.swing.*;
import java.awt.*;
import java.net.URLEncoder;
import java.util.function.Consumer;
import net.runelite.client.util.LinkBrowser;

public class LoginPanel extends JPanel
{
    private static final int MAX_PLUGIN_SEARCHES_PER_MINUTE = 10;
    
    private final CognitoAuthService cognitoAuthService;
    private final Consumer<String> onPluginSearch;
    private final Runnable onLoginStateChanged;

    private JTextField websiteSearchField;
    private JTextField pluginSearchField;
    private JButton pluginSearchBtn;
    private JButton loginButton;
    
    private boolean loginInProgress = false;
    private boolean isLoggedIn = false;
    
    // Rate limiting for plugin search (10 per minute)
    private final java.util.Deque<Long> pluginSearchTimestamps = new java.util.ArrayDeque<>();

    public LoginPanel(CognitoAuthService cognitoAuthService, Consumer<String> onPluginSearch, Runnable onLoginStateChanged)
    {
        this.cognitoAuthService = cognitoAuthService;
        this.onPluginSearch = onPluginSearch;
        this.onLoginStateChanged = onLoginStateChanged;

        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        setBorder(BorderFactory.createTitledBorder("Login to view stats in runelite"));
        setMaximumSize(new Dimension(220, 190));
        setPreferredSize(new Dimension(220, 190));

        initUI();
    }

    private void initUI()
    {
        // Website search
        JLabel websiteLabel = new JLabel("Search user on website:");
        websiteLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
        add(websiteLabel);
        
        JPanel websitePanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 2, 0));
        websitePanel.setAlignmentX(Component.LEFT_ALIGNMENT);
        websiteSearchField = new JTextField();
        websiteSearchField.setPreferredSize(new Dimension(120, 25));
        websiteSearchField.addActionListener(e -> searchUserOnWebsite());
        
        JButton websiteSearchBtn = new JButton("Search");
        websiteSearchBtn.setPreferredSize(new Dimension(70, 25));
        websiteSearchBtn.addActionListener(e -> searchUserOnWebsite());
        
        websitePanel.add(websiteSearchField);
        websitePanel.add(websiteSearchBtn);
        add(websitePanel);
        
        add(Box.createVerticalStrut(5));
        
        // Plugin search
        JLabel pluginLabel = new JLabel("Search user on plugin:");
        pluginLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
        add(pluginLabel);
        
        JPanel pluginPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 2, 0));
        pluginPanel.setAlignmentX(Component.LEFT_ALIGNMENT);
        pluginSearchField = new JTextField();
        pluginSearchField.setPreferredSize(new Dimension(120, 25));
        pluginSearchField.addActionListener(e -> searchUserOnPlugin());
        
        pluginSearchBtn = new JButton("Search");
        pluginSearchBtn.setPreferredSize(new Dimension(70, 25));
        pluginSearchBtn.addActionListener(e -> searchUserOnPlugin());
        
        pluginPanel.add(pluginSearchField);
        pluginPanel.add(pluginSearchBtn);
        add(pluginPanel);
        
        add(Box.createVerticalStrut(5));
        
        loginButton = new JButton("Login to view more stats");
        loginButton.setPreferredSize(new Dimension(210, 25));
        loginButton.setMaximumSize(new Dimension(220, 25));
        loginButton.setAlignmentX(Component.LEFT_ALIGNMENT);
        loginButton.addActionListener(e -> handleLogin());
        add(loginButton);
    }

    private boolean isValidUsername(String username)
    {
        if (username == null) return false;
        String trimmed = username.trim();
        if (trimmed.isEmpty() || trimmed.length() > 12) return false;
        // Allow alphanumeric, spaces, underscores, and hyphens (RuneScape username format)
        return trimmed.matches("^[a-zA-Z0-9 _-]+$");
    }
    
    private String normalizeUsername(String username)
    {
        if (username == null) return null;
        // Normalize: trim, lowercase, collapse multiple spaces to single space
        return username.trim().toLowerCase().replaceAll("\\s+", " ");
    }

    private void searchUserOnWebsite()
    {
        String username = websiteSearchField.getText();
        if (username == null || username.trim().isEmpty())
        {
            LinkBrowser.browse("https://devsecopsautomated.com/index.html");
            return;
        }
        if (!isValidUsername(username)) return;
        try
        {
            String normalizedUsername = normalizeUsername(username);
            String encodedUsername = URLEncoder.encode(normalizedUsername, "UTF-8");
            String url = "https://devsecopsautomated.com/profile.html?player=" + encodedUsername;
            LinkBrowser.browse(url);
        }
        catch (Exception ignore) {}
    }

    private void searchUserOnPlugin()
    {
        String username = pluginSearchField.getText();
        if (username == null || username.trim().isEmpty()) return;
        if (!isValidUsername(username)) return;
        
        // Rate limit: 10 searches per minute
        if (!checkPluginSearchRateLimit())
        {
            // Show rate limit feedback briefly
            if (pluginSearchBtn != null)
            {
                pluginSearchBtn.setText("Wait...");
                Timer timer = new Timer(1000, e -> pluginSearchBtn.setText("Search"));
                timer.setRepeats(false);
                timer.start();
            }
            return;
        }
        
        if (onPluginSearch != null)
        {
            // Immediate visual feedback
            String normalizedUsername = normalizeUsername(username);
            pluginSearchField.setText(normalizedUsername);
            
            // Trigger search
            onPluginSearch.accept(normalizedUsername);
        }
    }
    
    private boolean checkPluginSearchRateLimit()
    {
        long now = System.currentTimeMillis();
        long oneMinuteAgo = now - 60_000;
        
        // Remove timestamps older than 1 minute
        while (!pluginSearchTimestamps.isEmpty() && pluginSearchTimestamps.peekFirst() < oneMinuteAgo)
        {
            pluginSearchTimestamps.pollFirst();
        }
        
        // Check if we've exceeded the limit
        if (pluginSearchTimestamps.size() >= MAX_PLUGIN_SEARCHES_PER_MINUTE)
        {
            return false; // Rate limited
        }
        
        // Record this search
        pluginSearchTimestamps.addLast(now);
        return true;
    }

    private void handleLogin()
    {
        if (loginInProgress) { return; }
        if (isLoggedIn)
        {
            // Logout
            setLoggedIn(false);
            clearTokens();
            if (onLoginStateChanged != null) onLoginStateChanged.run();
            return;
        }
        
        // Use Cognito OAuth flow
        try
        {
            setLoginBusy(true);
            cognitoAuthService.login().thenAccept(success -> {
                if (success && cognitoAuthService.isLoggedIn() && cognitoAuthService.getStoredIdToken() != null)
                {
                    SwingUtilities.invokeLater(() -> {
                        setLoginBusy(false);
                        setLoggedIn(true);
                        if (onLoginStateChanged != null) onLoginStateChanged.run();
                    });
                }
                else
                {
                    SwingUtilities.invokeLater(() -> {
                        setLoginBusy(false);
                    });
                }
            }).exceptionally(ex -> {
                SwingUtilities.invokeLater(() -> {
                    setLoginBusy(false);
                });
                return null;
            });
        }
        catch (Exception e)
        {
            setLoginBusy(false);
        }
    }

    private void setLoginBusy(boolean busy)
    {
        loginInProgress = busy;
        try
        {
            if (loginButton != null)
            {
                loginButton.setEnabled(!busy);
                loginButton.setText(busy ? "Logging in..." : (isLoggedIn ? "Logout" : "Login to view more stats"));
            }
            if (websiteSearchField != null) websiteSearchField.setEnabled(!busy);
            if (pluginSearchField != null) pluginSearchField.setEnabled(!busy);
        }
        catch (Exception ignore) {}
    }

    public void setLoggedIn(boolean loggedIn)
    {
        this.isLoggedIn = loggedIn;
        if (loginButton != null)
        {
            loginButton.setText(loggedIn ? "Logout" : "Login to view more stats");
        }
    }
    
    public void setPluginSearchText(String text)
    {
        if (pluginSearchField != null)
        {
            pluginSearchField.setText(text);
        }
    }
    
    public String getPluginSearchText()
    {
        return pluginSearchField != null ? pluginSearchField.getText() : "";
    }

    private void clearTokens() {
        cognitoAuthService.logout();
        isLoggedIn = false;
        if (loginButton != null) loginButton.setText("Login to view stats in runelite");
    }
}


package com.pvp.leaderboard.overlay;

import com.pvp.leaderboard.config.PvPLeaderboardConfig;
import com.pvp.leaderboard.game.PlayerRankEvent;
import com.pvp.leaderboard.service.PvPDataService;
import com.pvp.leaderboard.util.NameUtils;
import com.pvp.leaderboard.util.RankUtils;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.Point;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import java.awt.*;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j
public class RankOverlay extends Overlay
{
    private final Client client;
    private final PvPLeaderboardConfig config;
    private final PvPDataService pvpDataService;

    // Displayed ranks cache
    private final ConcurrentHashMap<String, String> displayedRanks = new ConcurrentHashMap<>();
    private final Map<String, Long> displayedRanksTimestamp = new ConcurrentHashMap<>();
    
    // API-set ranks that should persist until shard cache refreshes with matching data
    private final ConcurrentHashMap<String, String> apiSetRanks = new ConcurrentHashMap<>();

    // Config change tracking
    private String lastBucketKey = null;
    private PvPLeaderboardConfig.RankDisplayMode lastDisplayMode = null;

    // Self-rank scheduling
    private volatile long selfRefreshRequestedAtMs = 0L;
    private volatile boolean selfRankAttempted = false;
    private volatile long nextSelfRankAllowedAtMs = 0L;

    // MMR change notification queue (for multi-kill scenarios)
    private final java.util.concurrent.ConcurrentLinkedQueue<MmrNotification> mmrNotificationQueue = new java.util.concurrent.ConcurrentLinkedQueue<>();
    private volatile MmrNotification currentMmrNotification = null;
    private volatile long mmrNotificationStartMs = 0L;
    private volatile int lastNotificationTick = -1; // Track tick for 1-per-tick display
    
    // Legacy fields kept for backwards compatibility
    private volatile Double previousMmr = null;
    
    /**
     * Represents a single MMR change notification.
     */
    private static class MmrNotification {
        final double delta;
        final String bucketLabel;
        
        MmrNotification(double delta, String bucketLabel) {
            this.delta = delta;
            this.bucketLabel = bucketLabel;
        }
    }

    @Inject
    public RankOverlay(Client client, PvPLeaderboardConfig config, PvPDataService pvpDataService)
    {
        this.client = client;
        this.config = config;
        this.pvpDataService = pvpDataService;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
        setPriority(Overlay.PRIORITY_HIGHEST);
    }

    @Subscribe
    public void onPlayerRankEvent(PlayerRankEvent event)
    {
        if (event == null || event.getPlayerName() == null || event.getTier() == null)
        {
            return;
        }
        log.debug("[Overlay] onPlayerRankEvent: player={} tier={} bucket={}",
            event.getPlayerName(), event.getTier(), event.getBucket());
        setRankFromApi(event.getPlayerName(), event.getTier());
    }

    /**
     * Schedule a self-rank refresh after the given delay.
     */
    public void scheduleSelfRankRefresh(long delayMs)
    {
        long now = System.currentTimeMillis();
        nextSelfRankAllowedAtMs = now + Math.max(0L, delayMs);
        selfRankAttempted = false;
        selfRefreshRequestedAtMs = nextSelfRankAllowedAtMs;
    }

    /**
     * Reset lookup state on world hop.
     */
    public void resetLookupStateOnWorldHop()
    {
        selfRankAttempted = false;
        nextSelfRankAllowedAtMs = 0L;
    }

    /**
     * Get cached rank for a player.
     */
    public String getCachedRankFor(String playerName)
    {
        return displayedRanks.get(NameUtils.canonicalKey(playerName));
    }

    /**
     * Set rank from API response.
     * This rank will persist until the shard cache refreshes with matching data.
     */
    public void setRankFromApi(String playerName, String rank)
    {
        if (playerName == null || playerName.trim().isEmpty() || rank == null || rank.trim().isEmpty())
        {
            return;
        }
        String key = NameUtils.canonicalKey(playerName);
        displayedRanks.put(key, rank);
        displayedRanksTimestamp.put(key, System.currentTimeMillis());
        // Track this as an API-set rank - persists until shard cache confirms with same rank
        apiSetRanks.put(key, rank);
        pvpDataService.clearShardNegativeCache(playerName);
        log.debug("[Overlay] setRankFromApi: key={} rank={} (will persist until shard confirms)", key, rank);
    }

    /**
     * Store the previous MMR value before a fight for delta calculation.
     */
    public void storePreviousMmr(double mmr)
    {
        this.previousMmr = mmr;
        log.debug("[Overlay] Stored previous MMR: {}", mmr);
    }

    /**
     * Show MMR delta notification with the actual delta from match history.
     * This is the preferred method as it uses the accurate server-calculated delta.
     * Notifications are queued for multi-kill scenarios.
     * 
     * @param mmrDelta The actual MMR change (positive for gain, negative for loss)
     * @param bucketLabel Optional bucket label to display (e.g., "Multi") when different from config bucket
     */
    public void showMmrDelta(double mmrDelta, String bucketLabel)
    {
        if (!config.showMmrChangeNotification())
        {
            return;
        }
        
        // Add to queue for sequential display
        MmrNotification notification = new MmrNotification(mmrDelta, bucketLabel);
        mmrNotificationQueue.offer(notification);
        log.debug("[Overlay] Queued MMR notification: delta={} bucket={} queueSize={}", 
            mmrDelta, bucketLabel, mmrNotificationQueue.size());
        
        // If no notification is currently showing, start this one immediately
        if (currentMmrNotification == null && mmrNotificationStartMs == 0L)
        {
            startNextNotification();
        }
    }
    
    /**
     * Start displaying the next notification from the queue.
     */
    private void startNextNotification()
    {
        MmrNotification next = mmrNotificationQueue.poll();
        if (next != null)
        {
            currentMmrNotification = next;
            mmrNotificationStartMs = System.currentTimeMillis();
            log.debug("[Overlay] Started MMR notification: delta={} bucket={} remaining={}", 
                next.delta, next.bucketLabel, mmrNotificationQueue.size());
        }
        else
        {
            currentMmrNotification = null;
            mmrNotificationStartMs = 0L;
        }
    }

    /**
     * Called after fight when new MMR is fetched.
     * Calculates delta and triggers notification.
     * @deprecated Use showMmrDelta instead which uses accurate server-calculated delta
     */
    @Deprecated
    public void onMmrUpdated(double newMmr, double oldMmr, String bucketLabel)
    {
        showMmrDelta(newMmr - oldMmr, bucketLabel);
    }

    /**
     * Called after fight when new MMR is fetched (legacy method without bucket label).
     * @deprecated Use showMmrDelta instead
     */
    @Deprecated
    public void onMmrUpdated(double newMmr, double oldMmr)
    {
        onMmrUpdated(newMmr, oldMmr, null);
    }

    /**
     * Get the stored previous MMR (for FightMonitor to check).
     */
    public Double getPreviousMmr()
    {
        return previousMmr;
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (config == null || client == null)
        {
            return new Dimension(0, 0);
        }

        // Handle config changes
        String currentBucket = bucketKey(config.rankBucket());
        PvPLeaderboardConfig.RankDisplayMode currentMode = config.rankDisplayMode();

        if (lastBucketKey == null || !lastBucketKey.equals(currentBucket) || lastDisplayMode != currentMode)
        {
            displayedRanks.clear();
            displayedRanksTimestamp.clear();
            apiSetRanks.clear();  // Clear API overrides when config changes
            lastBucketKey = currentBucket;
            lastDisplayMode = currentMode;
            selfRankAttempted = false;
            nextSelfRankAllowedAtMs = 0L;
        }

        // Get local player
        Player localPlayer = client.getLocalPlayer();
        if (localPlayer == null)
        {
            return new Dimension(0, 0);
        }

        String localName = localPlayer.getName();

        // Handle self-rank refresh scheduling
        if (config.showOwnRank() && localName != null && selfRefreshRequestedAtMs > 0L)
        {
            long now = System.currentTimeMillis();
            if (now >= selfRefreshRequestedAtMs && !selfRankAttempted && now >= nextSelfRankAllowedAtMs)
            {
                selfRankAttempted = true;
                selfRefreshRequestedAtMs = 0L;
                fetchRankForSelf(localName);
            }
        }

        // Only render self in Phase 1
        if (!config.showOwnRank())
        {
            // Still render MMR notification even if rank is hidden
            renderMmrChangeNotification(graphics, localPlayer);
            return new Dimension(0, 0);
        }

        String nameKey = NameUtils.canonicalKey(localName);
        String cachedRank = displayedRanks.get(nameKey);

        // Render rank above local player
        Point nameLocation = localPlayer.getCanvasTextLocation(graphics, localName, localPlayer.getLogicalHeight() + 40);
        if (nameLocation != null && cachedRank != null)
        {
            FontMetrics fm = graphics.getFontMetrics();

            Point headLoc = localPlayer.getCanvasTextLocation(graphics, "", localPlayer.getLogicalHeight() + 40);
            int x, y;
            if (headLoc != null)
            {
                x = headLoc.getX() + config.rankOffsetX();
                y = headLoc.getY() - fm.getAscent() - 2 + config.rankOffsetY();
            }
            else
            {
                x = nameLocation.getX() + config.rankOffsetX();
                y = nameLocation.getY() - fm.getAscent() - 2 + config.rankOffsetY();
            }

            renderRankText(graphics, cachedRank, x, y, Math.max(10, config.rankTextSize()));
        }

        // Render MMR change notification
        renderMmrChangeNotification(graphics, localPlayer);

        return new Dimension(0, 0);
    }

    private void fetchRankForSelf(String selfName)
    {
        String bucket = bucketKey(config.rankBucket());
        PvPLeaderboardConfig.RankDisplayMode mode = config.rankDisplayMode();
        String key = NameUtils.canonicalKey(selfName);

        pvpDataService.getShardRankByName(selfName, bucket)
            .thenAccept(sr -> {
                if (sr == null)
                {
                    log.debug("[Overlay] No shard rank found for self: {}", selfName);
                    return;
                }

                String shardRank;
                if (mode == PvPLeaderboardConfig.RankDisplayMode.RANK_NUMBER)
                {
                    shardRank = sr.rank > 0 ? "Rank " + sr.rank : null;
                }
                else
                {
                    shardRank = sr.tier;
                }

                if (shardRank != null)
                {
                    long fetchCompletedAt = System.currentTimeMillis();
                    
                    // Check if there's an API-set rank that should persist
                    String apiRank = apiSetRanks.get(key);
                    if (apiRank != null)
                    {
                        if (apiRank.equals(shardRank))
                        {
                            // Shard cache has refreshed with matching data - clear the API override
                            apiSetRanks.remove(key);
                            displayedRanks.put(key, shardRank);
                            displayedRanksTimestamp.put(key, fetchCompletedAt);
                            log.debug("[Overlay] Shard cache refreshed for {}: {} (API override cleared)", selfName, shardRank);
                        }
                        else
                        {
                            // Shard has stale data - preserve the API-set rank
                            log.debug("[Overlay] Preserving API rank for {}: {} (shard has stale: {})", 
                                selfName, apiRank, shardRank);
                        }
                    }
                    else
                    {
                        // No API override - use shard data
                        displayedRanks.put(key, shardRank);
                        displayedRanksTimestamp.put(key, fetchCompletedAt);
                        log.debug("[Overlay] Self rank fetched: {} = {}", selfName, shardRank);
                    }
                    nextSelfRankAllowedAtMs = fetchCompletedAt + 60_000L;
                }
            })
            .exceptionally(ex -> {
                log.debug("[Overlay] Error fetching self rank: {}", ex.getMessage());
                nextSelfRankAllowedAtMs = System.currentTimeMillis() + 60_000L;
                return null;
            });
    }

    private void renderRankText(Graphics2D g, String fullRank, int x, int y, int size)
    {
        if (fullRank == null || fullRank.trim().isEmpty())
        {
            return;
        }

        String[] parts = fullRank.split(" ");
        String rankName = parts[0];
        String division = parts.length > 1 ? parts[1] : "";
        String text = division.isEmpty() ? rankName : (rankName + " " + division);

        g.setFont(new Font(Font.DIALOG, Font.BOLD, size));
        FontMetrics fm = g.getFontMetrics();
        int textW = fm.stringWidth(text);
        int textH = fm.getAscent();
        int centerX = x - textW / 2;
        int baseY = y + textH;

        // Check for 3rd Age - special glow effect
        boolean isThirdAge = rankName.equals("3rd") || fullRank.startsWith("3rd");

        if (isThirdAge && !config.colorblindMode())
        {
            // Glowing white effect: multiple layers with decreasing alpha
            int[][] glowLayers = {
                {3, 25},   // offset 3px, alpha 25
                {2, 50},   // offset 2px, alpha 50
                {1, 100},  // offset 1px, alpha 100
            };

            for (int[] layer : glowLayers)
            {
                int offset = layer[0];
                int alpha = layer[1];
                g.setColor(new Color(255, 255, 255, alpha));
                for (int dy = -offset; dy <= offset; dy++)
                {
                    for (int dx = -offset; dx <= offset; dx++)
                    {
                        if (dx == 0 && dy == 0) continue;
                        g.drawString(text, centerX + dx, baseY + dy);
                    }
                }
            }

            // Core white text
            g.setColor(Color.WHITE);
            g.drawString(text, centerX, baseY);
        }
        else
        {
            // Standard rendering: black outline + colored text
            g.setColor(new Color(0, 0, 0, 180));
            for (int dy = -1; dy <= 1; dy++)
            {
                for (int dx = -1; dx <= 1; dx++)
                {
                    if (dx == 0 && dy == 0) continue;
                    g.drawString(text, centerX + dx, baseY + dy);
                }
            }

            // Determine text color
            if (config.colorblindMode() || fullRank.startsWith("Rank "))
            {
                g.setColor(Color.WHITE);
            }
            else
            {
                g.setColor(RankUtils.getRankColor(rankName));
            }
            g.drawString(text, centerX, baseY);
        }
    }

    private void renderMmrChangeNotification(Graphics2D g, Player localPlayer)
    {
        int currentTick = client.getTickCount();
        
        if (currentMmrNotification == null || mmrNotificationStartMs == 0L)
        {
            // Try to start next notification if queue has items (rate limit: 1 per tick)
            if (!mmrNotificationQueue.isEmpty() && currentTick != lastNotificationTick)
            {
                startNextNotification();
                lastNotificationTick = currentTick;
            }
            return;
        }
        if (!config.showMmrChangeNotification())
        {
            return;
        }

        // Check if current notification duration has expired
        long durationMs = config.mmrDuration() * 1000L;
        long elapsed = System.currentTimeMillis() - mmrNotificationStartMs;
        
        if (elapsed > durationMs)
        {
            // Current notification finished - start next (rate limit: 1 per tick)
            if (currentTick != lastNotificationTick)
            {
                startNextNotification();
                lastNotificationTick = currentTick;
            }
            else
            {
                // Already started one this tick, clear current and wait for next tick
                currentMmrNotification = null;
                mmrNotificationStartMs = 0L;
            }
            return;
        }

        // Get position above player
        Point headLoc = localPlayer.getCanvasTextLocation(g, "", localPlayer.getLogicalHeight() + 80);
        if (headLoc == null)
        {
            return;
        }

        double mmrDelta = currentMmrNotification.delta;
        String bucketLabel = currentMmrNotification.bucketLabel;

        // Calculate fade progress
        float progress = (float) elapsed / durationMs;
        int alpha = (int) (255 * (1.0f - progress));
        int floatOffset = (int) (progress * 30); // Float up 30 pixels

        // Format text: +1.3 MMR (NH) when bucket label present (auto-switched)
        // Otherwise: +1.3 MMR
        String sign = mmrDelta >= 0 ? "+" : "";
        String text;
        if (bucketLabel != null && !bucketLabel.isEmpty())
        {
            text = String.format("%s%.1f MMR (%s)", sign, mmrDelta, bucketLabel);
        }
        else
        {
            text = String.format("%s%.1f MMR", sign, mmrDelta);
        }

        // Determine color
        Color baseColor;
        if (config.colorblindMode())
        {
            baseColor = Color.WHITE;
        }
        else if (mmrDelta >= 0)
        {
            baseColor = new Color(0, 200, 0); // Green for gain
        }
        else
        {
            baseColor = new Color(229, 57, 53); // Red for loss
        }
        Color color = new Color(baseColor.getRed(), baseColor.getGreen(), baseColor.getBlue(), alpha);

        // Render with black outline
        g.setFont(new Font(Font.DIALOG, Font.BOLD, Math.max(12, config.rankTextSize() + 2)));
        FontMetrics fm = g.getFontMetrics();
        int textW = fm.stringWidth(text);
        int centerX = headLoc.getX() - textW / 2 + config.mmrOffsetX();
        int drawY = headLoc.getY() - floatOffset + config.mmrOffsetY();

        // Black outline with alpha
        Color outlineColor = new Color(0, 0, 0, (int) (180 * (1.0f - progress)));
        g.setColor(outlineColor);
        for (int dy = -1; dy <= 1; dy++)
        {
            for (int dx = -1; dx <= 1; dx++)
            {
                if (dx == 0 && dy == 0) continue;
                g.drawString(text, centerX + dx, drawY + dy);
            }
        }

        // Main colored text
        g.setColor(color);
        g.drawString(text, centerX, drawY);
    }

    private static String bucketKey(PvPLeaderboardConfig.RankBucket bucket)
    {
        if (bucket == null)
        {
            return "overall";
        }
        switch (bucket)
        {
            case NH:
                return "nh";
            case VENG:
                return "veng";
            case MULTI:
                return "multi";
            case DMM:
                return "dmm";
            case OVERALL:
            default:
                return "overall";
        }
    }
}

package com.pvp.leaderboard.service;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import lombok.extern.slf4j.Slf4j;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import javax.inject.Inject;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.CompletableFuture;

@Slf4j
public class MatchResultService
{
    private static final String API_URL = "https://l5xya0wf0d.execute-api.us-east-1.amazonaws.com/prod/matchresult";
    private static final String CLIENT_ID = "runelite";
    private static final String PLUGIN_VERSION = "1.0.0";
    // This is meant to be hardcoded and be this value for everyone. New versions of the plugin will update this on the backend so that it doesn't take matches from old clients if there is an incompatibility added.
    private static final String RUNELITE_CLIENT_SECRET = "7f2f6a0e-2c6b-4b1d-9a39-6f2b2a8a1f3c"; 
    private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");

    private final OkHttpClient httpClient;
    private final Gson gson;

    @Inject
    public MatchResultService(OkHttpClient httpClient, Gson gson)
    {
        this.httpClient = httpClient;
        this.gson = gson;
    }

    // Fallback constructor for tests: use RuneLite injector (no fresh clients)
    public MatchResultService()
    {
        this(
            net.runelite.client.RuneLite.getInjector().getInstance(OkHttpClient.class),
            net.runelite.client.RuneLite.getInjector().getInstance(Gson.class)
        );
    }

    /**
     * Validates a RuneScape username format.
     * Valid: alphanumeric, spaces, underscores, hyphens, 1-12 characters
     */
    private boolean isValidRunescapeName(String name)
    {
        if (name == null) return false;
        String trimmed = name.trim();
        if (trimmed.isEmpty() || trimmed.length() > 12) return false;
        return trimmed.matches("^[a-zA-Z0-9 _-]+$");
    }

    public CompletableFuture<Boolean> submitMatchResult(MatchResult match)
    {
        CompletableFuture<Boolean> overall = new CompletableFuture<>();
        try
        {
            // Validate player and opponent names match RuneScape format
            if (!isValidRunescapeName(match.getPlayerId()) || !isValidRunescapeName(match.getOpponentId()))
            {
                log.debug("[Submit] Invalid name format: player='{}' opponent='{}'", match.getPlayerId(), match.getOpponentId());
                overall.complete(false);
                return overall;
            }

            // Preflight diagnostics to understand why server might reject
            // Note: FightMonitor now ensures valid timestamps (non-zero, 60s apart if one was missing)
            try {
                String pLower = match.getPlayerId().trim().replaceAll("\\s+", " ").toLowerCase(java.util.Locale.ROOT);
                String oLower = match.getOpponentId().trim().replaceAll("\\s+", " ").toLowerCase(java.util.Locale.ROOT);
                boolean notSelf = !pLower.equals(oLower);
                boolean timeOk = match.getFightStartTs() > 0 && match.getFightEndTs() > 0 && match.getFightEndTs() >= match.getFightStartTs();
                boolean worldOk = match.getWorld() > 0;
                // log.debug("[Submit] preflight notSelf={} timeOk={} worldOk={} player='{}' opponent='{}' startTs={} endTs={} world={} multi={} dmgOut={}",
                //     notSelf, timeOk, worldOk, match.getPlayerId(), match.getOpponentId(), match.getFightStartTs(), match.getFightEndTs(), match.getWorld(), match.isWasInMulti(), match.getDamageToOpponent());
                // if (!notSelf) { log.debug("[Submit][why] Opponent equals self; likely mis-attribution"); }
                // if (!timeOk) { log.debug("[Submit][why] Invalid timestamps startTs={} endTs={}", match.getFightStartTs(), match.getFightEndTs()); }
                // if (!worldOk) { log.debug("[Submit][why] Invalid world={}", match.getWorld()); }
            } catch (Exception ignore) {}
            
            String dbgPlayer = (match.getPlayerId() != null ? match.getPlayerId() : "<null>");
            String dbgOpponent = (match.getOpponentId() != null ? match.getOpponentId() : "<null>");
            // log.debug("[Submit] begin playerId={} opponentId={} result={} world={} startTs={} endTs={} startSpell={} endSpell={} multi={} authed={}",
            //     dbgPlayer, dbgOpponent, match.getResult(), match.getWorld(), match.getFightStartTs(), match.getFightEndTs(), match.getFightStartSpellbook(), match.getFightEndSpellbook(), match.isWasInMulti(), (match.getIdToken() != null && !match.getIdToken().isEmpty()));

            JsonObject body = new JsonObject();
            body.addProperty("player_id", match.getPlayerId());
            body.addProperty("opponent_id", match.getOpponentId());
            body.addProperty("result", match.getResult());
            body.addProperty("world", match.getWorld());
            body.addProperty("fight_start_ts", match.getFightStartTs());
            body.addProperty("fight_end_ts", match.getFightEndTs());
            body.addProperty("fightStartSpellbook", match.getFightStartSpellbook());
            body.addProperty("fightEndSpellbook", match.getFightEndSpellbook());
            body.addProperty("wasInMulti", match.isWasInMulti());
            body.addProperty("client_id", CLIENT_ID);
            body.addProperty("plugin_version", PLUGIN_VERSION);
            body.addProperty("damage_to_opponent", match.getDamageToOpponent());

            String bodyJson = gson.toJson(body);
            
            log.debug("[MatchAPI] Request body: {}", bodyJson);

            if (match.getIdToken() != null && !match.getIdToken().isEmpty())
            {
                log.debug("[MatchAPI] Using authenticated path (has idToken)");
                submitAuthenticatedFightAsync(bodyJson, match.getIdToken(), match.getClientUniqueId()).whenComplete((ok, ex) -> {
                    if (ex != null)
                    {
                        log.debug("[MatchAPI] Authenticated path exception: {}, falling back to unauth", ex.getMessage());
                        submitUnauthenticatedFightAsync(bodyJson, match.getClientUniqueId()).whenComplete((ok2, ex2) -> {
                            if (ex2 != null) overall.complete(false); else overall.complete(ok2);
                        });
                        return;
                    }
                    if (Boolean.TRUE.equals(ok))
                    {
                        log.debug("[MatchAPI] Authenticated path SUCCESS");
                        overall.complete(true);
                    }
                    else
                    {
                        log.debug("[MatchAPI] Authenticated path failed, falling back to unauth");
                        submitUnauthenticatedFightAsync(bodyJson, match.getClientUniqueId()).whenComplete((ok2, ex2) -> {
                            if (ex2 != null) overall.complete(false); else overall.complete(ok2);
                        });
                    }
                });
            }
            else
            {
                log.debug("[MatchAPI] Using unauthenticated path (no idToken)");
                submitUnauthenticatedFightAsync(bodyJson, match.getClientUniqueId()).whenComplete((ok, ex) -> {
                    if (ex != null) overall.complete(false); else overall.complete(ok);
                });
            }
        }
        catch (Exception e)
        {
            log.debug("[MatchAPI] EXCEPTION during submit: {}", e.getMessage(), e);
            overall.complete(false);
        }
        return overall;
    }

    private CompletableFuture<Boolean> submitAuthenticatedFightAsync(String body, String idToken, String clientUniqueId)
    {
        CompletableFuture<Boolean> future = new CompletableFuture<>();

        Request request = new Request.Builder()
            .url(API_URL)
            .post(RequestBody.create(JSON, body))
            .addHeader("Authorization", "Bearer " + idToken)
            .addHeader("X-Client-Unique-Id", clientUniqueId)
            .build();

        log.debug("[MatchAPI] Auth request to: {}", API_URL);

        httpClient.newCall(request).enqueue(new Callback()
        {
            @Override
            public void onFailure(Call call, IOException e)
            {
                log.debug("[MatchAPI] Auth request NETWORK FAILURE: {}", e.getMessage());
                future.complete(false);
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException
            {
                try (Response res = response)
                {
                    int code = res.code();
                    String reqId = null; try { reqId = res.header("x-amzn-RequestId"); } catch (Exception ignore) {}
                    
                    if (code >= 200 && code < 300)
                    {
                        log.debug("[MatchAPI] Auth response SUCCESS: code={} requestId={}", code, reqId);
                        future.complete(true);
                    }
                    else
                    {
                        String errBody = null;
                        try { okhttp3.ResponseBody err = res.body(); errBody = err != null ? err.string() : null; } catch (Exception ignore) {}
                        log.debug("[MatchAPI] Auth response FAILED: code={} requestId={} body={}", code, reqId, errBody);
                        future.complete(false);
                    }
                }
            }
        });

        return future;
    }

    private CompletableFuture<Boolean> submitUnauthenticatedFightAsync(String body, String clientUniqueId)
    {
        CompletableFuture<Boolean> future = new CompletableFuture<>();
        long timestamp = System.currentTimeMillis() / 1000;
        String signature;
        try
        {
            signature = generateSignature(body, timestamp);
        }
        catch (Exception e)
        {
            log.debug("[MatchAPI] Unauth signature generation FAILED: {}", e.getMessage());
            future.completeExceptionally(e);
            return future;
        }

        Request request = new Request.Builder()
            .url(API_URL)
            .post(RequestBody.create(JSON, body))
            .addHeader("x-client-id", CLIENT_ID)
            .addHeader("x-timestamp", String.valueOf(timestamp))
            .addHeader("x-signature", signature)
            .addHeader("X-Client-Unique-Id", clientUniqueId)
            .build();

        log.debug("[MatchAPI] Unauth request to: {} timestamp={}", API_URL, timestamp);

        httpClient.newCall(request).enqueue(new Callback()
        {
            @Override
            public void onFailure(Call call, IOException e)
            {
                log.debug("[MatchAPI] Unauth request NETWORK FAILURE: {}", e.getMessage());
                future.complete(false);
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException
            {
                try (Response res = response)
                {
                    int code = res.code();
                    String reqId = null; try { reqId = res.header("x-amzn-RequestId"); } catch (Exception ignore) {}
                    
                    if ((code >= 200 && code < 300) || code == 202)
                    {
                        log.debug("[MatchAPI] Unauth response SUCCESS: code={} requestId={}", code, reqId);
                        future.complete(true);
                    }
                    else
                    {
                        String errBody = null;
                        try { okhttp3.ResponseBody err = res.body(); errBody = err != null ? err.string() : null; } catch (Exception ignore) {}
                        log.debug("[MatchAPI] Unauth response FAILED: code={} requestId={} body={}", code, reqId, errBody);
                        future.complete(false);
                    }
                }
            }
        });

        return future;
    }

    private String generateSignature(String body, long timestamp) throws Exception
    {
        String message = "POST\n/matchresult\n" + body + "\n" + timestamp;
        Mac mac = Mac.getInstance("HmacSHA256");
        SecretKeySpec secretKey = new SecretKeySpec(RUNELITE_CLIENT_SECRET.getBytes(StandardCharsets.UTF_8), "HmacSHA256");
        mac.init(secretKey);
        byte[] hash = mac.doFinal(message.getBytes(StandardCharsets.UTF_8));

        StringBuilder hexString = new StringBuilder();
        for (byte b : hash)
        {
            String hex = Integer.toHexString(0xff & b);
            if (hex.length() == 1) hexString.append('0');
            hexString.append(hex);
        }
        return hexString.toString();
    }
}

package com.pvp.leaderboard.service;

import java.io.File;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.UUID;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;

@Slf4j
@Singleton
public class ClientIdentityService
{
    private final ConfigManager configManager;
    private String clientUniqueId;

    @Inject
    public ClientIdentityService(ConfigManager configManager)
    {
        this.configManager = configManager;
    }

    /**
     * Initializes the client ID on startup.
     * Logic: Prefer global file ~/.runelite/pvp-leaderboard.id. If missing, generate and save.
     * Also syncs to RuneLite profile config for backup.
     */
    public void loadOrGenerateId()
    {
        if (clientUniqueId != null) return; // Already loaded

        File globalFile = new File(System.getProperty("user.home"), ".runelite/pvp-leaderboard.id");
        String globalId = null;

        try
        {
            if (globalFile.exists())
            {
                byte[] bytes = Files.readAllBytes(globalFile.toPath());
                globalId = new String(bytes, StandardCharsets.UTF_8).trim();
            }
        }
        catch (Exception e)
        {
            // log.debug("Failed to read global identity file", e);
        }

        String finalId = globalId;
        
        // If disk file missing, try to recover from profile config
        if (finalId == null || finalId.isEmpty())
        {
            String profileId = configManager.getConfiguration("PvPLeaderboard", "clientUniqueId");
            if (profileId != null && !profileId.isEmpty())
            {
                finalId = profileId;
            }
        }
        
        // If still no ID, generate new one
        if (finalId == null || finalId.isEmpty())
        {
            finalId = UUID.randomUUID().toString();
        }
        
        // Save to global file
        try
        {
            File parent = globalFile.getParentFile();
            if (parent != null && !parent.exists())
            {
                parent.mkdirs();
            }
            Files.write(globalFile.toPath(), finalId.getBytes(StandardCharsets.UTF_8));
        }
        catch (Exception e)
        {
            // log.debug("Failed to write global identity file", e);
        }

        // Sync to profile
        String profileId = configManager.getConfiguration("PvPLeaderboard", "clientUniqueId");
        if (!finalId.equals(profileId))
        {
            configManager.setConfiguration("PvPLeaderboard", "clientUniqueId", finalId);
        }

        this.clientUniqueId = finalId;
    }

    public String getClientUniqueId()
    {
        if (clientUniqueId == null) loadOrGenerateId();
        return clientUniqueId;
    }
}

package com.pvp.leaderboard.service;

public class ShardRank
{
    public final String tier;
    public final int rank;

    public ShardRank(String tier, int rank)
    {
        this.tier = tier;
        this.rank = rank;
    }
}

package com.pvp.leaderboard.service;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.JsonSyntaxException;
import com.pvp.leaderboard.cache.MatchesCacheEntry;
import com.pvp.leaderboard.cache.ShardEntry;
import com.pvp.leaderboard.cache.UserStatsCache;
import com.pvp.leaderboard.config.PvPLeaderboardConfig;
import com.pvp.leaderboard.util.RankUtils;
import lombok.extern.slf4j.Slf4j;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import okhttp3.ResponseBody;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j
@Singleton
public class PvPDataService
{
	private static final String API_BASE_URL = "https://l5xya0wf0d.execute-api.us-east-1.amazonaws.com/prod";
    private static final String SHARD_BASE_URL = "https://devsecopsautomated.com/rank_idx";

	private final OkHttpClient okHttpClient;
	private final Gson gson;
	private final PvPLeaderboardConfig config;
	private final ClientIdentityService clientIdentityService;

	// Shard lookup caching
    // Per spec: Shard Files = 60s TTL
	private static final long SHARD_CACHE_EXPIRY_MS = 60L * 1000L; 
    // "Not Found" State = 1 hour TTL
	private static final long MISSING_PLAYER_BACKOFF_MS = 60L * 60L * 1000L;
    // Failed fetch backoff
    private static final long SHARD_FAIL_BACKOFF_MS = 60L * 1000L;

	// In-flight request deduplication for getShardRankByName
	private final ConcurrentHashMap<String, CompletableFuture<ShardRank>> inFlightLookups = new ConcurrentHashMap<>();

	private final Map<String, ShardEntry> shardCache = Collections.synchronizedMap(
		new LinkedHashMap<String, ShardEntry>(128, 0.75f, true)
		{
			@Override
			protected boolean removeEldestEntry(Map.Entry<String, ShardEntry> eldest)
			{
				return size() > 512; // LRU cap
			}
		}
	);

	private final ConcurrentHashMap<String, Long> shardFailUntil = new ConcurrentHashMap<>();
	
    // Negative cache for specific players/accounts to avoid re-checking shards
	private final ConcurrentHashMap<String, Long> missingPlayerUntilMs = new ConcurrentHashMap<>();

    /**
     * Clears the shard negative cache for a player. Call this when API confirms player exists.
     */
    public void clearShardNegativeCache(String playerName) {
        if (playerName == null) return;
        String canonicalName = playerName.trim().replaceAll("\\s+", " ").toLowerCase();
        missingPlayerUntilMs.remove(canonicalName);
        // debug("[Cache] Cleared shard negative cache for {}", canonicalName);
    }

    // User Profile Caching
    private static final long USER_CACHE_TTL_MS = 1L * 60L * 1000L; // 1 minute
    private final ConcurrentHashMap<String, UserStatsCache> userStatsCache = new ConcurrentHashMap<>();

    // Matches Caching
    private static final long MATCHES_CACHE_TTL_MS = 1L * 60L * 1000L; // 1 minute
    private final ConcurrentHashMap<String, MatchesCacheEntry> matchesCache = new ConcurrentHashMap<>();

    // DMM Worlds Caching (1 hour TTL)
    private static final long DMM_WORLDS_CACHE_TTL_MS = 60L * 60L * 1000L; // 1 hour
    private volatile Set<Integer> dmmWorldsCache = new HashSet<>();
    private volatile long dmmWorldsCacheTimestamp = 0L;
    private volatile boolean dmmWorldsFetchInProgress = false;

	@Inject
	public PvPDataService(OkHttpClient okHttpClient, Gson gson, CognitoAuthService authService, PvPLeaderboardConfig config, ClientIdentityService clientIdentityService)
	{
		this.okHttpClient = okHttpClient;
		this.gson = gson;
		this.config = config;
		this.clientIdentityService = clientIdentityService;
	}


	public CompletableFuture<JsonObject> getPlayerMatches(String playerName, String nextToken, int limit)
	{
		return getPlayerMatches(playerName, nextToken, limit, false);
	}

	/**
	 * Fetch player match history with optional cache bypass.
	 * @param playerName The player to fetch matches for
	 * @param nextToken Pagination token (null for first page)
	 * @param limit Max matches to return
	 * @param bypassCache If true, skip cache and always fetch fresh data (use for MMR delta lookups)
	 */
	public CompletableFuture<JsonObject> getPlayerMatches(String playerName, String nextToken, int limit, boolean bypassCache)
	{
		CompletableFuture<JsonObject> future = new CompletableFuture<>();

        // Check cache (only for first page, i.e. no nextToken, and if not bypassing)
        if (!bypassCache && (nextToken == null || nextToken.isEmpty())) {
            String cacheKey = "matches:" + playerName + ":" + limit;
            MatchesCacheEntry cached = matchesCache.get(cacheKey);
            if (cached != null && System.currentTimeMillis() - cached.getTimestamp() <= MATCHES_CACHE_TTL_MS) {
                future.complete(cached.getResponse().deepCopy());
                return future;
            }
        }

		HttpUrl urlObj = HttpUrl.parse(API_BASE_URL + "/matches");
		if (urlObj == null) {
			future.completeExceptionally(new IOException("Invalid base URL"));
			return future;
		}
		HttpUrl.Builder urlBuilder = urlObj.newBuilder()
			.addQueryParameter("player_id", playerName)
			.addQueryParameter("limit", String.valueOf(limit));

		if (nextToken != null && !nextToken.isEmpty())
		{
			urlBuilder.addQueryParameter("next_token", nextToken);
		}

		Request.Builder requestBuilder = new Request.Builder()
			.url(urlBuilder.build())
			.get();
		
		// Add client UUID header for API authentication/tracking
		String clientUuid = clientIdentityService.getClientUniqueId();
		if (clientUuid != null && !clientUuid.isEmpty())
		{
			requestBuilder.addHeader("X-Client-Unique-Id", clientUuid);
		}
		
		Request request = requestBuilder.build();

		okHttpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
                // Try serving stale cache if available
                if (nextToken == null || nextToken.isEmpty()) {
                    String cacheKey = "matches:" + playerName + ":" + limit;
                    MatchesCacheEntry cached = matchesCache.get(cacheKey);
                    if (cached != null) {
                        future.complete(cached.getResponse().deepCopy());
                        return;
                    }
                }
				future.completeExceptionally(e);
			}

			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				try (Response res = response)
				{
					if (!res.isSuccessful())
					{
                        // Try serving stale cache if available
                        if (nextToken == null || nextToken.isEmpty()) {
                            String cacheKey = "matches:" + playerName + ":" + limit;
                            MatchesCacheEntry cached = matchesCache.get(cacheKey);
                            if (cached != null) {
                                future.complete(cached.getResponse().deepCopy());
                                return;
                            }
                        }
						future.completeExceptionally(new IOException("API call failed with status: " + res.code()));
						return;
					}

					ResponseBody body = res.body();
					if (body == null)
					{
						future.complete(new JsonObject());
						return;
					}

					try
					{
						String bodyString;
						try {
							bodyString = body.string();
						} catch (IOException cacheEx) {
							// Windows cache file locking issue - request succeeded but cache failed
							future.complete(new JsonObject());
							return;
						}
						JsonObject json = gson.fromJson(bodyString, JsonObject.class);
						if (nextToken == null || nextToken.isEmpty()) {
                            String cacheKey = "matches:" + playerName + ":" + limit;
                            matchesCache.put(cacheKey, new MatchesCacheEntry(json.deepCopy(), System.currentTimeMillis()));
                        }
						future.complete(json);
					}
					catch (JsonSyntaxException e)
					{
						future.completeExceptionally(e);
					}
				}
			}
		});

		return future;
	}

	/**
	 * Fetch match history by account SHA256 hash (derived from UUID).
	 * This returns ALL matches across ALL account names for this identity.
	 * Use this for accurate MMR delta lookups even after name changes.
	 * 
	 * @param acctSha SHA256 hash of the player's UUID
	 * @param nextToken Pagination token (null for first page)
	 * @param limit Max matches to return
	 * @param bypassCache If true, skip cache and always fetch fresh data
	 */
	public CompletableFuture<JsonObject> getPlayerMatchesByAcct(String acctSha, String nextToken, int limit, boolean bypassCache)
	{
		CompletableFuture<JsonObject> future = new CompletableFuture<>();

		if (acctSha == null || acctSha.isEmpty()) {
			future.complete(new JsonObject());
			return future;
		}

		String acctShaLower = acctSha.toLowerCase();

		// Check cache (only for first page, i.e. no nextToken, and if not bypassing)
		if (!bypassCache && (nextToken == null || nextToken.isEmpty())) {
			String cacheKey = "matches:acct:" + acctShaLower + ":" + limit;
			MatchesCacheEntry cached = matchesCache.get(cacheKey);
			if (cached != null && System.currentTimeMillis() - cached.getTimestamp() <= MATCHES_CACHE_TTL_MS) {
				future.complete(cached.getResponse().deepCopy());
				return future;
			}
		}

		HttpUrl urlObj = HttpUrl.parse(API_BASE_URL + "/matches");
		if (urlObj == null) {
			future.completeExceptionally(new IOException("Invalid base URL"));
			return future;
		}
		
		// Use 'acct' parameter instead of 'player_id' for SHA256-based lookup
		HttpUrl.Builder urlBuilder = urlObj.newBuilder()
			.addQueryParameter("acct", acctShaLower)
			.addQueryParameter("limit", String.valueOf(limit));

		if (nextToken != null && !nextToken.isEmpty()) {
			urlBuilder.addQueryParameter("next_token", nextToken);
		}

		Request.Builder requestBuilder = new Request.Builder()
			.url(urlBuilder.build())
			.get();

		// Add client UUID header for API authentication/tracking
		String clientUuid = clientIdentityService.getClientUniqueId();
		if (clientUuid != null && !clientUuid.isEmpty()) {
			requestBuilder.addHeader("X-Client-Unique-Id", clientUuid);
		}

		Request request = requestBuilder.build();
		log.debug("[API] Fetching matches by acct: {}", acctShaLower);

		okHttpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				// Try serving stale cache if available
				if (nextToken == null || nextToken.isEmpty()) {
					String cacheKey = "matches:acct:" + acctShaLower + ":" + limit;
					MatchesCacheEntry cached = matchesCache.get(cacheKey);
					if (cached != null) {
						future.complete(cached.getResponse().deepCopy());
						return;
					}
				}
				future.completeExceptionally(e);
			}

			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				try (Response res = response)
				{
					if (!res.isSuccessful())
					{
						// Try serving stale cache if available
						if (nextToken == null || nextToken.isEmpty()) {
							String cacheKey = "matches:acct:" + acctShaLower + ":" + limit;
							MatchesCacheEntry cached = matchesCache.get(cacheKey);
							if (cached != null) {
								future.complete(cached.getResponse().deepCopy());
								return;
							}
						}
						future.completeExceptionally(new IOException("API call failed with status: " + res.code()));
						return;
					}

					ResponseBody body = res.body();
					if (body == null)
					{
						future.complete(new JsonObject());
						return;
					}

					try
					{
						String bodyString;
						try {
							bodyString = body.string();
						} catch (IOException cacheEx) {
							future.complete(new JsonObject());
							return;
						}
						JsonObject json = gson.fromJson(bodyString, JsonObject.class);
						if (nextToken == null || nextToken.isEmpty()) {
							String cacheKey = "matches:acct:" + acctShaLower + ":" + limit;
							matchesCache.put(cacheKey, new MatchesCacheEntry(json.deepCopy(), System.currentTimeMillis()));
						}
						future.complete(json);
					}
					catch (JsonSyntaxException e)
					{
						future.completeExceptionally(e);
					}
				}
			}
		});

		return future;
	}

	/**
	 * Get the account SHA256 hash for the current client's UUID.
	 * Returns null if UUID is not available.
	 */
	public String getSelfAcctSha()
	{
		try {
			String uuid = clientIdentityService.getClientUniqueId();
			if (uuid != null && !uuid.isEmpty()) {
				return generateAcctSha(uuid);
			}
		} catch (Exception e) {
			log.debug("[API] Failed to generate self acct SHA: {}", e.getMessage());
		}
		return null;
	}

	public CompletableFuture<JsonObject> getUserProfile(String playerName, String clientUniqueId)
	{
		return getUserProfile(playerName, clientUniqueId, false);
	}

	public CompletableFuture<JsonObject> getUserProfile(String playerName, String clientUniqueId, boolean forceRefresh)
	{
		CompletableFuture<JsonObject> future = new CompletableFuture<>();
		log.debug("[API] getUserProfile called: player={} forceRefresh={}", playerName, forceRefresh);

		String cacheKey = "user:" + playerName;
		UserStatsCache cached = userStatsCache.get(cacheKey);
		if (!forceRefresh && cached != null && System.currentTimeMillis() - cached.getTimestamp() <= USER_CACHE_TTL_MS) {
			log.debug("[API] getUserProfile: returning cached data for player={}", playerName);
			future.complete(cached.getStats().deepCopy());
			return future;
		}

		HttpUrl urlObj = HttpUrl.parse(API_BASE_URL + "/user");
		if (urlObj == null) {
			log.debug("[API] getUserProfile: invalid base URL");
			future.completeExceptionally(new IOException("Invalid base URL"));
			return future;
		}
		HttpUrl url = urlObj.newBuilder()
			.addQueryParameter("player_id", playerName)
			.build();

		Request.Builder requestBuilder = new Request.Builder().url(url).get();
		
		// Add client UUID header for API authentication/tracking
		String clientUuid = clientIdentityService.getClientUniqueId();
		if (clientUuid != null && !clientUuid.isEmpty())
		{
			requestBuilder.addHeader("X-Client-Unique-Id", clientUuid);
		}
		
		Request request = requestBuilder.build();
		log.debug("[API] getUserProfile: making HTTP request to {}", url);

		okHttpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				log.debug("[API] getUserProfile onFailure: player={} error={}", playerName, e.getMessage());
				UserStatsCache stale = userStatsCache.get(cacheKey);
				if (stale != null) {
					log.debug("[API] getUserProfile: using stale cache on failure for player={}", playerName);
					future.complete(stale.getStats().deepCopy());
					return;
				}
				future.completeExceptionally(e);
			}

			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				try (Response res = response)
				{
					log.debug("[API] getUserProfile onResponse: player={} code={}", playerName, res.code());
					if (!res.isSuccessful())
					{
						if (res.code() == 404) {
							log.debug("[API] getUserProfile: 404 not found for player={}", playerName);
							future.complete(null);
							return;
						}
						log.debug("[API] getUserProfile: HTTP error {} for player={}", res.code(), playerName);
						future.completeExceptionally(new IOException("API error: " + res.code()));
						return;
					}
					ResponseBody body = res.body();
					String bodyString;
					try {
						bodyString = body != null ? body.string() : "{}";
					} catch (IOException cacheEx) {
						log.debug("[API] getUserProfile: cache error during body read for player={}: {}", playerName, cacheEx.getMessage());
						// Windows cache file locking issue - request succeeded but cache failed
						// Try to serve stale cache if available
						UserStatsCache stale = userStatsCache.get(cacheKey);
						if (stale != null) {
							log.debug("[API] getUserProfile: using stale cache after cache error for player={}", playerName);
							future.complete(stale.getStats().deepCopy());
							return;
						}
						log.debug("[API] getUserProfile: no stale cache, returning null for player={}", playerName);
						future.complete(null);
						return;
					}
					log.debug("[API] getUserProfile SUCCESS: player={} bodyLength={}", playerName, bodyString.length());
					log.debug("[API] getUserProfile RESPONSE: player={} body={}", playerName, bodyString);
					JsonObject json = gson.fromJson(bodyString, JsonObject.class);
					userStatsCache.put(cacheKey, new UserStatsCache(json.deepCopy(), System.currentTimeMillis()));
					future.complete(json);
				}
				catch (JsonSyntaxException e)
				{
					log.debug("[API] getUserProfile: JSON parse error for player={}: {}", playerName, e.getMessage());
					future.completeExceptionally(e);
				}
			}
		});

		return future;
	}

    /**
     * Get tier from user profile API using /user endpoint.
     * /user returns: rank (tier name like "Dragon"), division (1-3), buckets (per-bucket data)
     * Returns combined tier string like "Dragon 3" or just "Dragon" if no division.
     */
    public CompletableFuture<String> getTierFromProfile(String playerName, String bucket)
    {
        log.debug("[API] getTierFromProfile called: player={} bucket={}", playerName, bucket);
        
        // Force refresh to get fresh data after a fight, but keep cached data as fallback
        String cacheKey = "user:" + playerName;
        UserStatsCache cachedData = userStatsCache.get(cacheKey);
        log.debug("[API] getTierFromProfile: cachedData exists={}", cachedData != null);
        
        return getUserProfile(playerName, null, true).thenApply(profile -> {
            if (profile == null) {
                log.debug("[API] getTierFromProfile: profile is null for player={}", playerName);
                // Try fallback to cached data if available
                if (cachedData != null) {
                    JsonObject cachedProfile = cachedData.getStats();
                    if (cachedProfile != null) {
                        log.debug("[API] getTierFromProfile: using cached fallback for player={}", playerName);
                        // Try bucket-specific data first
                        if (cachedProfile.has("buckets") && cachedProfile.get("buckets").isJsonObject()) {
                            JsonObject buckets = cachedProfile.getAsJsonObject("buckets");
                            if (buckets.has(bucket) && buckets.get(bucket).isJsonObject()) {
                                JsonObject bucketData = buckets.getAsJsonObject(bucket);
                                String tier = extractTierFromUserResponse(bucketData, playerName, bucket);
                                if (tier != null) {
                                    log.debug("[API] getTierFromProfile: cached bucket tier={} for player={}", tier, playerName);
                                    return tier;
                                }
                            }
                        }
                        // Fallback to top-level
                        String tier = extractTierFromUserResponse(cachedProfile, playerName, "overall");
                        log.debug("[API] getTierFromProfile: cached top-level tier={} for player={}", tier, playerName);
                        return tier;
                    }
                }
                log.debug("[API] getTierFromProfile: no cached data, returning null for player={}", playerName);
                return null;
            }
            
            log.debug("[API] getTierFromProfile: got profile for player={}, keys={}", playerName, profile.keySet());
            
            // Try bucket-specific data first (in "buckets" object)
            if (profile.has("buckets") && profile.get("buckets").isJsonObject()) {
                JsonObject buckets = profile.getAsJsonObject("buckets");
                if (buckets.has(bucket) && buckets.get(bucket).isJsonObject()) {
                    JsonObject bucketData = buckets.getAsJsonObject(bucket);
                    String tier = extractTierFromUserResponse(bucketData, playerName, bucket);
                    if (tier != null) {
                        log.debug("[API] getTierFromProfile SUCCESS: bucket tier={} for player={}", tier, playerName);
                        return tier;
                    }
                }
            }
            
            // Fallback to top-level rank/division fields (for overall bucket)
            String tier = extractTierFromUserResponse(profile, playerName, "overall");
            if (tier != null) {
                log.debug("[API] getTierFromProfile SUCCESS: top-level tier={} for player={}", tier, playerName);
                return tier;
            }
            
            log.debug("[API] getTierFromProfile: no rank found in profile for player={} bucket={}", playerName, bucket);
            return null;
        });
    }
    
    /**
     * Extract tier from /user response object.
     * /user returns "rank" (tier name like "Bronze", "Dragon") and "division" (1, 2, or 3)
     * NOT a "tier" field - that's only in S3 shards.
     */
    private String extractTierFromUserResponse(JsonObject obj, String playerName, String bucket) {
        if (obj == null) return null;
        
        String rank = null;
        int division = 0;
        
        // /user endpoint uses "rank" for tier name (e.g., "Bronze", "Dragon", "3rd Age")
        if (obj.has("rank") && !obj.get("rank").isJsonNull()) {
            rank = obj.get("rank").getAsString();
        }
        // division is 1, 2, or 3
        if (obj.has("division") && !obj.get("division").isJsonNull()) {
            division = obj.get("division").getAsInt();
        }
        
        if (rank != null && !rank.isEmpty()) {
            // Combine rank and division (e.g., "Dragon 3")
            String tier = division > 0 ? rank + " " + division : rank;
            // debug("[API] extractTierFromUserResponse SUCCESS player={} bucket={} tier={}", playerName, bucket, tier);
            return tier;
        }
        return null;
    }

    /**
     * API lookup for post-fight rank refresh (bypasses shards for fresh data).
     * Uses /user endpoint which returns rank and division fields.
     */
	public CompletableFuture<String> getPlayerTier(String playerName, String bucket)
	{
		// debug("[API] getPlayerTier called for player={} bucket={}", playerName, bucket);
        // Delegate to getTierFromProfile which uses /user endpoint correctly
        return getTierFromProfile(playerName, bucket);
	}

	/**
     * Primary Entry Point: Get Rank by Name using the SHA256 Shard Logic
     * Uses in-flight deduplication to prevent multiple concurrent lookups for the same (player, bucket).
     */
	public CompletableFuture<ShardRank> getShardRankByName(String playerName, String bucket)
	{
        if (playerName == null || playerName.trim().isEmpty()) {
            return CompletableFuture.completedFuture(null);
        }

        // 1. Canonicalize Name and bucket (normalize spaces for consistency)
        String canonicalName = playerName.trim().replaceAll("\\s+", " ").toLowerCase();
        String bucketPath = (bucket == null || bucket.isEmpty()) ? "overall" : bucket.toLowerCase();
        
        // Create lookup key for deduplication
        String lookupKey = canonicalName + ":" + bucketPath;
        
        // Check for existing in-flight lookup - if one exists, return it instead of starting a new one
        CompletableFuture<ShardRank> existingLookup = inFlightLookups.get(lookupKey);
        if (existingLookup != null) {
            // debug("[Lookup] Dedup: reusing in-flight lookup for '{}' bucket={}", canonicalName, bucketPath);
            return existingLookup;
        }
        
        // Create new future for this lookup
        CompletableFuture<ShardRank> future = new CompletableFuture<>();
        
        // Try to register as the in-flight lookup (atomic operation)
        CompletableFuture<ShardRank> previousLookup = inFlightLookups.putIfAbsent(lookupKey, future);
        if (previousLookup != null) {
            // Another thread beat us to it - use their future instead
            // debug("[Lookup] Dedup: race detected, reusing in-flight lookup for '{}' bucket={}", canonicalName, bucketPath);
            return previousLookup;
        }
        
        // We own this lookup - make sure to clean up when done
        future.whenComplete((result, ex) -> inFlightLookups.remove(lookupKey, future));
        
        try {
            // Check Negative Cache first (1 hour block)
            Long missingUntil = missingPlayerUntilMs.get(canonicalName);
            if (missingUntil != null && System.currentTimeMillis() < missingUntil) {
                // debug("[Lookup] Negative cache hit for {} (blocked until {})", canonicalName, missingUntil);
                future.complete(null);
                return future;
            }

            // 2. Shard Key = first 2 chars of lowercase name (e.g., "toyco" -> "to")
            String shardKey = canonicalName.length() >= 2 
                ? canonicalName.substring(0, 2).toLowerCase() 
                : canonicalName.toLowerCase();
            String url = SHARD_BASE_URL + "/" + bucketPath + "/" + shardKey + ".json";

            // debug("[Lookup] Player: {} -> Shard: {} -> URL: {}", canonicalName, shardKey, url);

            // 4. Fetch/Get Cached Shard
            getShard(url).thenCompose(shardJson -> {
                if (shardJson == null) {
                    // debug("[Lookup] Shard download failed/empty for {}", url);
                    // THIS: Also mark player as missing for 1 hour when shard doesn't exist
                    missingPlayerUntilMs.put(canonicalName, System.currentTimeMillis() + MISSING_PLAYER_BACKOFF_MS);
                    future.complete(null);
                    return CompletableFuture.completedFuture(null);
                }
                
                // 5. Look for Name in name_rank_info_map
                JsonObject nameMap = shardJson.getAsJsonObject("name_rank_info_map");
                if (nameMap == null || !nameMap.has(canonicalName)) {
                    // debug("[Lookup] Player '{}' NOT FOUND in shard {}", canonicalName, shardKey);
                    // Mark missing (1 Hour TTL)
                    missingPlayerUntilMs.put(canonicalName, System.currentTimeMillis() + MISSING_PLAYER_BACKOFF_MS);
                    future.complete(null);
                    return CompletableFuture.completedFuture(null);
                }
                
                JsonObject entry = nameMap.getAsJsonObject(canonicalName);
                
                // Scenario B: Redirect
                if (entry.has("redirect")) {
                    String accountSha = entry.get("redirect").getAsString();
                    // debug("[Lookup] Redirect found for '{}' -> SHA: {}", canonicalName, accountSha);
                    // FIX: Complete the outer future with the redirect result
                    resolveRedirect(accountSha, bucketPath).thenAccept(result -> {
                        future.complete(result);
                    }).exceptionally(ex -> {
                        future.complete(null);
                        return null;
                    });
                    return CompletableFuture.completedFuture(null);
                }
                
                // Scenario A: Direct Hit
                // debug("[Lookup] Direct hit for '{}'", canonicalName);
                ShardRank rank = parseRankObject(entry);
                future.complete(rank);
                return CompletableFuture.completedFuture(null);
                
            }).exceptionally(ex -> {
                // debug("Exception in getShardRankByName: {}", ex.getMessage());
                future.complete(null);
                return null;
            });
            
        } catch (Exception e) {
            // debug("Error in getShardRankByName: {}", e.getMessage());
            future.complete(null);
        }
		return future;
	}

    /**
     * Helper to resolve Redirect (Account SHA -> Rank Shard)
     * Supports chained redirects with max depth of 10
     */
    private CompletableFuture<ShardRank> resolveRedirect(String accountSha, String bucket) {
        return resolveRedirectWithDepth(accountSha, bucket, 0);
    }

    private CompletableFuture<ShardRank> resolveRedirectWithDepth(String accountSha, String bucket, int depth) {
        CompletableFuture<ShardRank> future = new CompletableFuture<>();
        
        if (depth >= 10) {
            // debug("[Redirect] Max depth (10) reached for {}, aborting", accountSha);
            future.complete(null);
            return future;
        }
        
        if (accountSha == null || accountSha.length() < 2) {
            future.complete(null);
            return future;
        }

        // 1. Calc Shard from SHA (first 2 chars)
        String shardKey = accountSha.substring(0, 2);
        String url = SHARD_BASE_URL + "/" + bucket + "/" + shardKey + ".json";
        
        // debug("[Redirect] depth={} SHA={} -> Shard={}", depth, accountSha, shardKey);

        // 2. Fetch/Get Cached Shard
        getShard(url).thenAccept(shardJson -> {
            if (shardJson == null) {
                future.complete(null);
                return;
            }
            
            // 3. Look in account_rank_info_map
            JsonObject acctMap = shardJson.getAsJsonObject("account_rank_info_map");
            if (acctMap != null && acctMap.has(accountSha)) {
                JsonObject entry = acctMap.getAsJsonObject(accountSha);
                
                // Check for chained redirect
                if (entry.has("redirect")) {
                    String nextSha = entry.get("redirect").getAsString();
                    // debug("[Redirect] Chain redirect to {}", nextSha);
                    resolveRedirectWithDepth(nextSha, bucket, depth + 1)
                        .thenAccept(future::complete);
                    return;
                }
                
                // debug("[Redirect] Found SHA entry at depth {}", depth);
                future.complete(parseRankObject(entry));
            } else {
                // debug("[Redirect] SHA entry NOT FOUND in shard");
                future.complete(null);
            }
        }).exceptionally(ex -> {
            future.complete(null);
            return null;
        });
        
        return future;
    }
    
    private ShardRank parseRankObject(JsonObject o) {
        if (o == null) return null;
        if (RankUtils.isUnrankedOrDefault(o)) return null;

        int idx = o.has("world_rank") && !o.get("world_rank").isJsonNull() ? o.get("world_rank").getAsInt() : -1;
        
        String tier = null;
        if (o.has("tier") && !o.get("tier").isJsonNull()) {
            tier = RankUtils.formatTierLabel(o.get("tier").getAsString());
        }
        
        if (tier == null && o.has("rank")) {
             tier = o.get("rank").getAsString();
        }
        
        if (tier != null && idx > 0) {
            return new ShardRank(tier, idx);
        }
        if (tier != null) return new ShardRank(tier, idx > 0 ? idx : 0);
        
        return null;
    }

	/**
	 * Low-level shard fetch with 60s Cache
	 */
	public CompletableFuture<JsonObject> getShard(String url)
	{
		CompletableFuture<JsonObject> future = new CompletableFuture<>();
        
        long now = System.currentTimeMillis();
        
        // 1. Check Memory Cache
        ShardEntry cached = shardCache.get(url);
        if (cached != null && (now - cached.getTimestamp() < SHARD_CACHE_EXPIRY_MS)) {
            // debug("[Cache] HIT for {}", url);
            future.complete(cached.getPayload());
            return future;
        }
        
        // 2. Check Negative Cache (Fail Until)
        Long failUntil = shardFailUntil.get(url);
        if (failUntil != null && now < failUntil) {
            // debug("[Cache] Negative/Fail HIT for {}", url);
            future.complete(null);
            return future;
        }

        // 3. Download
		Request request = new Request.Builder().url(url).get().build();
		// debug("[Network] Downloading shard: {}", url);

		okHttpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
                // debug("[Network] Fail: {}", e.getMessage());
                shardFailUntil.put(url, System.currentTimeMillis() + SHARD_FAIL_BACKOFF_MS);
				future.completeExceptionally(e);
			}

			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				try (Response res = response)
				{
					if (!res.isSuccessful()) {
                        // debug("[Network] HTTP Error: {}", res.code());
                        shardFailUntil.put(url, System.currentTimeMillis() + SHARD_FAIL_BACKOFF_MS);
						future.complete(null);
						return;
					}
                    
                    ResponseBody body = res.body();
                    if (body == null) {
                        future.complete(new JsonObject());
                        return;
                    }
                    
                    String bodyStr;
                    try {
                        bodyStr = body.string();
                    } catch (IOException cacheEx) {
                        // Windows cache file locking issue - request succeeded but cache failed
                        // Try to serve stale cache if available
                        ShardEntry stale = shardCache.get(url);
                        if (stale != null) {
                            future.complete(stale.getPayload());
                            return;
                        }
                        future.complete(null);
                        return;
                    }
                    JsonObject json = gson.fromJson(bodyStr, JsonObject.class);
                    
                    // Cache Success (60s)
                    shardCache.put(url, new ShardEntry(json, System.currentTimeMillis()));
                    shardFailUntil.remove(url);
                    
                    future.complete(json);
				} catch (Exception e) {
                    // debug("[Network] Parse Error: {}", e.getMessage());
                    future.complete(null);
                }
			}
		});
		return future;
	}

    // Retained for compatibility if needed, but not used by new flow
	public CompletableFuture<ShardRank> getShardRank(String accountHash, String bucket)
	{
		// Map old account-hash based call to the resolveRedirect logic which effectively does SHA->Shard lookup
        // But getShardRank was used when we *only* had account hash.
        // If we want to support that, we can use the resolveRedirect logic.
        return resolveRedirect(accountHash, bucket == null ? "overall" : bucket);
	}

	public CompletableFuture<Integer> getRankNumber(String playerName, String accountHash, String bucket)
	{
		// New logic: Use getShardRankByName which handles everything (name->md5->shard or name->redirect->sha->shard)
        // If we have accountHash, we can try direct SHA lookup (resolveRedirect), but Name lookup is preferred now?
        // Actually, if we have Name, we should use getShardRankByName.
        
        return getShardRankByName(playerName, bucket).thenApply(sr -> {
            if (sr != null) return sr.rank;
            return -1;
        });
	}

    // Helper for deprecated usage if any
	public CompletableFuture<Integer> getRankIndex(String playerId, String bucket)
	{
        // Redirect to new logic
        return getShardRankByName(playerId, bucket).thenApply(sr -> sr != null ? sr.rank : -1);
	}

	public String generateAcctSha(String uuid) throws Exception
	{
		MessageDigest digest = MessageDigest.getInstance("SHA-256");
		byte[] hash = digest.digest(uuid.getBytes(StandardCharsets.UTF_8));
		StringBuilder hexString = new StringBuilder();
		for (byte b : hash)
		{
			String hex = Integer.toHexString(0xff & b);
			if (hex.length() == 1) hexString.append('0');
			hexString.append(hex);
		}
		return hexString.toString();
	}

    /**
     * Check if a world is a DMM world.
     * Uses cached DMM world list with 1-hour TTL.
     */
    public boolean isDmmWorld(int world)
    {
        refreshDmmWorldsIfNeeded();
        return dmmWorldsCache.contains(world);
    }

    /**
     * Get the set of DMM worlds (cached).
     */
    public Set<Integer> getDmmWorlds()
    {
        refreshDmmWorldsIfNeeded();
        return new HashSet<>(dmmWorldsCache);
    }

    /**
     * Refresh DMM worlds cache if expired or empty.
     */
    private void refreshDmmWorldsIfNeeded()
    {
        long now = System.currentTimeMillis();
        if (now - dmmWorldsCacheTimestamp < DMM_WORLDS_CACHE_TTL_MS && !dmmWorldsCache.isEmpty())
        {
            return; // Cache still valid
        }

        if (dmmWorldsFetchInProgress)
        {
            return; // Already fetching
        }

        dmmWorldsFetchInProgress = true;
        fetchDmmWorlds().whenComplete((worlds, ex) -> {
            dmmWorldsFetchInProgress = false;
            if (worlds != null && !worlds.isEmpty())
            {
                dmmWorldsCache = worlds;
                dmmWorldsCacheTimestamp = System.currentTimeMillis();
                log.debug("[DMM] Updated DMM worlds cache: {}", worlds);
            }
            else if (ex != null)
            {
                log.debug("[DMM] Failed to fetch DMM worlds: {}", ex.getMessage());
            }
        });
    }

    /**
     * Fetch DMM worlds from the API endpoint.
     * Endpoint: /config/worlds
     * Response: {"dmm": [345, 346, ...]}
     */
    private CompletableFuture<Set<Integer>> fetchDmmWorlds()
    {
        CompletableFuture<Set<Integer>> future = new CompletableFuture<>();

        String url = API_BASE_URL + "/config/worlds";
        Request request = new Request.Builder().url(url).get().build();

        log.debug("[DMM] Fetching DMM worlds from {}", url);

        okHttpClient.newCall(request).enqueue(new Callback()
        {
            @Override
            public void onFailure(Call call, IOException e)
            {
                log.debug("[DMM] Network failure fetching DMM worlds: {}", e.getMessage());
                future.complete(new HashSet<>());
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException
            {
                try (Response res = response)
                {
                    if (!res.isSuccessful())
                    {
                        log.debug("[DMM] HTTP error {} fetching DMM worlds", res.code());
                        future.complete(new HashSet<>());
                        return;
                    }

                    ResponseBody body = res.body();
                    if (body == null)
                    {
                        future.complete(new HashSet<>());
                        return;
                    }

                    String bodyString = body.string();
                    log.debug("[DMM] Response: {}", bodyString);

                    // Parse response - expecting {"dmm": [345, 346, ...]}
                    Set<Integer> worlds = new HashSet<>();
                    JsonObject json = gson.fromJson(bodyString, JsonObject.class);
                    
                    if (json.has("dmm") && json.get("dmm").isJsonArray())
                    {
                        for (var element : json.getAsJsonArray("dmm"))
                        {
                            worlds.add(element.getAsInt());
                        }
                    }
                    
                    future.complete(worlds);
                }
                catch (Exception e)
                {
                    log.debug("[DMM] Error parsing DMM worlds response: {}", e.getMessage());
                    future.complete(new HashSet<>());
                }
            }
        });

        return future;
    }

}

package com.pvp.leaderboard.service;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import net.runelite.client.config.ConfigManager;
import com.sun.net.httpserver.HttpExchange;
import com.sun.net.httpserver.HttpHandler;
import com.sun.net.httpserver.HttpServer;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;

import java.io.*;
import java.net.*;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.util.Base64;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import javax.inject.Inject;
import net.runelite.client.util.LinkBrowser;

public class CognitoAuthService {
    private static final String COGNITO_DOMAIN = "osrs-mmr-a8959e04.auth.us-east-1.amazoncognito.com";
    private static final String CLIENT_ID = "5ho4mj5d17v44s4vavnkmp2mmo";
    private static final String REDIRECT_URI = "http://127.0.0.1:49215/callback";
    private static final int CALLBACK_PORT = 49215;
    
    private final ConfigManager configManager;
    private final OkHttpClient httpClient;
    private final Gson gson;
    private String transientVerifier;
    private String transientState;
    // Local HTTP server for OAuth callback
    private HttpServer httpServer;
    private String accessToken;
    private String idToken;
    private String refreshToken;
    private long tokenExpiry;
    private final ScheduledExecutorService scheduler;
    private ScheduledFuture<?> refreshTask;
    
    @Inject
    public CognitoAuthService(ConfigManager configManager, OkHttpClient httpClient, Gson gson, ScheduledExecutorService scheduler) {
        this.configManager = configManager;
        this.httpClient = httpClient;
        this.gson = gson;
        this.scheduler = scheduler;
    }


    public CompletableFuture<Boolean> login() {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // Generate PKCE
                String verifier = generatePKCEVerifier();
                String challenge = generatePKCEChallenge(verifier);
                if (configManager != null) {
                    configManager.setConfiguration("PvPLeaderboard", "pkce_verifier", verifier);
                } else {
                    transientVerifier = verifier;
                }

                // Start local HTTP server to capture callback
                CompletableFuture<String> codeFuture = new CompletableFuture<>();
                startCallbackServer(codeFuture);

                // Open browser to login with random OAuth state
                String state = generateRandomState();
                if (configManager != null) {
                    configManager.setConfiguration("PvPLeaderboard", "oauth_state", state);
                } else {
                    transientState = state;
                }
                String loginUrl = String.format(
                    "https://%s/login?client_id=%s&response_type=code&scope=openid+email+profile&redirect_uri=%s&code_challenge_method=S256&code_challenge=%s&state=%s",
                    COGNITO_DOMAIN, CLIENT_ID, URLEncoder.encode(REDIRECT_URI, "UTF-8"), challenge, URLEncoder.encode(state, "UTF-8")
                );
                LinkBrowser.browse(loginUrl);

                // Wait for code up to 10s; on timeout, fail silently and allow re-login
                String code = null;
                try {
                    code = codeFuture.get(10, java.util.concurrent.TimeUnit.SECONDS);
                } catch (java.util.concurrent.TimeoutException te) {
                    // Timeout: stop server and return false without UI popups
                    stopCallbackServer();
                    clearTokens();
                    return false;
                }
                stopCallbackServer();
                if (code == null || code.isEmpty()) {
                    // Ensure auth artifacts are cleared on failure
                    clearTokens();
                    return false;
                }
                exchangeCodeForTokens(code.trim());
                ensureRefreshScheduler();
                return true;
            } catch (Exception e) {
                stopCallbackServer();
                clearTokens();
                return false;
            }
        }, scheduler);
    }
    
    private void startCallbackServer(CompletableFuture<String> codeFuture) throws IOException {
        if (httpServer != null) stopCallbackServer();
        InetSocketAddress addr = new InetSocketAddress("127.0.0.1", CALLBACK_PORT);
        httpServer = HttpServer.create(addr, 0);
        httpServer.createContext("/callback", new HttpHandler() {
            @Override
            public void handle(HttpExchange ex) throws IOException {
                try {
                    URI uri = ex.getRequestURI();
                    String query = uri.getRawQuery();
                    String code = extractParam(query, "code");
                    // Validate returned state to mitigate CSRF
                    String state = extractParam(query, "state");
                    String expectedState = null;
                    if (configManager != null) {
                        Object s = configManager.getConfiguration("PvPLeaderboard", "oauth_state");
                        expectedState = s != null ? String.valueOf(s) : null;
                    } else {
                        expectedState = transientState;
                    }
                    boolean stateOk = expectedState != null && expectedState.equals(state);
                    String html = stateOk && code != null && !code.isEmpty()
                        ? "<html><head><title>Login Complete</title></head><body style=\"background:#111;color:#ffcc00;font-family:Arial\"><h2>Login complete</h2><p>You may now return to RuneLite.</p></body></html>"
                        : "<html><head><title>Login Failed</title></head><body style=\"background:#111;color:#ff6666;font-family:Arial\"><h2>Login failed</h2><p>Invalid login state.</p></body></html>";
                    byte[] bytes = html.getBytes(StandardCharsets.UTF_8);
                    ex.getResponseHeaders().set("Content-Type", "text/html; charset=utf-8");
                    ex.sendResponseHeaders(200, bytes.length);
                    try (OutputStream os = ex.getResponseBody()) { os.write(bytes); }
                    if (stateOk && code != null && !code.isEmpty() && !codeFuture.isDone()) {
                        codeFuture.complete(code);
                    } else if (!codeFuture.isDone()) {
                        codeFuture.complete(null);
                    }
                } catch (Exception ignore) {
                    try { if (!codeFuture.isDone()) codeFuture.complete(null); } catch (Exception ignored) {}
                }
            }
        });
        httpServer.start();
    }

    private void stopCallbackServer() {
        try { if (httpServer != null) httpServer.stop(0); } catch (Exception ignore) {}
        httpServer = null;
    }
    
    private void exchangeCodeForTokens(String code) throws Exception {
        String verifier = null;
        if (configManager != null) {
            Object v = configManager.getConfiguration("PvPLeaderboard", "pkce_verifier");
            verifier = v != null ? String.valueOf(v) : null;
        } else {
            verifier = transientVerifier;
        }
        // Form-encode ALL values
        String postData =
            "grant_type=" + URLEncoder.encode("authorization_code", "UTF-8") +
            "&client_id=" + URLEncoder.encode(CLIENT_ID, "UTF-8") +
            "&code=" + URLEncoder.encode(code, "UTF-8") +
            "&redirect_uri=" + URLEncoder.encode(REDIRECT_URI, "UTF-8") +
            "&code_verifier=" + URLEncoder.encode(String.valueOf(verifier), "UTF-8");

        Request req = new Request.Builder()
            .url("https://" + COGNITO_DOMAIN + "/oauth2/token")
            .post(RequestBody.create(MediaType.parse("application/x-www-form-urlencoded"), postData))
            .addHeader("Accept", "application/json")
            .build();

        final java.util.concurrent.CompletableFuture<String> fut = new java.util.concurrent.CompletableFuture<>();
        httpClient.newCall(req).enqueue(new okhttp3.Callback() {
            @Override public void onFailure(okhttp3.Call call, java.io.IOException e) { fut.completeExceptionally(e); }
            @Override public void onResponse(okhttp3.Call call, okhttp3.Response response) throws java.io.IOException {
                try (okhttp3.Response res = response) {
                    if (!res.isSuccessful() || res.body() == null) {
                        fut.completeExceptionally(new IOException("Token exchange failed (status=" + res.code() + ")"));
                        return;
                    }
                    okhttp3.ResponseBody rb = res.body();
                    String body = rb != null ? rb.string() : "";
                    fut.complete(body);
                }
            }
        });
        String response = fut.get(10, java.util.concurrent.TimeUnit.SECONDS);

        JsonObject tokens = gson.fromJson(response, JsonObject.class);
        accessToken = tokens.has("access_token") && !tokens.get("access_token").isJsonNull() ? tokens.get("access_token").getAsString() : null;
        idToken = tokens.has("id_token") && !tokens.get("id_token").isJsonNull() ? tokens.get("id_token").getAsString() : null;
        refreshToken = tokens.has("refresh_token") && !tokens.get("refresh_token").isJsonNull() ? tokens.get("refresh_token").getAsString() : null;
        int expiresIn = tokens.has("expires_in") ? tokens.get("expires_in").getAsInt() : 3600;
        tokenExpiry = System.currentTimeMillis() + (expiresIn * 1000L);

        // Validate ID token claims before proceeding (iss/aud/exp/token_use)
        if (idToken == null || !validateIdTokenClaims(idToken)) {
            clearTokens();
            throw new IOException("Invalid ID token claims");
        }
        
        // Clean up
        if (configManager != null) {
            configManager.unsetConfiguration("PvPLeaderboard", "pkce_verifier");
            configManager.unsetConfiguration("PvPLeaderboard", "oauth_state");
        }
        transientVerifier = null;
        transientState = null;

        // Start/refresh auto refresh loop when we have a refresh token
        ensureRefreshScheduler();
    }
    
    public String getAccessToken() {
        return accessToken;
    }
    

    
    public boolean isLoggedIn() {
        return accessToken != null && System.currentTimeMillis() < tokenExpiry;
    }
    
    public void logout() {
        clearTokens();
    }
    
    public String getStoredIdToken() {
        return idToken;
    }
    
    private String generatePKCEVerifier() {
        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~";
        SecureRandom random = new SecureRandom();
        StringBuilder verifier = new StringBuilder(64);
        for (int i = 0; i < 64; i++) {
            verifier.append(chars.charAt(random.nextInt(chars.length())));
        }
        return verifier.toString();
    }
    
    private String generatePKCEChallenge(String verifier) throws Exception {
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        byte[] hash = digest.digest(verifier.getBytes(StandardCharsets.UTF_8));
        return Base64.getUrlEncoder().withoutPadding().encodeToString(hash).replace('+', '-').replace('/', '_');
    }
    
    private String generateRandomState() {
        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~";
        SecureRandom random = new SecureRandom();
        StringBuilder sb = new StringBuilder(32);
        for (int i = 0; i < 32; i++) {
            sb.append(chars.charAt(random.nextInt(chars.length())));
        }
        return sb.toString();
    }

    private void clearTokens() {
        accessToken = null;
        idToken = null;
        refreshToken = null;
        tokenExpiry = 0;
        try { if (refreshTask != null) { refreshTask.cancel(true); } } catch (Exception ignore) {}
        try { if (configManager != null) configManager.unsetConfiguration("PvPLeaderboard", "pkce_verifier"); } catch (Exception ignore) {}
        try { if (configManager != null) configManager.unsetConfiguration("PvPLeaderboard", "oauth_state"); } catch (Exception ignore) {}
        transientVerifier = null;
        transientState = null;
    }

    private boolean validateIdTokenClaims(String jwt) {
        try {
            String[] parts = jwt.split("\\.");
            if (parts.length < 2) return false;
            String payloadJson = new String(Base64.getUrlDecoder().decode(parts[1]), StandardCharsets.UTF_8);
            JsonObject payload = gson.fromJson(payloadJson, JsonObject.class);

            // Required claims
            String tokenUse = payload.has("token_use") && !payload.get("token_use").isJsonNull() ? payload.get("token_use").getAsString() : null;
            String aud = payload.has("aud") && !payload.get("aud").isJsonNull() ? payload.get("aud").getAsString() : null;
            String iss = payload.has("iss") && !payload.get("iss").isJsonNull() ? payload.get("iss").getAsString() : null;
            long exp = payload.has("exp") && !payload.get("exp").isJsonNull() ? payload.get("exp").getAsLong() : 0L;
            long now = System.currentTimeMillis() / 1000L;

            if (!"id".equalsIgnoreCase(tokenUse)) return false;
            if (aud == null || !aud.equals(CLIENT_ID)) return false;
            if (iss == null || !iss.startsWith("https://cognito-idp.us-east-1.amazonaws.com/")) return false;
            if (exp <= (now - 60)) return false; // allow small skew

            return true;
        } catch (Exception e) {
            return false;
        }
    }

    private synchronized void ensureRefreshScheduler() {
        if (refreshToken == null || refreshToken.isEmpty()) return;
        scheduleNextRefresh();
    }

    private void scheduleNextRefresh() {
        if (scheduler == null) return;
        long now = System.currentTimeMillis();
        // Refresh 60s before expiry; fallback to 55min if expiry unknown
        long target = tokenExpiry > 0 ? (tokenExpiry - 60_000L) : (now + 55L * 60L * 1000L);
        long delayMs = Math.max(5_000L, target - now);
        try { if (refreshTask != null) refreshTask.cancel(true); } catch (Exception ignore) {}
        refreshTask = scheduler.schedule(this::refreshFlow, delayMs, TimeUnit.MILLISECONDS);
    }

    private void refreshFlow() {
        try {
            // If logged out, skip
            if (refreshToken == null || refreshToken.isEmpty()) return;
            // If not close to expiry, reschedule
            long now = System.currentTimeMillis();
            if (tokenExpiry > 0 && now < tokenExpiry - 120_000L) {
                scheduleNextRefresh();
                return;
            }
            refreshWithToken();
        } catch (Exception ignore) {
            // On failure, retry in 2 minutes
            try { if (scheduler != null) scheduler.schedule(this::refreshFlow, 120_000L, TimeUnit.MILLISECONDS); } catch (Exception ignored) {}
            return;
        }
        // On success, schedule next
        scheduleNextRefresh();
    }

    private void refreshWithToken() throws Exception {
        if (refreshToken == null || refreshToken.isEmpty()) throw new IOException("No refresh token");
        String postData =
            "grant_type=" + URLEncoder.encode("refresh_token", "UTF-8") +
            "&client_id=" + URLEncoder.encode(CLIENT_ID, "UTF-8") +
            "&refresh_token=" + URLEncoder.encode(refreshToken, "UTF-8");

        Request req = new Request.Builder()
            .url("https://" + COGNITO_DOMAIN + "/oauth2/token")
            .post(RequestBody.create(MediaType.parse("application/x-www-form-urlencoded"), postData))
            .addHeader("Accept", "application/json")
            .build();

        final java.util.concurrent.CompletableFuture<String> fut = new java.util.concurrent.CompletableFuture<>();
        httpClient.newCall(req).enqueue(new okhttp3.Callback() {
            @Override public void onFailure(okhttp3.Call call, java.io.IOException e) { fut.completeExceptionally(e); }
            @Override public void onResponse(okhttp3.Call call, okhttp3.Response response) throws java.io.IOException {
                try (okhttp3.Response res = response) {
                    if (!res.isSuccessful() || res.body() == null) {
                        fut.completeExceptionally(new IOException("Refresh failed (status=" + res.code() + ")"));
                        return;
                    }
                    okhttp3.ResponseBody rb = res.body();
                    String body = rb != null ? rb.string() : "";
                    fut.complete(body);
                }
            }
        });
        String body = fut.get(10, java.util.concurrent.TimeUnit.SECONDS);

        JsonObject tokens = gson.fromJson(body, JsonObject.class);
        String newAccessToken = tokens.has("access_token") && !tokens.get("access_token").isJsonNull() ? tokens.get("access_token").getAsString() : null;
        String newIdToken = tokens.has("id_token") && !tokens.get("id_token").isJsonNull() ? tokens.get("id_token").getAsString() : null;
        int expiresIn = tokens.has("expires_in") ? tokens.get("expires_in").getAsInt() : 3600;
        if (newAccessToken == null) throw new IOException("No access token in refresh");
        accessToken = newAccessToken;
        if (newIdToken != null) {
            if (!validateIdTokenClaims(newIdToken)) throw new IOException("Invalid refreshed ID token");
            idToken = newIdToken;
        }
        tokenExpiry = System.currentTimeMillis() + (expiresIn * 1000L);
    }

    
    private String extractParam(String query, String param) {
        if (query == null) return null;
        for (String pair : query.split("&")) {
            String[] kv = pair.split("=", 2);
            if (kv.length == 2 && param.equals(kv[0])) {
                try {
                    return URLDecoder.decode(kv[1], "UTF-8");
                } catch (UnsupportedEncodingException e) {
                    return kv[1];
                }
            }
        }
        return null;
    }
}

package com.pvp.leaderboard.service;

public class RankInfo
{
    public final String rank;
    public final int division;
    public final double progress;

    public RankInfo(String rank, int division, double progress)
    {
        this.rank = rank;
        this.division = division;
        this.progress = progress;
    }
}

package com.pvp.leaderboard.service;

import lombok.Builder;
import lombok.Getter;
import lombok.ToString;

@Getter
@Builder
@ToString
public class MatchResult
{
    private final String playerId;
    private final String opponentId;
    private final String result; // "win", "loss", "tie"
    private final int world;
    private final long fightStartTs;
    private final long fightEndTs;
    private final String fightStartSpellbook;
    private final String fightEndSpellbook;
    private final boolean wasInMulti;
    private final String idToken;
    private final long damageToOpponent;
    private final String clientUniqueId;
}

package com.pvp.leaderboard;

import org.junit.Test;
import org.junit.Ignore;

public class MatchResultServiceTest
{
    @Ignore("Network/API tests disabled in unit context; migration to injected clients")
    @Test
    public void testUnauthenticatedMatchSubmission() throws Exception {}

    @Ignore("Network/API tests disabled in unit context; migration to injected clients")
    @Test
    public void testAuthenticatedMatchSubmission() throws Exception {}
}
package com.pvp.leaderboard;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.pvp.leaderboard.config.PvPLeaderboardConfig;
import com.pvp.leaderboard.service.PvPDataService;
import okhttp3.*;
import org.junit.Before;
import org.junit.Test;

import java.io.IOException;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

import static org.junit.Assert.*;

public class PvPDataServiceTest {

    private OkHttpClient okHttpClient;
    private TestInterceptor testInterceptor;
    private PvPLeaderboardConfig config;
    private PvPDataService dataService;
    private final Gson gson = new Gson();

    // Fake data for testing
    private static final String FAKE_PLAYER_ID = "TestPlayer_123";
    private static final String FAKE_UUID = "550e8400-e29b-41d4-a716-446655440000";
    private static final String FAKE_OPPONENT = "BadGuy_999";

    @Before
    public void setUp() {
        testInterceptor = new TestInterceptor();
        okHttpClient = new OkHttpClient.Builder()
                .addInterceptor(testInterceptor)
                .build();
        config = new MockConfig();
        // authService and clientIdentityService are unused in tests, passing null
        dataService = new PvPDataService(okHttpClient, gson, null, config, null);
    }

    @Test
    public void testGetPlayerMatches_Success() throws ExecutionException, InterruptedException, IOException {
        // Prepare fake response
        JsonObject fakeResponseJson = new JsonObject();
        fakeResponseJson.addProperty("player_id", FAKE_PLAYER_ID);
        // Add a fake match
        JsonObject match = new JsonObject();
        match.addProperty("opponent", FAKE_OPPONENT);
        match.addProperty("result", "win");
        match.addProperty("match_id", FAKE_UUID);
        
        com.google.gson.JsonArray matchesArray = new com.google.gson.JsonArray();
        matchesArray.add(match);
        fakeResponseJson.add("matches", matchesArray);

        testInterceptor.setNextResponse(200, gson.toJson(fakeResponseJson));

        // Execute
        CompletableFuture<JsonObject> future = dataService.getPlayerMatches(FAKE_PLAYER_ID, null, 10);
        JsonObject result = future.get();

        // Verify
        assertNotNull(result);
        assertEquals(FAKE_PLAYER_ID, result.get("player_id").getAsString());
        assertEquals(1, result.getAsJsonArray("matches").size());
        assertEquals(FAKE_OPPONENT, result.getAsJsonArray("matches").get(0).getAsJsonObject().get("opponent").getAsString());
        
        // Verify URL parameters
        assertNotNull(testInterceptor.getLastRequest());
        assertTrue(testInterceptor.getLastRequest().url().toString().contains("player_id=" + FAKE_PLAYER_ID));
    }

    @Test
    public void testGetPlayerTier_Success() throws ExecutionException, InterruptedException, IOException {
        // Prepare fake response
        JsonObject fakeTierJson = new JsonObject();
        fakeTierJson.addProperty("player_id", FAKE_PLAYER_ID);
        fakeTierJson.addProperty("tier", "Diamond I");
        fakeTierJson.addProperty("bucket", "nh");

        testInterceptor.setNextResponse(200, gson.toJson(fakeTierJson));

        // Execute
        CompletableFuture<String> future = dataService.getPlayerTier(FAKE_PLAYER_ID, "nh");
        String tier = future.get();

        // Verify
        assertEquals("Diamond I", tier);
    }

    @Test
    public void testGetPlayerTier_NotFound() throws ExecutionException, InterruptedException, IOException {
        testInterceptor.setNextResponse(404, "");

        // Execute
        CompletableFuture<String> future = dataService.getPlayerTier(FAKE_PLAYER_ID, "nh");
        String tier = future.get();

        // Verify
        assertNull(tier);
    }

    @Test
    public void testGetRankIndex_Success() throws ExecutionException, InterruptedException, IOException {
        JsonObject fakeRankJson = new JsonObject();
        fakeRankJson.addProperty("rank", 42);

        testInterceptor.setNextResponse(200, gson.toJson(fakeRankJson));

        // Execute
        CompletableFuture<Integer> future = dataService.getRankIndex(FAKE_PLAYER_ID, "nh");
        Integer rank = future.get();

        assertEquals(42, rank.intValue());
    }

    @Test
    public void testGetUserProfile_Success() throws ExecutionException, InterruptedException, IOException {
        JsonObject fakeProfile = new JsonObject();
        fakeProfile.addProperty("player_id", FAKE_PLAYER_ID);
        fakeProfile.addProperty("mmr", 1500.5);

        testInterceptor.setNextResponse(200, gson.toJson(fakeProfile));

        // Execute
        CompletableFuture<JsonObject> future = dataService.getUserProfile(FAKE_PLAYER_ID, "unique-id");
        JsonObject result = future.get();

        assertNotNull(result);
        assertEquals(FAKE_PLAYER_ID, result.get("player_id").getAsString());
        assertEquals(1500.5, result.get("mmr").getAsDouble(), 0.001);
    }

    @Test
    public void testGenerateAcctSha_ValidFormat() throws Exception {
        // Test SHA256 hash generation for UUID -> acct_sha conversion
        String hash = dataService.generateAcctSha("550e8400-e29b-41d4-a716-446655440000");
        assertNotNull(hash);
        assertEquals(64, hash.length()); // SHA256 produces 64 hex chars
        assertTrue(hash.matches("[0-9a-f]{64}")); // All lowercase hex
        
        // Verify same input produces same hash (deterministic)
        String hash2 = dataService.generateAcctSha("550e8400-e29b-41d4-a716-446655440000");
        assertEquals(hash, hash2);
        
        // Verify different inputs produce different hashes
        String otherHash = dataService.generateAcctSha("660e8400-e29b-41d4-a716-446655440001");
        assertNotEquals(hash, otherHash);
    }

    @Test
    public void testShardKeyFromName_FirstTwoChars() {
        // Verify shard key is first 2 chars of lowercase name, NOT SHA256
        // These match the expected behavior after the shard key change
        assertEquals("to", getShardKeyForName("Toyco"));
        assertEquals("to", getShardKeyForName("toyco"));
        assertEquals("mo", getShardKeyForName("MOH JO JOJO"));
        assertEquals("te", getShardKeyForName("test_account1"));
        assertEquals("a", getShardKeyForName("A")); // Single char edge case
    }
    
    private String getShardKeyForName(String name) {
        // Replicate the shard key logic from PvPDataService.getShardRankByName()
        String canonicalName = name.toLowerCase().trim().replaceAll("\\s+", " ");
        return canonicalName.length() >= 2 
            ? canonicalName.substring(0, 2).toLowerCase() 
            : canonicalName.toLowerCase();
    }

    // -- Mock Classes --

    private class TestInterceptor implements Interceptor {
        private int code;
        private String body;
        private Request lastRequest;

        public void setNextResponse(int code, String body) {
            this.code = code;
            this.body = body;
        }

        public Request getLastRequest() {
            return lastRequest;
        }

        @Override
        public Response intercept(Chain chain) throws IOException {
            lastRequest = chain.request();
            if (code == 0) throw new IOException("No mock response configured");
            
            return new Response.Builder()
                    .request(lastRequest)
                    .protocol(Protocol.HTTP_1_1)
                    .code(code)
                    .message(code == 200 ? "OK" : "Error")
                    .body(ResponseBody.create(MediaType.parse("application/json"), body != null ? body : ""))
                    .build();
        }
    }
    
    private class MockConfig implements PvPLeaderboardConfig {
        @Override
        public boolean enablePvpLookupMenu() { return false; }
    }
}

package com.pvp.leaderboard;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;
import net.runelite.client.plugins.Plugin;

public class PvPLeaderboardPluginTest
{

    public static void main(String[] args) throws Exception
	{
		loadPlugins(PvPLeaderboardPlugin.class);
		RuneLite.main(args);
	}

    @SafeVarargs
    private static void loadPlugins(Class<? extends Plugin>... plugins)
    {
        ExternalPluginManager.loadBuiltin(plugins);
    }
}


