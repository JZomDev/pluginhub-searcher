package com.linemarkers;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class LineMarkerPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(LineMarkerPlugin.class);
		RuneLite.main(args);
	}
}
package com.linemarkers;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonSyntaxException;
import com.google.gson.reflect.TypeToken;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class GsonTest
{
	private final Gson gson = new GsonBuilder().setPrettyPrinting().create();

	GsonTest()
	{
		LineGroup test = new LineGroup(null, null);
		test.id = 0;
		test.name = null;
		test.visible = false;
		test.collapsed = false;
		test.lines = null;

		// "" -> null
		test("", null);

		// "{}" -> null
		test("{}", null);

		// "[]" -> null
		test("[]", new ArrayList<>());

		// "[{}]" -> [null] // because of LineGroup::toString
		test("[{}]", new ArrayList<>(Arrays.asList(test)));

		// "[{id:0}]" -> [null] // because of LineGroup::toString
		test("[{id:0}]", new ArrayList<>(Arrays.asList(test)));

		// "[null]" -> [null] // because of null element
		test("[null]", new ArrayList<>(Arrays.asList(new LineGroup[]{null})));

		// null -> null
		test(null, null);
	}

	public void test(String text, List<LineGroup> expectedResult)
	{
		List<LineGroup> groups = null;
		try
		{
			groups = gson.fromJson(text, new TypeToken<ArrayList<LineGroup>>(){}.getType());
		}
		catch (IllegalStateException | JsonSyntaxException ignore)
		{
		}

		if (groups == null)
		{
			assert groups == expectedResult : "Expected output " + expectedResult + ", but got " + groups + " for input " + text;
		}
		else
		{
			if (!groups.isEmpty())
			{
				for (LineGroup group : groups)
				{
					assert LineGroup.isInvalid(group) : "Expected " + group + " to be an invalid line group for input " + text;
				}
			}
			assert groups.equals(expectedResult) : "Expected output " + expectedResult + ", but got " + groups + " for input " + text;
		}

	}

	public static void main(String[] args)
	{
		new GsonTest();
	}
}

package com.linemarkers;

import com.google.inject.Inject;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

class LineMarkerMinimapOverlay extends Overlay
{
	private final Client client;
	private final LineMarkerPlugin plugin;

	@Inject
	LineMarkerMinimapOverlay(Client client, LineMarkerPlugin plugin)
	{
		this.client = client;
		this.plugin = plugin;

		setPosition(OverlayPosition.DYNAMIC);
		setPriority(Overlay.PRIORITY_LOW);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (plugin.showMinimap)
		{
			drawMinimap(graphics);
		}
		return null;
	}

	private void drawMinimap(Graphics2D graphics)
	{
		graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);
		graphics.setClip(plugin.getMinimapClipArea());

		for (final LineGroup group : plugin.getMarkers())
		{
			if (!group.isVisible())
			{
				continue;
			}

			for (Line line : group.getLines())
			{
				drawLine(graphics, line);
			}
		}
	}

	private void drawLine(Graphics2D graphics, Line line)
	{
		final Point start = worldToMinimap(Edge.start(line));
		final Point end = worldToMinimap(Edge.end(line));

		if (start == null || end == null)
		{
			return;
		}

		graphics.setColor(line.getColour());
		graphics.drawLine(start.getX(), start.getY(), end.getX(), end.getY());
	}

	private Point worldToMinimap(final WorldPoint worldPoint)
	{
		if (client.getLocalPlayer() == null || client.getPlane() != worldPoint.getPlane())
		{
			return null;
		}

		final WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();
		final LocalPoint localLocation = client.getLocalPlayer().getLocalLocation();
		final LocalPoint playerLocalPoint = LocalPoint.fromWorld(client, playerLocation);

		if (playerLocalPoint == null)
		{
			return null;
		}

		final int offsetX = playerLocalPoint.getX() - localLocation.getX();
		final int offsetY = playerLocalPoint.getY() - localLocation.getY();

		final int dx = worldPoint.getX() - playerLocation.getX();
		final int dy = worldPoint.getY() - playerLocation.getY();

		final double tileSize = client.getMinimapZoom();

		final int x = (int) (dx * tileSize + offsetX * tileSize / Perspective.LOCAL_TILE_SIZE - tileSize / 2);
		final int y = (int) (dy * tileSize + offsetY * tileSize / Perspective.LOCAL_TILE_SIZE - tileSize / 2 + 1);

		final int angle = client.getCameraYawTarget() & 0x7FF;

		final int sin = Perspective.SINE[angle];
		final int cos = Perspective.COSINE[angle];

		final Widget minimapDrawWidget = plugin.getMinimapDrawWidget();
		if (minimapDrawWidget == null || minimapDrawWidget.isHidden())
		{
			return null;
		}

		final int xx = y * sin + cos * x >> 16;
		final int yy = sin * x - y * cos >> 16;

		final Point loc = minimapDrawWidget.getCanvasLocation();
		final int minimapX = loc.getX() + xx + minimapDrawWidget.getWidth() / 2;
		final int minimapY = loc.getY() + yy + minimapDrawWidget.getHeight() / 2;

		return new Point(minimapX, minimapY);
	}
}

package com.linemarkers;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.event.ActionListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.List;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JSpinner;
import javax.swing.SpinnerNumberModel;
import javax.swing.SwingUtilities;
import javax.swing.border.Border;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.components.FlatTextField;
import net.runelite.client.ui.components.TitleCaseListCellRenderer;
import net.runelite.client.ui.components.colorpicker.RuneliteColorPicker;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

class LineMarkerPanel extends JPanel
{
	private static final Border NAME_BOTTOM_BORDER = new CompoundBorder(
		BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.DARK_GRAY_COLOR),
		BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_COLOR));

	private static final ImageIcon SETTINGS_ICON;
	private static final ImageIcon SETTINGS_HOVER_ICON;
	private static final ImageIcon NO_SETTINGS_ICON;
	private static final ImageIcon NO_SETTINGS_HOVER_ICON;

	private static final ImageIcon VISIBLE_ICON;
	private static final ImageIcon VISIBLE_HOVER_ICON;
	private static final ImageIcon INVISIBLE_ICON;
	private static final ImageIcon INVISIBLE_HOVER_ICON;

	private static final ImageIcon DELETE_ICON;
	private static final ImageIcon DELETE_HOVER_ICON;

	private static final ImageIcon COLLAPSE_ICON;
	private static final ImageIcon COLLAPSE_HOVER_ICON;
	private static final ImageIcon EXPAND_ICON;
	private static final ImageIcon EXPAND_HOVER_ICON;

	private final LineMarkerPlugin plugin;
	private final LineGroup marker;

	private final JLabel visibilityMarker = new JLabel();
	private final JLabel deleteMarker = new JLabel();
	private final JButton expandToggle;
	private final JPanel markerContainer = new JPanel();

	private final FlatTextField nameInput = new FlatTextField();
	private final JLabel save = new JLabel("Save");
	private final JLabel cancel = new JLabel("Cancel");
	private final JLabel rename = new JLabel("Rename");

	static
	{
		final BufferedImage borderImg = ImageUtil.loadImageResource(LineMarkerPlugin.class, "settings_icon.png");
		final BufferedImage borderImgHover = ImageUtil.luminanceOffset(borderImg, -150);
		SETTINGS_ICON = new ImageIcon(borderImg);
		SETTINGS_HOVER_ICON = new ImageIcon(borderImgHover);

		NO_SETTINGS_ICON = new ImageIcon(borderImgHover);
		NO_SETTINGS_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(borderImgHover, -100));

		final BufferedImage visibleImg = ImageUtil.loadImageResource(LineMarkerPlugin.class, "visible_icon.png");
		VISIBLE_ICON = new ImageIcon(visibleImg);
		VISIBLE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(visibleImg, -100));

		final BufferedImage invisibleImg = ImageUtil.loadImageResource(LineMarkerPlugin.class, "invisible_icon.png");
		INVISIBLE_ICON = new ImageIcon(invisibleImg);
		INVISIBLE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(invisibleImg, -100));

		final BufferedImage deleteImg = ImageUtil.loadImageResource(LineMarkerPlugin.class, "delete_icon.png");
		DELETE_ICON = new ImageIcon(deleteImg);
		DELETE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(deleteImg, -100));

		BufferedImage retractIcon = ImageUtil.loadImageResource(LineMarkerPlugin.class, "arrow_right.png");
		retractIcon = ImageUtil.luminanceOffset(retractIcon, -121);
		EXPAND_ICON = new ImageIcon(retractIcon);
		EXPAND_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(retractIcon, -100));
		final BufferedImage expandIcon = ImageUtil.rotateImage(retractIcon, Math.PI / 2);
		COLLAPSE_ICON = new ImageIcon(expandIcon);
		COLLAPSE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(expandIcon, -100));
	}

	LineMarkerPanel(LineMarkerPlugin plugin, LineGroup marker)
	{
		this.plugin = plugin;
		this.marker = marker;

		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARKER_GRAY_COLOR);
		setBorder(new EmptyBorder(0, 0, 0, 0));

		JPanel nameWrapper = new JPanel(new BorderLayout());
		nameWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		nameWrapper.setBorder(NAME_BOTTOM_BORDER);

		JPanel nameActions = new JPanel(new FlowLayout(FlowLayout.RIGHT, 3, 3));
		nameActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		save.setVisible(false);
		save.setFont(FontManager.getRunescapeSmallFont());
		save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
		save.setBorder(new EmptyBorder(3, 0, 0, 3));
		save.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				save();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR.darker());
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
			}
		});

		cancel.setVisible(false);
		cancel.setFont(FontManager.getRunescapeSmallFont());
		cancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
		cancel.setBorder(new EmptyBorder(3, 0, 0, 3));
		cancel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				cancel();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				cancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR.darker());
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				cancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
			}
		});

		rename.setFont(FontManager.getRunescapeSmallFont());
		rename.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
		rename.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				nameInput.setEditable(true);
				updateNameActions(true);
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				rename.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker().darker());
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				rename.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
			}
		});

		nameInput.setText(marker.getName());
		nameInput.setBorder(null);
		nameInput.setEditable(false);
		nameInput.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		nameInput.setPreferredSize(new Dimension(0, 24));
		nameInput.getTextField().setForeground(Color.WHITE);
		nameInput.getTextField().setBorder(new EmptyBorder(0, 5, 0, 0));
		nameInput.addKeyListener(new KeyAdapter()
		{
			@Override
			public void keyPressed(KeyEvent e)
			{
				if (e.getKeyCode() == KeyEvent.VK_ENTER)
				{
					save();
				}
				else if (e.getKeyCode() == KeyEvent.VK_ESCAPE)
				{
					cancel();
				}
			}
		});
		nameInput.getTextField().addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				if (e.getClickCount() == 2 && e.getButton() == MouseEvent.BUTTON1)
				{
					marker.setCollapsed(!marker.isCollapsed());
					updateCollapsed();
					plugin.saveMarkers();
				}
			}
		});

		expandToggle = new JButton(marker.isCollapsed() ? COLLAPSE_ICON : EXPAND_ICON);
		expandToggle.setRolloverIcon(marker.isCollapsed() ? COLLAPSE_HOVER_ICON : EXPAND_HOVER_ICON);
		expandToggle.setPreferredSize(new Dimension(15, 0));
		expandToggle.setBorder(new EmptyBorder(0, 6, 1, 0));
		expandToggle.setToolTipText((marker.isCollapsed() ? "Expand" : "Collapse") + " marker");
		SwingUtil.removeButtonDecorations(expandToggle);
		expandToggle.addActionListener(actionEvent ->
		{
			marker.setCollapsed(!marker.isCollapsed());
			updateCollapsed();
			plugin.saveMarkers();
		});

		visibilityMarker.setIcon(marker.isVisible() ? VISIBLE_ICON : INVISIBLE_ICON);
		visibilityMarker.setToolTipText((marker.isVisible() ? "Hide" : "Show") + " marker");
		visibilityMarker.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				marker.setVisible(!marker.isVisible());
				visibilityMarker.setIcon(marker.isVisible() ? VISIBLE_ICON : INVISIBLE_ICON);
				plugin.saveMarkers();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				visibilityMarker.setIcon(marker.isVisible() ? VISIBLE_HOVER_ICON : INVISIBLE_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				visibilityMarker.setIcon(marker.isVisible() ? VISIBLE_ICON : INVISIBLE_ICON);
			}
		});

		deleteMarker.setIcon(DELETE_ICON);
		deleteMarker.setToolTipText("Delete marker");
		deleteMarker.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				int confirm = JOptionPane.showConfirmDialog(LineMarkerPanel.this,
					"Are you sure you want to permanently delete this line marker?",
					"Warning", JOptionPane.OK_CANCEL_OPTION);

				if (confirm == 0)
				{
					plugin.removeMarker(marker);
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				deleteMarker.setIcon(DELETE_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				deleteMarker.setIcon(DELETE_ICON);
			}
		});

		nameActions.add(rename);
		nameActions.add(cancel);
		nameActions.add(save);
		nameActions.add(visibilityMarker);
		nameActions.add(deleteMarker);

		nameWrapper.add(expandToggle, BorderLayout.WEST);
		nameWrapper.add(nameInput, BorderLayout.CENTER);
		nameWrapper.add(nameActions, BorderLayout.EAST);

		markerContainer.setLayout(new BoxLayout(markerContainer, BoxLayout.Y_AXIS));
		markerContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		markerContainer.add(nameWrapper);

		for (Line line : marker.getLines())
		{
			JPanel container = new JPanel(new BorderLayout());
			container.setBorder(new EmptyBorder(5, 0, 5, 0));
			container.setBackground(ColorScheme.DARKER_GRAY_COLOR);

			JPanel leftActions = new JPanel(new FlowLayout(FlowLayout.LEFT, 8, 0));
			leftActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);

			JPanel rightActions = new JPanel(new FlowLayout(FlowLayout.RIGHT, 8, 0));
			rightActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);

			JLabel colour = new JLabel();
			colour.setToolTipText("Edit line colour");
			colour.setForeground(line.getColour() == null ? plugin.defaultColour : line.getColour());
			colour.setBorder(line.getWidth() == 0 ? null : new MatteBorder(0, 0, 3, 0, line.getColour()));
			colour.setIcon(line.getWidth() == 0 ? NO_SETTINGS_ICON : SETTINGS_ICON);
			colour.addMouseListener(new MouseAdapter()
			{
				@Override
				public void mousePressed(MouseEvent mouseEvent)
				{
					RuneliteColorPicker colourPicker = getColourPicker(line.getColour() == null ? plugin.defaultColour : line.getColour());
					colourPicker.setOnColorChange(c ->
					{
						line.setColour(c);
						colour.setBorder(line.getWidth() == 0 ? null : new MatteBorder(0, 0, 3, 0, line.getColour()));
						colour.setIcon(line.getWidth() == 0 ? NO_SETTINGS_ICON : SETTINGS_ICON);
					});
					colourPicker.setVisible(true);
				}

				@Override
				public void mouseEntered(MouseEvent mouseEvent)
				{
					colour.setIcon(line.getWidth() == 0 ? NO_SETTINGS_HOVER_ICON : SETTINGS_HOVER_ICON);
				}

				@Override
				public void mouseExited(MouseEvent mouseEvent)
				{
					colour.setIcon(line.getWidth() == 0 ? NO_SETTINGS_ICON : SETTINGS_ICON);
				}
			});

			JButton edge = new JButton();
			edge.setPreferredSize(new Dimension(50, 24));
			edge.setBorder(new EmptyBorder(0, 0, 0, 0));
			edge.setText(line.getEdge().toString());
			edge.setToolTipText("Line edge");
			edge.setFont(FontManager.getRunescapeSmallFont());
			edge.addMouseListener(new MouseAdapter()
			{
				@Override
				public void mousePressed(MouseEvent mouseEvent)
				{
					line.setEdge(line.getEdge().next());
					edge.setText(line.getEdge().toString());
					plugin.saveMarkers();
				}

				@Override
				public void mouseEntered(MouseEvent mouseEvent)
				{
					edge.setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
				}

				@Override
				public void mouseExited(MouseEvent mouseEvent)
				{
					edge.setBackground(ColorScheme.DARK_GRAY_COLOR);
				}
			});

			JSpinner width = new JSpinner(new SpinnerNumberModel(3.0, 0, 10, 0.1));
			width.setValue(line.getWidth());
			width.setToolTipText("Line width");
			width.setPreferredSize(new Dimension(53, 20));
			width.addChangeListener(ce ->
			{
				line.setWidth((double) width.getValue());
				plugin.saveMarkers();
			});

			List<LineGroup> groups = plugin.getGroups();
			String[] names = new String[groups.size()];
			for (int i = 0; i < groups.size(); i++)
			{
				names[i] = groups.get(i).getName();
			}

			JLabel groupButton = new JLabel();
			JLabel deleteLine = new JLabel();
			JLabel groupText = new JLabel("Group:");
			JComboBox<String> groupSelection = new JComboBox<>(names);

			groupText.setFont(FontManager.getRunescapeSmallFont());
			groupText.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
			groupText.setVisible(false);

			JLabel groupCancel = new JLabel("Cancel");
			groupCancel.setVisible(false);
			groupCancel.setFont(FontManager.getRunescapeSmallFont());
			groupCancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
			groupCancel.setBorder(new EmptyBorder(6, 0, 0, 1));
			groupCancel.addMouseListener(new MouseAdapter()
			{
				@Override
				public void mousePressed(MouseEvent mouseEvent)
				{
					groupText.setVisible(false);
					groupSelection.setVisible(false);
					groupCancel.setVisible(false);

					colour.setVisible(true);
					edge.setVisible(true);
					width.setVisible(true);
					groupButton.setVisible(true);
					deleteLine.setVisible(true);
				}

				@Override
				public void mouseEntered(MouseEvent mouseEvent)
				{
					groupCancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR.darker());
				}

				@Override
				public void mouseExited(MouseEvent mouseEvent)
				{
					groupCancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
				}
			});

			groupSelection.setVisible(false);
			groupSelection.setRenderer(new TitleCaseListCellRenderer());
			groupSelection.setPreferredSize(new Dimension(115, 24));
			groupSelection.setSelectedIndex(groups.indexOf(marker));
			groupSelection.setToolTipText("Marker group");
			groupSelection.addActionListener(e ->
			{
				marker.getLines().remove(line);
				groups.get(groupSelection.getSelectedIndex()).getLines().add(line);
				if (marker.getLines().isEmpty())
				{
					groups.remove(marker);
				}

				groupText.setVisible(false);
				groupSelection.setVisible(false);
				groupCancel.setVisible(false);

				colour.setVisible(true);
				edge.setVisible(true);
				width.setVisible(true);
				groupButton.setVisible(true);
				deleteLine.setVisible(true);

				plugin.saveMarkers();
				plugin.rebuild();
			});

			groupButton.setIcon(SETTINGS_ICON);
			groupButton.setToolTipText("Edit group");
			groupButton.setBorder(new EmptyBorder(1, 0, 0, 0));
			groupButton.addMouseListener(new MouseAdapter()
			{
				@Override
				public void mousePressed(MouseEvent mouseEvent)
				{
					ActionListener actionListener = groupSelection.getActionListeners()[0];
					groupSelection.removeActionListener(actionListener);
					groupSelection.removeAllItems();
					for (LineGroup group : plugin.getGroups())
					{
						groupSelection.addItem(group.getName());
					}
					groupSelection.setSelectedIndex(plugin.getGroups().indexOf(marker));
					groupSelection.addActionListener(actionListener);

					colour.setVisible(false);
					edge.setVisible(false);
					width.setVisible(false);
					groupButton.setVisible(false);
					deleteLine.setVisible(false);

					groupText.setVisible(true);
					groupSelection.setVisible(true);
					groupCancel.setVisible(true);
				}

				@Override
				public void mouseEntered(MouseEvent mouseEvent)
				{
					groupButton.setIcon(SETTINGS_HOVER_ICON);
				}

				@Override
				public void mouseExited(MouseEvent mouseEvent)
				{
					groupButton.setIcon(SETTINGS_ICON);
				}
			});

			deleteLine.setIcon(DELETE_ICON);
			deleteLine.setToolTipText("Delete line segment");
			deleteLine.setBorder(new EmptyBorder(1, 0, 0, 0));
			deleteLine.addMouseListener(new MouseAdapter()
			{
				@Override
				public void mousePressed(MouseEvent mouseEvent)
				{
					int confirm = JOptionPane.showConfirmDialog(LineMarkerPanel.this,
						"Are you sure you want to permanently delete this line segment?",
						"Warning", JOptionPane.OK_CANCEL_OPTION);

					if (confirm == 0)
					{
						plugin.removeMarker(line);
					}
				}

				@Override
				public void mouseEntered(MouseEvent mouseEvent)
				{
					deleteLine.setIcon(DELETE_HOVER_ICON);
				}

				@Override
				public void mouseExited(MouseEvent mouseEvent)
				{
					deleteLine.setIcon(DELETE_ICON);
				}
			});

			leftActions.add(colour);
			leftActions.add(edge);
			leftActions.add(width);
			leftActions.add(groupText);
			leftActions.add(groupSelection);

			rightActions.add(groupButton);
			rightActions.add(groupCancel);
			rightActions.add(deleteLine);

			container.add(leftActions, BorderLayout.WEST);
			container.add(rightActions, BorderLayout.EAST);

			markerContainer.add(container);
		}

		add(markerContainer);

		updateCollapsed();
	}

	private void save()
	{
		String newName = nameInput.getText();

		if (newName.equals(marker.getName()))
		{
			cancel();
			return;
		}

		LineGroup newGroup = null;
		for (LineGroup group : plugin.getGroups())
		{
			if (newName.equals(group.getName()) && !group.equals(marker))
			{
				newGroup = group;
				break;
			}
		}

		if (newGroup != null)
		{
			int confirm = JOptionPane.showConfirmDialog(LineMarkerPanel.this,
				"Are you sure you want to combine this line marker with the other line marker with the same name?",
				"Warning", JOptionPane.OK_CANCEL_OPTION);

			if (confirm == 0)
			{
				for (Line line : marker.getLines())
				{
					newGroup.getLines().add(line);
				}
				plugin.removeMarker(marker);
			}
			else
			{
				return;
			}
		}
		else
		{
			marker.setName(newName);
			plugin.saveMarkers();
		}

		nameInput.setEditable(false);
		updateNameActions(false);
		requestFocusInWindow();
	}

	private void cancel()
	{
		nameInput.setEditable(false);
		nameInput.setText(marker.getName());
		updateNameActions(false);
		requestFocusInWindow();
	}

	private void updateNameActions(boolean saveAndCancel)
	{
		save.setVisible(saveAndCancel);
		cancel.setVisible(saveAndCancel);
		rename.setVisible(!saveAndCancel);
		expandToggle.setVisible(!saveAndCancel);
		visibilityMarker.setVisible(!saveAndCancel);
		deleteMarker.setVisible(!saveAndCancel);

		if (saveAndCancel)
		{
			nameInput.getTextField().requestFocusInWindow();
			nameInput.getTextField().selectAll();
		}
	}

	private void updateCollapsed()
	{
		final boolean open = !marker.isCollapsed();

		rename.setVisible(open);

		for (int i = 1; i < markerContainer.getComponentCount(); i++)
		{
			markerContainer.getComponent(i).setVisible(open);
		}

		expandToggle.setIcon(open ? COLLAPSE_ICON : EXPAND_ICON);
		expandToggle.setRolloverIcon(open ? COLLAPSE_HOVER_ICON : EXPAND_HOVER_ICON);
		expandToggle.setToolTipText((open ? "Collapse" : "Expand") + " marker");
	}

	private RuneliteColorPicker getColourPicker(Color colour)
	{
		RuneliteColorPicker colourPicker = plugin.getColourPickerManager().create(
			SwingUtilities.windowForComponent(this),
			colour,
			marker.getName() + " line segment colour",
			false);
		colourPicker.setLocationRelativeTo(this);
		colourPicker.setOnClose(c -> plugin.saveMarkers());
		return colourPicker;
	}
}

package com.linemarkers;

import com.google.inject.Inject;
import java.awt.BasicStroke;
import java.awt.Dimension;
import java.awt.Graphics2D;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

class LineMarkerSceneOverlay extends Overlay
{
	private static final int LOCAL_TILE_SIZE = Perspective.LOCAL_TILE_SIZE;
	private static final int MAX_DISTANCE = Perspective.SCENE_SIZE / 4;

	private final Client client;
	private final LineMarkerPlugin plugin;

	@Inject
	private LineMarkerSceneOverlay(Client client, LineMarkerPlugin plugin)
	{
		this.client = client;
		this.plugin = plugin;

		setPosition(OverlayPosition.DYNAMIC);
		setPriority(Overlay.PRIORITY_LOW);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		for (final LineGroup group : plugin.getMarkers())
		{
			if (!group.isVisible())
			{
				continue;
			}

			for (final Line line : group.getLines())
			{
				if (line.getLocation().getPlane() != client.getPlane())
				{
					continue;
				}

				drawLine(graphics, line);
			}
		}

		return null;
	}

	private void drawLine(Graphics2D graphics, Line line)
	{
		if (client.getLocalPlayer() == null || client.getLocalPlayer().getWorldLocation().distanceTo(line.getLocation()) > MAX_DISTANCE)
		{
			return;
		}

		final Point start = worldToScene(Edge.start(line));
		final Point end = worldToScene(Edge.end(line));

		if (start == null || end == null)
		{
			return;
		}

		graphics.setColor(line.getColour());
		graphics.setStroke(new BasicStroke((float) line.getWidth()));
		graphics.drawLine(start.getX(), start.getY(), end.getX(), end.getY());
	}

	private Point worldToScene(WorldPoint location)
	{
		LocalPoint localPoint = LocalPoint.fromWorld(client, location);

		if (localPoint == null)
		{
			return null;
		}

		return Perspective.localToCanvas(
			client,
			new LocalPoint(localPoint.getX() - LOCAL_TILE_SIZE / 2, localPoint.getY() - LOCAL_TILE_SIZE / 2),
			location.getPlane());
	}
}

package com.linemarkers;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.Setter;
import net.runelite.api.Client;

@Data
@AllArgsConstructor(access = AccessLevel.PRIVATE)
class LineGroup
{
	@Setter(AccessLevel.NONE)
	long id;
	String name;
	boolean visible;
	boolean collapsed;
	@Setter(AccessLevel.NONE)
	List<Line> lines;

	LineGroup(String name, Line line)
	{
		this(System.currentTimeMillis(), name, true, false, new ArrayList<>(Arrays.asList(line)));
	}

	public static List<LineGroup> instances(Client client, List<LineGroup> groups)
	{
		List<LineGroup> markers = new ArrayList<>();

		for (LineGroup group : groups)
		{
			List<Line> lines = new ArrayList<>(group.getLines());
			for (Line line : group.getLines())
			{
				lines.addAll(Line.instances(client, line));
			}
			markers.add(new LineGroup(group.id, group.name, group.visible, group.collapsed, lines));
		}

		return markers;
	}

	public static boolean isInvalid(LineGroup group)
	{
		return group == null || group.id <= 0 || group.name == null || group.lines == null;
	}

	@Override
	public String toString()
	{
		return name;
	}
}

package com.linemarkers;

enum Filter
{
	ALL,
	REGION,
	VISIBLE,
	INVISIBLE;

	private static final Filter[] FILTERS = values();

	public Filter next()
	{
		return FILTERS[(this.ordinal() + 1) % FILTERS.length];
	}
}

package com.linemarkers;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Toolkit;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.Comparator;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.client.util.ImageUtil;

class LineMarkerPluginPanel extends PluginPanel
{
	private static final ImageIcon COPY_ICON;
	private static final ImageIcon COPY_HOVER_ICON;
	private static final ImageIcon PASTE_ICON;
	private static final ImageIcon PASTE_HOVER_ICON;

	private static final ImageIcon[] FILTER_ICONS;
	private static final String[] FILTER_TEXT = {"ALL", "R", "", ""};
	private static final String[] FILTER_DESCRIPTIONS;

	private final JLabel copyMarkers = new JLabel(COPY_ICON);
	private final JLabel pasteMarkers = new JLabel(PASTE_ICON);
	private final JLabel filterButton = new JLabel(FILTER_ICONS[0]);
	private final IconTextField searchBar = new IconTextField();
	private final PluginErrorPanel noMarkersPanel = new PluginErrorPanel();
	private final JPanel markerView = new JPanel();
	private final JPanel searchPanel = new JPanel(new BorderLayout());

	private final Client client;
	private final LineMarkerPlugin plugin;

	@Getter
	private Filter filter = Filter.ALL;

	static
	{
		final BufferedImage copyIcon = ImageUtil.loadImageResource(LineMarkerPlugin.class, "copy_icon.png");
		COPY_ICON = new ImageIcon(copyIcon);
		COPY_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(copyIcon, 0.53f));

		final BufferedImage pasteIcon = ImageUtil.loadImageResource(LineMarkerPlugin.class, "paste_icon.png");
		PASTE_ICON = new ImageIcon(pasteIcon);
		PASTE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(pasteIcon, 0.53f));

		final BufferedImage visibleImg = ImageUtil.loadImageResource(LineMarkerPlugin.class, "visible_icon.png");
		final BufferedImage invisibleImg = ImageUtil.loadImageResource(LineMarkerPlugin.class, "invisible_icon.png");
		final BufferedImage regionIcon = ImageUtil.loadImageResource(LineMarkerPlugin.class, "region_icon.png");

		FILTER_ICONS = new ImageIcon[]
		{
			new ImageIcon(ImageUtil.alphaOffset(visibleImg, 0.0f)),
			new ImageIcon(regionIcon),
			new ImageIcon(visibleImg),
			new ImageIcon(invisibleImg)
		};

		FILTER_DESCRIPTIONS = new String[]
		{
			"<html>Filter:<br>Listing all markers</html>",
			"<html>Filter:<br>Listing only markers in the current region</html>",
			"<html>Filter:<br>Listing only visible markers</html>",
			"<html>Filter:<br>Listing only hidden markers</html>"
		};
	}

	public LineMarkerPluginPanel(Client client, LineMarkerPlugin plugin)
	{
		this.client = client;
		this.plugin = plugin;

		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(10, 10, 10, 10));

		JPanel northPanel = new JPanel(new BorderLayout());
		northPanel.setBorder(new EmptyBorder(1, 0, 10, 0));

		JPanel titlePanel = new JPanel(new BorderLayout());
		titlePanel.setBorder(new EmptyBorder(1, 3, 10, 7));

		JPanel markerButtons = new JPanel(new FlowLayout(FlowLayout.RIGHT, 7, 3));

		searchPanel.setBorder(new EmptyBorder(1, 0, 0, 0));

		searchBar.setIcon(IconTextField.Icon.SEARCH);
		searchBar.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		searchBar.setHoverBackgroundColor(ColorScheme.DARKER_GRAY_HOVER_COLOR);
		searchBar.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 43 - filterButton.getWidth(), 24));
		searchBar.addActionListener(e -> rebuild());
		searchBar.addClearListener(this::rebuild);
		searchBar.addKeyListener(new KeyAdapter()
		{
			@Override
			public void keyPressed(KeyEvent e)
			{
				if (e.getKeyCode() == KeyEvent.VK_ESCAPE)
				{
					searchBar.setText("");
					rebuild();
				}
			}
		});

		filterButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		filterButton.setOpaque(true);
		filterButton.setPreferredSize(new Dimension(28, 24));
		filterButton.setText(FILTER_TEXT[0]);
		filterButton.setToolTipText(FILTER_DESCRIPTIONS[0]);
		filterButton.setHorizontalTextPosition(JLabel.CENTER);
		filterButton.setFont(FontManager.getRunescapeSmallFont());
		filterButton.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				filter = filter.next();
				filterButton.setText(FILTER_TEXT[filter.ordinal()]);
				filterButton.setIcon(FILTER_ICONS[filter.ordinal()]);
				filterButton.setToolTipText(FILTER_DESCRIPTIONS[filter.ordinal()]);
				rebuild();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				filterButton.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				filterButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			}
		});

		JLabel title = new JLabel();
		title.setText("Line Markers");
		title.setForeground(Color.WHITE);

		titlePanel.add(title, BorderLayout.WEST);
		titlePanel.add(markerButtons, BorderLayout.EAST);

		searchPanel.add(searchBar, BorderLayout.WEST);
		searchPanel.add(filterButton, BorderLayout.EAST);

		northPanel.add(titlePanel, BorderLayout.NORTH);
		northPanel.add(searchPanel, BorderLayout.CENTER);

		JPanel centerPanel = new JPanel(new BorderLayout());
		centerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		markerView.setLayout(new BoxLayout(markerView, BoxLayout.Y_AXIS));
		markerView.setBackground(ColorScheme.DARK_GRAY_COLOR);

		noMarkersPanel.setVisible(false);

		markerView.add(noMarkersPanel);

		copyMarkers.setToolTipText("Export all searched or filtered markers to your clipboard");
		copyMarkers.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				copyMarkers();
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				copyMarkers.setIcon(COPY_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				copyMarkers.setIcon(COPY_ICON);
			}
		});

		pasteMarkers.setToolTipText("Import markers from your clipboard");
		pasteMarkers.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				pasteMarkers();
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				pasteMarkers.setIcon(PASTE_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				pasteMarkers.setIcon(PASTE_ICON);
			}
		});

		markerButtons.add(pasteMarkers);
		markerButtons.add(copyMarkers);

		centerPanel.add(markerView, BorderLayout.NORTH);

		add(northPanel, BorderLayout.NORTH);
		add(centerPanel, BorderLayout.CENTER);
	}

	public void rebuild()
	{
		markerView.removeAll();

		int regionId = client.getLocalPlayer() == null ? -1 : client.getLocalPlayer().getWorldLocation().getRegionID();

		plugin.getGroups().sort(Comparator.comparing(LineGroup::getName));
		for (final LineGroup group : plugin.getGroups())
		{
			if (group.getName().toLowerCase().contains(getSearchText().toLowerCase()) &&
				(Filter.ALL.equals(filter) ||
				(Filter.REGION.equals(filter) && plugin.anyLineInRegion(group.getLines(), regionId)) ||
				(Filter.VISIBLE.equals(filter) && group.isVisible()) ||
				(Filter.INVISIBLE.equals(filter) && !group.isVisible())))
			{
				markerView.add(new LineMarkerPanel(plugin, group));
				markerView.add(Box.createRigidArea(new Dimension(0, 10)));
			}
		}

		boolean empty = markerView.getComponentCount() == 0;
		noMarkersPanel.setContent("Line Markers", "Shift right-click a tile to add a line marker.");
		noMarkersPanel.setVisible(empty);
		searchPanel.setVisible(!empty);
		if (empty && plugin.getGroups().size() > 0)
		{
			noMarkersPanel.setContent("Line Markers",
				"No line markers are available for the current search term and/or selected filter.");
			searchPanel.setVisible(true);
		}

		markerView.add(noMarkersPanel);

		repaint();
		revalidate();
	}

	public String getSearchText()
	{
		return searchBar.getText();
	}

	private void copyMarkers()
	{
		if (plugin.copyMarkers() != null)
		{
			Toolkit.getDefaultToolkit().getSystemClipboard().setContents(new StringSelection(plugin.copyMarkers()), null);
		}
	}

	private void pasteMarkers()
	{
		final String clipboardText;
		try
		{
			clipboardText = Toolkit.getDefaultToolkit().getSystemClipboard().getData(DataFlavor.stringFlavor).toString();
		}
		catch (IOException | UnsupportedFlavorException ignore)
		{
			return;
		}

		if (plugin.pasteMarkers(clipboardText))
		{
			noMarkersPanel.setVisible(false);
			searchPanel.setVisible(true);
			rebuild();
		}
	}
}

package com.linemarkers;

import java.awt.Color;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;

@ConfigGroup(LineMarkerPlugin.CONFIG_GROUP)
public interface LineMarkerConfig extends Config
{
	@ConfigSection(
		name = "Default values",
		description = "Customize the marker range parameters to be displayed in the panel",
		position = 0
	)
	String defaultValues = "defaultValues";

	@Alpha
	@ConfigItem(
		keyName = "defaultColour",
		name = "Colour",
		description = "The default initial line colour when making a new line",
		position = 1,
		section = defaultValues
	)
	default Color defaultColour()
	{
		return Color.YELLOW;
	}

	@ConfigItem(
		keyName = "defaultEdge",
		name = "Edge",
		description = "The default initial line edge when making a new line",
		position = 2,
		section = defaultValues
	)
	default Edge defaultEdge()
	{
		return Edge.WEST;
	}

	@Range(
		max = 10
	)
	@ConfigItem(
		keyName = "defaultWidth",
		name = "Width",
		description = "The default initial line width when making a new line",
		position = 3,
		section = defaultValues
	)
	default double defaultWidth()
	{
		return 3.0;
	}

	@ConfigItem(
		keyName = "showMinimap",
		name = "Show on minimap",
		description = "Display line markers on the minimap",
		position = 4
	)
	default boolean showMinimap()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showWorldMap",
		name = "Show on world map",
		description = "Display line markers on the world map",
		position = 5
	)
	default boolean showWorldMap()
	{
		return true;
	}

	@ConfigItem(
		keyName = "hideNavButton",
		name = "Hide side panel button",
		description = "Whether to hide the side panel button to reduce clutter when not needing to modify markers",
		position = 6
	)
	default boolean hideNavButton()
	{
		return false;
	}
}

package com.linemarkers;

import java.awt.Color;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.coords.WorldPoint;

@Getter
@Setter
@EqualsAndHashCode
@AllArgsConstructor(access = AccessLevel.PRIVATE)
class Line
{
	Color colour;
	Edge edge;
	double width;
	@Setter(AccessLevel.NONE)
	WorldPoint location;

	Line(LineMarkerPlugin plugin, WorldPoint location)
	{
		this(plugin.defaultColour, plugin.defaultEdge, plugin.defaultWidth, location);
	}

	public static List<Line> instances(Client client, Line line)
	{
		if (!GameState.LOGGED_IN.equals(client.getGameState()))
		{
			List<Line> lines = new ArrayList<>();
			lines.add(line);
			return lines;
		}
		return WorldPoint.toLocalInstance(client, line.location).stream().filter(Objects::nonNull).map(wp ->
			new Line(line.colour, line.edge, line.width, wp)).collect(Collectors.toList());
	}
}

package com.linemarkers;

import com.google.inject.Inject;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.geom.Area;
import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.worldmap.WorldMapOverlay;

class LineMarkerMapOverlay extends Overlay
{
	private final Client client;
	private final LineMarkerPlugin plugin;

	@Inject
	private WorldMapOverlay worldMapOverlay;

	@Inject
	LineMarkerMapOverlay(Client client, LineMarkerPlugin plugin)
	{
		this.client = client;
		this.plugin = plugin;

		setPosition(OverlayPosition.DYNAMIC);
		setPriority(Overlay.PRIORITY_LOW);
		setLayer(OverlayLayer.MANUAL);
		drawAfterLayer(ComponentID.WORLD_MAP_MAPVIEW);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (plugin.showWorldMap)
		{
			drawWorldMap(graphics);
		}
		return null;
	}

	private void drawWorldMap(Graphics2D graphics)
	{
		final Widget worldMapView = client.getWidget(ComponentID.WORLD_MAP_MAPVIEW);
		if (worldMapView == null)
		{
			return;
		}

		final Rectangle bounds = worldMapView.getBounds();
		if (bounds == null)
		{
			return;
		}

		graphics.setClip(getWorldMapClipArea(bounds));

		for (final LineGroup group : plugin.getMarkers())
		{
			if (!group.isVisible())
			{
				continue;
			}

			for (final Line line : group.getLines())
			{
				drawLine(graphics, line);
			}
		}
	}

	private void drawLine(Graphics2D graphics, Line line)
	{
		final Point start = worldMapOverlay.mapWorldPointToGraphicsPoint(Edge.start(line));
		final Point end = worldMapOverlay.mapWorldPointToGraphicsPoint(Edge.end(line));
		final Point delta = worldMapOverlay.mapWorldPointToGraphicsPoint(Edge.start(line).dx(1));

		if (start == null || end == null || delta == null)
		{
			return;
		}

		final int offset = (delta.getX() - start.getX()) / 2;
		final int x1 = start.getX() - offset;
		final int y1 = start.getY() + offset;
		final int x2 = end.getX() - offset;
		final int y2 = end.getY() + offset;

		graphics.setColor(line.getColour());
		graphics.drawLine(x1, y1, x2, y2);
	}

	private Area getWorldMapClipArea(Rectangle baseRectangle)
	{
		final Widget overview = client.getWidget(ComponentID.WORLD_MAP_OVERVIEW_MAP);
		final Widget surfaceSelector = client.getWidget(ComponentID.WORLD_MAP_SURFACE_SELECTOR);

		Area clipArea = new Area(baseRectangle);

		if (overview != null && !overview.isHidden())
		{
			clipArea.subtract(new Area(overview.getBounds()));
		}
		if (surfaceSelector != null && !surfaceSelector.isHidden())
		{
			clipArea.subtract(new Area(surfaceSelector.getBounds()));
		}

		return clipArea;
	}
}

package com.linemarkers;

import com.google.common.base.Strings;
import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Inject;
import com.google.inject.Provides;
import java.awt.Color;
import java.awt.Point;
import java.awt.Polygon;
import java.awt.Rectangle;
import java.awt.Shape;
import java.awt.event.KeyEvent;
import java.awt.geom.Ellipse2D;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.KeyCode;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.SpriteID;
import net.runelite.api.Tile;
import net.runelite.api.Varbits;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.FocusChanged;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;
import net.runelite.client.input.MouseManager;
import net.runelite.client.input.MouseWheelListener;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;

@PluginDescriptor(
	name = "Line Markers",
	description = "Draw lines on tiles",
	tags = {"line", "tile", "edge", "ground", "marker"}
)
public class LineMarkerPlugin extends Plugin
{
	public static final String CONFIG_GROUP = "linemarkers";
	private static final String CONFIG_KEY = "markers";
	private static final String PLUGIN_NAME = "Line Markers";
	private static final String ICON_FILE = "panel_icon.png";
	private static final String DEFAULT_MARKER_NAME = "Marker";
	private static final String ADD_LINE = "Add line";
	private static final String REMOVE_LINE = "Remove line";

	@Getter(AccessLevel.PACKAGE)
	private List<LineGroup> groups = new ArrayList<>();

	/**
	 * 'markers' is a mirror of 'groups' with additional copies of LineGroups for all instances
	 */
	@Getter(AccessLevel.PACKAGE)
	private List<LineGroup> markers = new ArrayList<>();

	@Inject
	private Client client;

	@Inject
	private LineMarkerConfig config;

	@Inject
	private LineMarkerMapOverlay mapOverlay;

	@Inject
	private LineMarkerSceneOverlay sceneOverlay;

	@Inject
	private LineMarkerMinimapOverlay minimapOverlay;

	@Inject
	private ConfigManager configManager;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private Gson gson;

	@Inject
	private SpriteManager spriteManager;

	@Inject
	private KeyManager keyManager;

	@Inject
	private MouseManager mouseManager;

	@Getter
	@Inject
	private ColorPickerManager colourPickerManager;

	Color defaultColour = null;
	Edge defaultEdge = null;
	double defaultWidth;
	boolean showMinimap;
	boolean showWorldMap;
	boolean hideNavButton;

	private LineMarkerPluginPanel pluginPanel;
	private NavigationButton navigationButton;
	private BufferedImage minimapSpriteFixed;
	private BufferedImage minimapSpriteResizeable;
	private Shape minimapClipFixed;
	private Shape minimapClipResizeable;
	private Rectangle minimapRectangle = new Rectangle();
	private LineGroup lastGroup = null;
	private Line lastLine = null;
	private boolean isHotkeyPressed = false;

	private KeyListener keyListener = new KeyListener()
	{
		@Override
		public void keyTyped(KeyEvent e)
		{
		}

		@Override
		public void keyPressed(KeyEvent e)
		{
			if (e.getKeyCode() == KeyEvent.VK_SHIFT)
			{
				hotkeyPressed();
			}
		}

		@Override
		public void keyReleased(KeyEvent e)
		{
			if (e.getKeyCode() == KeyEvent.VK_SHIFT)
			{
				hotkeyReleased();
			}
		}
	};

	private void hotkeyPressed()
	{
		isHotkeyPressed = true;
	}

	private void hotkeyReleased()
	{
		lastLine = null;
		lastGroup = null;
		isHotkeyPressed = false;
	}

	private MouseWheelListener mouseWheelListener = event ->
	{
		if (isHotkeyPressed && lastLine != null)
		{
			if (event.getWheelRotation() > 0)
			{
				lastLine.setEdge(lastLine.getEdge().next());
			}
			else
			{
				lastLine.setEdge(lastLine.getEdge().next().next().next());
			}

			event.consume();
			saveMarkers();
			revalidate();
		}
		return event;
	};

	@Provides
	LineMarkerConfig providesConfig(ConfigManager configManager)
	{
		return configManager.getConfig(LineMarkerConfig.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		cacheConfig();

		keyManager.registerKeyListener(keyListener);
		mouseManager.registerMouseWheelListener(mouseWheelListener);

		overlayManager.add(mapOverlay);
		overlayManager.add(sceneOverlay);
		overlayManager.add(minimapOverlay);

		loadMarkers();

		pluginPanel = new LineMarkerPluginPanel(client, this);
		pluginPanel.rebuild();

		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), ICON_FILE);

		navigationButton = NavigationButton.builder()
			.tooltip(PLUGIN_NAME)
			.icon(icon)
			.priority(5)
			.panel(pluginPanel)
			.build();

		if (!hideNavButton)
		{
			clientToolbar.addNavigation(navigationButton);
		}
	}

	@Override
	protected void shutDown() throws Exception
	{
		keyManager.unregisterKeyListener(keyListener);
		mouseManager.unregisterMouseWheelListener(mouseWheelListener);

		overlayManager.remove(mapOverlay);
		overlayManager.remove(sceneOverlay);
		overlayManager.remove(minimapOverlay);

		groups.clear();
		markers.clear();

		clientToolbar.removeNavigation(navigationButton);

		pluginPanel = null;
		navigationButton = null;
	}

	@Subscribe
	public void onConfigChanged(final ConfigChanged event)
	{
		if (!CONFIG_GROUP.equals(event.getGroup()))
		{
			return;
		}

		cacheConfig();

		if ("hideNavButton".equals(event.getKey()))
		{
			if (hideNavButton)
			{
				clientToolbar.removeNavigation(navigationButton);
			}
			else
			{
				clientToolbar.addNavigation(navigationButton);
			}
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		if (!GameState.LOGGED_IN.equals(event.getGameState()) || !client.isInInstancedRegion())
		{
			return;
		}

		mirrorMarkers();
	}

	@Subscribe
	public void onFocusChanged(FocusChanged event)
	{
		if (isHotkeyPressed && !client.isKeyPressed(KeyCode.KC_SHIFT))
		{
			hotkeyReleased();
		}
	}

	@Subscribe
	public void onMenuEntryAdded(final MenuEntryAdded event)
	{
		if (isHotkeyPressed && MenuAction.WALK.getId() == event.getType())
		{
			client.createMenuEntry(1)
				.setOption(ADD_LINE)
				.setTarget(event.getTarget())
				.setParam0(event.getActionParam0())
				.setParam1(event.getActionParam1())
				.setIdentifier(event.getIdentifier())
				.setType(MenuAction.RUNELITE)
				.onClick(this::addMarker);

			Line line = getLineOnTile();
			if (line != null)
			{
				client.createMenuEntry(1)
					.setOption(REMOVE_LINE)
					.setTarget(event.getTarget())
					.setParam0(event.getActionParam0())
					.setParam1(event.getActionParam1())
					.setIdentifier(event.getIdentifier())
					.setType(MenuAction.RUNELITE)
					.onClick(e -> removeMarker(line));
			}
		}
	}

	private void cacheConfig()
	{
		defaultColour = config.defaultColour();
		defaultEdge = config.defaultEdge();
		defaultWidth = config.defaultWidth();
		showMinimap = config.showMinimap();
		showWorldMap = config.showWorldMap();
		hideNavButton = config.hideNavButton();
	}

	private void addMarker(MenuEntry entry)
	{
		Tile tile = client.getSelectedSceneTile();
		if (tile == null)
		{
			return;
		}

		lastLine = new Line(this, WorldPoint.fromLocalInstance(client, tile.getLocalLocation()));

		if (lastGroup == null)
		{
			lastGroup = new LineGroup(DEFAULT_MARKER_NAME + " " + (groups.size() + 1), lastLine);
			groups.add(lastGroup);
		}
		else
		{
			lastGroup.getLines().add(lastLine);
		}

		saveMarkers();
		rebuild();
	}

	private void loadMarkers()
	{
		groups.clear();
		markers.clear();

		String json = configManager.getConfiguration(CONFIG_GROUP, CONFIG_KEY);

		if (Strings.isNullOrEmpty(json))
		{
			return;
		}

		try
		{
			List<LineGroup> loaded = gson.fromJson(json, new TypeToken<ArrayList<LineGroup>>(){}.getType());
			loaded.removeIf(LineGroup::isInvalid);
			groups.addAll(loaded);
			mirrorMarkers();
		}
		catch (IllegalStateException | JsonSyntaxException ignore)
		{
			JOptionPane.showConfirmDialog(pluginPanel,
				"The line markers you are trying to load from your config are malformed",
				"Warning", JOptionPane.OK_CANCEL_OPTION);
		}
	}

	public void saveMarkers()
	{
		if (groups == null || groups.isEmpty())
		{
			configManager.unsetConfiguration(CONFIG_GROUP, CONFIG_KEY);
			return;
		}

		String json = gson.toJson(groups);
		configManager.setConfiguration(CONFIG_GROUP, CONFIG_KEY, json);
		mirrorMarkers();
	}

	private void mirrorMarkers()
	{
		markers = LineGroup.instances(client, groups);
	}

	public String copyMarkers()
	{
		List<LineGroup> markersCopy = new ArrayList<>();

		int regionId = client.getLocalPlayer() == null ? -1 : client.getLocalPlayer().getWorldLocation().getRegionID();
		String searchTerm = pluginPanel.getSearchText().toLowerCase();
		Filter filter = pluginPanel.getFilter();

		for (LineGroup group : groups)
		{
			if (group.getName().toLowerCase().contains(searchTerm) &&
				(Filter.ALL.equals(filter) ||
				(Filter.REGION.equals(filter) && anyLineInRegion(group.getLines(), regionId)) ||
				(Filter.VISIBLE.equals(filter) && group.isVisible()) ||
				(Filter.INVISIBLE.equals(filter) && !group.isVisible())))
			{
				markersCopy.add(group);
			}
		}

		if (markersCopy.isEmpty())
		{
			return null;
		}

		return gson.toJson(markersCopy);
	}

	public boolean pasteMarkers(String json)
	{
		if (Strings.isNullOrEmpty(json))
		{
			return false;
		}

		List<LineGroup> markers;
		try
		{
			markers = gson.fromJson(json, new TypeToken<ArrayList<LineGroup>>(){}.getType());
		}
		catch (IllegalStateException | JsonSyntaxException ignore)
		{
			JOptionPane.showConfirmDialog(pluginPanel,
				"The line markers you are trying to import are malformed",
				"Warning", JOptionPane.OK_CANCEL_OPTION);
			return false;
		}

		markers.removeIf(group -> LineGroup.isInvalid(group) || groups.contains(group));
		groups.addAll(markers);

		saveMarkers();

		return true;
	}

	public boolean anyLineInRegion(List<Line> lines, int regionId)
	{
		for (Line line : lines)
		{
			if (line.getLocation().getRegionID() == regionId)
			{
				return true;
			}
		}
		return false;
	}

	private Line getLineOnTile()
	{
		Tile tile = client.getSelectedSceneTile();
		if (tile == null)
		{
			return null;
		}

		for (LineGroup group : groups)
		{
			for (Line line : group.getLines())
			{
				if (line.getLocation().equals(tile.getWorldLocation()))
				{
					return line;
				}
			}
		}

		return null;
	}

	private Polygon bufferedImageToPolygon(BufferedImage image)
	{
		int outsideColour = -1;
		int previousColour;
		final int width = image.getWidth();
		final int height = image.getHeight();
		List<Point> points = new ArrayList<>();
		for (int y = 0; y < height; y++)
		{
			previousColour = outsideColour;
			for (int x = 0; x < width; x++)
			{
				int colour = image.getRGB(x, y);
				if (x == 0 && y == 0)
				{
					outsideColour = colour;
					previousColour = colour;
				}
				if (colour != outsideColour && previousColour == outsideColour)
				{
					points.add(new Point(x, y));
				}
				if ((colour == outsideColour || x == (width - 1)) && previousColour != outsideColour)
				{
					points.add(0, new Point(x, y));
				}
				previousColour = colour;
			}
		}
		int offsetX = 0;
		int offsetY = 0;
		Widget minimapDrawWidget = getMinimapDrawWidget();
		if (minimapDrawWidget != null)
		{
			offsetX = minimapDrawWidget.getBounds().x;
			offsetY = minimapDrawWidget.getBounds().y;
		}
		Polygon polygon = new Polygon();
		for (Point point : points)
		{
			polygon.addPoint(point.x + offsetX, point.y + offsetY);
		}
		return polygon;
	}

	private Shape getMinimapClipAreaSimple()
	{
		Widget minimapDrawArea = getMinimapDrawWidget();

		if (minimapDrawArea == null || minimapDrawArea.isHidden())
		{
			return null;
		}

		Rectangle bounds = minimapDrawArea.getBounds();

		return new Ellipse2D.Double(bounds.getX(), bounds.getY(), bounds.getWidth(), bounds.getHeight());
	}

	public void removeMarker(Line line)
	{
		for (LineGroup group : groups)
		{
			group.getLines().remove(line);
			if (group.getLines().isEmpty())
			{
				groups.remove(group);
				if (group.equals(lastGroup))
				{
					lastGroup = null;
				}
				break;
			}
		}

		saveMarkers();
		rebuild();
	}

	public void removeMarker(LineGroup group)
	{
		groups.remove(group);
		saveMarkers();
		rebuild();
	}

	public void rebuild()
	{
		SwingUtilities.invokeLater(() -> pluginPanel.rebuild());
	}

	public void revalidate()
	{
		SwingUtilities.invokeLater(() -> pluginPanel.revalidate());
	}

	public Shape getMinimapClipArea()
	{
		Widget minimapWidget = getMinimapDrawWidget();

		if (minimapWidget == null || minimapWidget.isHidden() || !minimapRectangle.equals(minimapRectangle = minimapWidget.getBounds()))
		{
			minimapClipFixed = null;
			minimapClipResizeable = null;
			minimapSpriteFixed = null;
			minimapSpriteResizeable = null;
		}

		if (client.isResized())
		{
			if (minimapClipResizeable != null)
			{
				return minimapClipResizeable;
			}
			if (minimapSpriteResizeable == null)
			{
				minimapSpriteResizeable = spriteManager.getSprite(SpriteID.RESIZEABLE_MODE_MINIMAP_ALPHA_MASK, 0);
			}
			if (minimapSpriteResizeable != null)
			{
				return minimapClipResizeable = bufferedImageToPolygon(minimapSpriteResizeable);
			}
			return getMinimapClipAreaSimple();
		}
		if (minimapClipFixed != null)
		{
			return minimapClipFixed;
		}
		if (minimapSpriteFixed == null)
		{
			minimapSpriteFixed = spriteManager.getSprite(SpriteID.FIXED_MODE_MINIMAP_ALPHA_MASK, 0);
		}
		if (minimapSpriteFixed != null)
		{
			return minimapClipFixed = bufferedImageToPolygon(minimapSpriteFixed);
		}
		return getMinimapClipAreaSimple();
	}

	public Widget getMinimapDrawWidget()
	{
		if (client.isResized())
		{
			if (client.getVarbitValue(Varbits.SIDE_PANELS) == 1)
			{
				return client.getWidget(ComponentID.RESIZABLE_VIEWPORT_BOTTOM_LINE_MINIMAP_DRAW_AREA);
			}
			return client.getWidget(ComponentID.RESIZABLE_VIEWPORT_MINIMAP_DRAW_AREA);
		}
		return client.getWidget(ComponentID.FIXED_VIEWPORT_MINIMAP_DRAW_AREA);
	}
}

package com.linemarkers;

import lombok.AllArgsConstructor;
import net.runelite.api.coords.WorldPoint;

@AllArgsConstructor
public enum Edge
{
	WEST(0, 0, 0, 1),
	EAST(1, 0, 0, 1),
	SOUTH(0, 0, 1, 0),
	NORTH(0, 1, 1, 0);

	private final int x;
	private final int y;
	private final int dx;
	private final int dy;

	private static final Edge[] EDGES = values();

	public Edge next()
	{
		return EDGES[(this.ordinal() + 1) % EDGES.length];
	}

	public static WorldPoint start(Line line)
	{
		return line.getLocation().dx(line.getEdge().x).dy(line.getEdge().y);
	}

	public static WorldPoint end(Line line)
	{
		return start(line).dx(line.getEdge().dx).dy(line.getEdge().dy);
	}

	@Override
	public String toString()
	{
		return name().charAt(0) + name().substring(1).toLowerCase().replaceAll("_", " ");
	}
}

