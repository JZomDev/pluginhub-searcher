package com.duckblade.osrs.sailing.features.courier;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.model.CourierTask;
import com.duckblade.osrs.sailing.model.Port;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.WidgetItemOverlay;
import net.runelite.client.ui.overlay.components.TextComponent;

@Slf4j
@Singleton
public class CourierDestinationOverlay
	extends WidgetItemOverlay
	implements PluginLifecycleComponent
{

	private final CourierTaskTracker taskTracker;

	@Inject
	public CourierDestinationOverlay(CourierTaskTracker taskTracker)
	{
		super();
		this.taskTracker = taskTracker;

		showOnInventory();
		showOnEquipment();
		showOnInterfaces(InterfaceID.SAILING_BOAT_CARGOHOLD);
		showOnInterfaces(InterfaceID.SAILING_BOAT_CARGOHOLD_SIDE);
	}

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		return config.courierItemIdentification();
	}

	@Override
	public void renderItemOverlay(Graphics2D graphics, int itemId, WidgetItem widgetItem)
	{
		CourierTask task = taskTracker.getTaskForItemID(itemId);
		if (task == null)
		{
			return;
		}

		Port port = task.getToPort();
		if (port == null)
		{
			return;
		}

		graphics.setFont(FontManager.getRunescapeSmallFont());

		Rectangle bounds = widgetItem.getCanvasBounds();
		TextComponent textComponent = new TextComponent();
		textComponent.setText(port.getShortCode());
		textComponent.setPosition(new Point(bounds.x - 1, bounds.y + bounds.height - 1));
		textComponent.render(graphics);
	}
}

package com.duckblade.osrs.sailing.features.courier;

import com.duckblade.osrs.sailing.features.util.CourierTaskUtil;
import com.duckblade.osrs.sailing.model.CourierTask;
import com.duckblade.osrs.sailing.model.Port;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.events.WorldViewUnloaded;
import net.runelite.api.gameval.DBTableID;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class CourierTaskTracker
	implements PluginLifecycleComponent
{

	private static final Set<Integer> LEDGER_TABLE_IDS = Arrays.stream(Port.values()).map(Port::getLedgerTableID).collect(Collectors.toSet());

	private final Client client;

	@Getter
	private final Set<CourierTask> tasks = new HashSet<>();

	@Getter
	private GameObject activeLedger;

	@Getter
	private Port activePort;

	public void shutDown()
	{
		activePort = null;
		activeLedger = null;
		tasks.clear();
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned e)
	{
		int id = e.getGameObject().getId();
		if (LEDGER_TABLE_IDS.contains(id))
		{
			log.debug("Found ledger table at {}", e.getGameObject().getLocalLocation());
			activeLedger = e.getGameObject();
			activePort = Port.findByLedgerTableID(id);
		}
	}

	@Subscribe
	public void onGameObjectDespawned(GameObjectDespawned e)
	{
		int id = e.getGameObject().getId();
		if (LEDGER_TABLE_IDS.contains(id))
		{
			activeLedger = null;
			activePort = null;
		}
	}

	@Subscribe
	public void onWorldViewUnloaded(WorldViewUnloaded e)
	{
		if (e.getWorldView().isTopLevel())
		{
			activeLedger = null;
			activePort = null;
		}
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged e)
	{
		if (CourierTaskUtil.ALL_COURIER_TASK_VARBITS.contains(e.getVarbitId()))
		{
			updateTasks();
		}
	}

	private void updateTasks()
	{
		tasks.clear();
		for (int i = 0; i < CourierTaskUtil.TASK_SLOT_IDS.size(); i++)
		{
			CourierTask task = this.getTaskInfo(i);
			if (task != null)
			{
				log.debug("Tracking task {}: {}", i, task);
				tasks.add(task);
			}
		}
	}

	public CourierTask getTaskInfo(int taskIndex)
	{
		int taskID = client.getVarbitValue(CourierTaskUtil.TASK_SLOT_IDS.get(taskIndex));
		List<Integer> taskRow = client.getDBRowsByValue(DBTableID.PortTask.ID, DBTableID.PortTask.COL_TASK_ID, 0, taskID);

		if (taskRow.isEmpty())
		{
			return null;
		}

		Integer rowID = taskRow.get(0);
		int taskType = (int) client.getDBTableField(rowID, DBTableID.PortTask.COL_TASK_TYPE, 0)[0];
		if (taskType != CourierTaskUtil.TaskType.DELIVERY.ordinal())
		{
			return null;
		}

		int fromPortID = (int) client.getDBTableField(rowID, DBTableID.PortTask.COL_CARGO_PORT, 0)[0];
		int toPortID = (int) client.getDBTableField(rowID, DBTableID.PortTask.COL_ENDING_PORT, 0)[0];
		int cargoAmount = (int) client.getDBTableField(rowID, DBTableID.PortTask.COL_CARGO, 1)[0];
		int cargoCrateItemID = (int) client.getDBTableField(rowID, DBTableID.PortTask.COL_CARGO, 0)[0];

		Port fromPort = Port.findByID(fromPortID);
		Port toPort = Port.findByID(toPortID);

		int numRetrieved = client.getVarbitValue(CourierTaskUtil.CARGO_RETRIEVED_VARBITS.get(taskIndex));
		int numDelivered = client.getVarbitValue(CourierTaskUtil.CARGO_DELIVERED_VARBITS.get(taskIndex));

		return new CourierTask(taskIndex, fromPort, toPort, cargoCrateItemID, cargoAmount, numRetrieved, numDelivered);
	}

	public List<CourierTask> getDropOffTasksForPort(Port port)
	{
		return tasks.stream()
			.filter(task -> task.getToPort() == port)
			.collect(Collectors.toList());
	}

	public List<CourierTask> getPickupTasksForPort(Port port)
	{
		return tasks.stream()
			.filter(task -> task.getFromPort() == port)
			.collect(Collectors.toList());
	}

	public CourierTask getTaskForItemID(int itemID)
	{
		return tasks.stream()
			.filter(task -> task.getCargoCrateItemID() == itemID)
			.findFirst()
			.orElse(null);
	}
}

package com.duckblade.osrs.sailing.features.courier;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.model.CourierTask;
import com.duckblade.osrs.sailing.model.Port;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.util.List;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameObject;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

@Slf4j
@Singleton
public class CourierTaskLedgerOverlay
	extends Overlay
	implements PluginLifecycleComponent
{

	private final SailingConfig config;
	private final CourierTaskTracker taskTracker;

	private Color ledgerPickupColour;
	private Color ledgerDropOffColour;

	@Inject
	public CourierTaskLedgerOverlay(SailingConfig config, CourierTaskTracker taskTracker)
	{
		super();
		this.taskTracker = taskTracker;
		this.config = config;

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		ledgerPickupColour = config.courierItemPickupOverlayColor();
		ledgerDropOffColour = config.courierItemDropOffOverlayColor();
		return config.courierItemShowDropOffOverlay() || config.courierItemShowPickupOverlay();
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		Port activePort = taskTracker.getActivePort();
		GameObject activeLedger = taskTracker.getActiveLedger();
		if (activePort == null || activeLedger == null)
		{
			return null;
		}

		Shape hull = activeLedger.getConvexHull();
		if (hull == null)
		{
			return null;
		}

		List<CourierTask> pickupTasks = taskTracker.getPickupTasksForPort(activePort);
		boolean allCargoRetrieved = pickupTasks.stream().allMatch(CourierTask::hasRetrievedAllCargo);
		if (!allCargoRetrieved && config.courierItemShowPickupOverlay())
		{
			OverlayUtil.renderPolygon(graphics, hull, ledgerPickupColour);
		}

		List<CourierTask> dropOffTasks = taskTracker.getDropOffTasksForPort(activePort);
		boolean allCargoDelivered = dropOffTasks.stream().allMatch(CourierTask::hasDeliveredAllCargo);
		if (!allCargoDelivered && config.courierItemShowDropOffOverlay())
		{
			OverlayUtil.renderPolygon(graphics, hull, ledgerDropOffColour);
		}

		return null;
	}
}

package com.duckblade.osrs.sailing.features.util;

import com.duckblade.osrs.sailing.model.Crewmate;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import com.google.common.collect.ImmutableMap;
import java.util.HashMap;
import java.util.Map;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class CrewmateTracker
	implements PluginLifecycleComponent
{

	private static final Map<Integer, Integer> CREWMATE_VARBS = ImmutableMap.<Integer, Integer>builder()
		.put(VarbitID.SAILING_CREW_SLOT_1, VarbitID.SAILING_CREW_SLOT_1_POSITION)
		.put(VarbitID.SAILING_CREW_SLOT_2, VarbitID.SAILING_CREW_SLOT_2_POSITION)
		.put(VarbitID.SAILING_CREW_SLOT_3, VarbitID.SAILING_CREW_SLOT_3_POSITION)
		.put(VarbitID.SAILING_CREW_SLOT_4, VarbitID.SAILING_CREW_SLOT_4_POSITION)
		.put(VarbitID.SAILING_CREW_SLOT_5, VarbitID.SAILING_CREW_SLOT_5_POSITION)
		.build();

	private final Client client;
	private final ClientThread clientThread;
	private final CrewmateIndex crewmateIndex;

	@Getter
	private final Map<Integer, Crewmate> crewmates = new HashMap<>();

	@Getter
	private final Map<Integer, CrewmateAssignment> assignments = new HashMap<>();

	@Override
	public void startUp()
	{
		if (client.getGameState() == GameState.LOGGED_IN)
		{
			clientThread.invokeLater(this::loadAll);
		}
	}

	@Override
	public void shutDown()
	{
		crewmates.clear();
		assignments.clear();
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged e)
	{
		for (Map.Entry<Integer, Integer> entry : CREWMATE_VARBS.entrySet())
		{
			if (entry.getValue() == e.getVarbitId() || entry.getKey() == e.getVarbitId())
			{
				loadSingle(entry.getKey(), e.getVarbitId());
				return;
			}
		}
	}

	private void loadAll()
	{
		CREWMATE_VARBS.forEach(this::loadSingle);
	}

	private void loadSingle(int slotVarb, int posVarb)
	{
		int crewmateVarbValue = client.getVarbitValue(slotVarb);
		if (crewmateVarbValue == 0)
		{
			crewmates.remove(slotVarb);
			assignments.remove(slotVarb);
			return;
		}

		Crewmate crewmate = crewmateIndex.getCrewmate(crewmateVarbValue);
		crewmates.put(slotVarb, crewmate);

		CrewmateAssignment assignment = CrewmateAssignment.fromCrewAssignmentVarb(client.getVarbitValue(posVarb));
		if (assignment == null)
		{
			assignments.remove(slotVarb);
		}
		else
		{
			assignments.put(slotVarb, assignment);
		}
	}
}

package com.duckblade.osrs.sailing.features.util;

import com.google.common.collect.ImmutableSet;
import javax.inject.Inject;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.ObjectComposition;
import net.runelite.api.Player;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.VarbitID;

@Slf4j
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class SailingUtil
{

	public static final ImmutableSet<Integer> WORLD_ENTITY_TYPE_BOAT = ImmutableSet.of(
		1, // raft
		2,
		3 // 3? confirm sloop?
	);
	public static final int ACCOUNT_TYPE_UIM = 2;

	@SuppressWarnings("BooleanMethodIsAlwaysInverted")
	public static boolean isSailing(Client client)
	{
		return client.getLocalPlayer() != null &&
			!client.getLocalPlayer().getWorldView().isTopLevel();
	}

	public static boolean isUim(Client client)
	{
		return client.getVarbitValue(VarbitID.IRONMAN) == ACCOUNT_TYPE_UIM;
	}

	// on boats, InteractingChanged fires for the local player but the target is null
	// it DOES fire an event with the expected target for a separate instance of Player with the same ID
	public static boolean isLocalPlayer(Client client, Actor actor)
	{
		return client.getLocalPlayer() != null &&
			actor instanceof Player && ((Player) actor).getId() == client.getLocalPlayer().getId();
	}

	public static ObjectComposition getTransformedObject(Client client, GameObject o)
	{
		ObjectComposition def = client.getObjectDefinition(o.getId());
		if (def == null || def.getImpostorIds() == null)
		{
			return def;
		}

		return def.getImpostor();
	}

	public static LocalPoint getTopLevelLocalPoint(Client client)
	{
		Player player = client.getLocalPlayer();
		WorldView wv = player.getWorldView();
		if (wv.isTopLevel())
		{
			return player.getLocalLocation();
		}

		return client.getTopLevelWorldView()
			.worldEntities()
			.byIndex(wv.getId())
			.transformToMainWorld(client.getLocalPlayer().getLocalLocation());
	}

	public static WorldPoint getTopLevelWorldPoint(Client client)
	{
		return WorldPoint.fromLocal(
			client,
			getTopLevelLocalPoint(client)
		);
	}
}

package com.duckblade.osrs.sailing.features.util;

import com.duckblade.osrs.sailing.model.Boat;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Polygon;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import static net.runelite.api.Perspective.LOCAL_HALF_TILE_SIZE;
import static net.runelite.api.Perspective.LOCAL_TILE_SIZE;
import net.runelite.api.WorldEntityConfig;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;

public class SailingGraphicsUtil
{

	// arrow facing right
	// spans about 2 full tiles
	private static final float[] ARROW_X = new float[]{
		0,
		-3 * ((float) LOCAL_TILE_SIZE / 4),
		-3 * ((float) LOCAL_TILE_SIZE / 4),
		0,
		0,
		+3 * ((float) (5 * LOCAL_TILE_SIZE) / 16),
		0,
	};
	private static final float[] ARROW_Y = new float[]{
		+((float) LOCAL_TILE_SIZE / 8), // box top right
		+((float) LOCAL_TILE_SIZE / 8), // box bottom right
		-((float) LOCAL_TILE_SIZE / 8), // box bottom left
		-((float) LOCAL_TILE_SIZE / 8), // box top left
		-((float) (5 * LOCAL_TILE_SIZE) / 16), // head left
		0, // head top
		+((float) (5 * LOCAL_TILE_SIZE) / 16), // head right
	};

	public static int jauBetween(LocalPoint p1, LocalPoint p2)
	{
		int dx = p2.getX() - p1.getX();
		int dy = p2.getY() - p1.getY();
		double radialStep = 2048. / (Math.PI * 2.);
		return ((int) Math.round(Math.atan2(dy, -dx) * radialStep)) & 2047;
	}

	public static float[] translate(float[] src, int offset)
	{
		float[] translated = new float[src.length];
		for (int i = 0; i < src.length; i++)
		{
			translated[i] = src[i] + offset;
		}
		return translated;
	}

	public static void renderBoatArrowTowardPoint(Graphics2D g, Client client, BoatTracker boatTracker, WorldPoint destination, Color color)
	{
		Boat boat = boatTracker.getBoat();

		WorldView tlwv = client.getTopLevelWorldView();
		int baseX = tlwv.getBaseX();
		int baseY = tlwv.getBaseY();

		LocalPoint targetLp = LocalPoint.fromScene(destination.getX() - baseX, destination.getY() - baseY, tlwv); // maybe outside the scene
		LocalPoint boatLp = boat.getWorldEntity().getLocalLocation();

		WorldEntityConfig wec = boat.getWorldEntity().getConfig();
		int radius = Math.max(wec.getBoundsWidth(), wec.getBoundsHeight()) / LOCAL_TILE_SIZE + 5;
		float[] arrowX = SailingGraphicsUtil.translate(ARROW_X, radius * LOCAL_HALF_TILE_SIZE); // push the arrow outside the boat
		float[] arrowY = ARROW_Y;

		int[] outXs = new int[arrowX.length];
		int[] outYs = new int[arrowY.length];
		Perspective.modelToCanvas(
			client,
			client.getTopLevelWorldView(),
			arrowX.length,
			boatLp.getX(),
			boatLp.getY(),
			0,
			SailingGraphicsUtil.jauBetween(targetLp, boatLp),
			arrowX,
			arrowY,
			new float[arrowX.length],
			outXs,
			outYs
		);

		g.setColor(color);
		g.fill(new Polygon(outXs, outYs, outXs.length));
	}

}

package com.duckblade.osrs.sailing.features.util;

import com.google.common.collect.ImmutableList;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.gameval.VarbitID;

@Slf4j
public class CourierTaskUtil
{
	public enum TaskType
	{
		DELIVERY,
		BOUNTY
	}

	public static final List<Integer> TASK_SLOT_IDS = ImmutableList.of(
		VarbitID.PORT_TASK_SLOT_0_ID,
		VarbitID.PORT_TASK_SLOT_1_ID,
		VarbitID.PORT_TASK_SLOT_2_ID,
		VarbitID.PORT_TASK_SLOT_3_ID,
		VarbitID.PORT_TASK_SLOT_4_ID
	);

	public static final List<Integer> CARGO_RETRIEVED_VARBITS = ImmutableList.of(
		VarbitID.PORT_TASK_SLOT_0_CARGO_TAKEN,
		VarbitID.PORT_TASK_SLOT_1_CARGO_TAKEN,
		VarbitID.PORT_TASK_SLOT_2_CARGO_TAKEN,
		VarbitID.PORT_TASK_SLOT_3_CARGO_TAKEN,
		VarbitID.PORT_TASK_SLOT_4_CARGO_TAKEN
	);

	public static final List<Integer> CARGO_DELIVERED_VARBITS = ImmutableList.of(
		VarbitID.PORT_TASK_SLOT_0_CARGO_DELIVERED,
		VarbitID.PORT_TASK_SLOT_1_CARGO_DELIVERED,
		VarbitID.PORT_TASK_SLOT_2_CARGO_DELIVERED,
		VarbitID.PORT_TASK_SLOT_3_CARGO_DELIVERED,
		VarbitID.PORT_TASK_SLOT_4_CARGO_DELIVERED
	);

	public static final Set<Integer> ALL_COURIER_TASK_VARBITS = Stream.of(
		TASK_SLOT_IDS,
		CARGO_RETRIEVED_VARBITS,
		CARGO_DELIVERED_VARBITS
	).flatMap(List::stream)
		.collect(Collectors.toUnmodifiableSet());
}

package com.duckblade.osrs.sailing.features.util;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum CrewmateAssignment
{

	SAILS(4),
	REPAIRS(5),
	WIND_CATCHER(7),
	HOOK_SKIFF(10),
	HOOK_SLOOP_1(13),
	HOOK_SLOOP_2(14),
	;

	private final int varbValue;

	public static CrewmateAssignment fromCrewAssignmentVarb(int varbitValue)
	{
		for (CrewmateAssignment slot : values())
		{
			if (slot.getVarbValue() == varbitValue)
			{
				return slot;
			}
		}

		return null;
	}

	public boolean isHook()
	{
		switch (this)
		{
			case HOOK_SLOOP_1:
			case HOOK_SLOOP_2:
			case HOOK_SKIFF:
				return true;

			default:
				return false;
		}
	}

}

package com.duckblade.osrs.sailing.features.util;

import com.duckblade.osrs.sailing.model.Boat;
import com.duckblade.osrs.sailing.model.CargoHoldTier;
import com.duckblade.osrs.sailing.model.HelmTier;
import com.duckblade.osrs.sailing.model.HullTier;
import com.duckblade.osrs.sailing.model.SailTier;
import com.duckblade.osrs.sailing.model.SalvagingHookTier;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import java.util.HashMap;
import java.util.Map;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.WorldEntity;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.WorldEntityDespawned;
import net.runelite.api.events.WorldEntitySpawned;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class BoatTracker
	implements PluginLifecycleComponent
{

	private final Map<Integer, Boat> trackedBoats = new HashMap<>();
	private final Client client;

	public void shutDown()
	{
		trackedBoats.clear();
	}

	@Subscribe
	public void onWorldEntitySpawned(WorldEntitySpawned e)
	{
		WorldEntity we = e.getWorldEntity();
		if (SailingUtil.WORLD_ENTITY_TYPE_BOAT.contains(we.getConfig().getId()))
		{
			int wvId = we.getWorldView().getId();
			log.trace("tracking boat in wv {}", wvId);
			trackedBoats.put(wvId, new Boat(wvId, we));
		}
	}

	@Subscribe
	public void onWorldEntityDespawned(WorldEntityDespawned e)
	{
		if (trackedBoats.remove(e.getWorldEntity().getWorldView().getId()) != null)
		{
			log.trace("removed tracking boat from wv {}", e.getWorldEntity().getWorldView().getId());
		}
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned e)
	{
		GameObject o = e.getGameObject();
		Boat boat = getBoat(o.getWorldView().getId());
		if (boat == null)
		{
			return;
		}

		if (HullTier.fromGameObjectId(o.getId()) != null)
		{
			boat.setHull(o);
			log.trace("found hull {}={}+{} for boat in wv {}", o.getId(), boat.getHullTier(), boat.getSizeClass(), boat.getWorldViewId());
		}
		if (SailTier.fromGameObjectId(o.getId()) != null)
		{
			boat.setSail(o);
			log.trace("found sail {}={} for boat in wv {}", o.getId(), boat.getSailTier(), boat.getWorldViewId());
		}
		if (HelmTier.fromGameObjectId(o.getId()) != null)
		{
			boat.setHelm(o);
			log.trace("found helm {}={} for boat in wv {}", o.getId(), boat.getHelmTier(), boat.getWorldViewId());
		}
		if (SalvagingHookTier.fromGameObjectId(o.getId()) != null && boat.getSalvagingHooks().add(o))
		{
			log.trace("found salvaging hook {}={} for boat in wv {}", o.getId(), SalvagingHookTier.fromGameObjectId(o.getId()), boat.getWorldViewId());
		}
		if (CargoHoldTier.fromGameObjectId(o.getId()) != null)
		{
			boat.setCargoHold(o);
			log.trace("found cargo hold {}={} for boat in wv {}", o.getId(), boat.getCargoHoldTier(), boat.getWorldViewId());
		}
	}

	@Subscribe
	public void onGameObjectDespawned(GameObjectDespawned e)
	{
		GameObject o = e.getGameObject();
		Boat boat = getBoat(o.getWorldView().getId());
		if (boat == null)
		{
			return;
		}

		if (boat.getHull() == o)
		{
			boat.setHull(null);
			log.trace("unsetting hull for boat in wv {}", boat.getWorldViewId());
		}
		if (boat.getSail() == o)
		{
			boat.setSail(null);
			log.trace("unsetting sail for boat in wv {}", boat.getWorldViewId());
		}
		if (boat.getHelm() == o)
		{
			boat.setHelm(null);
			log.trace("unsetting helm for boat in wv {}", boat.getWorldViewId());
		}
		if (boat.getSalvagingHooks().remove(o))
		{
			log.trace("unsetting salvaging hook for boat in wv {}", boat.getWorldViewId());
		}
		if (boat.getCargoHold() == o)
		{
			boat.setCargoHold(null);
			log.trace("unsetting cargo hold for boat in wv {}", boat.getWorldViewId());
		}
	}

	public Boat getBoat()
	{
		return getBoat(client.getLocalPlayer().getWorldView().getId());
	}

	public Boat getBoat(int wvId)
	{
		if (wvId == -1)
		{
			return null;
		}

		return trackedBoats.get(wvId);
	}
}

package com.duckblade.osrs.sailing.features.util;

import com.duckblade.osrs.sailing.model.Crewmate;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.NPCComposition;
import net.runelite.api.gameval.DBTableID;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class CrewmateIndex
{

	private final Client client;

	private final Map<Integer, Crewmate> crewmates = new HashMap<>();

	public Crewmate getCrewmate(int uniqueId)
	{
		if (uniqueId == 0)
		{
			return null;
		}

		return crewmates.computeIfAbsent(uniqueId, this::load);
	}

	private Crewmate load(int uniqueId)
	{
		List<Integer> rows = client.getDBRowsByValue(DBTableID.SailingCrew.ID, DBTableID.SailingCrew.COL_UNIQUE_ID, 0, uniqueId);
		if (rows.isEmpty())
		{
			log.warn("no crewmate found for uniqueId {}", uniqueId);
			return null;
		}

		int rowID = rows.get(0);
		if (rows.size() > 1)
		{
			log.warn("multiple crewmates found for uniqueId {}, only taking first", uniqueId);
		}

		// scripts use sailing_crew:cargo_npc for all of these lookups
		int npcId = (int) client.getDBTableField(rowID, DBTableID.SailingCrew.COL_CARGO_NPC, 0)[0];
		NPCComposition npcDef = client.getNpcDefinition(npcId);

		return new Crewmate(
			uniqueId,
			npcDef.getName(),
			(int) client.getDBTableField(rowID, DBTableID.SailingCrew.COL_STAT_HELMSMANSHIP, 0)[0],
			(int) client.getDBTableField(rowID, DBTableID.SailingCrew.COL_STAT_PRIVATEERING, 0)[0],
			(int) client.getDBTableField(rowID, DBTableID.SailingCrew.COL_STAT_DECKHANDINESS, 0)[0]
		);
	}

}

package com.duckblade.osrs.sailing.features.salvaging;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.features.util.SailingUtil;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import com.google.common.collect.ImmutableMap;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.Perspective;
import net.runelite.api.Skill;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.WorldViewUnloaded;
import net.runelite.api.gameval.ObjectID;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

@Slf4j
@Singleton
public class SalvagingHighlight
	extends Overlay
	implements PluginLifecycleComponent
{

	private static final int SIZE_SALVAGEABLE_AREA = 15;

	private static final Map<Integer, Integer> SALVAGE_LEVEL_REQ = ImmutableMap.<Integer, Integer>builder()
		.put(ObjectID.SAILING_SMALL_SHIPWRECK, 15)
		.put(ObjectID.SAILING_FISHERMAN_SHIPWRECK, 26)
		.put(ObjectID.SAILING_BARRACUDA_SHIPWRECK, 35)
		.put(ObjectID.SAILING_LARGE_SHIPWRECK, 53)
		.put(ObjectID.SAILING_PIRATE_SHIPWRECK, 64)
		.put(ObjectID.SAILING_MERCENARY_SHIPWRECK, 73)
		.put(ObjectID.SAILING_FREMENNIK_SHIPWRECK, 80)
		.put(ObjectID.SAILING_MERCHANT_SHIPWRECK, 87)
		.build();

	private static final Map<Integer, Integer> STUMP_LEVEL_REQ = ImmutableMap.<Integer, Integer>builder()
		.put(ObjectID.SAILING_SMALL_SHIPWRECK_STUMP, 15)
		.put(ObjectID.SAILING_FISHERMAN_SHIPWRECK_STUMP, 26)
		.put(ObjectID.SAILING_BARRACUDA_SHIPWRECK_STUMP, 35)
		.put(ObjectID.SAILING_LARGE_SHIPWRECK_STUMP, 53)
		.put(ObjectID.SAILING_PIRATE_SHIPWRECK_STUMP, 64)
		.put(ObjectID.SAILING_MERCENARY_SHIPWRECK_STUMP, 73)
		.put(ObjectID.SAILING_FREMENNIK_SHIPWRECK_STUMP, 80)
		.put(ObjectID.SAILING_MERCHANT_SHIPWRECK_STUMP, 87)
		.build();

	private final Client client;

	private final Set<GameObject> wrecks = new HashSet<>();
	private final Set<GameObject> stumps = new HashSet<>();

	private boolean activeWrecks;
	private Color activeColour;
	private boolean inactiveWrecks;
	private Color inactiveColour;
	private boolean highLevelWrecks;
	private Color highLevelColour;

	@Inject
	public SalvagingHighlight(Client client)
	{
		this.client = client;

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		activeWrecks = config.salvagingHighlightActiveWrecks();
		activeColour = config.salvagingHighlightActiveWrecksColour();
		inactiveWrecks = config.salvagingHighlightInactiveWrecks();
		inactiveColour = config.salvagingHighlightInactiveWrecksColour();
		highLevelWrecks = config.salvagingHighlightHighLevelWrecks();
		highLevelColour = config.salvagingHighLevelWrecksColour();

		return activeWrecks || inactiveWrecks || highLevelWrecks;
	}

	@Override
	public void shutDown()
	{
		wrecks.clear();
		stumps.clear();
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!SailingUtil.isSailing(client))
		{
			return null;
		}

		int sailingLevel = client.getBoostedSkillLevel(Skill.SAILING);

		for (GameObject wreck : wrecks)
		{
			boolean hasReq = sailingLevel >= SALVAGE_LEVEL_REQ.get(wreck.getId());
			if ((hasReq && activeWrecks) || (!hasReq && highLevelWrecks))
			{
				renderWreck(graphics, wreck, hasReq ? activeColour : highLevelColour);
			}
		}
		for (GameObject wreck : stumps)
		{
			boolean hasReq = sailingLevel >= STUMP_LEVEL_REQ.get(wreck.getId());
			if ((hasReq && inactiveWrecks) || (!hasReq && highLevelWrecks))
			{
				renderWreck(graphics, wreck, hasReq ? inactiveColour : highLevelColour);
			}
		}

		return null;
	}

	private void renderWreck(Graphics2D graphics, GameObject wreck, Color colour)
	{
		Polygon poly = Perspective.getCanvasTileAreaPoly(client, wreck.getLocalLocation(), SIZE_SALVAGEABLE_AREA);
		if (poly != null)
		{
			OverlayUtil.renderPolygon(graphics, poly, colour);
		}
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned e)
	{
		if (SALVAGE_LEVEL_REQ.containsKey(e.getGameObject().getId()))
		{
			wrecks.add(e.getGameObject());
		}
		else if (STUMP_LEVEL_REQ.containsKey(e.getGameObject().getId()))
		{
			stumps.add(e.getGameObject());
		}
	}

	@Subscribe
	public void onGameObjectDespawned(GameObjectDespawned e)
	{
		wrecks.remove(e.getGameObject());
		stumps.remove(e.getGameObject());
	}

	@Subscribe
	public void onWorldViewUnloaded(WorldViewUnloaded e)
	{
		if (e.getWorldView().isTopLevel())
		{
			wrecks.clear();
			stumps.clear();
		}
	}
}

package com.duckblade.osrs.sailing.features.navigation;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.features.util.BoatTracker;
import com.duckblade.osrs.sailing.features.util.SailingUtil;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import com.google.common.collect.ImmutableSet;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.HashSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.api.gameval.AnimationID;
import net.runelite.api.gameval.NpcID;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

@Singleton
public class LightningCloudsOverlay
	extends Overlay
	implements PluginLifecycleComponent
{

	private static final ImmutableSet<Integer> LIGHTNING_CLOUDS_WARNING_ANIM_IDS = ImmutableSet.of(
		AnimationID.TEMPOROSS_LIGHTNING_CLOUD_CHARGING_IDLE,
		AnimationID.SAILING_LIGHTNING_CLOUD_ATTACK
	);

	private final Client client;
	private final SailingConfig config;

	private final Set<NPC> clouds = new HashSet<>();

	private Color cloudColor;

	@Inject
	public LightningCloudsOverlay(Client client, SailingConfig config, BoatTracker boatTracker)
	{
		this.client = client;
		this.config = config;

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		cloudColor = config.lightningCloudStrikeColour();
		return config.highlightLightningCloudStrikes();
	}

	public void shutDown()
	{
		clouds.clear();
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned e)
	{
		NPC npc = e.getNpc();

		if (npc.getId() == NpcID.SAILING_SEA_STORMY_CLOUD)
		{
			clouds.add(npc);
		}
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned e)
	{
		clouds.remove(e.getNpc());
	}

	@Override
	public Dimension render(Graphics2D g)
	{
		if (!SailingUtil.isSailing(client) || !config.highlightLightningCloudStrikes())
		{
			return null;
		}

		for (NPC cloud : clouds)
		{
			int anim = cloud.getAnimation();

			if (LIGHTNING_CLOUDS_WARNING_ANIM_IDS.contains(anim))
			{
				Color color = (anim == AnimationID.SAILING_LIGHTNING_CLOUD_ATTACK ? cloudColor.darker() : cloudColor);
				OverlayUtil.renderActorOverlay(g, cloud, "", color);
			}
		}

		return null;
	}
}

package com.duckblade.osrs.sailing.features.navigation;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.features.util.BoatTracker;
import com.duckblade.osrs.sailing.features.util.SailingUtil;
import com.duckblade.osrs.sailing.model.Boat;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import com.google.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.Perspective;
import net.runelite.api.WorldEntity;
import net.runelite.api.WorldEntityConfig;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

public class TrueTileIndicator
	extends Overlay
	implements PluginLifecycleComponent
{

	private final Client client;
	private final BoatTracker boatTracker;

	private SailingConfig.TrueTileMode mode;
	private Color indicatorColor;

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		mode = config.navigationTrueTileIndicator();
		indicatorColor = config.navigationTrueTileIndicatorColor();

		return mode != SailingConfig.TrueTileMode.OFF;
	}

	@Inject
	public TrueTileIndicator(Client client, BoatTracker boatTracker)
	{
		this.client = client;
		this.boatTracker = boatTracker;

		setLayer(OverlayLayer.ABOVE_SCENE);
		setPosition(OverlayPosition.DYNAMIC);
	}

	@Override
	public Dimension render(Graphics2D g)
	{
		if (!SailingUtil.isSailing(client))
		{
			return null;
		}

		if (mode == SailingConfig.TrueTileMode.NAVIGATING
			&& client.getTopLevelWorldView().getYellowClickAction() != Constants.CLICK_ACTION_SET_HEADING)
		{
			return null;
		}

		g.setColor(indicatorColor);

		Boat boat = boatTracker.getBoat();
		WorldEntity we = boat.getWorldEntity();

		renderBoatArea(client, g, we.getConfig(), we.getTargetLocation(), we.getTargetOrientation());

		return null;
	}

	// public static so it can be used in SailingDebugRouteOverlay
	public static void renderBoatArea(Client client, Graphics2D g, WorldEntityConfig wec, LocalPoint lp, int angle)
	{
		int boatHalfWidth = wec.getBoundsWidth() / 2;
		int boatHalfHeight = wec.getBoundsHeight() / 2;

		float[] localCoordsX = new float[]{
			wec.getBoundsX() + boatHalfWidth,
			wec.getBoundsX() + boatHalfWidth,
			wec.getBoundsX() - boatHalfWidth,
			wec.getBoundsX() - boatHalfWidth
		};

		float[] localCoordsY = new float[]{
			wec.getBoundsY() - boatHalfHeight,
			wec.getBoundsY() + boatHalfHeight,
			wec.getBoundsY() + boatHalfHeight,
			wec.getBoundsY() - boatHalfHeight
		};

		float[] localCoordsZ = new float[]{0, 0, 0, 0};

		int[] canvasXs = new int[4];
		int[] canvasYs = new int[4];

		Perspective.modelToCanvas(
			client,
			client.getTopLevelWorldView(),
			localCoordsX.length, // end
			lp.getX(), // x3dCenter
			lp.getY(), // y3dCenter
			0, // z3dCenter
			angle, // rotate
			localCoordsX, // x3d
			localCoordsY, // y3d
			localCoordsZ, // z3d
			canvasXs, // x2d
			canvasYs // y2d
		);

		Polygon canvasPoly = new Polygon();
		canvasPoly.addPoint(canvasXs[0], canvasYs[0]);
		canvasPoly.addPoint(canvasXs[1], canvasYs[1]);
		canvasPoly.addPoint(canvasXs[2], canvasYs[2]);
		canvasPoly.addPoint(canvasXs[3], canvasYs[3]);
		g.draw(canvasPoly);
	}
}

package com.duckblade.osrs.sailing.features.navigation;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.features.util.BoatTracker;
import com.duckblade.osrs.sailing.features.util.SailingUtil;
import com.duckblade.osrs.sailing.model.Boat;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.GameObject;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.WorldEntity;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.events.GameTick;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

@Slf4j
@Singleton
public class NavigationOverlay
	extends Overlay
	implements PluginLifecycleComponent
{

	private final BoatTracker boatTracker;
	private final Client client;

	private SailingConfig.NavigationOverlayMode mode;
	private Color colour;
	private boolean speedEnabled;
	private boolean headingEnabled;

	private int sceneBaseX = -1;
	private int sceneBaseY = -1;
	private LocalPoint lastPoint;
	private int speed;

	@Inject
	public NavigationOverlay(BoatTracker boatTracker, Client client)
	{
		this.boatTracker = boatTracker;
		this.client = client;

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		mode = config.navigationOverlayMode();
		colour = config.navigationOverlayColour();
		speedEnabled = config.navigationOverlaySpeed();
		headingEnabled = config.navigationOverlayHeading();

		// always on for speed tracking, mode checked in config
		return true;
	}

	@Subscribe
	public void onGameTick(GameTick e)
	{
		if (!SailingUtil.isSailing(client))
		{
			lastPoint = null;
			return;
		}

		checkSceneBase();

		Boat boat = boatTracker.getBoat();
		WorldEntity we = boat.getWorldEntity();
		LocalPoint lp = we.getTargetLocation();

		if (!lp.equals(lastPoint))
		{
			if (lastPoint != null)
			{
				double trueSpeed = (float) Math.hypot(
					(lastPoint.getX() - lp.getX()),
					(lastPoint.getY() - lp.getY())
				);
				speed = roundToQuarterTile(trueSpeed) / 32;
			}
			lastPoint = lp;
		}
		else
		{
			speed = 0;
		}
	}

	@Override
	public Dimension render(Graphics2D g)
	{
		if (!SailingUtil.isSailing(client) ||
			mode == SailingConfig.NavigationOverlayMode.OFF ||
			(!speedEnabled && !headingEnabled))
		{
			return null;
		}

		if (mode == SailingConfig.NavigationOverlayMode.NAVIGATING &&
			client.getTopLevelWorldView().getYellowClickAction() != Constants.CLICK_ACTION_SET_HEADING)
		{
			return null;
		}

		String text = "";
		Boat boat = boatTracker.getBoat();
		if (headingEnabled)
		{
			text += "Heading: " + jauToDirectionString(boat.getWorldEntity().getTargetOrientation());
		}
		if (headingEnabled && speedEnabled)
		{
			text += "\n";
		}
		if (speedEnabled)
		{
			text += "Speed: " + speed;
		}

		Point textTarget = getRenderPoint();
		g.setFont(FontManager.getRunescapeBoldFont().deriveFont(24f));
		renderCenteredMultilineText(g, text, textTarget, colour);

		return null;
	}

	private void checkSceneBase()
	{
		WorldView tlwv = client.getTopLevelWorldView();
		int baseX = tlwv.getScene().getBaseX();
		int baseY = tlwv.getScene().getBaseY();

		if (baseX == sceneBaseX && baseY == sceneBaseY)
		{
			return;
		}

		if (lastPoint != null)
		{
			int xAdjust = baseX - sceneBaseX;
			int yAdjust = baseY - sceneBaseY;
			// reshift lastPoint to where it would be in the new scene
			lastPoint = new LocalPoint(
				lastPoint.getX() - (xAdjust * Perspective.LOCAL_TILE_SIZE),
				lastPoint.getY() - (yAdjust * Perspective.LOCAL_TILE_SIZE),
				tlwv
			);
		}

		sceneBaseX = client.getTopLevelWorldView().getScene().getBaseX();
		sceneBaseY = client.getTopLevelWorldView().getScene().getBaseY();
	}

	private static int roundToQuarterTile(double trueSpeed)
	{
		int quarterTileFloor = ((int) trueSpeed) & ~0x1F;
		int quarterTileCeil = quarterTileFloor + 0x20;
		log.trace("{} = {} {}", trueSpeed, quarterTileFloor, quarterTileCeil);

		if (quarterTileCeil - trueSpeed < trueSpeed - quarterTileFloor)
		{
			return quarterTileCeil;
		}

		return quarterTileFloor;
	}

	private Point getRenderPoint()
	{
		Boat boat = boatTracker.getBoat();
		WorldEntity we = boat.getWorldEntity();
		GameObject sail = boat.getSail();

		int height = 0;
		LocalPoint lp = boat.getWorldEntity().getLocalLocation();
		if (sail != null)
		{
			switch (boat.getSizeClass())
			{
				case RAFT:
					height = 250;
					lp = sail.getLocalLocation()
						.dx(Perspective.LOCAL_TILE_SIZE / 2)
						.dy(0);
					break;

				case SKIFF:
					height = 450;
					lp = sail.getLocalLocation()
						.dx(-Perspective.LOCAL_TILE_SIZE / 2)
						.dy(-5 * Perspective.LOCAL_TILE_SIZE / 2);
					break;

				case SLOOP:
					height = 550;
					lp = sail.getLocalLocation()
						.dx(-Perspective.LOCAL_TILE_SIZE)
						.dy(-11 * Perspective.LOCAL_TILE_SIZE / 2);
					break;
			}
		}

		return Perspective.localToCanvas(
			client,
			lp,
			we.getWorldView().getPlane(),
			height
		);
	}

	private static void renderCenteredMultilineText(Graphics2D g, String text, Point origin, Color c)
	{
		String[] lines = text.split("\n");

		int lineHeight = g.getFontMetrics().getHeight();
		int stackedHeight = lines.length * lineHeight;

		int y = origin.getY() - stackedHeight / 2;
		for (String line : lines)
		{
			int lineX = origin.getX() - g.getFontMetrics().stringWidth(line) / 2;
			OverlayUtil.renderTextLocation(g, new Point(lineX, y), line, c);

			y += lineHeight;
		}
	}

	private static String jauToDirectionString(int jau)
	{
		int flattened = jau / 128;
		switch (flattened)
		{
			case 0:
				return "S"; // why tho

			case 1:
				return "SSW";

			case 2:
				return "SW";

			case 3:
				return "WSW";

			case 4:
				return "W";

			case 5:
				return "WNW";

			case 6:
				return "NW";

			case 7:
				return "NNW";

			case 8:
				return "N";

			case 9:
				return "NNE";

			case 10:
				return "NE";

			case 11:
				return "ENE";

			case 12:
				return "E";

			case 13:
				return "ESE";

			case 14:
				return "SE";

			case 15:
				return "SSE";

			default:
				return "??? - " + jau + " / " + flattened;
		}
	}
}

package com.duckblade.osrs.sailing.features.navigation;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.features.util.BoatTracker;
import com.duckblade.osrs.sailing.features.util.SailingUtil;
import com.duckblade.osrs.sailing.model.Boat;
import com.duckblade.osrs.sailing.model.HelmTier;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.ObjectComposition;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.WorldViewUnloaded;
import net.runelite.api.gameval.ObjectID;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

@Singleton
public class RapidsOverlay
	extends Overlay
	implements PluginLifecycleComponent
{

	private static final Set<Integer> RAPIDS_IDS = ImmutableSet.of(
		ObjectID.SAILING_RAPIDS,
		ObjectID.SAILING_RAPIDS_STRONG,
		ObjectID.SAILING_RAPIDS_POWERFUL,
		ObjectID.SAILING_RAPIDS_DEADLY,
		ObjectID.SAILING_CHARTING_RAPIDS_KHARIDIAN_SEA,
		ObjectID.SAILING_CHARTING_RAPIDS_BAY_OF_SARIM,
		ObjectID.SAILING_CHARTING_RAPIDS_GREAT_SOUND,
		ObjectID.SAILING_CHARTING_RAPIDS_LUMBRIDGE_BASIN,
		ObjectID.SAILING_CHARTING_RAPIDS_CRABCLAW_BAY,
		ObjectID.SAILING_CHARTING_RAPIDS_MUDSKIPPER_SOUND,
		ObjectID.SAILING_CHARTING_RAPIDS_RIMMINGTON_STRAIT,
		ObjectID.SAILING_CHARTING_RAPIDS_CATHERBY_BAY,
		ObjectID.SAILING_CHARTING_RAPIDS_BRIMHAVEN_PASSAGE,
		ObjectID.SAILING_CHARTING_RAPIDS_GULF_OF_KOUREND,
		ObjectID.SAILING_CHARTING_RAPIDS_STRAIT_OF_KHAZARD,
		ObjectID.SAILING_CHARTING_RAPIDS_GUTANOTH_BAY,
		ObjectID.SAILING_CHARTING_RAPIDS_HOSIDIAN_SEA,
		ObjectID.SAILING_CHARTING_RAPIDS_PILGRIMS_PASSAGE,
		ObjectID.SAILING_CHARTING_RAPIDS_FELDIP_GULF,
		ObjectID.SAILING_CHARTING_RAPIDS_KHARAZI_STRAIT,
		ObjectID.SAILING_CHARTING_RAPIDS_LITUS_LUCIS,
		ObjectID.SAILING_CHARTING_RAPIDS_OOGLOG_CHANNEL,
		ObjectID.SAILING_CHARTING_RAPIDS_FORTIS_BAY,
		ObjectID.SAILING_CHARTING_RAPIDS_ARROW_PASSAGE,
		ObjectID.SAILING_CHARTING_RAPIDS_AUREUM_COAST,
		ObjectID.SAILING_CHARTING_RAPIDS_MENAPHITE_SEA,
		ObjectID.SAILING_CHARTING_RAPIDS_TURTLE_BELT,
		ObjectID.SAILING_CHARTING_RAPIDS_WYRMS_WATERS,
		ObjectID.SAILING_CHARTING_RAPIDS_THE_SIMIAN_SEA,
		ObjectID.SAILING_CHARTING_RAPIDS_SEA_OF_SHELLS,
		ObjectID.SAILING_CHARTING_RAPIDS_SUNSET_BAY,
		ObjectID.SAILING_CHARTING_RAPIDS_THE_STORM_TEMPOR,
		ObjectID.SAILING_CHARTING_RAPIDS_RED_REEF,
		ObjectID.SAILING_CHARTING_RAPIDS_MISTY_SEA,
		ObjectID.SAILING_CHARTING_RAPIDS_MYTHIC_SEA,
		ObjectID.SAILING_CHARTING_RAPIDS_ANGLERFISHS_LIGHT,
		ObjectID.SAILING_CHARTING_RAPIDS_BAY_OF_ELIDINIS,
		ObjectID.SAILING_CHARTING_RAPIDS_BREAKBONE_STRAIT,
		ObjectID.SAILING_CHARTING_RAPIDS_TORTUGAN_SEA,
		ObjectID.SAILING_CHARTING_RAPIDS_DUSKS_MAW,
		ObjectID.SAILING_CHARTING_RAPIDS_BACKWATER,
		ObjectID.SAILING_CHARTING_RAPIDS_PEARL_BANK,
		ObjectID.SAILING_CHARTING_RAPIDS_THE_LONELY_SEA,
		ObjectID.SAILING_CHARTING_RAPIDS_ZUL_EGIL,
		ObjectID.SAILING_CHARTING_RAPIDS_THE_SKULLHORDE,
		ObjectID.SAILING_CHARTING_RAPIDS_SEA_OF_SOULS,
		ObjectID.SAILING_CHARTING_RAPIDS_SOUL_BAY,
		ObjectID.SAILING_CHARTING_RAPIDS_BARRACUDA_BELT,
		ObjectID.SAILING_CHARTING_RAPIDS_THE_EVERDEEP,
		ObjectID.SAILING_CHARTING_RAPIDS_SAPPHIRE_SEA,
		ObjectID.SAILING_CHARTING_RAPIDS_WESTERN_GATE,
		ObjectID.SAILING_CHARTING_RAPIDS_RAINBOW_REEF,
		ObjectID.SAILING_CHARTING_RAPIDS_SOUTHERN_EXPANSE,
		ObjectID.SAILING_CHARTING_RAPIDS_PORTH_NEIGWL,
		ObjectID.SAILING_CHARTING_RAPIDS_TIRANNWN_BIGHT,
		ObjectID.SAILING_CHARTING_RAPIDS_CRYSTAL_SEA,
		ObjectID.SAILING_CHARTING_RAPIDS_PORTH_GWENITH,
		ObjectID.SAILING_CHARTING_RAPIDS_PISCATORIS_SEA,
		ObjectID.SAILING_CHARTING_RAPIDS_VAGABONDS_REST,
		ObjectID.SAILING_CHARTING_RAPIDS_MOONSHADOW,
		ObjectID.SAILING_CHARTING_RAPIDS_FREMENSUND,
		ObjectID.SAILING_CHARTING_RAPIDS_GRANDROOT_BAY,
		ObjectID.SAILING_CHARTING_RAPIDS_VS_BELT,
		ObjectID.SAILING_CHARTING_RAPIDS_FREMENNIK_STRAIT,
		ObjectID.SAILING_CHARTING_RAPIDS_IDESTIA_STRAIT,
		ObjectID.SAILING_CHARTING_RAPIDS_LUNAR_BAY,
		ObjectID.SAILING_CHARTING_RAPIDS_WINTERS_EDGE,
		ObjectID.SAILING_CHARTING_RAPIDS_LUNAR_SEA,
		ObjectID.SAILING_CHARTING_RAPIDS_EVERWINTER_SEA,
		ObjectID.SAILING_CHARTING_RAPIDS_KANNSKI_TIDES,
		ObjectID.SAILING_CHARTING_RAPIDS_WEISSMERE,
		ObjectID.SAILING_CHARTING_RAPIDS_STONEHEART_SEA,
		ObjectID.SAILING_CHARTING_RAPIDS_SHIVERWAKE_EXPANSE,
		ObjectID.SAILING_CHARTING_RAPIDS_WEISS_MELT
	);

	private final Map<Integer, HelmTier> MIN_HELM_TIER_BY_RAPID_TYPE = ImmutableMap.<Integer, HelmTier>builder()
		.put(ObjectID.SAILING_RAPIDS, HelmTier.IRON)
		.put(ObjectID.SAILING_RAPIDS_STRONG, HelmTier.MITHRIL)
		.put(ObjectID.SAILING_RAPIDS_POWERFUL, HelmTier.RUNE)
		.build();

	private final Client client;
	private final SailingConfig config;
	private final BoatTracker boatTracker;

	private final Set<GameObject> rapids = new HashSet<>();

	private Color safeRapidsColour;
	private Color dangerousRapidsColour;
	private Color unknownRapidsColour;

	@Inject
	public RapidsOverlay(Client client, SailingConfig config, BoatTracker boatTracker)
	{
		this.client = client;
		this.config = config;
		this.boatTracker = boatTracker;

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		safeRapidsColour = config.safeRapidsColor();
		dangerousRapidsColour = config.dangerousRapidsColour();
		unknownRapidsColour = config.unknownRapidsColour();
		return config.highlightRapids();
	}

	public void shutDown()
	{
		rapids.clear();
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned e)
	{
		GameObject o = e.getGameObject();
		if (RAPIDS_IDS.contains(o.getId()))
		{
			rapids.add(o);
		}
	}

	@Subscribe
	public void onGameObjectDespawned(GameObjectDespawned e)
	{
		rapids.remove(e.getGameObject());
	}

	@Subscribe
	public void onWorldViewUnloaded(WorldViewUnloaded e)
	{
		if (e.getWorldView().isTopLevel())
		{
			rapids.clear();
		}
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!SailingUtil.isSailing(client) || !config.highlightRapids())
		{
			return null;
		}

		for (GameObject rapid : rapids)
		{
			ObjectComposition def = SailingUtil.getTransformedObject(client, rapid);
			if (def != null)
			{
				Color colour = getHighlightColour(def.getId());
				OverlayUtil.renderTileOverlay(graphics, rapid, "", colour);
			}
		}

		return null;
	}

	private Color getHighlightColour(int objId)
	{
		HelmTier minTier = MIN_HELM_TIER_BY_RAPID_TYPE.get(objId);
		if (minTier == null)
		{
			return unknownRapidsColour;
		}

		Boat boat = boatTracker.getBoat();
		if (boat == null)
		{
			return unknownRapidsColour;
		}

		HelmTier helmTier = boat.getHelmTier();
		if (helmTier == null)
		{
			return unknownRapidsColour;
		}

		if (helmTier.ordinal() >= minTier.ordinal())
		{
			return safeRapidsColour;
		}

		return dangerousRapidsColour;
	}
}

package com.duckblade.osrs.sailing.features.reversebeep;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.audio.AudioPlayer;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class ReverseBeep implements PluginLifecycleComponent
{

	private static final int VARB_VALUE_REVERSING = 3;

	private final AudioPlayer audioPlayer;

	private boolean reversing;

	private ScheduledExecutorService es;
	private ScheduledFuture<?> beepTask;

	private float gain;

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		gain = (float) config.reverseBeepVolume() - 50.0f;
		return config.reverseBeep();
	}

	@Override
	public void startUp()
	{
		reversing = false;
		es = Executors.newScheduledThreadPool(1);
	}

	@Override
	public void shutDown()
	{
		es.shutdown();
		beepTask = null;
	}

	@Subscribe
	public void onGameTick(GameTick e)
	{
		if (reversing && beepTask == null)
		{
			// become a truck
			beepTask = es.scheduleAtFixedRate(this::beepOnce, 0, 1200, java.util.concurrent.TimeUnit.MILLISECONDS);
		}
		else if (!reversing && beepTask != null)
		{
			// become a boat again
			beepTask.cancel(false);
			beepTask = null;
		}
	}

	// Keep an eye on the PRNDL
	@Subscribe
	public void onVarbitChanged(VarbitChanged e)
	{
		if (e.getVarbitId() == VarbitID.SAILING_SIDEPANEL_BOAT_MOVE_MODE)
		{
			reversing = e.getValue() == VARB_VALUE_REVERSING;
		}
	}

	private void beepOnce()
	{
		try
		{
			audioPlayer.play(ReverseBeep.class, "beep.wav", gain);
		}
		catch (Exception e)
		{
			log.warn("Failed to play beep", e);
			beepTask.cancel(false);
		}
	}

}

package com.duckblade.osrs.sailing.features.charting;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.features.util.BoatTracker;
import com.duckblade.osrs.sailing.features.util.SailingGraphicsUtil;
import com.duckblade.osrs.sailing.features.util.SailingUtil;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameTick;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.ObjectID;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.ui.overlay.worldmap.WorldMapPointManager;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class CurrentDuckTaskTracker
	extends Overlay
	implements PluginLifecycleComponent
{

	private static final String MSG_DUCK_BEGIN = "You release your current duck and he begins tracking the currents...";

	private final Client client;
	private final ChatMessageManager chatMessageManager;
	private final ItemManager itemManager;
	private final WorldMapPointManager worldMapPointManager;
	private final SeaChartTaskIndex taskIndex;
	private final BoatTracker boatTracker;

	private BufferedImage sprite;
	private SeaChartTask activeTask;

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		return config.chartingDuckSolver();
	}

	@Override
	public void startUp()
	{
		sprite = itemManager.getImage(ItemID.SAILING_CHARTING_CURRENT_DUCK);
	}

	public void shutDown()
	{
		activeTask = null;
		worldMapPointManager.removeIf(it -> it instanceof CurrentDuckWorldMapPoint);
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (event.getType() != ChatMessageType.GAMEMESSAGE || !SailingUtil.isSailing(client))
		{
			return;
		}

		if (event.getMessage().contains(MSG_DUCK_BEGIN))
		{
			WorldPoint playerLoc = SailingUtil.getTopLevelWorldPoint(client);
			SeaChartTask task = taskIndex.findTask(playerLoc, 10, t -> t.getObjectId() == ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK);
			if (task != null)
			{
				log.debug("beginning duck task {}", task);
				setActiveTask(task);
			}
			else
			{
				log.warn("Current duck task began, but no nearby task was found at playerLoc={}", playerLoc);
			}
		}
	}

	@Subscribe
	public void onGameTick(GameTick e)
	{
		if (activeTask == null)
		{
			return;
		}

		if (activeTask.isComplete(client))
		{
			setActiveTask(null);
		}
	}

	private void setActiveTask(SeaChartTask task)
	{
		activeTask = task;
		if (activeTask != null)
		{
			WorldPoint dest = activeTask.getDestination();
			if (dest == null)
			{
				chatMessageManager.queue(QueuedMessage.builder()
					.value("[Sailing] This duck's end location is not yet supported by the plugin.")
					.build());
				activeTask = null;
				return;
			}

			worldMapPointManager.add(new CurrentDuckWorldMapPoint(dest, sprite, "Current Duck Destination"));
		}
		else
		{
			worldMapPointManager.removeIf(wmp -> wmp instanceof CurrentDuckWorldMapPoint);
		}
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (activeTask == null)
		{
			return null;
		}

		WorldPoint dest = activeTask.getDestination();
		assert dest != null;

		// todo proper height mapping of polygon
		LocalPoint destLp = LocalPoint.fromWorld(client.getTopLevelWorldView(), dest);
		if (destLp != null)
		{
			OverlayUtil.renderTileOverlay(client, graphics, destLp, sprite, Color.GREEN);
		}

		if (SailingUtil.isSailing(client))
		{
			SailingGraphicsUtil.renderBoatArrowTowardPoint(
				graphics,
				client,
				boatTracker,
				dest,
				Color.ORANGE
			);
			return null;
		}

		return null;
	}
}

package com.duckblade.osrs.sailing.features.charting;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.gameval.ItemID;

@Getter
@RequiredArgsConstructor
public enum SeaChartTaskType
{
	GENERIC("Oddity", ItemID.SAILING_LOG_INITIAL),
	SPYGLASS("Spyglass", ItemID.SAILING_CHARTING_SPYGLASS),
	DRINK_CRATE("Sealed crate", ItemID.SAILING_CHARTING_CROWBAR),
	CURRENT_DUCK("Current duck", ItemID.SAILING_CHARTING_CURRENT_DUCK),
	MERMAID_GUIDE("Diving", ItemID.HUNDRED_PIRATE_DIVING_HELMET),
	WEATHER("Weather", ItemID.SAILING_CHARTING_WEATHER_STATION_EMPTY),
	;

	private final String name;
	private final int iconItem;
}

package com.duckblade.osrs.sailing.features.charting;

import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Predicate;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.NPC;
import net.runelite.api.Quest;
import net.runelite.api.QuestState;
import net.runelite.api.Skill;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.game.ItemManager;

@Slf4j
@Singleton
public class SeaChartTaskIndex implements PluginLifecycleComponent
{

	private static final int SEARCH_DIST_GAME_OBJECT = 5;
	private static final int SEARCH_DIST_NPC = 5;

	@Inject
	private Client client;

	@Inject
	private ItemManager itemManager;

	private final Map<WorldPoint, SeaChartTask> tasksByLocation = new HashMap<>();
	private final Map<Integer, List<SeaChartTask>> tasksByGameObject = new HashMap<>();
	private final Map<Integer, List<SeaChartTask>> tasksByNpc = new HashMap<>();

	public void startUp()
	{
		for (SeaChartTask task : SeaChartTask.values())
		{
			if (task.getLocation() != null)
			{
				tasksByLocation.put(task.getLocation(), task);
			}
			if (task.getObjectId() != -1)
			{
				tasksByGameObject.computeIfAbsent(task.getObjectId(), ArrayList::new).add(task);
			}
			else if (task.getNpcId() != -1)
			{
				tasksByNpc.computeIfAbsent(task.getNpcId(), ArrayList::new).add(task);
			}
		}
	}

	public void shutDown()
	{
		tasksByLocation.clear();
		tasksByGameObject.clear();
		tasksByNpc.clear();
	}

	public SeaChartTask findTask(GameObject obj)
	{
		List<SeaChartTask> tasks = tasksByGameObject.get(obj.getId());
		if (tasks == null || tasks.isEmpty())
		{
			return null;
		}
		if (tasks.size() == 1)
		{
			return tasks.get(0);
		}

		WorldPoint wp = obj.getWorldLocation();
		SeaChartTask task = tasksByLocation.get(wp);
		if (task != null)
		{
			return task;
		}

		task = findTask(wp);
		if (task != null)
		{
			return task;
		}

		task = findTask(wp, SEARCH_DIST_GAME_OBJECT, t -> t.getObjectId() == obj.getId());
		if (task != null)
		{
			log.debug("scan found task for game object {} @ {} = task {}", obj.getId(), obj.getWorldLocation(), task.getTaskId());
			return task;
		}

		log.warn("No task found for game object {} @ {}", obj.getId(), obj.getWorldLocation());
		return null;
	}

	public SeaChartTask findTask(NPC npc)
	{
		List<SeaChartTask> tasks = tasksByNpc.get(npc.getId());
		if (tasks == null || tasks.isEmpty())
		{
			return null;
		}
		if (tasks.size() == 1)
		{
			return tasks.get(0);
		}

		WorldPoint wp = npc.getWorldLocation();
		SeaChartTask task = tasksByLocation.get(wp);
		if (task != null)
		{
			return task;
		}

		task = findTask(wp);
		if (task != null)
		{
			return task;
		}

		task = findTask(wp, SEARCH_DIST_NPC, t -> t.getNpcId() == npc.getId());
		if (task != null)
		{
			log.debug("scan found task for npc {} @ {} = task {}", npc.getId(), npc.getWorldLocation(), task.getTaskId());
			return task;
		}

		log.warn("No task found for npc {} @ {}", npc.getId(), npc.getWorldLocation());
		return null;
	}

	public SeaChartTask findTask(WorldPoint wp)
	{
		return findTask(wp, 1);
	}

	public SeaChartTask findTask(WorldPoint wp, int distance)
	{
		return findTask(wp, distance, t -> true);
	}

	public SeaChartTask findTask(WorldPoint wp, int distance, Predicate<SeaChartTask> filter)
	{
		for (int x = -distance; x <= distance; x++)
		{
			for (int y = -distance; y <= distance; y++)
			{
				SeaChartTask nearby = tasksByLocation.get(new WorldPoint(wp.getX() + x, wp.getY() + y, 0));
				if (nearby != null && filter.test(nearby))
				{
					return nearby;
				}
			}
		}

		return null;
	}

	public BufferedImage getTaskSprite(SeaChartTask task)
	{
		return itemManager.getImage(task.getType().getIconItem());
	}

	public Quest getTaskQuestRequirement(SeaChartTask task)
	{
		switch (task.getType())
		{
			case CURRENT_DUCK:
				return Quest.CURRENT_AFFAIRS;
			case DRINK_CRATE:
				return Quest.PRYING_TIMES;
			case MERMAID_GUIDE:
				return Quest.RECIPE_FOR_DISASTER__PIRATE_PETE;
			default:
				return Quest.PANDEMONIUM;
		}
	}

	public boolean hasTaskRequirement(SeaChartTask task)
	{
		var questRequirement = getTaskQuestRequirement(task);
		if (questRequirement.getState(client) != QuestState.FINISHED)
		{
			return false;
		}

		return client.getRealSkillLevel(Skill.SAILING) >= task.getLevel();
	}
}

package com.duckblade.osrs.sailing.features.charting;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.gameval.ObjectID;
import net.runelite.api.gameval.NpcID;

@RequiredArgsConstructor
@Getter
public enum SeaChartTask
{

	TASK_0(0, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_BOARD_PORT_SARIM_COMPLETE, ObjectID.PORT_TASK_BOARD_PORT_SARIM, -1, new WorldPoint(3030, 3197, 0), null, 1),
	TASK_1(1, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_SALVAGE_STATION_PORT_SARIM_COMPLETE, ObjectID.SAILING_PORT_SALVAGING_STATION_PORT_SARIM, -1, new WorldPoint(3029, 3205, 0), null, 1),
	TASK_2(2, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_WIZARDS_TOWER_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(3104, 3181, 0), null, 1),
	TASK_3(3, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_FAIRY_RING_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(3082, 3201, 0), new WorldPoint(3033, 3152, 0), 22),
	TASK_4(4, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_ROCK_BAY_OF_SARIM_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_ROCK_BAY_OF_SARIM, -1, new WorldPoint(3079, 3231, 0), null, 1),
	TASK_5(5, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_ROWBOAT_BAY_OF_SARIM_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_ROWBOAT_BAY_OF_SARIM, -1, new WorldPoint(3126, 3202, 0), null, 1),
	TASK_6(6, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_CRUNCH_POSTER_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_CRUNCH_POSTER, -1, new WorldPoint(2944, 3138, 0), null, 1),
	TASK_7(7, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_GLIDER_KHARIDIAN_SEA_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_GLIDER_KHARIDIAN_SEA, -1, new WorldPoint(2987, 3010, 0), null, 1),
	TASK_8(8, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_ROWBOAT_MUDSKIPPER_SOUND_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_ROWBOAT_MUDSKIPPER_SOUND, -1, new WorldPoint(3054, 3051, 0), null, 1),
	TASK_9(9, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_MUSA_POINT_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2890, 3121, 0), new WorldPoint(2967, 3065, 0), 22),
	TASK_10(10, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_SHIPYARD_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(3008, 3049, 0), null, 1),
	TASK_11(11, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_PRYING_TIMES_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(3013, 2998, 0), null, 12),
	TASK_12(12, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_KHARIDIAN_SEA_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_2, new WorldPoint(2988, 2949, 0), null, 38),
	TASK_13(13, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_KHARIDIAN_SEA_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(3145, 2963, 0), new WorldPoint(3049, 2962, 0), 22),
	TASK_14(14, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_THE_PANDEMONIUM_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(3045, 2995, 0), null, 1),
	TASK_15(15, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_PANDEMONIUM_2_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_PANDEMONIUM_2, -1, new WorldPoint(2973, 2994, 0), null, 1),
	TASK_16(16, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_PANDEMONIUM_3_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_PANDEMONIUM_3, -1, new WorldPoint(3143, 2979, 0), null, 1),
	TASK_17(17, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_CORPSE_LUMBRIDGE_BASIN_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_CORPSE_LUMBRIDGE_BASIN, -1, new WorldPoint(3133, 3053, 0), null, 1),
	TASK_18(18, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_ROCK_LUMBRIDGE_BASIN_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_ROCK_LUMBRIDGE_BASIN, -1, new WorldPoint(3182, 3136, 0), null, 1),
	TASK_19(19, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_LUMBRIDGE_MINE_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(3145, 3134, 0), null, 1),
	TASK_20(20, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_LUMBRIDGE_BASIN_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(3209, 3134, 0), new WorldPoint(3158, 3020, 0), 22),
	TASK_21(21, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_ROCK_RIMMINGTON_STRAIT_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_ROCK_RIMMINGTON_STRAIT, -1, new WorldPoint(2905, 3281, 0), null, 1),
	TASK_22(22, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_DRAGON_STATUE_RIMMINGTON_STRAIT_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_DRAGON_STATUE_RIMMINGTON_STRAIT, -1, new WorldPoint(2873, 3260, 0), null, 1),
	TASK_23(23, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_KARAMJA_VOLCANO_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2839, 3210, 0), null, 1),
	TASK_24(24, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_RIMMINGTON_STRAIT_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2902, 3317, 0), new WorldPoint(2872, 3273, 0), 22),
	TASK_25(25, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_THORNS_CATHERBY_BAY_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_THORNS_CATHERBY_BAY, -1, new WorldPoint(2897, 3335, 0), null, 1),
	TASK_26(26, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_MEGASHRIMP_CATHERBY_BAY_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_MEGASHRIMP_CATHERBY_BAY, -1, new WorldPoint(2760, 3364, 0), null, 1),
	TASK_27(27, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_KEEP_LE_FAYE_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2784, 3401, 0), null, 1),
	TASK_28(28, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_CATHERBY_BAY_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2835, 3417, 0), new WorldPoint(2802, 3322, 0), 22),
	TASK_29(29, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_WRECK_BRIMHAVEN_PASSAGE_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_WRECK_BRIMHAVEN_PASSAGE, -1, new WorldPoint(2741, 3270, 0), null, 1),
	TASK_30(30, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_BOTTLE_BRIMHAVEN_PASSAGE_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_BOTTLE_BRIMHAVEN_PASSAGE, -1, new WorldPoint(2769, 3267, 0), null, 1),
	TASK_31(31, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_FISHING_PLATFORM_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2779, 3265, 0), null, 1),
	TASK_32(32, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_BRIMHAVEN_PASSAGE_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2648, 3244, 0), new WorldPoint(2743, 3215, 0), 22),
	TASK_33(33, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_ROWBOAT_PORT_KHAZARD_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_ROWBOAT_STRAIT_OF_KHAZARD, -1, new WorldPoint(2702, 3151, 0), null, 1),
	TASK_34(34, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_ROCK_STRAIT_OF_KHAZARD_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_ROCK_STRAIT_OF_KHAZARD, -1, new WorldPoint(2720, 3103, 0), null, 1),
	TASK_35(35, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_SIGN_STRAIT_OF_KHAZARD_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_SIGN_STRAIT_OF_KHAZARD, -1, new WorldPoint(2681, 3134, 0), null, 1),
	TASK_36(36, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_TWO_TOWERS_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2664, 3219, 0), null, 1),
	TASK_37(37, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_STRAIT_OF_KHAZARD_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2664, 3172, 0), new WorldPoint(2640, 3095, 0), 22),
	TASK_38(38, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_SMUGGLED_RUM_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2994, 3134, 0), null, 12),
	TASK_39(39, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_SORODAMIN_BRU_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(3277, 3135, 0), null, 12),
	TASK_40(40, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_MARROW_WINE_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2869, 3378, 0), null, 12),
	TASK_41(41, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_SLUG_BALM_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2674, 3103, 0), null, 12),
	TASK_42(42, SeaChartTaskType.WEATHER, VarbitID.SAILING_CHARTING_WEATHER_TROLL_RIMMINGTON_STRAIT_COMPLETE, -1, NpcID.SAILING_CHARTING_WEATHER_TROLL, new WorldPoint(2912, 3213, 0), new WorldPoint(2840, 3315, 0), 57),
	TASK_43(43, SeaChartTaskType.WEATHER, VarbitID.SAILING_CHARTING_WEATHER_TROLL_STRAIT_OF_KHAZARD_COMPLETE, -1, NpcID.SAILING_CHARTING_WEATHER_TROLL, new WorldPoint(2656, 3195, 0), new WorldPoint(2742, 3100, 0), 57),
	TASK_44(44, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_MUDSKIPPER_SOUND_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_1, new WorldPoint(2979, 3085, 0), null, 38),
	TASK_45(45, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_CATHERBY_BAY_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_3, new WorldPoint(2873, 3397, 0), null, 38),
	TASK_46(46, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_STRAIT_OF_KHAZARD_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_4, new WorldPoint(2757, 3138, 0), null, 38),
	TASK_47(47, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_RED_REEF_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_5, new WorldPoint(2788, 2548, 0), null, 38),
	TASK_48(48, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_BARRACUDA_HQ_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_1, new WorldPoint(2276, 2598, 0), null, 38),
	TASK_49(49, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_ARROW_PASSAGE_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_2, new WorldPoint(2917, 2765, 0), null, 38),
	TASK_50(50, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_TURTLE_BELT_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_3, new WorldPoint(3014, 2556, 0), null, 38),
	TASK_51(51, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_GREAT_CONCH_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_4, new WorldPoint(3282, 2445, 0), null, 38),
	TASK_52(52, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_RAINBOW_REEF_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_5, new WorldPoint(2256, 2312, 0), null, 72),
	TASK_53(53, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_ANGLERFISHS_LIGHT_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_1, new WorldPoint(2766, 2382, 0), null, 38),
	TASK_54(54, SeaChartTaskType.WEATHER, VarbitID.SAILING_CHARTING_WEATHER_TROLL_THE_SKULLHORDE_COMPLETE, -1, NpcID.SAILING_CHARTING_WEATHER_TROLL, new WorldPoint(2542, 2541, 0), new WorldPoint(2732, 2641, 0), 57),
	TASK_55(55, SeaChartTaskType.WEATHER, VarbitID.SAILING_CHARTING_WEATHER_TROLL_BARRACUDA_BELT_COMPLETE, -1, NpcID.SAILING_CHARTING_WEATHER_TROLL, new WorldPoint(2082, 2590, 0), new WorldPoint(2154, 2440, 0), 57),
	TASK_56(56, SeaChartTaskType.WEATHER, VarbitID.SAILING_CHARTING_WEATHER_TROLL_ARROW_PASSAGE_COMPLETE, -1, NpcID.SAILING_CHARTING_WEATHER_TROLL, new WorldPoint(2903, 2698, 0), new WorldPoint(2869, 2805, 0), 57),
	TASK_57(57, SeaChartTaskType.WEATHER, VarbitID.SAILING_CHARTING_WEATHER_TROLL_STORM_TEMPOR_COMPLETE, -1, NpcID.SAILING_CHARTING_WEATHER_TROLL, new WorldPoint(2979, 2905, 0), new WorldPoint(3062, 2862, 0), 57),
	TASK_58(58, SeaChartTaskType.WEATHER, VarbitID.SAILING_CHARTING_WEATHER_TROLL_GREAT_CONCH_COMPLETE, -1, NpcID.SAILING_CHARTING_WEATHER_TROLL, new WorldPoint(3321, 2327, 0), new WorldPoint(3177, 2456, 0), 57),
	TASK_59(59, SeaChartTaskType.WEATHER, VarbitID.SAILING_CHARTING_WEATHER_TROLL_ANGLERFISHS_LIGHT_COMPLETE, -1, NpcID.SAILING_CHARTING_WEATHER_TROLL, new WorldPoint(2864, 2311, 0), new WorldPoint(2789, 2193, 0), 57),
	TASK_60(60, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_SPINNERS_GASP_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2677, 2654, 0), null, 12),
	TASK_61(61, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_BARRACUDA_BREW_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2282, 2506, 0), null, 12),
	TASK_62(62, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_BANANA_DAIQUIRI_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2816, 2733, 0), null, 12),
	TASK_63(63, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_KHARAZI_COOLER_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2888, 2857, 0), null, 12),
	TASK_64(64, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_DOGNOSE_DRAUGHT_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(3046, 2665, 0), null, 12),
	TASK_65(65, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_WAY_HOME_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(3098, 2458, 0), null, 12),
	TASK_66(66, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_PLATINUM_RUM_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2205, 2303, 0), null, 72),
	TASK_67(67, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_LIGHT_DARK_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2840, 2280, 0), null, 12),
	TASK_68(68, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_THE_SIMIAN_SEA_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2691, 2703, 0), new WorldPoint(2807, 2700, 0), 22),
	TASK_69(69, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_PEST_ISLAND_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2665, 2560, 0), new WorldPoint(2654, 2610, 0), 22),
	TASK_70(70, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_KHARAZI_STRAIT_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2767, 2895, 0), new WorldPoint(2764, 2994, 0), 22),
	TASK_71(71, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_RED_REEF_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2902, 2548, 0), new WorldPoint(2906, 2494, 0), 22),
	TASK_72(72, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_STORM_TEMPOR_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(3001, 2847, 0), new WorldPoint(3058, 2833, 0), 24),
	TASK_73(73, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_GREAT_CONCH_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(3204, 2367, 0), new WorldPoint(3279, 2398, 0), 22),
	TASK_74(74, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_RAINBOW_REEF_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2335, 2286, 0), new WorldPoint(2330, 2285, 0), 72),
	TASK_75(75, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_THE_LONELY_SEA_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2624, 2415, 0), new WorldPoint(2534, 2515, 0), 22),
	TASK_76(76, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_VOID_KNIGHTS_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2654, 2682, 0), null, 1),
	TASK_77(77, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_MONKEY_TEMPLE_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2828, 2785, 0), null, 1),
	TASK_78(78, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_KHARAZI_CAVE_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2945, 2878, 0), null, 24),
	TASK_79(79, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_DOGNOSE_ISLAND_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(3050, 2656, 0), null, 40),
	TASK_80(80, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_UNKAH_SHIP_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(3144, 2854, 0), null, 24),
	TASK_81(81, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_TORTUGAN_VILLAGE_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(3187, 2430, 0), null, 45),
	TASK_82(82, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_CONCH_MOUNTAIN_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(3154, 2548, 0), null, 1),
	TASK_83(83, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_ANGLERFISHS_LIGHTHOUSE_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2895, 2326, 0), null, 1),
	TASK_84(84, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_ATOLL_CAPE_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_ATOLL_CAPE, -1, new WorldPoint(2681, 2714, 0), null, 1),
	TASK_85(85, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_BANANA_BOAT_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_BANANA_BOAT, -1, new WorldPoint(2693, 2793, 0), null, 1),
	TASK_86(86, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_DEAD_SHIFTER_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_DEAD_SHIFTER, -1, new WorldPoint(2804, 2460, 0), null, 1),
	TASK_87(87, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_PEST_SHIPWRECK_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_PEST_SHIPWRECK, -1, new WorldPoint(2587, 2593, 0), null, 1),
	TASK_88(88, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_BARRACUDA_ROPE_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_BARRACUDA_ROPE, -1, new WorldPoint(2149, 2615, 0), null, 1),
	TASK_89(89, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_BARRACUDA_PORTION_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_BARRACUDA_PORTION, -1, new WorldPoint(2281, 2447, 0), null, 1),
	TASK_90(90, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_GLIDER_KHARAZI_STRAIT_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_GLIDER_KHARAZI_STRAIT, -1, new WorldPoint(2781, 2815, 0), null, 1),
	TASK_91(91, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_SEA_MONKEYS_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_SEA_MONKEYS, -1, new WorldPoint(2881, 2750, 0), null, 1),
	TASK_92(92, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_MAP_BOTTLE_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_MAP_BOTTLE, -1, new WorldPoint(2798, 2891, 0), null, 1),
	TASK_93(93, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_RAPIDLESS_RAPID_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_RAPIDLESS_RAPID, -1, new WorldPoint(2843, 2837, 0), null, 1),
	TASK_94(94, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_TREASURE_CHEST_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_TREASURE_CHEST, -1, new WorldPoint(3075, 2601, 0), null, 1),
	TASK_95(95, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_CRAB_STATUE_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_CRAB_STATUE, -1, new WorldPoint(2066, 2608, 0), null, 1),
	TASK_96(96, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_DESERT_TROUT_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_DESERT_TROUT, -1, new WorldPoint(3033, 2796, 0), null, 24),
	TASK_97(97, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_LIGHTNING_ROD_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_LIGHTNING_ROD, -1, new WorldPoint(3065, 2885, 0), null, 24),
	TASK_98(98, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_MINOR_CONCH_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_MINOR_CONCH, -1, new WorldPoint(3284, 2514, 0), null, 1),
	TASK_99(99, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_CRAB_APPLE_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_CRAB_APPLE, -1, new WorldPoint(3216, 2466, 0), null, 45),
	TASK_100(100, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_GNOME_BALL_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_GNOME_BALL, -1, new WorldPoint(2336, 2267, 0), null, 72),
	TASK_101(101, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_EDGE_BOAT_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_EDGE_BOAT, -1, new WorldPoint(2334, 2118, 0), null, 72),
	TASK_102(102, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_DRAGON_SCALES_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_DRAGON_SCALES, -1, new WorldPoint(2634, 2392, 0), null, 1),
	TASK_103(103, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_LARGE_LIGHT_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_LARGE_LIGHT, -1, new WorldPoint(2719, 2296, 0), null, 1),
	TASK_104(104, SeaChartTaskType.WEATHER, VarbitID.SAILING_CHARTING_WEATHER_TROLL_GUTANOTH_BAY_COMPLETE, -1, NpcID.SAILING_CHARTING_WEATHER_TROLL, new WorldPoint(2638, 3009, 0), new WorldPoint(2618, 2879, 0), 57),
	TASK_105(105, SeaChartTaskType.WEATHER, VarbitID.SAILING_CHARTING_WEATHER_TROLL_BREAKBONE_STRAIT_COMPLETE, -1, NpcID.SAILING_CHARTING_WEATHER_TROLL, new WorldPoint(2335, 2921, 0), new WorldPoint(2473, 2725, 0), 57),
	TASK_106(106, SeaChartTaskType.WEATHER, VarbitID.SAILING_CHARTING_WEATHER_TROLL_SOUL_BAY_COMPLETE, -1, NpcID.SAILING_CHARTING_WEATHER_TROLL, new WorldPoint(2140, 2806, 0), new WorldPoint(2021, 2681, 0), 57),
	TASK_107(107, SeaChartTaskType.WEATHER, VarbitID.SAILING_CHARTING_WEATHER_TROLL_ZUL_EGIL_COMPLETE, -1, NpcID.SAILING_CHARTING_WEATHER_TROLL, new WorldPoint(2149, 3068, 0), new WorldPoint(2253, 2987, 0), 66),
	TASK_108(108, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_OGRE_ISLAND_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2597, 3027, 0), null, 1),
	TASK_109(109, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_COVE_THRONE_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2605, 2867, 0), null, 1),
	TASK_110(110, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_MYTHS_GUILD_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2429, 2852, 0), null, 40),
	TASK_111(111, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_CAPE_SOUL_ISLAND_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2342, 2768, 0), null, 61),
	TASK_112(112, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_TOAD_PONDS_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2399, 3027, 0), null, 40),
	TASK_113(113, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_RUINED_TOWER_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2128, 2983, 0), null, 1),
	TASK_114(114, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_ZUL_ANDRA_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2199, 3036, 0), null, 40),
	TASK_115(115, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_OGRE_PRAYER_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2624, 3069, 0), null, 12),
	TASK_116(116, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_POINT_PUNCH_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2691, 2940, 0), null, 12),
	TASK_117(117, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_OOGLUG_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2595, 2787, 0), null, 12),
	TASK_118(118, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_MYTHS_MIXER_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2556, 2664, 0), null, 12),
	TASK_119(119, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_GOLDLESS_ALE_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2334, 2781, 0), null, 40),
	TASK_120(120, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_DESTRUCTORS_COCKTAIL_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2318, 2966, 0), null, 40),
	TASK_121(121, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_ZOGRES_KISS_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2476, 2969, 0), null, 40),
	TASK_122(122, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_CREATORS_COCKTAIL_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2086, 2882, 0), null, 12),
	TASK_123(123, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_SOUL_BOTTLE_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2221, 2765, 0), null, 12),
	TASK_124(124, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_ZUL_RYE_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2279, 3036, 0), null, 40),
	TASK_125(125, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_GUTANOTH_BAY_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_2, new WorldPoint(2676, 3035, 0), null, 38),
	TASK_126(126, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_OOGLOG_CHANNEL_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_3, new WorldPoint(2529, 2829, 0), null, 38),
	TASK_127(127, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_MYTHIC_SEA_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_4, new WorldPoint(2446, 2784, 0), null, 40),
	TASK_128(128, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_BACKWATER_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_5, new WorldPoint(2469, 3006, 0), null, 40),
	TASK_129(129, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_SOUL_BAY_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_1, new WorldPoint(2012, 2874, 0), null, 38),
	TASK_130(130, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_FELDIP_GULF_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2645, 2974, 0), new WorldPoint(2749, 2971, 0), 22),
	TASK_131(131, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_MYTHIC_SEA_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2495, 2708, 0), new WorldPoint(2533, 2736, 0), 40),
	TASK_132(132, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_BREAKBONE_STRAIT_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2340, 2896, 0), new WorldPoint(2456, 2895, 0), 40),
	TASK_133(133, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_SOUL_BAY_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2080, 2859, 0), new WorldPoint(2102, 2816, 0), 22),
	TASK_134(134, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_BACKWATER_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2318, 3057, 0), new WorldPoint(2233, 3028, 0), 40),
	TASK_135(135, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_OGRE_BOAT_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_OGRE_BOAT, -1, new WorldPoint(2633, 3039, 0), null, 1),
	TASK_136(136, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_FELDIP_RIDGE_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_FELDIP_RIDGE, -1, new WorldPoint(2695, 2981, 0), null, 1),
	TASK_137(137, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_DEAD_MONSTER_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_DEAD_MONSTER, -1, new WorldPoint(2634, 2882, 0), null, 1),
	TASK_138(138, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_ABANDONED_CAMP_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_ABANDONED_CAMP, -1, new WorldPoint(2476, 2707, 0), null, 51),
	TASK_139(139, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_SOUL_SHIPWRECK_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_SOUL_SHIPWRECK, -1, new WorldPoint(2289, 2712, 0), null, 1),
	TASK_140(140, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_ARMY_ATTIRE_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_ARMY_ATTIRE, -1, new WorldPoint(2460, 2881, 0), null, 40),
	TASK_141(141, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_DISEASED_CORAL_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_DISEASED_CORAL, -1, new WorldPoint(2300, 3043, 0), null, 40),
	TASK_142(142, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_SNAKE_EGGS_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_SNAKE_EGGS, -1, new WorldPoint(1996, 2947, 0), null, 1),
	TASK_143(143, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_LARGE_JELLYFISH_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_LARGE_JELLYFISH, -1, new WorldPoint(2089, 2797, 0), null, 1),
	TASK_144(144, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_POISON_SPILL_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_POISON_SPILL, -1, new WorldPoint(2165, 3030, 0), null, 40),
	TASK_145(145, SeaChartTaskType.WEATHER, VarbitID.SAILING_CHARTING_WEATHER_TROLL_TIRANNWN_BIGHT_COMPLETE, -1, NpcID.SAILING_CHARTING_WEATHER_TROLL, new WorldPoint(2130, 3395, 0), new WorldPoint(2041, 3328, 0), 66),
	TASK_146(146, SeaChartTaskType.WEATHER, VarbitID.SAILING_CHARTING_WEATHER_TROLL_PORTH_NEIGWL_COMPLETE, -1, NpcID.SAILING_CHARTING_WEATHER_TROLL, new WorldPoint(2118, 3159, 0), new WorldPoint(2028, 3220, 0), 66),
	TASK_147(147, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_WESTERN_GATE_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(1978, 3106, 0), new WorldPoint(1951, 3046, 0), 22),
	TASK_148(148, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_PORTH_NEIGWL_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2071, 3186, 0), new WorldPoint(2161, 3150, 0), 66),
	TASK_149(149, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_TIRANNWN_BIGHT_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2165, 3260, 0), new WorldPoint(2163, 3367, 0), 66),
	TASK_150(150, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_TYRAS_CAMP_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2160, 3155, 0), null, 66),
	TASK_151(151, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_PRIFDDINAS_GATE_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2163, 3318, 0), null, 66),
	TASK_152(152, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_WESTERN_GATE_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_2, new WorldPoint(2041, 3023, 0), null, 38),
	TASK_153(153, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_CRYSTAL_SEA_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_3, new WorldPoint(1979, 3211, 0), null, 38),
	TASK_154(154, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_PORTH_NEIGWL_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_4, new WorldPoint(2113, 3123, 0), null, 66),
	TASK_155(155, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_SAPPHIRE_SEA_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_5, new WorldPoint(1762, 2611, 0), null, 38),
	TASK_156(156, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_TIRANNWN_BIGHT_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_1, new WorldPoint(2120, 3345, 0), null, 66),
	TASK_157(157, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_SHARHAIS_PURSE_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_SHARHAIS_PURSE, -1, new WorldPoint(1947, 2985, 0), null, 1),
	TASK_158(158, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_ELVEN_SHIP_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_ELVEN_SHIP, -1, new WorldPoint(1980, 3232, 0), null, 1),
	TASK_159(159, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_HALBERD_POLES_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_HALBERD_POLES, -1, new WorldPoint(2118, 3158, 0), null, 66),
	TASK_160(160, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_RIVER_MINE_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_RIVER_MINE, -1, new WorldPoint(2157, 3274, 0), null, 66),
	TASK_161(161, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_HALF_BUILT_SHIP_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_HALF_BUILT_SHIP, -1, new WorldPoint(2026, 3669, 0), null, 1),
	TASK_162(162, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_MANGO_GIN_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(1993, 2972, 0), null, 12),
	TASK_163(163, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_SNAKE_GRAVY_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2008, 3261, 0), null, 12),
	TASK_164(164, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_CRYSTAL_WATER_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2161, 3203, 0), null, 66),
	TASK_165(165, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_UNDERGROUND_MILK_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2206, 3484, 0), null, 66),
	TASK_166(166, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_ELVEN_WINE_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2120, 3418, 0), null, 66),
	TASK_167(167, SeaChartTaskType.WEATHER, VarbitID.SAILING_CHARTING_WEATHER_TROLL_VAGABONDS_REST_COMPLETE, -1, NpcID.SAILING_CHARTING_WEATHER_TROLL, new WorldPoint(2280, 3518, 0), new WorldPoint(2118, 3587, 0), 66),
	TASK_168(168, SeaChartTaskType.WEATHER, VarbitID.SAILING_CHARTING_WEATHER_TROLL_PILGRIMS_PASSAGE_COMPLETE, -1, NpcID.SAILING_CHARTING_WEATHER_TROLL, new WorldPoint(1867, 3458, 0), new WorldPoint(1852, 3532, 0), 57),
	TASK_169(169, SeaChartTaskType.WEATHER, VarbitID.SAILING_CHARTING_WEATHER_TROLL_WINTERS_EDGE_COMPLETE, -1, NpcID.SAILING_CHARTING_WEATHER_TROLL, new WorldPoint(1817, 3965, 0), new WorldPoint(1866, 3826, 0), 78),
	TASK_170(170, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_PORTH_GWENITH_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_2, new WorldPoint(2283, 3459, 0), null, 66),
	TASK_171(171, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_PISCATORIS_SEA_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_3, new WorldPoint(2236, 3593, 0), null, 66),
	TASK_172(172, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_GULF_OF_KOUREND_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_4, new WorldPoint(1851, 3668, 0), null, 38),
	TASK_173(173, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_PORTH_GWENITH_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2220, 3429, 0), new WorldPoint(2205, 3462, 0), 66),
	TASK_174(174, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_PILGRIMS_PASSAGE_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(1871, 3430, 0), new WorldPoint(1791, 3414, 0), 22),
	TASK_175(175, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_GULF_OF_KOUREND_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(1813, 3664, 0), new WorldPoint(1831, 3697, 0), 22),
	TASK_176(176, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_WINTERS_EDGE_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(1866, 3911, 0), new WorldPoint(2054, 3889, 0), 78),
	TASK_177(177, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_FISHING_COLONY_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2303, 3700, 0), null, 1),
	TASK_178(178, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_TITHE_FARM_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(1861, 3528, 0), null, 1),
	TASK_179(179, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_PORT_PISCARILIUS_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(1846, 3769, 0), null, 1),
	TASK_180(180, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_RIVER_OF_SOULS_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(1793, 3978, 0), null, 78),
	TASK_181(181, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_SEA_SPRAY_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2079, 3655, 0), null, 12),
	TASK_182(182, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_BANKERS_DRAUGHT_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(1887, 3556, 0), null, 12),
	TASK_183(183, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_HEADLESS_UNICORNMAN_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(1934, 3742, 0), null, 12),
	TASK_184(184, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_SOUL_JUICE_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(1898, 4069, 0), null, 78),
	TASK_185(185, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_CRYSTAL_DINGHY_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_CRYSTAL_DINGHY, -1, new WorldPoint(2210, 3445, 0), null, 66),
	TASK_186(186, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_HUNTER_OUTFITS_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_HUNTER_OUTFITS, -1, new WorldPoint(2133, 3589, 0), null, 66),
	TASK_187(187, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_KRAKEN_SLIME_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_KRAKEN_SLIME, -1, new WorldPoint(2300, 3662, 0), null, 1),
	TASK_188(188, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_DISCARDED_PLOUGH_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_DISCARDED_PLOUGH, -1, new WorldPoint(1855, 3586, 0), null, 1),
	TASK_189(189, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_BROKEN_CRANE_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_BROKEN_CRANE, -1, new WorldPoint(1847, 3796, 0), null, 1),
	TASK_190(190, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_TOAD_SPAWN_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_TOAD_SPAWN, -1, new WorldPoint(1762, 4005, 0), null, 78),
	TASK_191(191, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_MENAPHOS_PYRAMID_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(3145, 2734, 0), null, 1),
	TASK_192(192, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_MENAPHITE_SEA_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_5, new WorldPoint(3044, 2722, 0), null, 38),
	TASK_193(193, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_SAND_PIT_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_SAND_PIT, -1, new WorldPoint(3143, 2770, 0), null, 1),
	TASK_194(194, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_MENAPHITE_SEA_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(3185, 2654, 0), new WorldPoint(3146, 2599, 0), 22),
	TASK_195(195, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_CROCODILE_TEARS_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(3190, 2706, 0), null, 12),
	TASK_196(196, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_CRAB_EYES_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_CRAB_EYES, -1, new WorldPoint(2587, 3657, 0), null, 1),
	TASK_197(197, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_TREE_ROOTS_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_TREE_ROOTS, -1, new WorldPoint(2479, 3546, 0), null, 1),
	TASK_198(198, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_GHRIM_SIGN_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_GHRIM_SIGN, -1, new WorldPoint(2528, 3818, 0), null, 1),
	TASK_199(199, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_NEDS_BOOK_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_NEDS_BOOK, -1, new WorldPoint(2383, 3769, 0), null, 1),
	TASK_200(200, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_KEBBIT_BURROW_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_KEBBIT_BURROW, -1, new WorldPoint(2726, 3855, 0), null, 78),
	TASK_201(201, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_MAGIC_WARDS_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_MAGIC_WARDS, -1, new WorldPoint(2225, 3892, 0), null, 1),
	TASK_202(202, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_DEAD_LIVID_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_DEAD_LIVID, -1, new WorldPoint(2083, 3953, 0), null, 78),
	TASK_203(203, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_LUNAR_BROOMS_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_LUNAR_BROOMS, -1, new WorldPoint(2144, 4067, 0), null, 78),
	TASK_204(204, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_FEARLESS_FREMENNIK_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_FEARLESS_FREMENNIK, -1, new WorldPoint(2426, 3961, 0), null, 78),
	TASK_205(205, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_DISCARDED_SLED_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_DISCARDED_SLED, -1, new WorldPoint(2783, 3882, 0), null, 78),
	TASK_206(206, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_SHARK_CORPSE_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_SHARK_CORPSE, -1, new WorldPoint(2587, 3919, 0), null, 78),
	TASK_207(207, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_KGP_PERISCOPE_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_KGP_PERISCOPE, -1, new WorldPoint(2709, 4124, 0), null, 78),
	TASK_208(208, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_ICE_SHIP_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_ICE_SHIP, -1, new WorldPoint(2902, 3965, 0), null, 78),
	TASK_209(209, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_FREMENSUND_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2561, 3626, 0), new WorldPoint(2484, 3628, 0), 22),
	TASK_210(210, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_GRANDROOT_BAY_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2369, 3507, 0), new WorldPoint(2404, 3591, 0), 22),
	TASK_211(211, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_VS_BELT_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2428, 3831, 0), new WorldPoint(2520, 3771, 0), 22),
	TASK_212(212, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_FREMENNIK_STRAIT_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2305, 3795, 0), new WorldPoint(2340, 3875, 0), 22),
	TASK_213(213, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_IDESTIA_STRAIT_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2695, 3828, 0), new WorldPoint(2716, 3757, 0), 22),
	TASK_214(214, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_LUNAR_BAY_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2159, 3849, 0), new WorldPoint(2202, 3799, 0), 22),
	TASK_215(215, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_EVERWINTER_SEA_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(1792, 4137, 0), new WorldPoint(1783, 4086, 0), 78),
	TASK_216(216, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_KANNSKI_TIDES_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2316, 3903, 0), new WorldPoint(2277, 4028, 0), 78),
	TASK_217(217, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_WEISSMERE_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2833, 3960, 0), new WorldPoint(2801, 3887, 0), 78),
	TASK_218(218, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_STONEHEART_SEA_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2433, 4006, 0), new WorldPoint(2459, 3996, 0), 78),
	TASK_219(219, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_WEISS_MELT_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2880, 3985, 0), new WorldPoint(2919, 4058, 0), 78),
	TASK_220(220, SeaChartTaskType.WEATHER, VarbitID.SAILING_CHARTING_WEATHER_TROLL_FREMENSUND_COMPLETE, -1, NpcID.SAILING_CHARTING_WEATHER_TROLL, new WorldPoint(2594, 3644, 0), new WorldPoint(2513, 3738, 0), 57),
	TASK_221(221, SeaChartTaskType.WEATHER, VarbitID.SAILING_CHARTING_WEATHER_TROLL_GRANDROOT_BAY_COMPLETE, -1, NpcID.SAILING_CHARTING_WEATHER_TROLL, new WorldPoint(2498, 3546, 0), new WorldPoint(2439, 3625, 0), 57),
	TASK_222(222, SeaChartTaskType.WEATHER, VarbitID.SAILING_CHARTING_WEATHER_TROLL_FREMENNIK_STRAIT_COMPLETE, -1, NpcID.SAILING_CHARTING_WEATHER_TROLL, new WorldPoint(2341, 3790, 0), new WorldPoint(2426, 3841, 0), 57),
	TASK_223(223, SeaChartTaskType.WEATHER, VarbitID.SAILING_CHARTING_WEATHER_TROLL_IDESTIA_STRAIT_COMPLETE, -1, NpcID.SAILING_CHARTING_WEATHER_TROLL, new WorldPoint(2600, 3910, 0), new WorldPoint(2625, 3795, 0), 78),
	TASK_224(224, SeaChartTaskType.WEATHER, VarbitID.SAILING_CHARTING_WEATHER_TROLL_EVERWINTER_SEA_COMPLETE, -1, NpcID.SAILING_CHARTING_WEATHER_TROLL, new WorldPoint(1959, 4065, 0), new WorldPoint(2045, 4128, 0), 78),
	TASK_225(225, SeaChartTaskType.WEATHER, VarbitID.SAILING_CHARTING_WEATHER_TROLL_STONEHEART_SEA_COMPLETE, -1, NpcID.SAILING_CHARTING_WEATHER_TROLL, new WorldPoint(2447, 3995, 0), new WorldPoint(2371, 4058, 0), 78),
	TASK_226(226, SeaChartTaskType.WEATHER, VarbitID.SAILING_CHARTING_WEATHER_TROLL_SHIVERWAKE_EXPANSE_COMPLETE, -1, NpcID.SAILING_CHARTING_WEATHER_TROLL, new WorldPoint(2793, 4020, 0), new WorldPoint(2784, 4108, 0), 78),
	TASK_227(227, SeaChartTaskType.WEATHER, VarbitID.SAILING_CHARTING_WEATHER_TROLL_WEISS_MELT_COMPLETE, -1, NpcID.SAILING_CHARTING_WEATHER_TROLL, new WorldPoint(2951, 3962, 0), new WorldPoint(2866, 4020, 0), 78),
	TASK_228(228, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_FREMENSUND_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2636, 3707, 0), null, 1),
	TASK_229(229, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_GRANDROOT_BAY_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2504, 3612, 0), null, 1),
	TASK_230(230, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_VS_BELT_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2477, 3862, 0), null, 1),
	TASK_231(231, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_FREMENNIK_STRAIT_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2366, 3777, 0), null, 1),
	TASK_232(232, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_IDESTIA_STRAIT_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2636, 3874, 0), null, 1),
	TASK_233(233, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_LUNAR_BAY_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2160, 3901, 0), null, 1),
	TASK_234(234, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_WINTERS_EDGE_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2051, 3913, 0), null, 1),
	TASK_235(235, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_LUNAR_SEA_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2237, 4064, 0), null, 78),
	TASK_236(236, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_KANNSKI_TIDES_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2351, 3904, 0), null, 78),
	TASK_237(237, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_WEISSMERE_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2781, 3987, 0), null, 78),
	TASK_238(238, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_STONEHEART_SEA_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2620, 4059, 0), null, 78),
	TASK_239(239, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_SHIVERWAKE_EXPANSE_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2879, 4078, 0), null, 78),
	TASK_240(240, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_WEISS_MELT_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2990, 3971, 0), null, 78),
	TASK_241(241, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_FREMENSUND_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_1, new WorldPoint(2518, 3690, 0), null, 38),
	TASK_242(242, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_GRANDROOT_BAY_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_2, new WorldPoint(2513, 3571, 0), null, 38),
	TASK_243(243, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_VS_BELT_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_3, new WorldPoint(2505, 3892, 0), null, 78),
	TASK_244(244, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_IDESTIA_STRAIT_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_4, new WorldPoint(2664, 3954, 0), null, 78),
	TASK_245(245, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_LUNAR_BAY_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_5, new WorldPoint(2221, 3833, 0), null, 38),
	TASK_246(246, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_WINTERS_EDGE_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_1, new WorldPoint(1970, 3966, 0), null, 78),
	TASK_247(247, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_LUNAR_SEA_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_2, new WorldPoint(2061, 4118, 0), null, 78),
	TASK_248(248, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_EVERWINTER_SEA_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_3, new WorldPoint(1823, 4018, 0), null, 78),
	TASK_249(249, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_KANNSKI_TIDES_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_4, new WorldPoint(2357, 3977, 0), null, 78),
	TASK_250(250, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_WEISSMERE_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_5, new WorldPoint(2816, 3975, 0), null, 78),
	TASK_251(251, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_STONEHEART_SEA_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_1, new WorldPoint(2475, 4133, 0), null, 78),
	TASK_252(252, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_SHIVERWAKE_EXPANSE_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_2, new WorldPoint(2824, 4092, 0), null, 78),
	TASK_253(253, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_FISHIER_STOUT_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2689, 3732, 0), null, 12),
	TASK_254(254, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_TOAD_CIDER_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2453, 3597, 0), null, 12),
	TASK_255(255, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_BLUE_LAGOON_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2474, 3798, 0), null, 12),
	TASK_256(256, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_FISHTONGUE_TONIC_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2273, 3745, 0), null, 12),
	TASK_257(257, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_ENDLESS_NIGHT_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2651, 3811, 0), null, 12),
	TASK_258(258, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_EXILES_WELCOME_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2142, 3874, 0), null, 12),
	TASK_259(259, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_SUQAH_COLA_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2113, 4142, 0), null, 78),
	TASK_260(260, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_WINTER_SUN_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(1757, 4150, 0), null, 78),
	TASK_261(261, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_BLACK_LOBSTER_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2359, 3878, 0), null, 12),
	TASK_262(262, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_DWARVERN_WIZARD_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2775, 3935, 0), null, 78),
	TASK_263(263, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_KGP_MARTINI_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2612, 4146, 0), null, 78),
	TASK_264(264, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_CORPSE_REVIVER_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2785, 4046, 0), null, 78),
	TASK_265(265, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_WEISS_MELTWATER_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2912, 4154, 0), null, 78),
	TASK_266(266, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_TURTLE_BELT_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2947, 2584, 0), new WorldPoint(2969, 2610, 0), 22),
	TASK_267(267, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_BAY_OF_ELIDINIS_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(3248, 2703, 0), new WorldPoint(3275, 2748, 0), 22),
	TASK_268(268, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_TORTUGAN_SEA_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(3279, 2463, 0), new WorldPoint(3403, 2509, 0), 22),
	TASK_269(269, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_PEARL_BANK_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(3337, 2179, 0), new WorldPoint(3414, 2134, 0), 22),
	TASK_270(270, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_TORTUGAN_SEA_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(3261, 2506, 0), null, 1),
	TASK_271(271, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_SEA_OF_SHELLS_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_3, new WorldPoint(2963, 2203, 0), null, 38),
	TASK_272(272, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_BAY_OF_ELIDINIS_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_4, new WorldPoint(3338, 2622, 0), null, 38),
	TASK_273(273, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_PEARL_BANK_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_5, new WorldPoint(3276, 2130, 0), null, 38),
	TASK_274(274, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_THE_LONELY_SEA_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_1, new WorldPoint(2528, 2149, 0), null, 38),
	TASK_275(275, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_BIRD_NEST_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_BIRD_NEST, -1, new WorldPoint(2963, 2264, 0), null, 47),
	TASK_276(276, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_GOLEM_CORPSE_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_GOLEM_CORPSE, -1, new WorldPoint(3243, 2702, 0), null, 1),
	TASK_277(277, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_SHIP_BOTTLE_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_SHIP_BOTTLE, -1, new WorldPoint(3375, 2135, 0), null, 1),
	TASK_278(278, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_REDDEST_RUM_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2778, 2523, 0), null, 12),
	TASK_279(279, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_LIFE_WATER_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(3239, 2598, 0), null, 12),
	TASK_280(280, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_POSSIBLE_ALBUMEN_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(3301, 2146, 0), null, 12),
	TASK_281(281, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_ALONE_AT_SEA_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2522, 2248, 0), null, 12),
	TASK_282(282, SeaChartTaskType.WEATHER, VarbitID.SAILING_CHARTING_WEATHER_TROLL_AUREUM_COAST_COMPLETE, -1, NpcID.SAILING_CHARTING_WEATHER_TROLL, new WorldPoint(1779, 2940, 0), new WorldPoint(1802, 2808, 0), 57),
	TASK_283(283, SeaChartTaskType.WEATHER, VarbitID.SAILING_CHARTING_WEATHER_TROLL_THE_EVERDEEP_COMPLETE, -1, NpcID.SAILING_CHARTING_WEATHER_TROLL, new WorldPoint(1928, 2791, 0), new WorldPoint(1895, 2665, 0), 57),
	TASK_284(284, SeaChartTaskType.WEATHER, VarbitID.SAILING_CHARTING_WEATHER_TROLL_SOUTHERN_EXPANSE_COMPLETE, -1, NpcID.SAILING_CHARTING_WEATHER_TROLL, new WorldPoint(1881, 2445, 0), new WorldPoint(1813, 2191, 0), 72),
	TASK_285(285, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_FORTIS_BAY_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(1823, 3046, 0), null, 1),
	TASK_286(286, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_AUREUM_COAST_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(1737, 2907, 0), null, 1),
	TASK_287(287, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_WYRMS_WATERS_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(1634, 2883, 0), null, 1),
	TASK_288(288, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_THE_EVERDEEP_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(1943, 2737, 0), null, 1),
	TASK_289(289, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_SAPPHIRE_SEA_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(1796, 2664, 0), null, 1),
	TASK_290(290, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_ALCO_SOL_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(1826, 2957, 0), null, 12),
	TASK_291(291, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_PORTAL_PERRY_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(1762, 2854, 0), null, 12),
	TASK_292(292, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_CONGRATULATION_WINE_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(1570, 2808, 0), null, 12),
	TASK_293(293, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_FISH_STOUTIER_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2387, 2477, 0), null, 12),
	TASK_294(294, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_CRYSTAL_VODKA_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(1854, 2771, 0), null, 12),
	TASK_295(295, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_COMP_KVASS_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(1675, 2478, 0), null, 12),
	TASK_296(296, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_PUZZLERS_POTEEN_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(1821, 2439, 0), null, 72),
	TASK_297(297, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_SEAGULL_NEST_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_SEAGULL_NEST, -1, new WorldPoint(1896, 2994, 0), null, 1),
	TASK_298(298, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_WRECK_WEIGHT_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_WRECK_WEIGHT, -1, new WorldPoint(1845, 2824, 0), null, 1),
	TASK_299(299, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_ATOLL_DICTIONARY_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_ATOLL_DICTIONARY, -1, new WorldPoint(1593, 2755, 0), null, 1),
	TASK_300(300, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_SCARY_SHADOW_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_SCARY_SHADOW, -1, new WorldPoint(1976, 2680, 0), null, 1),
	TASK_301(301, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_SEA_SAPPHIRES_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_SEA_SAPPHIRES, -1, new WorldPoint(1762, 2580, 0), null, 1),
	TASK_302(302, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_NOTHING_SIGN_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_NOTHING_SIGN, -1, new WorldPoint(1828, 2138, 0), null, 72),
	TASK_303(303, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_FORTIS_BAY_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(1779, 2988, 0), new WorldPoint(1900, 2984, 0), 22),
	TASK_304(304, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_WYRMS_WATERS_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(1543, 2785, 0), new WorldPoint(1583, 2773, 0), 22),
	TASK_305(305, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_THE_SKULLHORDE_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2488, 2530, 0), new WorldPoint(2367, 2521, 0), 22),
	TASK_306(306, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_SAPPHIRE_SEA_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(1745, 2662, 0), new WorldPoint(1695, 2662, 0), 22),
	TASK_307(307, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_FORTIS_BAY_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_2, new WorldPoint(1898, 3048, 0), null, 38),
	TASK_308(308, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_AUREUM_COAST_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_3, new WorldPoint(1889, 2882, 0), null, 38),
	TASK_309(309, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_WYRMS_WATERS_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_4, new WorldPoint(1711, 2818, 0), null, 38),
	TASK_310(310, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_THE_SKULLHORDE_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_5, new WorldPoint(2460, 2449, 0), null, 38),
	TASK_311(311, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_SEA_OF_SOULS_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_1, new WorldPoint(2118, 2716, 0), null, 38),
	TASK_312(312, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_THE_EVERDEEP_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_2, new WorldPoint(1942, 2650, 0), null, 38),
	TASK_313(313, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_SOUTHERN_EXPANSE_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_3, new WorldPoint(2057, 2317, 0), null, 72),
	TASK_314(314, SeaChartTaskType.WEATHER, VarbitID.SAILING_CHARTING_WEATHER_TROLL_CRABCLAW_BAY_COMPLETE, -1, NpcID.SAILING_CHARTING_WEATHER_TROLL, new WorldPoint(1651, 3461, 0), new WorldPoint(1579, 3365, 0), 57),
	TASK_315(315, SeaChartTaskType.WEATHER, VarbitID.SAILING_CHARTING_WEATHER_TROLL_LITUS_LUCIS_COMPLETE, -1, NpcID.SAILING_CHARTING_WEATHER_TROLL, new WorldPoint(1714, 3193, 0), new WorldPoint(1895, 3178, 0), 57),
	TASK_316(316, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_GREAT_SOUND_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(1413, 3394, 0), null, 1),
	TASK_317(317, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_CRABCLAW_BAY_1_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(1600, 3310, 0), null, 1),
	TASK_318(318, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_CRABCLAW_BAY_2_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(1744, 3405, 0), null, 1),
	TASK_319(319, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_CRYSTAL_SEA_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(1886, 3266, 0), null, 1),
	TASK_320(320, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_VAGABONDS_REST_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(2101, 3702, 0), null, 1),
	TASK_321(321, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_CRABCLAW_BAY_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_4, new WorldPoint(1681, 3380, 0), null, 38),
	TASK_322(322, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_HOSIDIAN_SEA_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_5, new WorldPoint(1969, 3597, 0), null, 38),
	TASK_323(323, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_PILGRIMS_PASSAGE_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_1, new WorldPoint(1880, 3372, 0), null, 38),
	TASK_324(324, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_LITUS_LUCIS_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_2, new WorldPoint(1821, 3166, 0), null, 38),
	TASK_325(325, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_VAGABONDS_REST_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_3, new WorldPoint(2018, 3705, 0), null, 38),
	TASK_326(326, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_MOONSHADOW_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_4, new WorldPoint(2044, 3792, 0), null, 38),
	TASK_327(327, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_GREAT_SOUND_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(1384, 3465, 0), new WorldPoint(1492, 3448, 0), 22),
	TASK_328(328, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_LITUS_LUCIS_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(1721, 3237, 0), new WorldPoint(1785, 3197, 0), 22),
	TASK_329(329, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_CRYSTAL_SEA_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(1920, 3296, 0), new WorldPoint(2059, 3299, 0), 22),
	TASK_330(330, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_MOONSHADOW_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(2122, 3796, 0), new WorldPoint(2167, 3682, 0), 22),
	TASK_331(331, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_WILD_WHISKY_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(1437, 3430, 0), null, 12),
	TASK_332(332, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_ROBERTS_PORT_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(1926, 3394, 0), null, 12),
	TASK_333(333, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_SEA_SHANDY_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(1783, 3252, 0), null, 12),
	TASK_334(334, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_MONKFISH_STOUT_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2248, 3744, 0), null, 12),
	TASK_335(335, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_LUNARSHINE_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(2030, 3829, 0), null, 12),
	TASK_336(336, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_BEGINNING_SIGN_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_BEGINNING_SIGN, -1, new WorldPoint(1529, 3405, 0), null, 1),
	TASK_337(337, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_BARRACUDA_ADVERT_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_BARRACUDA_ADVERT, -1, new WorldPoint(1656, 3304, 0), null, 1),
	TASK_338(338, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_SABOTAGED_MOORING_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_SABOTAGED_MOORING, -1, new WorldPoint(1789, 3401, 0), null, 1),
	TASK_339(339, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_CHINCHOMPA_TABLE_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_CHINCHOMPA_TABLE, -1, new WorldPoint(1887, 3424, 0), null, 1),
	TASK_340(340, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_KRAKEN_SKELETON_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_KRAKEN_SKELETON, -1, new WorldPoint(1871, 3177, 0), null, 1),
	TASK_341(341, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_JAIL_BOOK_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_JAIL_BOOK, -1, new WorldPoint(1890, 3271, 0), null, 1),
	TASK_342(342, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_LUNAR_WRECK_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_LUNAR_WRECK, -1, new WorldPoint(2170, 3773, 0), null, 1),
	TASK_343(343, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_SUNSET_BAY_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(1470, 2980, 0), null, 1),
	TASK_344(344, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_MISTY_SEA_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(1387, 2840, 0), null, 1),
	TASK_345(345, SeaChartTaskType.WEATHER, VarbitID.SAILING_CHARTING_WEATHER_TROLL_DUSKS_MAW_COMPLETE, -1, NpcID.SAILING_CHARTING_WEATHER_TROLL, new WorldPoint(1188, 2822, 0), new WorldPoint(1184, 3000, 0), 57),
	TASK_346(346, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_SUNSET_BAY_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(1422, 3046, 0), new WorldPoint(1387, 3148, 0), 22),
	TASK_347(347, SeaChartTaskType.CURRENT_DUCK, VarbitID.SAILING_CHARTING_CURRENT_DUCK_DUSKS_MAW_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_DUCK, -1, new WorldPoint(1259, 2876, 0), new WorldPoint(1104, 2900, 0), 22),
	TASK_348(348, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_SUNSET_BAY_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_5, new WorldPoint(1575, 2942, 0), null, 38),
	TASK_349(349, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_MISTY_SEA_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_1, new WorldPoint(1322, 2628, 0), null, 38),
	TASK_350(350, SeaChartTaskType.MERMAID_GUIDE, VarbitID.SAILING_CHARTING_MERMAID_GUIDE_DUSKS_MAW_COMPLETE, -1, NpcID.SAILING_CHARTING_MERMAID_GUIDE_2, new WorldPoint(1314, 2931, 0), null, 38),
	TASK_351(351, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_PROP_WRECK_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_PROP_WRECK, -1, new WorldPoint(1448, 2896, 0), null, 1),
	TASK_352(352, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_FISHING_NETS_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_FISHING_NETS, -1, new WorldPoint(1439, 2716, 0), null, 1),
	TASK_353(353, SeaChartTaskType.GENERIC, VarbitID.SAILING_CHARTING_GENERIC_CRAB_HOLE_COMPLETE, ObjectID.SAILING_CHARTING_GENERIC_CRAB_HOLE, -1, new WorldPoint(1232, 3005, 0), null, 1),
	TASK_354(354, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_DRUNK_IMPLING_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(1426, 2865, 0), null, 12),
	TASK_355(355, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_MYSTERY_CIDER_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(1561, 2655, 0), null, 12),
	TASK_356(356, SeaChartTaskType.DRINK_CRATE, VarbitID.SAILING_CHARTING_DRINK_CRATE_SAILING_CAT_COMPLETE, ObjectID.SAILING_CHARTING_DRINK_CRATE, -1, new WorldPoint(1050, 2886, 0), null, 12),
	TASK_357(357, SeaChartTaskType.SPYGLASS, VarbitID.SAILING_CHARTING_SPYGLASS_CHARTING_TUTOR_COMPLETE, ObjectID.SAILING_CHARTING_HINT_MARKER_SPYGLASS, -1, new WorldPoint(3051, 9388, 0), null, 1),
	;

	private final int taskId;
	private final SeaChartTaskType type;
	private final int completionVarb;
	private final int objectId;
	private final int npcId;
	private final WorldPoint location;
	private final WorldPoint destination;
	private final int level;

	public boolean isComplete(Client client)
	{
		return client.getVarbitValue(getCompletionVarb()) != 0;
	}

}

package com.duckblade.osrs.sailing.features.charting;

import java.awt.image.BufferedImage;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.worldmap.WorldMapPoint;

public class WeatherChartingWorldMapPoint extends WorldMapPoint
{

	public WeatherChartingWorldMapPoint(final WorldPoint worldPoint, BufferedImage icon, String name)
	{
		super(worldPoint, icon);

		setName(name);
		setSnapToEdge(true);
		setJumpOnClick(true);
	}
}

package com.duckblade.osrs.sailing.features.charting;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.features.util.SailingUtil;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.List;
import java.util.Map;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.InteractingChanged;
import net.runelite.api.gameval.NpcID;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LayoutableRenderableEntity;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

@Slf4j
@Singleton
public class MermaidTaskSolver
	extends OverlayPanel
	implements PluginLifecycleComponent
{

	@VisibleForTesting
	static final ImmutableSet<Integer> MERMAID_IDS = ImmutableSet.of(
		NpcID.SAILING_CHARTING_MERMAID_GUIDE_1,
		NpcID.SAILING_CHARTING_MERMAID_GUIDE_2,
		NpcID.SAILING_CHARTING_MERMAID_GUIDE_3,
		NpcID.SAILING_CHARTING_MERMAID_GUIDE_4,
		NpcID.SAILING_CHARTING_MERMAID_GUIDE_5
	);

	@VisibleForTesting
	static final Map<SeaChartTask, Map<String, Integer>> SOLUTIONS = ImmutableMap.<SeaChartTask, Map<String, Integer>>builder()
		.put(
			SeaChartTask.TASK_12,
			ImmutableMap.<String, Integer>builder()
				.put("Willow stock", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_44,
			ImmutableMap.<String, Integer>builder()
				.put("Pie dish", 1)
				.put("Pot of flour", 1)
				.put("Cooking apple", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_45,
			ImmutableMap.<String, Integer>builder()
				.put("Iron med helm", 1)
				.put("Bronze chainbody", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_46,
			ImmutableMap.<String, Integer>builder()
				.put("Cabbage seeds", 5)
				.build()
		)
		.put(
			SeaChartTask.TASK_47,
			ImmutableMap.<String, Integer>builder()
				.put("Watermelon", 10)
				.build()
		)
		.put(
			SeaChartTask.TASK_48,
			ImmutableMap.<String, Integer>builder()
				.put("Vial", 1)
				.put("Avantoe", 1)
				.put("Snape grass", 1)
				.put("Caviar", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_49,
			ImmutableMap.<String, Integer>builder()
				.put("Harralander potion (unf)", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_50,
			ImmutableMap.<String, Integer>builder()
				.put("Papaya fruit", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_51,
			ImmutableMap.<String, Integer>builder()
				.put("Ashes", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_52,
			ImmutableMap.<String, Integer>builder()
				.put("Bucket of sap", 1)
				.put("Raw slimy eel", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_53,
			ImmutableMap.<String, Integer>builder()
				.put("Barley", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_125,
			ImmutableMap.<String, Integer>builder()
				.put("Earth impling jar", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_127,
			ImmutableMap.<String, Integer>builder()
				.put("Cabbage", 1)
				.put("Onion", 1)
				.put("Tomato", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_126,
			ImmutableMap.<String, Integer>builder()
				.put("Coal", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_128,
			ImmutableMap.<String, Integer>builder()
				.put("Kwuarm", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_129,
			ImmutableMap.<String, Integer>builder()
				.put("Dwellberries", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_152,
			ImmutableMap.<String, Integer>builder()
				.put("Black flowers", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_153,
			ImmutableMap.<String, Integer>builder()
				.put("Butterfly jar", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_154,
			ImmutableMap.<String, Integer>builder()
				.put("Calquat keg", 2)
				.put("Ale yeast", 1)
				.put("Oak roots", 1)
				.put("Barley malt", 2)
				.build()
		)
		.put(
			SeaChartTask.TASK_155,
			ImmutableMap.<String, Integer>builder()
				.put("Vial", 1)
				.put("Coconut", 1)
				.put("Toadflax", 1)
				.put("Yew roots", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_156,
			ImmutableMap.<String, Integer>builder()
				.put("Soiled page", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_170,
			ImmutableMap.<String, Integer>builder()
				.put("Thatch spar dense", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_171,
			ImmutableMap.<String, Integer>builder()
				.put("Gold ore", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_172,
			ImmutableMap.<String, Integer>builder()
				.put("Malicious ashes", 2)
				.build()
		)
		.put(
			SeaChartTask.TASK_192,
			ImmutableMap.<String, Integer>builder()
				.put("Sandwich lady bottom", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_241,
			ImmutableMap.<String, Integer>builder()
				.put("Kharyrll teleport", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_242,
			ImmutableMap.<String, Integer>builder()
				.put("Raw cod", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_243,
			ImmutableMap.<String, Integer>builder()
				.put("Bronze limbs", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_244,
			ImmutableMap.<String, Integer>builder()
				.put("Onion", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_245,
			ImmutableMap.<String, Integer>builder()
				.put("Torstol", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_246,
			ImmutableMap.<String, Integer>builder()
				.put("Needle", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_247,
			ImmutableMap.<String, Integer>builder()
				.put("Clockwork", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_248,
			ImmutableMap.<String, Integer>builder()
				.put("Shield left half", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_249,
			ImmutableMap.<String, Integer>builder()
				.put("Vial of blood", 1)
				.put("Cadantine", 1)
				.put("Wine of zamorak", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_250,
			ImmutableMap.<String, Integer>builder()
				.put("Dragon bitter", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_251,
			ImmutableMap.<String, Integer>builder()
				.put("Rain bow", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_252,
			ImmutableMap.<String, Integer>builder()
				.put("Royal crown", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_271,
			ImmutableMap.<String, Integer>builder()
				.put("Nose peg", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_272,
			ImmutableMap.<String, Integer>builder()
				.put("Charcoal", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_273,
			ImmutableMap.<String, Integer>builder()
				.put("Woad leaf", 2)
				.put("Onion", 2)
				.build()
		)
		.put(
			SeaChartTask.TASK_274,
			ImmutableMap.<String, Integer>builder()
				.put("Swamp weed", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_307,
			ImmutableMap.<String, Integer>builder()
				.put("Stripy feather", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_308,
			ImmutableMap.<String, Integer>builder()
				.put("Equa leaves", 1)
				.put("Batta tin", 1)
				.put("Tomato", 2)
				.put("Cheese", 1)
				.put("Dwellberries", 1)
				.put("Onion", 1)
				.put("Cabbage", 1)
				.put("Gianne dough", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_309,
			ImmutableMap.<String, Integer>builder()
				.put("Lime", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_310,
			ImmutableMap.<String, Integer>builder()
				.put("Fedora", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_311,
			ImmutableMap.<String, Integer>builder()
				.put("Common tench", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_312,
			ImmutableMap.<String, Integer>builder()
				.put("Plank", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_313,
			ImmutableMap.<String, Integer>builder()
				.put("Ghrazi rapier", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_321,
			ImmutableMap.<String, Integer>builder()
				.put("Silver ore", 1)
				.put("Chisel", 1)
				.put("Uncut jade", 1)
				.put("Ring mould", 1)
				.put("Cosmic rune", 1)
				.put("Air rune", 3)
				.build()
		)
		.put(
			SeaChartTask.TASK_322,
			ImmutableMap.<String, Integer>builder()
				.put("Potato", 1)
				.put("Potato cactus", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_323,
			ImmutableMap.<String, Integer>builder()
				.put("Sandstone (10kg)", 1)
				.put("Sandstone (2kg)", 1)
				.put("Sandstone (1kg)", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_324,
			ImmutableMap.<String, Integer>builder()
				.put("Dark bow tie", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_325,
			ImmutableMap.<String, Integer>builder()
				.put("Double eye patch", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_326,
			ImmutableMap.<String, Integer>builder()
				.put("Bucket helm (g)", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_348,
			ImmutableMap.<String, Integer>builder()
				.put("Ring mould", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_349,
			ImmutableMap.<String, Integer>builder()
				.put("Bob's blue shirt", 1)
				.put("Bob's purple shirt", 1)
				.build()
		)
		.put(
			SeaChartTask.TASK_350,
			ImmutableMap.<String, Integer>builder()
				.put("Tarromin", 1)
				.build()
		)
		.build();

	private final Client client;
	private final SeaChartTaskIndex taskIndex;

	private SeaChartTask task;
	private Map<String, Integer> solution;

	@Inject
	public MermaidTaskSolver(Client client, SeaChartTaskIndex taskIndex)
	{
		this.client = client;
		this.taskIndex = taskIndex;

		setPreferredPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
	}

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		return config.chartingMermaidSolver();
	}

	@Override
	public void shutDown()
	{
		reset();
	}

	@Subscribe
	public void onGameTick(GameTick e)
	{
		if (task == null)
		{
			return;
		}

		if (task.isComplete(client))
		{
			log.debug("task {} completed, clearing", task.getTaskId());
			reset();
			return;
		}

		if (!SailingUtil.isSailing(client) || task.getLocation().distanceTo(SailingUtil.getTopLevelWorldPoint(client)) > 25)
		{
			log.debug("cancelling in progress task {} due to distance", task.getTaskId());
			reset();
		}
	}

	@Subscribe
	public void onInteractingChanged(InteractingChanged e)
	{
		if (!SailingUtil.isLocalPlayer(client, e.getSource()) || e.getTarget() == null)
		{
			return;
		}

		reset();

		Actor target = e.getTarget();
		if (!(target instanceof NPC) || !MERMAID_IDS.contains(((NPC) target).getId()))
		{
			return;
		}

		WorldPoint playerLoc = SailingUtil.getTopLevelWorldPoint(client);
		SeaChartTask maybeTask = taskIndex.findTask((NPC) target);
		if (maybeTask == null)
		{
			log.warn("no mermaid task found at {}", playerLoc);
			return;
		}
		task = maybeTask;

		solution = SOLUTIONS.get(maybeTask);
		if (solution == null)
		{
			log.warn("no solution found for task {}", task.getTaskId());
			reset();
			return;
		}

		log.debug("solution for task {} is {}", task.getTaskId(), solution);
	}

	private void reset()
	{
		task = null;
		solution = null;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (solution == null || !SailingUtil.isSailing(client))
		{
			return null;
		}

		List<LayoutableRenderableEntity> children = getPanelComponent().getChildren();
		children.add(TitleComponent.builder()
			.text("Mermaid Puzzle Solution")
			.build());

		for (Map.Entry<String, Integer> e : solution.entrySet())
		{
			children.add(LineComponent.builder()
				.left(e.getKey())
				.right(String.valueOf(e.getValue()))
				.build());
		}

		return super.render(graphics);
	}
}

package com.duckblade.osrs.sailing.features.charting;

import com.duckblade.osrs.sailing.SailingPlugin;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.components.LineComponent;

@Singleton
public class SeaChartPanelOverlay
	extends OverlayPanel
	implements PluginLifecycleComponent
{

	private final WeatherTaskTracker weatherTaskTracker;

	@Inject
	public SeaChartPanelOverlay(SailingPlugin plugin, WeatherTaskTracker weatherTaskTracker)
	{
		super(plugin);
		this.weatherTaskTracker = weatherTaskTracker;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (weatherTaskTracker.getActiveTask() != null)
		{
			panelComponent.getChildren().add(LineComponent.builder()
				.left("Weather pattern charting")
				.build());
			panelComponent.getChildren().add(LineComponent.builder().left("").build());

			if (weatherTaskTracker.isTaskComplete())
			{
				panelComponent.getChildren().add(LineComponent.builder()
					.left("Return to the meteorologist marked on your world map.")
					.build());
			}
			else
			{
				panelComponent.getChildren().add(LineComponent.builder()
					.left("Navigate to the marked point on your world map and use the weather device.")
					.build());
			}
		}

		return super.render(graphics);
	}
}

package com.duckblade.osrs.sailing.features.charting;

import java.awt.image.BufferedImage;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.worldmap.WorldMapPoint;

public class CurrentDuckWorldMapPoint extends WorldMapPoint
{

	public CurrentDuckWorldMapPoint(final WorldPoint worldPoint, BufferedImage icon, String name)
	{
		super(worldPoint, icon);

		setName(name);
		setSnapToEdge(true);
		setJumpOnClick(true);
	}
}

package com.duckblade.osrs.sailing.features.charting;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import com.google.common.collect.ImmutableMap;
import java.awt.image.BufferedImage;
import java.util.Map;
import java.util.stream.Stream;
import javax.inject.Inject;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.ui.overlay.worldmap.WorldMapPoint;
import net.runelite.client.ui.overlay.worldmap.WorldMapPointManager;
import net.runelite.client.util.ImageUtil;

@RequiredArgsConstructor(onConstructor_ = @Inject)
public class SeaChartMapPointManager implements PluginLifecycleComponent
{
	private static final BufferedImage MAP_GENERIC = ImageUtil.loadImageResource(SeaChartMapPointManager.class, "generic.png");
	private static final BufferedImage MAP_GENERIC_COMPLETE = ImageUtil.loadImageResource(SeaChartMapPointManager.class, "generic_complete.png");
	private static final BufferedImage MAP_SPYGLASS = ImageUtil.loadImageResource(SeaChartMapPointManager.class, "spyglass.png");
	private static final BufferedImage MAP_SPYGLASS_COMPLETE = ImageUtil.loadImageResource(SeaChartMapPointManager.class, "spyglass_complete.png");
	private static final BufferedImage MAP_CRATE = ImageUtil.loadImageResource(SeaChartMapPointManager.class, "crate.png");
	private static final BufferedImage MAP_CRATE_COMPLETE = ImageUtil.loadImageResource(SeaChartMapPointManager.class, "crate_complete.png");
	private static final BufferedImage MAP_DUCK = ImageUtil.loadImageResource(SeaChartMapPointManager.class, "duck.png");
	private static final BufferedImage MAP_DUCK_COMPLETE = ImageUtil.loadImageResource(SeaChartMapPointManager.class, "duck_complete.png");
	private static final BufferedImage MAP_MERMAID = ImageUtil.loadImageResource(SeaChartMapPointManager.class, "mermaid.png");
	private static final BufferedImage MAP_MERMAID_COMPLETE = ImageUtil.loadImageResource(SeaChartMapPointManager.class, "mermaid_complete.png");
	private static final BufferedImage MAP_WEATHER = ImageUtil.loadImageResource(SeaChartMapPointManager.class, "weather.png");
	private static final BufferedImage MAP_WEATHER_COMPLETE = ImageUtil.loadImageResource(SeaChartMapPointManager.class, "weather_complete.png");

	private final Map<Integer, ChartMapPoint> taskByVarb = Stream.of(SeaChartTask.values())
		.collect(ImmutableMap.toImmutableMap(SeaChartTask::getCompletionVarb, ChartMapPoint::new));

	private class ChartMapPoint extends WorldMapPoint
	{
		SeaChartTask task;
		boolean added = false;

		ChartMapPoint(SeaChartTask task)
		{
			super(WorldMapPoint.builder()
				.image(getIcon(task))
				.worldPoint(task.getLocation())
				.tooltip("Charting spot (" + task.getType().getName() + ")"));
			this.task = task;
		}

		void reconcile()
		{
			boolean show = !mode.isHidden(task.isComplete(client), taskIndex.hasTaskRequirement(task));
			setImage(getIcon(task));
			if (added != show)
			{
				if (show)
				{
					worldMapPointManager.add(this);
				}
				else
				{
					worldMapPointManager.remove(this);
				}

				added = show;
			}
		}
	}

	private final Client client;
	private final ClientThread clientThread;
	private final WorldMapPointManager worldMapPointManager;
	private final SeaChartTaskIndex taskIndex;

	private SailingConfig.ShowChartsMode mode;

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		mode = config.showChartsOnMap();
		return mode != SailingConfig.ShowChartsMode.NONE;
	}

	@Override
	public void startUp()
	{
		reconcileAll();
	}

	@Subscribe
	private void onConfigChanged(ConfigChanged ev)
	{
		if (SailingConfig.CONFIG_GROUP.equals(ev.getGroup())
			&& SailingConfig.SHOW_CHARTS_ON_MAP.equals(ev.getKey()))
		{
			this.reconcileAll();
		}
	}

	@Subscribe
	private void onGameStateChanged(GameStateChanged ev)
	{
		if (ev.getGameState() == GameState.LOGGED_IN)
		{
			reconcileAll();
		}
	}

	@Subscribe
	private void onVarbitChanged(VarbitChanged ev)
	{
		if (ev.getVarpId() == VarPlayerID.QP)
		{
			// a quest state changed
			reconcileAll();
		}

		var t = taskByVarb.get(ev.getVarbitId());
		if (t != null)
		{
			t.reconcile();
		}
	}

	@Override
	public void shutDown()
	{
		clientThread.invokeLater(() ->
		{
			worldMapPointManager.removeIf(p ->
			{
				if (p instanceof ChartMapPoint)
				{
					((ChartMapPoint) p).added = false;
					return true;
				}

				return false;
			});
		});
	}

	private void reconcileAll()
	{
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		clientThread.invoke(() ->
		{
			for (var e : taskByVarb.values())
			{
				e.reconcile();
			}
		});
	}

	private BufferedImage getIcon(SeaChartTask task)
	{
		boolean completed = client != null && task.isComplete(client);
		switch (task.getType())
		{
			case SPYGLASS:
				return completed ? MAP_SPYGLASS_COMPLETE : MAP_SPYGLASS;

			case DRINK_CRATE:
				return completed ? MAP_CRATE_COMPLETE : MAP_CRATE;

			case CURRENT_DUCK:
				return completed ? MAP_DUCK_COMPLETE : MAP_DUCK;

			case MERMAID_GUIDE:
				return completed ? MAP_MERMAID_COMPLETE : MAP_MERMAID;

			case WEATHER:
				return completed ? MAP_WEATHER_COMPLETE : MAP_WEATHER;

			case GENERIC:
			default:
				return completed ? MAP_GENERIC_COMPLETE : MAP_GENERIC;
		}
	}
}

package com.duckblade.osrs.sailing.features.charting;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Map;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.GameState;
import net.runelite.api.NPC;
import net.runelite.api.Perspective;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.api.events.WorldViewUnloaded;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

@Slf4j
@Singleton
public class SeaChartOverlay
	extends Overlay
	implements PluginLifecycleComponent
{

	private final Client client;
	private final ItemManager itemManager;
	private final SailingConfig config;
	private final SeaChartTaskIndex taskIndex;
	private final WeatherTaskTracker weatherTaskTracker;

	private final Map<GameObject, SeaChartTask> chartObjects = new HashMap<>();
	private final Map<NPC, SeaChartTask> chartNpcs = new HashMap<>();

	private Color colorCharted;
	private Color colorUncharted;
	private Color colorRequirementsUnmet;

	@Inject
	public SeaChartOverlay(
		Client client,
		ItemManager itemManager,
		SailingConfig config,
		SeaChartTaskIndex taskIndex,
		WeatherTaskTracker weatherTaskTracker
	)
	{
		this.client = client;
		this.itemManager = itemManager;
		this.config = config;
		this.taskIndex = taskIndex;
		this.weatherTaskTracker = weatherTaskTracker;

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		colorCharted = config.chartingChartedColor();
		colorUncharted = config.chartingUnchartedColor();
		colorRequirementsUnmet = config.chartingRequirementsUnmetColor();
		return config.showCharts() != SailingConfig.ShowChartsMode.NONE;
	}

	public void shutDown()
	{
		chartNpcs.clear();
		chartObjects.clear();
	}

	@Override
	public Dimension render(Graphics2D g)
	{
		SailingConfig.ShowChartsMode mode = config.showCharts();
		if (mode == SailingConfig.ShowChartsMode.NONE)
		{
			return null;
		}

		for (Map.Entry<GameObject, SeaChartTask> tracked : chartObjects.entrySet())
		{
			GameObject obj = tracked.getKey();
			SeaChartTask task = tracked.getValue();

			boolean completed = task.isComplete(client);
			boolean meetsRequirements = taskIndex.hasTaskRequirement(task);
			if (mode.isHidden(completed, meetsRequirements))
			{
				continue;
			}

			Polygon poly = obj.getCanvasTilePoly();
			if (poly != null)
			{
				Color color = getColor(completed, meetsRequirements);
				OverlayUtil.renderPolygon(g, poly, color);
			}
			OverlayUtil.renderImageLocation(client, g, obj.getLocalLocation(), taskIndex.getTaskSprite(task), 0);
		}

		for (Map.Entry<NPC, SeaChartTask> tracked : chartNpcs.entrySet())
		{
			NPC npc = tracked.getKey();
			SeaChartTask task = tracked.getValue();

			boolean completed = task.isComplete(client);
			boolean meetsRequirements = taskIndex.hasTaskRequirement(task);
			if (mode.isHidden(completed, meetsRequirements))
			{
				continue;
			}

			Color color = getColor(completed, meetsRequirements);
			OverlayUtil.renderActorOverlayImage(g, npc, taskIndex.getTaskSprite(task), color, npc.getLogicalHeight() / 2);
		}

		renderWeatherTaskTarget(g);

		return null;
	}

	private void renderWeatherTaskTarget(Graphics2D g)
	{
		if (weatherTaskTracker.getActiveTask() != null && !weatherTaskTracker.isTaskComplete())
		{
			LocalPoint lp = LocalPoint.fromWorld(client.getTopLevelWorldView(), weatherTaskTracker.getActiveTask().getDestination());
			if (lp == null)
			{
				return;
			}

			Polygon poly = Perspective.getCanvasTilePoly(client, lp, 0);
			if (poly == null)
			{
				return;
			}

			BufferedImage icon = itemManager.getImage(ItemID.SAILING_CHARTING_WEATHER_STATION_EMPTY);
			OverlayUtil.renderPolygon(g, poly, Color.GREEN);
			OverlayUtil.renderImageLocation(client, g, lp, icon, 0);
		}
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned e)
	{
		GameObject o = e.getGameObject();
		SeaChartTask task = taskIndex.findTask(o);
		if (task != null)
		{
			chartObjects.put(o, task);
		}
	}

	@Subscribe
	public void onGameObjectDespawned(GameObjectDespawned e)
	{
		chartObjects.remove(e.getGameObject());
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned e)
	{
		NPC npc = e.getNpc();
		SeaChartTask task = taskIndex.findTask(npc);
		if (task != null)
		{
			chartNpcs.put(npc, task);
		}
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned e)
	{
		chartNpcs.remove(e.getNpc());
	}

	@Subscribe
	public void onWorldViewUnloaded(WorldViewUnloaded e)
	{
		if (e.getWorldView().isTopLevel())
		{
			chartObjects.clear();
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged e)
	{
		if (e.getGameState() != GameState.LOADING &&
			e.getGameState() != GameState.LOGGED_IN &&
			e.getGameState() != GameState.CONNECTION_LOST)
		{
			chartNpcs.clear();
		}
	}

	private Color getColor(boolean isTaskCompleted, boolean hasTaskRequirement)
	{
		if (isTaskCompleted)
		{
			return colorCharted;
		}

		if (hasTaskRequirement)
		{
			return colorUncharted;
		}

		return colorRequirementsUnmet;
	}
}

package com.duckblade.osrs.sailing.features.charting;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.features.util.BoatTracker;
import com.duckblade.osrs.sailing.features.util.SailingGraphicsUtil;
import com.duckblade.osrs.sailing.features.util.SailingUtil;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.ItemContainer;
import net.runelite.api.NPC;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.InteractingChanged;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.worldmap.WorldMapPointManager;

@Slf4j
@Singleton
public class WeatherTaskTracker
	extends Overlay
	implements PluginLifecycleComponent
{


	private final Client client;
	private final ItemManager itemManager;
	private final WorldMapPointManager worldMapPointManager;
	private final SeaChartTaskIndex taskIndex;
	private final BoatTracker boatTracker;

	@Getter
	private SeaChartTask activeTask;

	@Getter
	private boolean taskComplete;

	private SeaChartTask potentialTask;

	// the active task state as indicated by the ID of the last weather device we had in the inventory
	private int lastState = -1;

	@Inject
	public WeatherTaskTracker(Client client, ItemManager itemManager, WorldMapPointManager worldMapPointManager, SeaChartTaskIndex taskIndex, BoatTracker boatTracker)
	{
		this.client = client;
		this.itemManager = itemManager;
		this.worldMapPointManager = worldMapPointManager;
		this.taskIndex = taskIndex;
		this.boatTracker = boatTracker;

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		return config.chartingWeatherSolver();
	}

	public void shutDown()
	{
		activeTask = null;
		taskComplete = false;
		potentialTask = null;
		lastState = -1;
		worldMapPointManager.removeIf(it -> it instanceof WeatherChartingWorldMapPoint);
	}

	@Subscribe
	public void onInteractingChanged(InteractingChanged event)
	{
		if (!SailingUtil.isLocalPlayer(client, event.getSource()))
		{
			return;
		}

		Actor target = event.getTarget();
		if (!(target instanceof NPC))
		{
			return;
		}

		NPC targetNpc = (NPC) target;
		var task = taskIndex.findTask(targetNpc);
		if (task != null)
		{
			potentialTask = task;
		}
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event)
	{
		if (event.getContainerId() != InventoryID.INV)
		{
			return;
		}

		ItemContainer inventory = event.getItemContainer();
		int newState;
		if (inventory.contains(ItemID.SAILING_CHARTING_WEATHER_STATION_EMPTY))
		{
			newState = ItemID.SAILING_CHARTING_WEATHER_STATION_EMPTY;
		}
		else if (inventory.contains(ItemID.SAILING_CHARTING_WEATHER_STATION_FULL))
		{
			newState = ItemID.SAILING_CHARTING_WEATHER_STATION_FULL;
		}
		else
		{
			newState = -1;
		}

		if (potentialTask != null && lastState == -1 && newState == ItemID.SAILING_CHARTING_WEATHER_STATION_EMPTY)
		{
			activeTask = potentialTask;
			potentialTask = null;

			BufferedImage mapIcon = itemManager.getImage(ItemID.SAILING_CHARTING_WEATHER_STATION_EMPTY);
			worldMapPointManager.add(new WeatherChartingWorldMapPoint(activeTask.getDestination(), mapIcon, "Use device here"));
		}
		else if (activeTask != null && lastState == ItemID.SAILING_CHARTING_WEATHER_STATION_EMPTY && newState == ItemID.SAILING_CHARTING_WEATHER_STATION_FULL)
		{
			taskComplete = true;

			BufferedImage mapIcon = itemManager.getImage(ItemID.SAILING_CHARTING_WEATHER_STATION_FULL);
			worldMapPointManager.removeIf(it -> it instanceof WeatherChartingWorldMapPoint);
			worldMapPointManager.add(new WeatherChartingWorldMapPoint(activeTask.getLocation(), mapIcon, "Return device here"));
		}
		else if (activeTask != null && (lastState == ItemID.SAILING_CHARTING_WEATHER_STATION_EMPTY || lastState == ItemID.SAILING_CHARTING_WEATHER_STATION_FULL) && newState == -1)
		{
			activeTask = null;
			taskComplete = false;

			worldMapPointManager.removeIf(it -> it instanceof WeatherChartingWorldMapPoint);
		}

		lastState = newState;
	}

	@Override
	public Dimension render(Graphics2D g)
	{
		if (activeTask == null)
		{
			return null;
		}

		WorldPoint dest = lastState == ItemID.SAILING_CHARTING_WEATHER_STATION_EMPTY ? activeTask.getDestination() : activeTask.getLocation();
		SailingGraphicsUtil.renderBoatArrowTowardPoint(
			g,
			client,
			boatTracker,
			dest,
			Color.ORANGE
		);

		return null;
	}
}

package com.duckblade.osrs.sailing.features.mes;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class HideStopNavigatingDuringTrials implements PluginLifecycleComponent
{

	private static final String OPTION_STOP_NAVIGATING = "Stop-navigating";
	private static final String OPTION_ESCAPE = "Escape";

	private final Client client;

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		return config.hideStopNavigatingDuringTrials();
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded e)
	{
		if (client.getVarbitValue(VarbitID.SAILING_BT_IN_TRIAL) == 0)
		{
			return;
		}

		if (OPTION_STOP_NAVIGATING.equals(e.getOption()) ||
			OPTION_ESCAPE.equals(e.getOption()))
		{
			// Push the Stop-navigating option down instead of removing it
			e.getMenuEntry().setDeprioritized(true);
		}
	}
}

package com.duckblade.osrs.sailing.features.mes;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.features.util.SailingUtil;
import com.duckblade.osrs.sailing.model.CargoHoldTier;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Set;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Menu;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.events.PostMenuSort;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class PrioritizeCargoHold
	implements PluginLifecycleComponent
{

	private static final Set<Integer> CARGO_HOLD_IDS = Arrays.stream(CargoHoldTier.values())
		.map(CargoHoldTier::getGameObjectIds)
		.flatMapToInt(Arrays::stream)
		.boxed()
		.collect(Collectors.toUnmodifiableSet());

	private static final Comparator<MenuEntry> MENU_ENTRY_COMPARATOR =
		Comparator.comparing((me) -> CARGO_HOLD_IDS.contains(me.getIdentifier()) && me.getType() != MenuAction.EXAMINE_OBJECT);

	private final Client client;

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		return config.prioritizeCargoHold();
	}

	@Subscribe(priority = -100)
	public void onPostMenuSort(PostMenuSort e)
	{
		if (!SailingUtil.isSailing(client))
		{
			return;
		}

		// Don't prioritize during Barracuda Trials
		if (client.getVarbitValue(VarbitID.SAILING_BT_IN_TRIAL) != 0)
		{
			return;
		}

		Menu menu = client.getMenu();
		menu.setMenuEntries(
			Arrays.stream(menu.getMenuEntries())
				.sorted(MENU_ENTRY_COMPARATOR)
				.toArray(MenuEntry[]::new)
		);
	}
}

package com.duckblade.osrs.sailing.features.mes;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.features.util.SailingUtil;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import java.util.Arrays;
import java.util.Comparator;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Menu;
import net.runelite.api.MenuEntry;
import net.runelite.api.events.PostMenuSort;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class DeprioSailsOffHelm
	implements PluginLifecycleComponent
{

	private static final int FACILITY_HELM = 3;
	private static final String MENU_TARGET_SAILS = "<col=ffff>Sails";

	private static final Comparator<MenuEntry> IS_SAILS =
		Comparator.comparing((MenuEntry me) -> MENU_TARGET_SAILS.equals(me.getTarget()))
			.reversed();

	private final Client client;

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		return config.disableSailsWhenNotAtHelm();
	}

	@Subscribe(priority = -1)
	public void onPostMenuSort(PostMenuSort e)
	{
		if (!SailingUtil.isSailing(client))
		{
			return;
		}

		// todo getSailingFacility
		// todo crewmate support?
		if (client.getVarbitValue(VarbitID.SAILING_BOAT_FACILITY_LOCKEDIN) == FACILITY_HELM)
		{
			// at helm
			return;
		}

		Menu menu = client.getMenu();
		menu.setMenuEntries(
			Arrays.stream(menu.getMenuEntries())
				.sorted(IS_SAILS)
				.toArray(MenuEntry[]::new)
		);
	}

}

package com.duckblade.osrs.sailing.features.barracudatrials;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.gameval.VarbitID;

@Getter
@RequiredArgsConstructor
public enum BarracudaDifficulty
{

	SWORDFISH("Swordfish", 2),
	SHARK("Shark", 3),
	MARLIN("Marlin", 4),
	;

	private final String name;
	private final int inTrialVarbValue;

	public static BarracudaDifficulty ofVarbitValue(int varbitValue)
	{
		for (BarracudaDifficulty difficulty : values())
		{
			if (difficulty.getInTrialVarbValue() == varbitValue)
			{
				return difficulty;
			}
		}
		return null;
	}

	public static BarracudaDifficulty current(Client client)
	{
		int varbitValue = client.getVarbitValue(VarbitID.SAILING_BT_IN_TRIAL);
		if (varbitValue == 1)
		{
			// unranked (1) is always the same as swordfish (2)
			varbitValue = 2;
		}

		return ofVarbitValue(varbitValue);
	}

	@Override
	public String toString()
	{
		return name;
	}
}

package com.duckblade.osrs.sailing.features.barracudatrials;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.features.util.SailingUtil;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class HidePortalTransitions
	implements PluginLifecycleComponent
{

	private final Client client;
	private final ClientThread clientThread;

	// fixes a jarring half-snap during course start
	private boolean wasInTrial;

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		return config.barracudaHidePortalTransitions();
	}

	@Subscribe
	public void onGameTick(GameTick e)
	{
		// not using onVarbitChanged due to event ordering
		wasInTrial = client.getVarbitValue(VarbitID.SAILING_BT_IN_TRIAL) != 0;
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded e)
	{
		if (!SailingUtil.isSailing(client))
		{
			return;
		}

		if (!wasInTrial)
		{
			return;
		}

		if (e.getGroupId() != InterfaceID.GOTR_OVERLAY &&
			e.getGroupId() != InterfaceID.FADE_OVERLAY)
		{
			return;
		}

		Widget w = client.getWidget(e.getGroupId(), 0);
		assert w != null;

		clientThread.invokeLater(() -> w.setHidden(true));
	}

}

package com.duckblade.osrs.sailing.features.barracudatrials.splits;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.SailingPlugin;
import com.duckblade.osrs.sailing.features.barracudatrials.BarracudaDifficulty;
import com.duckblade.osrs.sailing.features.barracudatrials.BarracudaTrial;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

@Slf4j
@Singleton
public class BarracudaSplitsOverlayPanel
	extends OverlayPanel
	implements PluginLifecycleComponent
{

	// how long to keep rendering the overlay after you've completed a run
	private static final int RENDER_DECAY_MS = 60 * 1_000;

	private final BarracudaSplitsTracker tracker;

	private long runEndTs;

	@Inject
	public BarracudaSplitsOverlayPanel(SailingPlugin plugin, BarracudaSplitsTracker tracker)
	{
		super(plugin);

		this.tracker = tracker;
		setPreferredPosition(OverlayPosition.TOP_LEFT);
		setLayer(OverlayLayer.ALWAYS_ON_TOP);
	}

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		return config.barracudaSplitsOverlayPanel();
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!shouldRender())
		{
			return null;
		}

		BarracudaTrial trial = tracker.getTrial();
		BarracudaDifficulty difficulty = tracker.getDifficulty();
		if (trial == null || difficulty == null)
		{
			return null;
		}

		int steps = trial.getProgressSteps(difficulty);
		String splitWord = tracker.getSplitWord();

		// Title
		panelComponent.getChildren().add(TitleComponent.builder()
			.text(trial.name().replace('_', ' '))
			.build());

		for (int i = 1; i <= steps; i++)
		{
			String right = "--:--.--";
			if (i <= tracker.getSplits().size())
			{
				right = tracker.getSplits().get(i - 1).getFormattedTicks();
			}

			panelComponent.getChildren().add(LineComponent.builder()
				.left(splitWord + " " + i)
				.right(right)
				.build());
		}

		return super.render(graphics);
	}

	private boolean shouldRender()
	{
		if (tracker.isInRun())
		{
			runEndTs = -1;
			return true;
		}

		if (runEndTs == -1)
		{
			runEndTs = System.currentTimeMillis() + RENDER_DECAY_MS;
			return true;
		}

		return System.currentTimeMillis() <= runEndTs;
	}
}

package com.duckblade.osrs.sailing.features.barracudatrials.splits;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import java.awt.Color;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.ColorUtil;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class BarracudaSplitsChatMessage
	implements PluginLifecycleComponent
{

	private final ChatMessageManager chatMessageManager;

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		return config.barracudaSplitsChatMessage();
	}

	@Subscribe
	public void onBarracudaSplit(BarracudaSplit split)
	{
		chatMessageManager.queue(QueuedMessage.builder()
			.type(ChatMessageType.GAMEMESSAGE)
			.sender("Runelite/Sailing")
			.value("[Sailing] " + split.getName() + ": " + ColorUtil.wrapWithColorTag(split.getFormattedTicks(), Color.RED))
			.build());
	}

	@Subscribe
	public void onBarracudaSplitsComplete(BarracudaSplitsComplete complete)
	{
		StringBuilder sb = new StringBuilder();
		sb.append("[Sailing] Splits:<br>");

		for (BarracudaSplit s : complete.getSplits())
		{
			sb.append(s.getName())
				.append(": ")
				.append(ColorUtil.wrapWithColorTag(s.getFormattedTicks(), Color.RED))
				.append("<br>");
		}

		chatMessageManager.queue(QueuedMessage.builder()
			.type(ChatMessageType.GAMEMESSAGE)
			.sender("Runelite/Sailing")
			.value(sb.toString())
			.build());
	}

}

package com.duckblade.osrs.sailing.features.barracudatrials.splits;

import com.duckblade.osrs.sailing.features.barracudatrials.BarracudaDifficulty;
import com.duckblade.osrs.sailing.features.barracudatrials.BarracudaTrial;
import com.duckblade.osrs.sailing.features.util.SailingUtil;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class BarracudaSplitsTracker
	implements PluginLifecycleComponent
{

	private final Client client;
	private final EventBus eventBus;

	@Getter
	private final List<BarracudaSplit> splits = new ArrayList<>();

	@Getter
	private boolean inRun;
	private int kc; // we use the varp change event to determine if the run was fully completed
	private int btStartServer;
	private int btStartClient;
	private int progress;

	private boolean trialStart;
	private boolean trialEnd;

	@Getter
	private BarracudaTrial trial;

	@Getter
	private BarracudaDifficulty difficulty;

	@Override
	public void shutDown()
	{
		reset();
	}

	@Subscribe
	public void onGameTick(GameTick e)
	{
		if (!SailingUtil.isSailing(client))
		{
			return;
		}

		if (trialStart)
		{
			reset();
			splits.clear();
			inRun = true;

			trial = BarracudaTrial.byLocation(SailingUtil.getTopLevelWorldPoint(client));
			difficulty = BarracudaDifficulty.current(client);
			if (trial == null || difficulty == null)
			{
				log.warn("trial and/or difficulty not found, did they add new features? t={} d={}", trial, difficulty);
				return;
			}

			kc = trial.getKc(client);
			log.debug("player began {}/{}, kc={}", trial, difficulty, kc);

			// it's impossible to begin moving on the tick where trialStart is set so this return is safe
			return;
		}

		if (trialEnd)
		{
			if (trial.getKc(client) <= kc)
			{
				log.debug("player abandoned in-progress barracuda trial");
				reset();
				return;
			}

			BarracudaSplit split = new BarracudaSplit(getSplitWord() + " " + progress, client.getTickCount() - btStartClient); // add in the final progress step
			splits.add(split);

			log.debug("bt run complete: {}", splits);
			eventBus.post(new BarracudaSplitsComplete(
				trial,
				difficulty,
				kc,
				Collections.unmodifiableList(splits))
			);

			reset();
			return;
		}

		if (!inRun)
		{
			return;
		}

		if (btStartServer != (btStartServer = client.getVarpValue(VarPlayerID.SAILING_BT_TIME_START)) &&
			btStartServer != 0)
		{
			btStartClient = client.getTickCount();
			log.debug("player began run of {}/{} on s={} c={}", trial, difficulty, btStartServer, btStartClient);
			return;
		}

		if (inRun &&
			progress != (progress = getProgress()) &&
			progress < trial.getProgressSteps(difficulty)) // ignore the last one so we get a "final" time only
		{
			BarracudaSplit split = new BarracudaSplit(getSplitWord() + " " + progress, client.getTickCount() - btStartClient);
			splits.add(split);
			eventBus.post(split);
		}
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged e)
	{
		if (e.getVarbitId() == VarbitID.SAILING_BT_IN_TRIAL)
		{
			if (e.getValue() != 0)
			{
				log.trace("trialStart");
				trialStart = true;
			}
			else
			{
				log.trace("trialEnd");
				trialEnd = true;
			}
		}
	}

	private void reset()
	{
		// intentionally does not unset trial, difficulty, and splits.clear()
		// to allow overlay panel to keep showing after the run
		inRun = false;
		btStartServer = 0;
		kc = 0;
		progress = 0;
		trialStart = false;
		trialEnd = false;
	}

	private int getProgress()
	{
		Widget widget = client.getWidget(InterfaceID.SailingBtHud.BT_TRACKER_PROGRESS);
		return widget != null ? Integer.parseInt(widget.getText().split("/")[0].trim()) : 0;
	}

	String getSplitWord()
	{
		switch (trial)
		{
			case JUBBLY_JIVE:
				return "Jubbly";

			case GWENITH_GLIDE:
				return "Crystal";

			default:
				return "Lap";
		}
	}
}

package com.duckblade.osrs.sailing.features.barracudatrials.splits;

import com.duckblade.osrs.sailing.features.barracudatrials.BarracudaDifficulty;
import com.duckblade.osrs.sailing.features.barracudatrials.BarracudaTrial;
import java.util.List;
import lombok.Value;

@Value
public class BarracudaSplitsComplete
{

	BarracudaTrial trial;
	BarracudaDifficulty difficulty;
	int kc;
	List<BarracudaSplit> splits;

}

package com.duckblade.osrs.sailing.features.barracudatrials.splits;

import lombok.Value;
import net.runelite.api.Constants;

@Value
public class BarracudaSplit
{
	String name;
	int ticks;

	String getFormattedTicks()
	{
		int ms = ticks * Constants.GAME_TICK_LENGTH;

		int cents = (ms / 10);
		int seconds = (ms / 1_000);
		int minutes = seconds / 60;
		return String.format("%d:%02d.%02d",
			minutes,
			seconds % 60,
			cents % 100
		);
	}
}

package com.duckblade.osrs.sailing.features.barracudatrials.splits;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.SailingPlugin;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import java.awt.Color;
import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.ColorUtil;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class BarracudaSplitsFileWriter implements PluginLifecycleComponent
{

	private static final File SPLITS_DIR = new File(SailingPlugin.SAILING_DIR, "splits");

	private final ChatMessageManager chatMessageManager;

	private SailingConfig.BarracudaSplitsToFileMode mode;

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		mode = config.barracudaSplitsToFile();
		return mode != SailingConfig.BarracudaSplitsToFileMode.OFF;
	}

	@Subscribe
	public void onBarracudaSplitsComplete(BarracudaSplitsComplete complete)
	{
		// Ensure base directory exists
		if (!SPLITS_DIR.exists() && !SPLITS_DIR.mkdirs())
		{
			log.warn("Unable to create sailing directory at {}", SPLITS_DIR.getAbsolutePath());
			return;
		}

		String filename = String.format("%s - %s - %d.txt",
			complete.getTrial(),
			complete.getDifficulty(),
			complete.getKc());

		Path path = SPLITS_DIR.toPath().resolve(filename);
		try
		{
			writeSplits(path, complete.getSplits());

			if (mode == SailingConfig.BarracudaSplitsToFileMode.NOTIFY)
			{
				chatMessageManager.queue(QueuedMessage.builder()
					.type(ChatMessageType.GAMEMESSAGE)
					.sender("Runelite/Sailing")
					.value("[Sailing] Barracuda splits written to " + ColorUtil.wrapWithColorTag(path.toAbsolutePath().toString(), Color.RED))
					.build());
			}
		}
		catch (IOException ex)
		{
			log.warn("Failed writing barracuda splits to {}", path, ex);
		}
	}

	private static void writeSplits(Path file, List<BarracudaSplit> splits) throws IOException
	{
		StringBuilder sb = new StringBuilder();
		for (BarracudaSplit s : splits)
		{
			sb.append(s.getName())
				.append(": ")
				.append(s.getFormattedTicks())
				.append(System.lineSeparator());
		}

		Files.writeString(file, sb.toString(), StandardCharsets.UTF_8);
	}
}

package com.duckblade.osrs.sailing.features.barracudatrials;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.features.util.SailingUtil;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.WorldViewUnloaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.ObjectID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

@Slf4j
@Singleton
public class JubblyJiveHelper
	extends Overlay
	implements PluginLifecycleComponent
{

	private static final int SPRITE_ID_JUBBLY = 6998;
	private static final Set<Integer> SPRITE_IDS_OUTCROP_FULL = ImmutableSet.of(
		SPRITE_ID_JUBBLY, // jubbly
		6999 // toady
	);

	// game object to highlight -> dynamic child id to check for state
	private static final Map<Integer, Integer> OUTCROP_WIDGET_CHILDREN_IDS = ImmutableMap.<Integer, Integer>builder()
		.put(ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_1_PARENT, 1)
		.put(ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_2_PARENT, 2)
		.put(ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_3_PARENT, 3)
		.put(ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_4_PARENT, 4)
		.put(ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_5_PARENT, 5)
		.put(ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_6_PARENT, 6)
		.put(ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_7_PARENT, 7)
		.build();

	private static final Map<Integer, Color> OUTCROP_HIGHLIGHT_COLOURS = ImmutableMap.<Integer, Color>builder()
		.put(ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_1_PARENT, new Color(0xC8C628))
		.put(ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_2_PARENT, new Color(0x752622))
		.put(ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_3_PARENT, new Color(0x213C64))
		.put(ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_4_PARENT, new Color(0xA77422))
		.put(ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_5_PARENT, new Color(0x589889))
		.put(ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_6_PARENT, new Color(0x8F5594))
		.put(ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_7_PARENT, new Color(0xA69FA9))
		.build();

	private final Client client;

	// realized version of OUTCROP_WIDGET_CHILDREN_IDS
	private final Map<GameObject, Integer> outcrops = new HashMap<>();

	private boolean active;

	@Inject
	public JubblyJiveHelper(Client client)
	{
		this.client = client;

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		return config.barracudaJubblyJiveShowToadyTargets();
	}

	@Subscribe
	public void onGameTick(GameTick e)
	{
		boolean nowActive = client.getVarbitValue(VarbitID.SAILING_BT_IN_TRIAL) != 0 &&
			SailingUtil.isSailing(client) &&
			BarracudaTrial.JUBBLY_JIVE.getArea().contains(SailingUtil.getTopLevelWorldPoint(client));

		if (active != nowActive)
		{
			log.debug("doing jubbly jive = {}", nowActive);
			active = nowActive;
		}
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned e)
	{
		GameObject o = e.getGameObject();
		Integer childIndex = OUTCROP_WIDGET_CHILDREN_IDS.get(o.getId());
		if (childIndex != null)
		{
			outcrops.put(o, childIndex);
		}
	}

	@Subscribe
	public void onGameObjectDespawned(GameObjectDespawned e)
	{
		outcrops.remove(e.getGameObject());
	}

	@Subscribe
	public void onWorldViewUnloaded(WorldViewUnloaded e)
	{
		if (e.getWorldView().isTopLevel())
		{
			outcrops.clear();
		}
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!active)
		{
			return null;
		}

		Widget widget = client.getWidget(InterfaceID.SailingBtHud.BT_MIDDLE_CONTENT);
		if (widget == null)
		{
			return null;
		}

		for (Map.Entry<GameObject, Integer> o : outcrops.entrySet())
		{
			GameObject obj = o.getKey();
			int childIx = o.getValue();

			// if we're on the final jubbly, only render the outcrops in front of the jubbly
			if (getJubbliesRemaining() == 1 && childIx <= getJubblyLocation())
			{
				continue;
			}

			// annoyingly these are dynamic children
			Widget stateWidget = widget.getChild(childIx);
			if (stateWidget == null || SPRITE_IDS_OUTCROP_FULL.contains(stateWidget.getSpriteId()))
			{
				continue;
			}

			Shape convexHull = obj.getConvexHull();
			if (convexHull != null)
			{
				graphics.setStroke(new BasicStroke(2));
				graphics.setColor(new Color(0, 0, 0, 50));
				graphics.fill(convexHull);
				graphics.setColor(OUTCROP_HIGHLIGHT_COLOURS.get(obj.getId()));
				graphics.draw(convexHull);
			}
		}

		return null;
	}

	private int getJubbliesRemaining()
	{
		Widget widget = client.getWidget(InterfaceID.SailingBtHud.BT_TRACKER_PROGRESS);
		String text;
		if (widget == null || (text = widget.getText()) == null)
		{
			return 0;
		}

		if (text.length() > 5)
		{
			// compact is "X / Y" but full is "X / Y Jubblies lured"
			text = text.substring(0, 5);
		}

		String[] split = text.split(" / ");
		return Integer.parseInt(split[1]) - Integer.parseInt(split[0]);
	}

	private int getJubblyLocation()
	{
		Widget widget = client.getWidget(InterfaceID.SailingBtHud.BT_MIDDLE_CONTENT);
		if (widget == null)
		{
			return -1;
		}

		for (int i = 0; i < 8; i++)
		{
			// first of the children to have the jubbly sprite
			Widget child = widget.getChild(i);
			if (child != null && child.getSpriteId() == SPRITE_ID_JUBBLY)
			{
				return i;
			}
		}

		return -1;
	}
}

package com.duckblade.osrs.sailing.features.barracudatrials;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.VarPlayerID;

@Getter
@RequiredArgsConstructor
public enum BarracudaTrial
{

	TEMPOR_TANTRUM(
		"Tempor Tantrum",
		new WorldArea(2944, 2751, 3136 - 2944, 2943 - 2751, 0),
		VarPlayerID.SAILING_BT_TRIAL_TEMPOR_TANTRUM_COMPLETED,
		new int[]{1, 2, 3}
	),
	JUBBLY_JIVE(
		"Jubbly Jive",
		new WorldArea(2210, 2880, 2488 - 2210, 3072 - 2880, 0),
		VarPlayerID.SAILING_BT_TRIAL_JUBBLY_JIVE_COMPLETED,
		new int[]{1, 2, 3}
	),

	// this one's worldarea is not very "snug" and might need trimmed down to a compound area or list of region ids or something
	GWENITH_GLIDE(
		"Gwenith Glide",
		new WorldArea(2026, 3071, 2295 - 2026, 3653 - 3071, 0),
		VarPlayerID.SAILING_BT_TRIAL_GWENITH_GLIDE_COMPLETED,
		new int[]{3, 5, 8}
	),
	;

	private final String name;
	private final WorldArea area;
	private final int kcVarp;
	private final int[] difficultyProgressSteps;

	public int getKc(Client client)
	{
		return client.getVarpValue(kcVarp);
	}

	public int getProgressSteps(BarracudaDifficulty difficulty)
	{
		return difficultyProgressSteps[difficulty.ordinal()];
	}

	public static BarracudaTrial byLocation(WorldPoint wp)
	{
		for (BarracudaTrial trial : BarracudaTrial.values())
		{
			if (trial.getArea().contains(wp))
			{
				return trial;
			}
		}

		return null;
	}

	@Override
	public String toString()
	{
		return name;
	}
}

package com.duckblade.osrs.sailing.features.barracudatrials;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.features.util.SailingUtil;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import com.google.common.collect.ImmutableSet;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.HashSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.ObjectComposition;
import net.runelite.api.Perspective;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.WorldViewUnloaded;
import net.runelite.api.gameval.ObjectID;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

@Slf4j
@Singleton
public class LostCargoHighlighter
	extends Overlay
	implements PluginLifecycleComponent
{

	private static final Set<Integer> LOST_CARGO_IDS = ImmutableSet.of(
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_1,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_2,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_3,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_4,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_5,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_6,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_7,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_8,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_9,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_10,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_11,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_12,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_13,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_14,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_15,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_16,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_17,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_18,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_19,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_20,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_21,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_22,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_23,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_24,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_25,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_26,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_27,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_28,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_29,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_30,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_31,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_32,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_33,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_34,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_35,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_36,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_37,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_38,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_39,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_40,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_41,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_42,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_43,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_44,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_45,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_46,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_47,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_48,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_49,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_50,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_51,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_52,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_53,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_54,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_55,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_56,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_57,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_58,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_59,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_60,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_61,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_62,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_63,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_64,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_65,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_66,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_67,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_68,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_69,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_70,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_71,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_72,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_73,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_74,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_75,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_76,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_77,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_78,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_79,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_80,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_81,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_82,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_83,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_84,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_85,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_86,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_87,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_88,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_89,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_90,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_91,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_92,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_93,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_94,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_95,
		ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_96,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_1,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_2,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_3,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_4,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_5,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_6,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_7,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_8,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_9,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_10,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_11,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_12,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_13,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_14,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_15,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_16,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_17,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_18,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_19,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_20,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_21,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_22,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_23,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_24,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_25,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_26,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_27,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_28,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_29,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_30,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_31,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_32,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_33,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_34,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_35,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_36,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_37,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_38,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_39,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_40,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_41,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_42,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_43,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_44,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_45,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_46,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_47,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_48,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_49,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_50,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_51,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_52,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_53,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_54,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_55,
		ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_56,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_1,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_2,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_3,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_4,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_5,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_6,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_7,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_8,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_9,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_10,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_11,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_12,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_13,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_14,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_15,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_16,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_17,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_18,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_19,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_20,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_21,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_22,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_23,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_24,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_25,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_26,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_27,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_28,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_29,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_30,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_31,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_32,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_33,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_34,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_35,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_36
	);

	private final Client client;

	private final Set<GameObject> lostCargo = new HashSet<>();
	private Color crateColour;

	@Inject
	public LostCargoHighlighter(Client client)
	{
		this.client = client;

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		crateColour = config.barracudaHighlightLostCratesColour();
		return config.barracudaHighlightLostCrates();
	}

	@Override
	public void shutDown()
	{
		lostCargo.clear();
	}

	@Subscribe
	public void onWorldViewUnloaded(WorldViewUnloaded e)
	{
		if (e.getWorldView().isTopLevel())
		{
			lostCargo.clear();
		}
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned e)
	{
		GameObject o = e.getGameObject();
		if (LOST_CARGO_IDS.contains(o.getId()))
		{
			lostCargo.add(o);
		}
	}

	@Subscribe
	public void onGameObjectDespawned(GameObjectDespawned e)
	{
		lostCargo.remove(e.getGameObject());
	}

	@Override
	public Dimension render(Graphics2D g)
	{
		for (GameObject o : lostCargo)
		{
			ObjectComposition def = SailingUtil.getTransformedObject(client, o);
			if (def != null)
			{
				var poly = Perspective.getCanvasTileAreaPoly(client, o.getLocalLocation(), 5);
				if (poly != null)
				{
					OverlayUtil.renderPolygon(g, poly, crateColour);
				}
			}
		}

		return null;
	}
}

package com.duckblade.osrs.sailing.features.barracudatrials;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.features.util.SailingUtil;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Shape;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.WorldViewUnloaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.ObjectID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

@Slf4j
@Singleton
public class TemporTantrumHelper
	extends Overlay
	implements PluginLifecycleComponent
{

	private static final int SPRITE_ID_RUM = 7022;

	private static final Color COLOUR_RUM = new Color(0xB24727);

	private final Client client;

	private boolean active;

	private GameObject pickUp;
	private GameObject dropOff;

	@Inject
	public TemporTantrumHelper(Client client)
	{
		this.client = client;

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		return config.barracudaTemporTantrumShowRumTarget();
	}

	@Subscribe
	public void onGameTick(GameTick e)
	{
		boolean nowActive = client.getVarbitValue(VarbitID.SAILING_BT_IN_TRIAL) != 0 &&
			SailingUtil.isSailing(client) &&
			BarracudaTrial.TEMPOR_TANTRUM.getArea().contains(SailingUtil.getTopLevelWorldPoint(client));

		if (active != nowActive)
		{
			log.debug("doing tempor tantrum = {}", nowActive);
			active = nowActive;
		}
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned e)
	{
		GameObject o = e.getGameObject();
		if (o.getId() == ObjectID.SAILING_BT_TEMPOR_TANTRUM_SOUTH_LOC_PARENT)
		{
			pickUp = o;
		}
		if (o.getId() == ObjectID.SAILING_BT_TEMPOR_TANTRUM_NORTH_LOC_PARENT)
		{
			dropOff = o;
		}
	}

	@Subscribe
	public void onGameObjectDespawned(GameObjectDespawned e)
	{
		if (e.getGameObject() == pickUp)
		{
			pickUp = null;
		}
		if (e.getGameObject() == dropOff)
		{
			dropOff = null;
		}
	}

	@Subscribe
	public void onWorldViewUnloaded(WorldViewUnloaded e)
	{
		if (pickUp != null && pickUp.getWorldView() == e.getWorldView())
		{
			pickUp = null;
		}
		if (dropOff != null && dropOff.getWorldView() == e.getWorldView())
		{
			dropOff = null;
		}
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!active)
		{
			return null;
		}

		GameObject target = hasRum() ? dropOff : pickUp;
		if (target == null)
		{
			return null;
		}

		Shape hull = target.getConvexHull();
		if (hull == null)
		{
			return null;
		}

		graphics.setColor(new Color(0, 0, 0, 50));
		graphics.setStroke(new BasicStroke(2));
		graphics.fill(hull);
		graphics.setColor(COLOUR_RUM);
		graphics.draw(hull);

		return null;
	}

	private boolean hasRum()
	{
		Widget widget = client.getWidget(InterfaceID.SailingBtHud.BT_PARTIAL_GFX);
		return widget != null && widget.getSpriteId() == SPRITE_ID_RUM;
	}
}

package com.duckblade.osrs.sailing.features.facilities;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.features.courier.CourierTaskTracker;
import com.duckblade.osrs.sailing.features.util.BoatTracker;
import com.duckblade.osrs.sailing.features.util.SailingUtil;
import com.duckblade.osrs.sailing.model.Boat;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import com.google.common.base.Joiner;
import com.google.common.base.Splitter;
import com.google.common.collect.HashMultiset;
import com.google.common.collect.ImmutableMultiset;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Multiset;
import com.google.common.collect.Multisets;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.GameState;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.NPC;
import net.runelite.api.Point;
import net.runelite.api.Skill;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.OverheadTextChanged;
import net.runelite.api.events.StatChanged;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.RuneScapeProfileChanged;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.util.ColorUtil;

@Slf4j
@Singleton
public class CargoHoldTracker
	extends Overlay
	implements PluginLifecycleComponent
{

	private static final String CONFIG_PREFIX = "cargoHoldInventory_";

	private static final int UNKNOWN_ITEM = -1;

	// todo cargo pickup and dropoff
	// these aren't necessary as of dec 4 2025 but jagex has said that is temporary (we'll see)
	private static final String MES_CARGO_PACK_PERSONAL = "You deposit some cargo into the cargo hold."; // always 1
	private static final String MES_CARGO_PACK_CREW = "Your crew pack the cargo they were holding into the cargo hold."; // todo determine amount?

	private static final String MSG_CREWMATE_SALVAGES = "Managed to hook some salvage! I'll put it in the cargo hold.";
	private static final String MSG_CREWMATE_SALVAGE_FULL = "The cargo hold is full. I can't salvage anything.";
	private static final String WIDGET_TEXT_CARGO_HOLD_EMPTY = "This cargo hold has no items to show here.";

	private static final Set<String> JENKINS_MESSAGES = ImmutableSet.of(
		"Wooo.",
		"Woooo wooo.",
		"Woooo wooo wooo.",
		"Woooo wooooo woooo.",
		"Woooo wooo wooooo woooo."
	);

	private static final Set<Integer> CARGO_INVENTORY_IDS = ImmutableSet.of(
		InventoryID.SAILING_BOAT_1_CARGOHOLD,
		InventoryID.SAILING_BOAT_2_CARGOHOLD,
		InventoryID.SAILING_BOAT_3_CARGOHOLD,
		InventoryID.SAILING_BOAT_4_CARGOHOLD,
		InventoryID.SAILING_BOAT_5_CARGOHOLD
	);

	private static final char CONFIG_DELIMITER_PAIRS = ';';
	private static final char CONFIG_DELIMITER_KV = ':';
	private static final Splitter.MapSplitter CONFIG_SPLITTER = Splitter.on(CONFIG_DELIMITER_PAIRS)
		.withKeyValueSeparator(CONFIG_DELIMITER_KV);
	private static final Joiner.MapJoiner CONFIG_JOINER = Joiner.on(CONFIG_DELIMITER_PAIRS)
		.withKeyValueSeparator(CONFIG_DELIMITER_KV);

	private static final int INVENTORY_DELTA_MAX_DELAY = 2;

	private final Client client;
	private final ConfigManager configManager;
	private final BoatTracker boatTracker;
	private final CourierTaskTracker courierTaskTracker;

	// boat slot -> item id+count
	private final Map<Integer, Multiset<Integer>> cargoHoldItems = new HashMap<>();
	private final Map<Integer, Boolean> stackabilityCache = new HashMap<>();

	private Multiset<Integer> memoizedInventory;

	private boolean overlayEnabled;
	private int pendingInventoryAction;
	private boolean sawItemContainerUpdate;
	private boolean sawInventoryContainerUpdate;

	private int lastXp;
	private boolean pendingJenkinsAction;

	@Inject
	public CargoHoldTracker(Client client, ConfigManager configManager, BoatTracker boatTracker, CourierTaskTracker courierTaskTracker)
	{
		this.client = client;
		this.configManager = configManager;
		this.boatTracker = boatTracker;
		this.courierTaskTracker = courierTaskTracker;

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		// always on for tracking events, conditionally display
		overlayEnabled = config.cargoHoldShowCounts();
		return true;
	}

	@Override
	public void startUp()
	{
		loadAllFromConfig();

		if (client.getGameState() == GameState.LOGGED_IN)
		{
			lastXp = client.getSkillExperience(Skill.SAILING);
		}
	}

	@Override
	public void shutDown()
	{
		cargoHoldItems.clear();
		memoizedInventory = null;
		pendingJenkinsAction = false;
	}

	@Override
	public Dimension render(Graphics2D g)
	{
		if (!overlayEnabled || !SailingUtil.isSailing(client))
		{
			return null;
		}

		Boat boat = boatTracker.getBoat();
		GameObject cargoHold = boat != null ? boat.getCargoHold() : null;
		if (cargoHold == null)
		{
			return null;
		}

		int maxCapacity = maxCapacity();
		int usedCapacity = usedCapacity();
		String text = (usedCapacity != -1 ? String.valueOf(usedCapacity) : "???") + "/" + (maxCapacity != -1 ? String.valueOf(maxCapacity) : "???");
		Color textColour = ColorUtil.colorLerp(Color.GREEN, Color.RED, (double) usedCapacity / maxCapacity);
		Point textLocation = cargoHold.getCanvasTextLocation(g, text, 0);
		if (textLocation != null)
		{
			OverlayUtil.renderTextLocation(g, textLocation, text, textColour);
		}

		return null;
	}

	@Subscribe
	public void onRuneScapeProfileChanged(RuneScapeProfileChanged e)
	{
		loadAllFromConfig();
	}

	@Subscribe
	public void onOverheadTextChanged(OverheadTextChanged e)
	{
		Actor actor = e.getActor();
		if (!(actor instanceof NPC) ||
			!SailingUtil.isSailing(client) ||
			actor.getWorldView() != client.getLocalPlayer().getWorldView())
		{
			return;
		}

		if (MSG_CREWMATE_SALVAGES.equals(e.getOverheadText()))
		{
			// todo different ones? doesn't matter now since it's count only but will matter later
			log.trace("crewmate salvage");
			add(ItemID.SAILING_SMALL_SHIPWRECK_SALVAGE, 1);
			writeToConfig();
			return;
		}

		if (MSG_CREWMATE_SALVAGE_FULL.equals(e.getOverheadText()))
		{
			set(UNKNOWN_ITEM, maxCapacity() - usedCapacity());
			writeToConfig();
			return;
		}

		if (JENKINS_MESSAGES.contains(e.getOverheadText()))
		{
			pendingJenkinsAction = true;
		}
	}

	@Subscribe
	public void onStatChanged(StatChanged e)
	{
		if (e.getSkill() == Skill.SAILING &&
			lastXp != (lastXp = e.getXp()) &&
			pendingJenkinsAction)
		{
			log.trace("jenkins salvage");
			add(ItemID.SAILING_SMALL_SHIPWRECK_SALVAGE, 1);
			writeToConfig();
		}
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged e)
	{
		if (e.getContainerId() == InventoryID.INV)
		{
			sawInventoryContainerUpdate = true;
			return;
		}

		if (!CARGO_INVENTORY_IDS.contains(e.getContainerId() & 0x4FFF))
		{
			return;
		}

		sawItemContainerUpdate = true;

		ItemContainer containerInv = e.getItemContainer();
		Multiset<Integer> trackedInv = cargoHold();
		trackedInv.clear();
		for (Item item : containerInv.getItems())
		{
			if (item == null)
			{
				continue;
			}

			if (courierTaskTracker.getTaskForItemID(item.getId()) != null)
			{
				continue;
			}

			add(item.getId(), item.getQuantity());
		}

		log.debug("read cargo hold inventory from event {}", trackedInv);
		writeToConfig();
	}

	@Subscribe
	public void onGameTick(GameTick e)
	{
		pendingJenkinsAction = false;

		if (--pendingInventoryAction < 0)
		{
			sawItemContainerUpdate = false;
			return;
		}

		if (sawItemContainerUpdate)
		{
			// trust the item container event over any guesswork
			resetInventoryDeltaState();
			return;
		}

		if (!sawInventoryContainerUpdate || memoizedInventory == null)
		{
			// inventory change might be delayed an extra tick if action was clicked near the tick boundary
			return;
		}

		Multiset<Integer> oldInventory = memoizedInventory;
		resetInventoryDeltaState();

		Multiset<Integer> cargoHoldToUpdate = cargoHold();

		Multiset<Integer> newInventory = getInventoryMap();
		log.trace("new inventory {}", newInventory);

		Multiset<Integer> withdrawn = Multisets.difference(newInventory, oldInventory); // items found in inv that weren't in prior snapshot
		log.trace("withdrawn: {}", withdrawn);

		Multiset<Integer> deposited = Multisets.difference(oldInventory, newInventory); // items missing from inv that were in prior snapshot
		log.trace("deposited: {}", deposited);

		Multisets.removeOccurrences(cargoHoldToUpdate, withdrawn);
		deposited.entrySet().forEach(entry -> cargoHoldToUpdate.add(entry.getElement(), entry.getCount()));

		log.debug("updated cargo hold from inventory delta {}", cargoHoldToUpdate);
		writeToConfig();
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked e)
	{
		if (!e.getMenuOption().contains("Withdraw") && !e.getMenuOption().contains("Deposit"))
		{
			return;
		}

		Widget cargoHoldWidget = client.getWidget(InterfaceID.SailingBoatCargohold.UNIVERSE); // todo confirm
		if (cargoHoldWidget != null && !cargoHoldWidget.isHidden())
		{
			pendingInventoryAction = INVENTORY_DELTA_MAX_DELAY;
			memoizedInventory = getInventoryMap();
			log.debug("queued pendingInventoryAction with inventory {}", memoizedInventory);
		}
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded e)
	{
		if (e.getGroupId() != InterfaceID.SAILING_BOAT_CARGOHOLD)
		{
			return;
		}

		Widget itemsParent = client.getWidget(InterfaceID.SailingBoatCargohold.ITEMS);
		Widget itemsChild = itemsParent != null ? itemsParent.getChild(0) : null;
		if (itemsChild != null && Objects.equals(itemsChild.getText(), WIDGET_TEXT_CARGO_HOLD_EMPTY))
		{
			cargoHold().clear();
		}
	}

	private void resetInventoryDeltaState()
	{
		pendingInventoryAction = 0;
		sawItemContainerUpdate = false;
		sawInventoryContainerUpdate = false;
		memoizedInventory = null;
	}

	private Multiset<Integer> cargoHold()
	{
		return cargoHold(currentBoatSlot());
	}

	private Multiset<Integer> cargoHold(int boatSlot)
	{
		return cargoHoldItems.computeIfAbsent(boatSlot, k -> HashMultiset.create());
	}

	private int currentBoatSlot()
	{
		return client.getVarbitValue(VarbitID.SAILING_LAST_PERSONAL_BOAT_BOARDED) - 1;
	}

	private int usedCapacity()
	{
		return Math.min(maxCapacity(), Math.max(0, cargoHold().size()));
	}

	private int maxCapacity()
	{
		Boat boat = boatTracker.getBoat();
		if (boat == null)
		{
			return -1;
		}

		return boat.getCargoCapacity(client);
	}

	private Multiset<Integer> getInventoryMap()
	{
		ItemContainer inv = client.getItemContainer(InventoryID.INV);
		if (inv == null)
		{
			return ImmutableMultiset.of();
		}

		Multiset<Integer> ret = HashMultiset.create();
		for (Item item : inv.getItems())
		{
			if (item == null || item.getId() == UNKNOWN_ITEM)
			{
				continue;
			}

			// todo fix stackable items
			ret.add(item.getId());
		}

		return ret;
	}

	private void add(int item, int count)
	{
		if (isStackable(item))
		{
			cargoHold().setCount(item, 1);
		}
		else
		{
			cargoHold().add(item, count);
		}
	}

	private void set(int item, int count)
	{
		if (isStackable(item))
		{
			cargoHold().setCount(item, 1);
		}
		else
		{
			cargoHold().setCount(item, count);
		}
	}

	private boolean isStackable(int itemId)
	{
		assert client.isClientThread();
		return stackabilityCache.computeIfAbsent(itemId, id ->
			client.getItemDefinition(id).isStackable()
		);
	}

	private String configKey(int boatSlot)
	{
		return CONFIG_PREFIX + boatSlot;
	}

	private void loadAllFromConfig()
	{
		if (configManager.getRSProfileKey() != null)
		{
			for (int boatSlot = 0; boatSlot < 5; boatSlot++)
			{
				loadFromConfig(boatSlot);
			}
		}
	}

	private void loadFromConfig(int boatSlot)
	{
		String key = configKey(boatSlot);
		String savedInventory = configManager.getRSProfileConfiguration(SailingConfig.CONFIG_GROUP, key);
		if (savedInventory != null)
		{
			Multiset<Integer> hold = cargoHold(boatSlot);
			CONFIG_SPLITTER.split(savedInventory).forEach((k, v) ->
				hold.add(Integer.parseInt(k), Integer.parseInt(v)));
			log.debug("read cargoHold {} from config {} = {}", boatSlot, key, hold);
		}
	}

	private void writeToConfig()
	{
		writeToConfig(currentBoatSlot());
	}

	private void writeToConfig(int boatSlot)
	{
		String key = configKey(boatSlot);
		Multiset<Integer> hold = cargoHold(boatSlot);
		String configValue = CONFIG_JOINER.join(hold.entrySet()
			.stream()
			.map(entry -> Map.entry(entry.getElement(), entry.getCount()))
			.iterator());

		configManager.setRSProfileConfiguration(SailingConfig.CONFIG_GROUP, key, configValue);
		log.trace("wrote cargoHold {} to config {} = {}", boatSlot, key, configValue);
	}

}

package com.duckblade.osrs.sailing.features.facilities;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.features.util.BoatTracker;
import com.duckblade.osrs.sailing.features.util.SailingUtil;
import com.duckblade.osrs.sailing.model.Boat;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Shape;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

@Slf4j
@Singleton
public class LuffOverlay
	extends Overlay
	implements PluginLifecycleComponent
{
	private final Client client;
	private final SailingConfig config;
	private final BoatTracker boatTracker;

	@Inject
	public LuffOverlay(Client client, SailingConfig config, BoatTracker boatTracker)
	{
		this.client = client;
		this.config = config;
		this.boatTracker = boatTracker;

		setLayer(OverlayLayer.ABOVE_SCENE);
		setPosition(OverlayPosition.DYNAMIC);
	}

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		return config.highlightTrimmableSails();
	}

	@Override
	public Dimension render(Graphics2D g)
	{
		if (!SailingUtil.isSailing(client) || !config.highlightTrimmableSails())
		{
			return null;
		}

		Boat boat = boatTracker.getBoat();
		GameObject sail = boat != null ? boat.getSail() : null;
		if (sail == null)
		{
			return null;
		}

		if (!sail.isOpShown(0))
		{
			return null;
		}

		Shape convexHull = sail.getConvexHull();
		if (convexHull != null)
		{
			OverlayUtil.renderPolygon(g, convexHull, Color.green);
		}

		return null;
	}
}

package com.duckblade.osrs.sailing.features.facilities;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.SailingPlugin;
import com.duckblade.osrs.sailing.features.util.BoatTracker;
import com.duckblade.osrs.sailing.features.util.SailingUtil;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameTick;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.overlay.infobox.InfoBox;
import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.Color;

@Singleton
public class SpeedBoostInfoBox
	extends InfoBox
	implements PluginLifecycleComponent
{

	private static final int ICON_ID_LUFF = 7075;

	private static final String CHAT_LUFF_SAIL = "You trim the sails, catching the wind for a burst of speed!";
	private static final String CHAT_LUFF_STORED = "You release the wind mote for a burst of speed!";

	private final Client client;
	private final BoatTracker boatTracker;

	private int speedBoostDuration;

	@Inject
	public SpeedBoostInfoBox(SailingPlugin plugin, Client client, SpriteManager spriteManager, BoatTracker boatTracker)
	{
		super(null, plugin);
		spriteManager.getSpriteAsync(ICON_ID_LUFF, 0, this);

		this.client = client;
		this.boatTracker = boatTracker;
	}

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		return config.showSpeedBoostInfoBox();
	}

	@Override
	public void shutDown()
	{
		speedBoostDuration = 0;
	}

	@Subscribe
	public void onChatMessage(ChatMessage e)
	{
		if (!SailingUtil.isSailing(client) ||
			(e.getType() != ChatMessageType.GAMEMESSAGE && e.getType() != ChatMessageType.SPAM))
		{
			return;
		}

		String msg = e.getMessage();
		if (CHAT_LUFF_SAIL.equals(msg) || CHAT_LUFF_STORED.equals(msg))
		{
			// offset by 1, onGameTick fires _after_ onChatMessage
			speedBoostDuration = boatTracker.getBoat().getSpeedBoostDuration() + 1;
		}
	}

	@Subscribe
	public void onGameTick(GameTick e)
	{
		if (speedBoostDuration > 0)
		{
			--speedBoostDuration;
		}
	}

	@Override
	public boolean render()
	{
		return speedBoostDuration > 0;
	}

	@Override
	public String getText()
	{
		return Integer.toString(speedBoostDuration);
	}

	@Override
	public Color getTextColor()
	{
		return Color.GREEN;
	}
}

package com.duckblade.osrs.sailing.features.facilities;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.features.util.SailingUtil;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.util.HashMap;
import java.util.Map;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.DynamicObject;
import net.runelite.api.GameObject;
import net.runelite.api.Renderable;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.WorldViewUnloaded;
import net.runelite.api.gameval.ObjectID;
import net.runelite.client.Notifier;
import net.runelite.client.config.Notification;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

@Slf4j
@Singleton
public class CrystalExtractorHighlight
	extends Overlay
	implements PluginLifecycleComponent
{

	private static final int ANIMATION_CRYSTAL_EXTRACTOR_CRYSTAL_HARVESTABLE = 13177;

	private final Client client;
	private final Notifier notifier;

	private final Map<Integer, GameObject> extractors = new HashMap<>();

	private boolean highlightHarvestable;
	private Color harvestableColour;
	private Notification harvestableNotification;

	private boolean highlightInactive;
	private Color inactiveColour;

	private boolean notified = false;

	@Inject
	public CrystalExtractorHighlight(Client client, Notifier notifier)
	{
		this.client = client;
		this.notifier = notifier;

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		highlightHarvestable = config.highlightCrystalExtractorHarvestable();
		harvestableColour = config.highlightCrystalExtractorHarvestableColour();
		harvestableNotification = config.notifyCrystalExtractorHarvestable();

		highlightInactive = config.highlightCrystalExtractorInactive();
		inactiveColour = config.highlightCrystalExtractorInactiveColour();

		return highlightHarvestable || highlightInactive;
	}

	@Override
	public void shutDown()
	{
		extractors.clear();
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned e)
	{
		GameObject go = e.getGameObject();
		if (go.getId() == ObjectID.SAILING_CRYSTAL_EXTRACTOR_ACTIVATED ||
			go.getId() == ObjectID.SAILING_CRYSTAL_EXTRACTOR_DEACTIVATED)
		{
			extractors.put(go.getWorldView().getId(), go);
		}
	}

	@Subscribe
	public void onGameObjectDespawned(GameObjectDespawned e)
	{
		if (e.getGameObject().getId() == ObjectID.SAILING_CRYSTAL_EXTRACTOR_ACTIVATED ||
			e.getGameObject().getId() == ObjectID.SAILING_CRYSTAL_EXTRACTOR_DEACTIVATED)
		{
			extractors.remove(e.getGameObject().getWorldView().getId());
		}
	}

	@Subscribe
	public void onWorldViewUnloaded(WorldViewUnloaded e)
	{
		extractors.remove(e.getWorldView().getId());
	}

	@Override
	public Dimension render(Graphics2D g)
	{
		if (!SailingUtil.isSailing(client))
		{
			return null;
		}

		int wvId = client.getLocalPlayer().getWorldView().getId();
		GameObject extractor = extractors.get(wvId);
		Shape hull = extractor != null ? extractor.getConvexHull() : null;
		if (extractor == null || hull == null)
		{
			return null;
		}

		if ((extractor.getId() == ObjectID.SAILING_CRYSTAL_EXTRACTOR_ACTIVATED && !highlightHarvestable) ||
			(extractor.getId() == ObjectID.SAILING_CRYSTAL_EXTRACTOR_DEACTIVATED && !highlightInactive))
		{
			return null;
		}

		if (extractor.getId() == ObjectID.SAILING_CRYSTAL_EXTRACTOR_ACTIVATED)
		{
			Renderable r = extractor.getRenderable();
			if (!(r instanceof DynamicObject))
			{
				return null;
			}

			DynamicObject dyn = (DynamicObject) r;
			int anim = dyn.getAnimation() != null ? dyn.getAnimation().getId() : -1;
			if (anim == ANIMATION_CRYSTAL_EXTRACTOR_CRYSTAL_HARVESTABLE)
			{
				if (!notified)
				{
					notified = true;
					notifier.notify(harvestableNotification, "Your crystal extractor has extracted a crystal mote!");
				}
			}
			else
			{
				notified = false;
				return null;
			}
		}

		Color colour = extractor.getId() == ObjectID.SAILING_CRYSTAL_EXTRACTOR_ACTIVATED ? harvestableColour : inactiveColour;
		OverlayUtil.renderPolygon(g, hull, colour);

		return null;
	}
}

package com.duckblade.osrs.sailing.features.crewmates;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.events.OverheadTextChanged;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class CrewmateOverheadMuter
	implements PluginLifecycleComponent
{

	private final Client client;

	private SailingConfig.CrewmateMuteMode mode;

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		mode = config.crewmatesMuteOverheads();
		return mode != SailingConfig.CrewmateMuteMode.NONE;
	}

	@Subscribe
	public void onOverheadTextChanged(OverheadTextChanged e)
	{
		Actor npc = e.getActor();
		if (!(npc instanceof NPC))
		{
			return;
		}

		if (npc.getWorldView().isTopLevel())
		{
			return;
		}

		if (mode == SailingConfig.CrewmateMuteMode.OTHER_BOATS &&
			npc.getWorldView() == client.getLocalPlayer().getWorldView())
		{
			return;
		}

		log.trace("muting npc {}={} in wv {}", ((NPC) npc).getId(), npc.getName(), npc.getWorldView().getId());
		npc.setOverheadCycle(-1);
		npc.setOverheadText("");
	}
}

package com.duckblade.osrs.sailing.features.oceanencounters;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.gameval.NpcID;
import net.runelite.api.events.NpcSpawned;
import net.runelite.client.Notifier;
import net.runelite.client.eventbus.Subscribe;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class ClueTurtle implements PluginLifecycleComponent
{
	private final SailingConfig config;

	private final Notifier notifier;

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		return config.notifyClueTurtleSpawn().isEnabled();
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned e)
	{
		if (e.getNpc().getId() == NpcID.SAILING_CHANCE_ENCOUNTER_CLUE_TURTLE)
		{
			notifier.notify(config.notifyClueTurtleSpawn(), "A clue turtle has spawned.");
		}
	}
}

package com.duckblade.osrs.sailing.features.oceanencounters;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.gameval.NpcID;
import net.runelite.api.events.NpcSpawned;
import net.runelite.client.Notifier;
import net.runelite.client.eventbus.Subscribe;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class LostShipment implements PluginLifecycleComponent
{
	private final SailingConfig config;

	private final Notifier notifier;

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		return config.notifyLostShipmentSpawn().isEnabled();
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned e)
	{
		switch (e.getNpc().getId())
		{
			case NpcID.SAILING_CHANCE_ENCOUNTER_LOST_GOODS_WOOD:
			case NpcID.SAILING_CHANCE_ENCOUNTER_LOST_GOODS_OAK:
			case NpcID.SAILING_CHANCE_ENCOUNTER_LOST_GOODS_TEAK:
			case NpcID.SAILING_CHANCE_ENCOUNTER_LOST_GOODS_MAHOGANY:
			case NpcID.SAILING_CHANCE_ENCOUNTER_LOST_GOODS_CAMPHOR:
			case NpcID.SAILING_CHANCE_ENCOUNTER_LOST_GOODS_IRONWOOD:
				notifier.notify(config.notifyLostShipmentSpawn(), "A lost shipment has spawned.");
				break;
		}
	}
}

package com.duckblade.osrs.sailing.features.oceanencounters;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.gameval.NpcID;
import net.runelite.api.events.NpcSpawned;
import net.runelite.client.Notifier;
import net.runelite.client.eventbus.Subscribe;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class GiantClam implements PluginLifecycleComponent
{
	private final SailingConfig config;

	private final Notifier notifier;

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		return config.notifyGiantClamSpawn().isEnabled();
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned e)
	{
		switch (e.getNpc().getId())
		{
			case NpcID.SAILING_CHANCE_ENCOUNTERS_CLAM_OPEN:
			case NpcID.SAILING_CHANCE_ENCOUNTERS_CLAM_PEARL:
				notifier.notify(config.notifyGiantClamSpawn(), "A giant clam has spawned.");
				break;
		}
	}
}

package com.duckblade.osrs.sailing.features.oceanencounters;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.gameval.NpcID;
import net.runelite.api.events.NpcSpawned;
import net.runelite.client.Notifier;
import net.runelite.client.eventbus.Subscribe;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class Castaway implements PluginLifecycleComponent
{
	private final SailingConfig config;

	private final Notifier notifier;

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		return config.notifyCastawaySpawn().isEnabled();
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned e)
	{
		switch (e.getNpc().getId())
		{
			case NpcID.SAILING_CHANCE_ENCOUNTERS_RESCUE_MAN1_ADRIFT:
			case NpcID.SAILING_CHANCE_ENCOUNTERS_RESCUE_MAN1_PASSENGER:
			case NpcID.SAILING_CHANCE_ENCOUNTERS_RESCUE_MAN2_ADRIFT:
			case NpcID.SAILING_CHANCE_ENCOUNTERS_RESCUE_MAN2_PASSENGER:
			case NpcID.SAILING_CHANCE_ENCOUNTERS_RESCUE_WOMAN1_ADRIFT:
			case NpcID.SAILING_CHANCE_ENCOUNTERS_RESCUE_WOMAN1_PASSENGER:
			case NpcID.SAILING_CHANCE_ENCOUNTERS_RESCUE_WOMAN2_ADRIFT:
			case NpcID.SAILING_CHANCE_ENCOUNTERS_RESCUE_WOMAN2_PASSENGER:
			case NpcID.SAILING_CHANCE_ENCOUNTERS_RESCUE_WOMAN3_ADRIFT:
			case NpcID.SAILING_CHANCE_ENCOUNTERS_RESCUE_WOMAN3_PASSENGER:
			case NpcID.SAILING_CHANCE_ENCOUNTERS_RESCUE_WILSON_ADRIFT:
			case NpcID.SAILING_CHANCE_ENCOUNTERS_RESCUE_WILSON_PASSENGER:
			case NpcID.SAILING_CHANCE_ENCOUNTERS_RESCUE_DOG1_ADRIFT:
			case NpcID.SAILING_CHANCE_ENCOUNTERS_RESCUE_DOG1_PASSENGER:
				notifier.notify(config.notifyCastawaySpawn(), "A castaway has spawned.");
				break;
		}
	}
}

package com.duckblade.osrs.sailing.features.oceanencounters;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.gameval.NpcID;
import net.runelite.api.events.NpcSpawned;
import net.runelite.client.Notifier;
import net.runelite.client.eventbus.Subscribe;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class MysteriousGlow implements PluginLifecycleComponent
{
	private final SailingConfig config;

	private final Notifier notifier;

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		return config.notifyMysteriousGlowSpawn().isEnabled();
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned e)
	{
		if (e.getNpc().getId() == NpcID.SAILING_CHANCE_ENCOUNTERS_GLOW)
		{
			notifier.notify(config.notifyMysteriousGlowSpawn(), "A mysterious glow has spawned.");
		}
	}
}

package com.duckblade.osrs.sailing.features.oceanencounters;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.gameval.NpcID;
import net.runelite.api.events.NpcSpawned;
import net.runelite.client.Notifier;
import net.runelite.client.eventbus.Subscribe;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class ClueCasket implements PluginLifecycleComponent
{
	private final SailingConfig config;

	private final Notifier notifier;

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		return config.notifyClueCasketSpawn().isEnabled();
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned e)
	{
		switch (e.getNpc().getId())
		{
			case NpcID.SAILING_CHANCE_ENCOUNTER_LOST_GOODS_CASKET_BEGINNER:
			case NpcID.SAILING_CHANCE_ENCOUNTER_LOST_GOODS_CASKET_EASY:
			case NpcID.SAILING_CHANCE_ENCOUNTER_LOST_GOODS_CASKET_MEDIUM:
			case NpcID.SAILING_CHANCE_ENCOUNTER_LOST_GOODS_CASKET_HARD:
			case NpcID.SAILING_CHANCE_ENCOUNTER_LOST_GOODS_CASKET_ELITE:
			case NpcID.SAILING_CHANCE_ENCOUNTER_LOST_GOODS_CASKET_MASTER:
				notifier.notify(config.notifyClueCasketSpawn(), "A clue casket has spawned.");
				break;
		}
	}
}

package com.duckblade.osrs.sailing.features.oceanencounters;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.gameval.NpcID;
import net.runelite.api.events.NpcSpawned;
import net.runelite.client.Notifier;
import net.runelite.client.eventbus.Subscribe;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class OceanMan implements PluginLifecycleComponent
{
	private final SailingConfig config;

	private final Notifier notifier;

	@Override
	public boolean isEnabled(SailingConfig config)
	{
		return config.notifyOceanManSpawn().isEnabled();
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned e)
	{
		if (e.getNpc().getId() == NpcID.SAILING_CHANCE_ENCOUNTERS_OCEAN_MAN)
		{
			notifier.notify(config.notifyOceanManSpawn(), "An ocean man has spawned.");
		}
	}
}

package com.duckblade.osrs.sailing;

import java.awt.Color;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Notification;
import net.runelite.client.config.Range;
import net.runelite.client.util.ColorUtil;

@ConfigGroup(SailingConfig.CONFIG_GROUP)
public interface SailingConfig extends Config
{

	String CONFIG_GROUP = "sailing";

	// Config sections  keep at the top in declared order
	@ConfigSection(
		name = "Navigation",
		description = "Settings for navigating the world with your ship.",
		position = 100,
		closedByDefault = true
	)
	String SECTION_NAVIGATION = "navigation";

	@ConfigSection(
		name = "Facilities",
		description = "Settings for your ship facilities and components.",
		position = 200,
		closedByDefault = true
	)
	String SECTION_FACILITIES = "facilities";

	@ConfigSection(
		name = "Crewmates",
		description = "Settings for your crewmates.",
		position = 300,
		closedByDefault = true
	)
	String SECTION_CREWMATES = "crewmates";

	@ConfigSection(
		name = "Menu Entry Swaps",
		description = "Settings for Menu Entry Swaps",
		position = 400,
		closedByDefault = true
	)
	String SECTION_MES = "mes";

	@ConfigSection(
		name = "Sea Charting",
		description = "Settings for Sea Charting",
		position = 500,
		closedByDefault = true
	)
	String SECTION_SEA_CHARTING = "seaCharting";

	@ConfigSection(
		name = "Barracuda Trials",
		description = "Settings for Barracuda Trials",
		position = 600,
		closedByDefault = true
	)
	String SECTION_BARRACUDA_TRIALS = "barracudaTrials";

	@ConfigSection(
		name = "Courier Tasks",
		description = "Settings for courier tasks (AKA port tasks).",
		position = 700,
		closedByDefault = true
	)
	String SECTION_COURIER_TASKS = "courier";

	@ConfigSection(
		name = "Salvaging",
		description = "Settings for shipwreck salvaging.",
		position = 800,
		closedByDefault = true
	)
	String SECTION_SALVAGING = "salvaging";

	@ConfigSection(
		name = "Cargo Hold Tracking",
		description = "Settings for tracking the contents of your cargo hold.",
		position = 900,
		closedByDefault = true
	)
	String SECTION_CARGO_HOLD_TRACKING = "cargoHoldTracking";

	@ConfigSection(
		name = "Ocean Encounters",
		description = "Settings for the ocean encounter random events.",
		position = 1000,
		closedByDefault = true
	)
	String SECTION_OCEAN_ENCOUNTERS = "oceanEncounters";

	@ConfigSection(
		name = "Silly Things",
		description = "Fun options for the lighthearted sailor.",
		position = 1100,
		closedByDefault = true
	)
	String SECTION_SILLY = "silly";

	@ConfigItem(
		keyName = "highlightRapids",
		name = "Highlight Rapids",
		description = "Highlight rapids.",
		section = SECTION_NAVIGATION,
		position = 1
	)
	default boolean highlightRapids()
	{
		return true;
	}

	@ConfigItem(
		keyName = "safeRapidsColour",
		name = "Safe Rapids Colour",
		description = "Colour to highlight safely navigable rapids.",
		section = SECTION_NAVIGATION,
		position = 2
	)
	@Alpha
	default Color safeRapidsColor()
	{
		return Color.CYAN;
	}

	@ConfigItem(
		keyName = "dangerousRapidsColour",
		name = "Dangerous Rapids Colour",
		description = "Colour to highlight unnavigable dangerous rapids.",
		section = SECTION_NAVIGATION,
		position = 3
	)
	@Alpha
	default Color dangerousRapidsColour()
	{
		return Color.RED;
	}

	@ConfigItem(
		keyName = "unknownRapidsColour",
		name = "Unknown Rapids Colour",
		description = "Colour to highlight rapids rapids unknown to be navigable or not.",
		section = SECTION_NAVIGATION,
		position = 4
	)
	@Alpha
	default Color unknownRapidsColour()
	{
		return Color.YELLOW;
	}

	@ConfigItem(
		keyName = "highlightLightningCloudStrikes",
		name = "Highlight Lightning Cloud Strikes",
		description = "Highlights the lightning clouds that are about to strike and should be avoided",
		section = SECTION_NAVIGATION,
		position = 5
	)
	default boolean highlightLightningCloudStrikes()
	{
		return true;
	}

	@ConfigItem(
		keyName = "lightningCloudStrikeColour",
		name = "Lightning Strike Colour",
		description = "Colour to highlight lightning cloud strikes. Colour will appear darker when about to strike.",
		section = SECTION_NAVIGATION,
		position = 6
	)
	@Alpha
	default Color lightningCloudStrikeColour()
	{
		return new Color(210, 109, 3);
	}

	enum TrueTileMode
	{
		OFF,
		NAVIGATING,
		ALWAYS,
		;
	}

	@ConfigItem(
		keyName = "navigationTrueTileIndicator",
		name = "True \"Tile\"",
		description = "Shows the location of your boat according to the server.<br>NOTE: Boats use sub-tile positioning.",
		section = SECTION_NAVIGATION,
		position = 7
	)
	default TrueTileMode navigationTrueTileIndicator()
	{
		return TrueTileMode.OFF;
	}

	@ConfigItem(
		keyName = "navigationTrueTileIndicatorColor",
		name = "True \"Tile\" Colour",
		description = "The colour to use for indicating your true \"tile\".",
		section = SECTION_NAVIGATION,
		position = 8
	)
	default Color navigationTrueTileIndicatorColor()
	{
		return Color.CYAN;
	}

	enum NavigationOverlayMode
	{
		OFF,
		NAVIGATING,
		ALWAYS,
		;
	}

	@ConfigItem(
		keyName = "navigationOverlayMode",
		name = "Sail Overlay",
		description = "Overlays basic navigational info on your sails.",
		section = SECTION_NAVIGATION,
		position = 9
	)
	default NavigationOverlayMode navigationOverlayMode()
	{
		return NavigationOverlayMode.OFF;
	}

	@ConfigItem(
		keyName = "navigationOverlayColour",
		name = "Sail Overlay: Colour",
		description = "Colour to render the sails overlay with.",
		section = SECTION_NAVIGATION,
		position = 10
	)
	default Color navigationOverlayColour()
	{
		return new Color(0xC4C4C4);
	}

	@ConfigItem(
		keyName = "navigationOverlayHeading",
		name = "Sail Overlay: Heading",
		description = "Shows the heading of your boat.",
		section = SECTION_NAVIGATION,
		position = 11
	)
	default boolean navigationOverlayHeading()
	{
		return true;
	}

	@ConfigItem(
		keyName = "navigationOverlaySpeed",
		name = "Sail Overlay: Speed",
		description = "Shows the speed of your boat in quarter-tile units.",
		section = SECTION_NAVIGATION,
		position = 12
	)
	default boolean navigationOverlaySpeed()
	{
		return true;
	}

	@ConfigItem(
		keyName = "highlightTrimmableSails",
		name = "Highlight Trimmable Sails",
		description = "Highlight sails when they require trimming.",
		section = SECTION_FACILITIES,
		position = 1
	)
	default boolean highlightTrimmableSails()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showSpeedBoostInfoBox",
		name = "Show Speed Boost InfoBox",
		description = "Show an InfoBox with the duration of your active speed boost.",
		section = SECTION_FACILITIES,
		position = 2
	)
	default boolean showSpeedBoostInfoBox()
	{
		return true;
	}

	@ConfigItem(
		keyName = "highlightCrystalExtractorHarvestable",
		name = "Highlight Harvestable Extractor",
		description = "Highlight the activated crystal extractor when it has a mote available.",
		section = SECTION_FACILITIES,
		position = 3
	)
	default boolean highlightCrystalExtractorHarvestable()
	{
		return true;
	}

	@ConfigItem(
		keyName = "highlightCrystalExtractorHarvestableColour",
		name = "Harvestable Colour",
		description = "Colour to highlight the crystal extractor while animating.",
		section = SECTION_FACILITIES,
		position = 4
	)
	@Alpha
	default Color highlightCrystalExtractorHarvestableColour()
	{
		return new Color(0xFF3FC4F0);
	}

	@ConfigItem(
		keyName = "notifyCrystalExtractorHarvestable",
		name = "Notify Harvestable Extractor",
		description = "Notify you when the crystal extractor has a mote available.",
		section = SECTION_FACILITIES,
		position = 5
	)
	default Notification notifyCrystalExtractorHarvestable()
	{
		return Notification.OFF;
	}

	@ConfigItem(
		keyName = "highlightCrystalExtractorInactive",
		name = "Highlight Deactivated Extractor Deactivated",
		description = "Highlight the activated crystal extractor when it is animating.",
		section = SECTION_FACILITIES,
		position = 6
	)
	default boolean highlightCrystalExtractorInactive()
	{
		return true;
	}

	@ConfigItem(
		keyName = "highlightCrystalExtractorInactiveColour",
		name = "Deactivated Colour",
		description = "Colour to highlight the crystal extractor when it is deactivated.",
		section = SECTION_FACILITIES,
		position = 7
	)
	@Alpha
	default Color highlightCrystalExtractorInactiveColour()
	{
		return Color.YELLOW;
	}

	enum CrewmateMuteMode
	{
		NONE,
		OTHER_BOATS,
		ALL,
		;
	}

	@ConfigItem(
		keyName = "crewmatesMuteOverheads",
		name = "Mute Overhead Text",
		description = "Mutes the overhead text of crewmates.",
		section = SECTION_CREWMATES,
		position = 1
	)
	default CrewmateMuteMode crewmatesMuteOverheads()
	{
		return CrewmateMuteMode.NONE;
	}

	@ConfigItem(
		keyName = "disableSailsWhenNotAtHelm",
		name = "Sails At Helm Only",
		description = "Deprioritizes sail options when not at the helm.",
		section = SECTION_MES,
		position = 1
	)
	default boolean disableSailsWhenNotAtHelm()
	{
		return true;
	}

	@ConfigItem(
		keyName = "prioritizeCargoHold",
		name = "Prioritize Cargo Hold",
		description = "Make the Cargo Hold easier to click on by prioritizing it over other objects. Does not apply during Barracuda Trials.",
		section = SECTION_MES,
		position = 2
	)
	default boolean prioritizeCargoHold()
	{
		return true;
	}

	@ConfigItem(
		keyName = "hideStopNavigatingDuringTrials",
		name = "Deprio Stop-navigating During BT",
		description = "Deprioritizes the 'Stop-navigating' and 'Escape' option while you are in a Barracuda Trial.",
		section = SECTION_MES,
		position = 3
	)
	default boolean hideStopNavigatingDuringTrials()
	{
		return true;
	}

	enum ShowChartsMode
	{
		NONE,
		REQUIREMENTS_MET,
		UNCHARTED,
		CHARTED,
		ALL,
		;

		public boolean isHidden(boolean completed, boolean meetsRequirements)
		{
			switch (this)
			{
				case ALL:
					return false;

				case CHARTED:
					return !completed;

				case UNCHARTED:
					return completed;

				case REQUIREMENTS_MET:
					return completed || !meetsRequirements;

				default:
					return true;
			}
		}
	}

	@ConfigItem(
		keyName = "showCharts",
		name = "Highlight Sea Charting Locations",
		description = "Highlight nearby sea charting locations.",
		section = SECTION_SEA_CHARTING,
		position = 1
	)
	default ShowChartsMode showCharts()
	{
		return ShowChartsMode.UNCHARTED;
	}

	String SHOW_CHARTS_ON_MAP = "showChartsOnMap";

	@ConfigItem(
		keyName = SHOW_CHARTS_ON_MAP,
		name = "Charting Map Icons",
		description = "Add icons for sea charting locations to the world map.",
		section = SECTION_SEA_CHARTING,
		position = 2
	)
	default ShowChartsMode showChartsOnMap()
	{
		return ShowChartsMode.UNCHARTED;
	}

	@ConfigItem(
		keyName = "chartingUnchartedColor",
		name = "Uncharted Colour",
		description = "Colour to highlight nearby uncharted locations.",
		section = SECTION_SEA_CHARTING,
		position = 3
	)
	@Alpha
	default Color chartingUnchartedColor()
	{
		return Color.GREEN;
	}

	@ConfigItem(
		keyName = "chartingChartedColor",
		name = "Charted Colour",
		description = "Colour to highlight nearby charted locations.",
		section = SECTION_SEA_CHARTING,
		position = 4
	)
	@Alpha
	default Color chartingChartedColor()
	{
		return Color.YELLOW;
	}

	@ConfigItem(
		keyName = "chartingUnavailableColor",
		name = "Unavailable Colour",
		description = "Colour to highlight nearby uncharted locations you do not meet requirements for.",
		section = SECTION_SEA_CHARTING,
		position = 5
	)
	@Alpha
	default Color chartingRequirementsUnmetColor()
	{
		return Color.RED;
	}

	@ConfigItem(
		keyName = "chartingWeatherSolver",
		name = "Weather Station Solver",
		description = "Whether to provide a helper for weather charting.",
		section = SECTION_SEA_CHARTING,
		position = 6
	)
	default boolean chartingWeatherSolver()
	{
		return true;
	}

	@ConfigItem(
		keyName = "chartingDuckSolver",
		name = "Current Duck Solver",
		description = "Whether to provide a helper for current duck trails.",
		section = SECTION_SEA_CHARTING,
		position = 7
	)
	default boolean chartingDuckSolver()
	{
		return true;
	}

	@ConfigItem(
		keyName = "chartingMermaidSolver",
		name = "Mermaid Task Solver",
		description = "Whether to provide a helper for mermaid charting tasks.",
		section = SECTION_SEA_CHARTING,
		position = 8
	)
	default boolean chartingMermaidSolver()
	{
		return true;
	}

	@ConfigItem(
		keyName = "barracudaHighlightLostCrates",
		name = "Highlight Crates",
		description = "Highlight lost crates that need to be collected during Barracuda Trials.",
		section = SECTION_BARRACUDA_TRIALS,
		position = 1
	)
	default boolean barracudaHighlightLostCrates()
	{
		return true;
	}

	@ConfigItem(
		keyName = "barracudaHighlightLostCratesColour",
		name = "Crate Colour",
		description = "The colour to highlight lost crates.",
		section = SECTION_BARRACUDA_TRIALS,
		position = 2
	)
	@Alpha
	default Color barracudaHighlightLostCratesColour()
	{
		return Color.ORANGE;
	}

	@ConfigItem(
		keyName = "barracudaHidePortalTransitions",
		name = "Hide Portal Transitions",
		description = "Hide the transition animation when taking a portal in The Gwenith Glide.",
		section = SECTION_BARRACUDA_TRIALS,
		position = 3
	)
	default boolean barracudaHidePortalTransitions()
	{
		return false;
	}

	@ConfigItem(
		keyName = "barracudaTemporTantrumShowRumTarget",
		name = "TT: Show Rum Target",
		description = "Show whether you have rum/need to drop-off rum in the Tempor Tantrum course.",
		section = SECTION_BARRACUDA_TRIALS,
		position = 4
	)
	default boolean barracudaTemporTantrumShowRumTarget()
	{
		return true;
	}

	@ConfigItem(
		keyName = "barracudaJubblyJiveShowToadyTargets",
		name = "JJ: Show Toady Targets",
		description = "Show which outcrops need toadies thrown at them in the Jubbly Jive course.",
		section = SECTION_BARRACUDA_TRIALS,
		position = 5
	)
	default boolean barracudaJubblyJiveShowToadyTargets()
	{
		return true;
	}

	@ConfigItem(
		keyName = "barracudaSplitsChatMessage",
		name = "Splits Chat Message",
		description = "Post Barracuda Trials split times to chat.",
		section = SECTION_BARRACUDA_TRIALS,
		position = 6
	)
	default boolean barracudaSplitsChatMessage()
	{
		return false;
	}

	@ConfigItem(
		keyName = "barracudaSplitsOverlayPanel",
		name = "Splits Overlay Panel",
		description = "Show an overlay panel with Barracuda Trials split times.",
		section = SECTION_BARRACUDA_TRIALS,
		position = 7
	)
	default boolean barracudaSplitsOverlayPanel()
	{
		return false;
	}

	enum BarracudaSplitsToFileMode
	{
		OFF,
		SILENT,
		NOTIFY,
		;
	}

	@ConfigItem(
		keyName = "barracudaSplitsToFile",
		name = "Splits to File",
		description = "Write Barracuda Trials splits to a file.",
		section = SECTION_BARRACUDA_TRIALS,
		position = 8
	)
	default BarracudaSplitsToFileMode barracudaSplitsToFile()
	{
		return BarracudaSplitsToFileMode.OFF;
	}

	@ConfigItem(
		keyName = "courierItemIdentification",
		name = "Destination on Items",
		description = "Show the destination port on cargo crates in your inventory and cargo hold.",
		section = SECTION_COURIER_TASKS,
		position = 1
	)
	default boolean courierItemIdentification()
	{
		return true;
	}

	@ConfigItem(
		keyName = "courierItemShowPickupOverlay",
		name = "Highlight Pickup Table",
		description = "Highlight the ledger table if there is cargo to be picked up",
		section = SECTION_COURIER_TASKS,
		position = 2
	)
	default boolean courierItemShowPickupOverlay()
	{
		return true;
	}

	@ConfigItem(
		keyName = "courierItemPickupOverlayColor",
		name = "Pickup Table Colour",
		description = "Colour to highlight the pickup table",
		section = SECTION_COURIER_TASKS,
		position = 3
	)
	default Color courierItemPickupOverlayColor()
	{
		return Color.GREEN;
	}

	@ConfigItem(
		keyName = "courierItemShowDropOffOverlay",
		name = "Highlight Drop Off Table",
		description = "Highlight the ledger table if there is cargo to be dropped off",
		section = SECTION_COURIER_TASKS,
		position = 4
	)
	default boolean courierItemShowDropOffOverlay()
	{
		return true;
	}

	@ConfigItem(
		keyName = "courierItemDropOffOverlayColor",
		name = "Drop Off Table Colour",
		description = "Colour to highlight the drop off table",
		section = SECTION_COURIER_TASKS,
		position = 5
	)
	default Color courierItemDropOffOverlayColor()
	{
		return Color.RED;
	}

	@ConfigItem(
		keyName = "salvagingHighlightActiveWrecks",
		name = "Highlight Active Locations",
		description = "Whether to highlight active shipwrecks.",
		section = SECTION_SALVAGING,
		position = 1
	)
	default boolean salvagingHighlightActiveWrecks()
	{
		return true;
	}

	@ConfigItem(
		keyName = "salvagingHighlightActiveWrecksColour",
		name = "Active Colour",
		description = "Colour to highlight active shipwrecks.",
		section = SECTION_SALVAGING,
		position = 2
	)
	@Alpha
	default Color salvagingHighlightActiveWrecksColour()
	{
		return Color.GREEN;
	}

	@ConfigItem(
		keyName = "salvagingHighlightInactiveWrecks",
		name = "Highlight Inactive Locations",
		description = "Whether to highlight inactive shipwrecks.",
		section = SECTION_SALVAGING,
		position = 3
	)
	default boolean salvagingHighlightInactiveWrecks()
	{
		return true;
	}

	@ConfigItem(
		keyName = "salvagingHighlightInactiveWrecksColour",
		name = "Inactive Colour",
		description = "Colour to highlight inactive shipwrecks.",
		section = SECTION_SALVAGING,
		position = 4
	)
	@Alpha
	default Color salvagingHighlightInactiveWrecksColour()
	{
		return Color.DARK_GRAY;
	}

	@ConfigItem(
		keyName = "salvagingHideHighLevelWrecks",
		name = "High-Level Wrecks",
		description = "Hide wrecks for which you do not have the required level to salvage.",
		section = SECTION_SALVAGING,
		position = 5
	)
	default boolean salvagingHighlightHighLevelWrecks()
	{
		return false;
	}

	@ConfigItem(
		keyName = "salvagingHideHighLevelWrecksColour",
		name = "High-Level Colour",
		description = "Colour to highlight wrecks for which you do not have the required level to salvage.",
		section = SECTION_SALVAGING,
		position = 6
	)
	@Alpha
	default Color salvagingHighLevelWrecksColour()
	{
		return ColorUtil.colorWithAlpha(Color.RED, 64);
	}

	@ConfigItem(
		keyName = "cargoHoldShowCounts",
		name = "Show Item Count",
		description = "Shows total item counts over the cargo hold.",
		section = SECTION_CARGO_HOLD_TRACKING,
		position = 1
	)
	default boolean cargoHoldShowCounts()
	{
		return true;
	}

	@ConfigItem(
		keyName = "notifyGiantClamSpawn",
		name = "Notify on Giant clam",
		description = "Notify when a giant clam spawns.",
		section = SECTION_OCEAN_ENCOUNTERS,
		position = 1
	)
	default Notification notifyGiantClamSpawn()
	{
		return Notification.OFF;
	}

	@ConfigItem(
		keyName = "notifyClueTurtleSpawn",
		name = "Notify on Clue turtle",
		description = "Notify when a clue turtle spawns.",
		section = SECTION_OCEAN_ENCOUNTERS,
		position = 2
	)
	default Notification notifyClueTurtleSpawn()
	{
		return Notification.OFF;
	}

	@ConfigItem(
		keyName = "notifyCastawaySpawn",
		name = "Notify on Castaway",
		description = "Notify when a castaway spawns.",
		section = SECTION_OCEAN_ENCOUNTERS,
		position = 3
	)
	default Notification notifyCastawaySpawn()
	{
		return Notification.OFF;
	}

	@ConfigItem(
		keyName = "notifyClueCasketSpawn",
		name = "Notify on Clue casket",
		description = "Notify when a clue casket spawns.",
		section = SECTION_OCEAN_ENCOUNTERS,
		position = 4
	)
	default Notification notifyClueCasketSpawn()
	{
		return Notification.OFF;
	}

	@ConfigItem(
		keyName = "notifyLostShipmentSpawn",
		name = "Notify on Lost shipment",
		description = "Notify when a lost shipment spawns.",
		section = SECTION_OCEAN_ENCOUNTERS,
		position = 5
	)
	default Notification notifyLostShipmentSpawn()
	{
		return Notification.OFF;
	}

	@ConfigItem(
		keyName = "notifyMysteriousGlowSpawn",
		name = "Notify on Mysterious glow",
		description = "Notify when a mysterious glow spawns.",
		section = SECTION_OCEAN_ENCOUNTERS,
		position = 6
	)
	default Notification notifyMysteriousGlowSpawn()
	{
		return Notification.OFF;
	}

	@ConfigItem(
		keyName = "notifyOceanManSpawn",
		name = "Notify on Ocean man",
		description = "Notify when an ocean man spawns.",
		section = SECTION_OCEAN_ENCOUNTERS,
		position = 7
	)
	default Notification notifyOceanManSpawn()
	{
		return Notification.OFF;
	}

	@ConfigItem(
		keyName = "reverseBeep",
		name = "Reverse Beep",
		description = "Become a truck",
		section = SECTION_SILLY,
		position = 1
	)
	default boolean reverseBeep()
	{
		return false;
	}

	int REVERSE_BEEP_MAX = 100;
	@ConfigItem(
		keyName = "reverseBeepVolume",
		name = "Reverse Beep Volume",
		description = "From 1-100.",
		section = SECTION_SILLY,
		position = 2
	)
	@Range(max = REVERSE_BEEP_MAX)
	default int reverseBeepVolume()
	{
		return 25;
	}
}

package com.duckblade.osrs.sailing.module;

import com.duckblade.osrs.sailing.SailingConfig;
import com.duckblade.osrs.sailing.features.barracudatrials.HidePortalTransitions;
import com.duckblade.osrs.sailing.features.barracudatrials.JubblyJiveHelper;
import com.duckblade.osrs.sailing.features.barracudatrials.LostCargoHighlighter;
import com.duckblade.osrs.sailing.features.barracudatrials.TemporTantrumHelper;
import com.duckblade.osrs.sailing.features.barracudatrials.splits.BarracudaSplitsChatMessage;
import com.duckblade.osrs.sailing.features.barracudatrials.splits.BarracudaSplitsFileWriter;
import com.duckblade.osrs.sailing.features.barracudatrials.splits.BarracudaSplitsOverlayPanel;
import com.duckblade.osrs.sailing.features.barracudatrials.splits.BarracudaSplitsTracker;
import com.duckblade.osrs.sailing.features.charting.CurrentDuckTaskTracker;
import com.duckblade.osrs.sailing.features.charting.MermaidTaskSolver;
import com.duckblade.osrs.sailing.features.charting.SeaChartMapPointManager;
import com.duckblade.osrs.sailing.features.charting.SeaChartOverlay;
import com.duckblade.osrs.sailing.features.charting.SeaChartPanelOverlay;
import com.duckblade.osrs.sailing.features.charting.SeaChartTaskIndex;
import com.duckblade.osrs.sailing.features.charting.WeatherTaskTracker;
import com.duckblade.osrs.sailing.features.courier.CourierDestinationOverlay;
import com.duckblade.osrs.sailing.features.courier.CourierTaskLedgerOverlay;
import com.duckblade.osrs.sailing.features.courier.CourierTaskTracker;
import com.duckblade.osrs.sailing.features.crewmates.CrewmateOverheadMuter;
import com.duckblade.osrs.sailing.features.facilities.CargoHoldTracker;
import com.duckblade.osrs.sailing.features.facilities.CrystalExtractorHighlight;
import com.duckblade.osrs.sailing.features.facilities.LuffOverlay;
import com.duckblade.osrs.sailing.features.facilities.SpeedBoostInfoBox;
import com.duckblade.osrs.sailing.features.mes.DeprioSailsOffHelm;
import com.duckblade.osrs.sailing.features.mes.HideStopNavigatingDuringTrials;
import com.duckblade.osrs.sailing.features.mes.PrioritizeCargoHold;
import com.duckblade.osrs.sailing.features.navigation.LightningCloudsOverlay;
import com.duckblade.osrs.sailing.features.navigation.NavigationOverlay;
import com.duckblade.osrs.sailing.features.navigation.RapidsOverlay;
import com.duckblade.osrs.sailing.features.navigation.TrueTileIndicator;
import com.duckblade.osrs.sailing.features.oceanencounters.Castaway;
import com.duckblade.osrs.sailing.features.oceanencounters.ClueCasket;
import com.duckblade.osrs.sailing.features.oceanencounters.ClueTurtle;
import com.duckblade.osrs.sailing.features.oceanencounters.GiantClam;
import com.duckblade.osrs.sailing.features.oceanencounters.LostShipment;
import com.duckblade.osrs.sailing.features.oceanencounters.MysteriousGlow;
import com.duckblade.osrs.sailing.features.oceanencounters.OceanMan;
import com.duckblade.osrs.sailing.features.reversebeep.ReverseBeep;
import com.duckblade.osrs.sailing.features.salvaging.SalvagingHighlight;
import com.duckblade.osrs.sailing.features.util.BoatTracker;
import com.google.common.collect.ImmutableSet;
import com.google.inject.AbstractModule;
import com.google.inject.Provides;
import com.google.inject.Singleton;
import java.util.Set;
import javax.inject.Named;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;

@Slf4j
public class SailingModule extends AbstractModule
{

	@Override
	protected void configure()
	{
		bind(ComponentManager.class);
	}

	@Provides
	Set<PluginLifecycleComponent> lifecycleComponents(
		@Named("developerMode") boolean developerMode,

		BarracudaSplitsTracker barracudaSplitsTracker,
		BarracudaSplitsChatMessage barracudaSplitsChatMessage,
		BarracudaSplitsOverlayPanel barracudaSplitsOverlayPanel,
		BarracudaSplitsFileWriter barracudaSplitsFileWriter,
		BoatTracker boatTracker,
		CargoHoldTracker cargoHoldTracker,
		Castaway castaway,
		ClueCasket clueCasket,
		ClueTurtle clueTurtle,
		CourierTaskLedgerOverlay courierTaskLedgerOverlay,
		CourierTaskTracker courierTaskTracker,
		CourierDestinationOverlay courierDestinationOverlay,
		CrewmateOverheadMuter crewmateOverheadMuter,
		CurrentDuckTaskTracker currentDuckTaskTracker,
		DeprioSailsOffHelm deprioSailsOffHelm,
		HideStopNavigatingDuringTrials hideStopNavigatingDuringTrials,
		GiantClam giantClam,
		HidePortalTransitions hidePortalTransitions,
		JubblyJiveHelper jubblyJiveHelper,
		TemporTantrumHelper temporTantrumHelper,
		LightningCloudsOverlay lightningCloudsOverlay,
		LostCargoHighlighter lostCargoHighlighter,
		LostShipment lostShipment,
		LuffOverlay luffOverlay,
		CrystalExtractorHighlight crystalExtractorHighlight,
		MermaidTaskSolver mermaidTaskSolver,
		MysteriousGlow mysteriousGlow,
		OceanMan oceanMan,
		PrioritizeCargoHold prioritizeCargoHold,
		RapidsOverlay rapidsOverlay,
		ReverseBeep reverseBeep,
		SalvagingHighlight salvagingHighlight,
		SeaChartMapPointManager seaChartMapPointManager,
		SeaChartOverlay seaChartOverlay,
		SeaChartPanelOverlay seaChartPanelOverlay,
		SeaChartTaskIndex seaChartTaskIndex,
		SpeedBoostInfoBox speedBoostInfoBox,
		NavigationOverlay navigationOverlay,
		TrueTileIndicator trueTileIndicator,
		WeatherTaskTracker weatherTaskTracker
	)
	{
		var builder = ImmutableSet.<PluginLifecycleComponent>builder()
			.add(barracudaSplitsTracker)
			.add(barracudaSplitsChatMessage)
			.add(barracudaSplitsOverlayPanel)
			.add(barracudaSplitsFileWriter)
			.add(boatTracker)
			.add(cargoHoldTracker)
			.add(castaway)
			.add(clueCasket)
			.add(clueTurtle)
			.add(courierTaskLedgerOverlay)
			.add(courierTaskTracker)
			.add(courierDestinationOverlay)
			.add(crewmateOverheadMuter)
			.add(currentDuckTaskTracker)
			.add(deprioSailsOffHelm)
			.add(hideStopNavigatingDuringTrials)
			.add(giantClam)
			.add(hidePortalTransitions)
			.add(jubblyJiveHelper)
			.add(temporTantrumHelper)
			.add(lightningCloudsOverlay)
			.add(lostCargoHighlighter)
			.add(lostShipment)
			.add(luffOverlay)
			.add(crystalExtractorHighlight)
			.add(mermaidTaskSolver)
			.add(mysteriousGlow)
			.add(navigationOverlay)
			.add(oceanMan)
			.add(prioritizeCargoHold)
			.add(rapidsOverlay)
			.add(reverseBeep)
			.add(salvagingHighlight)
			.add(seaChartOverlay)
			.add(seaChartMapPointManager)
			.add(seaChartPanelOverlay)
			.add(seaChartTaskIndex)
			.add(speedBoostInfoBox)
			.add(trueTileIndicator)
			.add(weatherTaskTracker);

		// features still in development
		//noinspection StatementWithEmptyBody
		if (developerMode)
		{
		}

		return builder.build();
	}

	@Provides
	@Singleton
	SailingConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(SailingConfig.class);
	}

}

package com.duckblade.osrs.sailing.module;

import com.duckblade.osrs.sailing.SailingConfig;

public interface PluginLifecycleComponent
{

	default boolean isEnabled(SailingConfig config)
	{
		return true;
	}

	default void startUp()
	{
	}

	default void shutDown()
	{
	}

}

package com.duckblade.osrs.sailing.module;

import com.duckblade.osrs.sailing.SailingConfig;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBox;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.GameEventManager;

/**
 * Manages all the subcomponents of the plugin
 * so they can register themselves to RuneLite resources
 * e.g. EventBus/OverlayManager/init on startup/etc
 * instead of the {@link com.duckblade.osrs.sailing.SailingPlugin} class handling everything.
 */
@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class ComponentManager
{

	private final EventBus eventBus;
	private final OverlayManager overlayManager;
	private final InfoBoxManager infoBoxManager;
	private final GameEventManager gameEventManager;
	private final SailingConfig config;
	private final Set<PluginLifecycleComponent> components;

	private final Map<PluginLifecycleComponent, Boolean> states = new HashMap<>();

	public void onPluginStart()
	{
		eventBus.register(this);
		components.forEach(c -> states.put(c, false));
		revalidateComponentStates();
	}

	public void onPluginStop()
	{
		eventBus.unregister(this);
		components.stream()
			.filter(states::get)
			.forEach(this::tryShutDown);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged e)
	{
		if (!SailingConfig.CONFIG_GROUP.equals(e.getGroup()))
		{
			return;
		}

		revalidateComponentStates();
	}

	private void revalidateComponentStates()
	{
		components.forEach(c ->
		{
			boolean shouldBeEnabled = c.isEnabled(config);
			boolean isEnabled = states.get(c);
			if (shouldBeEnabled == isEnabled)
			{
				return;
			}

			if (shouldBeEnabled)
			{
				tryStartUp(c);
			}
			else
			{
				tryShutDown(c);
			}
		});
	}

	private void tryStartUp(PluginLifecycleComponent component)
	{
		if (states.get(component))
		{
			return;
		}

		if (log.isDebugEnabled())
		{
			log.debug("Enabling Sailing component [{}]", component.getClass().getName());
		}

		try
		{
			component.startUp();

			eventBus.register(component);
			if (component instanceof Overlay)
			{
				overlayManager.add((Overlay) component);
			}
			if (component instanceof InfoBox)
			{
				infoBoxManager.addInfoBox((InfoBox) component);
			}

			gameEventManager.simulateGameEvents(component);
			states.put(component, true);
		}
		catch (Throwable e)
		{
			log.error("Failed to start Sailing component [{}]", component.getClass().getName(), e);
		}
	}

	private void tryShutDown(PluginLifecycleComponent component)
	{
		eventBus.unregister(component);
		if (component instanceof Overlay)
		{
			overlayManager.remove((Overlay) component);
		}
		if (component instanceof InfoBox)
		{
			infoBoxManager.removeInfoBox((InfoBox) component);
		}

		if (!states.get(component))
		{
			return;
		}

		if (log.isDebugEnabled())
		{
			log.debug("Disabling Sailing component [{}]", component.getClass().getName());
		}

		try
		{
			component.shutDown();
		}
		catch (Throwable e)
		{
			log.error("Failed to cleanly shut down Sailing component [{}]", component.getClass().getName());
		}
		finally
		{
			states.put(component, false);
		}
	}

}

package com.duckblade.osrs.sailing.model;

import com.duckblade.osrs.sailing.features.util.SailingUtil;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import lombok.AccessLevel;
import lombok.Data;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.WorldEntity;

@Data
public class Boat
{

	@Getter
	private final int worldViewId;
	private final WorldEntity worldEntity;

	GameObject hull;
	GameObject sail;
	GameObject helm;
	GameObject cargoHold;

	@Setter(AccessLevel.NONE)
	Set<GameObject> salvagingHooks = new HashSet<>();

	// these are intentionally not cached in case the object is transformed without respawning
	// e.g. helms have a different idle vs in-use id
	public HullTier getHullTier()
	{
		return hull != null ? HullTier.fromGameObjectId(hull.getId()) : null;
	}

	public SailTier getSailTier()
	{
		return sail != null ? SailTier.fromGameObjectId(sail.getId()) : null;
	}

	public HelmTier getHelmTier()
	{
		return helm != null ? HelmTier.fromGameObjectId(helm.getId()) : null;
	}

	public List<SalvagingHookTier> getSalvagingHookTiers()
	{
		return salvagingHooks.stream()
			.mapToInt(GameObject::getId)
			.mapToObj(SalvagingHookTier::fromGameObjectId)
			.collect(Collectors.toList());
	}

	public CargoHoldTier getCargoHoldTier()
	{
		return cargoHold != null ? CargoHoldTier.fromGameObjectId(cargoHold.getId()) : null;
	}

	public SizeClass getSizeClass()
	{
		return hull != null ? SizeClass.fromGameObjectId(hull.getId()) : null;
	}

	public Set<GameObject> getAllFacilities()
	{
		Set<GameObject> facilities = new HashSet<>();
		facilities.add(hull);
		facilities.add(sail);
		facilities.add(helm);
		facilities.addAll(salvagingHooks);
		facilities.add(cargoHold);
		return facilities;
	}

	public int getCargoCapacity(boolean uim)
	{
		CargoHoldTier cargoHoldTier = getCargoHoldTier();
		if (cargoHoldTier == null)
		{
			return 0;
		}

		return cargoHoldTier.getCapacity(getSizeClass(), uim);
	}

	public int getCargoCapacity(Client client)
	{
		return getCargoCapacity(SailingUtil.isUim(client));
	}

	public int getSpeedBoostDuration()
	{
		SailTier sailTier = getSailTier();
		if (sailTier == null)
		{
			return -1;
		}

		return sailTier.getSpeedBoostDuration(getSizeClass());
	}

	public String getDebugString()
	{
		return String.format(
			"Id: %d, Hull: %s, Sail: %s, Helm: %s, Hook: %s, Cargo: %s",
			worldViewId,
			getHullTier(),
			getSailTier(),
			getHelmTier(),
			getSalvagingHookTiers()
				.stream()
				.map(SalvagingHookTier::toString)
				.collect(Collectors.joining(", ", "[", "]")),
			getCargoHoldTier()
		);
	}
}

package com.duckblade.osrs.sailing.model;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.gameval.ObjectID;

@RequiredArgsConstructor
@Getter
public enum SalvagingHookTier
{

	BRONZE(
		new int[]{
			ObjectID.SALVAGING_HOOK_RAFT_BRONZE,
			ObjectID.SALVAGING_HOOK_BRONZE,
			ObjectID.SALVAGING_HOOK_LARGE_BRONZE,
			ObjectID.SALVAGING_HOOK_LARGE_BRONZE_B,
		}
	),
	IRON(
		new int[]{
			ObjectID.SALVAGING_HOOK_RAFT_IRON,
			ObjectID.SALVAGING_HOOK_IRON,
			ObjectID.SALVAGING_HOOK_LARGE_IRON,
			ObjectID.SALVAGING_HOOK_LARGE_IRON_B,
		}
	),
	STEEL(
		new int[]{
			ObjectID.SALVAGING_HOOK_RAFT_STEEL,
			ObjectID.SALVAGING_HOOK_STEEL,
			ObjectID.SALVAGING_HOOK_LARGE_STEEL,
			ObjectID.SALVAGING_HOOK_LARGE_STEEL_B,
		}
	),
	MITHRIL(
		new int[]{
			ObjectID.SALVAGING_HOOK_RAFT_MITHRIL,
			ObjectID.SALVAGING_HOOK_MITHRIL,
			ObjectID.SALVAGING_HOOK_LARGE_MITHRIL,
			ObjectID.SALVAGING_HOOK_LARGE_MITHRIL_B,
		}
	),
	ADAMANT(
		new int[]{
			ObjectID.SALVAGING_HOOK_RAFT_ADAMANT,
			ObjectID.SALVAGING_HOOK_ADAMANT,
			ObjectID.SALVAGING_HOOK_LARGE_ADAMANT,
			ObjectID.SALVAGING_HOOK_LARGE_ADAMANT_B,
		}
	),
	RUNE(
		new int[]{
			ObjectID.SALVAGING_HOOK_RAFT_RUNE,
			ObjectID.SALVAGING_HOOK_RUNE,
			ObjectID.SALVAGING_HOOK_LARGE_RUNE,
			ObjectID.SALVAGING_HOOK_LARGE_RUNE_B,
		}
	),
	DRAGON(
		new int[]{
			ObjectID.SALVAGING_HOOK_RAFT_DRAGON,
			ObjectID.SALVAGING_HOOK_DRAGON,
			ObjectID.SALVAGING_HOOK_LARGE_DRAGON,
			ObjectID.SALVAGING_HOOK_LARGE_DRAGON_B,
		}
	),
	;

	private final int[] gameObjectIds;

	public static SalvagingHookTier fromGameObjectId(int id)
	{
		for (SalvagingHookTier tier : values())
		{
			for (int objectId : tier.getGameObjectIds())
			{
				if (objectId == id)
				{
					return tier;
				}
			}
		}

		return null;
	}

}

package com.duckblade.osrs.sailing.model;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.gameval.ObjectID;

@Slf4j
@RequiredArgsConstructor
@Getter
public enum CargoHoldTier
{

	WOOD(
		new int[]{
			ObjectID.SAILING_BOAT_CARGO_HOLD_REGULAR_RAFT,
			ObjectID.SAILING_BOAT_CARGO_HOLD_REGULAR_RAFT_OPEN,
			ObjectID.SAILING_BOAT_CARGO_HOLD_REGULAR_2X5,
			ObjectID.SAILING_BOAT_CARGO_HOLD_REGULAR_2X5_OPEN,
			ObjectID.SAILING_BOAT_CARGO_HOLD_REGULAR_LARGE,
			ObjectID.SAILING_BOAT_CARGO_HOLD_REGULAR_LARGE_OPEN,
		},
		new int[]{
			20,
			30,
			40,
			4,
		}
	),
	OAK(
		new int[]{
			ObjectID.SAILING_BOAT_CARGO_HOLD_OAK_RAFT,
			ObjectID.SAILING_BOAT_CARGO_HOLD_OAK_RAFT_OPEN,
			ObjectID.SAILING_BOAT_CARGO_HOLD_OAK_2X5,
			ObjectID.SAILING_BOAT_CARGO_HOLD_OAK_2X5_OPEN,
			ObjectID.SAILING_BOAT_CARGO_HOLD_OAK_LARGE,
			ObjectID.SAILING_BOAT_CARGO_HOLD_OAK_LARGE_OPEN,
		},
		new int[]{
			30,
			45,
			60,
			5,
		}
	),
	TEAK(
		new int[]{
			ObjectID.SAILING_BOAT_CARGO_HOLD_TEAK_RAFT,
			ObjectID.SAILING_BOAT_CARGO_HOLD_TEAK_RAFT_OPEN,
			ObjectID.SAILING_BOAT_CARGO_HOLD_TEAK_2X5,
			ObjectID.SAILING_BOAT_CARGO_HOLD_TEAK_2X5_OPEN,
			ObjectID.SAILING_BOAT_CARGO_HOLD_TEAK_LARGE,
			ObjectID.SAILING_BOAT_CARGO_HOLD_TEAK_LARGE_OPEN,
		},
		new int[]{
			45,
			60,
			75,
			6,
		}
	),
	MAHOGANY(
		new int[]{
			ObjectID.SAILING_BOAT_CARGO_HOLD_MAHOGANY_RAFT,
			ObjectID.SAILING_BOAT_CARGO_HOLD_MAHOGANY_RAFT_OPEN,
			ObjectID.SAILING_BOAT_CARGO_HOLD_MAHOGANY_2X5,
			ObjectID.SAILING_BOAT_CARGO_HOLD_MAHOGANY_2X5_OPEN,
			ObjectID.SAILING_BOAT_CARGO_HOLD_MAHOGANY_LARGE,
			ObjectID.SAILING_BOAT_CARGO_HOLD_MAHOGANY_LARGE_OPEN,
		},
		new int[]{
			60,
			90,
			120,
			7,
		}
	),
	CAMPHOR(
		new int[]{
			ObjectID.SAILING_BOAT_CARGO_HOLD_CAMPHOR_RAFT,
			ObjectID.SAILING_BOAT_CARGO_HOLD_CAMPHOR_RAFT_OPEN,
			ObjectID.SAILING_BOAT_CARGO_HOLD_CAMPHOR_2X5,
			ObjectID.SAILING_BOAT_CARGO_HOLD_CAMPHOR_2X5_OPEN,
			ObjectID.SAILING_BOAT_CARGO_HOLD_CAMPHOR_LARGE,
			ObjectID.SAILING_BOAT_CARGO_HOLD_CAMPHOR_LARGE_OPEN,
		},
		new int[]{
			80,
			120,
			160,
			8,
		}
	),
	IRONWOOD(
		new int[]{
			ObjectID.SAILING_BOAT_CARGO_HOLD_IRONWOOD_RAFT,
			ObjectID.SAILING_BOAT_CARGO_HOLD_IRONWOOD_RAFT_OPEN,
			ObjectID.SAILING_BOAT_CARGO_HOLD_IRONWOOD_2X5,
			ObjectID.SAILING_BOAT_CARGO_HOLD_IRONWOOD_2X5_OPEN,
			ObjectID.SAILING_BOAT_CARGO_HOLD_IRONWOOD_LARGE,
			ObjectID.SAILING_BOAT_CARGO_HOLD_IRONWOOD_LARGE_OPEN,
		},
		new int[]{
			105,
			150,
			210,
			9,
		}
	),
	ROSEWOOD(
		new int[]{
			ObjectID.SAILING_BOAT_CARGO_HOLD_ROSEWOOD_RAFT,
			ObjectID.SAILING_BOAT_CARGO_HOLD_ROSEWOOD_RAFT_OPEN,
			ObjectID.SAILING_BOAT_CARGO_HOLD_ROSEWOOD_2X5,
			ObjectID.SAILING_BOAT_CARGO_HOLD_ROSEWOOD_2X5_OPEN,
			ObjectID.SAILING_BOAT_CARGO_HOLD_ROSEWOOD_LARGE,
			ObjectID.SAILING_BOAT_CARGO_HOLD_ROSEWOOD_LARGE_OPEN,
		},
		new int[]{
			120,
			180,
			240,
			10,
		}
	),
	;

	private final int[] gameObjectIds;
	private final int[] capacities; // raft, skiff, sloop, uim

	public static CargoHoldTier fromGameObjectId(int id)
	{
		for (CargoHoldTier tier : values())
		{
			for (int objectId : tier.getGameObjectIds())
			{
				if (objectId == id)
				{
					return tier;
				}
			}
		}

		return null;
	}

	public int getCapacity(SizeClass sizeClass, boolean uim)
	{
		if (uim)
		{
			return capacities[3];
		}

		switch (sizeClass)
		{
			case RAFT:
				return capacities[0];
			case SKIFF:
				return capacities[1];
			case SLOOP:
				return capacities[2];
			default:
				log.error("Unknown size class {}", sizeClass);
				return -1;
		}
	}

}

package com.duckblade.osrs.sailing.model;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.gameval.ObjectID;

@RequiredArgsConstructor
@Getter
public enum HullTier
{

	WOOD(
		new int[]{
			ObjectID.SAILING_BOAT_HULL_KANDARIN_1X3_WOOD,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_2X5_WOOD,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_3X8_WOOD,
		}
	),
	OAK(
		new int[]{
			ObjectID.SAILING_BOAT_HULL_KANDARIN_1X3_OAK,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_2X5_OAK,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_3X8_OAK,
		}
	),
	TEAK(
		new int[]{
			ObjectID.SAILING_BOAT_HULL_KANDARIN_1X3_TEAK,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_2X5_TEAK,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_3X8_TEAK,
		}
	),
	MAHOGANY(
		new int[]{
			ObjectID.SAILING_BOAT_HULL_KANDARIN_1X3_MAHOGANY,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_2X5_MAHOGANY,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_3X8_MAHOGANY,
		}
	),
	CAMPHOR(
		new int[]{
			ObjectID.SAILING_BOAT_HULL_KANDARIN_1X3_CAMPHOR,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_2X5_CAMPHOR,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_3X8_CAMPHOR,
		}
	),
	IRONWOOD(
		new int[]{
			ObjectID.SAILING_BOAT_HULL_KANDARIN_1X3_IRONWOOD,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_2X5_IRONWOOD,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_3X8_IRONWOOD,
		}
	),
	ROSEWOOD(
		new int[]{
			ObjectID.SAILING_BOAT_HULL_KANDARIN_1X3_ROSEWOOD,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_2X5_ROSEWOOD,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_3X8_ROSEWOOD,
		}
	),
	;

	private final int[] gameObjectIds;

	public static HullTier fromGameObjectId(int id)
	{
		for (HullTier tier : values())
		{
			for (int objectId : tier.getGameObjectIds())
			{
				if (objectId == id)
				{
					return tier;
				}
			}
		}

		return null;
	}

}

package com.duckblade.osrs.sailing.model;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.gameval.ObjectID;

@RequiredArgsConstructor
@Getter
public enum HelmTier
{

	BRONZE(
		new int[]{
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_1X3_WOOD,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_1X3_WOOD_IN_USE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_1X3_WOOD_IDLE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_2X5_WOOD,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_2X5_WOOD_IN_USE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_2X5_WOOD_IDLE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_3X8_WOOD,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_3X8_WOOD_IN_USE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_3X8_WOOD_IDLE,
		}
	),
	IRON(
		new int[]{
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_1X3_OAK,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_1X3_OAK_IN_USE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_1X3_OAK_IDLE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_2X5_OAK,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_2X5_OAK_IN_USE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_2X5_OAK_IDLE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_3X8_OAK,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_3X8_OAK_IN_USE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_3X8_OAK_IDLE,
		}
	),
	STEEL(
		new int[]{
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_1X3_TEAK,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_1X3_TEAK_IN_USE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_1X3_TEAK_IDLE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_2X5_TEAK,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_2X5_TEAK_IN_USE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_2X5_TEAK_IDLE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_3X8_TEAK,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_3X8_TEAK_IN_USE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_3X8_TEAK_IDLE,
		}
	),
	MITHRIL(
		new int[]{
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_1X3_MAHOGANY,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_1X3_MAHOGANY_IN_USE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_1X3_MAHOGANY_IDLE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_2X5_MAHOGANY,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_2X5_MAHOGANY_IN_USE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_2X5_MAHOGANY_IDLE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_3X8_MAHOGANY,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_3X8_MAHOGANY_IN_USE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_3X8_MAHOGANY_IDLE,
		}
	),
	ADAMANT(
		new int[]{
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_1X3_CAMPHOR,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_1X3_CAMPHOR_IN_USE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_1X3_CAMPHOR_IDLE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_2X5_CAMPHOR,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_2X5_CAMPHOR_IN_USE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_2X5_CAMPHOR_IDLE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_3X8_CAMPHOR,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_3X8_CAMPHOR_IN_USE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_3X8_CAMPHOR_IDLE,
		}
	),
	RUNE(
		new int[]{
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_1X3_IRONWOOD,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_1X3_IRONWOOD_IN_USE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_1X3_IRONWOOD_IDLE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_2X5_IRONWOOD,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_2X5_IRONWOOD_IN_USE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_2X5_IRONWOOD_IDLE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_3X8_IRONWOOD,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_3X8_IRONWOOD_IN_USE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_3X8_IRONWOOD_IDLE,
		}
	),
	DRAGON(
		new int[]{
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_1X3_ROSEWOOD,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_1X3_ROSEWOOD_IN_USE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_1X3_ROSEWOOD_IDLE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_2X5_ROSEWOOD,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_2X5_ROSEWOOD_IN_USE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_2X5_ROSEWOOD_IDLE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_3X8_ROSEWOOD,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_3X8_ROSEWOOD_IN_USE,
			ObjectID.SAILING_BOAT_STEERING_KANDARIN_3X8_ROSEWOOD_IDLE,
		}
	),
	;

	private final int[] gameObjectIds;

	public static HelmTier fromGameObjectId(int id)
	{
		for (HelmTier tier : values())
		{
			for (int objectId : tier.getGameObjectIds())
			{
				if (objectId == id)
				{
					return tier;
				}
			}
		}

		return null;
	}

}

package com.duckblade.osrs.sailing.model;

import lombok.Value;

@Value
public class Crewmate
{

	int uniqueId;
	String name;

	int helmsmanship;
	int privateering;
	int deckhandiness;

}

package com.duckblade.osrs.sailing.model;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.gameval.ObjectID;

@RequiredArgsConstructor
@Getter
public enum SizeClass
{

	RAFT(
		new int[]{
			ObjectID.SAILING_BOAT_HULL_KANDARIN_1X3_WOOD,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_1X3_OAK,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_1X3_TEAK,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_1X3_MAHOGANY,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_1X3_CAMPHOR,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_1X3_IRONWOOD,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_1X3_ROSEWOOD,
		}
	),
	SKIFF(
		new int[]{
			ObjectID.SAILING_BOAT_HULL_KANDARIN_2X5_WOOD,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_2X5_OAK,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_2X5_TEAK,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_2X5_MAHOGANY,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_2X5_CAMPHOR,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_2X5_IRONWOOD,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_2X5_ROSEWOOD,
		}
	),
	SLOOP(
		new int[]{
			ObjectID.SAILING_BOAT_HULL_KANDARIN_3X8_WOOD,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_3X8_OAK,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_3X8_TEAK,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_3X8_MAHOGANY,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_3X8_CAMPHOR,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_3X8_IRONWOOD,
			ObjectID.SAILING_BOAT_HULL_KANDARIN_3X8_ROSEWOOD,
		}
	),
	;

	private final int[] gameObjectIds;
	public static SizeClass fromGameObjectId(int id)
	{
		for (SizeClass tier : values())
		{
			for (int objectId : tier.getGameObjectIds())
			{
				if (objectId == id)
				{
					return tier;
				}
			}
		}

		return null;
	}

}

package com.duckblade.osrs.sailing.model;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.gameval.ObjectID;

@Getter
@RequiredArgsConstructor
public enum Port
{

	ALDARIN("Aldarin", "ALDRN", 8605, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_ALDARIN),
	ARDOUGNE("Ardougne", "ARDY", 8596, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_ARDOUGNE),
	BRIMHAVEN("Brimhaven", "BRIM", 8595, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_BRIMHAVEN),
	CAIRN_ISLE("Cairn Isle", "CAIRN", 8602, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_CAIRN_ISLE),
	CATHERBY("Catherby", "CATH", 8593, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_CATHERBY),
	CIVITAS_ILLA_FORTIS("Civitas Illa Fortis", "FORTS", 8600, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_CIVITAS_ILLA_FORTIS),
	CORSAIR_COVE("Corsair Cove", "CORSR", 8601, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_CORSAIR_COVE),
	DEEPFIN_POINT("Deepfin Point", "DPFIN", 8613, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_DEEPFIN_POINT),
	ENTRANA("Entrana", "ENTR", 8599, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_ENTRANA),
	ETCETERIA("Etceteria", "ETC", 8611, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_ETCETERIA),
	HOSIDIUS("Hosidius", "HOSDS", 8591, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_HOSIDIUS),
	JATIZSO("Jatizso", "JATIZ", 8614, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_JATIZSO),
	LANDS_END("Lands' End", "LANDS", 8589, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_LANDS_END),
	LUNAR_ISLE("Lunar Isle", "LUNAR", 8618, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_LUNAR_ISLE),
	MUSA_POINT("Musa Point", "MUSA", 8590, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_MUSA_POINT),
	NEITIZNOT("Neitiznot", "NEITZ", 8615, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_NEITIZNOT),
	PISCATORIS("Piscatoris", "PSCTR", 8617, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_PISCATORIS),
	PORT_KHAZARD("Port Khazard", "KHZRD", 8597, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_PORT_KHAZARD),
	PORT_PISCARILIUS("Port Piscarilius", "PSCRL", 8594, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_PORT_PISCARILIUS),
	PORT_ROBERTS("Port Roberts", "ROBRT", 8608, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_PORT_ROBERTS),
	PORT_SARIM("Port Sarim", "SARIM", 8597, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_PORT_SARIM),
	PORT_TYRAS("Port Tyras", "TYRAS", 8612, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_PORT_TYRAS),
	PRIFDDINAS("Prifddinas", "PRIF", 8616, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_PRIFDDINAS),
	RED_ROCK("Red Rock", "REDRK", 8609, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_RED_ROCK),
	RELLEKKA("Rellekka", "RELL", 8610, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_RELLEKKA),
	RUINS_OF_UNKAH("Ruins of Unkah", "UNKAH", 8606, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_RUINS_OF_UNKAH),
	SUNSET_COAST("Sunset Coast", "SUNST", 8603, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_SUNSET_COAST),
	THE_PANDEMONIUM("The Pandemonium", "PAND", 8588, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_PANDEMONIUM),
	THE_SUMMER_SHORE("The Summer Shore", "SUMMR", 8604, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_THE_SUMMER_SHORE),
	VOID_KNIGHTS_OUTPOST("Void Knights Outpost", "VOID", 8607, ObjectID.DOCK_LOADING_BAY_LEDGER_TABLE_VOID_KNIGHTS_OUTPOST),
	;

	private final String fullName;
	private final String shortCode;
	private final int dbRowID;
	private final int ledgerTableID;

	public static Port findByID(int id)
	{
		for (Port port : Port.values())
		{
			if (port.getDbRowID() == id)
			{
				return port;
			}
		}

		return null;
	}

	public static Port findByLedgerTableID(int id)
	{
		for (Port port : Port.values())
		{
			if (port.getLedgerTableID() == id)
			{
				return port;
			}
		}
		return null;
	}

	@Override
	public String toString()
	{
		return fullName;
	}
}

package com.duckblade.osrs.sailing.model;

import lombok.Data;

@Data
public class CourierTask
{
	private final int taskSlot;
	private final Port fromPort;
	private final Port toPort;
	private final int cargoCrateItemID;
	private final int cargoAmount;
	private final int numCargoRetrieved;
	private final int numCargoDelivered;

	public boolean hasRetrievedAllCargo()
	{
		return numCargoRetrieved == cargoAmount;
	}

	public boolean hasDeliveredAllCargo()
	{
		return numCargoDelivered == cargoAmount;
	}
}

package com.duckblade.osrs.sailing.model;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.gameval.ObjectID;

@Slf4j
@RequiredArgsConstructor
@Getter
public enum SailTier
{

	WOOD(
		new int[]{
			ObjectID.SAILING_BOAT_SAIL_KANDARIN_1X3_WOOD,
			ObjectID.SAILING_BOAT_SAIL_KANDARIN_2X5_WOOD,
			ObjectID.SAILING_BOAT_SAIL_KANDARIN_3X8_WOOD,
		},
		new int[]{
			20,
			20,
			20,
		}
	),
	OAK(
		new int[]{
			ObjectID.SAILING_BOAT_SAIL_KANDARIN_1X3_OAK,
			ObjectID.SAILING_BOAT_SAIL_KANDARIN_2X5_OAK,
			ObjectID.SAILING_BOAT_SAIL_KANDARIN_3X8_OAK,
		},
		new int[]{
			22,
			22,
			22,
		}
	),
	TEAK(
		new int[]{
			ObjectID.SAILING_BOAT_SAIL_KANDARIN_1X3_TEAK,
			ObjectID.SAILING_BOAT_SAIL_KANDARIN_2X5_TEAK,
			ObjectID.SAILING_BOAT_SAIL_KANDARIN_3X8_TEAK,
		},
		new int[]{
			24,
			24,
			24,
		}
	),
	MAHOGANY(
		new int[]{
			ObjectID.SAILING_BOAT_SAIL_KANDARIN_1X3_MAHOGANY,
			ObjectID.SAILING_BOAT_SAIL_KANDARIN_2X5_MAHOGANY,
			ObjectID.SAILING_BOAT_SAIL_KANDARIN_3X8_MAHOGANY,
		},
		new int[]{
			26, // yes, this is literally the only special case
			27,
			27,
		}
	),
	CAMPHOR(
		new int[]{
			ObjectID.SAILING_BOAT_SAIL_KANDARIN_1X3_CAMPHOR,
			ObjectID.SAILING_BOAT_SAIL_KANDARIN_2X5_CAMPHOR,
			ObjectID.SAILING_BOAT_SAIL_KANDARIN_3X8_CAMPHOR,
		},
		new int[]{
			30,
			30,
			30,
		}
	),
	IRONWOOD(
		new int[]{
			ObjectID.SAILING_BOAT_SAIL_KANDARIN_1X3_IRONWOOD,
			ObjectID.SAILING_BOAT_SAIL_KANDARIN_2X5_IRONWOOD,
			ObjectID.SAILING_BOAT_SAIL_KANDARIN_3X8_IRONWOOD,
		},
		new int[]{
			33,
			33,
			33,
		}
	),
	ROSEWOOD(
		new int[]{
			ObjectID.SAILING_BOAT_SAIL_KANDARIN_1X3_ROSEWOOD,
			ObjectID.SAILING_BOAT_SAIL_KANDARIN_2X5_ROSEWOOD,
			ObjectID.SAILING_BOAT_SAIL_KANDARIN_3X8_ROSEWOOD,
		},
		new int[]{
			36,
			36,
			36,
		}
	),
	;

	private final int[] gameObjectIds;
	private final int[] speedBoostDurations;

	public static SailTier fromGameObjectId(int id)
	{
		for (SailTier tier : values())
		{
			for (int objectId : tier.getGameObjectIds())
			{
				if (objectId == id)
				{
					return tier;
				}
			}
		}

		return null;
	}

	public int getSpeedBoostDuration(SizeClass sizeClass)
	{
		switch (sizeClass)
		{
			case RAFT:
				return speedBoostDurations[0];
			case SKIFF:
				return speedBoostDurations[1];
			case SLOOP:
				return speedBoostDurations[2];
			default:
				log.error("Unknown size class {}", sizeClass);
				return -1;
		}
	}
}

package com.duckblade.osrs.sailing;

import com.duckblade.osrs.sailing.module.ComponentManager;
import com.duckblade.osrs.sailing.module.SailingModule;
import com.google.inject.Binder;
import java.io.File;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;

@Slf4j
@PluginDescriptor(
	name = "Sailing"
)
public class SailingPlugin extends Plugin
{

	public static final File SAILING_DIR = new File(RuneLite.RUNELITE_DIR, "sailing");

	@Inject
	private ComponentManager componentManager;

	@Override
	public void configure(Binder binder)
	{
		binder.install(new SailingModule());
	}

	@Override
	protected void startUp() throws Exception
	{
		componentManager.onPluginStart();
	}

	@Override
	protected void shutDown() throws Exception
	{
		componentManager.onPluginStop();
	}

}

package com.duckblade.osrs.sailing.features.charting;

import org.junit.Assert;
import org.junit.Test;

public class MermaidTaskSolverTest
{

	@Test
	public void ensureAllTasksHaveMermaidSolutions()
	{
		for (SeaChartTask task : SeaChartTask.values())
		{
			if (!MermaidTaskSolver.MERMAID_IDS.contains(task.getNpcId()))
			{
				continue;
			}

			Assert.assertNotNull(
				String.format("task %d missing solution", task.getTaskId()),
				MermaidTaskSolver.SOLUTIONS.get(task)
			);
		}
	}

	@Test
	public void noNonMermaidsHaveSolutions()
	{
		for (SeaChartTask task : SeaChartTask.values())
		{
			if (MermaidTaskSolver.MERMAID_IDS.contains(task.getNpcId()))
			{
				continue;
			}

			Assert.assertNull(
				String.format("task %d has solution but is not a mermaid task", task.getTaskId()),
				MermaidTaskSolver.SOLUTIONS.get(task)
			);
		}
	}

}

package com.duckblade.osrs.sailing;

import com.duckblade.osrs.sailing.debugplugin.SailingDebugPlugin;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class SailingPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(
			SailingPlugin.class,
			SailingDebugPlugin.class
		);
		RuneLite.main(args);
	}
}

package com.duckblade.osrs.sailing.debugplugin;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup(SailingDebugConfig.CONFIG_GROUP)
public interface SailingDebugConfig extends Config
{

	String CONFIG_GROUP = "sailingdebug";

	@ConfigItem(
		keyName = "boatInfo",
		name = "Boat Info",
		description = ""
	)
	default boolean boatInfo()
	{
		return false;
	}

	@ConfigItem(
		keyName = "localBoatInfo",
		name = "Local Boat Info Panel",
		description = ""
	)
	default boolean localBoatInfo()
	{
		return true;
	}

	@ConfigItem(
		keyName = "tlwp",
		name = "Top Level WP Default On",
		description = "also toggleable with ::tlwp"
	)
	default boolean tlwp()
	{
		return false;
	}

	@ConfigItem(
		keyName = "courierTaskInfo",
		name = "Courier Task Info Panel",
		description = ""
	)
	default boolean courierTaskInfo()
	{
		return true;
	}

	@ConfigItem(
		keyName = "routeOverlayDefaultOn",
		name = "Route Default On",
		description = "also toggleable with ::route"
	)
	default boolean routeOverlayDefaultOn()
	{
		return true;
	}

	@ConfigItem(
		keyName = "facilities",
		name = "Facilities Overlay",
		description = ""
	)
	default boolean facilities()
	{
		return false;
	}

	@ConfigItem(
		keyName = "crewmates",
		name = "Crewmates",
		description = ""
	)
	default boolean crewmates()
	{
		return false;
	}

}

package com.duckblade.osrs.sailing.debugplugin;

import com.duckblade.osrs.sailing.debugplugin.module.DebugComponentManager;
import com.duckblade.osrs.sailing.debugplugin.module.DebugModule;
import com.google.inject.Binder;
import com.google.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;

@Slf4j
@PluginDescriptor(
	name = "SailingDebug",
	developerPlugin = true
)
public class SailingDebugPlugin extends Plugin
{

	@Inject
	private DebugComponentManager componentManager;

	@Override
	public void configure(Binder binder)
	{
		binder.install(new DebugModule());
	}

	@Override
	protected void startUp() throws Exception
	{
		componentManager.onPluginStart();
	}

	@Override
	protected void shutDown() throws Exception
	{
		componentManager.onPluginStop();
	}
}

package com.duckblade.osrs.sailing.debugplugin.features;

import com.duckblade.osrs.sailing.debugplugin.SailingDebugConfig;
import com.duckblade.osrs.sailing.debugplugin.module.DebugLifecycleComponent;
import com.duckblade.osrs.sailing.features.util.CrewmateAssignment;
import com.duckblade.osrs.sailing.features.util.CrewmateIndex;
import com.duckblade.osrs.sailing.model.Crewmate;
import com.google.common.collect.ImmutableMap;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.Map;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

@Slf4j
@Singleton
public class CrewmateInfoOverlay
	extends OverlayPanel
	implements DebugLifecycleComponent
{

	private static final Map<Integer, Integer> CREWMATE_VARBS = ImmutableMap.<Integer, Integer>builder()
		.put(VarbitID.SAILING_CREW_SLOT_1, VarbitID.SAILING_CREW_SLOT_1_POSITION)
		.put(VarbitID.SAILING_CREW_SLOT_2, VarbitID.SAILING_CREW_SLOT_2_POSITION)
		.put(VarbitID.SAILING_CREW_SLOT_3, VarbitID.SAILING_CREW_SLOT_3_POSITION)
		.put(VarbitID.SAILING_CREW_SLOT_4, VarbitID.SAILING_CREW_SLOT_4_POSITION)
		.put(VarbitID.SAILING_CREW_SLOT_5, VarbitID.SAILING_CREW_SLOT_5_POSITION)
		.build();

	private final Client client;
	private final CrewmateIndex crewmateIndex;

	@Inject
	public CrewmateInfoOverlay(Client client, CrewmateIndex crewmateIndex)
	{
		this.client = client;
		this.crewmateIndex = crewmateIndex;

		setPreferredPosition(OverlayPosition.TOP_LEFT);
		setLayer(OverlayLayer.ALWAYS_ON_TOP);
	}

	@Override
	public boolean isEnabled(SailingDebugConfig config)
	{
		return config.crewmates();
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		getPanelComponent().getChildren().add(TitleComponent.builder()
			.text("Crewmates")
			.build());

		CREWMATE_VARBS.forEach((crewmateVarb, positionVarb) ->
		{
			Crewmate crewmate = crewmateIndex.getCrewmate(client.getVarbitValue(crewmateVarb));
			if (crewmate != null)
			{
				int facilityIx = client.getVarbitValue(positionVarb);
				CrewmateAssignment facility = CrewmateAssignment.fromCrewAssignmentVarb(facilityIx);

				if (facility != null)
				{
					addLine(crewmate.getName(), facility.toString(), Color.GREEN);
				}
				else if (facilityIx != 0)
				{
					addLine(crewmate.getName(), String.valueOf(facilityIx), Color.RED);
				}
				else
				{
					addLine(crewmate.getName(), "None", Color.WHITE);
				}
			}
		});

		return super.render(graphics);
	}

	private void addLine(String left, String right, Color color)
	{
		getPanelComponent().getChildren().add(LineComponent.builder()
			.left(left)
			.right(right)
			.rightColor(color)
			.build());
	}
}

package com.duckblade.osrs.sailing.debugplugin.features;

import com.duckblade.osrs.sailing.debugplugin.SailingDebugConfig;
import com.duckblade.osrs.sailing.debugplugin.module.DebugLifecycleComponent;
import com.duckblade.osrs.sailing.features.util.BoatTracker;
import com.duckblade.osrs.sailing.model.Boat;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.WorldEntity;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

@Singleton
public class BoatInfoOverlay
	extends Overlay
	implements DebugLifecycleComponent
{

	private final Client client;
	private final BoatTracker boatTracker;

	@Inject
	public BoatInfoOverlay(Client client, BoatTracker boatTracker)
	{
		this.client = client;
		this.boatTracker = boatTracker;

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ALWAYS_ON_TOP);
	}

	@Override
	public boolean isEnabled(SailingDebugConfig config)
	{
		return config.boatInfo();
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		for (WorldEntity we : client.getTopLevelWorldView().worldEntities())
		{
			LocalPoint location = we.getLocalLocation();
			if (we.isHiddenForOverlap())
			{
				continue;
			}

			Boat boat = boatTracker.getBoat(we.getWorldView().getId());
			if (boat == null)
			{
				String text = "UNTRACKED BOAT: " + we.getWorldView().getId();
				Point p = Perspective.getCanvasTextLocation(client, graphics, location, text, 0);
				if (p != null)
				{
					OverlayUtil.renderTextLocation(graphics, p, text, Color.YELLOW);
				}
				continue;
			}

			String text = boat.getDebugString();
			Point p = Perspective.getCanvasTextLocation(client, graphics, location, text, 0);
			if (p != null)
			{
				OverlayUtil.renderTextLocation(graphics, p, text, Color.BLUE);
			}
		}

		return null;
	}

}

package com.duckblade.osrs.sailing.debugplugin.features;

import com.duckblade.osrs.sailing.debugplugin.SailingDebugConfig;
import com.duckblade.osrs.sailing.debugplugin.module.DebugLifecycleComponent;
import com.duckblade.osrs.sailing.features.util.BoatTracker;
import com.duckblade.osrs.sailing.model.Boat;
import com.duckblade.osrs.sailing.model.SalvagingHookTier;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

@Singleton
public class LocalBoatInfoOverlayPanel
	extends OverlayPanel
	implements DebugLifecycleComponent
{

	private final BoatTracker boatTracker;

	@Inject
	public LocalBoatInfoOverlayPanel(BoatTracker boatTracker)
	{
		this.boatTracker = boatTracker;

		setPreferredPosition(OverlayPosition.TOP_LEFT);
		setLayer(OverlayLayer.ALWAYS_ON_TOP);
	}

	@Override
	public boolean isEnabled(SailingDebugConfig config)
	{
		return config.localBoatInfo();
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		Boat boat = boatTracker.getBoat();
		if (boat == null)
		{
			return null;
		}

		getPanelComponent().getChildren()
			.add(TitleComponent.builder()
				.text("Local Boat")
				.build());

		getPanelComponent().getChildren()
			.add(LineComponent.builder()
				.left("Size")
				.right(String.valueOf(boat.getSizeClass()))
				.build());

		getPanelComponent().getChildren()
			.add(LineComponent.builder()
				.left("Hull")
				.right(String.valueOf(boat.getHullTier()))
				.build());

		getPanelComponent().getChildren()
			.add(LineComponent.builder()
				.left("Sail")
				.right(String.valueOf(boat.getSailTier()))
				.build());

		getPanelComponent().getChildren()
			.add(LineComponent.builder()
				.left("Helm")
				.right(String.valueOf(boat.getHelmTier()))
				.build());

		getPanelComponent().getChildren()
			.add(LineComponent.builder()
				.left("Hook")
				.right(boat
					.getSalvagingHookTiers()
					.stream()
					.map(SalvagingHookTier::toString)
					.collect(Collectors.joining(", ", "[", "]")))
				.build());

		getPanelComponent().getChildren()
			.add(LineComponent.builder()
				.left("Cargo")
				.right(String.valueOf(boat.getCargoHoldTier()))
				.build());

		return super.render(graphics);
	}

}

package com.duckblade.osrs.sailing.debugplugin.features;

import com.duckblade.osrs.sailing.debugplugin.SailingDebugConfig;
import com.duckblade.osrs.sailing.debugplugin.module.DebugLifecycleComponent;
import com.duckblade.osrs.sailing.features.courier.CourierTaskTracker;
import com.duckblade.osrs.sailing.model.CourierTask;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.Set;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

@Slf4j
@Singleton
public class CourierTaskOverlayPanel
	extends OverlayPanel
	implements DebugLifecycleComponent
{

	private final CourierTaskTracker taskTracker;

	@Inject
	public CourierTaskOverlayPanel(CourierTaskTracker taskTracker)
	{
		this.taskTracker = taskTracker;

		setPreferredPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
		setLayer(OverlayLayer.ALWAYS_ON_TOP);
	}

	@Override
	public boolean isEnabled(SailingDebugConfig config)
	{
		return config.courierTaskInfo();
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		Set<CourierTask> tasks = taskTracker.getTasks();
		if (tasks.isEmpty())
		{
			return null;
		}

		getPanelComponent().getChildren()
			.add(TitleComponent.builder()
				.text("Courier Tasks")
				.build());

		for (CourierTask task : tasks)
		{
			getPanelComponent().getChildren()
				.add(LineComponent.builder()
					.left(task.getFromPort().toString())
					.right(task.getToPort().toString())
					.build());

			boolean isRetrieved = task.getNumCargoRetrieved() == task.getCargoAmount();
			boolean isDelivered = task.getNumCargoDelivered() == task.getCargoAmount();
			getPanelComponent().getChildren()
				.add(LineComponent.builder()
					.left("RETRIEVED")
					.leftColor(isRetrieved ? Color.GREEN : Color.RED)
					.right("DELIVERED")
					.rightColor(isDelivered ? Color.GREEN : Color.RED)
					.build());
		}

		return super.render(graphics);
	}
}

package com.duckblade.osrs.sailing.debugplugin.features;

import com.duckblade.osrs.sailing.debugplugin.SailingDebugConfig;
import com.duckblade.osrs.sailing.debugplugin.module.DebugLifecycleComponent;
import com.duckblade.osrs.sailing.features.util.BoatTracker;
import com.duckblade.osrs.sailing.features.util.SailingUtil;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.util.Objects;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

@Singleton
public class TlwpOverlay
	extends Overlay
	implements DebugLifecycleComponent
{

	private final Client client;
	private final BoatTracker boatTracker;

	private boolean active;

	@Inject
	public TlwpOverlay(Client client, BoatTracker boatTracker)
	{
		this.client = client;
		this.boatTracker = boatTracker;

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ALWAYS_ON_TOP);
	}

	@Override
	public boolean isEnabled(SailingDebugConfig config)
	{
		return config.tlwp();
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!active || !SailingUtil.isSailing(client))
		{
			return null;
		}

		LocalPoint tllp = boatTracker.getBoat()
			.getWorldEntity()
			.getLocalLocation();
		Point canvasPoint = Perspective.localToCanvas(client, tllp, 0);
		if (canvasPoint != null)
		{
			graphics.setColor(Color.PINK);
			graphics.drawRect(canvasPoint.getX() - 5, canvasPoint.getY() - 5, 11, 11);
			graphics.drawRect(canvasPoint.getX(), canvasPoint.getY(), 1, 1);
		}

		WorldPoint tlwp = SailingUtil.getTopLevelWorldPoint(client);
		Polygon poly = Perspective.getCanvasTilePoly(client, Objects.requireNonNull(LocalPoint.fromWorld(client, tlwp)));
		if (poly != null)
		{
			OverlayUtil.renderPolygon(graphics, poly, Color.magenta);
		}

		return null;
	}
}

package com.duckblade.osrs.sailing.debugplugin.features;

import com.duckblade.osrs.sailing.debugplugin.SailingDebugConfig;
import com.duckblade.osrs.sailing.debugplugin.module.DebugLifecycleComponent;
import com.duckblade.osrs.sailing.features.util.BoatTracker;
import com.duckblade.osrs.sailing.features.util.SailingUtil;
import com.duckblade.osrs.sailing.model.Boat;
import com.duckblade.osrs.sailing.model.SalvagingHookTier;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.HashSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.events.CommandExecuted;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

@Singleton
public class FacilitiesOverlay
	extends Overlay
	implements DebugLifecycleComponent
{

	private final Client client;
	private final BoatTracker boatTracker;

	private final Set<String> facilityTypes = new HashSet<>();

	@Inject
	public FacilitiesOverlay(Client client, BoatTracker boatTracker)
	{
		this.client = client;
		this.boatTracker = boatTracker;

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ALWAYS_ON_TOP);
	}

	@Override
	public boolean isEnabled(SailingDebugConfig config)
	{
		return config.facilities();
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!SailingUtil.isSailing(client))
		{
			return null;
		}

		Boat boat = boatTracker.getBoat();
		renderFacility(graphics, Color.CYAN, "sail", boat.getSail(), boat.getSailTier());
		renderFacility(graphics, Color.ORANGE, "helm", boat.getHelm(), boat.getHelmTier());
		renderFacility(graphics, Color.GREEN, "cargo", boat.getCargoHold(), boat.getCargoHoldTier());
		for (GameObject hook : boat.getSalvagingHooks())
		{
			renderFacility(graphics, Color.RED, "hook", hook, SalvagingHookTier.fromGameObjectId(hook.getId()));
		}

		return null;
	}

	private void renderFacility(Graphics2D graphics, Color colour, String type, GameObject o, Object tier)
	{
		if (o == null || (!facilityTypes.isEmpty() && !facilityTypes.contains(type)))
		{
			return;
		}

		OverlayUtil.renderTileOverlay(graphics, o, type + "=" + tier, colour);
	}

	@Subscribe
	public void onCommandExecuted(CommandExecuted e)
	{
		if (!e.getCommand().equals("facility"))
		{
			return;
		}

		if (e.getArguments().length == 0)
		{
			return;
		}

		if (!facilityTypes.add(e.getArguments()[0]))
		{
			facilityTypes.remove(e.getArguments()[0]);
		}
	}

}

package com.duckblade.osrs.sailing.debugplugin.module;

import com.duckblade.osrs.sailing.debugplugin.SailingDebugConfig;
import com.duckblade.osrs.sailing.debugplugin.features.BoatInfoOverlay;
import com.duckblade.osrs.sailing.debugplugin.features.CourierTaskOverlayPanel;
import com.duckblade.osrs.sailing.debugplugin.features.CrewmateInfoOverlay;
import com.duckblade.osrs.sailing.debugplugin.features.FacilitiesOverlay;
import com.duckblade.osrs.sailing.debugplugin.features.LocalBoatInfoOverlayPanel;
import com.duckblade.osrs.sailing.debugplugin.features.TlwpOverlay;
import com.google.common.collect.ImmutableSet;
import com.google.inject.AbstractModule;
import com.google.inject.Provides;
import com.google.inject.Singleton;
import java.util.Set;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;

@Slf4j
public class DebugModule extends AbstractModule
{

	@Override
	protected void configure()
	{
		bind(DebugComponentManager.class);
	}

	@Provides
	Set<DebugLifecycleComponent> lifecycleComponents(
		BoatInfoOverlay boatInfoOverlay,
		CourierTaskOverlayPanel courierTaskOverlayPanel,
		CrewmateInfoOverlay crewmateInfoOverlay,
		FacilitiesOverlay facilitiesOverlay,
		LocalBoatInfoOverlayPanel localBoatInfoOverlayPanel,
		TlwpOverlay tlwpOverlay
	)
	{
		var builder = ImmutableSet.<DebugLifecycleComponent>builder()
			.add(boatInfoOverlay)
			.add(courierTaskOverlayPanel)
			.add(crewmateInfoOverlay)
			.add(facilitiesOverlay)
			.add(localBoatInfoOverlayPanel)
			.add(tlwpOverlay);

		return builder.build();
	}

	@Provides
	@Singleton
	SailingDebugConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(SailingDebugConfig.class);
	}

}

package com.duckblade.osrs.sailing.debugplugin.module;

import com.duckblade.osrs.sailing.debugplugin.SailingDebugConfig;

public interface DebugLifecycleComponent
{

	default boolean isEnabled(SailingDebugConfig config)
	{
		return true;
	}

	default void startUp()
	{
	}

	default void shutDown()
	{
	}

}

package com.duckblade.osrs.sailing.debugplugin.module;

import com.duckblade.osrs.sailing.debugplugin.SailingDebugConfig;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBox;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.GameEventManager;

/**
 * Manages all the subcomponents of the plugin
 * so they can register themselves to RuneLite resources
 * e.g. EventBus/OverlayManager/init on startup/etc
 * instead of the {@link com.duckblade.osrs.sailing.SailingPlugin} class handling everything.
 */
@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class DebugComponentManager
{

	private final EventBus eventBus;
	private final OverlayManager overlayManager;
	private final InfoBoxManager infoBoxManager;
	private final GameEventManager gameEventManager;
	private final SailingDebugConfig config;
	private final Set<DebugLifecycleComponent> components;

	private final Map<DebugLifecycleComponent, Boolean> states = new HashMap<>();

	public void onPluginStart()
	{
		eventBus.register(this);
		components.forEach(c -> states.put(c, false));
		revalidateComponentStates();
	}

	public void onPluginStop()
	{
		eventBus.unregister(this);
		components.stream()
			.filter(states::get)
			.forEach(this::tryShutDown);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged e)
	{
		if (!SailingDebugConfig.CONFIG_GROUP.equals(e.getGroup()))
		{
			return;
		}

		revalidateComponentStates();
	}

	private void revalidateComponentStates()
	{
		components.forEach(c ->
		{
			boolean shouldBeEnabled = c.isEnabled(config);
			boolean isEnabled = states.get(c);
			if (shouldBeEnabled == isEnabled)
			{
				return;
			}

			if (shouldBeEnabled)
			{
				tryStartUp(c);
			}
			else
			{
				tryShutDown(c);
			}
		});
	}

	private void tryStartUp(DebugLifecycleComponent component)
	{
		if (states.get(component))
		{
			return;
		}

		if (log.isDebugEnabled())
		{
			log.debug("Enabling Sailing component [{}]", component.getClass().getName());
		}

		try
		{
			component.startUp();

			eventBus.register(component);
			if (component instanceof Overlay)
			{
				overlayManager.add((Overlay) component);
			}
			if (component instanceof InfoBox)
			{
				infoBoxManager.addInfoBox((InfoBox) component);
			}

			gameEventManager.simulateGameEvents(component);
			states.put(component, true);
		}
		catch (Throwable e)
		{
			log.error("Failed to start Sailing component [{}]", component.getClass().getName(), e);
		}
	}

	private void tryShutDown(DebugLifecycleComponent component)
	{
		eventBus.unregister(component);
		if (component instanceof Overlay)
		{
			overlayManager.remove((Overlay) component);
		}
		if (component instanceof InfoBox)
		{
			infoBoxManager.removeInfoBox((InfoBox) component);
		}

		if (!states.get(component))
		{
			return;
		}

		if (log.isDebugEnabled())
		{
			log.debug("Disabling Sailing component [{}]", component.getClass().getName());
		}

		try
		{
			component.shutDown();
		}
		catch (Throwable e)
		{
			log.error("Failed to cleanly shut down Sailing component [{}]", component.getClass().getName());
		}
		finally
		{
			states.put(component, false);
		}
	}

}

package com.duckblade.osrs.sailing.debugplugin;

import com.duckblade.osrs.sailing.features.navigation.TrueTileIndicator;
import com.duckblade.osrs.sailing.features.util.BoatTracker;
import com.duckblade.osrs.sailing.features.util.SailingUtil;
import com.duckblade.osrs.sailing.model.Boat;
import com.duckblade.osrs.sailing.module.PluginLifecycleComponent;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.WorldEntity;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.events.CommandExecuted;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

@Slf4j
@Singleton
public class SailingDebugRouteOverlay
	extends Overlay
	implements PluginLifecycleComponent
{

	private final BoatTracker boatTracker;
	private final Client client;

	private boolean active;

	@Inject
	public SailingDebugRouteOverlay(BoatTracker boatTracker, Client client, SailingDebugConfig config)
	{
		this.boatTracker = boatTracker;
		this.client = client;
		active = config.routeOverlayDefaultOn();

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D g)
	{
		if (!active || !SailingUtil.isSailing(client))
		{
			return null;
		}

		Boat boat = boatTracker.getBoat();
		WorldEntity we = boat.getWorldEntity();

		// boat areas
		g.setColor(Color.ORANGE);

		LocalPoint currentLocation = we.getLocalLocation();
		int currentOrientation = we.getOrientation();
		TrueTileIndicator.renderBoatArea(client, g, we.getConfig(), currentLocation, currentOrientation);

		LocalPoint targetLocation = we.getTargetLocation();
		int targetOrientation = we.getTargetOrientation();
		if (!targetLocation.equals(we.getLocalLocation()) || targetOrientation != currentOrientation)
		{
			TrueTileIndicator.renderBoatArea(client, g, we.getConfig(), targetLocation, targetOrientation);
		}

		// boat centre tiles and delta line
		g.setColor(Color.YELLOW);

		Point currentPoint = Perspective.localToCanvas(client, currentLocation, 0);
		if (currentPoint != null)
		{
			g.fillRect(currentPoint.getX() - 3, currentPoint.getY() - 3, 7, 7);
		}

		Point targetPoint = Perspective.localToCanvas(client, targetLocation, 0);
		if (targetPoint != null)
		{
			g.fillRect(targetPoint.getX() - 3, targetPoint.getY() - 3, 7, 7);
		}

		if (currentPoint != null && targetPoint != null)
		{
			g.drawLine(currentPoint.getX(), currentPoint.getY(), targetPoint.getX(), targetPoint.getY());
		}

		return null;
	}

	@Subscribe
	public void onCommandExecuted(CommandExecuted e)
	{
		if (e.getCommand().equals("route"))
		{
			active = !active;
		}
	}
}

package com.duckblade.osrs.sailing;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Scanner;
import java.util.regex.Pattern;

public class GenerateSeaChartTasks
{

	private static final String VARBIT_ID_URL = "https://github.com/runelite/runelite/raw/refs/heads/master/runelite-api/src/main/java/net/runelite/api/gameval/VarbitID.java";
	private static final String OBJECT_ID_URL = "https://github.com/runelite/runelite/raw/refs/heads/master/runelite-api/src/main/java/net/runelite/api/gameval/ObjectID.java";
	private static final String OBJECT_ID_1_URL = "https://github.com/runelite/runelite/raw/refs/heads/master/runelite-api/src/main/java/net/runelite/api/gameval/ObjectID1.java";
	private static final String NPC_ID_URL = "https://github.com/runelite/runelite/raw/refs/heads/master/runelite-api/src/main/java/net/runelite/api/gameval/NpcID.java";

	public static void main(String[] main) throws Exception
	{
		Map<Integer, String> varbNames = readConstants(VARBIT_ID_URL);
		Map<Integer, String> objectNames = readConstants(OBJECT_ID_URL);
		objectNames.putAll(readConstants(OBJECT_ID_1_URL));
		Map<Integer, String> npcNames = readConstants(NPC_ID_URL);
		System.setOut(new PrintStream(new FileOutputStream("src/main/java/com/duckblade/osrs/sailing/features/charting/SeaChartTask.java")));

		System.out.println("package com.duckblade.osrs.sailing.features.charting;");
		System.out.println();
		System.out.println("import lombok.Getter;");
		System.out.println("import lombok.RequiredArgsConstructor;");
		System.out.println("import net.runelite.api.Client;");
		System.out.println("import net.runelite.api.coords.WorldPoint;");
		System.out.println("import net.runelite.api.gameval.VarbitID;");
		System.out.println("import net.runelite.api.gameval.ObjectID;");
		System.out.println("import net.runelite.api.gameval.NpcID;");
		System.out.println();
		System.out.println("@RequiredArgsConstructor");
		System.out.println("@Getter");
		System.out.println("public enum SeaChartTask");
		System.out.println("{");
		System.out.println();

		var taskTypePat = Pattern.compile("GENERIC|SPYGLASS|DRINK_CRATE|CURRENT_DUCK|MERMAID_GUIDE|WEATHER");

		try (Scanner scanner = new Scanner(Objects.requireNonNull(GenerateSeaChartTasks.class.getResourceAsStream("/chartables.tsv"))))
		{
			scanner.nextLine(); // skip header
			while (scanner.hasNextLine())
			{
				String[] parts = scanner.nextLine().split("\t");
				int taskId = Integer.parseInt(parts[0]);
				int varb = Integer.parseInt(parts[1]);
				int object = Integer.parseInt(parts[2]);
				int npc = Integer.parseInt(parts[3]);
				int x = Integer.parseInt(parts[4]);
				int y = Integer.parseInt(parts[5]);
				int dstX = Integer.parseInt(parts[6]);
				int dstY = Integer.parseInt(parts[7]);
				int level = Integer.parseInt(parts[8]);

				var varbName = varbNames.get(varb);

				System.out.print("\t");
				System.out.print("TASK_");
				System.out.print(taskId);
				System.out.print("(");
				System.out.print(taskId);
				System.out.print(", ");
				{
					var matcher = taskTypePat.matcher(varbName);
					if (!matcher.find())
					{
						System.out.println("null");
					}
					else
					{
						System.out.print("SeaChartTaskType.");
						System.out.print(matcher.group(0));
					}
					System.out.print(", ");
				}
				System.out.print("VarbitID." + varbName);
				System.out.print(", ");
				if (object != -1)
				{
					System.out.print("ObjectID." + objectNames.get(object));
				}
				else
				{
					System.out.print("-1");
				}
				System.out.print(", ");
				if (npc != -1)
				{
					System.out.print("NpcID." + npcNames.get(npc));
				}
				else
				{
					System.out.print("-1");
				}
				System.out.print(", ");
				if (x != -1 && y != -1)
				{
					System.out.print("new WorldPoint(");
					System.out.print(x);
					System.out.print(", ");
					System.out.print(y);
					System.out.print(", 0)");
				}
				else
				{
					System.out.print("null");
				}
				System.out.print(", ");
				if (dstX != -1 && dstY != -1)
				{
					System.out.print("new WorldPoint(");
					System.out.print(dstX);
					System.out.print(", ");
					System.out.print(dstY);
					System.out.print(", 0)");
				}
				else
				{
					System.out.print("null");
				}
				System.out.print(", ");
				System.out.print(level);
				System.out.println("),");
			}
		}

		System.out.println("\t;");
		System.out.println();
		System.out.println("\tprivate final int taskId;");
		System.out.println("\tprivate final SeaChartTaskType type;");
		System.out.println("\tprivate final int completionVarb;");
		System.out.println("\tprivate final int objectId;");
		System.out.println("\tprivate final int npcId;");
		System.out.println("\tprivate final WorldPoint location;");
		System.out.println("\tprivate final WorldPoint destination;");
		System.out.println("\tprivate final int level;");
		System.out.println();
		System.out.println("\tpublic boolean isComplete(Client client)");
		System.out.println("\t{");
		System.out.println("\t\treturn client.getVarbitValue(getCompletionVarb()) != 0;");
		System.out.println("\t}");
		System.out.println();
		System.out.println("}");
	}

	private static Map<Integer, String> readConstants(String url) throws IOException
	{
		Map<Integer, String> values = new HashMap<>();
		try (Scanner scanner = new Scanner(Objects.requireNonNull(new URL(url).openStream())))
		{
			while (scanner.hasNextLine())
			{
				String line = scanner.nextLine();
				if (!line.contains("=") || line.contains("*"))
				{
					continue;
				}

				String[] parts = line.split("=");
				String name = parts[0].trim()
					.substring("public static final int ".length());
				String value = parts[1].trim()
					.replace(";", "");

				values.put(Integer.parseInt(value), name);
			}
		}

		return values;
	}

}

