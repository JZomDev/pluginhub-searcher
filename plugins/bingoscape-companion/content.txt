package org.bingoscape;

import net.runelite.api.Client;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import org.bingoscape.models.Bingo;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.*;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.TimeZone;

/**
 * Overlay that displays the codephrase for the currently selected bingo
 */
public class BingoCodephraseOverlay extends OverlayPanel {
    private static final SimpleDateFormat TIME_FORMAT = new SimpleDateFormat("HH:mm:ss");
    private static final int MAX_WIDTH = 200; // Maximum width for the overlay

    private final BingoScapePlugin plugin;
    private final BingoScapeConfig config;
    private final Client client;

    @Inject
    public BingoCodephraseOverlay(Client client, BingoScapePlugin plugin, BingoScapeConfig config) {
        super(plugin);
        this.client = client;
        this.plugin = plugin;
        this.config = config;

        setPriority(0.1f);
        setPosition(OverlayPosition.TOP_LEFT);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        // Check if overlay is enabled in settings
        if (!config.showCodephraseOverlay()) {
            return null;
        }

        // Check if a bingo is selected
        Bingo currentBingo = plugin.getCurrentBingo();
        if (currentBingo == null || currentBingo.getCodephrase() == null || currentBingo.getCodephrase().trim().isEmpty()) {
            return null;
        }

        // Get all text components that will be displayed
        String title = plugin.getCurrentEvent().getTitle();
        String boardText = "Board: " + currentBingo.getTitle();
        String codephraseText = "Codephrase: " + currentBingo.getCodephrase();
        String timeText = "Time: " + utcNow();

        // Calculate maximum width based on all components
        FontMetrics metrics = graphics.getFontMetrics();
        int maxWidth = Math.max(
            Math.max(metrics.stringWidth(title), metrics.stringWidth(boardText)),
            Math.max(metrics.stringWidth(codephraseText), metrics.stringWidth(timeText))
        );

        // Add some padding
        maxWidth += 20;

        // Add title
        panelComponent.getChildren().add(TitleComponent.builder()
                .text(title)
                .color(new Color(255, 215, 0)) // Gold color
                .build());

        // Add board
        panelComponent.getChildren().add(LineComponent.builder()
                .left("Board:")
                .right(currentBingo.getTitle())
                .rightColor(Color.WHITE)
                .build());

        // Add codephrase
        panelComponent.getChildren().add(LineComponent.builder()
                .left("Codephrase:")
                .right(currentBingo.getCodephrase())
                .rightColor(Color.WHITE)
                .build());

        // Add current time
        panelComponent.getChildren().add(LineComponent.builder()
                .left("Time:")
                .right(utcNow())
                .rightColor(Color.LIGHT_GRAY)
                .build());

        // Set preferred size based on maximum width
        panelComponent.setPreferredSize(new Dimension(maxWidth, 0));

        return super.render(graphics);
    }

    private String utcNow() {
        SimpleDateFormat sdf = new SimpleDateFormat("dd.MM.yyyy HH:mm");
        sdf.setTimeZone(TimeZone.getTimeZone("UTC"));
        return sdf.format(new Date()) + " UTC";
    }
}

package org.bingoscape.models;

import lombok.Data;

@Data
public class TeamMember {
    private boolean isLeader;
    private String runescapeName;
}

package org.bingoscape.models;

public enum Role {
    ADMIN, MANAGEMENT, PARTICIPANT;
}

package org.bingoscape.models;

import lombok.Data;

import java.time.Instant;
import java.util.Date;
import java.util.UUID;

@Data
public class Clan {
    private UUID id;
    private String name;
    private String description;
    private UUID ownerId;
    private Date createdAt;
    private Date updatedAt;
}

package org.bingoscape.models;

import lombok.Data;

@Data
public class ErrorResponse {
    private String error;
}

package org.bingoscape.models;

import lombok.Data;

import java.util.Date;
import java.util.List;
import java.time.Instant;
import java.util.UUID;

@Data
public class EventData {
    private UUID id;
    private String title;
    private String description;
    private Date startDate;
    private Date endDate;
    private UUID creatorId;
    private UUID clanId;
    private Date createdAt;
    private Date updatedAt;
    private boolean locked;
    private boolean isPublic;
    private long basePrizePool;
    private long minimumBuyIn;
    private List<EventParticipant> eventParticipants;
    private Clan clan;
    private List<Bingo> bingos;
    private UserTeam userTeam;
    private Role role;
}


package org.bingoscape.models;

import lombok.Data; /**
 * Represents progress towards a goal
 */
@Data
public class GoalProgress {
    private String id;
    private int currentValue;
    private int targetValue;
    private String description;
    private int progress; // Progress as percentage (0-100)
}

package org.bingoscape.models;

import com.google.gson.annotations.SerializedName;

/**
 * Enum representing the possible status values for a bingo tile
 */
public enum TileSubmissionType {
    @SerializedName("pending")
    PENDING("pending"),
    @SerializedName("accepted")
    ACCEPTED("accepted"),
    @SerializedName("requires_interaction")
    REQUIRES_INTERACTION("requires_interaction"),
    @SerializedName("declined")
    DECLINED("declined"),
    @SerializedName("not_submitted")
    NOT_SUBMITTED("not_submitted");

    private final String value;

    TileSubmissionType(String value) {
        this.value = value;
    }

    public String getValue() {
        return value;
    }

    // Convert string value to enum
    public static TileSubmissionType fromValue(String value) {
        for (TileSubmissionType type : TileSubmissionType.values()) {
            if (type.value.equals(value)) {
                return type;
            }
        }
        throw new IllegalArgumentException("Unknown status type: " + value);
    }
}

package org.bingoscape.models;

import lombok.Data;

import java.time.Instant;
import java.util.Date;
import java.util.List;
import java.util.UUID;

/**
 * Enhanced Tile model to include submission and goals
 */
@Data
public class Tile {
    private UUID id;
    private UUID bingoId;
    private String headerImage;
    private String title;
    private String description;
    private int weight;
    private int index;
    private boolean isHidden;
    private Date createdAt;
    private Date updatedAt;
    private TileSubmission submission;
    private List<Goal> goals;
}

package org.bingoscape.models;

import lombok.Data;

import java.util.Date;

@Data
public class SubmissionDetails {
    private String id;
    private String imageUrl;
    private User submittedBy;
    private Date createdAt;
}

package org.bingoscape.models;

import lombok.Data;

import java.util.UUID; /**
 * Represents a user in the system
 */
@Data
public class User {
    private UUID id;
    private String name;
    private String runescapeName;
}

package org.bingoscape.models;

import lombok.Data;

@Data
public class Goal {
    private String id;
    private String description;
    private int targetValue;
}

package org.bingoscape.models;

import lombok.Data;

import java.time.Instant;
import java.util.Date;
import java.util.List;
import java.util.UUID;

@Data
public class Bingo {
    private UUID id;
    private UUID eventId;
    private String title;
    private String description;
    private int rows;
    private int columns;
    private String codephrase;
    private Date createdAt;
    private Date updatedAt;
    private boolean locked;
    private boolean visible;
    private List<Tile> tiles;
}

package org.bingoscape.models;

import lombok.Data;

import java.util.List;
import java.util.UUID;

@Data
public class UserTeam {
    private String name;
    private List<TeamMember> members;
}

package org.bingoscape.models;

import lombok.Data;

import java.util.Date;
import java.util.UUID;

/**
 * Represents a submission for a tile
 */
@Data
public class TileSubmission {
    private String id;
    private TileSubmissionType status;
    private Date lastUpdated;
    private int submissionCount;
    private SubmissionDetails latestSubmission;
}


package org.bingoscape.models;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.util.Map;
import java.util.UUID;

/**
 * Enhanced BingoTileResponse to include team details
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class BingoTileResponse {
    private String bingoId;
    private String teamId;
    private String teamName;
    private Map<UUID, TileStatus> tiles;
}

package org.bingoscape.models;

import lombok.Data;

import java.time.Instant;
import java.util.Date;
import java.util.UUID;

@Data
public class EventParticipant {
    private UUID id;
    private UUID eventId;
    private UUID userId;
    private Role role;
    private Date createdAt;
    private Date updatedAt;
}

package org.bingoscape.models;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

/**
 * Represents the status of a bingo tile
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class TileStatus {
    private String id;
    private TileSubmissionType status;
}

package org.bingoscape;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import org.bingoscape.models.*;

import javax.swing.*;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.net.URL;
import java.text.SimpleDateFormat;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ConcurrentHashMap;
import javax.imageio.ImageIO;
import java.util.List;

public class BingoBoardWindow extends JFrame {
    private static final int WINDOW_WIDTH = 600;
    private static final int WINDOW_HEIGHT = 600;
    private static final int PADDING = 10;
    private static final int SPACING = 4;
    private static final int IMAGE_LOADING_THREADS = 4;

    private final BingoScapePlugin plugin;
    private final JPanel bingoBoard;
    private JLabel titleLabel;
    private final ExecutorService executor;
    private Bingo currentBingo;
    private final Map<String, ImageIcon> imageCache = new ConcurrentHashMap<>();

    public BingoBoardWindow(BingoScapePlugin plugin, Bingo bingo) {
        this.plugin = plugin;
        this.currentBingo = bingo;
        this.executor = Executors.newFixedThreadPool(IMAGE_LOADING_THREADS);

        // Window setup
        // Window setup
        String windowTitle = "BingoScape - " + bingo.getTitle();
        // Add codephrase to title if available
        if (bingo.getCodephrase() != null && !bingo.getCodephrase().isEmpty()) {
            windowTitle += " | Codephrase: " + bingo.getCodephrase();
        }

        setTitle(windowTitle);
        setSize(WINDOW_WIDTH, WINDOW_HEIGHT);
        setResizable(true); // Allow resizing for better image viewing
        setLocationRelativeTo(null);
        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);

        // Main panel setup
        JPanel contentPanel = new JPanel(new BorderLayout());
        contentPanel.setBorder(new EmptyBorder(PADDING, PADDING, PADDING, PADDING));
        contentPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        // Title setup
        JPanel titlePanel = new JPanel(new BorderLayout());
        titlePanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        titlePanel.setBorder(new EmptyBorder(0, 0, PADDING, 0));
        
        titleLabel = new JLabel(bingo.getTitle());
        titleLabel.setFont(FontManager.getRunescapeBoldFont());
        titleLabel.setForeground(Color.WHITE);
        titleLabel.setHorizontalAlignment(SwingConstants.CENTER);
        titlePanel.add(titleLabel, BorderLayout.CENTER);

        // Create button container for reload and pin buttons
        JPanel buttonContainer = new JPanel(new FlowLayout(FlowLayout.RIGHT, 0, 0));
        buttonContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);

        // Add pin button
        JButton pinButton = new JButton(isPinned() ? "Un-📌" : "📌");
        pinButton.setFocusPainted(false);
        pinButton.setContentAreaFilled(false);
        pinButton.setForeground(Color.WHITE);
        pinButton.setBorder(new EmptyBorder(0, 5, 0, 5));
        pinButton.setToolTipText(isPinned() ? "Unpin Board" : "Pin Board");

        // Add hover effect for pin button
        pinButton.addMouseListener(new java.awt.event.MouseAdapter() {
            @Override
            public void mouseEntered(java.awt.event.MouseEvent evt) {
                if (pinButton.isEnabled()) {
                    pinButton.setContentAreaFilled(true);
                    pinButton.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
                }
            }

            @Override
            public void mouseExited(java.awt.event.MouseEvent evt) {
                pinButton.setContentAreaFilled(false);
            }
        });

        // Add pin action
        pinButton.addActionListener(e -> {
            if (isPinned()) {
                plugin.unpinBingo();
                pinButton.setText("📌");
                pinButton.setToolTipText("Pin Board");
            } else {
                plugin.pinBingo(currentBingo.getId());
                pinButton.setText("Un-📌");
                pinButton.setToolTipText("Unpin Board");
            }
        });

        // Add reload button
        JButton reloadButton = new JButton();
        reloadButton.setIcon(new ImageIcon(getClass().getResource("/refresh_icon.png")));
        reloadButton.setToolTipText("Reload Board");
        reloadButton.setPreferredSize(new Dimension(24, 24));
        reloadButton.setMaximumSize(new Dimension(24, 24));
        reloadButton.setMinimumSize(new Dimension(24, 24));
        reloadButton.setFocusPainted(false);
        reloadButton.setContentAreaFilled(false);
        reloadButton.setForeground(Color.WHITE);
        reloadButton.setBorder(new EmptyBorder(0, 5, 0, 5));

        // Create a container panel for the button to ensure proper spacing
        buttonContainer.add(pinButton);
        buttonContainer.add(reloadButton);

        // Add hover effect
        reloadButton.addMouseListener(new java.awt.event.MouseAdapter() {
            @Override
            public void mouseEntered(java.awt.event.MouseEvent evt) {
                if (reloadButton.isEnabled()) {
                    reloadButton.setContentAreaFilled(true);
                    reloadButton.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
                }
            }

            @Override
            public void mouseExited(java.awt.event.MouseEvent evt) {
                reloadButton.setContentAreaFilled(false);
            }
        });

        // Add reload action
        reloadButton.addActionListener(e -> {
            reloadButton.setEnabled(false);
            executor.submit(() -> {
                plugin.refreshBingoBoard();
                SwingUtilities.invokeLater(() -> reloadButton.setEnabled(true));
            });
        });

        titlePanel.add(buttonContainer, BorderLayout.EAST);
        contentPanel.add(titlePanel, BorderLayout.NORTH);

        // Bingo board setup
        bingoBoard = new JPanel();
        bingoBoard.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        bingoBoard.setBorder(new EmptyBorder(5, 5, 5, 5));

        JScrollPane scrollPane = new JScrollPane(bingoBoard);
        scrollPane.setBorder(null);
        scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);

        contentPanel.add(scrollPane, BorderLayout.CENTER);
        setContentPane(contentPanel);

        // Display the bingo board
        updateGridLayout(bingo);
        updateBingoBoard(bingo);
    }

    private void updateGridLayout(Bingo bingo) {
        int rows = bingo.getRows() <= 0 ? 5 : bingo.getRows();
        int cols = bingo.getColumns() <= 0 ? 5 : bingo.getColumns();
        bingoBoard.setLayout(new GridLayout(rows, cols, SPACING, SPACING));
    }

    public void updateBingoBoard(Bingo bingo) {
        this.currentBingo = bingo;
        SwingUtilities.invokeLater(() -> {
            String windowTitle = "BingoScape - " + bingo.getTitle();
            // Add codephrase to title if available
            if (bingo.getCodephrase() != null && !bingo.getCodephrase().isEmpty()) {
                windowTitle += " | Codephrase: " + bingo.getCodephrase();
            }
            titleLabel.setText(windowTitle);
            updateGridLayout(bingo);
            displayBingoBoard(bingo);
        });
    }

    // Updated to use new tile model with submission data directly
    private void displayBingoBoard(Bingo bingo) {
        SwingUtilities.invokeLater(() -> {
            bingoBoard.removeAll();

            if (bingo == null || bingo.getTiles() == null) {
                return;
            }

            // Sort tiles by position
            bingo.getTiles().sort((a, b) -> Integer.compare(a.getIndex(), b.getIndex()));

            // Create all tile panels at once
            for (Tile tile : bingo.getTiles()) {
                // Skip hidden tiles
                if (tile.isHidden()) {
                    JPanel hiddenPanel = createHiddenTilePanel();
                    bingoBoard.add(hiddenPanel);
                    continue;
                }

                JPanel tilePanel = createTilePanel(tile);
                bingoBoard.add(tilePanel);
            }

            bingoBoard.revalidate();
            bingoBoard.repaint();
        });
    }

    private JPanel createHiddenTilePanel() {
        // Calculate tile size based on board dimensions
        int rows = currentBingo.getRows() > 0 ? currentBingo.getRows() : 5;
        int cols = currentBingo.getColumns() > 0 ? currentBingo.getColumns() : 5;
        int availableWidth = WINDOW_WIDTH - 40;
        int availableHeight = WINDOW_HEIGHT - 100;
        int tileSize = Math.min(availableWidth / cols, availableHeight / rows) - PADDING;

        JPanel panel = new JPanel(new BorderLayout());
        panel.setPreferredSize(new Dimension(tileSize, tileSize));
        panel.setMinimumSize(new Dimension(tileSize, tileSize));
        panel.setMaximumSize(new Dimension(tileSize, tileSize));
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setBorder(new CompoundBorder(
                new LineBorder(ColorScheme.BORDER_COLOR, 1),
                new EmptyBorder(4, 4, 4, 4)
        ));

        JLabel hiddenLabel = new JLabel("?", SwingConstants.CENTER);
        hiddenLabel.setForeground(Color.GRAY);
        hiddenLabel.setFont(new Font(hiddenLabel.getFont().getName(), Font.BOLD, 24));
        panel.add(hiddenLabel, BorderLayout.CENTER);

        panel.setToolTipText("Hidden tile");
        return panel;
    }

    // Method to create enhanced tile panel with more information
    private JPanel createTilePanel(Tile tile) {
        // Calculate tile size based on board dimensions
        int rows = currentBingo.getRows() > 0 ? currentBingo.getRows() : 5;
        int cols = currentBingo.getColumns() > 0 ? currentBingo.getColumns() : 5;
        int availableWidth = WINDOW_WIDTH - 40;
        int availableHeight = WINDOW_HEIGHT - 100;
        int tileSize = Math.min(availableWidth / cols, availableHeight / rows) - PADDING;

        JPanel panel = new JPanel(new BorderLayout());
        panel.setPreferredSize(new Dimension(tileSize, tileSize));
        panel.setMinimumSize(new Dimension(tileSize, tileSize));

        // Don't set maximum size to allow proper image display
        // panel.setMaximumSize(new Dimension(tileSize, tileSize));

        // Set background based on submission status
        Color backgroundColor = getTileBackgroundColor(tile.getSubmission());
        panel.setBackground(backgroundColor);

        // Set border based on submission status
        panel.setBorder(new CompoundBorder(
                new LineBorder(getTileBorderColor(tile.getSubmission()), 2),
                new EmptyBorder(4, 4, 4, 4)
        ));

        // Create tooltip with extended information
        panel.setToolTipText(createDetailedTooltip(tile));

        // Add image if available, otherwise show title
        if (tile.getHeaderImage() != null && !tile.getHeaderImage().isEmpty()) {
            loadTileImage(panel, tile, tileSize);
        } else {
            JLabel titleLabel = new JLabel("<html><center>" + tile.getTitle() + "</center></html>", SwingConstants.CENTER);
            titleLabel.setForeground(Color.WHITE);
            panel.add(titleLabel, BorderLayout.CENTER);
        }

        // Add XP value indicator in corner - make sure it doesn't overlap with image
        JPanel topPanel = new JPanel(new BorderLayout());
        topPanel.setOpaque(false);
        JLabel xpLabel = new JLabel(String.valueOf(tile.getWeight()) + " XP");
        xpLabel.setForeground(new Color(255, 215, 0)); // Gold color
        xpLabel.setFont(new Font(xpLabel.getFont().getName(), Font.BOLD, 10));
        xpLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        topPanel.add(xpLabel, BorderLayout.NORTH);
        panel.add(topPanel, BorderLayout.NORTH);

        // Add status overlay
        if (tile.getSubmission() != null && tile.getSubmission().getStatus() != null &&
                tile.getSubmission().getStatus() != TileSubmissionType.NOT_SUBMITTED) {
            addStatusOverlay(panel, tile.getSubmission());
        }

        // Add click behavior
        addTilePanelListeners(panel, tile);

        return panel;
    }

    // Create a detailed HTML tooltip for the tile
    private String createDetailedTooltip(Tile tile) {
        StringBuilder tooltip = new StringBuilder();
        tooltip.append("<html><body style='width: 250px'>");

        // Title with weight
        tooltip.append("<div style='font-weight: bold; font-size: 12pt;'>")
                .append(tile.getTitle())
                .append(" (")
                .append(tile.getWeight())
                .append(" XP)</div>");

        // Description if available
        if (tile.getDescription() != null && !tile.getDescription().isEmpty()) {
            tooltip.append("<div style='margin-top: 5px;'>")
                    .append(tile.getDescription())
                    .append("</div>");
        }

        // Add submission status if available
        if (tile.getSubmission() != null && tile.getSubmission().getStatus() != null) {
            String statusText = getStatusText(tile.getSubmission().getStatus());
            String statusColor = getStatusHexColor(tile.getSubmission().getStatus());

            tooltip.append("<div style='margin-top: 8px;'><b>Status:</b> ")
                    .append("<span style='color: ")
                    .append(statusColor)
                    .append(";'>")
                    .append(statusText)
                    .append("</span></div>");

            // Show submission count if any
            if (tile.getSubmission().getSubmissionCount() > 0) {
                tooltip.append("<div><b>Submissions:</b> ")
                        .append(tile.getSubmission().getSubmissionCount())
                        .append("</div>");
            }

            // Show last update time if available
            if (tile.getSubmission().getLastUpdated() != null) {
                SimpleDateFormat dateFormat = new SimpleDateFormat("MMM dd, yyyy HH:mm");
                tooltip.append("<div><b>Last updated:</b> ")
                        .append(dateFormat.format(tile.getSubmission().getLastUpdated()))
                        .append("</div>");
            }
        }

        // Goal information
        if (tile.getGoals() != null && !tile.getGoals().isEmpty()) {
            tooltip.append("<div style='margin-top: 5px;'><b>Goals:</b></div><ul style='margin-top: 2px; margin-left: 15px; padding-left: 0px;'>");
            for (Goal goal : tile.getGoals()) {
                tooltip.append("<li>")
                        .append(goal.getDescription())
                        .append(": ")
                        .append(goal.getTargetValue())
                        .append("</li>");
            }
            tooltip.append("</ul>");
        }

        tooltip.append("</body></html>");
        return tooltip.toString();
    }

    // Get background color based on submission status
    private Color getTileBackgroundColor(TileSubmission submission) {
        if (submission == null || submission.getStatus() == null ||
                submission.getStatus() == TileSubmissionType.NOT_SUBMITTED) {
            return ColorScheme.DARK_GRAY_COLOR;
        }

        switch (submission.getStatus()) {
            case PENDING:
                return new Color(30, 64, 122); // Darker blue
            case ACCEPTED:
                return new Color(17, 99, 47);  // Darker green
            case REQUIRES_INTERACTION:
                return new Color(117, 89, 4);  // Darker yellow/gold
            case DECLINED:
                return new Color(120, 34, 34); // Darker red
            default:
                return ColorScheme.DARK_GRAY_COLOR;
        }
    }

    // Get border color based on submission status
    private Color getTileBorderColor(TileSubmission submission) {
        if (submission == null || submission.getStatus() == null)
            return ColorScheme.BORDER_COLOR;

        switch (submission.getStatus()) {
            case PENDING:
                return new Color(59, 130, 246); // Blue
            case ACCEPTED:
                return new Color(34, 197, 94);  // Green
            case REQUIRES_INTERACTION:
                return new Color(234, 179, 8);  // Yellow
            case DECLINED:
                return new Color(239, 68, 68);  // Red
            default:
                return ColorScheme.BORDER_COLOR;
        }
    }

    // Get hex color for tooltip based on submission status
    private String getStatusHexColor(TileSubmissionType status) {
        switch (status) {
            case PENDING:
                return "#3b82f6"; // Blue
            case ACCEPTED:
                return "#22c55e"; // Green
            case REQUIRES_INTERACTION:
                return "#eab308"; // Yellow
            case DECLINED:
                return "#ef4444"; // Red
            default:
                return "#ffffff"; // White
        }
    }

    private void addStatusOverlay(JPanel panel, TileSubmission submission) {
        JPanel overlayPanel = new JPanel(new BorderLayout());
        overlayPanel.setOpaque(false);

        JLabel statusLabel = new JLabel();
        statusLabel.setHorizontalAlignment(SwingConstants.CENTER);
        statusLabel.setFont(new Font(statusLabel.getFont().getName(), Font.BOLD, 12));

        switch (submission.getStatus()) {
            case PENDING:
                statusLabel.setText("PENDING");
                statusLabel.setForeground(new Color(59, 130, 246));
                break;
            case ACCEPTED:
                statusLabel.setText("COMPLETED");
                statusLabel.setForeground(new Color(34, 197, 94));
                break;
            case REQUIRES_INTERACTION:
                statusLabel.setText("NEEDS ACTION");
                statusLabel.setForeground(new Color(234, 179, 8));
                break;
            case DECLINED:
                statusLabel.setText("DECLINED");
                statusLabel.setForeground(new Color(239, 68, 68));
                break;
            default:
                // No overlay for NOT_SUBMITTED
                return;
        }

        overlayPanel.add(statusLabel, BorderLayout.SOUTH);
        panel.add(overlayPanel, BorderLayout.SOUTH);
    }

    private void addTilePanelListeners(JPanel panel, Tile tile) {
        panel.addMouseListener(new java.awt.event.MouseAdapter() {
            private final Color originalColor = panel.getBackground();

            @Override
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                showSubmissionDialog(tile);
            }

            @Override
            public void mouseEntered(java.awt.event.MouseEvent evt) {
                panel.setBackground(originalColor.brighter());
            }

            @Override
            public void mouseExited(java.awt.event.MouseEvent evt) {
                panel.setBackground(originalColor);
            }
        });
    }

    private void loadTileImage(JPanel panel, Tile tile, int tileSize) {
        String imageUrl = tile.getHeaderImage();

        // Create and add placeholder/loading label immediately
        JLabel imageLabel = new JLabel("Loading...");
        imageLabel.setHorizontalAlignment(JLabel.CENTER);
        imageLabel.setVerticalAlignment(JLabel.CENTER);
        imageLabel.setForeground(Color.LIGHT_GRAY);
        panel.add(imageLabel, BorderLayout.CENTER);

        // Check cache first (still do this async to not block UI)
        executor.submit(() -> {
            if (imageCache.containsKey(imageUrl)) {
                SwingUtilities.invokeLater(() -> {
                    imageLabel.setText("");
                    imageLabel.setIcon(imageCache.get(imageUrl));
                    panel.revalidate();
                });
                return;
            }

            try {
                // Fetch the image
                URL url = new URL(imageUrl);
                BufferedImage originalImage = ImageIO.read(url);

                if (originalImage != null) {
                    // Create a separate thread for the CPU-intensive scaling operation
                    executor.submit(() -> {
                        try {
                            // Scale the image to fit (CPU intensive)
                            // Use a better scaling approach that keeps aspect ratio
                            Image scaledImage = getScaledImageImproved(originalImage, tileSize - 10, tileSize - 20);
                            ImageIcon icon = new ImageIcon(scaledImage);

                            // Add to cache
                            imageCache.put(imageUrl, icon);

                            SwingUtilities.invokeLater(() -> {
                                imageLabel.setText("");
                                imageLabel.setIcon(icon);
                                // Center the image
                                imageLabel.setHorizontalAlignment(JLabel.CENTER);
                                panel.revalidate();
                            });
                        } catch (Exception e) {
                            handleImageLoadError(panel, imageLabel, tile);
                        }
                    });
                } else {
                    handleImageLoadError(panel, imageLabel, tile);
                }
            } catch (IOException e) {
                handleImageLoadError(panel, imageLabel, tile);
            }
        });
    }

    private void handleImageLoadError(JPanel panel, JLabel imageLabel, Tile tile) {
        SwingUtilities.invokeLater(() -> {
            imageLabel.setText("<html><center>" + tile.getTitle() + "</center></html>");
            imageLabel.setIcon(null);
            imageLabel.setForeground(Color.WHITE);
            panel.revalidate();
        });
    }

    // Improved scaling method to better handle aspect ratios
    private Image getScaledImageImproved(BufferedImage img, int targetWidth, int targetHeight) {
        if (img == null) {
            return null;
        }

        // Calculate dimensions that preserve aspect ratio
        double imgRatio = (double) img.getWidth() / img.getHeight();
        double targetRatio = (double) targetWidth / targetHeight;

        int scaledWidth, scaledHeight;
        if (imgRatio > targetRatio) {
            // Image is wider than target ratio - constrain by width
            scaledWidth = targetWidth;
            scaledHeight = (int) (scaledWidth / imgRatio);
        } else {
            // Image is taller than target ratio - constrain by height
            scaledHeight = targetHeight;
            scaledWidth = (int) (scaledHeight * imgRatio);
        }

        // Create a high-quality scaled version with transparency support
        Image scaledImage = img.getScaledInstance(scaledWidth, scaledHeight, Image.SCALE_SMOOTH);

        // Create a new BufferedImage with transparency
        BufferedImage finalImage = new BufferedImage(scaledWidth, scaledHeight, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = finalImage.createGraphics();

        // Set up high quality rendering
        g2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);
        g2d.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        // Draw the scaled image
        g2d.drawImage(scaledImage, 0, 0, null);
        g2d.dispose();

        return finalImage;
    }

    private void showSubmissionDialog(Tile tile) {
        JDialog dialog = new JDialog(this, "Tile Details", true);
        dialog.setMinimumSize(new Dimension(450, 300));
        dialog.setLayout(new BorderLayout());

        // Main panel with scroll support
        JPanel mainPanel = createTileDetailsPanel(tile);
        JScrollPane scrollPane = new JScrollPane(mainPanel);
        scrollPane.setBorder(null);
        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
        scrollPane.getVerticalScrollBar().setUnitIncrement(16);

        // Button panel
        JPanel buttonPanel = createDialogButtonPanel(dialog, tile);

        dialog.add(scrollPane, BorderLayout.CENTER);
        dialog.add(buttonPanel, BorderLayout.SOUTH);
        
        // Pack the dialog to fit content and ensure minimum size
        dialog.pack();
        
        // Set maximum height to 80% of screen height
        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
        int maxHeight = (int)(screenSize.height * 0.8);
        if (dialog.getHeight() > maxHeight) {
            dialog.setSize(dialog.getWidth(), maxHeight);
        }
        
        dialog.setLocationRelativeTo(this);
        dialog.setVisible(true);
    }

    private JPanel createTileDetailsPanel(Tile tile) {
        // Create a split panel with info on left, image on right
        JPanel mainPanel = new JPanel(new BorderLayout(10, 0));
        mainPanel.setBorder(new EmptyBorder(15, 15, 15, 15));
        mainPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Left side: Info panel with vertical scrolling
        JPanel infoPanel = new JPanel();
        infoPanel.setLayout(new BoxLayout(infoPanel, BoxLayout.Y_AXIS));
        infoPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Title
        JLabel titleLabel = new JLabel("<html><h2 style='margin: 0;'>" + tile.getTitle() + "</h2></html>");
        titleLabel.setFont(FontManager.getRunescapeBoldFont());
        titleLabel.setForeground(Color.WHITE);
        titleLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

        // XP (formerly weight)
        JLabel xpLabel = new JLabel("XP: " + tile.getWeight());
        xpLabel.setForeground(Color.LIGHT_GRAY);
        xpLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
        xpLabel.setBorder(new EmptyBorder(5, 0, 10, 0));

        // Description with proper wrapping
        JTextArea descriptionArea = new JTextArea(tile.getDescription());
        descriptionArea.setWrapStyleWord(true);
        descriptionArea.setLineWrap(true);
        descriptionArea.setEditable(false);
        descriptionArea.setForeground(Color.WHITE);
        descriptionArea.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        descriptionArea.setAlignmentX(Component.LEFT_ALIGNMENT);
        // Set preferred size for proper wrapping
        descriptionArea.setPreferredSize(new Dimension(250, descriptionArea.getPreferredSize().height));

        infoPanel.add(titleLabel);
        infoPanel.add(xpLabel);
        infoPanel.add(descriptionArea);

        // Add goals if present
        if (tile.getGoals() != null && !tile.getGoals().isEmpty()) {
            JPanel goalsPanel = new JPanel();
            goalsPanel.setLayout(new BoxLayout(goalsPanel, BoxLayout.Y_AXIS));
            goalsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            goalsPanel.setBorder(new EmptyBorder(10, 0, 0, 0));
            goalsPanel.setAlignmentX(Component.LEFT_ALIGNMENT);

            JLabel goalsLabel = new JLabel("Goals:");
            goalsLabel.setForeground(Color.WHITE);
            goalsLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
            goalsPanel.add(goalsLabel);
            goalsPanel.add(Box.createVerticalStrut(5));

            for (Goal goal : tile.getGoals()) {
                JLabel goalLabel = new JLabel("• " + goal.getDescription() + ": " + goal.getTargetValue());
                goalLabel.setForeground(Color.LIGHT_GRAY);
                goalLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
                goalsPanel.add(goalLabel);
                goalsPanel.add(Box.createVerticalStrut(2));
            }

            infoPanel.add(Box.createVerticalStrut(5));
            infoPanel.add(goalsPanel);
        }

        // Add submission status if any
        if (tile.getSubmission() != null && tile.getSubmission().getStatus() != null &&
                tile.getSubmission().getStatus() != TileSubmissionType.NOT_SUBMITTED) {

            JPanel statusPanel = new JPanel();
            statusPanel.setLayout(new BoxLayout(statusPanel, BoxLayout.Y_AXIS));
            statusPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            statusPanel.setBorder(new EmptyBorder(10, 0, 0, 0));
            statusPanel.setAlignmentX(Component.LEFT_ALIGNMENT);

            JLabel statusLabel = new JLabel("Status: " + getStatusText(tile.getSubmission().getStatus()));
            statusLabel.setForeground(getStatusColor(tile.getSubmission().getStatus()));
            statusLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
            statusPanel.add(statusLabel);

            if (tile.getSubmission().getSubmissionCount() > 0) {
                JLabel countLabel = new JLabel("Submissions: " + tile.getSubmission().getSubmissionCount());
                countLabel.setForeground(Color.LIGHT_GRAY);
                countLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
                statusPanel.add(Box.createVerticalStrut(2));
                statusPanel.add(countLabel);
            }

            infoPanel.add(Box.createVerticalStrut(5));
            infoPanel.add(statusPanel);
        }

        // Right side: Image panel
        JPanel imagePanel = createTileImagePanel(tile);

        mainPanel.add(infoPanel, BorderLayout.CENTER);
        mainPanel.add(imagePanel, BorderLayout.EAST);

        return mainPanel;
    }

    private String getStatusText(TileSubmissionType status) {
        switch (status) {
            case PENDING: return "Pending Review";
            case ACCEPTED: return "Completed";
            case REQUIRES_INTERACTION: return "Needs Action";
            case DECLINED: return "Declined";
            default: return "Not Submitted";
        }
    }

    private Color getStatusColor(TileSubmissionType status) {
        switch (status) {
            case PENDING: return new Color(59, 130, 246);
            case ACCEPTED: return new Color(34, 197, 94);
            case REQUIRES_INTERACTION: return new Color(234, 179, 8);
            case DECLINED: return new Color(239, 68, 68);
            default: return Color.LIGHT_GRAY;
        }
    }

    private JPanel createTileImagePanel(Tile tile) {
        JPanel imagePanel = new JPanel(new BorderLayout());
        imagePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        imagePanel.setPreferredSize(new Dimension(150, 150));

        if (tile.getHeaderImage() != null && !tile.getHeaderImage().isEmpty()) {
            // Create a label with loading state
            JLabel imageLabel = new JLabel("Loading...");
            imageLabel.setHorizontalAlignment(JLabel.CENTER);
            imageLabel.setVerticalAlignment(JLabel.CENTER);
            imageLabel.setForeground(Color.LIGHT_GRAY);
            imagePanel.add(imageLabel, BorderLayout.CENTER);

            // Load image in background thread pool
            executor.submit(() -> {
                String imageUrl = tile.getHeaderImage();

                // Check cache first
                if (imageCache.containsKey(imageUrl)) {
                    SwingUtilities.invokeLater(() -> {
                        imageLabel.setText("");
                        imageLabel.setIcon(imageCache.get(imageUrl));
                        imagePanel.revalidate();
                    });
                    return;
                }

                try {
                    // Fetch image in network thread
                    URL url = new URL(imageUrl);
                    BufferedImage originalImage = ImageIO.read(url);

                    if (originalImage != null) {
                        // Process image in separate thread
                        executor.submit(() -> {
                            try {
                                // CPU-intensive scaling operation
                                Image scaledImage = getScaledImageImproved(originalImage, 150, 150);
                                ImageIcon icon = new ImageIcon(scaledImage);

                                // Add to cache
                                imageCache.put(imageUrl, icon);

                                SwingUtilities.invokeLater(() -> {
                                    imageLabel.setText("");
                                    imageLabel.setIcon(icon);
                                    imagePanel.revalidate();
                                });
                            } catch (Exception e) {
                                SwingUtilities.invokeLater(() -> {
                                    imageLabel.setText(tile.getTitle());
                                    imageLabel.setForeground(Color.WHITE);
                                });
                            }
                        });
                    } else {
                        SwingUtilities.invokeLater(() -> {
                            imageLabel.setText(tile.getTitle());
                            imageLabel.setForeground(Color.WHITE);
                        });
                    }
                } catch (IOException e) {
                    SwingUtilities.invokeLater(() -> {
                        imageLabel.setText(tile.getTitle());
                        imageLabel.setForeground(Color.WHITE);
                    });
                }
            });
        }

        return imagePanel;
    }

    private JPanel createDialogButtonPanel(JDialog dialog, Tile tile) {
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        buttonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JButton cancelButton = new JButton("Cancel");
        JButton submitButton = new JButton("Take & Review Screenshot");

        // If tile is already completed, adjust the UI accordingly
        if (tile.getSubmission() != null &&
                tile.getSubmission().getStatus() == TileSubmissionType.ACCEPTED) {
            submitButton.setText("Already Completed");
            submitButton.setEnabled(false);
        }

        if (currentBingo.isLocked()) {
            submitButton.setText("Submissions locked");
            submitButton.setEnabled(false);
        }

        cancelButton.addActionListener(e -> dialog.dispose());
        submitButton.addActionListener(e -> {
            dialog.dispose();
            takeScreenshotAndShowPreview(tile);
        });

        buttonPanel.add(cancelButton);
        buttonPanel.add(submitButton);

        return buttonPanel;
    }

    private void takeScreenshotAndShowPreview(Tile tile) {
        plugin.takeScreenshot(tile.getId(), (screenshotBytes) -> {
            if (screenshotBytes != null) {
                showScreenshotPreviewDialog(tile, screenshotBytes);
            } else {
                JOptionPane.showMessageDialog(this, "Failed to take screenshot.", "Error", JOptionPane.ERROR_MESSAGE);
            }
        });
    }

    private void showScreenshotPreviewDialog(Tile tile, byte[] screenshotBytes) {
        JDialog previewDialog = new JDialog(this, "Screenshot Preview", true);
        previewDialog.setSize(600, 400);
        previewDialog.setLocationRelativeTo(this);
        previewDialog.setLayout(new BorderLayout());

        JLabel screenshotLabel = new JLabel(new ImageIcon(screenshotBytes));
        previewDialog.add(new JScrollPane(screenshotLabel), BorderLayout.CENTER);

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        buttonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JButton cancelButton = new JButton("Cancel");
        JButton submitButton = new JButton("Submit");

        cancelButton.addActionListener(e -> previewDialog.dispose());
        submitButton.addActionListener(e -> {
            plugin.submitTileCompletionWithScreenshot(tile.getId(), screenshotBytes);
            previewDialog.dispose();
        });

        buttonPanel.add(cancelButton);
        buttonPanel.add(submitButton);

        previewDialog.add(buttonPanel, BorderLayout.SOUTH);
        previewDialog.setVisible(true);
    }

    // Clean up resources when window is closed
    @Override
    public void dispose() {
        executor.shutdown();
        imageCache.clear();
        super.dispose();
    }

    private boolean isPinned() {
        return currentBingo != null && 
               currentBingo.getId().toString().equals(plugin.getConfig().pinnedBingoId());
    }
}

package org.bingoscape;

import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;
import org.bingoscape.models.Bingo;
import org.bingoscape.models.EventData;
import org.bingoscape.models.Role;
import org.bingoscape.models.TeamMember;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.CompoundBorder;
import javax.swing.border.MatteBorder;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.List;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.Executors;
import javax.swing.DefaultListCellRenderer;
import java.awt.event.ActionListener;
import java.text.SimpleDateFormat;
import java.util.Date;
import javax.swing.DefaultComboBoxModel;

public class BingoScapePanel extends PluginPanel {
    // Constants
    private static final int BORDER_SPACING = 10;
    private static final int COMPONENT_SPACING = 10;
    private static final String NO_EVENTS_TEXT = "No active events found";
    private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("MMM dd, yyyy");

    // Components
    private final JPanel mainContentPanel = new JPanel(); // Main container for all content
    private final JPanel eventsPanel = new JPanel();
    private final JPanel bingoPanel = new JPanel();
    private final JPanel eventDetailsPanel = new JPanel();
    private final JComboBox<EventData> eventSelector = new JComboBox<>();
    private final JComboBox<Bingo> bingoSelector = new JComboBox<>();
    private final JButton showBingoBoardButton;
    private final JButton reloadEventsButton; // New reload events button
    private final JLabel loadingLabel; // New loading label
    private final Timer fadeTimer; // Timer for smooth transitions

    // Reference to plugin and other resources
    private final BingoScapePlugin plugin;
    private final ScheduledExecutorService executor;
    private BingoBoardWindow bingoBoardWindow;

    public BingoScapePanel(BingoScapePlugin plugin) {
        super();
        this.plugin = plugin;
        this.executor = Executors.newSingleThreadScheduledExecutor();

        // Initialize fade timer
        this.fadeTimer = new Timer(50, null);
        fadeTimer.setRepeats(true);

        // Panel setup
        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(BORDER_SPACING, BORDER_SPACING, BORDER_SPACING, BORDER_SPACING));
        setBackground(ColorScheme.DARK_GRAY_COLOR);

        // Main content panel setup
        mainContentPanel.setLayout(new BoxLayout(mainContentPanel, BoxLayout.Y_AXIS));
        mainContentPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        add(mainContentPanel, BorderLayout.NORTH);

        // Create show bingo board button
        showBingoBoardButton = createShowBingoBoardButton();

        // Create reload events button and loading label
        reloadEventsButton = createReloadEventsButton();
        loadingLabel = createLoadingLabel();

        // Setup all panels
        setupEventsPanel();
        setupBingoPanel();
        setupEventDetailsPanel();

        // Add panels to main content panel
        mainContentPanel.add(eventsPanel);
        mainContentPanel.add(bingoPanel);
        mainContentPanel.add(eventDetailsPanel);

        // Initially hide the bingo panel
        bingoPanel.setVisible(false);
    }

    private JLabel createLoadingLabel() {
        JLabel label = new JLabel("Loading events...");
        label.setForeground(Color.LIGHT_GRAY);
        label.setVisible(false);
        return label;
    }

    private void setupEventsPanel() {
        eventsPanel.setLayout(new BorderLayout(0, COMPONENT_SPACING));
        eventsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        eventsPanel.setBorder(new EmptyBorder(0, 0, COMPONENT_SPACING, 0));
        eventsPanel.setAlignmentX(Component.LEFT_ALIGNMENT);

        // Create a header panel that contains the label and reload button
        JPanel headerPanel = new JPanel(new BorderLayout(COMPONENT_SPACING, 0));
        headerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JLabel eventsLabel = new JLabel("Select an Event:");
        eventsLabel.setForeground(Color.WHITE);
        
        // Create a button panel to hold both the reload button and loading label
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, 5, 0));
        buttonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        buttonPanel.add(loadingLabel);
        buttonPanel.add(reloadEventsButton);
        
        headerPanel.add(buttonPanel, BorderLayout.EAST);
        headerPanel.add(eventsLabel, BorderLayout.WEST);

        eventsPanel.add(headerPanel, BorderLayout.NORTH);

        configureEventSelector();
        eventsPanel.add(eventSelector, BorderLayout.CENTER);
    }

    private void setupEventDetailsPanel() {
        eventDetailsPanel.setLayout(new BoxLayout(eventDetailsPanel, BoxLayout.Y_AXIS));
        eventDetailsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        eventDetailsPanel.setBorder(new EmptyBorder(0, 0, 0, 0));
    }

    private void configureEventSelector() {
        eventSelector.setRenderer(createEventRenderer());
        eventSelector.addActionListener(createEventSelectionListener());
        eventSelector.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        eventSelector.setForeground(Color.WHITE);
        eventSelector.setFocusable(false);
    }

    private DefaultListCellRenderer createEventRenderer() {
        return new DefaultListCellRenderer() {
            @Override
            public Component getListCellRendererComponent(JList<?> list, Object value, int index,
                                                          boolean isSelected, boolean cellHasFocus) {
                super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
                if (value instanceof EventData) {
                    setText(((EventData) value).getTitle());
                }

                if (isSelected) {
                    setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
                } else {
                    setBackground(ColorScheme.DARKER_GRAY_COLOR);
                }
                setForeground(Color.WHITE);

                return this;
            }
        };
    }

    private ActionListener createEventSelectionListener() {
        return e -> {
            EventData selectedEvent = (EventData) eventSelector.getSelectedItem();
            if (selectedEvent != null) {
                executor.submit(() -> plugin.setEventDetails(selectedEvent));
            }
        };
    }

    private JButton createReloadEventsButton() {
        JButton button = new JButton();
        button.setIcon(new ImageIcon(getClass().getResource("/refresh_icon.png")));
        button.setToolTipText("Reload Events");
        button.setPreferredSize(new Dimension(24, 24));
        button.setMaximumSize(new Dimension(24, 24));
        button.setMinimumSize(new Dimension(24, 24));
        button.setFocusPainted(false);
        button.setContentAreaFilled(false);
        button.setForeground(Color.WHITE);

        // Add hover effect
        button.addMouseListener(new java.awt.event.MouseAdapter() {
            @Override
            public void mouseEntered(java.awt.event.MouseEvent evt) {
                if (button.isEnabled()) {
                    button.setContentAreaFilled(true);
                    button.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
                }
            }

            @Override
            public void mouseExited(java.awt.event.MouseEvent evt) {
                button.setContentAreaFilled(false);
            }
        });

        // Connect to plugin's fetchActiveEvents method with smooth transition
        button.addActionListener(e -> {
            reloadEventsButton.setEnabled(false);
            loadingLabel.setVisible(true);
            eventSelector.setEnabled(false);
            
            // Store current selections
            EventData selectedEvent = (EventData) eventSelector.getSelectedItem();
            Bingo selectedBingo = (Bingo) bingoSelector.getSelectedItem();
            String selectedEventId = selectedEvent != null ? selectedEvent.getId().toString() : null;
            String selectedBingoId = selectedBingo != null ? selectedBingo.getId().toString() : null;
            
            // Start fade out animation
            for (ActionListener listener : fadeTimer.getActionListeners()) {
                fadeTimer.removeActionListener(listener);
            }
            fadeTimer.addActionListener(evt -> {
                float alpha = eventSelector.getForeground().getAlpha() - 10;
                if (alpha <= 0) {
                    fadeTimer.stop();
                    executor.submit(() -> {
                        plugin.fetchActiveEvents();
                        SwingUtilities.invokeLater(() -> {
                            reloadEventsButton.setEnabled(true);
                            loadingLabel.setVisible(false);
                            eventSelector.setEnabled(true);
                            
                            // Restore selections if they still exist
                            if (selectedEventId != null) {
                                for (int i = 0; i < eventSelector.getItemCount(); i++) {
                                    EventData event = eventSelector.getItemAt(i);
                                    if (event.getId().toString().equals(selectedEventId)) {
                                        eventSelector.setSelectedIndex(i);
                                        break;
                                    }
                                }
                            }
                            
                            if (selectedBingoId != null) {
                                for (int i = 0; i < bingoSelector.getItemCount(); i++) {
                                    Bingo bingo = bingoSelector.getItemAt(i);
                                    if (bingo.getId().toString().equals(selectedBingoId)) {
                                        bingoSelector.setSelectedIndex(i);
                                        break;
                                    }
                                }
                            }
                            
                            // Start fade in animation
                            for (ActionListener listener : fadeTimer.getActionListeners()) {
                                fadeTimer.removeActionListener(listener);
                            }
                            fadeTimer.addActionListener(evt2 -> {
                                float fadeInAlpha = eventSelector.getForeground().getAlpha() + 10;
                                if (fadeInAlpha >= 255) {
                                    fadeTimer.stop();
                                }
                                eventSelector.setForeground(new Color(255, 255, 255, (int)fadeInAlpha));
                            });
                            fadeTimer.start();
                        });
                    });
                } else {
                    eventSelector.setForeground(new Color(255, 255, 255, (int)alpha));
                }
            });
            fadeTimer.start();
        });

        return button;
    }

    private void setupBingoPanel() {
        bingoPanel.setLayout(new BorderLayout(0, COMPONENT_SPACING));
        bingoPanel.setBorder(new EmptyBorder(COMPONENT_SPACING, 0, COMPONENT_SPACING, 0));
        bingoPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        bingoPanel.setAlignmentX(Component.LEFT_ALIGNMENT);

        JPanel bingoHeaderPanel = new JPanel(new BorderLayout());
        bingoHeaderPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JLabel bingoLabel = new JLabel("Select a Bingo Board:");
        bingoLabel.setForeground(Color.WHITE);
        bingoHeaderPanel.add(bingoLabel, BorderLayout.NORTH);

        configureBingoSelector();
        bingoHeaderPanel.add(bingoSelector, BorderLayout.CENTER);
        bingoPanel.add(bingoHeaderPanel, BorderLayout.NORTH);

        // Add button to show bingo board in a popup
        JPanel buttonPanel = new JPanel(new BorderLayout());
        buttonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        buttonPanel.setBorder(new EmptyBorder(COMPONENT_SPACING, 0, 0, 0));
        buttonPanel.add(showBingoBoardButton, BorderLayout.CENTER);
        bingoPanel.add(buttonPanel, BorderLayout.CENTER);
    }

    private void configureBingoSelector() {
        bingoSelector.setRenderer(createBingoRenderer());
        bingoSelector.addActionListener(createBingoSelectionListener());
        bingoSelector.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        bingoSelector.setForeground(Color.WHITE);
        bingoSelector.setFocusable(false);
    }

    private DefaultListCellRenderer createBingoRenderer() {
        return new DefaultListCellRenderer() {
            @Override
            public Component getListCellRendererComponent(JList<?> list, Object value, int index,
                                                          boolean isSelected, boolean cellHasFocus) {
                super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
                if (value instanceof Bingo) {
                    Bingo bingo = (Bingo) value;
                    StringBuilder text = new StringBuilder(bingo.getTitle());

                    // Show if the bingo is locked or visible
                    if (bingo.isLocked()) {
                        text.append(" [Locked]");
                    }

                    // Show pin icon if this bingo is pinned
                    if (bingo.getId().toString().equals(plugin.getConfig().pinnedBingoId())) {
                        text.append(" 📌");
                    }

                    setText(text.toString());
                }

                if (isSelected) {
                    setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
                } else {
                    setBackground(ColorScheme.DARKER_GRAY_COLOR);
                }
                setForeground(Color.WHITE);

                return this;
            }
        };
    }

    private ActionListener createBingoSelectionListener() {
        return e -> {
            Bingo selectedBingo = (Bingo) bingoSelector.getSelectedItem();
            if (selectedBingo != null) {
                // Update the current bingo in the plugin first to ensure the overlay gets updated
                plugin.selectBingo(selectedBingo);
            }
        };
    }

    private JButton createShowBingoBoardButton() {
        JButton button = new JButton("Show Bingo Board");
        button.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        button.setForeground(Color.WHITE);
        button.setFocusPainted(false);
        button.addActionListener(e -> {
            Bingo selectedBingo = (Bingo) bingoSelector.getSelectedItem();
            if (selectedBingo != null) {
                showBingoBoardWindow(selectedBingo);
            }
        });
        return button;
    }

    private void showBingoBoardWindow(Bingo bingo) {
        SwingUtilities.invokeLater(() -> {
            if (bingoBoardWindow != null) {
                bingoBoardWindow.dispose();
            }

            bingoBoardWindow = new BingoBoardWindow(plugin, bingo);
            bingoBoardWindow.setVisible(true);
        });
    }

    public void updateEventsList(List<EventData> events) {
        SwingUtilities.invokeLater(() -> {
            // Store current selections
            EventData selectedEvent = (EventData) eventSelector.getSelectedItem();
            String selectedEventId = selectedEvent != null ? selectedEvent.getId().toString() : null;
            String pinnedBingoId = plugin.getConfig().pinnedBingoId();

            // Update the event selector model
            DefaultComboBoxModel<EventData> model = new DefaultComboBoxModel<>();
            for (EventData event : events) {
                model.addElement(event);
                // If this event contains the pinned bingo, select it
                if (!pinnedBingoId.isEmpty() && event.getBingos().stream()
                        .anyMatch(b -> b.getId().toString().equals(pinnedBingoId))) {
                    selectedEventId = event.getId().toString();
                }
            }
            eventSelector.setModel(model);

            // Restore selection if possible
            if (selectedEventId != null) {
                for (int i = 0; i < model.getSize(); i++) {
                    EventData event = model.getElementAt(i);
                    if (event.getId().toString().equals(selectedEventId)) {
                        eventSelector.setSelectedIndex(i);
                        break;
                    }
                }
            } else if (model.getSize() > 0) {
                eventSelector.setSelectedIndex(0);
            }

            // Update UI state
            eventSelector.setEnabled(model.getSize() > 0);
            reloadEventsButton.setEnabled(true);
            loadingLabel.setVisible(false);
        });
    }

    // Method to update event details with enhanced information
    public void updateEventDetails(EventData eventData) {
        if (eventData == null) {
            eventDetailsPanel.setVisible(false);
            bingoPanel.setVisible(false);
            return;
        }

        // Update bingo selector
        bingoSelector.removeAllItems();
        String pinnedBingoId = plugin.getConfig().pinnedBingoId();
        Bingo pinnedBingo = null;

        // First pass to find pinned bingo if it exists
        if (!pinnedBingoId.isEmpty()) {
            for (Bingo bingo : eventData.getBingos()) {
                if (bingo.getId().toString().equals(pinnedBingoId)) {
                    pinnedBingo = bingo;
                    break;
                }
            }
        }

        // Add all bingos, with pinned one first if it exists
        if (pinnedBingo != null) {
            bingoSelector.addItem(pinnedBingo);
        }
        for (Bingo bingo : eventData.getBingos()) {
            if (pinnedBingo == null || !bingo.getId().equals(pinnedBingo.getId())) {
                bingoSelector.addItem(bingo);
            }
        }

        // Select pinned bingo if it exists, otherwise first bingo
        if (pinnedBingo != null) {
            bingoSelector.setSelectedItem(pinnedBingo);
        } else if (bingoSelector.getItemCount() > 0) {
            bingoSelector.setSelectedIndex(0);
        }

        // Rest of the event details update...
        // ... existing code ...

        SwingUtilities.invokeLater(() -> {
            // Clear previous event details
            eventDetailsPanel.removeAll();
            bingoSelector.removeAllItems();

            // Build event details panel
            if (eventData != null) {
                // Title panel
                JPanel titlePanel = new JPanel();
                titlePanel.setLayout(new BoxLayout(titlePanel, BoxLayout.Y_AXIS));
                titlePanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
                titlePanel.setAlignmentX(Component.LEFT_ALIGNMENT);
                titlePanel.setBorder(new EmptyBorder(5, 5, 5, 5));
                
                JLabel titleLabel = new JLabel(eventData.getTitle());
                titleLabel.setFont(FontManager.getRunescapeBoldFont());
                titleLabel.setForeground(new Color(255, 215, 0)); // Gold color
                titleLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
                titlePanel.add(titleLabel);
                
                // Add status indicator
                JLabel statusLabel = new JLabel(eventData.isLocked() ? "🔒 Locked" : "✅ Active");
                statusLabel.setForeground(eventData.isLocked() ? Color.LIGHT_GRAY : new Color(34, 197, 94));
                statusLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
                titlePanel.add(statusLabel);
                
                eventDetailsPanel.add(titlePanel);

                // Event description
                if (eventData.getDescription() != null && !eventData.getDescription().isEmpty()) {
                    JTextArea descriptionArea = new JTextArea(eventData.getDescription());
                    descriptionArea.setWrapStyleWord(true);
                    descriptionArea.setLineWrap(true);
                    descriptionArea.setEditable(false);
                    descriptionArea.setForeground(Color.WHITE);
                    descriptionArea.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                    descriptionArea.setBorder(new CompoundBorder(
                        new MatteBorder(1, 0, 1, 0, ColorScheme.MEDIUM_GRAY_COLOR),
                        new EmptyBorder(5, 5, 5, 5)
                    ));
                    descriptionArea.setAlignmentX(Component.LEFT_ALIGNMENT);
                    eventDetailsPanel.add(descriptionArea);
                }

                // Info section
                JPanel infoSection = new JPanel();
                infoSection.setLayout(new BoxLayout(infoSection, BoxLayout.Y_AXIS));
                infoSection.setBackground(ColorScheme.DARK_GRAY_COLOR);
                infoSection.setBorder(new EmptyBorder(5, 5, 5, 5));
                infoSection.setAlignmentX(Component.LEFT_ALIGNMENT);

                // Event dates
                if (eventData.getStartDate() != null && eventData.getEndDate() != null) {
                    addInfoLabel(infoSection, "📅 Event dates: " +
                            DATE_FORMAT.format(eventData.getStartDate()) + " - " +
                            DATE_FORMAT.format(eventData.getEndDate()));
                }

                // Prize pool
                if (eventData.getBasePrizePool() > 0) {
                    addInfoLabel(infoSection, "💰 Prize pool: " + formatGpAmount(eventData.getBasePrizePool()));
                    if (eventData.getMinimumBuyIn() > 0) {
                        addInfoLabel(infoSection, "💎 Minimum buy-in: " + formatGpAmount(eventData.getMinimumBuyIn()));
                    }
                }

                // Role
                if (eventData.getRole() != null) {
                    addInfoLabel(infoSection, "👤 Role: " + formatRole(eventData.getRole()));
                }

                // Clan
                if (eventData.getClan() != null) {
                    addInfoLabel(infoSection, "🏰 Clan: " + eventData.getClan().getName());
                }

                // Team
                if (eventData.getUserTeam() != null) {
                    addInfoLabel(infoSection, "👥 Team: " + eventData.getUserTeam().getName());
                    if (eventData.getUserTeam().getMembers() != null && !eventData.getUserTeam().getMembers().isEmpty()) {
                        JPanel membersPanel = new JPanel();
                        membersPanel.setLayout(new BoxLayout(membersPanel, BoxLayout.Y_AXIS));
                        membersPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
                        membersPanel.setBorder(new EmptyBorder(0, 15, 0, 0));
                        membersPanel.setAlignmentX(Component.LEFT_ALIGNMENT);

                        // First add the leader
                        for (TeamMember member : eventData.getUserTeam().getMembers()) {
                            if (member.isLeader()) {
                                String memberText = "• " + member.getRunescapeName() + " 👑";
                                JLabel memberLabel = new JLabel(memberText);
                                memberLabel.setForeground(new Color(255, 215, 0));
                                memberLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
                                membersPanel.add(memberLabel);
                                membersPanel.add(Box.createVerticalStrut(2));
                                break;
                            }
                        }

                        // Then add other members
                        for (TeamMember member : eventData.getUserTeam().getMembers()) {
                            if (!member.isLeader()) {
                                String memberText = "• " + member.getRunescapeName();
                                JLabel memberLabel = new JLabel(memberText);
                                memberLabel.setForeground(Color.WHITE);
                                memberLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
                                membersPanel.add(memberLabel);
                                membersPanel.add(Box.createVerticalStrut(2));
                            }
                        }
                        infoSection.add(membersPanel);
                    }
                }

                // Available boards
                if (eventData.getBingos() != null) {
                    addInfoLabel(infoSection, "🎯 Available boards: " + eventData.getBingos().size());
                }

                eventDetailsPanel.add(infoSection);
                eventDetailsPanel.setVisible(true);

                // Populate bingo selector
                if (eventData.getBingos() != null && !eventData.getBingos().isEmpty()) {
                    for (Bingo bingo : eventData.getBingos()) {
                        bingoSelector.addItem(bingo);
                    }
                    bingoPanel.setVisible(true);
                } else {
                    bingoPanel.setVisible(false);
                }
            } else {
                eventDetailsPanel.setVisible(false);
                bingoPanel.setVisible(false);
            }

            revalidate();
            repaint();
        });
    }

    private void addInfoLabel(JPanel container, String text) {
        JLabel label = new JLabel(text);
        label.setForeground(Color.WHITE);
        label.setAlignmentX(Component.LEFT_ALIGNMENT);
        container.add(label);
        container.add(Box.createVerticalStrut(4));
    }

    // Helper method to format GP amounts nicely
    private String formatGpAmount(long amount) {
        if (amount >= 1_000_000_000) {
            return (amount / 1_000_000_000) + "B GP";
        } else if (amount >= 1_000_000) {
            return (amount / 1_000_000) + "M GP";
        } else if (amount >= 1_000) {
            return (amount / 1_000) + "K GP";
        } else {
            return amount + " GP";
        }
    }

    private String formatRole(Role role) {
        if (role == null) return "Participant";

        switch (role) {
            case ADMIN:
                return "Admin";
            case MANAGEMENT:
                return "Manager";
            case PARTICIPANT:
                return "Participant";
            default:
                return role.toString();
        }
    }

    public void displayBingoBoard(Bingo bingo) {
        // Update the bingo board window if it's open
        if (bingoBoardWindow != null && bingoBoardWindow.isVisible()) {
            // Close and reopen with fresh data to ensure a full refresh
            SwingUtilities.invokeLater(() -> {
                bingoBoardWindow.dispose();
                bingoBoardWindow = new BingoBoardWindow(plugin, bingo);
                bingoBoardWindow.setVisible(true);
            });
        }
    }
}

package org.bingoscape;

import com.google.inject.Provides;

import javax.inject.Inject;

import lombok.extern.slf4j.Slf4j;
import lombok.Getter;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.ClientUI;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.task.Schedule;
import net.runelite.client.ui.DrawManager;
import net.runelite.client.ui.overlay.OverlayManager;
import org.bingoscape.services.BingoScapeApiService;

import java.time.temporal.ChronoUnit;
import java.awt.image.BufferedImage;
import java.awt.Image;
import java.awt.Graphics;
import java.io.IOException;
import java.io.ByteArrayOutputStream;
import javax.imageio.ImageIO;
import javax.swing.*;

import okhttp3.*;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import org.bingoscape.models.*;

import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.UUID;
import java.util.concurrent.ScheduledExecutorService;
import java.util.function.Consumer;
import java.util.Date;

@Slf4j
@PluginDescriptor(
        name = "BingoScape",
        description = "Participate in bingo events with your clan or friends",
        tags = {"bingo", "clan", "event", "minigame"}
)
public class BingoScapePlugin extends Plugin {
    // Constants
    private static final String ICON_PATH = "/sidepanel_icon.png";
    private static final String PNG_FORMAT = "png";
    private static final MediaType MEDIA_TYPE_PNG = MediaType.parse("image/png");

    // Injected components
    @Inject
    private Client client;

    @Inject
    private ClientUI clientUI;

    @Inject
    private ClientThread clientThread;

    @Getter
    @Inject
    private BingoScapeConfig config;

    @Inject
    private ClientToolbar clientToolbar;

    @Inject
    private OkHttpClient httpClient;

    @Inject
    private DrawManager drawManager;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private BingoCodephraseOverlay codephraseOverlay;

    @Inject
    private ScheduledExecutorService executor;

    @Inject
    private Gson gson;

    @Inject
    private BingoScapeApiService apiService;

    // Plugin components
    private NavigationButton navButton;
    private BingoScapePanel panel;

    // State
    private final List<EventData> activeEvents = new CopyOnWriteArrayList<>();
    @Getter
    private EventData currentEvent;
    @Getter
    private Bingo currentBingo;
    private boolean isLoggedIn;

    @Override
    protected void startUp() {
        // Load the icon for the side panel
        final BufferedImage icon = ImageUtil.loadImageResource(getClass(), ICON_PATH);

        // Create and initialize the side panel
        panel = new BingoScapePanel(this);
        navButton = NavigationButton.builder()
                .tooltip("BingoScape")
                .icon(icon)
                .priority(5)
                .panel(panel)
                .build();

        clientToolbar.addNavigation(navButton);
        overlayManager.add(codephraseOverlay);

        // Load all events and handle pinned bingo
        if (hasApiKey()) {
            String pinnedBingoId = config.pinnedBingoId();
            apiService.fetchEvents(
                events -> {
                    activeEvents.clear();
                    activeEvents.addAll(events);
                    sortEvents(activeEvents);
                    panel.updateEventsList(activeEvents);

                    // If there's a pinned bingo, find and select its event
                    if (!pinnedBingoId.isEmpty()) {
                        UUID pinnedId = UUID.fromString(pinnedBingoId);
                        for (EventData event : events) {
                            if (event.getBingos().stream().anyMatch(b -> b.getId().equals(pinnedId))) {
                                // Found the event with pinned bingo, select it and load the bingo
                                setEventDetails(event);
                                apiService.refreshBingoBoard(
                                    pinnedId,
                                    bingo -> selectBingo(bingo),
                                    error -> log.error("Failed to load pinned bingo: " + error)
                                );
                                break;
                            }
                        }
                    }
                },
                error -> log.error("Failed to load events: " + error)
            );
        }
    }

    @Override
    protected void shutDown() {
        clientToolbar.removeNavigation(navButton);
        overlayManager.remove(codephraseOverlay);
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        // Only update login state if transitioning to LOGGED_IN from a non-logged-in state
        if (gameStateChanged.getGameState() == GameState.LOGGED_IN && !isLoggedIn) {
            isLoggedIn = true;
            if (hasApiKey()) {
                fetchActiveEvents();
            }
        } else if (gameStateChanged.getGameState() == GameState.LOGIN_SCREEN) {
            isLoggedIn = false;
        }
    }

    public void fetchActiveEvents() {
        if (!hasApiKey()) {
            return;
        }

        apiService.fetchActiveEvents(
            events -> {
                activeEvents.clear();
                activeEvents.addAll(events);
                sortEvents(activeEvents);
                panel.updateEventsList(activeEvents);
            },
            error -> showErrorMessage(error)
        );
    }

    private void sortEvents(List<EventData> events) {
        Date now = new Date();
        
        // Filter events based on configuration
        events.removeIf(event -> {
            // Filter past events
            if (config.hidePastEvents() && event.getEndDate().before(now)) {
                return true;
            }
            
            // Filter locked events
            if (config.hideLockedEvents() && event.isLocked()) {
                return true;
            }
            
            // Filter upcoming events
            if (config.hideUpcomingEvents() && event.getStartDate().after(now)) {
                return true;
            }
            
            return false;
        });

        // Sort remaining events
        events.sort((e1, e2) -> {
            // First sort by locked status (active events first)
            if (e1.isLocked() != e2.isLocked()) {
                return e1.isLocked() ? 1 : -1;
            }

            // Then sort by start date (upcoming events first)
            boolean e1Upcoming = e1.getStartDate().after(now);
            boolean e2Upcoming = e2.getStartDate().after(now);
            
            if (e1Upcoming != e2Upcoming) {
                return e1Upcoming ? -1 : 1;
            }

            // For events with the same status, sort by start date (most recent first)
            int dateComparison = e2.getStartDate().compareTo(e1.getStartDate());
            if (dateComparison != 0) {
                return dateComparison;
            }

            // Finally, sort alphabetically by title
            return e1.getTitle().compareToIgnoreCase(e2.getTitle());
        });
    }

    public void setEventDetails(EventData eventData) {
        currentEvent = eventData;
        panel.updateEventDetails(eventData);

        if (eventData.getBingos() != null && !eventData.getBingos().isEmpty()) {
            // Default to first bingo or current one if it exists
            selectBingo(currentBingo == null ?
                    eventData.getBingos().get(0) : currentBingo);
        }
    }

    public void selectBingo(Bingo bingo) {
        currentBingo = bingo;
        panel.displayBingoBoard(currentBingo);
    }

    public void takeScreenshot(UUID tileId, Consumer<byte[]> callback) {
        drawManager.requestNextFrameListener(image -> {
            executor.submit(() -> {
                try {
                    BufferedImage screenshot = convertToBufferedImage(image);
                    byte[] screenshotBytes = convertImageToBytes(screenshot);
                    callback.accept(screenshotBytes);
                } catch (IOException e) {
                    log.error("Failed to process screenshot", e);
                    showErrorMessage("Failed to take screenshot for submission.");
                    callback.accept(null);
                }
            });
        });
    }

    private BufferedImage convertToBufferedImage(Image image) {
        BufferedImage screenshot = new BufferedImage(
                image.getWidth(null),
                image.getHeight(null),
                BufferedImage.TYPE_INT_ARGB
        );
        Graphics graphics = screenshot.getGraphics();
        graphics.drawImage(image, 0, 0, null);
        graphics.dispose();
        return screenshot;
    }

    private byte[] convertImageToBytes(BufferedImage image) throws IOException {
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        ImageIO.write(image, PNG_FORMAT, outputStream);
        return outputStream.toByteArray();
    }

    public void submitTileCompletionWithScreenshot(UUID tileId, byte[] screenshotBytes) {
        apiService.submitTileCompletion(
            tileId,
            screenshotBytes,
            updatedBingo -> {
                showSuccessMessage("Tile submission sent to BingoScape!");
                updateCurrentBingoAndPanel(updatedBingo);
            },
            error -> {
                showErrorMessage(error);
                if (error.contains("423")) { // 423 Locked
                    refreshBingoBoard();
                }
            }
        );
    }

    public void refreshBingoBoard() {
        if (currentBingo == null || !hasApiKey()) {
            return;
        }

        apiService.refreshBingoBoard(
            currentBingo.getId(),
            this::updateCurrentBingoAndPanel,
            error -> log.error(error)
        );
    }

    private void updateCurrentBingoAndPanel(Bingo updatedBingo) {
        for(EventData e : activeEvents) {
            e.getBingos().replaceAll(b -> b.getId().equals(updatedBingo.getId()) ? updatedBingo : b);
        }
        currentBingo = updatedBingo;
        panel.displayBingoBoard(updatedBingo);
    }

    private void showErrorMessage(String message) {
        clientThread.invokeLater(() ->
                client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "BingoScape: " + message, null));
    }

    private void showSuccessMessage(String message) {
        clientThread.invokeLater(() ->
                client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "BingoScape: " + message, null));
    }

    private boolean hasApiKey() {
        return config.apiKey() != null && !config.apiKey().isEmpty();
    }

    public void pinBingo(UUID bingoId) {
        config.pinnedBingoId(bingoId.toString());
    }

    public void unpinBingo() {
        config.pinnedBingoId("");
    }

    @Provides
    BingoScapeConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(BingoScapeConfig.class);
    }
}

package org.bingoscape;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("bingoscape")
public interface BingoScapeConfig extends Config
{
    @ConfigItem(
            keyName = "apiKey",
            name = "API Key",
            description = "Your BingoScape API key",
            secret = true
    )
    default String apiKey()
    {
        return "";
    }

    @ConfigItem(
            keyName = "apiKey",
            name = "API Key",
            description = "Your BingoScape API key"
    )
    void apiKey(String key);

    @ConfigItem(
            keyName = "apiBaseUrl",
            name = "API Base URL",
            description = "The base URL for the BingoScape API"
    )
    default String apiBaseUrl()
    {
        return "https://next.bingoscape.org";
    }

    @ConfigItem(
            keyName = "showCodephraseOverlay",
            name = "Show Bingo Codephrase Overlay",
            description = "Display the codephrase for the currently selected bingo as an overlay"
    )
    default boolean showCodephraseOverlay()
    {
        return true;
    }

    @ConfigItem(
            keyName = "hidePastEvents",
            name = "Hide Past Events",
            description = "Hide events that have already ended"
    )
    default boolean hidePastEvents()
    {
        return false;
    }

    @ConfigItem(
            keyName = "hideLockedEvents",
            name = "Hide Locked Events",
            description = "Hide events that are locked"
    )
    default boolean hideLockedEvents()
    {
        return false;
    }

    @ConfigItem(
            keyName = "hideUpcomingEvents",
            name = "Hide Upcoming Events",
            description = "Hide events that haven't started yet"
    )
    default boolean hideUpcomingEvents()
    {
        return false;
    }

    @ConfigItem(
            keyName = "pinnedBingoId",
            name = "Pinned Bingo ID",
            description = "The ID of the pinned bingo to display on startup",
            hidden = true
    )
    default String pinnedBingoId()
    {
        return "";
    }

    @ConfigItem(
            keyName = "pinnedBingoId",
            name = "Pinned Bingo ID",
            description = "The ID of the pinned bingo to display on startup"
    )
    void pinnedBingoId(String id);
}

package org.bingoscape.services;

import com.google.gson.Gson;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;
import org.bingoscape.BingoScapeConfig;
import org.bingoscape.models.*;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;
import java.util.function.Consumer;

@Slf4j
@Singleton
public class BingoScapeApiService {
    private static final MediaType MEDIA_TYPE_PNG = MediaType.parse("image/png");

    private final OkHttpClient httpClient;
    private final Gson gson;
    private final BingoScapeConfig config;

    @Inject
    public BingoScapeApiService(OkHttpClient httpClient, Gson gson, BingoScapeConfig config) {
        this.httpClient = httpClient;
        this.gson = gson;
        this.config = config;
    }

    public void fetchActiveEvents(Consumer<List<EventData>> onSuccess, Consumer<String> onError) {
        if (!hasApiKey()) {
            onError.accept("No API key configured");
            return;
        }

        String apiUrl = config.apiBaseUrl() + "/api/runelite/events";
        Request request = new Request.Builder()
                .url(apiUrl)
                .header("Authorization", "Bearer " + config.apiKey())
                .build();

        httpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.error("Failed to fetch events", e);
                onError.accept("Failed to fetch events: " + e.getMessage());
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (!response.isSuccessful() || responseBody == null) {
                        String error = "Unsuccessful response: " + response;
                        log.error(error);
                        onError.accept(error);
                        return;
                    }

                    String jsonData = responseBody.string();
                    EventData[] eventsResponse = gson.fromJson(jsonData, EventData[].class);
                    onSuccess.accept(Arrays.asList(eventsResponse));
                }
            }
        });
    }

    public void refreshBingoBoard(UUID bingoId, Consumer<Bingo> onSuccess, Consumer<String> onError) {
        if (!hasApiKey()) {
            onError.accept("No API key configured");
            return;
        }

        String apiUrl = config.apiBaseUrl() + "/api/runelite/bingos/" + bingoId;
        Request request = new Request.Builder()
                .url(apiUrl)
                .header("Authorization", "Bearer " + config.apiKey())
                .build();

        httpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.error("Failed to refresh bingo board", e);
                onError.accept("Failed to refresh bingo board: " + e.getMessage());
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (!response.isSuccessful() || responseBody == null) {
                        String error = "Unsuccessful response when refreshing bingo: " + response;
                        log.error(error);
                        onError.accept(error);
                        return;
                    }

                    String jsonData = responseBody.string();
                    Bingo updatedBingo = gson.fromJson(jsonData, Bingo.class);
                    onSuccess.accept(updatedBingo);
                }
            }
        });
    }

    public void submitTileCompletion(UUID tileId, byte[] screenshotBytes, Consumer<Bingo> onSuccess, Consumer<String> onError) {
        if (!hasApiKey()) {
            onError.accept("No API key configured");
            return;
        }

        String apiUrl = config.apiBaseUrl() + "/api/runelite/tiles/" + tileId + "/submissions";
        RequestBody requestBody = new MultipartBody.Builder()
                .setType(MultipartBody.FORM)
                .addFormDataPart("image", "screenshot.png", RequestBody.create(MEDIA_TYPE_PNG, screenshotBytes))
                .build();

        Request request = new Request.Builder()
                .url(apiUrl)
                .header("Authorization", "Bearer " + config.apiKey())
                .post(requestBody)
                .build();

        httpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.error("Failed to submit tile completion", e);
                onError.accept("Failed to submit tile completion: " + e.getMessage());
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String stringBody = responseBody.string();
                    if (!response.isSuccessful()) {
                        ErrorResponse errorResponse = gson.fromJson(stringBody, ErrorResponse.class);
                        String error = errorResponse.getError();
                        log.error("Unsuccessful submission response: {}", error);
                        onError.accept(error);
                        return;
                    }

                    Bingo updatedBingo = gson.fromJson(stringBody, Bingo.class);
                    onSuccess.accept(updatedBingo);
                }
            }
        });
    }

    public void fetchEvents(Consumer<List<EventData>> onSuccess, Consumer<String> onError) {
        if (!hasApiKey()) {
            onError.accept("No API key configured");
            return;
        }

        String apiUrl = config.apiBaseUrl() + "/api/runelite/events";
        Request request = new Request.Builder()
                .url(apiUrl)
                .header("Authorization", "Bearer " + config.apiKey())
                .build();

        httpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.error("Failed to fetch events", e);
                onError.accept("Failed to fetch events: " + e.getMessage());
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (!response.isSuccessful() || responseBody == null) {
                        String error = "Unsuccessful response when fetching events: " + response;
                        log.error(error);
                        onError.accept(error);
                        return;
                    }

                    String jsonData = responseBody.string();
                    EventData[] events = gson.fromJson(jsonData, EventData[].class);
                    onSuccess.accept(Arrays.asList(events));
                }
            }
        });
    }

    private boolean hasApiKey() {
        return config.apiKey() != null && !config.apiKey().isEmpty();
    }
} 
package org.bingoscape;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class BingoScapePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(BingoScapePlugin.class);
		RuneLite.main(args);
	}
}

