package com.projectileoverride;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup(ProjectileOverrideConfig.CONFIG_GROUP)
public interface ProjectileOverrideConfig extends Config
{
	public static final String CONFIG_GROUP = "projectileoverride";

    @ConfigItem(
        keyName = "akkha",
        name = "Akkha",
        description = "Projectile override for Akkha"
    )
    default BossProjectiles Akkha() {
        return BossProjectiles.DEFAULT;
    }

	@ConfigItem(
		keyName = "cerberus",
		name = "Cerberus",
		description = "Projectile override for Cerberus"
	)
	default BossProjectiles Cerberus() {
		return BossProjectiles.DEFAULT;
	}

	@ConfigItem(
		keyName = "dks",
		name = "DKS",
		description = "Projectile override for the Dagganoth Kings"
	)
	default BossProjectiles DagganothKings() {
		return BossProjectiles.DEFAULT;
	}

	@ConfigItem(
		keyName = "dom",
		name = "Doom",
		description = "Projectile override for Doom of Mokhaiotl"
	)
	default BossProjectiles DoomOfMokhaiotl()
	{
		return BossProjectiles.DEFAULT;
	}

	@ConfigItem(
		keyName = "dom-rocks",
		name = "Doom rocks",
		description = "Projectile override for Doom of Mokhaiotl rocks"
	)
	default BossProjectiles DoomOfMokhaiotlRocks()
	{
		return BossProjectiles.DEFAULT;
	}

	@ConfigItem(
		keyName = "hueycoatl",
		name = "Hueycoatl",
		description = "Projectile override for Hueycoatl"
	)
	default BossProjectiles Hueycoatl() {
		return BossProjectiles.DEFAULT;
	}

	@ConfigItem(
		keyName = "hunllefnormal",
		name = "Hunllef",
		description = "Projectile override for normal Hunllef"
	)
	default BossProjectiles HunllefNormal() {
		return BossProjectiles.DEFAULT;
	}

	@ConfigItem(
		keyName = "hunllefcorrupted",
		name = "Hunllef (Corrupted)",
		description = "Projectile override for corrupted Hunllef"
	)
	default BossProjectiles HunllefCorrupted() {
		return BossProjectiles.DEFAULT;
	}

    @ConfigItem(
            keyName = "hdyra",
            name = "Hydra",
            description = "Projectile override for Alchemical Hydra and smaller hydras"
    )
    default BossProjectiles AlchemicalHydra() {
        return BossProjectiles.DEFAULT;
    }

	@ConfigItem(
		keyName = "inferno",
		name = "Inferno",
		description = "Projectile override for the blobs in the Inferno"
	)
	default BossProjectiles Inferno() {
		return BossProjectiles.DEFAULT;
	}

    @ConfigItem(
        keyName = "kalphite-queen",
        name = "Kalphite Queen",
        description = "Projectile override for the Kalphite Queen"
    )
    default BossProjectiles KalphiteQueen() {
        return BossProjectiles.DEFAULT;
    }

    @ConfigItem(
        keyName = "kree-arra",
        name = "Kree Arra",
        description = "Projectile override for Kree Arra"
    )
    default BossProjectiles KreeArra() {
        return BossProjectiles.DEFAULT;
    }

	@ConfigItem(
		keyName = "leviathan",
		name = "Leviathan",
		description = "Projectile override for Leviathan"
	)
	default BossProjectiles Leviathan() {
		return BossProjectiles.DEFAULT;
	}

    @ConfigItem(
        keyName = "manticore",
        name = "Manticore",
        description = "Projectile override for Manticores within the Fortis Colosseum"
    )
    default BossProjectiles Manticore() {
        return BossProjectiles.DEFAULT;
    }

	@ConfigItem(
		keyName = "olm",
		name = "Olm",
		description = "Projectile override for Olm in the Chambers of Xeric"
	)
	default BossProjectiles Olm() {
		return BossProjectiles.DEFAULT;
	}

	@ConfigItem(
		keyName = "scurrius",
		name = "Scurrius",
		description = "Projectile override for Scurrius"
	)
	default BossProjectiles Scurrius() {
		return BossProjectiles.DEFAULT;
	}

	@ConfigItem(
		keyName = "sotetseg",
		name = "Sotetseg",
		description = "Projectile override for Sotetseg in the Theatre of Blood"
	)
	default BossProjectiles Sotetseg() {
		return BossProjectiles.DEFAULT;
	}

	@ConfigItem(
        keyName = "tormented-demon",
        name = "Tormented Demon",
        description = "Projectile override for Tormented Demons within the Ancient Guthixian Temple"
    )
    default BossProjectiles TormentedDemon() {
        return BossProjectiles.DEFAULT;
    }

	@ConfigItem(
		keyName = "vardorvis",
		name = "Vardorvis",
		description = "Projectile override for Vardorvis"
	)
	default BossProjectiles Vardorvis() {
		return BossProjectiles.DEFAULT;
	}

	@ConfigItem(
		keyName = "wardens",
		name = "Wardens",
		description = "Projectile override for Wardens in the Tombs of Amascut"
	)
	default BossProjectiles Wardens() {
		return BossProjectiles.DEFAULT;
	}

    @ConfigItem(
        keyName = "wardens-divine",
        name = "Wardens divine",
        description = "Projectile override for the divine projectiles of the Wardens in the Tombs of Amascut"
    )
    default BossProjectiles WardensDivine() {
        return BossProjectiles.DEFAULT;
    }

	@ConfigItem(
		keyName = "whisperer",
		name = "Whisperer",
		description = "Projectile override for the Whisperer"
	)
	default BossProjectiles Whisperer() {
		return BossProjectiles.DEFAULT;
	}

	@ConfigItem(
		keyName = "zebak",
		name = "Zebak",
		description = "Projectile override for regular Zebak attacks"
	)
	default BossProjectiles Zebak()
	{
		return BossProjectiles.DEFAULT;
	}

	@ConfigItem(
		keyName = "zebak-rocks",
		name = "Zebak rocks",
		description = "Projectile override for the rocks and jugs attacks of Zebak"
	)
	default BossProjectiles ZebakRocks()
	{
		return BossProjectiles.DEFAULT;
	}

	@ConfigItem(
		keyName = "zulrah",
		name = "Zulrah",
		description = "Projectile override for Zulrah"
	)
	default BossProjectiles Zulrah() {
		return BossProjectiles.DEFAULT;
	}
}

package com.projectileoverride;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ThreadLocalRandom;

public final class ProjectileIds
{
	public static final int NONE = -1;
    public static final int RANDOM = -2;

    public static final int STYLE_MAGIC = 0;
    public static final int STYLE_RANGED = 1;
    public static final int STYLE_MELEE = 2;

    private static final List<Integer>[] ALL_PROJECTILES_PER_STYLE = buildPoolPerStyle();

	private ProjectileIds() {}

    public static int getRandomProjectile(int style) {
        var pool = ALL_PROJECTILES_PER_STYLE[style];
        return pool.get(ThreadLocalRandom.current().nextInt(pool.size()));
    }

    @SuppressWarnings("unchecked")
    private static List<Integer>[] buildPoolPerStyle() {
        List<Integer>[] pools = new List[]{new ArrayList<>(), new ArrayList<>(), new ArrayList<>()};
        BossProjectiles[] allProjectiles = BossProjectiles.values();

        for (var projectile : allProjectiles) {
            addToPool(pools[STYLE_MAGIC], projectile.getMagicOverride());
            addToPool(pools[STYLE_RANGED], projectile.getRangedOverride());
            addToPool(pools[STYLE_MELEE], projectile.getMeleeOverride());
        }

        return pools;
    }

    private static void addToPool(List<Integer> pool, int override) {
        if (override != ProjectileIds.NONE && override != ProjectileIds.RANDOM) {
            pool.add(override);
        }
    }
}

package com.projectileoverride;

import lombok.Getter;
import net.runelite.api.Projectile;

public class ProjectileOverride
{
    @Getter
    private final int sourceProjectileId;
	private final int overrideProjectileId;
    private final int style;
	private final int[] requiredRegion;

    public ProjectileOverride(int sourceProjectileId, int overrideProjectileId, int style, int[] requiredRegion) {
		this.sourceProjectileId = sourceProjectileId;
        this.overrideProjectileId = overrideProjectileId;
        this.style = style;
		this.requiredRegion = requiredRegion;
	}

    public int getOverrideProjectileId() {
        if (overrideProjectileId == ProjectileIds.RANDOM) {
            return ProjectileIds.getRandomProjectile(style);
        }

        return overrideProjectileId;
    }

	public boolean canOverride(Projectile projectile) {
		if (requiredRegion == null || requiredRegion.length == 0) {
			return true;
		}

		for (int regionId: requiredRegion)
		{
			if (projectile.getSourcePoint().getRegionID() == regionId) {
				return true;
			}
		}

		return false;
	}
}

package com.projectileoverride;

import java.util.ArrayList;
import java.util.List;

public enum BossProjectiles
{
	DEFAULT("Default"),
    RANDOM("Random", ProjectileIds.RANDOM, ProjectileIds.RANDOM, ProjectileIds.RANDOM),
    AKKHA("Akkha", 2253, 2255),
	CERBERUS("Cerberus", 1242, 1245),
	DAGGANOTH_KINGS("DKS", 162, 475, new int[] { 11588, 11589 }),
	DOOM_OF_MOKHAIOTL("Doom", 3379, 3380, 3378),
	DOOM_OF_MOKHAIOTL_ROCKS("Doom rocks", 3385, 3384),
	HUEYCOATL("Hueycoatl", 2975, 2972, 2969),
	HUNLLEF_NORMAL("Hunllef", 1707, 1711),
	HUNLLEF_CORRUPTED("Hunllef (c)", 1708, 1712),
    HYDRA("Hydra", 1662, 1663),
	INFERNO("Inferno", 1380, 1378),
    KALPHITE_QUEEN("Kalphite Queen", 280, 288),
    KREE_ARRA("Kree Arra", 1200, 1199),
    LEVIATHAN("Leviathan", 2489, 2487, 2488),
    MANTICORE("Manticore", 2681, 2683, 2685),
	OLM("Olm", 1341, 1343, 1345),
	SCURRIUS("Scurrius", 2640, 2642),
	SOTETSEG("Sotetseg", 1606, 1607),
	TORMENTED_DEMON("Tormented Demon", 2853, 2857),
	VARDORVIS("Vardorvis", 2520, 2521),
	WARDENS("Wardens", 2224, 2241),
    WARDENS_DIVINE("Wardens divine", 2208, 2206, 2204),
	WHISPERER("Whisperer", 2445, 2444),
	ZEBAK("Zebak", 2181, 2187),
	ZEBAK_ROCKS("Zebak rocks", new int[] { 2176, 2177 }, new int[] { 2178, 2179 }),
	ZULRAH("Zulrah", 1046, 1044);

	private final String name;
    private final int[] magicProjectiles;
    private final int[] rangedProjectiles;
    private final int[] meleeProjectiles;
    private final int[] requiredRegions;

    private BossProjectiles(String name) {
        this(name, new int[0], new int[0]);
    }

    private BossProjectiles(String name, int magicProjectile, int rangedProjectile) {
        this(name, new int[] { magicProjectile }, new int[] { rangedProjectile });
    }

    private BossProjectiles(String name, int magicProjectile, int rangedProjectile, int meleeProjectile) {
        this(name, new int[] { magicProjectile }, new int[] { rangedProjectile }, new int[] { meleeProjectile });
    }

    private BossProjectiles(String name, int magicProjectile, int rangedProjectile, int[] requiredRegions) {
        this(name, new int[] { magicProjectile }, new int[] { rangedProjectile }, new int[0], requiredRegions);
    }

	private BossProjectiles(String name, int[] magicProjectiles, int[] rangedProjectiles) {
		this(name, magicProjectiles, rangedProjectiles, new int[0]);
	}

    private BossProjectiles(String name, int[] magicProjectiles, int[] rangedProjectiles, int[] meleeProjectiles) {
        this(name, magicProjectiles, rangedProjectiles, meleeProjectiles, new int[0]);
    }

    private BossProjectiles(String name, int[] magicProjectiles, int[] rangedProjectiles, int[] meleeProjectiles, int[] requiredRegions) {
        this.name = name;
        this.magicProjectiles = magicProjectiles;
        this.rangedProjectiles = rangedProjectiles;
        this.meleeProjectiles = meleeProjectiles;
        this.requiredRegions = requiredRegions;
    }

    public int getMagicOverride() {
        return this.magicProjectiles.length > 0 ? this.magicProjectiles[0] : ProjectileIds.NONE;
    }

    public int getRangedOverride() {
        return this.rangedProjectiles.length > 0 ? this.rangedProjectiles[0] : ProjectileIds.NONE;
    }

    public int getMeleeOverride() {
        return this.meleeProjectiles.length > 0 ? this.meleeProjectiles[0] : ProjectileIds.NONE;
    }

    public List<ProjectileOverride> createOverride(BossProjectiles override) {
        var result = new ArrayList<ProjectileOverride>();

        result.addAll(createOverride(this.magicProjectiles, override.getMagicOverride(), ProjectileIds.STYLE_MAGIC));
        result.addAll(createOverride(this.rangedProjectiles, override.getRangedOverride(), ProjectileIds.STYLE_RANGED));
        result.addAll(createOverride(this.meleeProjectiles, override.getMeleeOverride(), ProjectileIds.STYLE_MELEE));

        return result;
    }

	@Override
	public String toString()
	{
		return name;
	}

    private List<ProjectileOverride> createOverride(int[] sourceProjectiles, int override, int style) {
        var result = new ArrayList<ProjectileOverride>();

        if (override != ProjectileIds.NONE) {
            for (int source : sourceProjectiles) {
                if(source != ProjectileIds.NONE && source != override) {
                    result.add(new ProjectileOverride(source, override, style, this.requiredRegions));
                }
            }
        }

        return result;
    }
}

package com.projectileoverride;

import com.google.inject.Provides;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Projectile;
import net.runelite.api.events.ProjectileMoved;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;

@Slf4j
@PluginDescriptor(
	name = "Projectile Override"
)
public class ProjectileOverridePlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private ProjectileOverrideConfig config;

	private final HashMap<Integer, ProjectileOverride> overrideMap = new HashMap<>();

	private final HashSet<Projectile> overriddenProjectiles = new HashSet<>();

	@Provides
	ProjectileOverrideConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(ProjectileOverrideConfig.class);
	}

	@Override
	protected void startUp() throws Exception {
		createOverrideMap();
	}

	@Override
	protected void shutDown() throws Exception {
		overriddenProjectiles.clear();
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event) {
		if(!ProjectileOverrideConfig.CONFIG_GROUP.equals(event.getGroup())) {
			return;
		}

		createOverrideMap();
	}

	@Subscribe
	public void onProjectileMoved(ProjectileMoved projectileMoved)
	{
		Projectile projectile = projectileMoved.getProjectile();

		// Prevent overriding projectiles that have already been overridden. This can happen if a player has configured
		// Boss A -> Boss B, Boss B -> Boss C. This will result in Boss A -> Boss C (instead of Boss B). Let's not talk
		// about what happens when you configure Boss A -> Boss B and Boss B -> Boss A.
		if (overriddenProjectiles.contains(projectile)) {
			return;
		}

		ProjectileOverride override = overrideMap.getOrDefault(projectile.getId(), null);

		if (override != null && override.canOverride(projectile)) {
			overriddenProjectiles.removeIf(p -> p.getRemainingCycles() < 0);
			overriddenProjectiles.add(replaceProjectile(projectile, override));
		}
	}

	private Projectile replaceProjectile(Projectile projectile, ProjectileOverride override)
	{
		Projectile overrideProjectile = client.createProjectile(
			override.getOverrideProjectileId(),
			projectile.getSourcePoint(),
			projectile.getStartHeight(), projectile.getSourceActor(),
			projectile.getTargetPoint(),
			projectile.getEndHeight(), projectile.getTargetActor(),
			projectile.getStartCycle(), projectile.getEndCycle(),
			projectile.getSlope(), projectile.getStartPos());

		client.getProjectiles().addLast(overrideProjectile);

		log.debug("Overriding projectile {} with {}", projectile.getId(), override.getOverrideProjectileId());

		// Hide the original projectile.
		projectile.setEndCycle(0);

		return overrideProjectile;
	}

	private void createOverrideMap() {
		overrideMap.clear();
        hydrateOverrideMap(BossProjectiles.AKKHA, config.Akkha());
		hydrateOverrideMap(BossProjectiles.CERBERUS, config.Cerberus());
		hydrateOverrideMap(BossProjectiles.DAGGANOTH_KINGS, config.DagganothKings());
		hydrateOverrideMap(BossProjectiles.DOOM_OF_MOKHAIOTL, config.DoomOfMokhaiotl());
		hydrateOverrideMap(BossProjectiles.DOOM_OF_MOKHAIOTL_ROCKS, config.DoomOfMokhaiotlRocks());
		hydrateOverrideMap(BossProjectiles.HUEYCOATL, config.Hueycoatl());
		hydrateOverrideMap(BossProjectiles.HUNLLEF_NORMAL, config.HunllefNormal());
		hydrateOverrideMap(BossProjectiles.HUNLLEF_CORRUPTED, config.HunllefCorrupted());
        hydrateOverrideMap(BossProjectiles.HYDRA, config.AlchemicalHydra());
		hydrateOverrideMap(BossProjectiles.INFERNO, config.Inferno());
        hydrateOverrideMap(BossProjectiles.KALPHITE_QUEEN, config.KalphiteQueen());
        hydrateOverrideMap(BossProjectiles.KREE_ARRA, config.KreeArra());
		hydrateOverrideMap(BossProjectiles.LEVIATHAN, config.Leviathan());
        hydrateOverrideMap(BossProjectiles.MANTICORE, config.Manticore());
		hydrateOverrideMap(BossProjectiles.OLM, config.Olm());
		hydrateOverrideMap(BossProjectiles.SCURRIUS, config.Scurrius());
		hydrateOverrideMap(BossProjectiles.SOTETSEG, config.Sotetseg());
		hydrateOverrideMap(BossProjectiles.TORMENTED_DEMON, config.TormentedDemon());
		hydrateOverrideMap(BossProjectiles.VARDORVIS, config.Vardorvis());
		hydrateOverrideMap(BossProjectiles.WARDENS, config.Wardens());
        hydrateOverrideMap(BossProjectiles.WARDENS_DIVINE, config.WardensDivine());
		hydrateOverrideMap(BossProjectiles.WHISPERER, config.Whisperer());
		hydrateOverrideMap(BossProjectiles.ZEBAK, config.Zebak());
		hydrateOverrideMap(BossProjectiles.ZEBAK_ROCKS, config.ZebakRocks());
		hydrateOverrideMap(BossProjectiles.ZULRAH, config.Zulrah());
	}

	private void hydrateOverrideMap(BossProjectiles source, BossProjectiles override) {
        var overrides = source.createOverride(override);

        for(var createdOverride: overrides) {
            overrideMap.put(createdOverride.getSourceProjectileId(), createdOverride);
        }
	}
}

package com.projectileoverride;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ProjectileOverridePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(ProjectileOverridePlugin.class);
		RuneLite.main(args);
	}
}
