package com.animationtransmog;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.lang.reflect.Field;
import java.util.Map;

public class AnimationTransmogPluginTest
{
	private static void setEnv(String key, String value)
	{
		try
		{
			Map<String, String> env = System.getenv();
			Class<?> cl = env.getClass();
			Field field = cl.getDeclaredField("m");
			field.setAccessible(true);
			Map<String, String> writableEnv = (Map<String, String>) field.get(env);
			writableEnv.put(key, value);
		}
		catch (Exception e)
		{
			throw new IllegalStateException("Failed to set environment variable", e);
		}
	}

	private static void bootstrapJagexAccount() throws Exception
	{
		ProcessBuilder pb = new ProcessBuilder(
			"/bin/sh", "-c",
			"ps Eww -o command $(ps -A | grep -m 1 RuneLite | awk '{print $1}') | " +
			"sed 's/ JX/\\nJX/g' | " +
			"grep JX_"
		);
		pb.redirectErrorStream(true);
		Process process = pb.start();
		BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
		String line;
		while ((line = reader.readLine()) != null)
		{
			String[] newVar = line.split("=");
			if (newVar.length == 2) setEnv(newVar[0], newVar[1]);
		}
		reader.close();
		process.waitFor();

		pb = new ProcessBuilder(
			"/bin/sh", "-c",
			"kill $(ps -A | grep -m 1 RuneLite | awk '{print $1}')"
		);
		pb.inheritIO();
		pb.redirectErrorStream(true);
		process = pb.start();
		process.waitFor();
	}

	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(AnimationTransmogPlugin.class);
		bootstrapJagexAccount();
		RuneLite.main(args);
	}
}
package com.animationtransmog;

import com.animationtransmog.config.AnimationTransmogConfig;
import com.animationtransmog.config.AnimationTransmogConfigManager;
import com.animationtransmog.effect.AnimationPlayerController;
import com.animationtransmog.effect.DatabaseManager;
import com.animationtransmog.effect.PlayerController;
import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import okhttp3.OkHttpClient;

import java.util.HashMap;

@Slf4j
@PluginDescriptor(
	name = "Animation Transmog"
)
public class AnimationTransmogPlugin extends Plugin
{
	@Inject
	private AnimationTransmogConfig config;

	@Inject
	private Client client;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private OkHttpClient okHttpClient;

	boolean configChanged = true;

	DatabaseManager dbManager;

	AnimationTransmogConfigManager configManager;
	AnimationTypes animationTypes;
	AnimationPlayerController animationPlayerController;

	HashMap<String, PlayerController> players;

	String messageFromAnotherThread = "";

	@Override
	protected void startUp()
	{
		log.info("Animation Transmog started!");
		dbManager = new DatabaseManager(okHttpClient);
		configManager = new AnimationTransmogConfigManager(config);
		animationTypes = new AnimationTypes();
		animationPlayerController = new AnimationPlayerController(configManager);
		players = new HashMap<>();
	}

	@Override
	protected void shutDown()
	{
		log.info("Animation Transmog stopped!");
	}

	@Subscribe
	public void onPlayerSpawned(PlayerSpawned e)
	{
		String playerName = e.getActor().getName();
		addNewPlayer(playerName, e.getActor());
	}

	void addNewPlayer(String playerName, Actor actor)
	{
		if (playerName == null) return;

		// If not using the DB, or player is the local player, get settings locally
		if (!configManager.getCanUseDB() || actor == client.getLocalPlayer())
		{
			// If not using the DB, ignore other players
			if (actor != client.getLocalPlayer()) return;

			HashMap<String, String> settings = getLocalSettings();
			PlayerController playerController = new PlayerController(animationTypes, actor, client, settings);
			players.put(playerName, playerController);

			return;
		}

		// Only add new player if they are not already in the players Hash Map
		if (!players.containsKey(playerName))
		{
			dbManager.getSettings(playerName, (settings) -> {
				// If they are not in the DB, just add a null under their name to be ignored
				if (settings.size() == 0)
				{
					players.put(playerName, null);
					return;
				}
				PlayerController playerController = new PlayerController(animationTypes, actor, client, settings);
				players.put(playerName, playerController);
			});
		}
		else
		{
			// If player already exists in Hash Map, and has a valid PlayerController, simply update player actor
			PlayerController playerController = players.get(playerName);
			if (playerController == null) return;

			playerController.effectController.setPlayer(actor, client);
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		if (gameStateChanged.getGameState() == GameState.LOGGED_IN)
		{
			// Setup animationPlayerController
			animationPlayerController.setPlayer(client.getLocalPlayer(), client);
		}
	}

	@Subscribe
	public void onClientTick(ClientTick event)
	{
		if (!messageFromAnotherThread.equals(""))
		{
			client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", messageFromAnotherThread, null);
			messageFromAnotherThread = "";
		}

		Player local = client.getLocalPlayer();
		if (local == null || local.getName() == null) return;

		// Update animation player
		animationPlayerController.update();

		// Update timers on player's effect controllers
		for (PlayerController player : players.values())
		{
			if (player != null) player.effectController.updateTimer();
		}

		// When the local plugin configs are changed, update the DB if applicable, and then update the playerController
		if (configChanged)
		{
			configChanged = false;
			HashMap<String, String> settings = updateSettings();

			if (!players.containsKey(local.getName())) addNewPlayer(local.getName(), client.getLocalPlayer());
			else players.get(local.getName()).setSettings(settings);
		}
	}

	@Subscribe
	public void onBeforeRender(BeforeRender event)
	{
		// For each player stored, run the player's effectController
		for (PlayerController player : players.values())
		{
			if (player != null) player.effectController.onBeforeRender();
		}
	}

	@Subscribe
	public void onAnimationChanged(AnimationChanged e)
	{
		Actor playerActor = e.getActor();
		PlayerController playerController = players.get(playerActor.getName());
		if (playerController == null) return;

		// Update effect
		playerController.effectController.onChange();
	}

	@Provides
	AnimationTransmogConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(AnimationTransmogConfig.class);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged e)
	{
		// When a setting in the plugin is changed, request a DB update
		if (e.getGroup().equals("animationtransmog"))
		{
			configChanged = true;
		}
	}

	HashMap<String, String> updateSettings()
	{
		// Get local settings
		HashMap<String, String> newSettings = getLocalSettings();

		// Set player's settings in the DB, if opted into the DB
		String playerName = client.getLocalPlayer().getName();
		if (configManager.getCanUseDB()) dbManager.setSettings(playerName, newSettings);

		return newSettings;
	}

	HashMap<String, String> getLocalSettings()
	{
		// Generate HashMap of settings for a given player
		HashMap<String, String> settings = new HashMap<>();
		Object[] keys = configManager.configGetters.keySet().toArray();
		for (int i = 0; i < configManager.configGetters.size(); i++)
		{
			String key = (String)keys[i];
			String value = configManager.configGetters.get(key).get();
			settings.put(key, value);
		}
		return settings;
	}
}

package com.animationtransmog;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;

public class AnimationTypes
{
    HashMap<Integer, String> animationTypes;
    HashMap<String, List<Integer>> animationTypeSpotAnimIds;

    public AnimationTypes()
    {
        // Defining animation types
        animationTypes = new HashMap<>();
        animationTypeSpotAnimIds = new HashMap<>();


        animationTypes.put(4069, "Teleport");
        animationTypes.put(714, "Teleport");
        animationTypeSpotAnimIds.put("Teleport", Arrays.asList(111, 678));

        animationTypes.put(2295, "AshScatter");

        animationTypes.put(879, "Woodcut");
        animationTypes.put(877, "Woodcut");
        animationTypes.put(875, "Woodcut");
        animationTypes.put(873, "Woodcut");
        animationTypes.put(871, "Woodcut");
        animationTypes.put(869, "Woodcut");
        animationTypes.put(867, "Woodcut");
        animationTypes.put(2846, "Woodcut");
        animationTypes.put(2117, "Woodcut");
        animationTypes.put(7264, "Woodcut");
        animationTypes.put(8324, "Woodcut");

        animationTypes.put(625, "Mine");
        animationTypes.put(626, "Mine");
        animationTypes.put(627, "Mine");
        animationTypes.put(3873, "Mine");
        animationTypes.put(629, "Mine");
        animationTypes.put(628, "Mine");
        animationTypes.put(624, "Mine");
        animationTypes.put(8313, "Mine");
        animationTypes.put(7139, "Mine");
        animationTypes.put(642, "Mine");
        animationTypes.put(8346, "Mine");
        animationTypes.put(8887, "Mine");
        animationTypes.put(4482, "Mine");
        animationTypes.put(7283, "Mine");
        animationTypes.put(8347, "Mine");
        animationTypes.put(8787, "Mine");
        animationTypes.put(8788, "Mine");
        animationTypes.put(8789, "Mine");
        animationTypes.put(6753, "Mine");
        animationTypes.put(6754, "Mine");
        animationTypes.put(6755, "Mine");
        animationTypes.put(3866, "Mine");
        animationTypes.put(6757, "Mine");
        animationTypes.put(6756, "Mine");
        animationTypes.put(6752, "Mine");
        animationTypes.put(8312, "Mine");
        animationTypes.put(6758, "Mine");
        animationTypes.put(335, "Mine");
        animationTypes.put(8344, "Mine");
        animationTypes.put(8886, "Mine");
        animationTypes.put(4481, "Mine");
        animationTypes.put(7282, "Mine");
        animationTypes.put(8345, "Mine");
        animationTypes.put(8786, "Mine");

        animationTypes.put(710, "StandardSpell");
        animationTypes.put(711, "StandardSpell");
        animationTypes.put(717, "StandardSpell");
        animationTypes.put(718, "StandardSpell");
        animationTypes.put(727, "StandardSpell");
        animationTypes.put(728, "StandardSpell");
        animationTypes.put(729, "StandardSpell");
        animationTypes.put(1161, "StandardSpell");
        animationTypes.put(1162, "StandardSpell");
        animationTypes.put(1165, "StandardSpell");
        animationTypes.put(1167, "StandardSpell");
        animationTypes.put(1169, "StandardSpell");
        animationTypes.put(7855, "StandardSpell");

        animationTypes.put(713, "Alch");
        animationTypes.put(712, "Alch");
        animationTypeSpotAnimIds.put("Alch", Arrays.asList(112, 113));

        animationTypes.put(836, "Death");
    }

    // Gets the type of animation given its ID number
    public String getAnimationType(int animationID)
    {
        return animationTypes.get(animationID);
    }
    public List<Integer> getAnimationTypeSpotAnimIds(String animationType)
    {
        List<Integer> spotAnimIds = new ArrayList<>();
        if (animationTypeSpotAnimIds.containsKey(animationType))
            spotAnimIds = animationTypeSpotAnimIds.get(animationType);

        return spotAnimIds;
    }
}
package com.animationtransmog.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum ActionAnimation
{
    DEFAULT("Default"),
    ARCANECHOP("Arcane Chop"),
    BRONZECHOP("Bronze Chop"),
    ARCANEMINE("Arcane Mine"),
    BLASTMINE("Blast Mine"),
    DIG("Dig"),
    HEADBANG("Headbang"),
    SMOOTHSCATTER("Smooth Scatter"),
    BRUTAL("Brutal");


    private final String option;

    @Override
    public String toString()
    {
        return option;
    }
}
package com.animationtransmog.config;

import net.runelite.client.config.*;

@ConfigGroup("animationtransmog")
public interface AnimationTransmogConfig extends Config
{
	@ConfigSection(
			name = "Very Important!",
			description = "",
			position = 0
	)
	String importantSection = "important";

	@ConfigSection(
			name = "Skilling",
			description = "All options for various skilling animations",
			position = 1
	)
	String skillingSection = "skilling";

	@ConfigSection(
			name = "Combat",
			description = "All options for various combat animations",
			position = 2
	)
	String combatSection = "combat";

	@ConfigSection(
			name = "Action",
			description = "All options for various action animations",
			position = 3
	)
	String actionSection = "action";

	@ConfigSection(
			name = "Animation Player",
			description = "Play a certain animation on demand",
			position = 5,
			closedByDefault = true
	)
	String playerSection = "player";


	@ConfigItem(
			keyName = "swapPluginDBUsage",
			name = "Enable Multiplayer",
			description = "This enables the plugin to show custom effects of other players around you, if they also have the plugin installed.",
			warning = "By enabling this you opt into sending your player name and IP Address to a Third-Party Database in order to store these plugin settings.",
			section = importantSection
	)
	default boolean swapPluginDBUsage()
	{
		return false;
	}

	@ConfigItem(
			keyName = "swapWoodcutAnimation",
			name = "Woodcutting Animation",
			description = "Change the effect used for Woodcutting.",
			section = skillingSection
	)
	default ActionAnimation swapWoodcutAnimation()
	{
		return ActionAnimation.DEFAULT;
	}

	@ConfigItem(
			keyName = "swapMineAnimation",
			name = "Mining Animation",
			description = "Change the effect used for Mining.",
			section = skillingSection
	)
	default ActionAnimation swapMineAnimation()
	{
		return ActionAnimation.DEFAULT;
	}

	@ConfigItem(
			keyName = "swapStandardSpellAnimation",
			name = "Standard Spell Animation",
			description = "Change the effect used for casting from the Standard Spellbook.",
			section = combatSection
	)
	default ActionAnimation swapStandardSpellAnimation()
	{
		return ActionAnimation.DEFAULT;
	}

	@ConfigItem(
			keyName = "swapTeleportAnimation",
			name = "Teleport Animation",
			description = "Change the effect used to teleport.",
			section = actionSection
	)
	default TeleportAnimation swapTeleportAnimation()
	{
		return TeleportAnimation.DEFAULT;
	}

	@ConfigItem(
			keyName = "swapAlchAnimation",
			name = "Alch Animation",
			description = "Change the effect used for high and low alchemy.",
			section = actionSection
	)
	default ActionAnimation swapAlchAnimation()
	{
		return ActionAnimation.DEFAULT;
	}

	@ConfigItem(
			keyName = "swapAshScatterAnimation",
			name = "Ash Scatter Animation",
			description = "Change the effect used to scatter ashes.",
			section = actionSection
	)
	default ActionAnimation swapAshScatterAnimation()
	{
		return ActionAnimation.DEFAULT;
	}

	@ConfigItem(
			keyName = "swapDeathAnimation",
			name = "Death Animation",
			description = "Change the effect used when you die.",
			section = actionSection
	)
	default DeathAnimation swapDeathAnimation()
	{
		return DeathAnimation.MELT;
	}


	@Range(min=-1)@ConfigItem(
			keyName = "selectedAnimation",
			name = "Selected Animation",
			description = "Animation to play, -1 to stop",
			position = 1,
			section = playerSection
	)
	default int selectedAnimation()
	{
		return -1;
	}

	@Range(min=-1)@ConfigItem(
			keyName = "selectedAnimationFrame",
			name = "Selected Animation Frame",
			description = "Animation frame to show, -1 to loop whole animation",
			position = 2,
			section = playerSection
	)
	default int selectedAnimationFrame()
	{
		return -1;
	}

	@Range(min=-1)@ConfigItem(
			keyName = "selectedGFX",
			name = "Selected GFX",
			description = "GFX to create, -1 to stop",
			position = 3,
			section = playerSection
	)
	default int selectedGFX()
	{
		return -1;
	}

	@Range(min=-1)@ConfigItem(
			keyName = "selectedGFXFrame",
			name = "Selected GFX Frame",
			description = "GFX frame to show, -1 to loop whole GFX",
			position = 4,
			section = playerSection
	)
	default int selectedGFXFrame()
	{
		return -1;
	}

	@Range(min=-10)@ConfigItem(
			keyName = "selectedGFXHeight",
			name = "Selected GFX Height",
			description = "GFX height compared to the character",
			position = 5,
			section = playerSection
	)
	default int selectedGFXHeight()
	{
		return 0;
	}
}

package com.animationtransmog.config;

import java.util.HashMap;
import java.util.function.Supplier;

public class AnimationTransmogConfigManager
{
    public Supplier<Boolean> canUseDB;
    public HashMap<String, Supplier<String>> configGetters;
    HashMap<String, Supplier<Integer>> animationPlayerConfigGetters;
    public AnimationTransmogConfigManager(AnimationTransmogConfig config)
    {
        canUseDB = config::swapPluginDBUsage;

        configGetters = new HashMap<>();
        configGetters.put("Woodcut", () -> config.swapWoodcutAnimation().getOption());
        configGetters.put("Mine", () -> config.swapMineAnimation().getOption());
        configGetters.put("Alch", () -> config.swapAlchAnimation().getOption());
        configGetters.put("StandardSpell", () -> config.swapStandardSpellAnimation().getOption());
        configGetters.put("Teleport", () -> config.swapTeleportAnimation().getOption());
        configGetters.put("AshScatter", () -> config.swapAshScatterAnimation().getOption());
        configGetters.put("Death", () -> config.swapDeathAnimation().getOption());

        animationPlayerConfigGetters = new HashMap<>();
        animationPlayerConfigGetters.put("SelectedAnimation", config::selectedAnimation);
        animationPlayerConfigGetters.put("SelectedAnimationFrame", config::selectedAnimationFrame);
        animationPlayerConfigGetters.put("SelectedGFX", config::selectedGFX);
        animationPlayerConfigGetters.put("SelectedGFXFrame", config::selectedGFXFrame);
        animationPlayerConfigGetters.put("SelectedGFXHeight", config::selectedGFXHeight);
    }

    public int getAnimationPlayerOption(String configType)
    {
        return animationPlayerConfigGetters.get(configType).get();
    }

    public boolean getCanUseDB() { return canUseDB.get(); }
}

package com.animationtransmog.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum DeathAnimation
{
    DEFAULT("Default"),
    PLANK("Plank"),
    BLAZE("Blaze"),
    MELT("Melt"),
    VAPORIZE("Vaporize");


    private final String option;

    @Override
    public String toString()
    {
        return option;
    }
}
package com.animationtransmog.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum TeleportAnimation
{
    DEFAULT("Default"),
    HAILZAMORAK("Hail Zamorak"),
    PRAISESARADOMIN("Praise Saradomin"),
    ANCIENTDISCIPLE("Ancient Disciple"),
    GLITCH("Glitch"),
    POMMELSMASH("Pommel Smash"),
    UHH("???"),
    DARKNESSASCENDS("Darkness Ascends"),
    HDVIBES("2010 Vibes"),
    JAD2OP("Jad 2 OP");

    private final String option;

    @Override
    public String toString()
    {
        return option;
    }
}

package com.animationtransmog.effect;
import com.animationtransmog.config.AnimationTransmogConfigManager;
import net.runelite.api.Actor;
import net.runelite.api.Client;

public class AnimationPlayerController
{
    AnimationTransmogConfigManager configManager;

    private int selectedAnimationId = -1;
    private int selectedGFXId = -1;

    public Actor actor = null;
    public Client client = null;

    public AnimationPlayerController(AnimationTransmogConfigManager configManager)
    {
        this.configManager = configManager;
    }

    public void setPlayer(Actor actor, Client client)
    {
        this.actor = actor;
        this.client = client;
    }

    public void update()
    {
        // Get selected animation configs
        int tempAnimationId = configManager.getAnimationPlayerOption("SelectedAnimation");
        int tempAnimationFrame = configManager.getAnimationPlayerOption("SelectedAnimationFrame");
        if (tempAnimationId == -1) tempAnimationFrame = 0;

        // Get selected GFX configs
        int tempGFXId = configManager.getAnimationPlayerOption("SelectedGFX");
        int tempGFXFrame = configManager.getAnimationPlayerOption("SelectedGFXFrame");
        int tempGFXHeight = configManager.getAnimationPlayerOption("SelectedGFXHeight");
        if (tempGFXId == -1) tempGFXFrame = 0;

        // Disable Animation Player Controller if not being used
        if (tempAnimationId == -1 && tempGFXId == -1) return;

        // Play selected animation
        int currentAnimation = actor.getAnimation();
        if(currentAnimation == -1 && actor.getAnimationFrame() != 0) actor.setAnimationFrame(0);
        if(tempAnimationFrame != -1) actor.setAnimationFrame(tempAnimationFrame);
        if(tempAnimationId != selectedAnimationId || currentAnimation == -1) actor.setAnimation(tempAnimationId);

        // Create selected GFX
        if (actor.hasSpotAnim(selectedGFXId))
        {
            if (tempGFXFrame != -1) actor.getSpotAnims().get(selectedGFXId).setFrame(tempGFXFrame);
        }
        else
        {
            actor.createSpotAnim(tempGFXId, tempGFXId, tempGFXHeight, 0);
        }

        // Keep track of selected animation and GFX
        selectedAnimationId = tempAnimationId;
        selectedGFXId = tempGFXId;
    }
}

package com.animationtransmog.effect;

import com.animationtransmog.AnimationTypes;
import net.runelite.api.Actor;
import net.runelite.api.Client;

import java.util.*;

public class PlayerController
{

    public EffectController effectController;
    HashMap<String, String> settings;

    // Constructor for non-local player
    public PlayerController(AnimationTypes animationTypes, Actor actor, Client client, HashMap<String, String> settings)
    {
        this.settings = settings;
        String playerName = actor.getName();
        if (playerName == null) return;
        effectController = new EffectController(animationTypes, settings);
        effectController.setPlayer(actor, client);
    }

    // Used for updating playerController and effectController settings when the DB updates
    public void setSettings(HashMap<String, String> settings)
    {
        this.settings = settings;
        effectController.setSettings(settings);
    }
}

package com.animationtransmog.effect;

public class Sound
{
    int soundId;
    int delayFrame;

    public Sound(int soundId, int delayFrame)
    {
        this.soundId = soundId;
        this.delayFrame = delayFrame;
    }
}
package com.animationtransmog.effect;

public class Effect
{
    Animation animation;
    GFX gfx;
    Sound sound;

    int length;

    public Effect(int animationId, int gfxId, int animationStartFrame, int animationEndFrame, int gfxStartFrame, int gfxEndFrame, int soundId, int soundDelayFrame, int length)
    {
        animation = new Animation(animationId, animationStartFrame, animationEndFrame);
        gfx = new GFX(gfxId, gfxStartFrame, gfxEndFrame);
        sound = new Sound(soundId, soundDelayFrame);
        this.length = length;
    }
}

package com.animationtransmog.effect;
/*
Given an actor, the Effect class can control the gfx, animation, and the timing
of the two to orchestrate and overall visual effect.
 */

import com.animationtransmog.AnimationTypes;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;

import java.util.*;
import java.util.stream.Collectors;

public class EffectController
{
    AnimationTypes animationTypes;
    HashMap<String, String> settings;

    List<Integer> regionBlacklist;
    List<String> regionBlacklistAnimations;

    HashMap<String, Effect> effects;

    private int customEffectLength = 0;
    private int customEffectLengthTimer = 0;
    private List<Integer> customEffectSpotAnimBlockList;

    private int customAnimationID = -1;
    private int customAnimationFrame = 0;
    private int customAnimationStartFrame = 0;
    private int customAnimationEndFrame = -1;

    private int customGfxID = -1;
    private int customGfxFrame = 0;
    private int customGfxStartFrame = 0;
    private int customGfxEndFrame = -1;

    private int customSoundID = -1;
    private int customSoundFrameDelay = 0;

    private WorldPoint effectLocation = null;

    private boolean isPlaying = false;
    private boolean isReadyToPlay = false;
    private String playingAnimationType = "";

    public Actor actor = null;
    public Client client = null;

    public EffectController(AnimationTypes animationTypes, HashMap<String, String> settings)
    {
        this.animationTypes = animationTypes;
        this.settings = settings;

        regionBlacklist = new ArrayList<>();
        regionBlacklistAnimations = new ArrayList<>();

        // ToA Regions
        regionBlacklist.add(14164);
        regionBlacklist.add(14676);
        regionBlacklist.add(15188);
        regionBlacklist.add(15444);
        regionBlacklist.add(15700);
        regionBlacklist.add(15955);
        regionBlacklist.add(13906);
        regionBlacklist.add(14162);
        regionBlacklist.add(14674);
        regionBlacklist.add(15186);
        regionBlacklist.add(15698);
        regionBlacklist.add(15954);
        regionBlacklist.add(15953);
        regionBlacklist.add(14160);
        regionBlacklist.add(14672);
        regionBlacklist.add(15184);
        regionBlacklist.add(15696);

        regionBlacklistAnimations.add("Teleport");

        // Defining Effects
        effects = new HashMap<>();

        // Teleport Effects
        effects.put("Hail Zamorak", new Effect(1500, 246, 0, 17, 0, 6, -1, 0, 150));
        effects.put("Praise Saradomin", new Effect(1500, 247, 0, 17, 0, 6, -1, 0, 150));
        effects.put("Ancient Disciple", new Effect(1500, 332, 0, 17, 0, 6, -1, 0,150));
        effects.put("Glitch", new Effect(7040, 482, 0, 12, 0, 48, -1, 0, 150));
        effects.put("Pommel Smash", new Effect(9131, 559,  0, 35,0, 10, -1, 0, 150));
        effects.put("???", new Effect(9286, -1, 0, 31, 0, 0, -1, 0, 150));
        effects.put("Darkness Ascends", new Effect(3945, 1577, 0, 12, 0, 57, -1, 0, 150));
        effects.put("2010 Vibes", new Effect(3945, 56, 0, 12, 0, 31, -1, 0, 150));
        effects.put("Jad 2 OP", new Effect(836, 451, 0, 9, 0, 20, -1, 0, 150));

        // Action Effects
        effects.put("Arcane Chop", new Effect(6298, 1063, 0, 159, 0, 40, -1, 0, -1));
        effects.put("Bronze Chop", new Effect(879, -1, 0, 5, 0, 0, -1, 0,  500));
        effects.put("Arcane Mine", new Effect(4411, 739, 0, 45, 15, 35, -1, 0, -1));

        // Credit goes to @Cyborger1 for name and effect IDs
        effects.put("Smooth Scatter", new Effect(7533, 1103, 0, 32, 0, 32, -1, 0, -1));
        effects.put("Brutal", new Effect(9544, 1103, 0, 13, 0, 32, -1, 0, -1));
        effects.put("Blast Mine", new Effect(2107, 659, 0, 16, 0, 16, 163, 0, -1));
        effects.put("Dig", new Effect(830, -1, 0, 7, 0, 0, -1, 0, -1));
        effects.put("Headbang", new Effect(2108, -1, 0, 48, 0, 0, -1, 0, -1));

        // Death Effects
        // Credit goes to @geheur for idea
        effects.put("Plank", new Effect(837, -1, 0, 4, 0, 0, -1, 0, 200));
        effects.put("Vaporize", new Effect(11035, -1, 0, 8, 0, 0, -1, 0, -1));
        effects.put("Blaze", new Effect(10873, 2610, 0, 42, 0, 38, -1, 0, -1));
        effects.put("Melt", new Effect(10873, 2711, 0, 42, 0, 74, -1, 0, -1));

        customEffectSpotAnimBlockList = new ArrayList<>();
    }

    public void setPlayer(Actor actor, Client client)
    {
        this.actor = actor;
        this.client = client;
    }

    public void setSettings(HashMap<String, String> settings)
    {
        this.settings = settings;
    }

    public void onChange() {
        // Get plugin config for current animation
        String currentAnimationType = animationTypes.getAnimationType(actor.getAnimation());
        List<Integer> currentAnimationTypeSpotAnimIDs = animationTypes.getAnimationTypeSpotAnimIds(currentAnimationType);
        if (currentAnimationType == null) return;

        // Check if player is in a region that causes issues for the plugin
        int[] regionIDs = client.getMapRegions();
        if (!Collections.disjoint(regionBlacklist, Arrays.stream(regionIDs).boxed().collect(Collectors.toList())))
        {
            if (regionBlacklistAnimations.contains(currentAnimationType)) return;
        }

        // If a custom effect is already playing, ignore any future changes
        if (isPlaying && playingAnimationType.equals(currentAnimationType)) return;

        // Set the new effect based on the client animation
        setEffect(currentAnimationType, currentAnimationTypeSpotAnimIDs);
    }

    void setEffect(String currentAnimationType, List<Integer> currentAnimationTypeSpotAnimIDs)
    {
        String configOption = settings.get(currentAnimationType);

        if (configOption.equals("Default")) return;

        // Get custom effect for config
        Effect effect = getEffect(configOption);
        if (effect == null) return;

        resetController();

        // Set information for new custom effect
        Animation newAnimation = effect.animation;
        GFX newGfx = effect.gfx;
        Sound newSound = effect.sound;
        customEffectLength = effect.length;
        if (currentAnimationTypeSpotAnimIDs.size() > 0)
        {
            customEffectSpotAnimBlockList = currentAnimationTypeSpotAnimIDs;
        }

        customAnimationID = newAnimation.animationId;
        customAnimationStartFrame = newAnimation.startFrame;
        customAnimationEndFrame = newAnimation.endFrame;

        if (newGfx.gfxId != -1)
        {
            customGfxID = newGfx.gfxId;
            customGfxStartFrame = newGfx.startFrame;
            customGfxEndFrame = newGfx.endFrame;
        }

        if (newSound.soundId != -1)
        {
            customSoundID = newSound.soundId;
            customSoundFrameDelay = newSound.delayFrame;
        }

        isReadyToPlay = true;
        playingAnimationType = currentAnimationType;
    }


    public void onBeforeRender()
    {
        // If there is a new effect to play, and one isn't already playing, start the new one
        if (!isPlaying)
        {
            if (isReadyToPlay)
            {
                playEffect();
            }
            return;
        }

        //  Once the effect timer has reached the effect length, or player has moved, reset everything
        if (
                (customEffectLength != -1 && customEffectLengthTimer >= customEffectLength) ||
                (customEffectLength == -1 && customAnimationFrame >= customAnimationEndFrame) ||
                !effectLocation.equals(actor.getWorldLocation())
        )
        {
            resetController();
            return;
        }

        // Track the state of the current animation and overwrite any client animations that try to play
        int currentAnimationID = actor.getAnimation();
        if (customAnimationID != -1)
        {
            if (currentAnimationID != customAnimationID)
            {
                actor.setAnimation(customAnimationID);
                actor.setAnimationFrame(customAnimationFrame);
            }
            if (currentAnimationID == customAnimationID)
            {
                if (customAnimationFrame > customAnimationEndFrame) actor.setAnimationFrame(customAnimationEndFrame);
                customAnimationFrame = actor.getAnimationFrame();
            }
        }

        // Track the state of the current GFX
        IterableHashTable<ActorSpotAnim> spotAnims = actor.getSpotAnims();
        if (actor.hasSpotAnim(customGfxID))
        {
            if (customGfxFrame > customGfxEndFrame) spotAnims.get(customGfxID).setFrame(customGfxEndFrame);
            customGfxFrame = spotAnims.get(customGfxID).getFrame();

        }

        // Block any spot anims that are in the block list
        if (spotAnims != null && customEffectSpotAnimBlockList.size() > 0)
        {
            for (ActorSpotAnim spotAnim : spotAnims)
            {
                if (customEffectSpotAnimBlockList.contains(spotAnim.getId()))
                {
                    actor.removeSpotAnim((int)spotAnim.getHash());
                }
            }
        }
    }

    public void updateTimer()
    {
        if (isPlaying) customEffectLengthTimer++;
    }

    void resetController()
    {
        customEffectLength = 0;
        customEffectLengthTimer = 0;
        if (customEffectSpotAnimBlockList.size() > 0)
        {
            customEffectSpotAnimBlockList = new ArrayList<>();
        }

        customAnimationFrame = 0;
        customAnimationStartFrame = 0;
        customAnimationEndFrame = -1;
        if (actor.getAnimation() == customAnimationID) actor.setAnimation(-1);
        customAnimationID = -1;

        customGfxFrame = 0;
        customGfxStartFrame = 0;
        customGfxEndFrame = -1;
        if (actor.hasSpotAnim(customGfxID)) actor.removeSpotAnim(customGfxID);
        customGfxID = -1;

        customSoundID = -1;
        customSoundFrameDelay = 0;

        effectLocation = null;

        isPlaying = false;
        isReadyToPlay = false;
        playingAnimationType = "";
    }

    void playEffect()
    {
        // Set the animation and GFX of the effect as the current ones on the player
        actor.setAnimation(customAnimationID);
        actor.setAnimationFrame(customAnimationStartFrame);

        if (customGfxID != -1)
        {
            actor.createSpotAnim(customGfxID, customGfxID, 0, 0);
            actor.getSpotAnims().get(customGfxID).setFrame(customGfxStartFrame);
        }

        if (customSoundID != -1)
        {
            int sceneX = actor.getLocalLocation().getSceneX();
            int sceneY = actor.getLocalLocation().getSceneY();
            client.playSoundEffect(customSoundID, sceneX, sceneY, 1, customSoundFrameDelay);
        }

        effectLocation = actor.getWorldLocation();

        isPlaying = true;
        isReadyToPlay = false;
    }


    // Gets an Effect given the name of the effect
    Effect getEffect(String effectName)
    {
        return effects.get(effectName);
    }
}

package com.animationtransmog.effect;

public class GFX
{
    int gfxId;
    int startFrame;
    int endFrame;

    public GFX(int gfxId, int startFrame, int endFrame)
    {
        this.gfxId = gfxId;
        this.startFrame = startFrame;
        this.endFrame = endFrame;
    }
}

package com.animationtransmog.effect;

public class Animation
{
    int animationId;
    int startFrame;
    int endFrame;

    public Animation(int animationId, int startFrame,  int endFrame)
    {
        this.animationId = animationId;
        this.startFrame = startFrame;
        this.endFrame = endFrame;
    }
}

package com.animationtransmog.effect;

import lombok.NonNull;
import okhttp3.*;

import java.io.*;
import java.sql.Timestamp;
import java.util.HashMap;
import java.util.function.Consumer;

public class DatabaseManager
{
    OkHttpClient client;

    public DatabaseManager(OkHttpClient client)
    {
        this.client = client;
    }

    public void getSettings(String playerName, Consumer<HashMap<String, String>> callback)
    {
        HashMap<String, String> newSettings = new HashMap<>();

        // Generate GET request to get settings from database
        Request request = new Request.Builder()
                .url("https://runelite-animation-transmog-default-rtdb.firebaseio.com/players/" + playerName.replace(" ", "+") + ".json")
                .addHeader("Content-Type", "application/json")
                .build();

        // Execute request on new thread
        client.newCall(request).enqueue(new Callback()
        {
            @Override
            public void onFailure(@NonNull Call call, @NonNull IOException e)
            {
                e.printStackTrace();
            }

            @Override
            public void onResponse(@NonNull Call call, @NonNull final Response response) throws IOException
            {
                if (!response.isSuccessful())
                {
                    throw new IOException("Unexpected code " + response);
                }
                else
                {
                    ResponseBody body = response.body();
                    if (body == null) return;

                    String bodyString = body.string();
                    if (!bodyString.equals("null"))
                    {
                        // Parse JSON response into HashMap
                        String responseString = bodyString.substring(1, bodyString.length() - 1);
                        String[] responseStringList = responseString.split(",");
                        for (String keyVal : responseStringList)
                        {
                            String[] keyValList = keyVal.split(":");
                            String key = keyValList[0].substring(1, keyValList[0].length() - 1);
                            String value = keyValList[1].substring(1, keyValList[1].length() - 1);
                            if (!key.equals("lastUpdated")) newSettings.put(key, value);
                        }
                    }
                    body.close();
                    callback.accept(newSettings);
                }
            }
        });
    }

    public void setSettings(String playerName, HashMap<String, String> newSettings)
    {
        // Convert HashMap to JSON string
        StringBuilder result = new StringBuilder();
        result.append("{");
        for (HashMap.Entry<String, String> entry : newSettings.entrySet())
        {
            result.append('"').append(entry.getKey()).append('"')
                    .append(":")
                    .append('"').append(entry.getValue()).append('"')
                    .append(",");
        }
        result.append('"').append("lastUpdated").append('"')
                .append(":")
                .append('"').append(new Timestamp(System.currentTimeMillis()).toInstant()).append('"')
                .append("}");

        // Generate PUT request to update database
        MediaType mediaType = MediaType.parse("application/json");
        RequestBody body = RequestBody.create(mediaType, result.toString());
        Request request = new Request.Builder()
                .url("https://runelite-animation-transmog-default-rtdb.firebaseio.com/players/" + playerName.replace(" ", "+") + ".json?print=silent")
                .put(body)
                .addHeader("Content-Type", "application/json")
                .build();

        // Execute request on new thread
        client.newCall(request).enqueue(new Callback()
        {
            @Override
            public void onFailure(@NonNull Call call, @NonNull IOException e)
            {
                e.printStackTrace();
            }

            @Override
            public void onResponse(@NonNull Call call, @NonNull final Response response) throws IOException
            {
                if (!response.isSuccessful())
                {
                    throw new IOException("Unexpected code " + response);
                }
                response.close();
            }
        });
    }
}
