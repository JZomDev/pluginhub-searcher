package dev.seafoo.richtextnotes;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("richtextnotes")
public interface RichTextNotesConfig extends Config
{
	@ConfigItem(
		keyName = "alwaysShowToolbar",
		name = "Always show Toolbar",
		description = "Always show the editor toolbar even when it is not in focus"
	)
	default boolean alwaysShowToolbar()
	{
		return false;
	}

	@ConfigItem(
		keyName = "maxPaneCount",
		name = "Pane Limit",
		description = "Maximum Number of Panes"
	)
	default int maxPaneCount()
	{
		return 5;
	}
}
package dev.seafoo.richtextnotes.models;

import com.google.gson.annotations.SerializedName;
import java.util.ArrayList;
import java.util.List;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
public class EditorLayout
{
	// Multi-pane layout support
	@SerializedName("pane_groups")
	private List<PaneGroupLayout> paneGroups;

	@SerializedName("active_pane_group_id")
	private String activePaneGroupId;

	@SerializedName("active_note_id")
	private String activeNoteId;

	// Legacy fields (kept for potential future use)
	@SerializedName("window_width")
	private int windowWidth;

	@SerializedName("window_height")
	private int windowHeight;

	@SerializedName("search_history")
	private List<String> searchHistory;

	public EditorLayout()
	{
		this.paneGroups = new ArrayList<>();
		this.searchHistory = new ArrayList<>();
		this.windowWidth = 400;
		this.windowHeight = 600;
	}

	/**
	 * Add a pane group to the layout
	 */
	public void addPaneGroup(PaneGroupLayout paneGroup)
	{
		if (paneGroups == null)
		{
			paneGroups = new ArrayList<>();
		}
		paneGroups.add(paneGroup);
	}

	/**
	 * Get pane group by ID
	 */
	public PaneGroupLayout getPaneGroupById(String paneGroupId)
	{
		if (paneGroups == null)
		{
			return null;
		}

		return paneGroups.stream()
			.filter(pg -> paneGroupId.equals(pg.getPaneGroupId()))
			.findFirst()
			.orElse(null);
	}

	/**
	 * Remove pane group by ID
	 */
	public boolean removePaneGroup(String paneGroupId)
	{
		if (paneGroups == null)
		{
			return false;
		}

		return paneGroups.removeIf(pg -> paneGroupId.equals(pg.getPaneGroupId()));
	}

	/**
	 * Get total number of pane groups
	 */
	public int getPaneGroupCount()
	{
		return paneGroups != null ? paneGroups.size() : 0;
	}

	/**
	 * Get total number of notes across all panes
	 */
	public int getTotalNoteCount()
	{
		if (paneGroups == null)
		{
			return 0;
		}

		return paneGroups.stream()
			.mapToInt(pg -> pg.getNoteIds() != null ? pg.getNoteIds().size() : 0)
			.sum();
	}

	/**
	 * Check if layout has any content
	 */
	public boolean hasContent()
	{
		return getPaneGroupCount() > 0 && getTotalNoteCount() > 0;
	}

	/**
	 * Clear all layout data
	 */
	public void clear()
	{
		if (paneGroups != null)
		{
			paneGroups.clear();
		}
		activePaneGroupId = null;
		activeNoteId = null;
	}

	/**
	 * Layout information for a single pane group
	 */
	@Data
	@NoArgsConstructor
	public static class PaneGroupLayout
	{
		@SerializedName("pane_group_id")
		private String paneGroupId;

		@SerializedName("note_ids")
		private List<String> noteIds;

		@SerializedName("active_note_id")
		private String activeNoteId;

		@SerializedName("order_index")
		private int orderIndex; // For maintaining pane order

		public PaneGroupLayout(String paneGroupId, int orderIndex)
		{
			this.paneGroupId = paneGroupId;
			this.orderIndex = orderIndex;
			this.noteIds = new ArrayList<>();
		}

		/**
		 * Add a note ID to this pane group
		 */
		public void addNoteId(String noteId)
		{
			if (noteIds == null)
			{
				noteIds = new ArrayList<>();
			}
			if (!noteIds.contains(noteId))
			{
				noteIds.add(noteId);
			}
		}

		/**
		 * Remove a note ID from this pane group
		 */
		public void removeNoteId(String noteId)
		{
			if (noteIds != null)
			{
				noteIds.remove(noteId);
			}
		}

		/**
		 * Get the number of notes in this pane group
		 */
		public int getNoteCount()
		{
			return noteIds != null ? noteIds.size() : 0;
		}

		/**
		 * Check if this pane group has any notes
		 */
		public boolean hasNotes()
		{
			return getNoteCount() > 0;
		}
	}
}
package dev.seafoo.richtextnotes.models;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Data
@NoArgsConstructor
public class Note
{
	private String noteId;
	private String rtfContent;
	private NoteMetadata metadata;
	public boolean isModified;
	private boolean isLoaded;

	public Note(String noteId, String rtfContent, NoteMetadata metadata)
	{
		this.noteId = noteId;
		this.rtfContent = rtfContent;
		this.metadata = metadata;
		this.isModified = false;
		this.isLoaded = true;
	}

	public void setRtfContent(String rtfContent)
	{
		if (!rtfContent.equals(this.rtfContent))
		{
			this.rtfContent = rtfContent;
			this.isModified = true;
			if (metadata != null)
			{
				metadata.updateModified();
			}
		}
	}

	public void markSaved()
	{
		this.isModified = false;
	}

	public String getDisplayTitle()
	{
		if (metadata != null && metadata.getTitle() != null && !metadata.getTitle().trim().isEmpty())
		{
			return metadata.getTitle();
		}
		return "Untitled Note";
	}
}
package dev.seafoo.richtextnotes.models;

import com.google.gson.annotations.SerializedName;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class NoteMetadata
{
	@SerializedName("id")
	private String noteId;


	@SerializedName("title")
	private String title;

	@SerializedName("created")
	private LocalDateTime createdDate;

	@SerializedName("modified")
	private LocalDateTime lastModified;

	@SerializedName("tags")
	private List<String> tags;

	@SerializedName("category")
	private String category;

	@SerializedName("pinned")
	private boolean pinned;

	@SerializedName("color")
	private String color; // For color-coding notes

	// Constructor for basic metadata
	public NoteMetadata(String noteId, String title, LocalDateTime createdDate, List<String> tags)
	{
		this.noteId = noteId;
		this.title = title;
		this.createdDate = createdDate;
		this.lastModified = createdDate;
		this.tags = tags != null ? new ArrayList<>(tags) : new ArrayList<>();
		this.category = null;
		this.pinned = false;
		this.color = null;
	}

	public void addTag(String tag)
	{
		if (tags == null)
		{
			tags = new ArrayList<>();
		}
		if (!tags.contains(tag))
		{
			tags.add(tag);
		}
	}

	public void removeTag(String tag)
	{
		if (tags != null)
		{
			tags.remove(tag);
		}
	}

	public boolean hasTag(String tag)
	{
		return tags != null && tags.contains(tag);
	}

	public void updateModified()
	{
		this.lastModified = LocalDateTime.now();
	}
}
package dev.seafoo.richtextnotes.ui.panels;

import dev.seafoo.richtextnotes.RichTextNotesConfig;
import dev.seafoo.richtextnotes.models.Note;
import dev.seafoo.richtextnotes.models.NoteMetadata;
import dev.seafoo.richtextnotes.services.FileStorageService;
import dev.seafoo.richtextnotes.services.ItemIconService;
import dev.seafoo.richtextnotes.ui.components.RichTextEditor;
import dev.seafoo.richtextnotes.ui.popups.NoteSelectionDialog;
import dev.seafoo.richtextnotes.ui.popups.TagEditDialog;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JTabbedPane;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

/**
 * A single pane group that contains a tabbed interface for notes.
 * This can be split vertically to create multiple pane groups.
 */
@EqualsAndHashCode(callSuper = true)
@Slf4j
@Data
public class NotePaneGroup extends JPanel
{

	private final NotesPanel parentPanel;
	private final FileStorageService storageService;
	private final RichTextNotesConfig config;
	private final ItemIconService itemIconService;

	// UI Components
	private JTabbedPane tabbedPane;

	// Note management for this pane group
	private final Map<String, Note> loadedNotes = new ConcurrentHashMap<>();
	private final Map<String, NoteEditor> noteEditors = new ConcurrentHashMap<>();
	private String currentNoteId;
	private final String paneGroupId;

	public NotePaneGroup(NotesPanel parentPanel, FileStorageService storageService,
						 RichTextNotesConfig config, String paneGroupId, ItemIconService itemIconService)
	{
		this.parentPanel = parentPanel;
		this.storageService = storageService;
		this.config = config;
		this.paneGroupId = paneGroupId;
		this.itemIconService = itemIconService;
		setupUI();
	}

	private void setupUI()
	{
		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARK_GRAY_COLOR);
		setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));

		// Create compact tab header with navigation and actions
		JPanel tabHeader = createTabHeader();
		add(tabHeader, BorderLayout.NORTH);

		// Create tabbed pane
		tabbedPane = new JTabbedPane();
		tabbedPane.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		tabbedPane.setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);
		tabbedPane.setTabPlacement(JTabbedPane.TOP);

		// Hide the default tab area since we're using custom header
		tabbedPane.setUI(new javax.swing.plaf.basic.BasicTabbedPaneUI()
		{
			@Override
			protected int calculateTabAreaHeight(int tabPlacement, int horizRunCount, int maxTabHeight)
			{
				return 0; // Hide default tabs
			}

			@Override
			protected void paintTabArea(Graphics g, int tabPlacement, int selectedIndex)
			{
				// Don't paint default tab area
			}
		});

		// Add tab change listener
		tabbedPane.addChangeListener(e -> {
			int selectedIndex = tabbedPane.getSelectedIndex();
			if (selectedIndex >= 0)
			{
				String noteId = (String) tabbedPane.getClientProperty("noteId_" + selectedIndex);
				if (noteId != null)
				{
					currentNoteId = noteId;
					updateTabHeader();
					parentPanel.onActiveNoteChanged(this, noteId);
				}
			}
		});

		add(tabbedPane, BorderLayout.CENTER);
	}

	private JPanel createTabHeader()
	{
		JPanel header = new JPanel(new BorderLayout());
		header.setBackground(ColorScheme.DARK_GRAY_COLOR);
		header.setBorder(new EmptyBorder(3, 3, 3, 3));

		// Simple current note display
		JLabel currentNoteLabel = new JLabel("No note selected");
		currentNoteLabel.setForeground(Color.WHITE);
		currentNoteLabel.setFont(currentNoteLabel.getFont().deriveFont(Font.BOLD, 11f));

		// Add right-click menu to the header area
		MouseAdapter headerClickListener = new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				if (SwingUtilities.isRightMouseButton(e))
				{
					showHeaderContextMenu(e);
				}
			}
		};
		currentNoteLabel.addMouseListener(headerClickListener);
		header.addMouseListener(headerClickListener);

		header.add(currentNoteLabel, BorderLayout.CENTER);

		// Simple action buttons
		JPanel actionsPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, 2, 0));
		actionsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		JButton prevButton = new JButton("<");
		prevButton.setPreferredSize(new Dimension(30, 24));
		prevButton.addActionListener(e -> navigateTab(-1));
		actionsPanel.add(prevButton);

		JButton nextButton = new JButton(">");
		nextButton.setPreferredSize(new Dimension(30, 24));
		nextButton.addActionListener(e -> navigateTab(1));
		actionsPanel.add(nextButton);

		JButton newButton = new JButton("+");
		newButton.setPreferredSize(new Dimension(30, 24));
		newButton.setToolTipText("New note");
		newButton.addActionListener(e -> createNewNote());
		actionsPanel.add(newButton);

		JButton menuButton = new JButton("...");
		menuButton.setPreferredSize(new Dimension(30, 24));
		menuButton.setToolTipText("Menu");
		menuButton.addActionListener(e -> showPaneMenu(menuButton));
		actionsPanel.add(menuButton);

		header.add(actionsPanel, BorderLayout.EAST);

		// Store references
		header.putClientProperty("currentNoteLabel", currentNoteLabel);
		header.putClientProperty("prevButton", prevButton);
		header.putClientProperty("nextButton", nextButton);

		return header;
	}

	private void navigateTab(int direction)
	{
		int tabCount = tabbedPane.getTabCount();
		if (tabCount == 0)
		{
			return;
		}

		int currentIndex = tabbedPane.getSelectedIndex();
		int newIndex = currentIndex + direction;

		if (newIndex >= 0 && newIndex < tabCount)
		{
			tabbedPane.setSelectedIndex(newIndex);
			updateTabHeader();
		}
	}

	private void updateTabHeader()
	{
		Component headerComponent = getComponent(0); // North component
		if (!(headerComponent instanceof JPanel))
		{
			return;
		}

		JPanel header = (JPanel) headerComponent;
		JLabel currentNoteLabel = (JLabel) header.getClientProperty("currentNoteLabel");
		JButton prevButton = (JButton) header.getClientProperty("prevButton");
		JButton nextButton = (JButton) header.getClientProperty("nextButton");

		if (currentNoteLabel == null)
		{
			return;
		}

		int tabCount = tabbedPane.getTabCount();
		int selectedIndex = tabbedPane.getSelectedIndex();

		// Update current note display
		if (selectedIndex >= 0 && currentNoteId != null)
		{
			Note note = loadedNotes.get(currentNoteId);
			if (note != null)
			{
				String title = note.getDisplayTitle();
				if (note.isModified())
				{
					title += " *";
				}

				// Show tab position if multiple tabs
				if (tabCount > 1)
				{
					title += String.format(" (%d/%d)", selectedIndex + 1, tabCount);
				}
				currentNoteLabel.setText(title);

				// Set the note title as tooltip
				currentNoteLabel.setToolTipText(note.getDisplayTitle());
			}
		}
		else
		{
			currentNoteLabel.setText("No note selected");
			currentNoteLabel.setToolTipText(null);
		}

		// Update navigation button states
		if (prevButton != null && nextButton != null)
		{
			prevButton.setEnabled(selectedIndex > 0);
			nextButton.setEnabled(selectedIndex >= 0 && selectedIndex < tabCount - 1);
		}

		this.parentPanel.scheduleLayoutSave();
	}

	private void showHeaderContextMenu(MouseEvent e)
	{
		if (currentNoteId == null)
		{
			return;
		}

		JPopupMenu menu = new JPopupMenu();

		JMenuItem closeTab = new JMenuItem("Close Current Tab");
		closeTab.addActionListener(ev -> {
			int currentIndex = tabbedPane.getSelectedIndex();
			if (currentIndex >= 0)
			{
				closeTab(currentIndex);
			}
		});
		closeTab.setEnabled(tabbedPane.getTabCount() > 0);
		menu.add(closeTab);

		menu.addSeparator();

		JMenuItem rename = new JMenuItem("Rename Note");
		rename.addActionListener(ev -> renameNote(currentNoteId));
		menu.add(rename);

		JMenuItem editTags = new JMenuItem("Edit Tags");
		editTags.addActionListener(ev -> editNoteTags(currentNoteId));
		menu.add(editTags);

		JMenuItem deleteNote = new JMenuItem("Delete Note");
		deleteNote.setForeground(Color.RED);
		deleteNote.addActionListener(ev -> {
			Note note = loadedNotes.get(currentNoteId);
			String noteTitle = note != null ? note.getDisplayTitle() : "Note";
			deleteNote(currentNoteId, noteTitle);
		});
		menu.add(deleteNote);

		menu.show((Component) e.getSource(), e.getX(), e.getY());
	}

	private void showPaneMenu(JButton menuButton)
	{
		JPopupMenu menu = new JPopupMenu();

		JMenuItem openExisting = new JMenuItem("Open Existing Note");
		openExisting.addActionListener(e -> showOpenNoteDialog());
		menu.add(openExisting);

		menu.addSeparator();

		JMenuItem closeTab = new JMenuItem("Close Current Tab");
		closeTab.addActionListener(ev -> {
			int currentIndex = tabbedPane.getSelectedIndex();
			if (currentIndex >= 0)
			{
				closeTab(currentIndex);
			}
		});
		closeTab.setEnabled(tabbedPane.getTabCount() > 0);
		menu.add(closeTab);

		menu.addSeparator();

		JMenuItem rename = new JMenuItem("Rename Note");
		rename.addActionListener(ev -> renameNote(currentNoteId));
		rename.setEnabled(tabbedPane.getTabCount() > 0);
		menu.add(rename);

		JMenuItem editTags = new JMenuItem("Edit Tags");
		editTags.addActionListener(ev -> editNoteTags(currentNoteId));
		editTags.setEnabled(tabbedPane.getTabCount() > 0);
		menu.add(editTags);

		JMenuItem deleteNote = new JMenuItem("Delete Note");
		deleteNote.setForeground(Color.RED);
		deleteNote.addActionListener(ev -> {
			Note note = loadedNotes.get(currentNoteId);
			String noteTitle = note != null ? note.getDisplayTitle() : "Note";
			deleteNote(currentNoteId, noteTitle);
		});
		deleteNote.setEnabled(tabbedPane.getTabCount() > 0);
		menu.add(deleteNote);

		menu.addSeparator();

		JMenuItem splitPane = new JMenuItem("Split Pane");
		splitPane.addActionListener(e -> parentPanel.splitPaneGroup());
		// Disable split pane if we already have the maximum number of pane groups
		splitPane.setEnabled(parentPanel.getPaneGroupCount() < config.maxPaneCount());
		if (parentPanel.getPaneGroupCount() >= config.maxPaneCount())
		{
			splitPane.setToolTipText("Maximum of " + config.maxPaneCount() + " panes allowed");
		}
		menu.add(splitPane);

		JMenuItem closePane = new JMenuItem("Close Pane");
		closePane.addActionListener(e -> parentPanel.closePaneGroup(this));
		closePane.setEnabled(parentPanel.getPaneGroupCount() > 1);
		menu.add(closePane);

		menu.addSeparator();

		JMenuItem openDirectory = new JMenuItem("Open Notes Directory");
		openDirectory.addActionListener(e -> openNotesDirectory());
		menu.add(openDirectory);

		menu.show(menuButton, 0, menuButton.getHeight());
	}


	private void showOpenNoteDialog()
	{
		try
		{
			java.util.List<NoteMetadata> allNotes = storageService.listNotesWithMetadata();

			if (allNotes.isEmpty())
			{
				JOptionPane.showMessageDialog(this, "No notes found.", "Open Note", JOptionPane.INFORMATION_MESSAGE);
				return;
			}

			// Use the enhanced note selection dialog
			NoteSelectionDialog dialog =
				new NoteSelectionDialog(this, allNotes);

			dialog.setVisible(true);

			if (dialog.isOkPressed())
			{
				NoteMetadata selectedNote = dialog.getSelectedNote();
				if (selectedNote != null)
				{
					openNoteInTab(selectedNote.getNoteId(), true);
				}
			}

		}
		catch (Exception e)
		{
			log.error("Failed to show open note dialog", e);
		}
	}


	private void openNotesDirectory()
	{
		try
		{
			java.awt.Desktop desktop = java.awt.Desktop.getDesktop();
			desktop.open(storageService.getProfileDirectory().toFile());
		}
		catch (Exception e)
		{
			log.error("Failed to open notes directory", e);

			String directoryPath = storageService.getNotesDirectory().toString();
			JOptionPane.showMessageDialog(
				this,
				"Failed to open directory automatically.\nNotes are stored at:\n" + directoryPath,
				"Notes Directory",
				JOptionPane.INFORMATION_MESSAGE
			);
		}
	}

	private void editNoteTags(String noteId)
	{
		Note note = loadedNotes.get(noteId);
		if (note == null || note.getMetadata() == null)
		{
			return;
		}

		NoteMetadata metadata = note.getMetadata();
		List<String> currentTags = metadata.getTags() != null ?
			new ArrayList<>(metadata.getTags()) : new ArrayList<>();

		TagEditDialog dialog = new TagEditDialog(this, currentTags, note.getDisplayTitle());
		dialog.setVisible(true);

		if (dialog.isOkPressed())
		{
			List<String> newTags = dialog.getTags();

			// Clear existing tags and add new ones
			if (metadata.getTags() != null)
			{
				metadata.getTags().clear();
			}

			for (String tag : newTags)
			{
				metadata.addTag(tag);
			}

			metadata.updateModified();

			try
			{
				storageService.saveNoteMetadata(noteId, metadata);
				updateTabHeader(); // Update display to show tag count
				log.debug("Updated tags for note {}: {}", noteId, newTags);
			}
			catch (Exception e)
			{
				log.error("Failed to save note tags", e);
			}
		}
	}

	public void createNewNote()
	{
		try
		{
			// Create new note with default content
			String defaultContent = "";
			String noteId = storageService.saveNote(null, defaultContent);

			// Create metadata
			NoteMetadata metadata = new NoteMetadata(
				noteId,
				"Untitled Note",
				LocalDateTime.now(),
				new ArrayList<>()
			);
			storageService.saveNoteMetadata(noteId, metadata);

			// Open in new tab
			openNoteInTab(noteId, true);

			log.debug("Created new note: {} in pane group: {}", noteId, paneGroupId);

		}
		catch (Exception e)
		{
			log.error("Failed to create new note", e);
		}
	}

	public void openNoteInTab(String noteId, boolean focus)
	{
		try
		{
			// Check if note is already open
			for (int i = 0; i < tabbedPane.getTabCount(); i++)
			{
				String existingNoteId = (String) tabbedPane.getClientProperty("noteId_" + i);
				if (noteId.equals(existingNoteId))
				{
					if (focus)
					{
						tabbedPane.setSelectedIndex(i);
						updateTabHeader();
					}
					return;
				}
			}

			// Load note if not already loaded
			Note note = loadedNotes.get(noteId);
			if (note == null)
			{
				String content = storageService.loadNote(noteId);
				NoteMetadata metadata = storageService.loadNoteMetadata(noteId);
				note = new Note(noteId, content, metadata);
				loadedNotes.put(noteId, note);
			}

			// Create editor for this note
			NoteEditor editor = new NoteEditor(note, parentPanel::scheduleAutoSave, itemIconService, config);
			noteEditors.put(noteId, editor);

			// Add tab to tabbedPane (hidden, just for content management)
			int tabIndex = tabbedPane.getTabCount();
			tabbedPane.addTab("", editor.getEditorComponent()); // Empty title since we use custom header
			tabbedPane.putClientProperty("noteId_" + tabIndex, noteId);

			if (currentNoteId == null)
			{
				currentNoteId = noteId;
			}

			// Focus if requested
			if (focus)
			{
				tabbedPane.setSelectedIndex(tabIndex);
				currentNoteId = noteId;
				editor.requestFocus();
			}

			updateTabHeader();

		}
		catch (Exception e)
		{
			log.error("Failed to open note in tab: {}", noteId, e);
		}
	}

	private void closeTab(int tabIndex)
	{
		String noteId = (String) tabbedPane.getClientProperty("noteId_" + tabIndex);
		if (noteId != null)
		{
			// Save note before closing
			saveNote(noteId);
			closeTabInternal(tabIndex);
		}
	}

	private void closeTabInternal(int tabIndex)
	{
		String noteId = (String) tabbedPane.getClientProperty("noteId_" + tabIndex);
		if (noteId == null)
		{
			return;
		}

		// Remove tab from tabbedPane
		tabbedPane.removeTabAt(tabIndex);

		// Update client properties for remaining tabs
		for (int i = tabIndex; i < tabbedPane.getTabCount(); i++)
		{
			String nextNoteId = (String) tabbedPane.getClientProperty("noteId_" + (i + 1));
			if (nextNoteId != null)
			{
				tabbedPane.putClientProperty("noteId_" + i, nextNoteId);
			}
		}
		// Remove the last property that's now unused
		tabbedPane.putClientProperty("noteId_" + tabbedPane.getTabCount(), null);

		// Clean up editor and memory
		noteEditors.remove(noteId);
		loadedNotes.remove(noteId);

		// Update current note
		if (noteId.equals(currentNoteId))
		{
			currentNoteId = tabbedPane.getTabCount() > 0 ?
				(String) tabbedPane.getClientProperty("noteId_0") : null;
		}

		updateTabHeader();
	}

	private void renameNote(String noteId)
	{
		Note note = loadedNotes.get(noteId);
		if (note == null)
		{
			return;
		}

		String currentTitle = note.getDisplayTitle();
		String newTitle = JOptionPane.showInputDialog(
			this,
			"Enter new title:",
			currentTitle
		);

		if (newTitle != null && !newTitle.trim().isEmpty() && !newTitle.equals(currentTitle))
		{
			try
			{
				note.getMetadata().setTitle(newTitle.trim());
				note.getMetadata().updateModified();
				storageService.saveNoteMetadata(noteId, note.getMetadata());

				// Update tab display
				updateTabHeader();

			}
			catch (Exception e)
			{
				log.error("Failed to rename note", e);
			}
		}
	}

	private void deleteNote(String noteId, String noteTitle)
	{
		int result = JOptionPane.showConfirmDialog(
			this,
			"Delete \"" + noteTitle + "\"?\nThis cannot be undone.",
			"Delete Note",
			JOptionPane.YES_NO_OPTION,
			JOptionPane.WARNING_MESSAGE
		);

		if (result == JOptionPane.YES_OPTION)
		{
			try
			{
				// Remove from storage
				storageService.deleteNote(noteId);

				// Find and remove tab
				for (int i = 0; i < tabbedPane.getTabCount(); i++)
				{
					String tabNoteId = (String) tabbedPane.getClientProperty("noteId_" + i);
					if (noteId.equals(tabNoteId))
					{
						closeTabInternal(i);
						break;
					}
				}

				log.debug("Deleted note: {} from pane group: {}", noteId, paneGroupId);

			}
			catch (Exception e)
			{
				log.error("Failed to delete note", e);
			}
		}
	}

	// Public methods for parent panel management

	public void saveNote(String noteId)
	{
		try
		{
			Note note = loadedNotes.get(noteId);
			if (note == null || !note.isModified())
			{
				return;
			}

			// Get current content from editor
			NoteEditor editor = noteEditors.get(noteId);
			if (editor != null)
			{
				String currentContent = editor.getContent();
				note.setRtfContent(currentContent);
			}

			// Save to storage
			storageService.saveNote(noteId, note.getRtfContent());
			storageService.saveNoteMetadata(noteId, note.getMetadata());

			note.markSaved();
			updateTabHeader(); // Update to remove the * indicator

		}
		catch (Exception e)
		{
			log.error("Failed to save note: {}", noteId, e);
			throw new RuntimeException("Failed to save note", e);
		}
	}

	public void saveAllNotes()
	{
		for (String noteId : loadedNotes.keySet())
		{
			if (loadedNotes.get(noteId).isModified())
			{
				saveNote(noteId);
			}
		}
	}

	public boolean hasModifiedNotes()
	{
		return loadedNotes.values().stream().anyMatch(Note::isModified);
	}

	public int getTabCount()
	{
		return tabbedPane.getTabCount();
	}

	public void setActiveNote(String noteId)
	{
		if (noteId == null)
		{
			return;
		}

		// Find the tab with this note ID
		for (int i = 0; i < tabbedPane.getTabCount(); i++)
		{
			String tabNoteId = (String) tabbedPane.getClientProperty("noteId_" + i);
			if (noteId.equals(tabNoteId))
			{
				tabbedPane.setSelectedIndex(i);
				currentNoteId = noteId;
				updateTabHeader();
				return;
			}
		}

		log.warn("Could not set active note {} - note not found in this pane group", noteId);
	}

	// Inner class for note editing using the new RTF editor
	private static class NoteEditor
	{
		private final Note note;
		private final dev.seafoo.richtextnotes.ui.components.RichTextEditor richTextEditor;
		private final Runnable saveCallback;
		private final RichTextNotesConfig config;

		public NoteEditor(Note note, Runnable saveCallback, ItemIconService itemIconService, RichTextNotesConfig config)
		{
			this.note = note;
			this.saveCallback = saveCallback;
			this.config = config;
			this.richTextEditor = new RichTextEditor(
				note, saveCallback, itemIconService, config);
		}

		public JComponent getEditorComponent()
		{
			return richTextEditor;
		}

		public String getContent()
		{
			return richTextEditor.getContentAsRtf();
		}

		public void requestFocus()
		{
			richTextEditor.requestEditorFocus();
		}
	}

}
package dev.seafoo.richtextnotes.ui.panels;

import dev.seafoo.richtextnotes.RichTextNotesConfig;
import dev.seafoo.richtextnotes.models.EditorLayout;
import dev.seafoo.richtextnotes.models.NoteMetadata;
import dev.seafoo.richtextnotes.services.FileStorageService;
import dev.seafoo.richtextnotes.services.ItemIconService;
import java.awt.BorderLayout;
import java.awt.Component;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import javax.swing.BorderFactory;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JSplitPane;
import javax.swing.JTabbedPane;
import javax.swing.SwingUtilities;
import javax.swing.Timer;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;

/**
 * Main notes panel that manages multiple pane groups.
 */
@Slf4j
public class NotesPanel extends PluginPanel
{
	private static final int AUTO_SAVE_DELAY_MS = 2000;
	private static final int LAYOUT_SAVE_DELAY_MS = 2000;

	private FileStorageService storageService;
	private RichTextNotesConfig config;
	private ItemIconService itemIconService;

	// Split pane management
	private JPanel mainContentPanel;
	private final List<NotePaneGroup> paneGroups = new ArrayList<>();
	private final AtomicInteger paneGroupCounter = new AtomicInteger(0);

	// UI Components
	private Timer autoSaveTimer;

	// State tracking
	private NotePaneGroup activePaneGroup;
	private String activeNoteId;
	private Timer layoutSaveTimer;

	public void init(RichTextNotesConfig config, FileStorageService storageService, ItemIconService itemIconService)
	{

		this.config = config;
		this.storageService = storageService;
		this.itemIconService = itemIconService;

		setupUI();
		setupAutoSave();
		restoreEditorLayout();

	}

	private void setupUI()
	{
		// Set up main layout
		getParent().setLayout(new BorderLayout());
		getParent().add(this, BorderLayout.CENTER);

		setLayout(new BorderLayout());
		setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
		setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Create main content panel that will contain the split panes
		mainContentPanel = new JPanel(new BorderLayout());
		mainContentPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		add(mainContentPanel, BorderLayout.CENTER);


		// Create the first pane group
		createInitialPaneGroup();
	}

	private void createInitialPaneGroup()
	{
		String paneGroupId = "pane_" + paneGroupCounter.getAndIncrement();
		NotePaneGroup paneGroup = new NotePaneGroup(this, storageService, config, paneGroupId, itemIconService);

		paneGroups.add(paneGroup);
		activePaneGroup = paneGroup;

		// Add directly to main content panel (no split pane needed for single pane)
		mainContentPanel.add(paneGroup, BorderLayout.CENTER);

		log.debug("Created initial pane group: {}", paneGroupId);
	}

	/**
	 * Split the specified pane group, creating a new pane group below
	 */
	public void splitPaneGroup()
	{
		try
		{
			// Check if we've reached the maximum number of pane groups
			if (paneGroups.size() >= config.maxPaneCount())
			{
				return;
			}

			String newPaneGroupId = "pane_" + paneGroupCounter.getAndIncrement();
			NotePaneGroup newPaneGroup = new NotePaneGroup(this, storageService, config, newPaneGroupId, itemIconService);

			paneGroups.add(newPaneGroup);

			// Rebuild the split pane layout
			rebuildSplitPaneLayout();
			scheduleLayoutSave();

			log.debug("Split pane group. Total panes: {}", paneGroups.size());

		}
		catch (Exception e)
		{
			log.error("Failed to split pane group", e);
		}
	}

	/**
	 * Close the specified pane group
	 */
	public void closePaneGroup(NotePaneGroup paneGroup)
	{
		if (paneGroups.size() <= 1)
		{
			JOptionPane.showMessageDialog(
				this,
				"Cannot close the last pane group.\nUse 'Reset Layout' from the menu to clear all notes.",
				"Close Pane",
				JOptionPane.WARNING_MESSAGE
			);
			return;
		}

		// Count tabs in this pane
		int tabCount = paneGroup.getTabCount();

		// Check for unsaved changes
		if (paneGroup.hasModifiedNotes())
		{
			int result = JOptionPane.showConfirmDialog(
				this,
				String.format("This pane has %d tab(s) with unsaved changes.\nSave before closing?", tabCount),
				"Close Pane - Unsaved Changes",
				JOptionPane.YES_NO_CANCEL_OPTION,
				JOptionPane.WARNING_MESSAGE
			);

			if (result == JOptionPane.YES_OPTION)
			{
				paneGroup.saveAllNotes();
			}
			else if (result == JOptionPane.CANCEL_OPTION)
			{
				return;
			}
		}

		String closedPaneId = paneGroup.getPaneGroupId();

		// Remove the pane group
		paneGroups.remove(paneGroup);

		// Update active pane if necessary
		if (activePaneGroup == paneGroup)
		{
			activePaneGroup = paneGroups.isEmpty() ? null : paneGroups.get(0);
			activeNoteId = null;
		}

		// Rebuild the split pane layout
		rebuildSplitPaneLayout();

		log.debug("Closed pane group: {}. Remaining panes: {}", closedPaneId, paneGroups.size());
	}

	/**
	 * Rebuild the entire split pane layout based on current pane groups
	 */
	private void rebuildSplitPaneLayout()
	{
		mainContentPanel.removeAll();
		JSplitPane rootSplitPane;

		if (paneGroups.isEmpty())
		{
			createInitialPaneGroup();
			return;
		}

		if (paneGroups.size() == 1)
		{
			// Single pane, no split needed
			mainContentPanel.add(paneGroups.get(0), BorderLayout.CENTER);
		}
		else
		{
			// Multiple panes, create nested split panes
			rootSplitPane = createNestedSplitPanes(paneGroups);
			mainContentPanel.add(rootSplitPane, BorderLayout.CENTER);
		}

		mainContentPanel.revalidate();
		mainContentPanel.repaint();
	}

	/**
	 * Create nested split panes for multiple pane groups
	 */
	private JSplitPane createNestedSplitPanes(List<NotePaneGroup> paneGroups)
	{
		if (paneGroups.size() == 2)
		{
			JSplitPane splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT,
				paneGroups.get(0), paneGroups.get(1));
			setupSplitPane(splitPane);
			return splitPane;
		}

		// For more than 2 panes, create nested split panes
		// Split the list in half and recurse
		int mid = paneGroups.size() / 2;
		List<NotePaneGroup> topPanes = paneGroups.subList(0, mid);
		List<NotePaneGroup> bottomPanes = paneGroups.subList(mid, paneGroups.size());

		Component topComponent = topPanes.size() == 1 ?
			topPanes.get(0) : createNestedSplitPanes(topPanes);
		Component bottomComponent = bottomPanes.size() == 1 ?
			bottomPanes.get(0) : createNestedSplitPanes(bottomPanes);

		JSplitPane splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT,
			topComponent, bottomComponent);
		setupSplitPane(splitPane);
		return splitPane;
	}

	private void setupSplitPane(JSplitPane splitPane)
	{
		splitPane.setResizeWeight(0.5); // Equal space by default
		splitPane.setContinuousLayout(true);
		splitPane.setOneTouchExpandable(false);
		splitPane.setBorder(BorderFactory.createEmptyBorder());
		splitPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
		splitPane.setDividerSize(5);
	}

	private void setupAutoSave()
	{
		autoSaveTimer = new Timer(AUTO_SAVE_DELAY_MS, e -> {
			saveAllNotes();
			autoSaveTimer.stop();
		});
		autoSaveTimer.setRepeats(false);

		layoutSaveTimer = new Timer(LAYOUT_SAVE_DELAY_MS, e -> {
			saveEditorLayout();
			layoutSaveTimer.stop();
		});
		layoutSaveTimer.setRepeats(false);

	}


	private void restoreEditorLayout()
	{
		try
		{
			EditorLayout layout = storageService.loadEditorLayout();

			if (layout == null || !layout.hasContent())
			{
				log.debug("No layout to restore or layout is empty");
				loadExistingNotesDefaultBehavior();
				return;
			}

			log.debug("Restoring editor layout: {} pane groups, {} total notes",
				layout.getPaneGroupCount(), layout.getTotalNoteCount());

			// Clear current layout (we already have one initial pane group)
			paneGroups.clear();
			mainContentPanel.removeAll();
			activePaneGroup = null;
			activeNoteId = null;

			// Sort pane groups by order index
			List<EditorLayout.PaneGroupLayout> sortedPaneGroups = new ArrayList<>(layout.getPaneGroups());
			sortedPaneGroups.sort(Comparator.comparingInt(EditorLayout.PaneGroupLayout::getOrderIndex));


			for (EditorLayout.PaneGroupLayout paneLayout : sortedPaneGroups)
			{
				// Create new pane group
				String paneGroupId = paneLayout.getPaneGroupId();
				NotePaneGroup paneGroup = new NotePaneGroup(this, storageService, config, paneGroupId, itemIconService);
				paneGroups.add(paneGroup);

				// Load notes into this pane group
				for (String noteId : paneLayout.getNoteIds())
				{
					try
					{
						// Check if note still exists
						if (storageService.noteExists(noteId))
						{
							paneGroup.openNoteInTab(noteId, false);
						}
						else
						{
							log.warn("Note {} no longer exists, skipping", noteId);
						}
					}
					catch (Exception e)
					{
						log.error("Failed to load note {} into pane {}", noteId, paneGroupId, e);
					}
				}

				// Set active note for this pane
				if (paneLayout.getActiveNoteId() != null && paneGroup.getTabCount() > 0)
				{
					try
					{
						paneGroup.setActiveNote(paneLayout.getActiveNoteId());
					}
					catch (Exception e)
					{
						log.warn("Failed to set active note {} in pane {}",
							paneLayout.getActiveNoteId(), paneGroupId, e);
					}
				}
			}

			// Handle case where no pane groups were created successfully
			if (paneGroups.isEmpty())
			{
				log.warn("No pane groups were restored, creating initial pane");
				createInitialPaneGroup();
				loadExistingNotesDefaultBehavior();
				return;
			}

			// Rebuild the split pane layout
			rebuildSplitPaneLayout();

			// Set global active pane and note
			String activePaneGroupId = layout.getActivePaneGroupId();
			if (activePaneGroupId != null)
			{
				activePaneGroup = paneGroups.stream()
					.filter(pg -> activePaneGroupId.equals(pg.getPaneGroupId()))
					.findFirst()
					.orElse(paneGroups.get(0));
			}
			else
			{
				activePaneGroup = paneGroups.get(0);
			}

			// Set active note
			String activeNoteIdFromLayout = layout.getActiveNoteId();
			if (activeNoteIdFromLayout != null)
			{
				activeNoteId = activeNoteIdFromLayout;
			}
			else if (activePaneGroup != null)
			{
				activeNoteId = activePaneGroup.getCurrentNoteId();
			}

		}
		catch (Exception e)
		{
			log.error("Failed to restore editor layout, falling back to default behavior", e);

			// Fallback to default behavior if restoration fails
			try
			{
				paneGroups.clear();
				mainContentPanel.removeAll();
				activePaneGroup = null;
				activeNoteId = null;
				createInitialPaneGroup();
				loadExistingNotesDefaultBehavior();
			}
			catch (Exception fallbackError)
			{
				log.error("Even fallback failed", fallbackError);
			}
		}
	}

	private void loadExistingNotesDefaultBehavior()
	{
		try
		{
			List<NoteMetadata> allNotes = storageService.listNotesWithMetadata();

			if (allNotes.isEmpty())
			{
				log.debug("No existing notes found");
				return;
			}

			// Sort notes by last modified date (most recent first)
			allNotes.sort((a, b) -> {
				if (a.getLastModified() == null && b.getLastModified() == null)
				{
					return 0;
				}
				if (a.getLastModified() == null)
				{
					return 1;
				}
				if (b.getLastModified() == null)
				{
					return -1;
				}
				return b.getLastModified().compareTo(a.getLastModified());
			});

			// Load notes into the first pane group
			NotePaneGroup firstPane = paneGroups.isEmpty() ? null : paneGroups.get(0);
			if (firstPane != null)
			{
				int loadedCount = 0;
				for (NoteMetadata metadata : allNotes)
				{
					if (metadata.isPinned() || loadedCount < 5)
					{
						firstPane.openNoteInTab(metadata.getNoteId(), false);
						loadedCount++;
					}
				}

				log.debug("Loaded {} notes into first pane (default behavior)", loadedCount);
			}

		}
		catch (Exception e)
		{
			log.error("Failed to load existing notes with default behavior", e);
		}
	}


	// Public interface methods for NotePaneGroup callbacks

	public void onActiveNoteChanged(NotePaneGroup paneGroup, String noteId)
	{
		activePaneGroup = paneGroup;
		activeNoteId = noteId;
	}

	public void scheduleAutoSave()
	{
		if (autoSaveTimer.isRunning())
		{
			autoSaveTimer.restart();
		}
		else
		{
			autoSaveTimer.start();
		}
	}

	public int getPaneGroupCount()
	{
		return paneGroups.size();
	}

	// Public interface methods for plugin

	public void saveAllNotes()
	{
		try
		{
			int savedCount = 0;
			for (NotePaneGroup paneGroup : paneGroups)
			{
				if (paneGroup.hasModifiedNotes())
				{
					paneGroup.saveAllNotes();
					savedCount++;
				}
			}

			if (savedCount > 0)
			{
				log.debug("Auto-saved notes in {} pane groups", savedCount);
			}

		}
		catch (Exception e)
		{
			log.error("Failed to auto-save notes", e);
		}
	}

	public void scheduleLayoutSave()
	{
		if (layoutSaveTimer.isRunning())
		{
			layoutSaveTimer.restart();
		}
		else
		{
			layoutSaveTimer.start();
		}
	}


	public void saveEditorLayout()
	{
		try
		{
			EditorLayout layout = new EditorLayout();

			// Save current active state
			if (activePaneGroup != null)
			{
				layout.setActivePaneGroupId(activePaneGroup.getPaneGroupId());
			}
			if (activeNoteId != null)
			{
				layout.setActiveNoteId(activeNoteId);
			}

			// Save each pane group
			for (int i = 0; i < paneGroups.size(); i++)
			{
				NotePaneGroup paneGroup = paneGroups.get(i);
				EditorLayout.PaneGroupLayout paneLayout = new EditorLayout.PaneGroupLayout(
					paneGroup.getPaneGroupId(), i);

				// Get all note IDs from this pane group
				JTabbedPane tabbedPane = paneGroup.getTabbedPane();
				for (int j = 0; j < paneGroup.getTabCount(); j++)
				{
					String noteId = (String) tabbedPane.getClientProperty("noteId_" + j);
					if (noteId != null)
					{
						paneLayout.addNoteId(noteId);
					}
				}

				// Set active note for this pane
				if (paneGroup.getCurrentNoteId() != null)
				{
					paneLayout.setActiveNoteId(paneGroup.getCurrentNoteId());
				}

				layout.addPaneGroup(paneLayout);
			}

			// Save to storage
			storageService.saveEditorLayout(layout);


		}
		catch (Exception e)
		{
			log.warn("Failed to save editor layout", e);
		}
	}


	public void switchProfile(String newProfile)
	{
		try
		{
			log.debug("Switching to profile: {}", newProfile);

			// Save current state before switching
			try
			{
				saveAllNotes();
				saveEditorLayout();
				log.debug("Saved current profile state before switching");
			}
			catch (Exception e)
			{
				log.warn("Failed to save current state before profile switch", e);
			}

			SwingUtilities.invokeLater(() -> {
				try
				{
					// Clear all pane groups
					paneGroups.clear();
					mainContentPanel.removeAll();
					activePaneGroup = null;
					activeNoteId = null;

					// Create fresh initial pane group
					createInitialPaneGroup();

					// Load notes for new profile
					restoreEditorLayout();

					log.debug("Successfully switched to profile: {}", storageService.getDisplayProfileName());

				}
				catch (Exception e)
				{
					log.error("Error during profile switch UI update", e);
				}
			});

		}
		catch (Exception e)
		{
			log.error("Failed to switch profile", e);
		}
	}

	public void cleanup()
	{
		try
		{
			// Save everything before cleanup
			saveAllNotes();
			saveEditorLayout();

			// Stop auto-save timer
			if (autoSaveTimer != null)
			{
				autoSaveTimer.stop();
			}

			paneGroups.clear();

		}
		catch (Exception e)
		{
			log.error("Error during NotesPanel cleanup", e);
		}
	}
}
package dev.seafoo.richtextnotes.ui.popups;

import dev.seafoo.richtextnotes.services.ItemIconService;
import dev.seafoo.richtextnotes.ui.components.AsyncImageIcon;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.event.FocusAdapter;
import java.awt.event.FocusEvent;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.function.Consumer;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JScrollPane;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

/**
 * Discord-style emoji picker popup for item selection
 */
@Slf4j
public class ItemSearchPopup extends JPopupMenu
{

	// Result callback
	private Consumer<ItemSearchResult> resultCallback;

	// UI Components
	private final JTextField searchField;
	private final JTextField quantityField;
	private final JPanel itemGridPanel;

	// Services
	private final ItemIconService itemIconService;

	// Category system
	private String currentCategory = "Search";
	private final java.util.List<CategoryItem> currentSearchResults = new ArrayList<>();

	// Grid settings
	private static final int GRID_COLUMNS = 6;
	private static final int ITEM_PADDING = 2;
	private static final int POPUP_WIDTH = 220;
	private static final int POPUP_HEIGHT = 260;

	public ItemSearchPopup(ItemIconService itemIconService)
	{
		this.itemIconService = itemIconService;
		this.itemGridPanel = new JPanel();
		this.searchField = new JTextField();
		this.quantityField = new JTextField("1");

		setupPopup();
		setupComponents();
		setupPopupHandling();
	}


	private void setupPopup()
	{
		setBackground(ColorScheme.DARK_GRAY_COLOR);
		setBorder(BorderFactory.createCompoundBorder(
			BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_HOVER_COLOR, 1),
			BorderFactory.createEmptyBorder(1, 1, 1, 1)
		));
		setFocusable(true);
	}

	private void setupComponents()
	{
		// Create main content panel
		JPanel mainContentPanel = new JPanel(new BorderLayout());
		mainContentPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		mainContentPanel.setPreferredSize(new Dimension(POPUP_WIDTH, POPUP_HEIGHT));

		// Compact search field with quantity
		JPanel searchPanel = createCompactSearchPanel();
		mainContentPanel.add(searchPanel, BorderLayout.NORTH);

		// Content area
		JPanel contentPanel = new JPanel(new BorderLayout());
		contentPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Item grid
		setupItemGrid();
		JScrollPane gridScrollPane = new JScrollPane(itemGridPanel);
		gridScrollPane.setBorder(BorderFactory.createEmptyBorder());
		gridScrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
		gridScrollPane.getVerticalScrollBar().setUnitIncrement(12);
		gridScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
		gridScrollPane.setPreferredSize(new Dimension(POPUP_WIDTH - 10, POPUP_HEIGHT - 10));
		contentPanel.add(gridScrollPane, BorderLayout.CENTER);

		mainContentPanel.add(contentPanel, BorderLayout.CENTER);

		// Add main content to popup menu
		add(mainContentPanel);

		// Start with search category
		showSearchCategory();
	}

	private JPanel createCompactSearchPanel()
	{
		JPanel searchPanel = new JPanel(new BorderLayout());
		searchPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		searchPanel.setBorder(new EmptyBorder(8, 8, 5, 8));

		// Create main search area
		JPanel searchInputPanel = new JPanel(new BorderLayout(5, 0));
		searchInputPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Search field (main area)
		searchField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		searchField.setForeground(Color.WHITE);
		searchField.setCaretColor(Color.WHITE);
		searchField.setBorder(BorderFactory.createCompoundBorder(
			BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_HOVER_COLOR),
			new EmptyBorder(6, 8, 6, 8)
		));
		searchField.setFont(searchField.getFont().deriveFont(11f));

		// Placeholder text
		searchField.setText("Search items...");
		searchField.setForeground(Color.GRAY);

		searchField.addFocusListener(new FocusAdapter()
		{
			@Override
			public void focusGained(FocusEvent e)
			{
				if ("Search items...".equals(searchField.getText()))
				{
					searchField.setText("");
					searchField.setForeground(Color.WHITE);
				}
			}

			@Override
			public void focusLost(FocusEvent e)
			{
				if (searchField.getText().trim().isEmpty())
				{
					searchField.setText("Search items...");
					searchField.setForeground(Color.GRAY);
				}
			}
		});

		// Real-time search
		searchField.getDocument().addDocumentListener(new DocumentListener()
		{
			@Override
			public void insertUpdate(DocumentEvent e)
			{
				performSearch();
			}

			@Override
			public void removeUpdate(DocumentEvent e)
			{
				performSearch();
			}

			@Override
			public void changedUpdate(DocumentEvent e)
			{
				performSearch();
			}
		});

		// Escape to close
		searchField.addKeyListener(new KeyAdapter()
		{
			@Override
			public void keyPressed(KeyEvent e)
			{
				if (e.getKeyCode() == KeyEvent.VK_ESCAPE)
				{
					setVisible(false);
				}
			}
		});

		searchInputPanel.add(searchField, BorderLayout.CENTER);

		// Quantity panel (right side)
		JPanel quantityPanel = new JPanel(new BorderLayout(3, 0));
		quantityPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		JLabel qtyLabel = new JLabel("Qty:");
		qtyLabel.setForeground(Color.WHITE);
		qtyLabel.setFont(qtyLabel.getFont().deriveFont(10f));
		quantityPanel.add(qtyLabel, BorderLayout.WEST);

		// Quantity field
		quantityField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		quantityField.setForeground(Color.WHITE);
		quantityField.setCaretColor(Color.WHITE);
		quantityField.setBorder(BorderFactory.createCompoundBorder(
			BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_HOVER_COLOR),
			new EmptyBorder(6, 6, 6, 6)
		));
		quantityField.setFont(quantityField.getFont().deriveFont(11f));
		quantityField.setPreferredSize(new Dimension(40, 25));
		quantityField.setHorizontalAlignment(JTextField.CENTER);

		// Validate quantity input - only allow numbers
		quantityField.addKeyListener(new KeyAdapter()
		{
			@Override
			public void keyTyped(KeyEvent e)
			{
				char c = e.getKeyChar();
				if (!Character.isDigit(c) && c != KeyEvent.VK_BACK_SPACE && c != KeyEvent.VK_DELETE)
				{
					e.consume();
				}
			}

			@Override
			public void keyPressed(KeyEvent e)
			{
				if (e.getKeyCode() == KeyEvent.VK_ESCAPE)
				{
					setVisible(false);
				}
			}
		});

		quantityPanel.add(quantityField, BorderLayout.CENTER);

		searchInputPanel.add(quantityPanel, BorderLayout.EAST);
		searchPanel.add(searchInputPanel, BorderLayout.CENTER);

		return searchPanel;
	}

	private void setupItemGrid()
	{
		itemGridPanel.setLayout(new GridBagLayout());
		itemGridPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		itemGridPanel.setBorder(new EmptyBorder(2, 4, 4, 4));
	}


	private void showSearchCategory()
	{
		String searchText = searchField.getText().trim();
		if (searchText.isEmpty() || "Search items...".equals(searchText))
		{
			showPlaceholder("Type to search...");
		}
	}


	private void showPlaceholder(String message)
	{
		itemGridPanel.removeAll();

		JLabel placeholder = new JLabel(message, JLabel.CENTER);
		placeholder.setForeground(Color.LIGHT_GRAY);
		placeholder.setFont(placeholder.getFont().deriveFont(Font.ITALIC, 11f));

		GridBagConstraints gbc = new GridBagConstraints();
		gbc.gridx = 0;
		gbc.gridy = 0;
		gbc.weightx = 1.0;
		gbc.weighty = 1.0;
		gbc.anchor = GridBagConstraints.CENTER;

		itemGridPanel.add(placeholder, gbc);
		itemGridPanel.revalidate();
		itemGridPanel.repaint();
	}

	private void displayItemsInGrid(java.util.List<CategoryItem> items)
	{
		itemGridPanel.removeAll();

		GridBagConstraints gbc = new GridBagConstraints();
		gbc.insets = new Insets(ITEM_PADDING, ITEM_PADDING, ITEM_PADDING, ITEM_PADDING);

		int col = 0;
		int row = 0;

		for (CategoryItem item : items)
		{
			JButton itemButton = createItemButton(item);

			gbc.gridx = col;
			gbc.gridy = row;
			gbc.weightx = 0;
			gbc.weighty = 0;
			gbc.anchor = GridBagConstraints.CENTER;

			itemGridPanel.add(itemButton, gbc);

			col++;
			if (col >= GRID_COLUMNS)
			{
				col = 0;
				row++;
			}
		}

		// Add spacer to push items to top
		gbc.gridx = 0;
		gbc.gridy = row + 1;
		gbc.gridwidth = GRID_COLUMNS + 1;
		gbc.weightx = 1.0;
		gbc.weighty = 1.0;
		gbc.fill = GridBagConstraints.BOTH;
		itemGridPanel.add(Box.createGlue(), gbc);

		itemGridPanel.revalidate();
		itemGridPanel.repaint();
	}

	private JButton createItemButton(CategoryItem item)
	{
		JButton button = new JButton();
		button.setPreferredSize(new Dimension(32, 28));
		button.setMinimumSize(new Dimension(32, 28));
		button.setFocusPainted(false);
		button.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		button.setBorder(BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_COLOR, 1));
		button.setToolTipText(item.displayName);

		// Try to load icon with async handling
		try
		{
			net.runelite.client.util.AsyncBufferedImage itemImage =
				itemIconService.getItemImageById(item.itemId);
			if (itemImage != null)
			{
				// Use AsyncImageIcon and attach to button for proper loading
				AsyncImageIcon icon = AsyncImageIcon.createAndAttach(itemImage, button);
				button.setIcon(icon);
			}
			else
			{
				// Fallback text display
				button.setText(item.displayName.substring(0, Math.min(2, item.displayName.length())));
				button.setFont(button.getFont().deriveFont(9f));
				button.setForeground(Color.WHITE);
			}
		}
		catch (Exception e)
		{
			button.setText(item.displayName.substring(0, Math.min(2, item.displayName.length())));
			button.setFont(button.getFont().deriveFont(9f));
			button.setForeground(Color.WHITE);
		}

		// Click handler
		button.addActionListener(e -> selectItem(item));

		// Hover effect
		button.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseEntered(MouseEvent e)
			{
				button.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
				button.setBorder(BorderFactory.createLineBorder(ColorScheme.DARK_GRAY_COLOR, 1));
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				button.setBackground(ColorScheme.DARKER_GRAY_COLOR);
				button.setBorder(BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_COLOR, 1));
			}
		});

		return button;
	}

	private void performSearch()
	{
		String query = searchField.getText().trim();

		if (query.isEmpty() || "Search items...".equals(query))
		{
			if ("Search".equals(currentCategory))
			{
				showPlaceholder("Type to search...");
			}
			return;
		}

		if (itemIconService == null)
		{
			showPlaceholder("Service not ready...");
			return;
		}

		// Use ItemIconService for search
		itemIconService.searchItems(query, results -> {
			// Convert to CategoryItem list (limit for popup)
			currentSearchResults.clear();
			int count = 0;
			for (ItemIconService.ItemSearchResult result : results)
			{
				if (count >= 60)
				{
					break; // Limit results for popup
				}
				currentSearchResults.add(new CategoryItem(
					result.getName(),
					result.getId(),
					result.getSearchName()
				));
				count++;
			}

			// Only update grid if we're still in search mode
			if ("Search".equals(currentCategory))
			{
				if (currentSearchResults.isEmpty())
				{
					showPlaceholder("No items found");
				}
				else
				{
					displayItemsInGrid(currentSearchResults);
				}
			}
		});
	}

	private void selectItem(CategoryItem item)
	{
		if (resultCallback != null)
		{
			int quantity = parseQuantityFromField();
			resultCallback.accept(new ItemSearchResult(item.itemId, item.searchName, quantity));
		}
		setVisible(false);
	}

	/**
	 * Parse quantity from the quantity field, defaulting to 1 if invalid
	 */
	private int parseQuantityFromField()
	{
		try
		{
			String qtyText = quantityField.getText().trim();
			if (qtyText.isEmpty())
			{
				return 1;
			}

			int quantity = Integer.parseInt(qtyText);
			return Math.max(1, quantity); // Ensure minimum quantity of 1
		}
		catch (NumberFormatException e)
		{
			return 1; // Default to 1 if parsing fails
		}
	}

	private void setupPopupHandling()
	{
		addPopupMenuListener(new PopupMenuListener()
		{
			@Override
			public void popupMenuWillBecomeVisible(PopupMenuEvent e)
			{
				// Focus the search field when popup becomes visible
				SwingUtilities.invokeLater(() -> {
					searchField.requestFocusInWindow();
					if ("Search items...".equals(searchField.getText()))
					{
						searchField.selectAll();
					}
				});
			}

			@Override
			public void popupMenuWillBecomeInvisible(PopupMenuEvent e)
			{
				// Reset state when popup closes
				currentSearchResults.clear();
				quantityField.setText("1"); // Reset quantity to 1
			}

			@Override
			public void popupMenuCanceled(PopupMenuEvent e)
			{
				// Handle cancel
			}
		});
	}

	/**
	 * Show the popup at the specified location
	 */
	public void showPopup(Component invoker, int x, int y, Consumer<ItemSearchResult> callback)
	{
		this.resultCallback = callback;

		// Reset state
		currentSearchResults.clear();
		searchField.setText("Search items...");
		searchField.setForeground(Color.GRAY);
		quantityField.setText("1"); // Reset quantity to 1

		// Start with search category
		showSearchCategory();

		// Show the popup menu
		show(invoker, x, y);
	}

	/**
	 * Result class for popup return value
	 */
	@Getter
	public static class ItemSearchResult
	{
		private final int itemId;
		private final String itemName;
		private final int quantity;

		public ItemSearchResult(int itemId, String itemName, int quantity)
		{
			this.itemId = itemId;
			this.itemName = itemName;
			this.quantity = Math.max(1, quantity); // Ensure minimum quantity of 1
		}

	}

	/**
	 * Internal class for category items
	 */
	private static class CategoryItem
	{
		final String displayName;
		final int itemId;
		final String searchName;

		CategoryItem(String displayName, int itemId, String searchName)
		{
			this.displayName = displayName;
			this.itemId = itemId;
			this.searchName = searchName;
		}
	}
}
package dev.seafoo.richtextnotes.ui.popups;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import java.util.List;
import javax.swing.BorderFactory;
import javax.swing.DefaultListModel;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import lombok.Getter;
import net.runelite.client.ui.ColorScheme;

public class TagEditDialog extends JDialog
{
	private final List<String> tags;
	@Getter
	private boolean okPressed = false;

	private JTextField newTagField;
	private DefaultListModel<String> tagListModel;
	private JList<String> tagList;
	private String noteTitle;

	public TagEditDialog(JComponent parent, List<String> currentTags, String noteTitle)
	{
		super(SwingUtilities.getWindowAncestor(parent), "Edit Tags", ModalityType.APPLICATION_MODAL);
		this.tags = new ArrayList<>(currentTags);
		this.noteTitle = noteTitle;

		setupDialog();
		setLocationRelativeTo(parent);
	}

	private void setupDialog()
	{
		setLayout(new BorderLayout());
		setSize(300, 400);
		setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);

		// Create main panel
		JPanel mainPanel = new JPanel(new BorderLayout());
		mainPanel.setBorder(new EmptyBorder(10, 10, 10, 10));
		mainPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Title label
		JLabel titleLabel = new JLabel(noteTitle);
		titleLabel.setForeground(Color.WHITE);
		titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD, 14f));
		mainPanel.add(titleLabel, BorderLayout.NORTH);

		// Center panel for tag list and controls
		JPanel centerPanel = new JPanel(new BorderLayout());
		centerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		centerPanel.setBorder(new EmptyBorder(10, 0, 10, 0));

		// Tag list
		tagListModel = new DefaultListModel<>();
		for (String tag : tags)
		{
			tagListModel.addElement(tag);
		}

		tagList = new JList<>(tagListModel);
		tagList.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		tagList.setForeground(Color.WHITE);
		tagList.setSelectionBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
		tagList.setBorder(new EmptyBorder(5, 5, 5, 5));

		JScrollPane scrollPane = new JScrollPane(tagList);
		scrollPane.setPreferredSize(new Dimension(250, 200));
		scrollPane.setBorder(BorderFactory.createTitledBorder(
			BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_HOVER_COLOR),
			"Current Tags",
			0, 0, null, Color.WHITE
		));
		centerPanel.add(scrollPane, BorderLayout.CENTER);

		// Add tag panel
		JPanel addTagPanel = new JPanel(new BorderLayout());
		addTagPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		addTagPanel.setBorder(new EmptyBorder(5, 0, 0, 0));

		newTagField = new JTextField();
		newTagField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		newTagField.setForeground(Color.WHITE);
		newTagField.setCaretColor(Color.WHITE);
		newTagField.setBorder(BorderFactory.createCompoundBorder(
			BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_HOVER_COLOR),
			new EmptyBorder(5, 5, 5, 5)
		));

		// Add tag on Enter key
		newTagField.addKeyListener(new KeyAdapter()
		{
			@Override
			public void keyPressed(KeyEvent e)
			{
				if (e.getKeyCode() == KeyEvent.VK_ENTER)
				{
					addTag();
				}
			}
		});

		JButton addButton = new JButton("Add Tag");
		addButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		addButton.setForeground(Color.WHITE);
		addButton.setFocusPainted(false);
		addButton.addActionListener(e -> addTag());

		addTagPanel.add(newTagField, BorderLayout.CENTER);
		addTagPanel.add(addButton, BorderLayout.EAST);
		centerPanel.add(addTagPanel, BorderLayout.SOUTH);

		mainPanel.add(centerPanel, BorderLayout.CENTER);

		// Button panel
		JPanel buttonPanel = new JPanel(new FlowLayout());
		buttonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		JButton removeButton = new JButton("Remove Selected");
		removeButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		removeButton.setForeground(Color.WHITE);
		removeButton.setFocusPainted(false);
		removeButton.addActionListener(e -> removeSelectedTag());
		buttonPanel.add(removeButton);

		JButton okButton = new JButton("OK");
		okButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		okButton.setForeground(Color.WHITE);
		okButton.setFocusPainted(false);
		okButton.addActionListener(e -> {
			okPressed = true;
			dispose();
		});
		buttonPanel.add(okButton);

		JButton cancelButton = new JButton("Cancel");
		cancelButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		cancelButton.setForeground(Color.WHITE);
		cancelButton.setFocusPainted(false);
		cancelButton.addActionListener(e -> dispose());
		buttonPanel.add(cancelButton);

		mainPanel.add(buttonPanel, BorderLayout.SOUTH);

		add(mainPanel);

		// Make the dialog look consistent with RuneLite
		getContentPane().setBackground(ColorScheme.DARK_GRAY_COLOR);
	}

	private void addTag()
	{
		String newTag = newTagField.getText().trim();
		if (!newTag.isEmpty() && !tags.contains(newTag))
		{
			tags.add(newTag);
			tagListModel.addElement(newTag);
			newTagField.setText("");
			newTagField.requestFocus();
		}
	}

	private void removeSelectedTag()
	{
		int selectedIndex = tagList.getSelectedIndex();
		if (selectedIndex >= 0)
		{
			String selectedTag = tagListModel.getElementAt(selectedIndex);
			tags.remove(selectedTag);
			tagListModel.removeElementAt(selectedIndex);
		}
	}

	public List<String> getTags()
	{
		return new ArrayList<>(tags);
	}
}

package dev.seafoo.richtextnotes.ui.popups;

import dev.seafoo.richtextnotes.models.NoteMetadata;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTable;
import javax.swing.JTextField;
import javax.swing.ListSelectionModel;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import javax.swing.border.TitledBorder;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.TableRowSorter;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

/**
 * Enhanced dialog for selecting notes with search, tag filtering, and sorting
 */
@Slf4j
public class NoteSelectionDialog extends JDialog
{

	private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern("MMM dd, yyyy HH:mm");

	// Data
	private final List<NoteMetadata> allNotes;
	private List<NoteMetadata> filteredNotes;
	private Set<String> allTags;
	@Getter
	private NoteMetadata selectedNote = null;
	// Public accessors
	@Getter
	private boolean okPressed = false;

	// UI Components
	private JTextField searchField;
	private JPanel tagFilterPanel;
	private JScrollPane tagFilterScrollPane;
	private Map<String, JCheckBox> tagCheckBoxes;
	private JTable notesTable;
	private NoteTableModel tableModel;
	private TableRowSorter<NoteTableModel> tableSorter;
	private JButton okButton;
	private JButton cancelButton;
	private JLabel resultCountLabel;

	// Search and filter state
	private String currentSearchText = "";
	private Set<String> selectedTags = new HashSet<>();

	public NoteSelectionDialog(JComponent parent, List<NoteMetadata> notes)
	{
		super(SwingUtilities.getWindowAncestor(parent), "Open Existing Note", ModalityType.APPLICATION_MODAL);
		this.allNotes = new ArrayList<>(notes);
		this.filteredNotes = new ArrayList<>(notes);

		extractAllTags();
		setupDialog();
		updateFilteredNotes();
		setLocationRelativeTo(parent);
	}

	private void extractAllTags()
	{
		allTags = new HashSet<>();
		for (NoteMetadata note : allNotes)
		{
			if (note.getTags() != null)
			{
				allTags.addAll(note.getTags());
			}
		}
	}

	private void setupDialog()
	{
		setLayout(new BorderLayout());
		setSize(800, 500);
		setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
		setResizable(true);

		// Main panel
		JPanel mainPanel = new JPanel(new BorderLayout());
		mainPanel.setBorder(new EmptyBorder(10, 10, 10, 10));
		mainPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Top panel with search only
		JPanel topPanel = createTopPanel();
		mainPanel.add(topPanel, BorderLayout.NORTH);

		// Center panel with horizontal split: tags left, notes right
		JSplitPane splitPane = createMainSplitPane();
		mainPanel.add(splitPane, BorderLayout.CENTER);

		// Bottom panel with buttons
		JPanel bottomPanel = createBottomPanel();
		mainPanel.add(bottomPanel, BorderLayout.SOUTH);

		add(mainPanel);

		// Make dialog look consistent with RuneLite
		getContentPane().setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Set initial focus
		SwingUtilities.invokeLater(() -> searchField.requestFocus());
	}

	private JPanel createTopPanel()
	{
		JPanel topPanel = new JPanel(new BorderLayout());
		topPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		topPanel.setBorder(new EmptyBorder(0, 0, 10, 0));

		// Search panel only
		JPanel searchPanel = createSearchPanel();
		topPanel.add(searchPanel, BorderLayout.CENTER);

		return topPanel;
	}

	private JSplitPane createMainSplitPane()
	{
		// Left panel: Tag filters
		JPanel leftPanel = createTagFilterPanel();
		leftPanel.setPreferredSize(new Dimension(220, 0));
		leftPanel.setMinimumSize(new Dimension(180, 0));

		// Right panel: Notes table
		JPanel rightPanel = createNotesPanel();

		// Create split pane
		JSplitPane splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, leftPanel, rightPanel);
		splitPane.setDividerLocation(220);
		splitPane.setResizeWeight(0.0); // Give all extra space to the right panel
		splitPane.setContinuousLayout(true);
		splitPane.setOneTouchExpandable(false);
		splitPane.setBorder(BorderFactory.createEmptyBorder());
		splitPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
		splitPane.setDividerSize(6);

		return splitPane;
	}

	private JPanel createSearchPanel()
	{
		JPanel searchPanel = new JPanel(new BorderLayout());
		searchPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		JLabel searchLabel = new JLabel("Search:");
		searchLabel.setForeground(Color.WHITE);
		searchLabel.setBorder(new EmptyBorder(0, 0, 0, 5));
		searchPanel.add(searchLabel, BorderLayout.WEST);

		searchField = new JTextField();
		searchField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		searchField.setForeground(Color.WHITE);
		searchField.setCaretColor(Color.WHITE);
		searchField.setBorder(BorderFactory.createCompoundBorder(
			BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_HOVER_COLOR),
			new EmptyBorder(5, 8, 5, 8)
		));

		// Real-time search
		searchField.getDocument().addDocumentListener(new DocumentListener()
		{
			@Override
			public void insertUpdate(DocumentEvent e)
			{
				onSearchChanged();
			}

			@Override
			public void removeUpdate(DocumentEvent e)
			{
				onSearchChanged();
			}

			@Override
			public void changedUpdate(DocumentEvent e)
			{
				onSearchChanged();
			}
		});

		searchPanel.add(searchField, BorderLayout.CENTER);

		// Clear search button
		JButton clearButton = new JButton("Clear");
		clearButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		clearButton.setForeground(Color.WHITE);
		clearButton.setFocusPainted(false);
		clearButton.addActionListener(e -> {
			searchField.setText("");
			searchField.requestFocus();
		});
		searchPanel.add(clearButton, BorderLayout.EAST);

		return searchPanel;
	}

	private JPanel createTagFilterPanel()
	{
		JPanel container = new JPanel(new BorderLayout());
		container.setBackground(ColorScheme.DARK_GRAY_COLOR);
		container.setBorder(BorderFactory.createTitledBorder(
			BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_HOVER_COLOR),
			"Filter by Tags",
			TitledBorder.DEFAULT_JUSTIFICATION,
			TitledBorder.DEFAULT_POSITION,
			null,
			Color.WHITE
		));

		// Tag count label
		JLabel tagCountLabel = new JLabel(allTags.size() + " available tags");
		tagCountLabel.setForeground(Color.LIGHT_GRAY);
		tagCountLabel.setFont(tagCountLabel.getFont().deriveFont(10f));
		tagCountLabel.setBorder(new EmptyBorder(5, 5, 5, 5));
		container.add(tagCountLabel, BorderLayout.NORTH);

		// Tag checkboxes panel
		JPanel tagCheckboxContainer = new JPanel();
		tagCheckboxContainer.setLayout(new BoxLayout(tagCheckboxContainer, BoxLayout.Y_AXIS));
		tagCheckboxContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		tagFilterPanel = new JPanel(new BorderLayout());
		tagFilterPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		tagFilterPanel.setBorder(new EmptyBorder(5, 5, 5, 5));

		tagCheckBoxes = new HashMap<>();

		// Create "All Tags" checkbox
		JCheckBox allTagsCheckBox = new JCheckBox("(All Tags)");
		allTagsCheckBox.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		allTagsCheckBox.setForeground(Color.WHITE);
		allTagsCheckBox.setSelected(true);
		allTagsCheckBox.addActionListener(e -> {
			if (allTagsCheckBox.isSelected())
			{
				// Uncheck all individual tags
				selectedTags.clear();
				for (JCheckBox cb : tagCheckBoxes.values())
				{
					cb.setSelected(false);
				}
			}
			updateFilteredNotes();
		});
		tagCheckboxContainer.add(allTagsCheckBox);

		if (!allTags.isEmpty())
		{
			// Add separator
			JSeparator separator = new JSeparator();
			separator.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
			separator.setForeground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
			tagCheckboxContainer.add(Box.createVerticalStrut(3));
			tagCheckboxContainer.add(separator);
			tagCheckboxContainer.add(Box.createVerticalStrut(3));

			// Sort tags alphabetically
			List<String> sortedTags = new ArrayList<>(allTags);
			sortedTags.sort(String.CASE_INSENSITIVE_ORDER);

			// Create individual tag checkboxes
			for (String tag : sortedTags)
			{
				JCheckBox tagCheckBox = new JCheckBox(tag);
				tagCheckBox.setBackground(ColorScheme.DARKER_GRAY_COLOR);
				tagCheckBox.setForeground(Color.WHITE);
				tagCheckBox.addActionListener(e -> {
					// Update selected tags
					if (tagCheckBox.isSelected())
					{
						selectedTags.add(tag);
						allTagsCheckBox.setSelected(false);
					}
					else
					{
						selectedTags.remove(tag);
						if (selectedTags.isEmpty())
						{
							allTagsCheckBox.setSelected(true);
						}
					}
					updateFilteredNotes();
				});

				tagCheckBoxes.put(tag, tagCheckBox);
				tagCheckboxContainer.add(tagCheckBox);
			}
		}

		// Add the checkbox container to the NORTH of the BorderLayout
		tagFilterPanel.add(tagCheckboxContainer, BorderLayout.NORTH);

		// Scroll pane for tags
		tagFilterScrollPane = new JScrollPane(tagFilterPanel);
		tagFilterScrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
		tagFilterScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
		tagFilterScrollPane.setBorder(BorderFactory.createEmptyBorder());

		container.add(tagFilterScrollPane, BorderLayout.CENTER);

		return container;
	}

	private JPanel createNotesPanel()
	{
		JPanel notesPanel = new JPanel(new BorderLayout());
		notesPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		notesPanel.setBorder(BorderFactory.createTitledBorder(
			BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_HOVER_COLOR),
			"Notes",
			TitledBorder.DEFAULT_JUSTIFICATION,
			TitledBorder.DEFAULT_POSITION,
			null,
			Color.WHITE
		));

		// Result count label
		resultCountLabel = new JLabel();
		resultCountLabel.setForeground(Color.WHITE);
		resultCountLabel.setBorder(new EmptyBorder(5, 5, 5, 5));
		notesPanel.add(resultCountLabel, BorderLayout.NORTH);

		// Notes table
		tableModel = new NoteTableModel();
		notesTable = new JTable(tableModel);

		// Enable column sorting
		tableSorter = new TableRowSorter<>(tableModel);
		notesTable.setRowSorter(tableSorter);

		// Configure table appearance
		notesTable.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		notesTable.setForeground(Color.WHITE);
		notesTable.setSelectionBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
		notesTable.setSelectionForeground(Color.WHITE);
		notesTable.setGridColor(ColorScheme.DARK_GRAY_COLOR);
		notesTable.setRowHeight(24);
		notesTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);

		// Configure column widths
		notesTable.getColumnModel().getColumn(0).setPreferredWidth(200); // Title
		notesTable.getColumnModel().getColumn(1).setPreferredWidth(120); // Created
		notesTable.getColumnModel().getColumn(2).setPreferredWidth(120); // Modified
		notesTable.getColumnModel().getColumn(3).setPreferredWidth(150); // Tags

		// Custom cell renderer for better appearance
		DefaultTableCellRenderer cellRenderer = new DefaultTableCellRenderer()
		{
			@Override
			public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected,
														   boolean hasFocus, int row, int column)
			{
				super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);

				if (isSelected)
				{
					setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
					setForeground(Color.WHITE);
				}
				else
				{
					setBackground(ColorScheme.DARKER_GRAY_COLOR);
					setForeground(Color.WHITE);
				}

				setBorder(new EmptyBorder(2, 5, 2, 5));

				return this;
			}
		};

		for (int i = 0; i < notesTable.getColumnCount(); i++)
		{
			notesTable.getColumnModel().getColumn(i).setCellRenderer(cellRenderer);
		}

		// Configure table header
		notesTable.getTableHeader().setBackground(ColorScheme.DARK_GRAY_COLOR);
		notesTable.getTableHeader().setForeground(Color.WHITE);
		notesTable.getTableHeader().setBorder(BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_HOVER_COLOR));

		// Double-click to select
		notesTable.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				if (e.getClickCount() == 2)
				{
					selectNote();
				}
			}
		});

		// Selection change listener
		notesTable.getSelectionModel().addListSelectionListener(e -> {
			if (!e.getValueIsAdjusting())
			{
				int selectedRow = notesTable.getSelectedRow();
				okButton.setEnabled(selectedRow >= 0);
			}
		});

		JScrollPane tableScrollPane = new JScrollPane(notesTable);
		tableScrollPane.setBorder(BorderFactory.createEmptyBorder());

		notesPanel.add(tableScrollPane, BorderLayout.CENTER);

		return notesPanel;
	}

	private JPanel createBottomPanel()
	{
		JPanel bottomPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
		bottomPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		bottomPanel.setBorder(new EmptyBorder(10, 0, 0, 0));

		okButton = new JButton("Open Note");
		okButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		okButton.setForeground(Color.WHITE);
		okButton.setFocusPainted(false);
		okButton.setEnabled(false);
		okButton.addActionListener(e -> selectNote());
		bottomPanel.add(okButton);

		cancelButton = new JButton("Cancel");
		cancelButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		cancelButton.setForeground(Color.WHITE);
		cancelButton.setFocusPainted(false);
		cancelButton.addActionListener(e -> dispose());
		bottomPanel.add(cancelButton);

		return bottomPanel;
	}

	private void onSearchChanged()
	{
		currentSearchText = searchField.getText().trim().toLowerCase();
		updateFilteredNotes();
	}

	private void updateFilteredNotes()
	{
		// Apply filters
		filteredNotes = allNotes.stream()
			.filter(this::matchesSearchFilter)
			.filter(this::matchesTagFilter)
			.collect(Collectors.toList());

		// Update table
		tableModel.fireTableDataChanged();

		// Update result count
		updateResultCount();

		// Clear selection if needed
		if (notesTable.getSelectedRow() >= filteredNotes.size())
		{
			notesTable.clearSelection();
		}
	}

	private boolean matchesSearchFilter(NoteMetadata note)
	{
		if (currentSearchText.isEmpty())
		{
			return true;
		}

		String title = note.getTitle() != null ? note.getTitle().toLowerCase() : "";
		return title.contains(currentSearchText);
	}

	private boolean matchesTagFilter(NoteMetadata note)
	{
		if (selectedTags.isEmpty())
		{
			return true; // "All Tags" mode
		}

		if (note.getTags() == null || note.getTags().isEmpty())
		{
			return false; // Note has no tags but we're filtering by tags
		}

		// Check if note has at least one of the selected tags
		return note.getTags().stream().anyMatch(selectedTags::contains);
	}

	private void updateResultCount()
	{
		String countText = String.format("Showing %d of %d notes", filteredNotes.size(), allNotes.size());
		if (!currentSearchText.isEmpty() || !selectedTags.isEmpty())
		{
			countText += " (filtered)";
		}
		resultCountLabel.setText(countText);
	}

	private void selectNote()
	{
		int selectedRow = notesTable.getSelectedRow();
		if (selectedRow >= 0)
		{
			// Convert view row to model row (accounts for sorting)
			int modelRow = notesTable.convertRowIndexToModel(selectedRow);
			if (modelRow >= 0 && modelRow < filteredNotes.size())
			{
				selectedNote = filteredNotes.get(modelRow);
				okPressed = true;
				dispose();
			}
		}
	}

	// Table model
	private class NoteTableModel extends AbstractTableModel
	{
		private final String[] columnNames = {"Title", "Created", "Modified", "Tags"};

		@Override
		public int getRowCount()
		{
			return filteredNotes.size();
		}

		@Override
		public int getColumnCount()
		{
			return columnNames.length;
		}

		@Override
		public String getColumnName(int column)
		{
			return columnNames[column];
		}

		@Override
		public Object getValueAt(int rowIndex, int columnIndex)
		{
			if (rowIndex >= filteredNotes.size())
			{
				return "";
			}

			NoteMetadata note = filteredNotes.get(rowIndex);

			switch (columnIndex)
			{
				case 0: // Title
					return note.getTitle() != null ? note.getTitle() : "Untitled Note";
				case 1: // Created
					return note.getCreatedDate() != null ?
						note.getCreatedDate().format(DATE_FORMATTER) : "";
				case 2: // Modified
					return note.getLastModified() != null ?
						note.getLastModified().format(DATE_FORMATTER) : "";
				case 3: // Tags
					if (note.getTags() == null || note.getTags().isEmpty())
					{
						return "";
					}
					return String.join(", ", note.getTags());
				default:
					return "";
			}
		}

		@Override
		public Class<?> getColumnClass(int columnIndex)
		{
			return String.class;
		}

	}
}
package dev.seafoo.richtextnotes.ui.popups;

import dev.seafoo.richtextnotes.services.ItemIconService;
import dev.seafoo.richtextnotes.ui.components.AsyncImageIcon;
import dev.seafoo.richtextnotes.ui.components.NotesEnhancedDocument;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Rectangle;
import java.awt.event.FocusAdapter;
import java.awt.event.FocusEvent;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.swing.BorderFactory;
import javax.swing.DefaultListCellRenderer;
import javax.swing.DefaultListModel;
import javax.swing.Icon;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JScrollPane;
import javax.swing.JTextPane;
import javax.swing.ListSelectionModel;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.SimpleAttributeSet;
import javax.swing.text.StyleConstants;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

/**
 * Discord-style inline autocomplete for item icons
 * Triggers when user types ":" followed by at least 2 characters
 */
@Slf4j
public class InlineItemAutoComplete
{

	private static final Pattern TRIGGER_PATTERN = Pattern.compile(":([a-zA-Z0-9_]{2,})$");
	private static final int MAX_SUGGESTIONS = 32;
	private static final int ITEM_HEIGHT = 28;
	private static final int POPUP_WIDTH = 180;

	private final JTextPane textPane;
	private final ItemIconService itemIconService;

	// Popup components
	private JPopupMenu popup;
	private JList<SuggestionItem> suggestionList;
	private DefaultListModel<SuggestionItem> listModel;
	private int triggerPosition = -1;
	private boolean isShowingPopup = false;

	public InlineItemAutoComplete(JTextPane textPane, ItemIconService itemIconService)
	{
		this.textPane = textPane;
		this.itemIconService = itemIconService;

		setupPopup();
		attachListeners();
	}

	private void setupPopup()
	{
		// Create popup menu
		popup = new JPopupMenu();
		popup.setBackground(ColorScheme.DARK_GRAY_COLOR);
		popup.setBorder(BorderFactory.createCompoundBorder(
			BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_HOVER_COLOR, 1),
			BorderFactory.createEmptyBorder(2, 2, 2, 2)
		));
		popup.setFocusable(false);

		// Create list model and list
		listModel = new DefaultListModel<>();
		suggestionList = new JList<>(listModel);
		suggestionList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		suggestionList.setBackground(ColorScheme.DARK_GRAY_COLOR);
		suggestionList.setForeground(Color.WHITE);
		suggestionList.setFixedCellHeight(ITEM_HEIGHT + 4);
		suggestionList.setCellRenderer(new SuggestionCellRenderer());

		// Setup list selection
		suggestionList.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				if (e.getClickCount() == 1)
				{
					insertSelectedItem();
				}
			}
		});

		// Add hover effect
		suggestionList.addMouseMotionListener(new MouseMotionAdapter()
		{
			@Override
			public void mouseMoved(MouseEvent e)
			{
				int index = suggestionList.locationToIndex(e.getPoint());
				if (index >= 0)
				{
					suggestionList.setSelectedIndex(index);
				}
			}
		});

		// Wrap in scroll pane
		JScrollPane scrollPane = new JScrollPane(suggestionList);
		scrollPane.setBorder(BorderFactory.createEmptyBorder());
		scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
		scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
		scrollPane.setPreferredSize(new Dimension(POPUP_WIDTH, 200));

		popup.add(scrollPane);
	}

	private void attachListeners()
	{
		// Document listener for text changes
		textPane.getDocument().addDocumentListener(new DocumentListener()
		{
			@Override
			public void insertUpdate(DocumentEvent e)
			{
				SwingUtilities.invokeLater(() -> checkForTrigger());
			}

			@Override
			public void removeUpdate(DocumentEvent e)
			{
				SwingUtilities.invokeLater(() -> checkForTrigger());
			}

			@Override
			public void changedUpdate(DocumentEvent e)
			{
				// Attribute changes, ignore
			}
		});

		// Key listener for navigation
		textPane.addKeyListener(new KeyAdapter()
		{
			@Override
			public void keyPressed(KeyEvent e)
			{
				if (isShowingPopup)
				{
					handlePopupKeyPress(e);
				}
			}
		});

		// Focus listener to hide popup
		textPane.addFocusListener(new FocusAdapter()
		{
			@Override
			public void focusLost(FocusEvent e)
			{
				// Hide popup when focus lost (unless focus went to popup)
				if (!popup.isFocusOwner() && !suggestionList.isFocusOwner())
				{
					hidePopup();
				}
			}
		});

		// Caret listener to hide popup when cursor moves away
		textPane.addCaretListener(e -> {
			if (isShowingPopup && triggerPosition >= 0)
			{
				int caretPos = e.getDot();
				// Hide if caret moved before the trigger
				if (caretPos < triggerPosition)
				{
					hidePopup();
				}
			}
		});
	}

	private void checkForTrigger()
	{
		try
		{
			int caretPos = textPane.getCaretPosition();
			if (caretPos == 0)
			{
				hidePopup();
				return;
			}

			// Get text before caret
			Document doc = textPane.getDocument();

			// Look back to find the start of the current word/trigger
			int searchStart = Math.max(0, caretPos - 50); // Look back up to 50 chars
			String textBefore = doc.getText(searchStart, caretPos - searchStart);

			// Check for trigger pattern
			Matcher matcher = TRIGGER_PATTERN.matcher(textBefore);
			String matchedQuery = null;
			int matchStart = -1;

			while (matcher.find())
			{
				matchedQuery = matcher.group(1);
				matchStart = searchStart + matcher.start();
			}

			if (matchedQuery != null)
			{
				// Found a trigger
				triggerPosition = matchStart;
				performSearch(matchedQuery);
			}
			else
			{
				// No trigger found
				hidePopup();
			}

		}
		catch (BadLocationException e)
		{
			log.error("Error checking for trigger", e);
			hidePopup();
		}
	}

	private void performSearch(String query)
	{
		if (itemIconService == null)
		{
			hidePopup();
			return;
		}

		// Replace spaces with underscores for the search
		String searchQuery = query.replace("_", " ");

		// Search for items
		itemIconService.searchItems(searchQuery, this::updateSuggestions);
	}

	private void updateSuggestions(List<ItemIconService.ItemSearchResult> results)
	{
		listModel.clear();

		if (results.isEmpty())
		{
			hidePopup();
			return;
		}

		// Add results to list (limit to MAX_SUGGESTIONS)
		int count = 0;
		for (ItemIconService.ItemSearchResult result : results)
		{
			if (count >= MAX_SUGGESTIONS)
			{
				break;
			}
			listModel.addElement(new SuggestionItem(result));
			count++;
		}

		// Select first item
		if (!listModel.isEmpty())
		{
			suggestionList.setSelectedIndex(0);
			showPopup();
		}
	}

	private void showPopup()
	{
		if (isShowingPopup)
		{
			// Just revalidate if already showing
			popup.revalidate();
			popup.repaint();
			return;
		}

		try
		{
			// Calculate popup position
			Rectangle caretBounds = (Rectangle) textPane.modelToView2D(textPane.getCaretPosition());
			if (caretBounds != null && textPane.isShowing())
			{

				// Adjust size based on content
				int itemCount = Math.min(listModel.size(), MAX_SUGGESTIONS);
				int popupHeight = Math.min(itemCount * ITEM_HEIGHT + 4, 300);
				popup.setPreferredSize(new Dimension(POPUP_WIDTH, popupHeight));

				// Show popup
				popup.show(textPane, caretBounds.x, caretBounds.y + caretBounds.height + 2);
				isShowingPopup = true;
			}
		}
		catch (BadLocationException e)
		{
			log.error("Error showing popup", e);
		}
	}

	private void hidePopup()
	{
		if (isShowingPopup)
		{
			popup.setVisible(false);
			isShowingPopup = false;
			triggerPosition = -1;
			listModel.clear();
		}
	}

	private void handlePopupKeyPress(KeyEvent e)
	{
		switch (e.getKeyCode())
		{
			case KeyEvent.VK_UP:
				e.consume();
				moveSelection(-1);
				break;

			case KeyEvent.VK_DOWN:
				e.consume();
				moveSelection(1);
				break;

			case KeyEvent.VK_ENTER:
			case KeyEvent.VK_TAB:
				e.consume();
				insertSelectedItem();
				break;

			case KeyEvent.VK_ESCAPE:
				e.consume();
				hidePopup();
				break;
		}
	}

	private void moveSelection(int direction)
	{
		if (listModel.isEmpty())
		{
			return;
		}

		int currentIndex = suggestionList.getSelectedIndex();
		int newIndex = currentIndex + direction;

		// Wrap around
		if (newIndex < 0)
		{
			newIndex = listModel.size() - 1;
		}
		else if (newIndex >= listModel.size())
		{
			newIndex = 0;
		}

		suggestionList.setSelectedIndex(newIndex);
		suggestionList.ensureIndexIsVisible(newIndex);
	}

	private void insertSelectedItem()
	{
		SuggestionItem selected = suggestionList.getSelectedValue();
		if (selected == null)
		{
			hidePopup();
			return;
		}

		try
		{
			Document doc = textPane.getDocument();

			// Calculate positions
			int replaceStart = triggerPosition;
			int replaceEnd = textPane.getCaretPosition();

			// Remove the trigger text (including the colon)
			doc.remove(replaceStart, replaceEnd - replaceStart);

			// Default quantity for autocomplete insertions
			int defaultQuantity = 1;

			// Insert the item icon with quantity
			Icon icon = itemIconService.getCenteredIconById(selected.result.getId(), defaultQuantity);
			if (icon != null)
			{
				// Attach icon for repaint
				if (icon instanceof ItemIconService.CenteredImageIcon)
				{
					((ItemIconService.CenteredImageIcon) icon).attachToComponent(textPane);
				}

				// Create attributes with icon and metadata
				SimpleAttributeSet attrs = new SimpleAttributeSet();
				StyleConstants.setIcon(attrs, icon);

				// Store metadata for saving/loading including quantity
				attrs.addAttribute("item-icon-data",
					new NotesEnhancedDocument.IconData(selected.result.getName(), selected.result.getId(), defaultQuantity));

				// Insert icon
				doc.insertString(replaceStart, " ", attrs);

				// Add a space after the icon
				doc.insertString(replaceStart + 1, " ", null);
			}

		}
		catch (BadLocationException e)
		{
			log.error("Error inserting item", e);
		}
		finally
		{
			hidePopup();
		}
	}

	/**
	 * Clean up resources
	 */
	public void cleanup()
	{
		hidePopup();
	}

	/**
	 * Suggestion item wrapper
	 */
	private static class SuggestionItem
	{
		final ItemIconService.ItemSearchResult result;

		SuggestionItem(ItemIconService.ItemSearchResult result)
		{
			this.result = result;
		}

		@Override
		public String toString()
		{
			return result.getName();
		}
	}

	/**
	 * Custom cell renderer for suggestions - simplified to remove shortcut label
	 */
	private class SuggestionCellRenderer extends DefaultListCellRenderer
	{
		private final JPanel panel;
		private final JLabel iconLabel;
		private final JLabel nameLabel;

		public SuggestionCellRenderer()
		{
			panel = new JPanel(new BorderLayout(5, 2));
			panel.setBorder(new EmptyBorder(2, 5, 2, 5));

			iconLabel = new JLabel();
			iconLabel.setPreferredSize(new Dimension(32, 28 + 4));
			iconLabel.setHorizontalAlignment(JLabel.CENTER);

			nameLabel = new JLabel();
			nameLabel.setFont(nameLabel.getFont().deriveFont(11f));

			panel.add(iconLabel, BorderLayout.WEST);
			panel.add(nameLabel, BorderLayout.CENTER);

		}

		@Override
		public Component getListCellRendererComponent(JList<?> list, Object value,
													  int index, boolean isSelected, boolean cellHasFocus)
		{

			if (value instanceof SuggestionItem)
			{
				SuggestionItem item = (SuggestionItem) value;

				// Set name
				nameLabel.setText(item.result.getName());


				try
				{
					net.runelite.client.util.AsyncBufferedImage itemImage =
						itemIconService.getItemImageById(item.result.getId()); // Increased icon size
					if (itemImage != null)
					{
						AsyncImageIcon icon = AsyncImageIcon.createAndAttach(itemImage, iconLabel);
						iconLabel.setIcon(icon);
						iconLabel.setText("");
					}
					else
					{
						iconLabel.setIcon(null);
						iconLabel.setText("?");
						iconLabel.setForeground(Color.GRAY);
					}
				}
				catch (Exception e)
				{
					iconLabel.setIcon(null);
					iconLabel.setText("?");
					iconLabel.setForeground(Color.GRAY);
				}

				// Set colors based on selection
				if (isSelected)
				{
					panel.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
					nameLabel.setForeground(Color.WHITE);
					if (iconLabel.getIcon() == null)
					{
						iconLabel.setForeground(Color.WHITE);
					}
				}
				else
				{
					panel.setBackground(ColorScheme.DARK_GRAY_COLOR);
					nameLabel.setForeground(Color.LIGHT_GRAY);
					if (iconLabel.getIcon() == null)
					{
						iconLabel.setForeground(Color.GRAY);
					}
				}
			}

			return panel;
		}
	}
}
package dev.seafoo.richtextnotes.ui.components;

import dev.seafoo.richtextnotes.services.ItemIconService;
import dev.seafoo.richtextnotes.ui.components.clipboard.EnhancedCopyAction;
import dev.seafoo.richtextnotes.ui.components.clipboard.EnhancedCutAction;
import dev.seafoo.richtextnotes.ui.components.clipboard.EnhancedPasteAction;
import java.awt.Color;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.HashMap;
import java.util.Map;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.JEditorPane;
import javax.swing.JTextPane;
import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.DefaultEditorKit;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.MutableAttributeSet;
import javax.swing.text.SimpleAttributeSet;
import javax.swing.text.Style;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyleContext;
import javax.swing.text.StyledDocument;
import javax.swing.text.StyledEditorKit;
import javax.swing.text.rtf.RTFEditorKit;
import javax.swing.undo.UndoManager;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

/**
 * Enhanced RTF Editor Kit with custom formatting actions, undo/redo support,
 * and improved copy/paste functionality that preserves internal icons while
 * stripping external formatting
 */
@Slf4j
public class NotesEnhancedEditorKit extends RTFEditorKit
{

	// Font size constants - normal is 16pt base
	public static final int FONT_SIZE_SMALLER = 12;
	public static final int FONT_SIZE_SMALL = 14;
	public static final int FONT_SIZE_NORMAL = 16;
	public static final int FONT_SIZE_BIG = 20;
	public static final int FONT_SIZE_BIGGER = 24;
	public static final int FONT_SIZE_HUGE = 28;

	// Style constants
	public static final String STYLE_SMALLER = "smaller";
	public static final String STYLE_SMALL = "small";
	public static final String STYLE_NORMAL = "normal";
	public static final String STYLE_BIG = "big";
	public static final String STYLE_BIGGER = "bigger";
	public static final String STYLE_HUGE = "huge";

	private final Map<String, Action> customActions;
	private final ItemIconService itemIconService;

	public NotesEnhancedEditorKit(ItemIconService itemIconService)
	{
		super();
		this.itemIconService = itemIconService;
		customActions = new HashMap<>();
		initializeCustomActions();
	}

	/**
	 * Override to use our custom document
	 */
	@Override
	public Document createDefaultDocument()
	{
		return new NotesEnhancedDocument();
	}

	/**
	 * Override write to convert icons to placeholders before saving
	 */
	@Override
	public void write(OutputStream out, Document doc, int pos, int len)
		throws IOException, BadLocationException
	{

		if (doc instanceof NotesEnhancedDocument)
		{
			// Create a copy of the document for saving
			NotesEnhancedDocument copyDoc = createDocumentCopy((NotesEnhancedDocument) doc);

			try
			{
				// Convert icons to placeholders in the copy only
				copyDoc.convertIconsToPlaceholders();

				// Write the copy to RTF
				super.write(out, copyDoc, 0, copyDoc.getLength());

			}
			catch (Exception e)
			{
				log.error("Failed to save with icon conversion, trying original document", e);
				// Fallback to original document if copy fails
				super.write(out, doc, pos, len);
			}
		}
		else
		{
			// Fallback for non-enhanced documents
			super.write(out, doc, pos, len);
		}
	}

	/**
	 * Create a copy of the document with all content and formatting
	 */
	private NotesEnhancedDocument createDocumentCopy(NotesEnhancedDocument originalDoc) throws BadLocationException
	{
		NotesEnhancedDocument copyDoc = new NotesEnhancedDocument();
		try
		{
			// Copy all content from original to copy
			copyDocumentContent(originalDoc, copyDoc);
			return copyDoc;

		}
		catch (Exception e)
		{
			log.error("Failed to create document copy", e);
			throw new BadLocationException("Could not copy document", 0);
		}
	}

	/**
	 * Copy all content and formatting from source to destination document
	 */
	private void copyDocumentContent(StyledDocument sourceDoc, StyledDocument destDoc) throws BadLocationException
	{
		Element root = sourceDoc.getDefaultRootElement();
		copyElementContent(sourceDoc, destDoc, root, 0);
	}

	/**
	 * Recursively copy element content with all formatting and icons
	 */
	private int copyElementContent(StyledDocument sourceDoc, StyledDocument destDoc, Element element, int destPos)
		throws BadLocationException
	{

		if (element.isLeaf())
		{
			int elemStart = element.getStartOffset();
			int elemEnd = element.getEndOffset();

			if (elemEnd > elemStart)
			{
				AttributeSet attrs = element.getAttributes();

				// Check if this element contains an icon
				Object iconAttr = attrs.getAttribute(StyleConstants.IconAttribute);
				if (iconAttr != null)
				{
					// Copy icon with all its attributes
					destDoc.insertString(destPos, " ", attrs);
					return destPos + 1;
				}
				else
				{
					// Copy regular text with attributes
					String text = sourceDoc.getText(elemStart, elemEnd - elemStart);
					if (!text.isEmpty())
					{
						destDoc.insertString(destPos, text, attrs);
						return destPos + text.length();
					}
				}
			}
		}
		else
		{
			// Process child elements
			for (int i = 0; i < element.getElementCount(); i++)
			{
				destPos = copyElementContent(sourceDoc, destDoc, element.getElement(i), destPos);
			}
		}

		return destPos;
	}

	/**
	 * Override read to restore icons from placeholders after loading
	 */
	@Override
	public void read(InputStream in, Document doc, int pos)
		throws IOException, BadLocationException
	{

		// First do the regular RTF read
		super.read(in, doc, pos);

		// Then convert placeholders back to icons
		if (doc instanceof NotesEnhancedDocument && itemIconService != null)
		{
			NotesEnhancedDocument enhancedDoc = (NotesEnhancedDocument) doc;
			enhancedDoc.convertPlaceholdersToIcons(itemIconService);
		}
	}

	private void initializeCustomActions()
	{
		// Font size actions
		customActions.put("font-size-smaller", new FontSizeAction("font-size-smaller", FONT_SIZE_SMALLER));
		customActions.put("font-size-small", new FontSizeAction("font-size-small", FONT_SIZE_SMALL));
		customActions.put("font-size-normal", new FontSizeAction("font-size-normal", FONT_SIZE_NORMAL));
		customActions.put("font-size-big", new FontSizeAction("font-size-big", FONT_SIZE_BIG));
		customActions.put("font-size-bigger", new FontSizeAction("font-size-bigger", FONT_SIZE_BIGGER));
		customActions.put("font-size-huge", new FontSizeAction("font-size-huge", FONT_SIZE_HUGE));

		// Style toggle actions
		customActions.put("toggle-bold", new BoldAction());
		customActions.put("toggle-italic", new ItalicAction());
		customActions.put("toggle-strikethrough", new StrikeThroughAction());

		// Color action
		customActions.put("set-color", new ColorAction());

		// Undo/Redo actions - will be configured with UndoManager later
		customActions.put("undo", new UndoAction());
		customActions.put("redo", new RedoAction());

		// Enhanced Copy/Paste actions
		customActions.put("copy-to-clipboard", new EnhancedCopyAction());
		customActions.put("paste-from-clipboard", new EnhancedPasteAction(itemIconService));
		customActions.put("cut-to-clipboard", new EnhancedCutAction());
	}

	@Override
	public Action[] getActions()
	{
		Action[] superActions = super.getActions();
		Action[] allActions = new Action[superActions.length + customActions.size()];

		System.arraycopy(superActions, 0, allActions, 0, superActions.length);

		int index = superActions.length;
		for (Action action : customActions.values())
		{
			allActions[index++] = action;
		}

		return allActions;
	}

	/**
	 * Get a custom action by name
	 */
	public Action getCustomAction(String actionName)
	{
		return customActions.get(actionName);
	}

	/**
	 * Create a JTextPane configured for Notes Enhanced
	 */
	public JTextPane createTextPane()
	{
		JTextPane textPane = new JTextPane();
		textPane.setEditorKit(this);

		// Use our custom document
		textPane.setDocument(createDefaultDocument());

		textPane.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		textPane.setForeground(Color.WHITE);
		textPane.setCaretColor(Color.WHITE);
		textPane.setSelectedTextColor(Color.WHITE);

		initializeStyles(textPane.getStyledDocument(), textPane.getFont());

		// Override default copy/paste actions
		setupEnhancedCopyPaste(textPane);

		MutableAttributeSet inputAttrs = textPane.getInputAttributes();
		StyleConstants.setForeground(inputAttrs, Color.WHITE);

		return textPane;
	}

	/**
	 * Setup enhanced copy/paste functionality
	 */
	private void setupEnhancedCopyPaste(JTextPane textPane)
	{
		// Get the action map and input map
		ActionMap actionMap = textPane.getActionMap();

		// Override the default actions
		actionMap.put(DefaultEditorKit.copyAction, getCustomAction("copy-to-clipboard"));
		actionMap.put(DefaultEditorKit.pasteAction, getCustomAction("paste-from-clipboard"));
		actionMap.put(DefaultEditorKit.cutAction, getCustomAction("cut-to-clipboard"));

		actionMap.put("copy", getCustomAction("copy-to-clipboard"));
		actionMap.put("paste", getCustomAction("paste-from-clipboard"));
		actionMap.put("cut", getCustomAction("cut-to-clipboard"));
	}

	/**
	 * Initialize default styles for the document, preserving RuneLite's font family
	 */
	private void initializeStyles(StyledDocument doc, Font baseFont)
	{
		Style defaultStyle = StyleContext.getDefaultStyleContext().getStyle(StyleContext.DEFAULT_STYLE);

		// Get RuneLite's font family and preserve it
		String fontFamily = baseFont != null ? baseFont.getFontName() : "Dialog";

		// Base style - preserve RuneLite font family, use normal size (16pt) as default
		Style base = doc.addStyle("base", defaultStyle);
		StyleConstants.setFontFamily(base, fontFamily);
		StyleConstants.setFontSize(base, FONT_SIZE_NORMAL);

		// Normal text style (16pt) - this is the default
		Style normal = doc.addStyle(STYLE_NORMAL, base);
		StyleConstants.setFontSize(normal, FONT_SIZE_NORMAL);

		// Smaller sizes
		Style smaller = doc.addStyle(STYLE_SMALLER, base);
		StyleConstants.setFontSize(smaller, FONT_SIZE_SMALLER);

		Style small = doc.addStyle(STYLE_SMALL, base);
		StyleConstants.setFontSize(small, FONT_SIZE_SMALL);

		Style big = doc.addStyle(STYLE_BIG, base);
		StyleConstants.setFontSize(big, FONT_SIZE_BIG);

		Style bigger = doc.addStyle(STYLE_BIGGER, base);
		StyleConstants.setFontSize(bigger, FONT_SIZE_BIGGER);

		Style huge = doc.addStyle(STYLE_HUGE, base);
		StyleConstants.setFontSize(huge, FONT_SIZE_HUGE);
	}


	/**
	 * Action to change font size while preserving font family
	 */
	public static class FontSizeAction extends StyledEditorKit.StyledTextAction
	{
		private final int fontSize;

		public FontSizeAction(String name, int fontSize)
		{
			super(name);
			this.fontSize = fontSize;
		}

		@Override
		public void actionPerformed(ActionEvent e)
		{
			JEditorPane editor = getEditor(e);
			if (editor != null)
			{
				StyledEditorKit kit = getStyledEditorKit(editor);
				MutableAttributeSet attr = kit.getInputAttributes();

				// Preserve the current font family, only change size
				String currentFontFamily = StyleConstants.getFontFamily(attr);
				StyleConstants.setFontSize(attr, fontSize);
				if (currentFontFamily != null)
				{
					StyleConstants.setFontFamily(attr, currentFontFamily);
				}

				setCharacterAttributes(editor, attr, false);
			}
		}
	}

	/**
	 * Bold toggle action that preserves font family
	 */
	public static class BoldAction extends StyledEditorKit.StyledTextAction
	{
		public BoldAction()
		{
			super("toggle-bold");
			putValue(Action.NAME, "Bold");
			putValue(Action.SHORT_DESCRIPTION, "Toggle bold formatting");
		}

		@Override
		public void actionPerformed(ActionEvent e)
		{
			JEditorPane editor = getEditor(e);
			if (editor != null)
			{
				StyledEditorKit kit = getStyledEditorKit(editor);
				MutableAttributeSet attr = kit.getInputAttributes();

				// Preserve font family
				String currentFontFamily = StyleConstants.getFontFamily(attr);
				boolean isBold = StyleConstants.isBold(attr);
				StyleConstants.setBold(attr, !isBold);
				if (currentFontFamily != null)
				{
					StyleConstants.setFontFamily(attr, currentFontFamily);
				}

				setCharacterAttributes(editor, attr, false);
			}
		}
	}

	/**
	 * Italic toggle action that preserves font family
	 */
	public static class ItalicAction extends StyledEditorKit.StyledTextAction
	{
		public ItalicAction()
		{
			super("toggle-italic");
			putValue(Action.NAME, "Italic");
			putValue(Action.SHORT_DESCRIPTION, "Toggle italic formatting");
		}

		@Override
		public void actionPerformed(ActionEvent e)
		{
			JEditorPane editor = getEditor(e);
			if (editor != null)
			{
				StyledEditorKit kit = getStyledEditorKit(editor);
				MutableAttributeSet attr = kit.getInputAttributes();

				// Preserve font family
				String currentFontFamily = StyleConstants.getFontFamily(attr);
				boolean isItalic = StyleConstants.isItalic(attr);
				StyleConstants.setItalic(attr, !isItalic);
				if (currentFontFamily != null)
				{
					StyleConstants.setFontFamily(attr, currentFontFamily);
				}

				setCharacterAttributes(editor, attr, false);
			}
		}
	}

	/**
	 * Strikethrough toggle action that preserves font family
	 */
	public static class StrikeThroughAction extends StyledEditorKit.StyledTextAction
	{
		public StrikeThroughAction()
		{
			super("toggle-strikethrough");
			putValue(Action.NAME, "Strikethrough");
			putValue(Action.SHORT_DESCRIPTION, "Toggle strikethrough formatting");
		}

		@Override
		public void actionPerformed(ActionEvent e)
		{
			JEditorPane editor = getEditor(e);
			if (editor != null)
			{
				StyledEditorKit kit = getStyledEditorKit(editor);
				MutableAttributeSet attr = kit.getInputAttributes();

				// Preserve font family
				String currentFontFamily = StyleConstants.getFontFamily(attr);
				boolean isStrikeThrough = StyleConstants.isStrikeThrough(attr);
				StyleConstants.setStrikeThrough(attr, !isStrikeThrough);
				if (currentFontFamily != null)
				{
					StyleConstants.setFontFamily(attr, currentFontFamily);
				}

				setCharacterAttributes(editor, attr, false);
			}
		}
	}

	/**
	 * Color action that preserves font family
	 */
	public static class ColorAction extends StyledEditorKit.StyledTextAction
	{
		public ColorAction()
		{
			super("set-color");
			putValue(Action.NAME, "Color");
			putValue(Action.SHORT_DESCRIPTION, "Set text color");
		}

		@Override
		public void actionPerformed(ActionEvent e)
		{
			JEditorPane editor = getEditor(e);
			if (editor != null)
			{
				StyledEditorKit kit = getStyledEditorKit(editor);
				MutableAttributeSet attr = kit.getInputAttributes();

				// Get the color from the action value
				Color color = (Color) getValue("color");
				if (color != null)
				{
					// Preserve font family
					String currentFontFamily = StyleConstants.getFontFamily(attr);
					StyleConstants.setForeground(attr, color);
					if (currentFontFamily != null)
					{
						StyleConstants.setFontFamily(attr, currentFontFamily);
					}

					setCharacterAttributes(editor, attr, false);
				}
			}
		}
	}

	/**
	 * Undo action - will be configured with UndoManager by RichTextEditor
	 */
	@Setter
	public static class UndoAction extends AbstractAction
	{
		private UndoManager undoManager;

		public UndoAction()
		{
			super("undo");
			putValue(Action.NAME, "Undo");
			putValue(Action.SHORT_DESCRIPTION, "Undo last action");
		}

		@Override
		public void actionPerformed(ActionEvent e)
		{
			if (undoManager != null && undoManager.canUndo())
			{
				try
				{
					undoManager.undo();
				}
				catch (Exception ex)
				{
					log.warn("Failed to undo", ex);
				}
			}
		}

		@Override
		public boolean isEnabled()
		{
			return undoManager != null && undoManager.canUndo();
		}
	}

	/**
	 * Redo action - will be configured with UndoManager by RichTextEditor
	 */
	@Setter
	public static class RedoAction extends AbstractAction
	{
		private UndoManager undoManager;

		public RedoAction()
		{
			super("redo");
			putValue(Action.NAME, "Redo");
			putValue(Action.SHORT_DESCRIPTION, "Redo last undone action");
		}

		@Override
		public void actionPerformed(ActionEvent e)
		{
			if (undoManager != null && undoManager.canRedo())
			{
				try
				{
					undoManager.redo();
				}
				catch (Exception ex)
				{
					log.warn("Failed to redo", ex);
				}
			}
		}

		@Override
		public boolean isEnabled()
		{
			return undoManager != null && undoManager.canRedo();
		}
	}

	// Utility methods (unchanged)

	/**
	 * Utility method to apply a named style to the current selection while preserving font family
	 */
	public static void applyStyle(JTextPane textPane, String styleName)
	{
		StyledDocument doc = textPane.getStyledDocument();
		Style style = doc.getStyle(styleName);

		if (style != null)
		{
			int start = textPane.getSelectionStart();
			int length = textPane.getSelectionEnd() - start;

			// Get the current font family to preserve it
			String currentFontFamily;
			if (length > 0)
			{
				AttributeSet currentAttrs = doc.getCharacterElement(start).getAttributes();
				currentFontFamily = StyleConstants.getFontFamily(currentAttrs);
			}
			else
			{
				AttributeSet inputAttrs = textPane.getInputAttributes();
				currentFontFamily = StyleConstants.getFontFamily(inputAttrs);
			}

			// Create a copy of the style with preserved font family
			SimpleAttributeSet preservedStyle = new SimpleAttributeSet(style);
			if (currentFontFamily != null && !currentFontFamily.isEmpty())
			{
				StyleConstants.setFontFamily(preservedStyle, currentFontFamily);
			}

			if (length > 0)
			{
				doc.setCharacterAttributes(start, length, preservedStyle, false);
			}
			else
			{
				// Apply to current input attributes
				textPane.setCharacterAttributes(preservedStyle, false);
			}
		}
	}

	/**
	 * Get the current font size at the caret position
	 */
	public static int getCurrentFontSize(JTextPane textPane)
	{
		AttributeSet attrs = textPane.getCharacterAttributes();
		return StyleConstants.getFontSize(attrs);
	}

	/**
	 * Get the current text color at the caret position
	 */
	public static Color getCurrentTextColor(JTextPane textPane)
	{
		AttributeSet attrs = textPane.getCharacterAttributes();
		Color color = StyleConstants.getForeground(attrs);
		return color != null ? color : Color.WHITE; // Default to white if no color set
	}
}
package dev.seafoo.richtextnotes.ui.components;

import dev.seafoo.richtextnotes.services.ItemIconService;
import dev.seafoo.richtextnotes.ui.popups.ItemSearchPopup;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.KeyEvent;
import java.awt.image.BufferedImage;
import javax.swing.Action;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.DefaultListCellRenderer;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JTextPane;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import javax.swing.event.CaretEvent;
import javax.swing.event.CaretListener;
import javax.swing.text.SimpleAttributeSet;
import javax.swing.text.StyleConstants;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

/**
 * Formatting toolbar for the Notes Enhanced RTF editor
 */
@Slf4j
public class FormattingToolbar extends JToolBar implements CaretListener
{

	private final JTextPane textPane;
	private final NotesEnhancedEditorKit editorKit;
	private final ItemIconService itemIconService;

	// Font size controls
	private JComboBox<FontSizeOption> fontSizeCombo;

	// Formatting toggle buttons
	private JToggleButton boldButton;
	private JToggleButton italicButton;
	private JToggleButton strikethroughButton;

	// Item icon button
	private JButton itemIconButton;

	// Color picker
	private JComboBox<ColorOption> colorCombo;

	// Item search popup - NEW FIELD
	private ItemSearchPopup itemSearchPopup;

	// Prevent recursive updates during caret events
	private boolean updatingToolbar = false;

	public FormattingToolbar(JTextPane textPane, NotesEnhancedEditorKit editorKit, ItemIconService itemIconService)
	{
		super("Formatting", JToolBar.HORIZONTAL);
		this.textPane = textPane;
		this.editorKit = editorKit;
		this.itemIconService = itemIconService;

		setupToolbar();
		setupButtons();

		// Listen for caret changes to update button states
		textPane.addCaretListener(this);

		// Initial update
		updateToolbarState();
	}

	private void setupToolbar()
	{
		setFloatable(false);
		setRollover(true);
		setBackground(ColorScheme.DARKER_GRAY_COLOR);
		setBorder(new EmptyBorder(0, 0, 3, 0));
		setPreferredSize(new Dimension(0, 35));
	}

	private void setupButtons()
	{


		// Bold button
		boldButton = createToggleButton("B", "Bold (" + getShortcutText("B", false) + ")", true);
		boldButton.addActionListener(e -> editorKit.getCustomAction("toggle-bold").actionPerformed(
			new ActionEvent(textPane, ActionEvent.ACTION_PERFORMED, "toggle-bold")));
		add(boldButton);

		// Italic button
		italicButton = createToggleButton("I", "Italic (" + getShortcutText("I ", false) + ")", false);
		italicButton.setFont(italicButton.getFont().deriveFont(Font.ITALIC));
		italicButton.addActionListener(e -> editorKit.getCustomAction("toggle-italic").actionPerformed(
			new ActionEvent(textPane, ActionEvent.ACTION_PERFORMED, "toggle-italic")));
		add(italicButton);

		// Strikethrough button
		strikethroughButton = createToggleButton("<html><s>S</s></html>", "Strikethrough (" + getShortcutText("S", true) + ")", false);
		strikethroughButton.addActionListener(e -> editorKit.getCustomAction("toggle-strikethrough").actionPerformed(
			new ActionEvent(textPane, ActionEvent.ACTION_PERFORMED, "toggle-strikethrough")));
		add(strikethroughButton);

		addSeparator();

		// Font size dropdown
		createFontSizeCombo();
		add(fontSizeCombo);

		// Color picker
		createColorCombo();
		add(colorCombo);

		addSeparator();

		// Item icon button
		String itemDisplayIcon = "¤";
		if (getFont().canDisplay('⚔'))
		{
			itemDisplayIcon = "⚔";
		}
		itemIconButton = createButton(itemDisplayIcon, "Insert Item Icon");
		itemIconButton.addActionListener(e -> insertItemIcon());
		itemIconButton.setEnabled(itemIconService != null);
		add(itemIconButton);

		// Add flexible space to push remaining buttons to the right
		add(Box.createHorizontalGlue());
	}

	private void createFontSizeCombo()
	{
		FontSizeOption[] options = {
			new FontSizeOption("Smaller", NotesEnhancedEditorKit.FONT_SIZE_SMALLER, "font-size-smaller"),
			new FontSizeOption("Small", NotesEnhancedEditorKit.FONT_SIZE_SMALL, "font-size-small"),
			new FontSizeOption("Normal", NotesEnhancedEditorKit.FONT_SIZE_NORMAL, "font-size-normal"),
			new FontSizeOption("Big", NotesEnhancedEditorKit.FONT_SIZE_BIG, "font-size-big"),
			new FontSizeOption("Bigger", NotesEnhancedEditorKit.FONT_SIZE_BIGGER, "font-size-bigger"),
			new FontSizeOption("Huge", NotesEnhancedEditorKit.FONT_SIZE_HUGE, "font-size-huge")
		};

		fontSizeCombo = new JComboBox<>(options);
		fontSizeCombo.setSelectedIndex(2); // Default to "Normal" (16pt)
		fontSizeCombo.setMaximumSize(new Dimension(55, 25));
		fontSizeCombo.setPreferredSize(new Dimension(55, 25));
		fontSizeCombo.setMinimumSize(new Dimension(55, 25));


		fontSizeCombo.setRenderer(new DefaultListCellRenderer()
		{
			@Override
			public Component getListCellRendererComponent(JList<?> list, Object value, int index,
														  boolean isSelected, boolean cellHasFocus)
			{
				super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);

				if (value instanceof FontSizeOption)
				{
					FontSizeOption option = (FontSizeOption) value;
					setText(option.getDisplayName());
					setFont(getFont().deriveFont((float) option.getFontSize() - index));

					if (index == -1)
					{
						setText("aA");
						setHorizontalAlignment(SwingConstants.CENTER);
					}
					else
					{
						setHorizontalAlignment(SwingConstants.LEFT);
					}

					if (isSelected)
					{
						setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
						setForeground(Color.WHITE);

					}
					else
					{
						setBackground(ColorScheme.DARKER_GRAY_COLOR);
						setForeground(Color.WHITE);
					}
				}

				return this;
			}
		});

		fontSizeCombo.addActionListener(e -> {
			if (updatingToolbar)
			{
				return;
			}

			FontSizeOption selected = (FontSizeOption) fontSizeCombo.getSelectedItem();
			if (selected != null)
			{
				Action action = editorKit.getCustomAction(selected.getActionName());
				if (action != null)
				{
					action.actionPerformed(new ActionEvent(textPane, ActionEvent.ACTION_PERFORMED,
						selected.getActionName()));
					textPane.requestFocus();
				}
			}
		});
	}

	private void createColorCombo()
	{
		ColorOption[] options = {
			new ColorOption("", Color.WHITE),
			new ColorOption("", Color.YELLOW),
			new ColorOption("", Color.RED),
			new ColorOption("", Color.GREEN),
			new ColorOption("", Color.CYAN),
			new ColorOption("", Color.MAGENTA)
		};

		colorCombo = new JComboBox<>(options);
		colorCombo.setSelectedIndex(0); // Default to white
		colorCombo.setMaximumSize(new Dimension(44, 25));
		colorCombo.setPreferredSize(new Dimension(44, 25));
		colorCombo.setMinimumSize(new Dimension(44, 25));


		colorCombo.setRenderer(new DefaultListCellRenderer()
		{
			@Override
			public Component getListCellRendererComponent(JList<?> list, Object value, int index,
														  boolean isSelected, boolean cellHasFocus)
			{
				super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);

				if (value instanceof ColorOption)
				{
					ColorOption option = (ColorOption) value;

					// Create a color swatch
					setIcon(createColorSwatch(option.getColor()));
					setText("");

					if (isSelected)
					{
						setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
						setBorder(BorderFactory.createLineBorder(Color.WHITE, 1));
					}
					else
					{
						setBackground(ColorScheme.DARKER_GRAY_COLOR);
						setBorder(BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_COLOR, 1));
					}
				}

				return this;
			}
		});

		colorCombo.setPrototypeDisplayValue(new ColorOption("", Color.WHITE));

		colorCombo.addActionListener(e -> {
			if (updatingToolbar)
			{
				return;
			}

			ColorOption selected = (ColorOption) colorCombo.getSelectedItem();
			if (selected != null)
			{
				Action action = editorKit.getCustomAction("set-color");
				if (action != null)
				{
					// Set the color in the action
					action.putValue("color", selected.getColor());
					action.actionPerformed(new ActionEvent(textPane, ActionEvent.ACTION_PERFORMED, "set-color"));
					textPane.requestFocus();
				}
			}
		});
	}

	private Icon createColorSwatch(Color color)
	{
		int width = 16;
		int height = 16;
		BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
		Graphics2D g2d = image.createGraphics();

		// Fill with the color
		g2d.setColor(color);
		g2d.fillRect(0, 0, width, height);

		// Add border
		g2d.setColor(Color.DARK_GRAY);
		g2d.drawRect(0, 0, width - 1, height - 1);

		g2d.dispose();
		return new ImageIcon(image);
	}

	private JToggleButton createToggleButton(String text, String tooltip, boolean bold)
	{
		JToggleButton button = new JToggleButton(text);
		button.setToolTipText(tooltip);
		button.setPreferredSize(new Dimension(20, 25));
		button.setMaximumSize(new Dimension(20, 25));
		button.setMinimumSize(new Dimension(20, 25));
		button.setFocusPainted(false);
		button.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		button.setForeground(Color.WHITE);

		if (bold)
		{
			button.setFont(button.getFont().deriveFont(Font.BOLD));
		}

		// Custom styling for toggle state
		button.addItemListener(e -> {
			if (button.isSelected())
			{
				button.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
			}
			else
			{
				button.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			}
		});

		return button;
	}

	private JButton createButton(String text, String tooltip)
	{
		JButton button = new JButton(text);
		button.setToolTipText(tooltip);
		button.setPreferredSize(new Dimension(25, 25));
		button.setFocusPainted(false);
		button.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		button.setForeground(Color.WHITE);

		// Hover effect
		button.addMouseListener(new java.awt.event.MouseAdapter()
		{
			@Override
			public void mouseEntered(java.awt.event.MouseEvent e)
			{
				button.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
			}

			@Override
			public void mouseExited(java.awt.event.MouseEvent e)
			{
				button.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			}
		});

		return button;
	}

	@Override
	public void caretUpdate(CaretEvent e)
	{
		SwingUtilities.invokeLater(this::updateToolbarState);
	}

	private void updateToolbarState()
	{
		if (textPane == null)
		{
			return;
		}

		updatingToolbar = true;

		try
		{
			// Update toggle button states based on current character attributes
			var attrs = textPane.getCharacterAttributes();

			boldButton.setSelected(StyleConstants.isBold(attrs));
			italicButton.setSelected(StyleConstants.isItalic(attrs));
			strikethroughButton.setSelected(StyleConstants.isStrikeThrough(attrs));

			// Update font size combo
			int currentSize = NotesEnhancedEditorKit.getCurrentFontSize(textPane);
			updateFontSizeCombo(currentSize);

			// Update color combo
			Color currentColor = NotesEnhancedEditorKit.getCurrentTextColor(textPane);
			updateColorCombo(currentColor);

			// Update item icon button state
			if (itemIconService != null)
			{
				itemIconButton.setEnabled(true);
			}

		}
		catch (Exception ex)
		{
			log.warn("Error updating toolbar state", ex);
		}
		finally
		{
			updatingToolbar = false;
		}
	}

	private void updateFontSizeCombo(int currentSize)
	{
		// Find the closest matching font size option
		FontSizeOption bestMatch = null;
		int bestDistance = Integer.MAX_VALUE;

		for (int i = 0; i < fontSizeCombo.getItemCount(); i++)
		{
			FontSizeOption option = fontSizeCombo.getItemAt(i);
			int distance = Math.abs(option.getFontSize() - currentSize);
			if (distance < bestDistance)
			{
				bestDistance = distance;
				bestMatch = option;
			}
		}

		if (bestMatch != null)
		{
			fontSizeCombo.setSelectedItem(bestMatch);
		}
	}

	private void updateColorCombo(Color currentColor)
	{
		if (currentColor == null)
		{
			currentColor = Color.WHITE; // Default to white
		}

		// Find exact matching color option
		for (int i = 0; i < colorCombo.getItemCount(); i++)
		{
			ColorOption option = colorCombo.getItemAt(i);
			if (option.getColor().equals(currentColor))
			{
				colorCombo.setSelectedItem(option);
				return;
			}
		}

		// If no exact match found, default to white
		colorCombo.setSelectedIndex(0);
	}

	private void insertItemIcon()
	{
		if (itemIconService == null)
		{
			JOptionPane.showMessageDialog(this,
				"Item icon service is not ready. Please wait a moment and try again.",
				"Service Not Ready",
				JOptionPane.WARNING_MESSAGE);
			return;
		}

		// Show the item search popup
		showItemSearchDialog();
	}


	private void showItemSearchDialog()
	{
		// Create popup if not exists
		if (itemSearchPopup == null)
		{
			itemSearchPopup = new ItemSearchPopup(itemIconService);
		}

		// Show popup at button location
		itemSearchPopup.showPopup(itemIconButton, 0, itemIconButton.getHeight(), result -> {
			if (result != null)
			{
				insertSelectedItem(result.getItemName(), result.getItemId(), result.getQuantity());
			}
		});
	}

	private void insertSelectedItem(String itemName, int itemId, int quantity)
	{
		try
		{
			// Use the quantity from the popup, ensuring it's at least 1
			int validQuantity = Math.max(1, quantity);

			// Use ItemIconService to get a properly centered icon with quantity
			Icon centeredIcon = itemIconService.getCenteredIconById(itemId, validQuantity);

			if (centeredIcon != null)
			{
				// Attach icon to text pane for repaint on load
				if (centeredIcon instanceof ItemIconService.CenteredImageIcon)
				{
					((ItemIconService.CenteredImageIcon) centeredIcon).attachToComponent(textPane);
				}

				// Create attributes with icon and metadata
				SimpleAttributeSet attrs = new SimpleAttributeSet();
				StyleConstants.setIcon(attrs, centeredIcon);

				// Store metadata for saving/loading including quantity
				attrs.addAttribute("item-icon-data",
					new NotesEnhancedDocument.IconData(itemName, itemId, validQuantity));

				// Insert the icon
				textPane.getDocument().insertString(textPane.getCaretPosition(), " ", attrs);

				log.debug("Inserted centered icon for {} (ID: {}) with quantity: {}", itemName, itemId, validQuantity);
			}
			else
			{
				JOptionPane.showMessageDialog(this,
					"Could not load icon for: " + itemName,
					"Icon Not Found",
					JOptionPane.WARNING_MESSAGE);
			}

		}
		catch (Exception ex)
		{
			log.error("Failed to insert item icon", ex);
			JOptionPane.showMessageDialog(this,
				"Error inserting icon: " + ex.getMessage(),
				"Error",
				JOptionPane.ERROR_MESSAGE);
		}
	}

	private String getShortcutText(String key, boolean shift)
	{
		int shortcutKeyMask = Toolkit.getDefaultToolkit().getMenuShortcutKeyMaskEx();
		String modifier = shortcutKeyMask == KeyEvent.CTRL_DOWN_MASK ? "Ctrl" : "Cmd";
		String shiftText = shift ? "Shift+" : "";
		return modifier + "+" + shiftText + key;
	}

	/**
	 * Cleanup method to remove listeners - UPDATED METHOD
	 */
	public void cleanup()
	{
		if (textPane != null)
		{
			textPane.removeCaretListener(this);
		}
		if (itemSearchPopup != null)
		{
			itemSearchPopup.setVisible(false);
			itemSearchPopup = null;
		}
	}

	/**
	 * Color option for the combo box
	 */
	@Getter
	private static class ColorOption
	{
		private final String displayName;
		private final Color color;

		public ColorOption(String displayName, Color color)
		{
			this.displayName = displayName;
			this.color = color;
		}

		@Override
		public String toString()
		{
			return displayName;
		}

		@Override
		public boolean equals(Object obj)
		{
			if (this == obj)
			{
				return true;
			}
			if (obj == null || getClass() != obj.getClass())
			{
				return false;
			}
			ColorOption that = (ColorOption) obj;
			return color.equals(that.color) && displayName.equals(that.displayName);
		}

		@Override
		public int hashCode()
		{
			return displayName.hashCode() * 31 + color.hashCode();
		}
	}

	/**
	 * Font size option for the combo box
	 */
	@Getter
	private static class FontSizeOption
	{
		private final String displayName;
		private final int fontSize;
		private final String actionName;

		public FontSizeOption(String displayName, int fontSize, String actionName)
		{
			this.displayName = displayName;
			this.fontSize = fontSize;
			this.actionName = actionName;
		}

		@Override
		public String toString()
		{
			return displayName;
		}

		@Override
		public boolean equals(Object obj)
		{
			if (this == obj)
			{
				return true;
			}
			if (obj == null || getClass() != obj.getClass())
			{
				return false;
			}
			FontSizeOption that = (FontSizeOption) obj;
			return fontSize == that.fontSize && displayName.equals(that.displayName);
		}

		@Override
		public int hashCode()
		{
			return displayName.hashCode() * 31 + fontSize;
		}
	}
}
package dev.seafoo.richtextnotes.ui.components.clipboard;

import dev.seafoo.richtextnotes.ui.components.NotesEnhancedDocument;
import java.awt.Color;
import java.awt.Font;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.event.ActionEvent;
import java.util.HashMap;
import java.util.Map;
import javax.swing.JTextPane;
import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.Element;
import javax.swing.text.JTextComponent;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyledDocument;
import javax.swing.text.TextAction;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class EnhancedCopyAction extends TextAction
{
	public EnhancedCopyAction()
	{
		super("copy-to-clipboard");
	}

	@Override
	public void actionPerformed(ActionEvent e)
	{
		JTextComponent target = getTextComponent(e);
		if (target == null)
		{
			return;
		}

		try
		{
			int selectionStart = target.getSelectionStart();
			int selectionEnd = target.getSelectionEnd();

			if (selectionStart == selectionEnd)
			{
				// Nothing selected
				return;
			}

			if (!(target instanceof JTextPane))
			{
				// Fallback for non-JTextPane components
				target.copy();
				return;
			}

			JTextPane textPane = (JTextPane) target;

			// Extract RTF content using the existing RTF export mechanism
			String rtfContent = extractSelectionAsRtf(textPane, selectionStart, selectionEnd);
			String plainText = target.getSelectedText();

			// Create clipboard data with RTF and plain text
			NotesEnhancedClipboardData clipboardData = new NotesEnhancedClipboardData();
			clipboardData.setRtfContent(rtfContent);
			clipboardData.setPlainText(plainText != null ? plainText : "");

			// Create transferable
			NotesEnhancedTransferable transferable = new NotesEnhancedTransferable(clipboardData);

			// Set to system clipboard
			Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
			clipboard.setContents(transferable, null);

			log.debug("Enhanced copy completed using RTF export");

		}
		catch (Exception ex)
		{
			log.error("Failed to copy content", ex);
			// Fallback to default behavior
			target.copy();
		}
	}

	/**
	 * Extract selected content as RTF using manual RTF fragment building
	 * This avoids the extra \par tags from document-level RTF export
	 */
	private String extractSelectionAsRtf(JTextPane textPane, int start, int end)
	{
		try
		{
			StyledDocument doc = textPane.getStyledDocument();

			// First pass: collect all colors used in selection
			Map<Color, Integer> colorMap = new HashMap<>();
			collectColorsInRange(doc, start, end, colorMap);

			// Build minimal RTF fragment
			StringBuilder rtf = new StringBuilder();
			rtf.append("{\\rtf1\\ansi\\deff0 ");

			// Add minimal font table (preserve current font)
			Font currentFont = textPane.getFont();
			String fontName = currentFont != null ? currentFont.getFontName() : "Dialog";
			rtf.append("{\\fonttbl\\f0\\fmodern ").append(fontName).append(";}");

			// Add color table with all colors found
			if (!colorMap.isEmpty())
			{
				rtf.append("{\\colortbl;"); // First entry is default (auto)
				for (Map.Entry<Color, Integer> entry : colorMap.entrySet())
				{
					Color color = entry.getKey();
					rtf.append("\\red").append(color.getRed())
						.append("\\green").append(color.getGreen())
						.append("\\blue").append(color.getBlue()).append(";");
				}
				rtf.append("}");
			}

			// Extract content for the selection range
			extractRtfContentFragment(doc, start, end, rtf, colorMap);

			rtf.append("}");
			return rtf.toString();

		}
		catch (Exception e)
		{
			log.error("Failed to extract RTF fragment", e);
			return "";
		}
	}

	/**
	 * First pass: collect all colors used in the selection range
	 */
	private void collectColorsInRange(StyledDocument doc, int selStart, int selEnd, Map<Color, Integer> colorMap)
		throws BadLocationException
	{

		Element root = doc.getDefaultRootElement();
		collectColorsInElement(doc, root, selStart, selEnd, colorMap);
	}

	private void collectColorsInElement(StyledDocument doc, Element element, int selStart, int selEnd, Map<Color, Integer> colorMap)
	{

		if (element.isLeaf())
		{
			int elemStart = element.getStartOffset();
			int elemEnd = element.getEndOffset();

			// Check if this element overlaps with selection
			if (elemEnd <= selStart || elemStart >= selEnd)
			{
				return;
			}

			AttributeSet attrs = element.getAttributes();
			Color color = StyleConstants.getForeground(attrs);

			// Add color to map if not already present
			if (color != null && !colorMap.containsKey(color))
			{
				colorMap.put(color, colorMap.size() + 1); // Index starts at 1 (0 is auto)
			}
		}
		else
		{
			// Process child elements
			for (int i = 0; i < element.getElementCount(); i++)
			{
				collectColorsInElement(doc, element.getElement(i), selStart, selEnd, colorMap);
			}
		}
	}

	/**
	 * Extract RTF content for a specific range without document structure
	 */
	private void extractRtfContentFragment(StyledDocument doc, int selStart, int selEnd, StringBuilder rtf, Map<Color, Integer> colorMap)
		throws BadLocationException
	{

		Element root = doc.getDefaultRootElement();
		extractElementContentAsRtf(doc, root, selStart, selEnd, rtf, colorMap);
	}

	/**
	 * Recursively extract element content as RTF fragment
	 */
	private void extractElementContentAsRtf(StyledDocument doc, Element element,
											int selStart, int selEnd, StringBuilder rtf, Map<Color, Integer> colorMap)
		throws BadLocationException
	{

		if (element.isLeaf())
		{
			int elemStart = element.getStartOffset();
			int elemEnd = element.getEndOffset();

			// Check if this element overlaps with selection
			if (elemEnd <= selStart || elemStart >= selEnd)
			{
				return;
			}

			// Calculate overlap
			int overlapStart = Math.max(elemStart, selStart);
			int overlapEnd = Math.min(elemEnd, selEnd);

			AttributeSet attrs = element.getAttributes();

			// Check if this element contains an icon
			Object iconAttr = attrs.getAttribute(StyleConstants.IconAttribute);
			if (iconAttr != null)
			{
				// Convert icon to placeholder
				Object iconData = attrs.getAttribute("item-icon-data");
				if (iconData instanceof NotesEnhancedDocument.IconData)
				{
					NotesEnhancedDocument.IconData data = (NotesEnhancedDocument.IconData) iconData;
					String placeholder = "{{ITEM:" + data.itemId + ":" + data.itemName + ":" + data.itemQuantity + "}}";
					rtf.append(escapeRtfText(placeholder));
				}
				else
				{
					rtf.append("[icon]"); // Fallback
				}
			}
			else
			{
				// Regular text element - add formatting codes
				String text = doc.getText(overlapStart, overlapEnd - overlapStart);
				if (!text.isEmpty())
				{
					// Add RTF formatting codes based on attributes
					appendRtfFormatting(attrs, rtf, colorMap);
					rtf.append(escapeRtfText(text));
					closeRtfFormatting(attrs, rtf);
				}
			}
		}
		else
		{
			// Process child elements
			for (int i = 0; i < element.getElementCount(); i++)
			{
				extractElementContentAsRtf(doc, element.getElement(i), selStart, selEnd, rtf, colorMap);
			}
		}
	}

	/**
	 * Add RTF formatting codes for the given attributes
	 */
	private void appendRtfFormatting(AttributeSet attrs, StringBuilder rtf, Map<Color, Integer> colorMap)
	{
		// Bold
		if (StyleConstants.isBold(attrs))
		{
			rtf.append("\\b ");
		}

		// Italic
		if (StyleConstants.isItalic(attrs))
		{
			rtf.append("\\i ");
		}

		// Strikethrough
		if (StyleConstants.isStrikeThrough(attrs))
		{
			rtf.append("\\strike ");
		}

		// Font size
		int fontSize = StyleConstants.getFontSize(attrs);
		if (fontSize > 0)
		{
			rtf.append("\\fs").append(fontSize * 2).append(" "); // RTF uses half-points
		}

		// Text color - use the color map index
		Color color = StyleConstants.getForeground(attrs);
		if (color != null && colorMap.containsKey(color))
		{
			int colorIndex = colorMap.get(color);
			rtf.append("\\cf").append(colorIndex).append(" ");
		}
	}

	/**
	 * Close RTF formatting codes for the given attributes
	 */
	private void closeRtfFormatting(AttributeSet attrs, StringBuilder rtf)
	{
		// Close in reverse order
		if (StyleConstants.isBold(attrs))
		{
			rtf.append("\\b0 ");
		}
		if (StyleConstants.isItalic(attrs))
		{
			rtf.append("\\i0 ");
		}
		if (StyleConstants.isStrikeThrough(attrs))
		{
			rtf.append("\\strike0 ");
		}
	}

	/**
	 * Escape special RTF characters
	 */
	private String escapeRtfText(String text)
	{
		return text.replace("\\", "\\\\")
			.replace("{", "\\{")
			.replace("}", "\\}")
			.replace("\n", "\\par") // Convert newlines to spaces instead of \par
			.replace("\r", "");
	}
}

package dev.seafoo.richtextnotes.ui.components.clipboard;

import dev.seafoo.richtextnotes.ui.components.NotesEnhancedDocument;
import java.awt.Color;
import java.awt.Font;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.event.ActionEvent;
import java.util.HashMap;
import java.util.Map;
import javax.swing.JTextPane;
import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.Element;
import javax.swing.text.JTextComponent;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyledDocument;
import javax.swing.text.TextAction;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class EnhancedCutAction extends TextAction
{
	public EnhancedCutAction()
	{
		super("cut-to-clipboard");
	}

	@Override
	public void actionPerformed(ActionEvent e)
	{
		JTextComponent target = getTextComponent(e);
		if (target == null || !target.isEditable())
		{
			return;
		}

		try
		{
			int selectionStart = target.getSelectionStart();
			int selectionEnd = target.getSelectionEnd();

			if (selectionStart == selectionEnd)
			{
				// Nothing selected, do nothing
				return;
			}

			if (!(target instanceof JTextPane))
			{
				// Fallback for non-JTextPane components
				target.cut();
				return;
			}

			JTextPane textPane = (JTextPane) target;

			// Extract RTF content using the same mechanism as copy
			String rtfContent = extractSelectionAsRtf(textPane, selectionStart, selectionEnd);
			String plainText = target.getSelectedText();

			// Create clipboard data
			NotesEnhancedClipboardData clipboardData = new NotesEnhancedClipboardData();
			clipboardData.setRtfContent(rtfContent);
			clipboardData.setPlainText(plainText != null ? plainText : "");

			// Create transferable
			NotesEnhancedTransferable transferable = new NotesEnhancedTransferable(clipboardData);

			// Set to system clipboard
			Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
			clipboard.setContents(transferable, null);

			// After successful copy, delete the selected text (this is atomic)
			target.replaceSelection("");

			log.debug("Enhanced cut completed using RTF export");

		}
		catch (Exception ex)
		{
			log.error("Failed to cut content", ex);
			// Fallback to default behavior
			target.cut();
		}
	}

	/**
	 * Extract selected content as RTF using manual RTF fragment building
	 * This avoids the extra \par tags from document-level RTF export
	 */
	private String extractSelectionAsRtf(JTextPane textPane, int start, int end)
	{
		try
		{
			StyledDocument doc = textPane.getStyledDocument();

			// First pass: collect all colors used in selection
			Map<Color, Integer> colorMap = new HashMap<>();
			collectColorsInRange(doc, start, end, colorMap);

			// Build minimal RTF fragment
			StringBuilder rtf = new StringBuilder();
			rtf.append("{\\rtf1\\ansi\\deff0 ");

			// Add minimal font table (preserve current font)
			Font currentFont = textPane.getFont();
			String fontName = currentFont != null ? currentFont.getFontName() : "Dialog";
			rtf.append("{\\fonttbl\\f0\\fmodern ").append(fontName).append(";}");

			// Add color table with all colors found
			if (!colorMap.isEmpty())
			{
				rtf.append("{\\colortbl;"); // First entry is default (auto)
				for (Map.Entry<Color, Integer> entry : colorMap.entrySet())
				{
					Color color = entry.getKey();
					rtf.append("\\red").append(color.getRed())
						.append("\\green").append(color.getGreen())
						.append("\\blue").append(color.getBlue()).append(";");
				}
				rtf.append("}");
			}

			// Extract content for the selection range
			extractRtfContentFragment(doc, start, end, rtf, colorMap);

			rtf.append("}");
			return rtf.toString();

		}
		catch (Exception e)
		{
			log.error("Failed to extract RTF fragment", e);
			return "";
		}
	}

	/**
	 * First pass: collect all colors used in the selection range
	 */
	private void collectColorsInRange(StyledDocument doc, int selStart, int selEnd, Map<Color, Integer> colorMap)
		throws BadLocationException
	{

		Element root = doc.getDefaultRootElement();
		collectColorsInElement(doc, root, selStart, selEnd, colorMap);
	}

	private void collectColorsInElement(StyledDocument doc, Element element, int selStart, int selEnd, Map<Color, Integer> colorMap)
	{

		if (element.isLeaf())
		{
			int elemStart = element.getStartOffset();
			int elemEnd = element.getEndOffset();

			// Check if this element overlaps with selection
			if (elemEnd <= selStart || elemStart >= selEnd)
			{
				return;
			}

			AttributeSet attrs = element.getAttributes();
			Color color = StyleConstants.getForeground(attrs);

			// Add color to map if not already present
			if (color != null && !colorMap.containsKey(color))
			{
				colorMap.put(color, colorMap.size() + 1); // Index starts at 1 (0 is auto)
			}
		}
		else
		{
			// Process child elements
			for (int i = 0; i < element.getElementCount(); i++)
			{
				collectColorsInElement(doc, element.getElement(i), selStart, selEnd, colorMap);
			}
		}
	}

	/**
	 * Extract RTF content for a specific range without document structure
	 */
	private void extractRtfContentFragment(StyledDocument doc, int selStart, int selEnd, StringBuilder rtf, Map<Color, Integer> colorMap)
		throws BadLocationException
	{

		Element root = doc.getDefaultRootElement();
		extractElementContentAsRtf(doc, root, selStart, selEnd, rtf, colorMap);
	}

	/**
	 * Recursively extract element content as RTF fragment
	 */
	private void extractElementContentAsRtf(StyledDocument doc, Element element,
											int selStart, int selEnd, StringBuilder rtf, Map<Color, Integer> colorMap)
		throws BadLocationException
	{

		if (element.isLeaf())
		{
			int elemStart = element.getStartOffset();
			int elemEnd = element.getEndOffset();

			// Check if this element overlaps with selection
			if (elemEnd <= selStart || elemStart >= selEnd)
			{
				return;
			}

			// Calculate overlap
			int overlapStart = Math.max(elemStart, selStart);
			int overlapEnd = Math.min(elemEnd, selEnd);

			AttributeSet attrs = element.getAttributes();

			// Check if this element contains an icon
			Object iconAttr = attrs.getAttribute(StyleConstants.IconAttribute);
			if (iconAttr != null)
			{
				Object iconData = attrs.getAttribute("item-icon-data");
				if (iconData instanceof NotesEnhancedDocument.IconData)
				{
					NotesEnhancedDocument.IconData data = (NotesEnhancedDocument.IconData) iconData;
					String placeholder = "{{ITEM:" + data.itemId + ":" + data.itemName + ":" + data.itemQuantity + "}}";
					rtf.append(escapeRtfText(placeholder));
				}
				else
				{
					rtf.append("[icon]"); // Fallback
				}
			}
			else
			{
				// Regular text element - add formatting codes
				String text = doc.getText(overlapStart, overlapEnd - overlapStart);
				if (!text.isEmpty())
				{
					// Add RTF formatting codes based on attributes
					appendRtfFormatting(attrs, rtf, colorMap);
					rtf.append(escapeRtfText(text));
					closeRtfFormatting(attrs, rtf);
				}
			}
		}
		else
		{
			// Process child elements
			for (int i = 0; i < element.getElementCount(); i++)
			{
				extractElementContentAsRtf(doc, element.getElement(i), selStart, selEnd, rtf, colorMap);
			}
		}
	}

	/**
	 * Add RTF formatting codes for the given attributes
	 */
	private void appendRtfFormatting(AttributeSet attrs, StringBuilder rtf, Map<Color, Integer> colorMap)
	{
		// Bold
		if (StyleConstants.isBold(attrs))
		{
			rtf.append("\\b ");
		}

		// Italic
		if (StyleConstants.isItalic(attrs))
		{
			rtf.append("\\i ");
		}

		// Strikethrough
		if (StyleConstants.isStrikeThrough(attrs))
		{
			rtf.append("\\strike ");
		}

		// Font size
		int fontSize = StyleConstants.getFontSize(attrs);
		if (fontSize > 0)
		{
			rtf.append("\\fs").append(fontSize * 2).append(" "); // RTF uses half-points
		}

		// Text color - use the color map index
		Color color = StyleConstants.getForeground(attrs);
		if (color != null && colorMap.containsKey(color))
		{
			int colorIndex = colorMap.get(color);
			rtf.append("\\cf").append(colorIndex).append(" ");
		}
	}

	/**
	 * Close RTF formatting codes for the given attributes
	 */
	private void closeRtfFormatting(AttributeSet attrs, StringBuilder rtf)
	{
		// Close in reverse order
		if (StyleConstants.isBold(attrs))
		{
			rtf.append("\\b0 ");
		}
		if (StyleConstants.isItalic(attrs))
		{
			rtf.append("\\i0 ");
		}
		if (StyleConstants.isStrikeThrough(attrs))
		{
			rtf.append("\\strike0 ");
		}
	}

	/**
	 * Escape special RTF characters
	 */
	private String escapeRtfText(String text)
	{
		return text.replace("\\", "\\\\")
			.replace("{", "\\{")
			.replace("}", "\\}")
			.replace("\n", "\\par") // Convert newlines to spaces instead of \par
			.replace("\r", "");
	}

}
package dev.seafoo.richtextnotes.ui.components.clipboard;

import dev.seafoo.richtextnotes.services.ItemIconService;
import java.awt.Color;
import java.awt.Font;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.event.ActionEvent;
import java.io.ByteArrayInputStream;
import java.nio.charset.StandardCharsets;
import javax.swing.JTextPane;
import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.JTextComponent;
import javax.swing.text.SimpleAttributeSet;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyledDocument;
import javax.swing.text.TextAction;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class EnhancedPasteAction extends TextAction
{

	private final ItemIconService itemIconService;

	public EnhancedPasteAction(ItemIconService itemIconService)
	{
		super("paste-from-clipboard");
		this.itemIconService = itemIconService;
	}

	@Override
	public void actionPerformed(ActionEvent e)
	{
		JTextComponent target = getTextComponent(e);
		if (target == null || !target.isEditable())
		{
			return;
		}

		try
		{
			Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();

			// First try to get our custom RTF data
			if (clipboard.isDataFlavorAvailable(NotesEnhancedTransferable.NOTES_ENHANCED_FLAVOR))
			{
				pasteNotesEnhancedRtf(target, clipboard);
			}
			else
			{
				// Fallback to plain text paste (strips all formatting)
				pastePlainTextOnly(target, clipboard);
			}

		}
		catch (Exception ex)
		{
			log.error("Failed to paste content", ex);
			// Final fallback to default paste
			target.paste();
		}
	}

	/**
	 * Paste RTF content using the existing RTF import mechanism
	 * This automatically converts placeholders back to icons
	 */
	private void pasteNotesEnhancedRtf(JTextComponent target, Clipboard clipboard) throws Exception
	{
		NotesEnhancedClipboardData data = (NotesEnhancedClipboardData)
			clipboard.getData(NotesEnhancedTransferable.NOTES_ENHANCED_FLAVOR);

		if (!(target instanceof JTextPane))
		{
			// Just paste plain text if not a JTextPane
			target.replaceSelection(data.getPlainText());
			return;
		}

		JTextPane textPane = (JTextPane) target;
		String rtfContent = data.getRtfContent();

		if (rtfContent == null || rtfContent.trim().isEmpty())
		{
			// No RTF content, use plain text with default formatting
			pastePlainTextWithDefaultFormatting(textPane, data.getPlainText());
			return;
		}

		// Use RTF import mechanism - this is atomic and handles icon restoration automatically
		pasteRtfContent(textPane, rtfContent);
	}

	/**
	 * Paste RTF content using the existing RTF reader
	 * This automatically converts icon placeholders back to icons
	 */
	private void pasteRtfContent(JTextPane textPane, String rtfContent) throws Exception
	{
		// Get current selection
		int selectionStart = textPane.getSelectionStart();
		int selectionEnd = textPane.getSelectionEnd();

		// Create a temporary document to load the RTF into
		StyledDocument tempDoc = (StyledDocument) textPane.getEditorKit().createDefaultDocument();

		// Load RTF content into temporary document
		ByteArrayInputStream bais = new ByteArrayInputStream(rtfContent.getBytes(StandardCharsets.UTF_8));
		textPane.getEditorKit().read(bais, tempDoc, 0);

		// Remove the trailing newline that RTF reader adds
		int tempLength = tempDoc.getLength();
		if (tempLength > 0)
		{
			String lastChar = tempDoc.getText(tempLength - 1, 1);
			if ("\n".equals(lastChar))
			{
				tempDoc.remove(tempLength - 1, 1);
			}
		}

		// Remove selected text first if any
		if (selectionStart != selectionEnd)
		{
			textPane.getDocument().remove(selectionStart, selectionEnd - selectionStart);
		}

		// Insert content using a simpler approach - transfer content directly
		if (tempDoc.getLength() > 0)
		{
			// Use the document's own transfer mechanism instead of element copying
			try
			{
				// Get all content from temp doc with attributes
				String plainText = tempDoc.getText(0, tempDoc.getLength());

				// Insert character by character to preserve formatting
				StyledDocument targetDoc = textPane.getStyledDocument();
				for (int i = 0; i < plainText.length(); i++)
				{
					AttributeSet attrs = tempDoc.getCharacterElement(i).getAttributes();
					String ch = plainText.substring(i, i + 1);
					targetDoc.insertString(selectionStart + i, ch, attrs);
				}
			}
			catch (BadLocationException e)
			{
				log.error("Failed to insert styled content", e);
				// Fallback to plain text
				textPane.replaceSelection(tempDoc.getText(0, tempDoc.getLength()));
			}
		}
	}

	/**
	 * Paste plain text with default formatting
	 */
	private void pastePlainTextWithDefaultFormatting(JTextPane textPane, String text) throws BadLocationException
	{
		if (text == null || text.isEmpty())
		{
			return;
		}

		// Use replaceSelection which is atomic
		int caretPos = textPane.getCaretPosition();
		textPane.replaceSelection(text);

		// Apply default formatting to the inserted text
		int newCaretPos = textPane.getCaretPosition();
		int textLength = newCaretPos - caretPos;

		if (textLength > 0)
		{
			StyledDocument doc = textPane.getStyledDocument();
			SimpleAttributeSet attrs = new SimpleAttributeSet();

			// Get current font family
			Font currentFont = textPane.getFont();
			if (currentFont != null)
			{
				StyleConstants.setFontFamily(attrs, currentFont.getFontName());
			}

			// Apply default styling
			StyleConstants.setFontSize(attrs, 16);
			StyleConstants.setForeground(attrs, Color.WHITE);
			StyleConstants.setBold(attrs, false);
			StyleConstants.setItalic(attrs, false);
			StyleConstants.setStrikeThrough(attrs, false);

			// Apply to the pasted text
			doc.setCharacterAttributes(caretPos, textLength, attrs, true);
		}
	}

	/**
	 * Fallback for plain text from external sources
	 */
	private void pastePlainTextOnly(JTextComponent target, Clipboard clipboard) throws Exception
	{
		if (clipboard.isDataFlavorAvailable(DataFlavor.stringFlavor))
		{
			String text = (String) clipboard.getData(DataFlavor.stringFlavor);

			if (target instanceof JTextPane)
			{
				pastePlainTextWithDefaultFormatting((JTextPane) target, text);
			}
			else
			{
				target.replaceSelection(text);
			}
		}
	}
}

package dev.seafoo.richtextnotes.ui.components.clipboard;

import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.io.IOException;
import lombok.extern.slf4j.Slf4j;

/**
 * Transferable implementation for Notes Enhanced clipboard operations
 */
@Slf4j
public class NotesEnhancedTransferable implements Transferable
{

	// Custom data flavor for our enhanced clipboard data
	public static final DataFlavor NOTES_ENHANCED_FLAVOR;

	// Standard data flavors
	private static final DataFlavor[] SUPPORTED_FLAVORS;

	static
	{
		DataFlavor customFlavor;
		customFlavor = new DataFlavor(
			"application/x-rich-text-notes-content;class=" + NotesEnhancedClipboardData.class.getName(),
			"Rich Text Notes Content"
		);
		NOTES_ENHANCED_FLAVOR = customFlavor;

		// Define supported flavors in order of preference
		SUPPORTED_FLAVORS = new DataFlavor[]{
			NOTES_ENHANCED_FLAVOR,      // Our custom format (highest priority)
			DataFlavor.stringFlavor     // Plain text (fallback)
		};
	}

	private final NotesEnhancedClipboardData clipboardData;

	public NotesEnhancedTransferable(NotesEnhancedClipboardData clipboardData)
	{
		this.clipboardData = clipboardData != null ? clipboardData : new NotesEnhancedClipboardData();
	}

	@Override
	public DataFlavor[] getTransferDataFlavors()
	{
		return SUPPORTED_FLAVORS.clone();
	}

	@Override
	public boolean isDataFlavorSupported(DataFlavor flavor)
	{
		for (DataFlavor supportedFlavor : SUPPORTED_FLAVORS)
		{
			if (supportedFlavor.equals(flavor))
			{
				return true;
			}
		}
		return false;
	}

	@Override
	public Object getTransferData(DataFlavor flavor) throws UnsupportedFlavorException, IOException
	{
		if (!isDataFlavorSupported(flavor))
		{
			throw new UnsupportedFlavorException(flavor);
		}

		try
		{
			// Return our custom data if requested
			if (NOTES_ENHANCED_FLAVOR.equals(flavor))
			{
				return clipboardData;
			}

			// Return plain text for standard text flavor
			if (DataFlavor.stringFlavor.equals(flavor))
			{
				String plainText = clipboardData.getPlainText();
				return plainText != null ? plainText : "";
			}

			// Should not reach here due to isDataFlavorSupported check
			throw new UnsupportedFlavorException(flavor);

		}
		catch (Exception e)
		{
			log.error("Error getting transfer data for flavor: " + flavor, e);

			// Fallback to plain text if something goes wrong
			if (DataFlavor.stringFlavor.equals(flavor))
			{
				return clipboardData.getPlainText() != null ? clipboardData.getPlainText() : "";
			}

			throw new IOException("Failed to get transfer data", e);
		}
	}
}
package dev.seafoo.richtextnotes.ui.components.clipboard;

import java.awt.Color;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Data container for Notes Enhanced clipboard operations
 * Stores text content, icon information, and formatting for proper copy/paste
 */
@Data
@NoArgsConstructor
public class NotesEnhancedClipboardData implements Serializable
{
	private static final long serialVersionUID = 2L; // Updated version

	// Plain text content (always available)
	private String plainText = "";

	// RTF content with formatting (if available)
	private String rtfContent = "";

	// Icon information for restoration
	private List<IconInfo> icons = new ArrayList<>();

	// Formatting information for text segments
	private List<FormattingRun> formatting = new ArrayList<>();

	/**
	 * Information about an icon in the clipboard content
	 */
	@Data
	@NoArgsConstructor
	public static class IconInfo implements Serializable
	{
		private static final long serialVersionUID = 1L;

		// Position in the text where this icon should be inserted
		public int position;

		// Item name (for display/fallback)
		public String itemName;

		// Item ID (for icon lookup)
		public int itemId;

		@Override
		public String toString()
		{
			return String.format("IconInfo{pos=%d, name='%s', id=%d}", position, itemName, itemId);
		}
	}

	/**
	 * Information about formatting for a segment of text
	 */
	@Data
	@NoArgsConstructor
	public static class FormattingRun implements Serializable
	{
		private static final long serialVersionUID = 1L;

		// Start position in the text
		public int startPosition;

		// Length of this formatting run
		public int length;

		// Formatting attributes
		public boolean bold = false;
		public boolean italic = false;
		public boolean strikethrough = false;
		public int fontSize = 16; // Default font size
		public Color textColor = Color.WHITE; // Default color

		@Override
		public String toString()
		{
			return String.format("FormattingRun{pos=%d, len=%d, bold=%s, italic=%s, strike=%s, size=%d}",
				startPosition, length, bold, italic, strikethrough, fontSize);
		}
	}
}
package dev.seafoo.richtextnotes.ui.components;

import dev.seafoo.richtextnotes.services.ItemIconService;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import javax.swing.Icon;
import javax.swing.event.UndoableEditEvent;
import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.DefaultStyledDocument;
import javax.swing.text.Element;
import javax.swing.text.SimpleAttributeSet;
import javax.swing.text.StyleConstants;
import lombok.extern.slf4j.Slf4j;

/**
 * Custom document that handles conversion between icons and text placeholders
 * for RTF saving/loading
 */
@Slf4j
public class NotesEnhancedDocument extends DefaultStyledDocument
{

	private static final String ICON_PLACEHOLDER_PREFIX = "{{ITEM:";
	private static final String ICON_PLACEHOLDER_SUFFIX = "}}";
	private static final String ICON_ATTRIBUTE = "item-icon-data";

	private boolean processingIcons = false;

	public NotesEnhancedDocument()
	{
		super();
	}


	/**
	 * Override fireUndoableEditUpdate to respect the undo tracking flag
	 */
	@Override
	protected void fireUndoableEditUpdate(UndoableEditEvent e)
	{
		if (!processingIcons)
		{
			super.fireUndoableEditUpdate(e);
		}
	}

	/**
	 * Convert all icons in the document to text placeholders
	 * Call this before saving to RTF
	 */
	public void convertIconsToPlaceholders()
	{
		if (processingIcons)
		{
			return;
		}

		processingIcons = true;
		try
		{
			List<IconPosition> iconPositions = findAllIcons();

			// Process in reverse order to maintain positions
			Collections.reverse(iconPositions);

			for (IconPosition iconPos : iconPositions)
			{
				try
				{
					// Remove the icon character
					remove(iconPos.position, 1);

					// Insert placeholder text with quantity
					String placeholder = createPlaceholder(iconPos.itemName, iconPos.itemId, iconPos.itemQuantity);
					insertString(iconPos.position, placeholder, null);

				}
				catch (BadLocationException e)
				{
					log.error("Failed to convert icon at position {}", iconPos.position, e);
				}
			}

			log.debug("Converted {} icons to placeholders", iconPositions.size());

		}
		finally
		{
			processingIcons = false;
		}
	}

	/**
	 * Convert all text placeholders back to icons
	 * Call this after loading from RTF
	 */
	public void convertPlaceholdersToIcons(ItemIconService itemIconService)
	{
		if (processingIcons || itemIconService == null)
		{
			return;
		}

		processingIcons = true;
		try
		{
			String text = getText(0, getLength());
			List<PlaceholderInfo> placeholders = findAllPlaceholders(text);

			// Process in reverse order to maintain positions
			Collections.reverse(placeholders);

			for (PlaceholderInfo placeholder : placeholders)
			{
				try
				{
					// Remove the placeholder text
					remove(placeholder.startPos, placeholder.length);

					// Insert icon using ItemIconService's centered icon with quantity
					SimpleAttributeSet attrs = new SimpleAttributeSet();

					// Get the centered icon from ItemIconService with quantity
					Icon centeredIcon = itemIconService.getCenteredIconById(placeholder.itemId, placeholder.itemQuantity);

					if (centeredIcon != null)
					{
						StyleConstants.setIcon(attrs, centeredIcon);

						// Store metadata for future conversion including quantity
						attrs.addAttribute(ICON_ATTRIBUTE,
							new IconData(placeholder.itemName, placeholder.itemId, placeholder.itemQuantity));

						insertString(placeholder.startPos, " ", attrs);

					}
					else
					{
						// If icon not found, keep the placeholder or insert item name with quantity
						String fallbackText = placeholder.itemQuantity > 1 ?
							"[" + placeholder.itemQuantity + "x " + placeholder.itemName + "]" :
							"[" + placeholder.itemName + "]";
						insertString(placeholder.startPos, fallbackText, null);
					}

				}
				catch (BadLocationException e)
				{
					log.error("Failed to restore icon for {}", placeholder.itemName, e);
				}
			}

			log.debug("Restored {} icons from placeholders", placeholders.size());

		}
		catch (BadLocationException e)
		{
			log.error("Failed to get document text", e);
		}
		finally
		{
			processingIcons = false;
		}
	}

	/**
	 * Find all icon positions in the document
	 */
	private List<IconPosition> findAllIcons()
	{
		List<IconPosition> positions = new ArrayList<>();

		Element root = getDefaultRootElement();
		scanElementForIcons(root, positions);

		return positions;
	}

	private void scanElementForIcons(Element element, List<IconPosition> positions)
	{
		if (element.isLeaf())
		{
			AttributeSet attrs = element.getAttributes();

			// Check if this element has an icon
			Object icon = attrs.getAttribute(StyleConstants.IconAttribute);
			if (icon != null)
			{
				// Try to get our custom icon data
				Object iconData = attrs.getAttribute(ICON_ATTRIBUTE);

				if (iconData instanceof IconData)
				{
					IconData data = (IconData) iconData;
					positions.add(new IconPosition(
						element.getStartOffset(),
						data.itemName,
						data.itemId,
						data.itemQuantity
					));
				}
				else
				{
					// Fallback - try to extract from icon filename or use default
					positions.add(new IconPosition(
						element.getStartOffset(),
						"unknown_item",
						0,
						1 // Default quantity
					));
				}
			}
		}
		else
		{
			// Recursively check child elements
			for (int i = 0; i < element.getElementCount(); i++)
			{
				scanElementForIcons(element.getElement(i), positions);
			}
		}
	}

	/**
	 * Find all placeholders in text
	 */
	private List<PlaceholderInfo> findAllPlaceholders(String text)
	{
		List<PlaceholderInfo> placeholders = new ArrayList<>();

		int searchStart = 0;
		while (searchStart < text.length())
		{
			int start = text.indexOf(ICON_PLACEHOLDER_PREFIX, searchStart);
			if (start == -1)
			{
				break;
			}

			int end = text.indexOf(ICON_PLACEHOLDER_SUFFIX, start);
			if (end == -1)
			{
				break;
			}

			end += ICON_PLACEHOLDER_SUFFIX.length();

			// Parse the placeholder
			String placeholder = text.substring(start, end);
			PlaceholderInfo info = parsePlaceholder(placeholder, start);

			if (info != null)
			{
				placeholders.add(info);
			}

			searchStart = end;
		}

		return placeholders;
	}

	private PlaceholderInfo parsePlaceholder(String placeholder, int position)
	{
		// Format: {{ITEM:itemId:itemName:itemQuantity}}
		if (!placeholder.startsWith(ICON_PLACEHOLDER_PREFIX) ||
			!placeholder.endsWith(ICON_PLACEHOLDER_SUFFIX))
		{
			return null;
		}

		String content = placeholder.substring(
			ICON_PLACEHOLDER_PREFIX.length(),
			placeholder.length() - ICON_PLACEHOLDER_SUFFIX.length()
		);

		String[] parts = content.split(":", 3);
		if (parts.length < 2)
		{
			return null;
		}

		try
		{
			int itemId = Integer.parseInt(parts[0]);
			String itemName = parts[1];
			int itemQuantity = 1; // Default quantity

			// Parse quantity if present
			if (parts.length >= 3)
			{
				try
				{
					itemQuantity = Integer.parseInt(parts[2]);
					if (itemQuantity < 1)
					{
						itemQuantity = 1;
					}
				}
				catch (NumberFormatException e)
				{
					log.warn("Invalid quantity in placeholder: {}, using default quantity 1", placeholder);
				}
			}

			return new PlaceholderInfo(
				position,
				placeholder.length(),
				itemName,
				itemId,
				itemQuantity
			);
		}
		catch (NumberFormatException e)
		{
			log.warn("Invalid placeholder format: {}", placeholder);
			return null;
		}
	}

	private String createPlaceholder(String itemName, int itemId, int itemQuantity)
	{
		return ICON_PLACEHOLDER_PREFIX + itemId + ":" + itemName + ":" + itemQuantity + ICON_PLACEHOLDER_SUFFIX;
	}

	// Helper classes

	private static class IconPosition
	{
		final int position;
		final String itemName;
		final int itemId;
		final int itemQuantity;

		IconPosition(int position, String itemName, int itemId, int itemQuantity)
		{
			this.position = position;
			this.itemName = itemName;
			this.itemId = itemId;
			this.itemQuantity = itemQuantity;
		}
	}

	private static class PlaceholderInfo
	{
		final int startPos;
		final int length;
		final String itemName;
		final int itemId;
		final int itemQuantity;

		PlaceholderInfo(int startPos, int length, String itemName, int itemId, int itemQuantity)
		{
			this.startPos = startPos;
			this.length = length;
			this.itemName = itemName;
			this.itemId = itemId;
			this.itemQuantity = itemQuantity;
		}
	}

	public static class IconData
	{
		public final String itemName;
		public final int itemId;
		public final int itemQuantity;

		public IconData(String itemName, int itemId, int itemQuantity)
		{
			this.itemName = itemName;
			this.itemId = itemId;
			this.itemQuantity = Math.max(1, itemQuantity); // Ensure minimum quantity of 1
		}
	}
}
package dev.seafoo.richtextnotes.ui.components;

import dev.seafoo.richtextnotes.RichTextNotesConfig;
import dev.seafoo.richtextnotes.models.Note;
import dev.seafoo.richtextnotes.services.ItemIconService;
import dev.seafoo.richtextnotes.ui.popups.InlineItemAutoComplete;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.KeyboardFocusManager;
import java.awt.Toolkit;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyEvent;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.nio.charset.StandardCharsets;
import javax.swing.ActionMap;
import javax.swing.BorderFactory;
import javax.swing.InputMap;
import javax.swing.JComponent;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextPane;
import javax.swing.KeyStroke;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.undo.UndoManager;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

/**
 * Rich Text Editor component for Notes Enhanced
 * Combines the NotesEnhancedEditorKit with FormattingToolbar
 */
@EqualsAndHashCode(callSuper = true)
@Slf4j
@Data
public class RichTextEditor extends JPanel
{

	private final Note note;
	private final Runnable changeCallback;

	// Components
	private NotesEnhancedEditorKit editorKit;
	private JTextPane textPane;
	private FormattingToolbar toolbar;
	private JScrollPane scrollPane;
	private ItemIconService itemIconService;
	private InlineItemAutoComplete autoComplete;
	private RichTextNotesConfig config;

	// Undo/Redo support
	private UndoManager undoManager;

	// State tracking
	private boolean documentChanging = false;
	private boolean toolbarVisible = true; // Track toolbar visibility state


	public RichTextEditor(Note note, Runnable changeCallback, ItemIconService itemIconService, RichTextNotesConfig config)
	{
		this.note = note;
		this.changeCallback = changeCallback;
		this.itemIconService = itemIconService;
		this.config = config;

		setupEditor();
		setupUndoRedo();
		loadContent();
		setupKeyboardShortcuts();
	}

	private void setupEditor()
	{
		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Create the editor kit with icon service
		editorKit = new NotesEnhancedEditorKit(itemIconService);
		textPane = editorKit.createTextPane();

		// Configure text pane
		textPane.setBorder(new EmptyBorder(10, 10, 10, 10));

		// Add focus listener to show/hide toolbar
		textPane.addFocusListener(new FocusListener()
		{
			@Override
			public void focusGained(FocusEvent e)
			{
				showToolbar();
			}

			@Override
			public void focusLost(FocusEvent e)
			{
				// Small delay to prevent flickering when clicking on toolbar buttons
				SwingUtilities.invokeLater(() -> {
					// Check if focus went to a toolbar component
					Component focusOwner = KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner();
					if (focusOwner != null && SwingUtilities.isDescendingFrom(focusOwner, toolbar))
					{
						// Focus went to toolbar, don't hide it
						return;
					}
					hideToolbar();
				});
			}
		});

		// Create scroll pane
		scrollPane = new JScrollPane(textPane);
		scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
		scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
		scrollPane.setBorder(BorderFactory.createEmptyBorder());
		scrollPane.getVerticalScrollBar().setUnitIncrement(16);

		scrollPane.setMinimumSize(new Dimension(100, 100));
		scrollPane.setPreferredSize(new Dimension(100, 100));

		// Create formatting toolbar
		toolbar = new FormattingToolbar(textPane, editorKit, itemIconService);

		// NEW: Create inline autocomplete if item service is available
		if (itemIconService != null)
		{
			autoComplete = new InlineItemAutoComplete(textPane, itemIconService);
		}

		// Add components - toolbar starts hidden
		add(toolbar, BorderLayout.NORTH);
		hideToolbar();
		add(scrollPane, BorderLayout.CENTER);

		// Add document listener for change tracking
		textPane.getDocument().addDocumentListener(new DocumentListener()
		{
			@Override
			public void insertUpdate(DocumentEvent e)
			{
				onTextChanged();
			}

			@Override
			public void removeUpdate(DocumentEvent e)
			{
				onTextChanged();
			}

			@Override
			public void changedUpdate(DocumentEvent e)
			{
				// This fires for attribute changes (formatting, icons, etc.)
				onTextChanged();
			}
		});
	}

	/**
	 * Setup undo/redo functionality
	 */
	private void setupUndoRedo()
	{
		// Create undo manager
		undoManager = new UndoManager();

		// Limit undo history to prevent memory issues
		undoManager.setLimit(100);

		// Add undoable edit listener to document
		textPane.getDocument().addUndoableEditListener(e -> {
			// Only add to undo history if we're not currently loading content
			if (!documentChanging)
			{
				undoManager.addEdit(e.getEdit());
			}
		});

		// Configure the undo/redo actions with our undo manager
		NotesEnhancedEditorKit.UndoAction undoAction =
			(NotesEnhancedEditorKit.UndoAction) editorKit.getCustomAction("undo");
		NotesEnhancedEditorKit.RedoAction redoAction =
			(NotesEnhancedEditorKit.RedoAction) editorKit.getCustomAction("redo");

		if (undoAction != null)
		{
			undoAction.setUndoManager(undoManager);
		}
		if (redoAction != null)
		{
			redoAction.setUndoManager(undoManager);
		}

	}

	/**
	 * Show the formatting toolbar
	 */
	private void showToolbar()
	{
		if (!toolbarVisible)
		{
			add(toolbar, BorderLayout.NORTH);
			toolbarVisible = true;
			revalidate();
			repaint();
			log.debug("Toolbar shown for note: {}", note != null ? note.getNoteId() : "unknown");
		}
	}

	/**
	 * Hide the formatting toolbar
	 */
	private void hideToolbar()
	{
		if (toolbarVisible && !config.alwaysShowToolbar())
		{
			remove(toolbar);
			toolbarVisible = false;
			revalidate();
			repaint();
			log.debug("Toolbar hidden for note: {}", note != null ? note.getNoteId() : "unknown");
		}
	}

	private void loadContent()
	{
		if (note == null || note.getRtfContent() == null)
		{
			return;
		}

		documentChanging = true;

		try
		{
			// Clear undo history when loading new content
			if (undoManager != null)
			{
				undoManager.discardAllEdits();
				log.debug("Cleared undo history for content load");
			}

			String content = note.getRtfContent();

			if (content.trim().isEmpty())
			{
				// Empty content, just clear the editor
				textPane.setText("");
			}
			else if (isRtfContent(content))
			{
				// Load RTF content - icons will be automatically restored
				loadRtfContent(content);
			}
			else
			{
				// Plain text content
				textPane.setText(content);
			}

		}
		catch (Exception e)
		{
			log.error("Failed to load note content", e);
			// Fallback to plain text
			textPane.setText(note.getRtfContent() != null ? note.getRtfContent() : "");
		}
		finally
		{
			documentChanging = false;

			// Reset the modified flag since we just loaded content
			if (note != null)
			{
				note.markSaved();
			}
		}
	}

	private boolean isRtfContent(String content)
	{
		return content.trim().startsWith("{\\rtf");
	}

	private void loadRtfContent(String rtfContent)
	{
		try
		{
			ByteArrayInputStream bais = new ByteArrayInputStream(rtfContent.getBytes(StandardCharsets.UTF_8));
			textPane.getEditorKit().read(bais, textPane.getDocument(), 0);
		}
		catch (Exception e)
		{
			log.warn("Failed to load RTF content, falling back to plain text", e);
			textPane.setText(rtfContent);
		}
	}

	private void setupKeyboardShortcuts()
	{
		int shortcutKeyMask = Toolkit.getDefaultToolkit().getMenuShortcutKeyMaskEx();

		// Add common keyboard shortcuts
		InputMap inputMap = textPane.getInputMap(JComponent.WHEN_FOCUSED);
		ActionMap actionMap = textPane.getActionMap();

		// Bold: Ctrl+B
		inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_B, shortcutKeyMask), "toggle-bold");
		actionMap.put("toggle-bold", editorKit.getCustomAction("toggle-bold"));

		// Italic: Ctrl+I
		inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_I, shortcutKeyMask), "toggle-italic");
		actionMap.put("toggle-italic", editorKit.getCustomAction("toggle-italic"));

		// Strikethrough: Ctrl+Shift+S
		inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_S, shortcutKeyMask | KeyEvent.SHIFT_DOWN_MASK), "toggle-strikethrough");
		actionMap.put("toggle-strikethrough", editorKit.getCustomAction("toggle-strikethrough"));

		// Undo: Ctrl+Z
		inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_Z, shortcutKeyMask), "undo");
		actionMap.put("undo", editorKit.getCustomAction("undo"));

		// Redo: Ctrl+Y
		inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_Y, shortcutKeyMask), "redo");
		actionMap.put("redo", editorKit.getCustomAction("redo"));

		// Enhanced Copy: Ctrl+C
		inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_C, shortcutKeyMask), "copy-to-clipboard");
		actionMap.put("copy-to-clipboard", editorKit.getCustomAction("copy-to-clipboard"));

		// Enhanced Paste: Ctrl+V
		inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_V, shortcutKeyMask), "paste-from-clipboard");
		actionMap.put("paste-from-clipboard", editorKit.getCustomAction("paste-from-clipboard"));

		// Enhanced Cut: Ctrl+X
		inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_X, shortcutKeyMask), "cut-to-clipboard");
		actionMap.put("cut-to-clipboard", editorKit.getCustomAction("cut-to-clipboard"));

		// Force enter to insert a break with modifiers
		inputMap.put(KeyStroke.getKeyStroke("shift ENTER"), "insert-break");
		inputMap.put(KeyStroke.getKeyStroke("ctrl ENTER"), "insert-break");
		inputMap.put(KeyStroke.getKeyStroke("ctrl shift ENTER"), "insert-break");
		inputMap.put(KeyStroke.getKeyStroke("alt ENTER"), "insert-break");
		inputMap.put(KeyStroke.getKeyStroke("meta ENTER"), "insert-break");
		inputMap.put(KeyStroke.getKeyStroke("meta shift ENTER"), "insert-break");


	}

	private void onTextChanged()
	{
		if (documentChanging || note == null)
		{
			return;
		}

		// Update the note content
		try
		{
			note.setModified(true);
		}
		catch (Exception e)
		{
			log.error("Error saving content", e);
		}

		// Notify change callback
		if (changeCallback != null)
		{
			SwingUtilities.invokeLater(changeCallback);
		}
	}

	/**
	 * Get the current content as RTF string
	 * Icons are automatically converted to placeholders during this process
	 */
	public String getContentAsRtf()
	{
		try
		{
			ByteArrayOutputStream baos = new ByteArrayOutputStream();
			textPane.getEditorKit().write(baos, textPane.getDocument(), 0, textPane.getDocument().getLength());
			return baos.toString(String.valueOf(StandardCharsets.UTF_8));
		}
		catch (Exception e)
		{
			log.warn("Failed to export RTF content, using plain text", e);
			return textPane.getText();
		}
	}

	/**
	 * Set content from RTF string
	 * Icons are automatically restored from placeholders during this process
	 */
	public void setContent(String rtfContent)
	{
		documentChanging = true;

		try
		{
			// Clear undo history when setting new content
			if (undoManager != null)
			{
				undoManager.discardAllEdits();
				log.debug("Cleared undo history for content change");
			}

			if (rtfContent == null || rtfContent.trim().isEmpty())
			{
				textPane.setText("");
			}
			else if (isRtfContent(rtfContent))
			{
				loadRtfContent(rtfContent);
			}
			else
			{
				textPane.setText(rtfContent);
			}
		}
		finally
		{
			documentChanging = false;
		}
	}

	/**
	 * Request focus on the text editor
	 */
	public void requestEditorFocus()
	{
		textPane.requestFocus();
	}


	/**
	 * Enable or disable the editor
	 */
	@Override
	public void setEnabled(boolean enabled)
	{
		super.setEnabled(enabled);
		textPane.setEditable(enabled);
		toolbar.setEnabled(enabled);
	}
}
package dev.seafoo.richtextnotes.ui.components;

import java.awt.Component;
import java.util.ArrayList;
import java.util.List;
import javax.swing.ImageIcon;
import javax.swing.SwingUtilities;
import javax.swing.text.JTextComponent;
import net.runelite.client.util.AsyncBufferedImage;

/**
 * ImageIcon wrapper that properly handles AsyncBufferedImage loading
 * and triggers component repaints when the image loads
 */
public class AsyncImageIcon extends ImageIcon
{
	private final AsyncBufferedImage asyncImage;
	private final List<Component> componentsToRepaint = new ArrayList<>();

	public AsyncImageIcon(AsyncBufferedImage asyncImage)
	{
		super(asyncImage);
		this.asyncImage = asyncImage;

		// Register for load notification
		if (asyncImage != null)
		{
			asyncImage.onLoaded(() -> SwingUtilities.invokeLater(this::repaintComponents));
		}
	}

	/**
	 * Attach this icon to a component that should be repainted when the image loads
	 */
	public void attachToComponent(Component component)
	{
		if (component != null && !componentsToRepaint.contains(component))
		{
			componentsToRepaint.add(component);
			// If already loaded, repaint immediately
			if (asyncImage != null)
			{
				asyncImage.onLoaded(() -> SwingUtilities.invokeLater(() -> {
					component.repaint();
					// For text components, also revalidate
					if (component instanceof JTextComponent)
					{
						component.revalidate();
					}
				}));
			}
		}
	}

	private void repaintComponents()
	{
		for (Component component : componentsToRepaint)
		{
			if (component != null)
			{
				component.repaint();
				// For text components, also revalidate to ensure proper layout
				if (component instanceof JTextComponent)
				{
					component.revalidate();
				}
			}
		}
	}

	/**
	 * Create an AsyncImageIcon and automatically attach it to the component
	 */
	public static AsyncImageIcon createAndAttach(AsyncBufferedImage asyncImage, Component component)
	{
		if (asyncImage == null)
		{
			return null;
		}
		AsyncImageIcon icon = new AsyncImageIcon(asyncImage);
		icon.attachToComponent(component);
		return icon;
	}

}
package dev.seafoo.richtextnotes;

import com.google.gson.Gson;
import com.google.inject.Provides;
import dev.seafoo.richtextnotes.services.FileStorageService;
import dev.seafoo.richtextnotes.services.ItemIconService;
import dev.seafoo.richtextnotes.ui.panels.NotesPanel;
import java.awt.image.BufferedImage;
import javax.inject.Inject;
import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ProfileChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;

@Slf4j
@PluginDescriptor(
	name = "Rich Text Notes",
	description = "Enhanced notes plugin with rich text formatting and item icons",
	tags = {"notes", "rich", "text", "enhanced", "sidebar", "markdown"}
)
public class RichTextNotesPlugin extends Plugin
{

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private RichTextNotesConfig config;

	@Inject
	private ConfigManager configManager;

	@Inject
	private ItemIconService itemIconService;

	@Inject
	private Gson gson;

	private NotesPanel panel;
	private NavigationButton navButton;
	private FileStorageService storageService;

	@Provides
	RichTextNotesConfig getConfig(ConfigManager configManager)
	{
		return configManager.getConfig(RichTextNotesConfig.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		try
		{
			// Initialize storage service with configManager
			storageService = new FileStorageService(configManager, gson);

			log.debug("Rich Text Notes Initialized with profile: {}", storageService.getCurrentProfileName());

			// Create and initialize the panel
			panel = injector.getInstance(NotesPanel.class);
			panel.init(config, storageService, itemIconService);

			// Create navigation button
			final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "icons/rich_text_notes_icon.png");

			navButton = NavigationButton.builder()
				.tooltip("Rich Text Notes")
				.icon(icon)
				.priority(7)
				.panel(panel)
				.build();

			clientToolbar.addNavigation(navButton);

			log.info("Rich Text Notes plugin started successfully for profile: {}",
				storageService.getDisplayProfileName());

		}
		catch (Exception e)
		{
			log.error("Failed to start Rich Text Notes plugin", e);

			SwingUtilities.invokeLater(() -> JOptionPane.showMessageDialog(
				null,
				"Failed to start Rich Text Notes plugin:\n" + e.getMessage(),
				"Rich Text Notes Error",
				JOptionPane.ERROR_MESSAGE
			));

			throw new Exception(e);
		}
	}

	@Override
	protected void shutDown()
	{
		try
		{
			if (panel != null)
			{
				panel.saveAllNotes();
				panel.saveEditorLayout();
			}

			if (navButton != null)
			{
				clientToolbar.removeNavigation(navButton);
			}

			if (panel != null)
			{
				panel.cleanup();
			}

		}
		catch (Exception e)
		{
			log.error("Error during plugin shutdown", e);
		}
	}

	@Subscribe
	public void onProfileChanged(ProfileChanged profileChanged)
	{
		log.debug("Profile changed event received");

		try
		{
			// Save current state before switching
			if (panel != null)
			{
				panel.saveAllNotes();
				panel.saveEditorLayout();
			}

			String newProfile = storageService.updateCurrentProfile();

			// Switch panel to new profile
			if (panel != null)
			{
				panel.switchProfile(newProfile);
			}

			log.debug("Successfully switched to profile: {}", storageService.getDisplayProfileName());
		}
		catch (Exception e)
		{
			log.error("Error handling profile change", e);

			SwingUtilities.invokeLater(() -> JOptionPane.showMessageDialog(
				panel,
				"Failed to switch to new profile:\n" + e.getMessage(),
				"Profile Switch Error",
				JOptionPane.WARNING_MESSAGE
			));
		}
	}
}
package dev.seafoo.richtextnotes.services;

import com.google.gson.Gson;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import dev.seafoo.richtextnotes.models.EditorLayout;
import dev.seafoo.richtextnotes.models.NoteMetadata;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.Type;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.ConfigProfile;

@Slf4j
public class FileStorageService
{
	private static final String NOTES_ENHANCED_DIR = "rich-text-notes";
	private static final String NOTES_SUBDIR = "notes";
	private static final String BACKUP_SUBDIR = "backups";

	private static final String DEFAULT_PROFILE = "default_profile";

	private static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ISO_LOCAL_DATE_TIME;


	private final Gson gson;
	private final Path baseDirectory;
	private final ConfigManager configManager;
	private String currentProfileDirectory;

	public FileStorageService(ConfigManager configManager, Gson gson)
	{
		this.configManager = configManager;
		this.gson = gson.newBuilder().setPrettyPrinting()
			.registerTypeAdapter(LocalDateTime.class, new LocalDateTimeTypeAdapter())
			.create();
		this.baseDirectory = RuneLite.RUNELITE_DIR.toPath().resolve(NOTES_ENHANCED_DIR);

		initializeDirectories();
		updateCurrentProfile();
	}

	private void initializeDirectories()
	{
		try
		{
			Files.createDirectories(baseDirectory);
			log.debug("Initialized rich-text-notes directory structure at: {}", baseDirectory);
		}
		catch (IOException e)
		{
			log.error("Failed to initialize directory structure", e);
			throw new RuntimeException("Could not create notes directories", e);
		}
	}

	/**
	 * Profile Management Methods
	 */

	public String getCurrentProfileName()
	{
		if (configManager != null)
		{
			ConfigProfile profile = configManager.getProfile();
			if (profile != null)
			{
				return profile.getName();
			}
		}
		return DEFAULT_PROFILE;
	}

	public String getDisplayProfileName()
	{
		return getCurrentProfileName();
	}

	public String updateCurrentProfile()
	{
		String newProfileDir = determineProfileDirectory();

		if (!newProfileDir.equals(currentProfileDirectory))
		{
			String oldProfile = currentProfileDirectory;
			currentProfileDirectory = newProfileDir;
			createProfileDirectories();

			log.debug("Profile directory changed: {} -> {}", oldProfile, newProfileDir);
		}

		return getCurrentProfileName();
	}

	private String determineProfileDirectory()
	{
		if (configManager != null)
		{
			ConfigProfile profile = configManager.getProfile();
			if (profile != null)
			{
				// Use profile ID to ensure uniqueness even if names are similar
				return "profile_" + profile.getId() + "_" + sanitizeProfileName(profile.getName());
			}
		}
		return DEFAULT_PROFILE;
	}

	private void createProfileDirectories()
	{
		try
		{
			Path profileDir = getProfileDirectory();
			Files.createDirectories(profileDir.resolve(NOTES_SUBDIR));
			Files.createDirectories(profileDir.resolve(BACKUP_SUBDIR));

			log.debug("Created directories for profile: {}", currentProfileDirectory);

		}
		catch (IOException e)
		{
			log.error("Failed to create profile directories for: {}", currentProfileDirectory, e);
			throw new RuntimeException("Could not create profile directories", e);
		}
	}

	private String sanitizeProfileName(String profileName)
	{
		if (profileName == null || profileName.trim().isEmpty())
		{
			return "unnamed";
		}

		// Remove invalid filename characters and limit length
		return profileName.replaceAll("[^a-zA-Z0-9_-]", "_")
			.substring(0, Math.min(profileName.length(), 30));
	}

	public Path getProfileDirectory()
	{
		if (currentProfileDirectory == null)
		{
			throw new IllegalStateException("No profile directory set");
		}
		return baseDirectory.resolve(currentProfileDirectory);
	}

	/**
	 * Note file operations
	 */

	public String saveNote(String noteId, String rtfContent) throws IOException
	{
		if (noteId == null)
		{
			noteId = generateNoteId();
		}

		Path noteFile = getProfileDirectory().resolve(NOTES_SUBDIR).resolve(noteId + ".rtf");

		// Create backup if file exists
		if (Files.exists(noteFile))
		{
			createBackup(noteId);
		}

		Files.write(noteFile, rtfContent.getBytes(StandardCharsets.UTF_8));
		log.debug("Saved note: {} for profile: {}", noteId, getCurrentProfileName());
		return noteId;
	}

	public String loadNote(String noteId) throws IOException
	{
		Path noteFile = getProfileDirectory().resolve(NOTES_SUBDIR).resolve(noteId + ".rtf");

		if (!Files.exists(noteFile))
		{
			throw new FileNotFoundException("Note not found: " + noteId + " in profile: " + getCurrentProfileName());
		}

		return new String(Files.readAllBytes(noteFile), StandardCharsets.UTF_8);
	}

	public void deleteNote(String noteId) throws IOException
	{
		// Create backup before deletion
		createBackup(noteId);

		Path noteFile = getProfileDirectory().resolve(NOTES_SUBDIR).resolve(noteId + ".rtf");
		Path metadataFile = getProfileDirectory().resolve(NOTES_SUBDIR).resolve(noteId + ".json");

		Files.deleteIfExists(noteFile);
		Files.deleteIfExists(metadataFile);
		log.debug("Deleted note: {} from profile: {}", noteId, getCurrentProfileName());
	}

	/**
	 * Metadata operations
	 */

	public void saveNoteMetadata(String noteId, NoteMetadata metadata) throws IOException
	{
		Path metadataFile = getProfileDirectory().resolve(NOTES_SUBDIR).resolve(noteId + ".json");
		String json = gson.toJson(metadata);
		Files.write(metadataFile, json.getBytes(StandardCharsets.UTF_8));
	}

	public NoteMetadata loadNoteMetadata(String noteId) throws IOException
	{
		Path metadataFile = getProfileDirectory().resolve(NOTES_SUBDIR).resolve(noteId + ".json");

		if (!Files.exists(metadataFile))
		{
			// Return default metadata if none exists
			return new NoteMetadata(noteId, "Untitled Note", LocalDateTime.now(), new ArrayList<>());
		}

		String json = new String(Files.readAllBytes(metadataFile), StandardCharsets.UTF_8);
		return gson.fromJson(json, NoteMetadata.class);
	}

	/**
	 * Layout persistence
	 */

	public void saveEditorLayout(EditorLayout layout) throws IOException
	{
		Path layoutFile = getProfileDirectory().resolve("layout.json");
		String json = gson.toJson(layout);
		Files.write(layoutFile, json.getBytes(StandardCharsets.UTF_8));
	}

	public EditorLayout loadEditorLayout() throws IOException
	{
		Path layoutFile = getProfileDirectory().resolve("layout.json");

		if (!Files.exists(layoutFile))
		{
			return new EditorLayout(); // Return default layout
		}

		String json = new String(Files.readAllBytes(layoutFile), StandardCharsets.UTF_8);
		return gson.fromJson(json, EditorLayout.class);
	}

	/**
	 * List operations
	 */

	public List<String> listNotes() throws IOException
	{
		Path notesDir = getProfileDirectory().resolve(NOTES_SUBDIR);

		if (!Files.exists(notesDir))
		{
			return new ArrayList<>();
		}

		return Files.list(notesDir)
			.filter(path -> path.toString().endsWith(".rtf"))
			.map(path -> {
				String filename = path.getFileName().toString();
				return filename.substring(0, filename.length() - 4); // Remove .rtf extension
			})
			.collect(Collectors.toList());
	}

	public List<NoteMetadata> listNotesWithMetadata() throws IOException
	{
		List<String> noteIds = listNotes();
		List<NoteMetadata> metadataList = new ArrayList<>();

		for (String noteId : noteIds)
		{
			try
			{
				metadataList.add(loadNoteMetadata(noteId));
			}
			catch (IOException e)
			{
				log.warn("Could not load metadata for note: {} in profile: {}", noteId, getCurrentProfileName(), e);
				// Add default metadata for notes without metadata files
				metadataList.add(new NoteMetadata(noteId, "Untitled Note", LocalDateTime.now(), new ArrayList<>()));
			}
		}

		return metadataList;
	}

	/**
	 * Backup operations
	 */

	private void createBackup(String noteId) throws IOException
	{
		Path noteFile = getProfileDirectory().resolve(NOTES_SUBDIR).resolve(noteId + ".rtf");
		Path metadataFile = getProfileDirectory().resolve(NOTES_SUBDIR).resolve(noteId + ".json");

		if (!Files.exists(noteFile))
		{
			return; // Nothing to back up
		}

		String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
		Path backupDir = getProfileDirectory().resolve(BACKUP_SUBDIR).resolve(timestamp);
		Files.createDirectories(backupDir);

		Files.copy(noteFile, backupDir.resolve(noteId + ".rtf"));
		if (Files.exists(metadataFile))
		{
			Files.copy(metadataFile, backupDir.resolve(noteId + ".json"));
		}
	}

	public void createFullBackup() throws IOException
	{
		String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
		Path backupDir = getProfileDirectory().resolve(BACKUP_SUBDIR).resolve("full_" + timestamp);
		Files.createDirectories(backupDir);

		// Copy all notes and metadata
		copyDirectoryRecursively(getProfileDirectory().resolve(NOTES_SUBDIR),
			backupDir.resolve(NOTES_SUBDIR));
		copyDirectoryRecursively(getProfileDirectory().resolve(NOTES_SUBDIR),
			backupDir.resolve(NOTES_SUBDIR));

		// Copy layout
		Path layoutFile = getProfileDirectory().resolve("layout.json");
		if (Files.exists(layoutFile))
		{
			Files.copy(layoutFile, backupDir.resolve("layout.json"));
		}

		log.debug("Created full backup for profile {}: {}", getCurrentProfileName(), backupDir);
	}

	private void copyDirectoryRecursively(Path source, Path target) throws IOException
	{
		if (!Files.exists(source))
		{
			return;
		}

		Files.createDirectories(target);
		Files.walk(source)
			.forEach(sourcePath -> {
				try
				{
					Path targetPath = target.resolve(source.relativize(sourcePath));
					if (Files.isDirectory(sourcePath))
					{
						Files.createDirectories(targetPath);
					}
					else
					{
						Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING);
					}
				}
				catch (IOException e)
				{
					log.error("Failed to copy: {}", sourcePath, e);
				}
			});
	}

	private String generateNoteId()
	{
		return "note_" + System.currentTimeMillis() + "_" + new Random().nextInt(1000);
	}

	public boolean noteExists(String noteId)
	{
		Path noteFile = getProfileDirectory().resolve(NOTES_SUBDIR).resolve(noteId + ".rtf");
		return Files.exists(noteFile);
	}

	public Path getNotesDirectory()
	{
		return getProfileDirectory().resolve(NOTES_SUBDIR);
	}

	private static class LocalDateTimeTypeAdapter implements JsonSerializer<LocalDateTime>, JsonDeserializer<LocalDateTime>
	{
		@Override
		public JsonElement serialize(LocalDateTime localDateTime, Type type, JsonSerializationContext context)
		{
			// Serialize as ISO string
			return new JsonPrimitive(localDateTime.format(DATE_TIME_FORMATTER));
		}

		@Override
		public LocalDateTime deserialize(JsonElement jsonElement, Type type, JsonDeserializationContext context)
			throws JsonParseException
		{
			try
			{
				// Handle the case where it's already a primitive string
				if (jsonElement.isJsonPrimitive())
				{
					String dateTimeString = jsonElement.getAsString();
					return LocalDateTime.parse(dateTimeString, DATE_TIME_FORMATTER);
				}

				// Handle the complex object format that's causing the issue
				if (jsonElement.isJsonObject())
				{
					JsonObject dateTimeObj = jsonElement.getAsJsonObject();

					// Check if it has the nested structure: {"date": {...}, "time": {...}}
					if (dateTimeObj.has("date") && dateTimeObj.has("time"))
					{
						JsonObject dateObj = dateTimeObj.getAsJsonObject("date");
						JsonObject timeObj = dateTimeObj.getAsJsonObject("time");

						int year = dateObj.get("year").getAsInt();
						int month = dateObj.get("month").getAsInt();
						int day = dateObj.get("day").getAsInt();

						int hour = timeObj.get("hour").getAsInt();
						int minute = timeObj.get("minute").getAsInt();
						int second = timeObj.get("second").getAsInt();
						int nano = timeObj.has("nano") ? timeObj.get("nano").getAsInt() : 0;

						return LocalDateTime.of(year, month, day, hour, minute, second, nano);
					}

					// Handle direct object format: {"year": 2025, "month": 8, ...}
					if (dateTimeObj.has("year") && dateTimeObj.has("month"))
					{
						int year = dateTimeObj.get("year").getAsInt();
						int month = dateTimeObj.get("month").getAsInt();
						int day = dateTimeObj.get("day").getAsInt();
						int hour = dateTimeObj.has("hour") ? dateTimeObj.get("hour").getAsInt() : 0;
						int minute = dateTimeObj.has("minute") ? dateTimeObj.get("minute").getAsInt() : 0;
						int second = dateTimeObj.has("second") ? dateTimeObj.get("second").getAsInt() : 0;
						int nano = dateTimeObj.has("nano") ? dateTimeObj.get("nano").getAsInt() : 0;

						return LocalDateTime.of(year, month, day, hour, minute, second, nano);
					}
				}

				// Fallback - try to parse as string
				String dateTimeString = jsonElement.getAsString();
				return LocalDateTime.parse(dateTimeString, DATE_TIME_FORMATTER);

			}
			catch (DateTimeParseException e)
			{
				log.warn("Failed to parse LocalDateTime from: {}, using current time", jsonElement, e);
				return LocalDateTime.now();
			}
			catch (Exception e)
			{
				log.error("Unexpected error parsing LocalDateTime from: {}, using current time", jsonElement, e);
				return LocalDateTime.now();
			}
		}
	}

}
package dev.seafoo.richtextnotes.services;

import dev.seafoo.richtextnotes.ui.components.AsyncImageIcon;
import java.awt.Component;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Image;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.SwingUtilities;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.AsyncBufferedImage;

/**
 * Service for managing item icons in notes
 */
@Slf4j
@Singleton
public class ItemIconService
{

	private static final int MAX_SEARCH_RESULTS = 60;

	@Inject
	private ItemManager itemManager;

	@Inject
	private ClientThread clientThread;

	@Inject
	private Client client;


	/**
	 * Search items by name - main search method for toolbar functionality
	 * Uses ClientThread internally so it's safe to call from any thread
	 */
	public void searchItems(String query, Consumer<List<ItemSearchResult>> callback)
	{
		if (itemManager == null || clientThread == null)
		{
			log.warn("Item service not ready for searching");
			SwingUtilities.invokeLater(() -> callback.accept(new ArrayList<>()));
			return;
		}

		String search = query.toLowerCase().trim();
		if (search.isEmpty())
		{
			SwingUtilities.invokeLater(() -> callback.accept(new ArrayList<>()));
			return;
		}

		// Run search on client thread
		clientThread.invoke(() -> {
			try
			{
				List<ItemSearchResult> results = performItemSearch(search);

				// Return results on EDT
				SwingUtilities.invokeLater(() -> callback.accept(results));

			}
			catch (Exception e)
			{
				log.error("Error during item search", e);
				SwingUtilities.invokeLater(() -> callback.accept(new ArrayList<>()));
			}
		});
	}

	/**
	 * Core search logic based on ChatboxItemSearch.filterResults()
	 * Must be called on client thread
	 */
	private List<ItemSearchResult> performItemSearch(String search)
	{
		Map<Integer, ItemSearchResult> resultMap = new LinkedHashMap<>();
		Set<ItemIconData> seenIcons = new HashSet<>();

		try
		{
			// Iterate through items like ChatboxItemSearch does
			for (int i = 0; i < client.getItemCount() && resultMap.size() < MAX_SEARCH_RESULTS; i++)
			{
				try
				{
					net.runelite.api.ItemComposition itemComposition = itemManager.getItemComposition(itemManager.canonicalize(i));

					String name = itemComposition.getName().toLowerCase();

					// Same filtering logic as ChatboxItemSearch
					if (!"null".equals(name) && name.contains(search) && !resultMap.containsKey(itemComposition.getId()))
					{

						// Check for duplicate item images (same logic as ChatboxItemSearch)
						ItemIconData iconData = new ItemIconData(
							itemComposition.getInventoryModel(),
							itemComposition.getAmbient(),
							itemComposition.getContrast(),
							itemComposition.getColorToReplaceWith(),
							itemComposition.getTextureToReplaceWith()
						);

						if (seenIcons.contains(iconData))
						{
							continue; // Skip duplicate item images
						}

						seenIcons.add(iconData);
						ItemSearchResult result = new ItemSearchResult(
							itemComposition.getId(),
							itemComposition.getName(),
							itemComposition.getName().toLowerCase().replace(" ", "_")
						);
						resultMap.put(itemComposition.getId(), result);
					}

				}
				catch (Exception e)
				{
					log.error("Error in performItemSearch", e);
				}
			}

		}
		catch (Exception e)
		{
			log.error("Error in performItemSearch", e);
		}

		return new ArrayList<>(resultMap.values());
	}

	/**
	 * Get item image by item ID with default quantity of 1
	 */
	public AsyncBufferedImage getItemImageById(int itemId)
	{
		return getItemImageById(itemId, 1);
	}

	/**
	 * Get item image by item ID with specified quantity
	 */
	public AsyncBufferedImage getItemImageById(int itemId, int quantity)
	{
		if (itemManager == null)
		{
			return null;
		}

		try
		{
			// Ensure quantity is at least 1
			int validQuantity = Math.max(1, quantity);

			return itemManager.getImage(itemId, validQuantity, false);

		}
		catch (Exception e)
		{
			log.error("Failed to get image for item ID: {} with quantity: {}", itemId, quantity, e);
			return null;
		}
	}

	/**
	 * Create a centered icon for use in text documents
	 * This centers the icon vertically relative to the text baseline
	 */
	public Icon createCenteredIcon(Image image)
	{
		if (image == null)
		{
			return null;
		}
		return new CenteredImageIcon(image);
	}


	/**
	 * Get a centered icon by item ID with specified quantity
	 * This is the recommended method for getting icons for text insertion
	 */
	public Icon getCenteredIconById(int itemId, int quantity)
	{
		AsyncBufferedImage itemImage = getItemImageById(itemId, quantity);
		return createCenteredIcon(itemImage);
	}

	/**
	 * Item search result
	 */
	@Getter
	public static class ItemSearchResult
	{
		private final int id;
		private final String name;
		private final String searchName; // underscore version for inserting

		public ItemSearchResult(int id, String name, String searchName)
		{
			this.id = id;
			this.name = name;
			this.searchName = searchName;
		}

		@Override
		public String toString()
		{
			return name;
		}
	}

	/**
	 * Item icon data for duplicate detection (same as ChatboxItemSearch.ItemIcon)
	 */
	private static class ItemIconData
	{
		final int modelId;
		final int ambient;
		final int contrast;
		final short[] colorsToReplace;
		final short[] texturesToReplace;

		ItemIconData(int modelId, int ambient, int contrast, short[] colorsToReplace, short[] texturesToReplace)
		{
			this.modelId = modelId;
			this.ambient = ambient;
			this.contrast = contrast;
			this.colorsToReplace = colorsToReplace;
			this.texturesToReplace = texturesToReplace;
		}

		@Override
		public boolean equals(Object obj)
		{
			if (this == obj)
			{
				return true;
			}
			if (obj == null || getClass() != obj.getClass())
			{
				return false;
			}
			ItemIconData that = (ItemIconData) obj;
			return modelId == that.modelId &&
				ambient == that.ambient &&
				contrast == that.contrast &&
				java.util.Arrays.equals(colorsToReplace, that.colorsToReplace) &&
				java.util.Arrays.equals(texturesToReplace, that.texturesToReplace);
		}

		@Override
		public int hashCode()
		{
			int result = modelId;
			result = 31 * result + ambient;
			result = 31 * result + contrast;
			result = 31 * result + java.util.Arrays.hashCode(colorsToReplace);
			result = 31 * result + java.util.Arrays.hashCode(texturesToReplace);
			return result;
		}
	}

	/**
	 * Centered image icon that adjusts vertical positioning for text alignment
	 */
	public static class CenteredImageIcon implements Icon
	{
		private final Icon baseIcon;
		private Component attachedComponent;

		public CenteredImageIcon(Image image)
		{
			// Use AsyncImageIcon if it's an AsyncBufferedImage, otherwise ImageIcon
			if (image instanceof AsyncBufferedImage)
			{
				this.baseIcon = new AsyncImageIcon((AsyncBufferedImage) image);
			}
			else
			{
				this.baseIcon = new ImageIcon(image);
			}
		}

		/**
		 * Attach to a component for repaint on load
		 */
		public void attachToComponent(Component component)
		{
			this.attachedComponent = component;
			if (baseIcon instanceof AsyncImageIcon)
			{
				((AsyncImageIcon) baseIcon).attachToComponent(component);
			}
		}

		@Override
		public void paintIcon(Component c, Graphics g, int x, int y)
		{
			// Ensure we're attached to the component being painted
			if (c != attachedComponent)
			{
				attachToComponent(c);
			}

			FontMetrics fm = c.getFontMetrics(c.getFont());
			int iconHeight = baseIcon.getIconHeight();
			int fontAscent = fm.getAscent();

			// Calculate vertical offset to center icon with text baseline
			int yOffset = fontAscent - (iconHeight / 2);
			// Additional adjustment for better visual centering
			yOffset += 8;

			baseIcon.paintIcon(c, g, x, y + yOffset);
		}

		@Override
		public int getIconWidth()
		{
			return baseIcon.getIconWidth();
		}

		@Override
		public int getIconHeight()
		{
			return baseIcon.getIconHeight();
		}
	}

}
package dev.seafoo.richtextnotes;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class RichTextNotesTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(RichTextNotesPlugin.class);
		RuneLite.main(args);
	}
}
