package com.duckblade.osrs.fortis.features.waves;

import com.duckblade.osrs.fortis.FortisColosseumConfig;
import com.duckblade.osrs.fortis.module.PluginLifecycleComponent;
import com.duckblade.osrs.fortis.util.ColosseumState;
import com.duckblade.osrs.fortis.util.ColosseumStateTracker;
import com.duckblade.osrs.fortis.util.spawns.WaveSpawn;
import com.duckblade.osrs.fortis.util.spawns.WaveSpawns;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Client;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

@Singleton
public class WavesOverlay extends OverlayPanel implements PluginLifecycleComponent
{

	private static final Color HEADER_COLOR = ColorScheme.BRAND_ORANGE;
	private static final Color SPAWN_COLOR = Color.white;
	private static final Color REINFORCEMENT_COLOR = ColorScheme.GRAND_EXCHANGE_ALCH;
	private static final Color MODIFIER_COLOR = new Color(228, 156, 248);

	private final EventBus eventBus;
	private final OverlayManager overlayManager;
	private final Client client;
	private final FortisColosseumConfig config;
	private final ColosseumStateTracker stateTracker;

	@Inject
	private WavesOverlay(
		EventBus eventBus,
		OverlayManager overlayManager,
		Client client,
		FortisColosseumConfig config,
		ColosseumStateTracker stateTracker
	)
	{
		this.eventBus = eventBus;
		this.overlayManager = overlayManager;
		this.client = client;
		this.config = config;
		this.stateTracker = stateTracker;

		setPosition(OverlayPosition.TOP_LEFT);
	}

	@Override
	public boolean isEnabled(FortisColosseumConfig config, ColosseumState colosseumState)
	{
		return config.wavesOverlayMode() != WaveOverlayMode.OFF
			&& colosseumState.isInColosseum();
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);
		overlayManager.add(this);
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
		overlayManager.remove(this);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		WaveOverlayMode mode = config.wavesOverlayMode();
		EnemyNameMode nameMode = config.wavesOverlayNames();

		ColosseumState state = this.stateTracker.getCurrentState();
		if (state.getWaveNumber() > 12)
		{
			// post-wave 12
			return null;
		}

		if (mode.showCurrent())
		{
			addTitleLine(state.getWaveNumber());
			WaveSpawns spawns = state.getWaveSpawns(client);
			spawns.getSpawns().forEach(s -> addSpawnLine(nameMode, s, SPAWN_COLOR));
			spawns.getReinforcements().forEach(s -> addSpawnLine(nameMode, s, REINFORCEMENT_COLOR));
			if (config.wavesOverlayShowModifierSpawns())
			{
				spawns.getModifierSpawns().forEach(s -> addSpawnLine(nameMode, s, MODIFIER_COLOR));
			}
		}

		if (mode == WaveOverlayMode.BOTH && state.getWaveNumber() != 12)
		{
			// a lil spacer
			panelComponent.getChildren().add(TitleComponent.builder().text("").build());
		}

		if (mode.showNext() && state.getWaveNumber() != 12)
		{
			addTitleLine(state.getWaveNumber() + 1);
			WaveSpawns nextSpawns = state.getNextWaveSpawns(client);
			nextSpawns.getSpawns().forEach(s -> addSpawnLine(nameMode, s, SPAWN_COLOR));
			nextSpawns.getReinforcements().forEach(s -> addSpawnLine(nameMode, s, REINFORCEMENT_COLOR));
			if (config.wavesOverlayShowModifierSpawns())
			{
				nextSpawns.getModifierSpawns().forEach(s -> addSpawnLine(nameMode, s, MODIFIER_COLOR));
			}
		}

		return super.render(graphics);
	}

	private void addTitleLine(int wave)
	{
		panelComponent.getChildren().add(TitleComponent.builder()
			.text("Wave " + wave)
			.color(HEADER_COLOR)
			.build());
	}

	private void addSpawnLine(EnemyNameMode nameMode, WaveSpawn spawn, Color color)
	{
		panelComponent.getChildren().add(LineComponent.builder()
			.left(spawn.getCount() + "x " + nameMode.nameOf(spawn.getEnemy()))
			.leftColor(color)
			.build());
	}
}

package com.duckblade.osrs.fortis.features.waves;

public enum WaveOverlayMode
{

	OFF,
	CURRENT,
	NEXT,
	BOTH,
	;

	public boolean showCurrent()
	{
		return this == CURRENT || this == BOTH;
	}

	public boolean showNext()
	{
		return this == NEXT || this == BOTH;
	}

}

package com.duckblade.osrs.fortis.features.waves;

import com.duckblade.osrs.fortis.util.spawns.Enemy;

public enum EnemyNameMode
{

	OFFICIAL,
	COLLOQUIAL,
	;

	public String nameOf(Enemy enemy)
	{
		return this == OFFICIAL ? enemy.getNpcName() : enemy.getColloquialName();
	}

}

package com.duckblade.osrs.fortis.features;

import com.duckblade.osrs.fortis.FortisColosseumConfig;
import com.duckblade.osrs.fortis.module.PluginLifecycleComponent;
import com.duckblade.osrs.fortis.util.ColosseumState;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Singleton
public class LeftClickBankAll implements PluginLifecycleComponent
{

	private static final String MENU_ENTRY_OPTION = "Bank-all";

	@Inject
	private EventBus eventBus;

	@Override
	public boolean isEnabled(FortisColosseumConfig config, ColosseumState colosseumState)
	{
		return config.leftClickBankAll() && colosseumState.isInColosseum();
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded e)
	{
		if (MENU_ENTRY_OPTION.equals(e.getOption()))
		{
			e.getMenuEntry().setForceLeftClick(true);
		}
	}
}

package com.duckblade.osrs.fortis.features.timetracking;

import com.duckblade.osrs.fortis.FortisColosseumConfig;
import com.duckblade.osrs.fortis.features.timetracking.livesplit.LiveSplitManager;
import com.duckblade.osrs.fortis.module.PluginLifecycleComponent;
import com.duckblade.osrs.fortis.util.ColosseumState;
import com.duckblade.osrs.fortis.util.ColosseumStateChanged;
import com.duckblade.osrs.fortis.util.ColosseumStateTracker;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class SplitsTracker implements PluginLifecycleComponent
{

	private static final Pattern WAVE_COMPLETE_PATTERN =
		Pattern.compile("Wave (?<wave>\\d+) completed! Wave duration:.*?(?<duration>[0-9]+:[.0-9]+).*");
	private static final Pattern COLOSSEUM_COMPLETE_PATTERN =
		Pattern.compile("Colosseum duration:.*?(?<duration>[0-9]+:[.0-9]+).*");

	private final EventBus eventBus;

	private final Client client;
	private final ColosseumStateTracker stateTracker;
	private final LiveSplitManager liveSplitManager;

	private int runStart = -1;
	private int lastWaveStart = -1;
	private final List<Split> splits = new ArrayList<>(12);

	@Override
	public boolean isEnabled(FortisColosseumConfig config, ColosseumState state)
	{
		// always track, conditionally display
		return state.isInColosseum();
	}

	@Override
	public void startUp()
	{
		runStart = -1;
		lastWaveStart = -1;
		splits.clear();
		eventBus.register(this);
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
	}

	@Subscribe
	public void onChatMessage(ChatMessage e)
	{
		if (e.getType() != ChatMessageType.GAMEMESSAGE)
		{
			return;
		}

		String msg = e.getMessage();
		if (!msg.contains("duration"))
		{
			return;
		}

		Matcher m;
		if (!(m = WAVE_COMPLETE_PATTERN.matcher(msg)).matches() &&
			!(m = COLOSSEUM_COMPLETE_PATTERN.matcher(msg)).matches())
		{
			return;
		}

		int wave = m.groupCount() == 2 ? Integer.parseInt(m.group("wave")) : 12;
		int duration = parseTimeString(m.group("duration"));
		int cumulative = getCumulativeDuration();
		int cumulativeWave = getCumulativeWaveDuration();

		if (wave == 12)
		{
			// wave 12 message is your final overall time
			duration = duration - cumulativeWave;
		}

		Split newSplit = new Split(wave, duration, cumulative, cumulativeWave + duration);
		splits.add(newSplit);
		lastWaveStart = -1;

		liveSplitManager.onSplit(newSplit);
	}

	@Subscribe
	public void onColosseumStateChanged(ColosseumStateChanged e)
	{
		if (e.getNewState().isWaveStarted() && !e.getPreviousState().isWaveStarted())
		{
			if (e.getNewState().getWaveNumber() == 1)
			{
				runStart = client.getTickCount();
			}
			liveSplitManager.onWaveStart(e.getNewState().getWaveNumber());
			lastWaveStart = client.getTickCount();
		}
	}

	public Split getInProgressSplit()
	{
		return new Split(
			stateTracker.getCurrentState().getWaveNumber(),
			getWaveDuration(),
			getCumulativeDuration(),
			getCumulativeWaveDuration()
		);
	}

	private int getWaveDuration()
	{
		return lastWaveStart == -1 ? -1 : client.getTickCount() - lastWaveStart;
	}

	public int getWaveCumulativeDuration()
	{
		int currentWaveTime = getWaveDuration();
		if (splits.isEmpty())
		{
			return getWaveDuration();
		}

		int cumulative = 0;
		for (Split split : splits)
		{
			int waveDuration = split.getWaveDuration();
			cumulative += waveDuration;
		}

		if (currentWaveTime != -1)
		{
			cumulative += currentWaveTime;
		}

		return cumulative;
	}

	public int getCumulativeDuration()
	{
		if (splits.size() == 12)
		{
			return splits.get(11).getCumulativeDuration();
		}

		return runStart == -1 ? -1 : client.getTickCount() - runStart;
	}

	public int getCumulativeWaveDuration()
	{
		return splits.stream()
			.mapToInt(Split::getWaveDuration)
			.sum();
	}

	public List<Split> getSplits()
	{
		return Collections.unmodifiableList(splits);
	}

	private static int parseTimeString(String timeString)
	{
		String[] components = timeString.split(":");

		int mins = Integer.parseInt(components[0]);
		float seconds = Float.parseFloat(components[1]);
		return mins * 100 + (int) Math.ceil(seconds / 0.6f);
	}

}

package com.duckblade.osrs.fortis.features.timetracking.livesplit;

import com.duckblade.osrs.fortis.FortisColosseumConfig;
import com.duckblade.osrs.fortis.features.timetracking.Split;
import com.duckblade.osrs.fortis.module.PluginLifecycleComponent;
import com.duckblade.osrs.fortis.util.ColosseumState;
import com.duckblade.osrs.fortis.util.ColosseumStateChanged;
import com.duckblade.osrs.fortis.util.TimerMode;
import java.util.Objects;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class LiveSplitManager implements PluginLifecycleComponent
{

	private final EventBus eventBus;
	private final FortisColosseumConfig config;
	private final LiveSplitWriter ls;

	private boolean active;

	@Override
	public boolean isEnabled(FortisColosseumConfig config, ColosseumState colosseumState)
	{
		return config.splitsLivesplitPort() != 0;
	}

	@Override
	public void startUp()
	{
		ls.setTargetPort(config.splitsLivesplitPort());
		ls.startUp();
		eventBus.register(this);
		active = true;
	}

	@Override
	public void shutDown()
	{
		active = false;
		eventBus.unregister(this);
		ls.shutDown();
	}

	@Subscribe(priority = 1)
	public void onConfigChanged(ConfigChanged e)
	{
		if (Objects.equals(e.getGroup(), FortisColosseumConfig.CONFIG_GROUP) && Objects.equals(e.getKey(), FortisColosseumConfig.KEY_LIVESPLIT_PORT))
		{
			ls.setTargetPort(config.splitsLivesplitPort());
		}
	}

	@Subscribe(priority = 1)
	public void onColosseumStateChanged(ColosseumStateChanged e)
	{
		if (!e.getPreviousState().isInColosseum() && e.getNewState().isInColosseum() && config.splitsLivesplitAutoReset())
		{
			ls.sendCommand("reset");
		}
	}

	public void onWaveStart(int wave)
	{
		if (active)
		{
			if (wave == 1)
			{
				ls.sendCommand("setgametime 0");
				ls.sendCommand("starttimer");
			}
			else
			{
				ls.sendCommand("unpausegametime");
			}
		}
	}

	public void onSplit(Split e)
	{
		if (active)
		{
			ls.sendCommand("pausegametime");
			ls.sendCommand("setgametime " + TimerMode.PRECISE.format(e.getCumulativeWaveDuration()));
			ls.sendCommand("split");
		}
	}
}

package com.duckblade.osrs.fortis.features.timetracking.livesplit;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.InetAddress;
import java.net.Socket;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;

@Singleton
@Slf4j
public class LiveSplitWriter
{

	// es being a singleThreadExecutor is implicitly required for some things here,
	// otherwise we'd need a synchronization lock as well
	private ScheduledExecutorService es;

	private int targetPort = 0; // 0 denotes not connected
	private Socket activeSocket;
	private PrintWriter writer;
	private BufferedReader reader;

	public void startUp()
	{
		es = Executors.newSingleThreadScheduledExecutor(r ->
		{
			Thread t = Executors.defaultThreadFactory().newThread(r);
			t.setDaemon(true);
			t.setName("FortisColosseumLiveSplitWriter");
			return t;
		});
		es.scheduleWithFixedDelay(this::open, 0, 5, TimeUnit.SECONDS);
	}

	public void shutDown()
	{
		es.submit(this::close);
		es.shutdown();
	}

	public void setTargetPort(int port)
	{
		if (es == null || es.isShutdown())
		{
			targetPort = port;
			return;
		}

		// reconnect if the port changed
		es.submit(() ->
		{
			if (targetPort != port)
			{
				close();
				targetPort = port;
				open();
			}
		});
	}

	public void sendCommand(String command)
	{
		log.debug(">> {}", command);
		sendCommand(command, null);
	}

	public void sendCommand(String command, Consumer<String> callback)
	{
		es.submit(() ->
		{
			try
			{
				writer.print(command);
				writer.print("\r\n"); // livesplit always uses \r\n regardless of system line endings
				writer.flush();
				if (writer.checkError())
				{
					close();
				}
				else if (callback != null)
				{
					String response = reader.readLine();
					log.debug("<< {}", response);
					callback.accept(response);
				}
			}
			catch (IOException e)
			{
				log.warn("Unexpected error in sendCommand. Closing socket and reconnecting at next scheduled open.", e);
				close();
			}
		});
	}

	private void open()
	{
		// cancel early if no connection is desired, or there already is a connection
		if (targetPort == 0 || activeSocket != null)
		{
			log.trace("Not opening a connection to LiveSplit port={} socketNull={}", targetPort, activeSocket == null);
			return;
		}

		try
		{
			log.debug("Connecting to LiveSplit on port {}", targetPort);
			activeSocket = new Socket(InetAddress.getLoopbackAddress(), targetPort);
			writer = new PrintWriter(activeSocket.getOutputStream());
			reader = new BufferedReader(new InputStreamReader(activeSocket.getInputStream()));

			log.info("Connected to LiveSplit on port {}", targetPort);
		}
		catch (IOException e)
		{
			log.debug("Failed to connect to LiveSplit on port {}, will retry later", this.targetPort);
			activeSocket = null;
			writer = null;
			reader = null;
		}
	}

	private void close()
	{
		if (activeSocket != null && !activeSocket.isClosed())
		{
			try
			{
				log.debug("Closing LiveSplit connection");
				activeSocket.close();
				writer.close();
				reader.close();
			}
			catch (IOException e)
			{
				// this shouldn't happen, but if it does there's nothing more we can do
				log.warn("encountered an unexpected error closing the socket, socket may be dangling!", e);
			}
			activeSocket = null;
			writer = null;
			reader = null;
		}
	}

}

package com.duckblade.osrs.fortis.features.timetracking;

import com.duckblade.osrs.fortis.util.TimerMode;

public enum SplitsOverlayMode
{

	OFF,
	WAVE_TIME,
	CUMULATIVE,
	BOTH,
	;

	public String formatSplit(TimerMode timerMode, Split split)
	{
		switch (this)
		{
			case WAVE_TIME:
				return timerMode.format(split.getWaveDuration());

			case CUMULATIVE:
				return timerMode.format(split.getCumulativeDuration());

			case BOTH:
				return timerMode.format(split.getWaveDuration()) + " / " + timerMode.format(split.getCumulativeDuration());

			default:
				return "";
		}
	}

	public String formatTotal(TimerMode timerMode, int waveTime, int overallTime)
	{
		switch (this)
		{
			case WAVE_TIME:
				return timerMode.format(waveTime);

			case CUMULATIVE:
				return timerMode.format(overallTime);

			case BOTH:
				return timerMode.format(waveTime) + " / " + timerMode.format(overallTime);

			default:
				return "";
		}
	}

}

package com.duckblade.osrs.fortis.features.timetracking;

import com.duckblade.osrs.fortis.FortisColosseumConfig;
import com.duckblade.osrs.fortis.module.PluginLifecycleComponent;
import com.duckblade.osrs.fortis.util.ColosseumState;
import com.duckblade.osrs.fortis.util.ColosseumStateChanged;
import com.duckblade.osrs.fortis.util.TimerMode;
import com.google.common.annotations.VisibleForTesting;
import java.io.File;
import java.io.FileWriter;
import java.io.PrintWriter;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
@Slf4j
public class SplitsFileWriter implements PluginLifecycleComponent
{

	public enum WriteCondition
	{
		NEVER,
		EVERY_RUN,
		SUCESSFUL_RUNS,
	}

	private static final SimpleDateFormat DATE_FORMATTER = new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss");

	private final EventBus eventBus;

	private final FortisColosseumConfig config;
	private final SplitsTracker splitsTracker;
	private final ChatMessageManager chatMessageManager;

	@VisibleForTesting
	ExecutorService es;

	@Override
	public boolean isEnabled(FortisColosseumConfig config, ColosseumState colosseumState)
	{
		return config.splitsFileCondition() != WriteCondition.NEVER;
	}

	@Override
	public void startUp()
	{
		es = Executors.newSingleThreadExecutor(r ->
		{
			Thread t = Executors.defaultThreadFactory().newThread(r);
			t.setDaemon(true);
			t.setName("FortisColosseumSplitsFileWriter");
			return t;
		});
		eventBus.register(this);
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
		es.shutdown();
	}

	@Subscribe
	public void onColosseumStateChanged(ColosseumStateChanged e)
	{
		if (!e.getNewState().isInColosseum() && e.getPreviousState().isInColosseum())
		{
			List<Split> splits = splitsTracker.getSplits();
			if (splits.isEmpty() || (splits.size() < 12 && config.splitsFileCondition() == WriteCondition.SUCESSFUL_RUNS))
			{
				return;
			}

			queueWrite(splits);
		}
	}

	@VisibleForTesting
	void queueWrite(List<Split> splitsIn)
	{
		log.debug("Queuing write of {} splits", splitsIn.size());
		final List<Split> splits = new ArrayList<>(splitsIn);
		final String fileName = DATE_FORMATTER.format(new Date()) + ".txt";
		es.submit(() ->
		{
			TimerMode timerMode = config.splitsFileTimerMode();

			File dir = new File(RuneLite.RUNELITE_DIR, "fortis-colosseum/splits");
			if (!dir.mkdirs() && !dir.exists())
			{
				chatMessageManager.queue(QueuedMessage.builder()
					.value("Could not write splits: failed to create directory")
					.build());
				return;
			}

			File destFile = new File(dir, fileName);
			try (PrintWriter out = new PrintWriter(new FileWriter(destFile)))
			{
				for (Split split : splits)
				{
					out.print("Wave ");
					out.print(split.getWave());
					out.print(": ");
					out.print(timerMode.format(split.getWaveDuration()));
					out.print(" / ");
					out.print(timerMode.format(split.getCumulativeWaveDuration()));
					out.print(" / ");
					out.println(timerMode.format(split.getCumulativeDuration()));
				}
			}
			catch (Exception e)
			{
				log.warn("Failed to write fortis colosseum splits to [{}]", destFile.getAbsoluteFile(), e);
				chatMessageManager.queue(QueuedMessage.builder()
					.value("Could not write splits: an unexpected error occurred")
					.build());
			}
		});
	}
}

package com.duckblade.osrs.fortis.features.timetracking;

import lombok.Value;

@Value
public class Split
{

	int wave;
	int waveDuration;
	int cumulativeDuration;
	int cumulativeWaveDuration;

}

package com.duckblade.osrs.fortis.features.timetracking;

import com.duckblade.osrs.fortis.FortisColosseumConfig;
import com.duckblade.osrs.fortis.module.PluginLifecycleComponent;
import com.duckblade.osrs.fortis.util.ColosseumState;
import com.duckblade.osrs.fortis.util.ColosseumStateTracker;
import com.duckblade.osrs.fortis.util.TimerMode;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.List;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

@Slf4j
@Singleton
public class SplitsOverlay extends OverlayPanel implements PluginLifecycleComponent
{

	private final OverlayManager overlayManager;

	private final Client client;
	private final FortisColosseumConfig config;
	private final SplitsTracker splitsTracker;
	private final ColosseumStateTracker stateTracker;

	@Inject
	public SplitsOverlay(
		OverlayManager overlayManager,
		Client client,
		FortisColosseumConfig config,
		SplitsTracker splitsTracker,
		ColosseumStateTracker stateTracker
	)
	{
		this.overlayManager = overlayManager;
		this.client = client;
		this.config = config;
		this.splitsTracker = splitsTracker;
		this.stateTracker = stateTracker;

		setPosition(OverlayPosition.CANVAS_TOP_RIGHT);
	}

	@Override
	public boolean isEnabled(FortisColosseumConfig config, ColosseumState state)
	{
		return state.isInColosseum() && config.splitsOverlayMode() != SplitsOverlayMode.OFF;
	}

	@Override
	public void startUp()
	{
		overlayManager.add(this);
	}

	@Override
	public void shutDown()
	{
		overlayManager.remove(this);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		long start = System.currentTimeMillis();
		getPanelComponent().getChildren()
			.add(TitleComponent.builder()
				.text("Fortis Colosseum Splits")
				.build());

		TimerMode timerMode = TimerMode.fromClient(client);
		SplitsOverlayMode overlayMode = config.splitsOverlayMode();
		boolean waveStarted = stateTracker.getCurrentState().isWaveStarted();
		int wavesWanted = config.splitsOverlayLines();

		if (wavesWanted > 0)
		{
			List<Split> allSplits = splitsTracker.getSplits();
			boolean showCurrentWave = waveStarted && allSplits.size() < 12;

			int visibleSplitsCount = wavesWanted - (showCurrentWave ? 1 : 0);
			if (visibleSplitsCount > 0)
			{
				List<Split> visibleSplits = allSplits.subList(Math.max(0, allSplits.size() - visibleSplitsCount), allSplits.size()); // last N splits
				for (Split s : visibleSplits)
				{
					addLine("Wave " + s.getWave(), overlayMode.formatSplit(timerMode, s));
				}
			}

			Split inProgress = splitsTracker.getInProgressSplit();
			if (showCurrentWave)
			{
				String text = overlayMode.formatSplit(timerMode, inProgress);
				addLine("Wave " + inProgress.getWave(), text);
			}
		}

		String text = overlayMode.formatTotal(timerMode, splitsTracker.getWaveCumulativeDuration(), splitsTracker.getCumulativeDuration());
		addLine("Total", text);

		long ms = System.currentTimeMillis() - start;
		if (ms > 1)
		{
			log.debug("splits overlay rendered in {}ms", ms);
		}
		return super.render(graphics);
	}

	private void addLine(String left, String right)
	{
		getPanelComponent()
			.getChildren()
			.add(LineComponent.builder()
				.left(left)
				.right(right)
				.build());
	}
}

package com.duckblade.osrs.fortis.features.modifiers;

import com.duckblade.osrs.fortis.util.Modifier;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Map;
import javax.inject.Inject;
import javax.inject.Singleton;
import joptsimple.internal.Strings;
import lombok.RequiredArgsConstructor;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class ModifierSpriteCache
{

	private static final int SPRITE_ID_BG = 5531;

	@Value
	private static class SpriteCacheKey
	{
		Modifier modifier;
		int level;
		ModifierSpriteStyle style;
	}

	private final SpriteManager spriteManager;
	private final Client client;

	private final Map<SpriteCacheKey, BufferedImage> modifierSpriteCache = new HashMap<>();

	public BufferedImage getSprite(Modifier modifier, ModifierSpriteStyle style)
	{
		int level = Math.max(1, modifier.getLevel(client));
		SpriteCacheKey key = new SpriteCacheKey(modifier, level, style);
		BufferedImage sprite;
		if ((sprite = modifierSpriteCache.get(key)) != null)
		{
			return sprite;
		}

		log.debug("sprite cache miss");
		sprite = getSpriteImpl(modifier, level, style);
		modifierSpriteCache.put(key, sprite);
		return sprite;
	}

	private BufferedImage getSpriteImpl(Modifier modifier, int level, ModifierSpriteStyle style)
	{
		BufferedImage modifierSprite = spriteManager.getSprite(modifier.getSpriteId(level), 0);
		if (modifierSprite == null)
		{
			return null;
		}

		if (style == ModifierSpriteStyle.COMPACT || style == ModifierSpriteStyle.ICON_ONLY)
		{
			BufferedImage ret = ImageUtil.resizeCanvas(modifierSprite, 38, 38);
			if (style == ModifierSpriteStyle.ICON_ONLY)
			{
				return ret;
			}

			if (modifier.getLevelVarb() != -1)
			{
				Graphics2D g = ret.createGraphics();
				g.setFont(FontManager.getRunescapeSmallFont());
				String label = Strings.repeat('I', level);
				Rectangle2D labelSize = g.getFontMetrics().getStringBounds(label, g);
				g.setColor(Color.black);
				g.drawString(label, ret.getWidth() - ((int) labelSize.getWidth()), ((int) labelSize.getHeight()));
				g.setColor(Color.white);
				g.drawString(label, ret.getWidth() - ((int) labelSize.getWidth()) - 1, (int) labelSize.getHeight() - 1);
			}
			return ret;
		}

		BufferedImage bgSprite = spriteManager.getSprite(SPRITE_ID_BG + level - 1, 0);
		if (bgSprite == null)
		{
			return null;
		}

		BufferedImage ret = new BufferedImage(bgSprite.getWidth(), bgSprite.getHeight(), BufferedImage.TYPE_INT_ARGB);
		Graphics2D g = ret.createGraphics();
		g.drawImage(bgSprite, 0, 0, null);
		g.drawImage(
			modifierSprite,
			bgSprite.getWidth() / 2 - modifierSprite.getWidth() / 2,
			bgSprite.getHeight() / 2 - modifierSprite.getHeight() / 2,
			null
		);
		return ret;
	}

}

package com.duckblade.osrs.fortis.features.modifiers;

import com.duckblade.osrs.fortis.FortisColosseumConfig;
import com.duckblade.osrs.fortis.module.PluginLifecycleComponent;
import com.duckblade.osrs.fortis.util.ColosseumState;
import com.duckblade.osrs.fortis.util.ColosseumStateTracker;
import com.duckblade.osrs.fortis.util.Modifier;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;
import java.util.List;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.ComponentOrientation;
import net.runelite.client.ui.overlay.components.ImageComponent;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;

@Singleton
@Slf4j
public class ModifierOverlay extends OverlayPanel implements PluginLifecycleComponent
{

	private static final int SPRITE_PADDING = 4;

	private final OverlayManager overlayManager;
	private final EventBus eventBus;
	private final Client client;
	private final TooltipManager tooltipManager;
	private final FortisColosseumConfig config;
	private final ColosseumStateTracker stateTracker;
	private final ModifierSpriteCache spriteCache;

	@Inject
	public ModifierOverlay(
		OverlayManager overlayManager,
		EventBus eventBus,
		Client client,
		TooltipManager tooltipManager,
		FortisColosseumConfig config,
		ColosseumStateTracker stateTracker,
		ModifierSpriteCache spriteCache
	)
	{
		this.overlayManager = overlayManager;
		this.eventBus = eventBus;
		this.client = client;
		this.tooltipManager = tooltipManager;
		this.config = config;
		this.stateTracker = stateTracker;
		this.spriteCache = spriteCache;

		setPosition(OverlayPosition.BOTTOM_LEFT);
		addMenuEntry(MenuAction.RUNELITE_OVERLAY_CONFIG, "Flip", "Modifier Overlay", (me) ->
		{
			ComponentOrientation newVal = config.modifiersOverlayOrientation() == ComponentOrientation.HORIZONTAL
				? ComponentOrientation.VERTICAL
				: ComponentOrientation.HORIZONTAL;
			this.config.setModifiersOverlayOrientation(newVal);
		});
		addMenuEntry(MenuAction.RUNELITE_OVERLAY_CONFIG, "Change Style", "Modifier Overlay", (me) ->
		{
			ModifierSpriteStyle newVal = config.modifiersOverlayStyle() == ModifierSpriteStyle.COMPACT
				? ModifierSpriteStyle.FANCY
				: ModifierSpriteStyle.COMPACT;
			this.config.setModifiersOverlayStyle(newVal);
		});
	}

	@Override
	public boolean isEnabled(FortisColosseumConfig config, ColosseumState colosseumState)
	{
		return config.modifiersOverlayEnabled() && colosseumState.isInColosseum();
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);
		overlayManager.add(this);
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
		overlayManager.remove(this);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		long start = System.currentTimeMillis();
		setPreferredColor(new Color(0, 0, 0, 0)); // no background

		ComponentOrientation orientation = config.modifiersOverlayOrientation();
		getPanelComponent().setOrientation(orientation);
		getPanelComponent().setGap(new Point(SPRITE_PADDING, SPRITE_PADDING));

		int x = 4;
		int y = 4;
		List<Modifier> mods = stateTracker.getCurrentState().getModifiers();
		ModifierSpriteStyle style = config.modifiersOverlayStyle();
		for (Modifier modifier : mods)
		{
			if (orientation == ComponentOrientation.HORIZONTAL)
			{
				x += renderModifier(modifier, style, x, y) + SPRITE_PADDING;
			}
			else
			{
				y += renderModifier(modifier, style, x, y) + SPRITE_PADDING;
			}
		}

		long ms = System.currentTimeMillis() - start;
		if (ms > 1)
		{
			log.debug("modifier overlay rendered in {}ms", ms);
		}
		return super.render(graphics);
	}

	private int renderModifier(Modifier modifier, ModifierSpriteStyle style, int x, int y)
	{
		Rectangle bounds = getBounds();
		net.runelite.api.Point mouse = client.getMouseCanvasPosition();
		int mouseX = mouse.getX() - bounds.x;
		int mouseY = mouse.getY() - bounds.y;

		BufferedImage sprite = spriteCache.getSprite(modifier, style);
		if (sprite == null)
		{
			return 0;
		}

		getPanelComponent().getChildren().add(new ImageComponent(sprite));

		Rectangle hoverArea = new Rectangle(x, y, sprite.getWidth(), sprite.getHeight());
		if (hoverArea.contains(mouseX, mouseY))
		{
			tooltipManager.add(new Tooltip(modifier.getName(client)));
		}

		return hoverArea.width;
	}
}

package com.duckblade.osrs.fortis.features.modifiers;

public enum ModifierSpriteStyle
{
	FANCY,
	COMPACT,
	ICON_ONLY,
}

package com.duckblade.osrs.fortis.features.modifiers;

import com.duckblade.osrs.fortis.FortisColosseumConfig;
import com.duckblade.osrs.fortis.module.PluginLifecycleComponent;
import com.duckblade.osrs.fortis.util.ColosseumState;
import com.duckblade.osrs.fortis.util.Modifier;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.time.Duration;
import java.time.Instant;
import java.util.HashSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Value;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.events.ActorDeath;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.util.RSTimeUnit;

@Singleton
public class VolatilityReminder extends Overlay implements PluginLifecycleComponent
{

	private static final Duration RENDER_DURATION = Duration.of(5, RSTimeUnit.GAME_TICKS);

	@Inject
	public VolatilityReminder(EventBus eventBus, OverlayManager overlayManager, Client client, ModifierSpriteCache spriteCache)
	{
		this.eventBus = eventBus;
		this.overlayManager = overlayManager;
		this.client = client;
		this.spriteCache = spriteCache;

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.UNDER_WIDGETS);
	}

	@Value
	private static class DeathReminder
	{
		LocalPoint location;
		int z;
		Instant renderUntil;
	}

	private final EventBus eventBus;
	private final OverlayManager overlayManager;

	private final Client client;
	private final ModifierSpriteCache spriteCache;

	private final Set<DeathReminder> reminders = new HashSet<>();

	@Override
	public boolean isEnabled(FortisColosseumConfig config, ColosseumState colosseumState)
	{
		return config.volatilityReminder()
			&& colosseumState.isInColosseum();
//			&& colosseumState.getModifiers().contains(Modifier.VOLATILITY);
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);
		overlayManager.add(this);
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
		overlayManager.remove(this);
	}

	@Subscribe
	public void onActorDeath(ActorDeath e)
	{
		if (e.getActor() instanceof NPC)
		{
			reminders.add(new DeathReminder(
				e.getActor().getLocalLocation(),
				e.getActor().getLogicalHeight() / 2,
				Instant.now().plus(RENDER_DURATION)
			));
		}
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		Instant now = Instant.now();
		reminders.removeIf(r -> r.getRenderUntil().isBefore(now));
		for (DeathReminder reminder : reminders)
		{
			OverlayUtil.renderImageLocation(
				client,
				graphics,
				reminder.getLocation(),
				spriteCache.getSprite(Modifier.VOLATILITY, ModifierSpriteStyle.ICON_ONLY),
				reminder.getZ()
			);
		}

		return null;
	}
}

package com.duckblade.osrs.fortis.features.modifiers;

import com.duckblade.osrs.fortis.FortisColosseumConfig;
import com.duckblade.osrs.fortis.module.PluginLifecycleComponent;
import com.duckblade.osrs.fortis.util.ColosseumState;
import com.duckblade.osrs.fortis.util.ColosseumStateTracker;
import com.duckblade.osrs.fortis.util.Modifier;
import java.util.List;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.FontID;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetPositionMode;
import net.runelite.api.widgets.WidgetSizeMode;
import net.runelite.api.widgets.WidgetTextAlignment;
import net.runelite.api.widgets.WidgetType;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
@Slf4j
public class ModifierSelectNamesManager implements PluginLifecycleComponent
{

	private static final int SCRIPT_MODIFIER_SELECT_INIT = 4931;
	private static final int SCRIPT_MODIFIER_SELECT_OUTLINE = 4938;

	private static final int WIDGET_OPTION_1 = WidgetUtil.packComponentId(865, 15);
	private static final int WIDGET_OPTION_2 = WidgetUtil.packComponentId(865, 16);
	private static final int WIDGET_OPTION_3 = WidgetUtil.packComponentId(865, 17);

	private final EventBus eventBus;
	private final Client client;
	private final ColosseumStateTracker stateTracker;

	@Override
	public boolean isEnabled(FortisColosseumConfig config, ColosseumState colosseumState)
	{
		return config.modifiersNamesOnSelectWidget() && colosseumState.isInColosseum();
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
	}

	@Subscribe
	public void onScriptPostFired(ScriptPostFired e)
	{
		if (e.getScriptId() != SCRIPT_MODIFIER_SELECT_INIT && e.getScriptId() != SCRIPT_MODIFIER_SELECT_OUTLINE)
		{
			return;
		}

		List<Modifier> options = stateTracker.getModifierOptions();
		if (options.isEmpty())
		{
			log.debug("Can't add names, no options detected by state tracker");
			return;
		}

		installName(client.getWidget(WIDGET_OPTION_1), options.get(0));
		installName(client.getWidget(WIDGET_OPTION_2), options.get(1));
		installName(client.getWidget(WIDGET_OPTION_3), options.get(2));
	}

	private void installName(Widget container, Modifier option)
	{
		if (container == null)
		{
			log.debug("Can't install name for modifier {}, widget was not found", option);
			return;
		}

		int targetLevel = option.getLevelVarb() == -1 ? 1 : option.getLevel(client) + 1;
		String name = option.getName(targetLevel);
		container.createChild(WidgetType.TEXT)
			.setText(name)
			.setTextShadowed(true)
			.setTextColor(0xFFFFFF)
			.setFontId(FontID.PLAIN_11)
			.setSize(0, 0, WidgetSizeMode.MINUS, WidgetSizeMode.MINUS)
			.setXTextAlignment(WidgetTextAlignment.CENTER)
			.setYTextAlignment(WidgetTextAlignment.BOTTOM)
			.setPos(0, 0, WidgetPositionMode.ABSOLUTE_CENTER, WidgetPositionMode.ABSOLUTE_BOTTOM)
			.revalidate();
	}
}

package com.duckblade.osrs.fortis.features.loot;

import com.duckblade.osrs.fortis.FortisColosseumConfig;
import com.duckblade.osrs.fortis.module.PluginLifecycleComponent;
import com.duckblade.osrs.fortis.util.ColosseumState;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.FontID;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetPositionMode;
import net.runelite.api.widgets.WidgetSizeMode;
import net.runelite.api.widgets.WidgetTextAlignment;
import net.runelite.api.widgets.WidgetType;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
@Slf4j
public class LootTotalDisplay implements PluginLifecycleComponent
{

	private static final int SCRIPT_MODIFIER_SELECT_INIT = 4931;

	private static final int WIDGET_PARENT_EARNED = WidgetUtil.packComponentId(865, 5);
	private static final int WIDGET_PARENT_NEXT = WidgetUtil.packComponentId(865, 11);
	private static final int WIDGET_GP_TOTAL = WidgetUtil.packComponentId(865, 37);
	private static final int WIDGET_GP_EARNED = WidgetUtil.packComponentId(865, 9);
	private static final int WIDGET_GP_NEXT = WidgetUtil.packComponentId(865, 40);

	private final EventBus eventBus;
	private final Client client;
	private final FortisColosseumConfig config;

	@Override
	public boolean isEnabled(FortisColosseumConfig config, ColosseumState state)
	{
		return config.lootInterfaceShowTotal() != LootTotalMode.OFF && state.isInColosseum();
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);
	}

	@Override
	public void shutDown()
	{
		uninstall();
		eventBus.unregister(this);
	}

	@Subscribe
	public void onScriptPostFired(ScriptPostFired e)
	{
		if (e.getScriptId() != SCRIPT_MODIFIER_SELECT_INIT)
		{
			return;
		}

		Widget total = client.getWidget(WIDGET_GP_TOTAL);
		Widget earnedParent = client.getWidget(WIDGET_PARENT_EARNED);
		Widget earnedGpLabel = client.getWidget(WIDGET_GP_EARNED);
		Widget nextParent = client.getWidget(WIDGET_PARENT_NEXT);
		Widget nextGpLabel = client.getWidget(WIDGET_GP_NEXT);
		if (total == null || earnedParent == null || earnedGpLabel == null || nextParent == null || nextGpLabel == null)
		{
			return;
		}

		// this widget contains all the items and the total label
		int totalEarned = 0;
		Widget[] children = total.getChildren();
		if (children != null && children.length != 0)
		{
			totalEarned = readGPLabel(children[children.length - 1]);
		}

		LootTotalMode mode = config.lootInterfaceShowTotal();
		if (mode == LootTotalMode.EARNED || mode == LootTotalMode.BOTH)
		{
			addTotalWidget(earnedParent, earnedGpLabel, "Total", totalEarned);
		}

		if (mode == LootTotalMode.POTENTIAL || mode == LootTotalMode.BOTH)
		{
			int potential = totalEarned + readGPLabel(nextGpLabel);
			addTotalWidget(nextParent, nextGpLabel, "Potential", potential);
		}
	}

	private void uninstall()
	{
		// everything vanilla is static children, we can deleteAll
		Widget earned = client.getWidget(WIDGET_PARENT_EARNED);
		if (earned != null)
		{
			earned.deleteAllChildren();
		}

		Widget next = client.getWidget(WIDGET_PARENT_NEXT);
		if (next != null)
		{
			next.deleteAllChildren();
		}
	}

	private int readGPLabel(Widget reference)
	{
		String totalLabel = reference.getText();
		if (totalLabel != null && totalLabel.endsWith(" GP"))
		{
			String withoutGP = totalLabel.substring(0, totalLabel.length() - 3);
			String sanitized = withoutGP.replace(",", "");
			return Integer.parseInt(sanitized);
		}
		return 0;
	}

	private void addTotalWidget(Widget parent, Widget yRef, String prefix, int value)
	{
		parent.createChild(WidgetType.TEXT)
			.setPos(0, yRef.getOriginalY() + 26, WidgetPositionMode.ABSOLUTE_LEFT, WidgetPositionMode.ABSOLUTE_TOP)
			.setSize(0, 26, WidgetSizeMode.MINUS, WidgetSizeMode.ABSOLUTE)
			.setXTextAlignment(WidgetTextAlignment.CENTER)
			.setYTextAlignment(WidgetTextAlignment.CENTER)
			.setFontId(FontID.PLAIN_11)
			.setText(String.format("%s:<br>%,d GP", prefix, value))
			.setTextColor(0xFFFFFF)
			.setTextShadowed(true)
			.setLineHeight(14)
			.revalidate();
	}
}

package com.duckblade.osrs.fortis.features.loot;

public enum LootHiderMode
{

	OFF,
	WAVE_12,
	ALWAYS,

}

package com.duckblade.osrs.fortis.features.loot;

import com.duckblade.osrs.fortis.FortisColosseumConfig;
import com.duckblade.osrs.fortis.module.PluginLifecycleComponent;
import com.duckblade.osrs.fortis.util.ColosseumState;
import com.duckblade.osrs.fortis.util.ColosseumStateTracker;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.FontID;
import net.runelite.api.SoundEffectID;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetPositionMode;
import net.runelite.api.widgets.WidgetSizeMode;
import net.runelite.api.widgets.WidgetTextAlignment;
import net.runelite.api.widgets.WidgetType;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
@Slf4j
public class LootHider implements PluginLifecycleComponent
{

	private static final int SCRIPT_MODIFIER_SELECT_INIT = 4931;

	private static final int WIDGET_LOOT_ITEMS = WidgetUtil.packComponentId(865, 39);
	private static final int WIDGET_LOOT_GP = WidgetUtil.packComponentId(865, 40);
	private static final int WIDGET_BUTTON_PARENT = WidgetUtil.packComponentId(865, 13);

	private static final int[] SPRITE_IDS_STANDARD = {
		913, 914, 915, 916, 917, 918, 919, 920,
	};
	private static final int[] SPRITE_IDS_HOVER = {
		921, 922, 923, 924, 925, 926, 927, 928,
	};

	private final EventBus eventBus;
	private final Client client;
	private final FortisColosseumConfig config;
	private final ColosseumStateTracker stateTracker;

	private Widget[] buttonGraphicWidgets = null;
	private Widget buttonTextWidget = null;

	private boolean showLootQueued = false;

	@Override
	public boolean isEnabled(FortisColosseumConfig config, ColosseumState state)
	{
		return config.lootInterfaceHideNextWave() != LootHiderMode.OFF && state.isInColosseum();
	}

	@Override
	public void startUp()
	{
		buttonGraphicWidgets = null;
		buttonTextWidget = null;
		showLootQueued = false;
		eventBus.register(this);
	}

	@Override
	public void shutDown()
	{
		unhide();
		eventBus.unregister(this);
	}

	@Subscribe(priority = -10) // priority low just in case some other plugin reads the items out of here
	public void onScriptPostFired(ScriptPostFired e)
	{
		if (e.getScriptId() != SCRIPT_MODIFIER_SELECT_INIT)
		{
			return;
		}

		if (config.lootInterfaceHideNextWave() == LootHiderMode.WAVE_12 && stateTracker.getCurrentState().getWaveNumber() != 12)
		{
			return;
		}

		hide();
	}

	private void hide()
	{
		Widget itemPreview = client.getWidget(WIDGET_LOOT_ITEMS);
		Widget gpPreview = client.getWidget(WIDGET_LOOT_GP);
		Widget buttonParent = client.getWidget(WIDGET_BUTTON_PARENT);
		if (itemPreview == null || gpPreview == null || buttonParent == null)
		{
			return;
		}
		itemPreview.setHidden(true);
		gpPreview.setHidden(true);

		int w = 78;
		int h = 28;
		int x = buttonParent.getWidth() / 2 - w / 2; // of top left corner
		int y = buttonParent.getHeight() / 2 - h / 2;
		buttonGraphicWidgets = new Widget[]{
			buildGraphicWidget(buttonParent, x, y, 9, 9, SPRITE_IDS_STANDARD[0]), // corners
			buildGraphicWidget(buttonParent, x + w - 9, y, 9, 9, SPRITE_IDS_STANDARD[1]),
			buildGraphicWidget(buttonParent, x, y + h - 9, 9, 9, SPRITE_IDS_STANDARD[2]),
			buildGraphicWidget(buttonParent, x + w - 9, y + h - 9, 9, 9, SPRITE_IDS_STANDARD[3]),
			buildGraphicWidget(buttonParent, x, y + 9, 9, h - 18, SPRITE_IDS_STANDARD[4]), // edges
			buildGraphicWidget(buttonParent, x + 9, y, w - 18, 9, SPRITE_IDS_STANDARD[5]),
			buildGraphicWidget(buttonParent, x + w - 9, y + 9, 9, h - 18, SPRITE_IDS_STANDARD[6]),
			buildGraphicWidget(buttonParent, x + 9, y + h - 9, w - 18, 9, SPRITE_IDS_STANDARD[7]),
		};

		buttonTextWidget = buttonParent.createChild(-1, WidgetType.TEXT)
			.setPos(x, y, WidgetPositionMode.ABSOLUTE_LEFT, WidgetPositionMode.ABSOLUTE_TOP)
			.setSize(w, h, WidgetSizeMode.ABSOLUTE, WidgetSizeMode.ABSOLUTE)
			.setTextShadowed(true)
			.setFontId(FontID.PLAIN_12)
			.setTextColor(0xff981f)
			.setText("Show Loot")
			.setXTextAlignment(WidgetTextAlignment.CENTER)
			.setYTextAlignment(WidgetTextAlignment.CENTER)
			.setHasListener(true);
		buttonTextWidget.revalidate();

		// on mouse hover and leave, update the sprite ids to simulate depth
		// also add a tooltip for the fake action
		buttonTextWidget.setOnMouseOverListener((JavaScriptCallback) (ignored) ->
		{
			for (int i = 0; buttonGraphicWidgets != null && i < buttonGraphicWidgets.length; i++)
			{
				buttonGraphicWidgets[i].setSpriteId(SPRITE_IDS_HOVER[i]);
			}
		});
		buttonTextWidget.setOnMouseLeaveListener((JavaScriptCallback) (ignored) ->
		{
			for (int i = 0; buttonGraphicWidgets != null && i < buttonGraphicWidgets.length; i++)
			{
				buttonGraphicWidgets[i].setSpriteId(SPRITE_IDS_STANDARD[i]);
			}
		});

		buttonTextWidget.setAction(0, "Show");
		buttonTextWidget.setOnOpListener((JavaScriptCallback) (ignored) ->
		{
			// queue the action for the next game tick just to simulate jagex widget delay ;)
			client.playSoundEffect(SoundEffectID.UI_BOOP);
			showLootQueued = true;
		});
	}

	private void unhide()
	{
		Widget items = client.getWidget(WIDGET_LOOT_ITEMS);
		if (items != null)
		{
			items.setHidden(false);
		}

		Widget gp = client.getWidget(WIDGET_LOOT_GP);
		if (gp != null)
		{
			gp.setHidden(false);
		}

		Widget buttonParent = client.getWidget(WIDGET_BUTTON_PARENT);
		if (buttonParent == null || buttonGraphicWidgets == null)
		{
			return;
		}

		// clear out all the children we added
		// I tried actually removing them from the array but setChildren failed on a classcast due to separate classloaders?
		for (Widget graphic : buttonGraphicWidgets)
		{
			graphic.setHidden(true);
		}
		buttonTextWidget.setHidden(true);
		buttonTextWidget.setHasListener(false);
		buttonGraphicWidgets = null;
		buttonTextWidget = null;
		showLootQueued = false;
	}

	@Subscribe
	public void onGameTick(GameTick e)
	{
		if (showLootQueued)
		{
			unhide();
		}
	}

	private Widget buildGraphicWidget(Widget parent, int x, int y, int w, int h, int spriteId)
	{
		Widget graphic = parent.createChild(WidgetType.GRAPHIC)
			.setPos(x, y, WidgetPositionMode.ABSOLUTE_LEFT, WidgetPositionMode.ABSOLUTE_TOP)
			.setSize(w, h, WidgetSizeMode.ABSOLUTE, WidgetSizeMode.ABSOLUTE)
			.setSpriteId(spriteId);
		graphic.revalidate();
		return graphic;
	}
}

package com.duckblade.osrs.fortis.features.loot;

public enum LootTotalMode
{

	OFF,
	EARNED,
	POTENTIAL,
	BOTH,

}

package com.duckblade.osrs.fortis.util;

import lombok.Value;

@Value
public class ColosseumStateChanged
{

	private final ColosseumState previousState;
	private final ColosseumState newState;

}

package com.duckblade.osrs.fortis.util.spawns;

import lombok.Value;

@Value
public class WaveSpawn
{

	int count;
	Enemy enemy;

}

package com.duckblade.osrs.fortis.util.spawns;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Getter
public enum Enemy
{

	FREMENNIK("Fremennik", "Fremmy"),
	SERPENT_SHAMAN("Serpent Shaman", "Mage"),
	JAGUAR_WARRIOR("Jaguar Warrior", "Melee"),
	JAVELIN_COLOSSUS("Javelin Colossus", "Ranger"),
	MANTICORE("Manticore", "Lion"),
	SHOCKWAVE_COLOSSUS("Shockwave Colossus", "Shocker"),
	MINOTAUR("Minotaur", "Minotaur"),
	SOL_HEREDIT("Sol Heredit", "Sol Heredit"),

	ANGRY_BEES("Angry Bees", "BEES!!"),
	;

	private final String npcName;
	private final String colloquialName;

}

package com.duckblade.osrs.fortis.util.spawns;

import com.duckblade.osrs.fortis.util.ColosseumState;
import com.duckblade.osrs.fortis.util.Modifier;
import java.util.List;
import lombok.AccessLevel;
import lombok.Builder;
import lombok.Singular;
import lombok.Value;
import net.runelite.api.Client;

@Value
@Builder(access = AccessLevel.PRIVATE)
public class WaveSpawns
{

	@Singular
	List<WaveSpawn> spawns;

	@Singular
	List<WaveSpawn> reinforcements;

	@Singular
	List<WaveSpawn> modifierSpawns;

	public static WaveSpawns forWave(Client client, ColosseumState state, boolean next)
	{
		int wave = next ? state.getWaveNumber() + 1 : state.getWaveNumber();
		List<Modifier> modifiers = state.getModifiers();

		WaveSpawnsBuilder builder = WaveSpawns.builder();

		// modifier-only spawns
		if (modifiers.contains(Modifier.BEES))
		{
			builder.modifierSpawn(new WaveSpawn(Modifier.BEES.getLevel(client), Enemy.ANGRY_BEES));
		}

		// skip early for boss
		if (wave == 12)
		{
			if (modifiers.contains(Modifier.QUARTET))
			{
				builder.spawn(new WaveSpawn(1, Enemy.FREMENNIK));
			}
			builder.spawn(new WaveSpawn(1, Enemy.SOL_HEREDIT));
			return builder.build();
		}

		// frems every wave, 3 by default or 4 with quartet
		builder.spawn(new WaveSpawn(modifiers.contains(Modifier.QUARTET) ? 4 : 3, Enemy.FREMENNIK));

		if (wave <= 6)
		{
			// serpent shaman every wave up to 6
			builder.spawn(new WaveSpawn(1, Enemy.SERPENT_SHAMAN));
		}
		if ((wave >= 4 && wave <= 6) || (wave >= 10))
		{
			// and also as a reinforcement 4-6 and 10-11
			builder.reinforcement(new WaveSpawn(1, Enemy.SERPENT_SHAMAN));
		}

		// jaguar warrior is reinforcement only, all waves up to 6
		if (wave <= 6)
		{
			builder.reinforcement(new WaveSpawn(1, Enemy.JAGUAR_WARRIOR));
		}

		// javelins alternate 1 and 2 spawns, but skip waves 1 and 4
		if (wave == 2 || wave == 3)
		{
			builder.spawn(new WaveSpawn(wave - 1, Enemy.JAVELIN_COLOSSUS));
		}
		if (wave >= 5)
		{
			builder.spawn(new WaveSpawn(2 - (wave % 2), Enemy.JAVELIN_COLOSSUS));
		}

		// manticore every wave 4 and up, varying between 1 and 2 spawns
		if (wave >= 4)
		{
			// single spawn on wave 4-8, double thereafter
			boolean single = wave <= 8;
			builder.spawn(new WaveSpawn(single ? 1 : 2, Enemy.MANTICORE));
		}

		// shockwave waves 7, 8, and 11, and 2 spawns if dynamic duo is on
		if (wave == 7 || wave == 8 || wave == 11)
		{
			builder.spawn(new WaveSpawn(modifiers.contains(Modifier.DYNAMIC_DUO) ? 2 : 1, Enemy.SHOCKWAVE_COLOSSUS));
		}

		// minotaur replaces jaguar warrior in replacements wave 7 and up
		if (wave >= 7)
		{
			builder.reinforcement(new WaveSpawn(1, Enemy.MINOTAUR));
		}

		return builder.build();
	}

}

package com.duckblade.osrs.fortis.util;

import com.duckblade.osrs.fortis.module.PluginLifecycleComponent;
import com.google.common.annotations.VisibleForTesting;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.NpcID;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
@Slf4j
public class ColosseumStateTracker implements PluginLifecycleComponent
{

	private static final int REGION_LOBBY = 7316;
	private static final int REGION_COLOSSEUM = 7216;

	private static final int SCRIPT_MODIFIER_SELECT_INIT = 4931;
	private static final int VARBIT_MODIFIER_SELECTED = 9788;

	private static final ColosseumState DEFAULT_STATE = new ColosseumState(false, false, 1, false, Collections.emptyList());

	private final Client client;
	private final EventBus eventBus;

	@Getter
	private ColosseumState currentState = DEFAULT_STATE;

	private int waveNumber = 1;
	private boolean waveStarted = false;

	@Getter
	private final List<Modifier> modifierOptions = new ArrayList<>(3);

	@Getter(value = AccessLevel.PACKAGE, onMethod_ = @VisibleForTesting)
	private final List<Modifier> modifiers = new ArrayList<>(12);

	@Override
	public void startUp()
	{
		eventBus.register(this);
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
	}

	@Subscribe(priority = 5)
	public void onGameTick(GameTick e)
	{
		LocalPoint lp = client.getLocalPlayer().getLocalLocation();
		int region = lp == null ? -1 : WorldPoint.fromLocalInstance(client, lp).getRegionID();

		boolean inLobby = region == REGION_LOBBY;
		boolean inColosseum = client.isInInstancedRegion() && region == REGION_COLOSSEUM;

		if (!inColosseum)
		{
			waveNumber = 1;
			waveStarted = false;
			modifierOptions.clear();
			modifiers.clear();
		}

		setState(
			new ColosseumState(inLobby, inColosseum, waveNumber, waveStarted, Collections.unmodifiableList(modifiers)),
			false
		);
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged e)
	{
		switch (e.getGameState())
		{
			case LOGGING_IN:
			case HOPPING:
				setState(DEFAULT_STATE, true);
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage e)
	{
		if (e.getType() != ChatMessageType.GAMEMESSAGE || !getCurrentState().isInColosseum())
		{
			return;
		}

		String msg = e.getMessage();
		if (msg.contains("Sol Heredit jumps down from his seat"))
		{
			waveNumber = 12;
			waveStarted = true;
		}
		else if (msg.contains("Wave: ")) // only wave start messages contain a :
		{
			waveNumber = Integer.parseInt(msg.substring(18, msg.length() - 6));
			waveStarted = true;
		}
		else if (msg.startsWith("Wave ") && msg.contains("completed!"))
		{
			// it's either a two-char number or a number and a space
			waveNumber = Integer.parseInt(msg.substring(5, 7).trim()) + 1;
			waveStarted = false;
		}
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned e)
	{
		if (currentState.isInColosseum() && e.getNpc().getId() == NpcID.MINIMUS_12808)
		{
			trackSelectedModifier();
		}
	}

	@Subscribe
	public void onScriptPreFired(ScriptPreFired e)
	{
		if (e.getScriptId() != SCRIPT_MODIFIER_SELECT_INIT)
		{
			return;
		}

		try
		{
			// pull the options available for next wave from the script args
			modifierOptions.clear();
			Object[] args = e.getScriptEvent().getArguments();
			modifierOptions.add(Modifier.forId((Integer) args[2]));
			modifierOptions.add(Modifier.forId((Integer) args[3]));
			modifierOptions.add(Modifier.forId((Integer) args[4]));
			log.debug("Modifier options = {}", modifierOptions);

			// also make sure we haven't missed any so far
			for (Modifier h : Modifier.forBitmask((Integer) args[8]))
			{
				if (!modifiers.contains(h))
				{
					modifiers.add(h);
				}
			}
		}
		catch (Exception ex)
		{
			// very much so don't want to throw uncaught into script eval
			log.warn("failed to extract modifier from arguments", ex);
		}
	}

	private void setState(ColosseumState newValue, boolean forceEvent)
	{
		if (!forceEvent && currentState.equals(newValue))
		{
			return;
		}

		log.debug("Colosseum state change {} => {}", currentState, newValue);
		ColosseumState previous = currentState;
		currentState = newValue;
		eventBus.post(new ColosseumStateChanged(previous, currentState));
	}

	private void trackSelectedModifier()
	{
		if (modifierOptions.isEmpty())
		{
			log.warn("Wave started but modifier options were not tracked");
			return;
		}

		int selectedIx = client.getVarbitValue(VARBIT_MODIFIER_SELECTED);
		if (selectedIx == 0)
		{
			log.debug("varb {} = 0, no modifier selected?", VARBIT_MODIFIER_SELECTED);
			return;
		}

		Modifier selected = modifierOptions.get(selectedIx - 1);
		modifierOptions.clear();
		if (selected == null)
		{
			log.warn("Failed to select modifier with index {}, options = {}", selectedIx, modifierOptions);
			return;
		}

		if (!modifiers.contains(selected))
		{
			modifiers.add(selected);
		}
		log.debug("Tracked modifier selection {} (ix {}), handicaps = {}", selected, selectedIx, modifiers);
	}
}

package com.duckblade.osrs.fortis.util;

import java.util.EnumSet;
import java.util.Set;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.annotations.VisibleForDevtools;

@RequiredArgsConstructor
public enum Modifier
{

	BEES("Bees!", new int[]{5544, 5559, 5574}, 2, 9791),
	BLASPHEMY("Blasphemy", new int[]{5538, 5553, 5568}, 4, 9790),
	DOOM("Doom", new int[]{5543, 5558, 5573}, 8, 10681),
	DYNAMIC_DUO("Dynamic Duo", new int[]{5545}, 9, -1),
	FRAILTY("Frailty", new int[]{5541, 5556, 5571}, 12, 9796),
	MANTIMAYHEM("Mantimayhem", new int[]{5539, 5554, 5569}, 0, 4588),
	MYOPIA("Myopia", new int[]{5547, 5562, 5577}, 11, 9795),
	REENTRY("Reentry", new int[]{5536, 5551, 5566}, 1, 9792),
	RED_FLAG("Red Flag", new int[]{5540}, 13, -1),
	RELENTLESS("Relentless", new int[]{5535, 5550, 5565}, 5, 9798),
	SOLARFLARE("Solarflare", new int[]{5537, 5552, 5567}, 10, 9797),
	QUARTET("Quartet", new int[]{5546}, 6, -1),
	TOTEMIC("Totemic", new int[]{5542}, 7, -1),
	VOLATILITY("Volatility", new int[]{5534, 5549, 5564}, 3, 9799),
	;

	private final String name;
	private final int[] spriteIds;

	@Getter(onMethod_ = @VisibleForDevtools)
	private final int id;

	@Getter
	private final int levelVarb;

	public int getLevel(Client client)
	{
		if (levelVarb == -1)
		{
			return 1;
		}

		try
		{
			return client.getVarbitValue(levelVarb);
		}
		catch (Exception e)
		{
			// jagex moved one of the varbs when adding mantimayhem which caused failed reads and crashes
			return 1;
		}
	}

	public String getName(int level)
	{
		if (levelVarb == -1)
		{
			return name;
		}

		return level == 3 ? name + " (III)"
			: level == 2 ? name + " (II)"
			: name;
	}

	public String getName(Client client)
	{
		return getName(getLevel(client));
	}

	public int getSpriteId(int level)
	{
		return spriteIds[Math.max(0, level - 1)];
	}

	public int getSpriteId(Client client)
	{
		return getSpriteId(getLevel(client));
	}

	public static Modifier forId(int id)
	{
		for (Modifier h : values())
		{
			if (h.id == id)
			{
				return h;
			}
		}

		return null;
	}

	public static Set<Modifier> forBitmask(int bits)
	{
		Set<Modifier> ret = EnumSet.noneOf(Modifier.class);
		for (Modifier h : values())
		{
			if ((bits & (1 << h.id)) != 0)
			{
				ret.add(h);
			}
		}

		return ret;
	}

}

package com.duckblade.osrs.fortis.util;

import com.duckblade.osrs.fortis.util.spawns.WaveSpawns;
import java.util.List;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.ToString;
import net.runelite.api.Client;

@RequiredArgsConstructor
@EqualsAndHashCode
@ToString
public class ColosseumState
{

	@Getter
	private final boolean inLobby;

	@Getter
	private final boolean inColosseum;

	@Getter
	private final int waveNumber;

	@Getter
	private final boolean waveStarted;

	@Getter
	@EqualsAndHashCode.Exclude
	@ToString.Exclude
	private final List<Modifier> modifiers;

	@EqualsAndHashCode.Exclude
	@ToString.Exclude
	private WaveSpawns waveSpawns;

	@EqualsAndHashCode.Exclude
	@ToString.Exclude
	private WaveSpawns nextWaveSpawns;

	public WaveSpawns getWaveSpawns(Client client)
	{
		if (this.waveSpawns != null)
		{
			return this.waveSpawns;
		}
		return this.waveSpawns = WaveSpawns.forWave(client, this, false);
	}

	public WaveSpawns getNextWaveSpawns(Client client)
	{
		if (this.nextWaveSpawns != null)
		{
			return this.nextWaveSpawns;
		}
		return this.nextWaveSpawns = WaveSpawns.forWave(client, this, true);
	}
}

package com.duckblade.osrs.fortis.util;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;

@Getter
@RequiredArgsConstructor
public enum TimerMode
{

	PRECISE("--:--.--"),
	LAX("--:--"),
	TICKS("--"),
	;

	private final String nullPattern;

	private static final int VARBIT_PRECISE_TIMING = 11866;

	public String format(int ticks)
	{
		if (ticks < 0)
		{
			return this.nullPattern;
		}

		int mins = (ticks / 100);
		float secondsReal = (ticks % 100) * 0.6f;
		int seconds = (int) secondsReal;
		int tenths = Math.round((secondsReal - seconds) * 10f);

		switch (this)
		{
			case PRECISE:
				return String.format("%d:%02d.%d0", mins, seconds, tenths);

			case LAX:
				return String.format("%d:%02d", mins, seconds);

			case TICKS:
				return String.valueOf(ticks);

			default:
				throw new IllegalStateException("Unimplemented timer mode format " + this.name());
		}
	}

	public static TimerMode fromClient(Client c)
	{
		assert c.isClientThread();
		return c.getVarbitValue(VARBIT_PRECISE_TIMING) == 1 ? PRECISE : LAX;
	}

}

package com.duckblade.osrs.fortis.module;

import com.duckblade.osrs.fortis.FortisColosseumConfig;
import com.duckblade.osrs.fortis.util.ColosseumState;

public interface PluginLifecycleComponent
{

	default boolean isEnabled(FortisColosseumConfig config, ColosseumState colosseumState)
	{
		return true;
	}

	void startUp();

	void shutDown();

}

package com.duckblade.osrs.fortis.module;

import com.duckblade.osrs.fortis.FortisColosseumConfig;
import com.duckblade.osrs.fortis.features.LeftClickBankAll;
import com.duckblade.osrs.fortis.features.loot.LootHider;
import com.duckblade.osrs.fortis.features.loot.LootTotalDisplay;
import com.duckblade.osrs.fortis.features.modifiers.ModifierOverlay;
import com.duckblade.osrs.fortis.features.modifiers.ModifierSelectNamesManager;
import com.duckblade.osrs.fortis.features.modifiers.VolatilityReminder;
import com.duckblade.osrs.fortis.features.timetracking.SplitsFileWriter;
import com.duckblade.osrs.fortis.features.timetracking.SplitsOverlay;
import com.duckblade.osrs.fortis.features.timetracking.SplitsTracker;
import com.duckblade.osrs.fortis.features.timetracking.livesplit.LiveSplitManager;
import com.duckblade.osrs.fortis.features.waves.WavesOverlay;
import com.duckblade.osrs.fortis.util.ColosseumStateTracker;
import com.google.common.collect.ImmutableSet;
import com.google.inject.AbstractModule;
import com.google.inject.Provides;
import com.google.inject.Singleton;
import java.util.Set;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;

@Slf4j
public class FortisColosseumModule extends AbstractModule
{

	@Override
	protected void configure()
	{
		bind(ComponentManager.class);
	}

	@Provides
	Set<PluginLifecycleComponent> lifecycleComponents(
		ColosseumStateTracker colosseumStateTracker,
		LeftClickBankAll leftClickBankAll,
		LiveSplitManager liveSplitManager,
		LootHider lootHider,
		LootTotalDisplay lootTotalDisplay,
		ModifierOverlay modifierOverlay,
		ModifierSelectNamesManager modifierSelectNamesManager,
		SplitsFileWriter splitsFileWriter,
		SplitsOverlay splitsOverlay,
		SplitsTracker splitsTracker,
		VolatilityReminder volatilityReminder,
		WavesOverlay wavesOverlay
	)
	{
		return ImmutableSet.of(
			colosseumStateTracker,
			leftClickBankAll,
			liveSplitManager,
			lootHider,
			lootTotalDisplay,
			modifierOverlay,
			modifierSelectNamesManager,
			splitsFileWriter,
			splitsOverlay,
			splitsTracker,
			volatilityReminder,
			wavesOverlay
		);
	}

	@Provides
	@Singleton
	FortisColosseumConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(FortisColosseumConfig.class);
	}

}

package com.duckblade.osrs.fortis.module;

import com.duckblade.osrs.fortis.FortisColosseumConfig;
import com.duckblade.osrs.fortis.util.ColosseumState;
import com.duckblade.osrs.fortis.util.ColosseumStateChanged;
import com.duckblade.osrs.fortis.util.ColosseumStateTracker;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.util.GameEventManager;

/**
 * Manages all the subcomponents of the plugin
 * so they can register themselves to RuneLite resources
 * e.g. EventBus/OverlayManager/init on startup/etc
 * instead of the FortisColosseumPlugin class handling everything.
 */
@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
@Slf4j
public class ComponentManager
{

	private final EventBus eventBus;
	private final GameEventManager gameEventManager;
	private final FortisColosseumConfig config;
	private final ColosseumStateTracker colosseumStateTracker;
	private final Set<PluginLifecycleComponent> components;

	private final Map<PluginLifecycleComponent, Boolean> states = new HashMap<>();

	public void onPluginStart()
	{
		eventBus.register(this);
		components.forEach(c -> states.put(c, false));
		revalidateComponentStates();
	}

	public void onPluginStop()
	{
		eventBus.unregister(this);
		components.stream()
			.filter(states::get)
			.forEach(this::tryShutDown);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged e)
	{
		if (!FortisColosseumConfig.CONFIG_GROUP.equals(e.getGroup()))
		{
			return;
		}

		revalidateComponentStates();
	}

	@Subscribe
	public void onColosseumStateChanged(ColosseumStateChanged e)
	{
		revalidateComponentStates();
	}

	private void revalidateComponentStates()
	{
		ColosseumState colosseumState = colosseumStateTracker.getCurrentState();
		components.forEach(c ->
		{
			boolean shouldBeEnabled = c.isEnabled(config, colosseumState);
			boolean isEnabled = states.get(c);
			if (shouldBeEnabled == isEnabled)
			{
				return;
			}

			if (shouldBeEnabled)
			{
				tryStartUp(c);
			}
			else
			{
				tryShutDown(c);
			}
		});
	}

	private void tryStartUp(PluginLifecycleComponent component)
	{
		if (states.get(component))
		{
			return;
		}

		if (log.isDebugEnabled())
		{
			log.debug("Enabling FortisColosseum plugin component [{}]", component.getClass().getName());
		}

		try
		{
			component.startUp();
			gameEventManager.simulateGameEvents(component);
			states.put(component, true);
		}
		catch (Exception e)
		{
			log.error("Failed to start FortisColosseum plugin component [{}]", component.getClass().getName(), e);
		}
	}

	private void tryShutDown(PluginLifecycleComponent component)
	{
		if (!states.get(component))
		{
			return;
		}

		if (log.isDebugEnabled())
		{
			log.debug("Disabling FortisColosseum plugin component [{}]", component.getClass().getName());
		}

		try
		{
			component.shutDown();
		}
		catch (Exception e)
		{
			log.error("Failed to cleanly shut down FortisColosseum plugin component [{}]", component.getClass().getName());
		}
		finally
		{
			states.put(component, false);
		}
	}

}

package com.duckblade.osrs.fortis;

import com.duckblade.osrs.fortis.module.ComponentManager;
import com.duckblade.osrs.fortis.module.FortisColosseumModule;
import com.google.inject.Binder;
import com.google.inject.Inject;
import com.google.inject.Injector;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;

@Slf4j
@PluginDescriptor(
	name = "Fortis Colosseum",
	description = "Utilities and information for the Fortis Colosseum.",
	tags = {"fortis", "colosseum", "varlamore", "dizana", "quiver"}
)
public class FortisColosseumPlugin extends Plugin
{

	@Inject
	private Injector injector;

	private ComponentManager componentManager = null;

	@Override
	public void configure(Binder binder)
	{
		binder.install(new FortisColosseumModule());
	}

	@Override
	protected void startUp() throws Exception
	{
		if (componentManager == null)
		{
			componentManager = injector.getInstance(ComponentManager.class);
		}
		componentManager.onPluginStart();
	}

	@Override
	protected void shutDown() throws Exception
	{
		componentManager.onPluginStop();
	}
}

package com.duckblade.osrs.fortis;

import com.duckblade.osrs.fortis.features.loot.LootHiderMode;
import com.duckblade.osrs.fortis.features.loot.LootTotalMode;
import com.duckblade.osrs.fortis.features.modifiers.ModifierSpriteStyle;
import com.duckblade.osrs.fortis.features.timetracking.SplitsFileWriter;
import com.duckblade.osrs.fortis.features.timetracking.SplitsOverlayMode;
import com.duckblade.osrs.fortis.features.waves.EnemyNameMode;
import com.duckblade.osrs.fortis.features.waves.WaveOverlayMode;
import com.duckblade.osrs.fortis.util.TimerMode;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;
import net.runelite.client.ui.overlay.components.ComponentOrientation;

@ConfigGroup(FortisColosseumConfig.CONFIG_GROUP)
public interface FortisColosseumConfig extends Config
{

	String CONFIG_GROUP = "fortiscolosseum";

	@ConfigSection(
		name = "Waves Overlay",
		description = "Show which enemies are in the current and next wave.",
		position = 100
	)
	String SECTION_WAVES_OVERLAY = "wavesOverlay";

	@ConfigItem(
		keyName = "wavesOverlayMode",
		name = "Display",
		description = "Enable or disable the waves display components.",
		position = 101,
		section = SECTION_WAVES_OVERLAY
	)
	default WaveOverlayMode wavesOverlayMode()
	{
		return WaveOverlayMode.BOTH;
	}

	@ConfigItem(
		keyName = "wavesOverlayNames",
		name = "Names",
		description = "Whether to use official NPC names (e.g. Serpent Shaman), or colloquial (e.g. Mage)",
		position = 102,
		section = SECTION_WAVES_OVERLAY
	)
	default EnemyNameMode wavesOverlayNames()
	{
		return EnemyNameMode.COLLOQUIAL;
	}

	@ConfigItem(
		keyName = "wavesOverlayShowModifierSpawns",
		name = "Show Modifier-Only Spawns",
		description = "Include Angry Bees in the list of spawns for each wave.<br>Dynamic Duo and Quartet are always shown.",
		position = 103,
		section = SECTION_WAVES_OVERLAY
	)
	default boolean wavesOverlayShowModifierSpawns()
	{
		return false;
	}

	@ConfigSection(
		name = "Modifiers",
		description = "Modifiers overlay and selection options",
		position = 200
	)
	String SECTION_MODIFIERS = "modifiers";

	@ConfigItem(
		keyName = "modifiersOverlayEnabled",
		name = "Overlay Enabled",
		description = "Shows the current active modifiers as an overlay of icons",
		position = 201,
		section = SECTION_MODIFIERS
	)
	default boolean modifiersOverlayEnabled()
	{
		return true;
	}

	@ConfigItem(
		keyName = "modifiersOverlayOrientation",
		name = "Overlay Orientation",
		description = "Whether to render vertically or horizontally",
		position = 202,
		section = SECTION_MODIFIERS
	)
	default ComponentOrientation modifiersOverlayOrientation()
	{
		return ComponentOrientation.HORIZONTAL;
	}

	@ConfigItem(
		keyName = "modifiersOverlayOrientation",
		name = "Overlay Orientation",
		description = "Whether to render vertically or horizontally",
		position = 202,
		section = SECTION_MODIFIERS
	)
	void setModifiersOverlayOrientation(ComponentOrientation orientation);

	@ConfigItem(
		keyName = "modifiersOverlayStyle",
		name = "Style",
		description = "Whether to render vertically or horizontally",
		position = 203,
		section = SECTION_MODIFIERS
	)
	default ModifierSpriteStyle modifiersOverlayStyle()
	{
		return ModifierSpriteStyle.COMPACT;
	}

	@ConfigItem(
		keyName = "modifiersOverlayStyle",
		name = "Style",
		description = "Whether to render vertically or horizontally",
		position = 203,
		section = SECTION_MODIFIERS
	)
	void setModifiersOverlayStyle(ModifierSpriteStyle style);

	@ConfigItem(
		keyName = "modifiersNamesOnSelectWidget",
		name = "Show Names on Selector",
		description = "Show the modifier names on the pre-wave selector panel.",
		position = 204,
		section = SECTION_MODIFIERS
	)
	default boolean modifiersNamesOnSelectWidget()
	{
		return true;
	}

	@ConfigItem(
		keyName = "volatilityReminder",
		name = "Volatility Reminder",
		description = "Shows an icon overlay on dying NPCs to remind of their explosion.<br>Does NOT indicate the explosion radius.",
		position = 205,
		section = SECTION_MODIFIERS
	)
	default boolean volatilityReminder()
	{
		return false;
	}

	@ConfigSection(
		name = "Splits",
		description = "Time tracking and splits",
		position = 300
	)
	String SECTION_SPLITS = "splits";

	@ConfigItem(
		keyName = "splitsOverlayMode",
		name = "Overlay Panel",
		description = "Show splits as an overlay panel.",
		position = 301,
		section = SECTION_SPLITS
	)
	default SplitsOverlayMode splitsOverlayMode()
	{
		return SplitsOverlayMode.OFF;
	}

	@ConfigItem(
		keyName = "splitsOverlayLines",
		name = "Overlay Wave Count",
		description = "Show the last N waves on the overlay panel.<br>" +
			"Set to 1 to only show the active wave.<br>" +
			"Set to 0 to only show the total time.",
		position = 302,
		section = SECTION_SPLITS
	)
	@Range(min = 0, max = 12)
	default int splitsOverlayLines()
	{
		return 12;
	}

	@ConfigItem(
		keyName = "splitsFileCondition",
		name = "Save to File",
		description = "Save splits to files in .runelite/fortis-colosseum/splits/",
		position = 303,
		section = SECTION_SPLITS
	)
	default SplitsFileWriter.WriteCondition splitsFileCondition()
	{
		return SplitsFileWriter.WriteCondition.NEVER;
	}

	@ConfigItem(
		keyName = "splitsTimerMode",
		name = "File Timer Mode",
		description = "Whether to use human times or ticks when writing to the file.<br>" +
				"'Precise' is minutes, seconds, and milliseconds.<br>" +
				"'Lax' is minutes and seconds.<br>" +
				"'Ticks' is an unconverted server tick count.",
		position = 304,
		section = SECTION_SPLITS
	)
	default TimerMode splitsFileTimerMode()
	{
		return TimerMode.TICKS;
	}

	String KEY_LIVESPLIT_PORT = "splitsLivesplitPort";
	@ConfigItem(
		keyName = KEY_LIVESPLIT_PORT,
		name = "LiveSplit Port",
		description = "Send splits events to LiveSplit. Set to 0 to disable.<br>Requires LiveSplit Server. See the plugin README for more details.",
		position = 305,
		section = SECTION_SPLITS
	)
	@Range(min = 0, max = 65535)
	default int splitsLivesplitPort()
	{
		return 0;
	}

	@ConfigItem(
		keyName = "splitsLivesplitAutoReset",
		name = "LiveSplit Auto-Reset",
		description = "Automatically restart the timer at Wave 1 when a new run is started.",
		position = 306,
		section = SECTION_SPLITS
	)
	default boolean splitsLivesplitAutoReset()
	{
		return false;
	}

	@ConfigSection(
		name = "Loot Interface",
		description = "Options for the loot shown between waves and on completion.",
		position = 400
	)
	String SECTION_LOOT_INTERFACE = "lootInterface";

	@ConfigItem(
		keyName = "leftClickBankAll", // legacy keyName
		name = "Left-Click Bank-All",
		description = "Switch the two-click Bank-All to a single click in the loot chest interface.",
		position = 401,
		section = SECTION_LOOT_INTERFACE
	)
	default boolean leftClickBankAll()
	{
		return true;
	}

	@ConfigItem(
		keyName = "lootInterfaceHideNextWave",
		name = "Hide Next Wave",
		description = "Hide potential next wave loot behind an extra click.",
		position = 402,
		section = SECTION_LOOT_INTERFACE
	)
	default LootHiderMode lootInterfaceHideNextWave()
	{
		return LootHiderMode.OFF;
	}

	@ConfigItem(
		keyName = "lootInterfaceShowTotal",
		name = "Show Loot Total",
		description = "",
		position = 403,
		section = SECTION_LOOT_INTERFACE
	)
	default LootTotalMode lootInterfaceShowTotal()
	{
		return LootTotalMode.EARNED;
	}

}

package launcher;

import com.duckblade.osrs.fortis.FortisColosseumPlugin;
import com.duckblade.osrs.fortis.debugplugins.FortisColosseumDebugPlugin;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class FortisColosseumPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(FortisColosseumPlugin.class, FortisColosseumDebugPlugin.class);
		RuneLite.main(args);
	}
}

package com.duckblade.osrs.fortis.debugplugins;

import com.duckblade.osrs.fortis.util.DebugColosseumStateTrackerInterface;
import com.duckblade.osrs.fortis.util.Modifier;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JPanel;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.devtools.DevToolsFrame;

@Singleton
@Slf4j
public class FortisColosseumDebugPanel extends DevToolsFrame
{

	private static final int SCRIPT_MODIFIER_SELECT_INIT = 4931;

	private final Client client;
	private final ClientThread clientThread;
	private final EventBus eventBus;
	private final DebugColosseumStateTrackerInterface stateTrackerInterface;

	private final Map<Modifier, Integer> modifiers = new HashMap<>();
	private final List<Modifier> options = new ArrayList<>(Arrays.asList(Modifier.BEES, Modifier.BEES, Modifier.BEES));

	private boolean mockingModifiers = false;
	private boolean mockingOptions = false;

	@Inject
	public FortisColosseumDebugPanel(
		Client client,
		ClientThread clientThread,
		SpriteManager spriteManager,
		EventBus eventBus,
		DebugColosseumStateTrackerInterface stateTrackerInterface
	)
	{
		this.client = client;
		this.clientThread = clientThread;
		this.eventBus = eventBus;
		this.stateTrackerInterface = stateTrackerInterface;
		eventBus.register(this);

		setTitle("Fortis Colosseum");
		setAlwaysOnTop(true);
		setPreferredSize(new Dimension(800, 320));
		getContentPane().setLayout(new BoxLayout(getContentPane(), BoxLayout.Y_AXIS));
		add(Box.createVerticalStrut(5));

		JPanel mockModifiers = new JPanel();
		mockModifiers.setLayout(new BoxLayout(mockModifiers, BoxLayout.Y_AXIS));

		JCheckBox mockModifiersActive = new JCheckBox("Override modifiers");
		mockModifiersActive.addActionListener((_e) ->
		{
			mockingModifiers = !mockingModifiers;
			mockModifiers();
		});
		mockModifiers.add(mockModifiersActive);

		JPanel modifierToggles = new JPanel(new GridLayout(2, 7));
		for (Modifier m : Modifier.values())
		{
			modifierToggles.add(new ModifierToggle(spriteManager, m, this::modifierToggleCallback));
		}
		mockModifiers.add(modifierToggles);
		add(mockModifiers);
		add(Box.createVerticalStrut(10));

		JPanel mockOptions = new JPanel();
		mockOptions.setLayout(new BoxLayout(mockOptions, BoxLayout.Y_AXIS));
		JCheckBox mockOptionsActive = new JCheckBox("Override options");
		mockOptionsActive.addActionListener((_e) -> mockingOptions = !mockingOptions);
		mockOptions.add(mockOptionsActive);

		JPanel optionCombos = new JPanel(new GridLayout(1, 3));
		optionCombos.setMaximumSize(new Dimension(1000, 50));
		for (int i = 0; i < 3; i++)
		{
			final int optionIx = i;
			JComboBox<Modifier> option = new JComboBox<>(Modifier.values());
			option.addActionListener((_e) -> options.set(optionIx, (Modifier) option.getSelectedItem()));
			optionCombos.add(option);
		}
		mockOptions.add(optionCombos);
		add(mockOptions);

		pack();
	}

	private void modifierToggleCallback(Modifier m, int level)
	{
		if (level == 0)
		{
			modifiers.remove(m);
		}
		else
		{
			modifiers.put(m, level);
		}
		mockModifiers();
	}

	private void mockModifiers()
	{
		if (mockingModifiers)
		{
			for (Map.Entry<Modifier, Integer> e : modifiers.entrySet())
			{
				Modifier m = e.getKey();
				int level = e.getValue();
				if (m.getLevelVarb() != -1)
				{
					clientThread.invokeLater(() -> client.setVarbit(m.getLevelVarb(), level));
				}
			}
			stateTrackerInterface.setModifiers(modifiers.keySet());
		}
	}

	@Override
	public void open()
	{
		eventBus.register(this);
		super.open();
	}

	@Override
	public void close()
	{
		eventBus.unregister(this);
		super.close();
	}

	@Subscribe(priority = 100)
	public void onScriptPreFired(ScriptPreFired e)
	{
		if (e.getScriptId() != SCRIPT_MODIFIER_SELECT_INIT)
		{
			return;
		}

		Object[] args = e.getScriptEvent().getArguments();

		if (mockingModifiers)
		{
			stateTrackerInterface.setModifiers(Collections.emptyList());
			int bits = 0;
			for (Modifier m : modifiers.keySet())
			{
				bits |= (1 << m.getId());
			}

			args[8] = bits;
		}

		if (mockingOptions)
		{
			args[2] = options.get(0).getId();
			args[3] = options.get(1).getId();
			args[4] = options.get(2).getId();
		}
	}

	@Subscribe(priority = 100)
	public void onVarbitChanged(VarbitChanged e)
	{
		if (!mockingModifiers)
		{
			return;
		}

		for (Modifier m : modifiers.keySet())
		{
			if (e.getVarbitId() == m.getLevelVarb())
			{
				e.setValue(modifiers.get(m));
				return;
			}
		}
	}
}

package com.duckblade.osrs.fortis.debugplugins;

import com.duckblade.osrs.fortis.util.Modifier;
import java.awt.BorderLayout;
import java.awt.image.BufferedImage;
import java.util.function.BiConsumer;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.util.ImageUtil;

class ModifierToggle extends JButton
{
	private static final BufferedImage EMPTY = new BufferedImage(38, 38, BufferedImage.TYPE_INT_ARGB);

	private final Modifier modifier;
	private final SpriteManager spriteManager;
	private final BiConsumer<Modifier, Integer> callback;

	private final JLabel imageLabel;
	private final JLabel textLabel;

	private int level = 0;

	public ModifierToggle(SpriteManager spriteManager, Modifier modifier, BiConsumer<Modifier, Integer> callback)
	{
		super();
		this.spriteManager = spriteManager;
		this.modifier = modifier;
		this.callback = callback;

		setLayout(new BorderLayout());
		add(imageLabel = new JLabel(new ImageIcon(EMPTY)), BorderLayout.CENTER);
		imageLabel.setHorizontalAlignment(JLabel.CENTER);
		add(textLabel = new JLabel(modifier.getName(1)), BorderLayout.SOUTH);
		textLabel.setHorizontalAlignment(JLabel.CENTER);

		addActionListener((_e) -> toggle());
	}

	private void toggle()
	{
		textLabel.setHorizontalAlignment(JLabel.CENTER);
		level++;
		level %= (modifier.getLevelVarb() == -1) ? 2 : 4;
		if (level == 0)
		{
			imageLabel.setIcon(new ImageIcon(EMPTY));
		}
		else
		{
			ImageIcon icon = new ImageIcon();
			imageLabel.setIcon(icon);
			spriteManager.getSpriteAsync(modifier.getSpriteId(level), 0, i ->
				icon.setImage(ImageUtil.resizeCanvas(i, 38, 38)));
		}
		textLabel.setName(modifier.getName(level));
		callback.accept(modifier, level);
	}
}

package com.duckblade.osrs.fortis.debugplugins;

import ch.qos.logback.classic.Level;
import ch.qos.logback.classic.Logger;
import javax.inject.Singleton;
import javax.swing.SwingUtilities;
import net.runelite.api.events.CommandExecuted;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import org.slf4j.LoggerFactory;

@Singleton
@PluginDescriptor(
	name = "Fortis Colosseum Debug"
)
public class FortisColosseumDebugPlugin extends Plugin
{

	private FortisColosseumDebugPanel debugPanel;

	@Override
	protected void startUp()
	{
		((Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME)).setLevel(Level.WARN);
		((Logger) LoggerFactory.getLogger("com.duckblade.osrs.fortis")).setLevel(Level.DEBUG);

		SwingUtilities.invokeLater(() -> debugPanel = injector.getInstance(FortisColosseumDebugPanel.class));
	}

	@Override
	protected void shutDown() throws Exception
	{
		((Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME)).setLevel(Level.DEBUG);
	}

	@Subscribe
	public void onCommandExecuted(CommandExecuted e)
	{
		if (e.getCommand().equals("fortis"))
		{
			if (debugPanel.isVisible())
			{
				debugPanel.close();
			}
			else
			{
				debugPanel.open();
			}
		}
	}
}

package com.duckblade.osrs.fortis.features.timetracking;

import com.duckblade.osrs.fortis.FortisColosseumConfig;
import com.duckblade.osrs.fortis.util.TimerMode;
import java.util.List;
import java.util.concurrent.TimeUnit;
import net.runelite.client.eventbus.EventBus;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
public class SplitsFileWriterTest
{

	@InjectMocks
	SplitsFileWriter fileWriter;

	@Mock
	private FortisColosseumConfig config;

	@Mock
	private EventBus eventBus;

	@BeforeEach
	void setUp()
	{
		fileWriter.startUp();
	}

	@AfterEach
	void shutDown()
	{
		fileWriter.shutDown();
	}

	@Test
	@Disabled("writes to userhome, no verification mechanism")
	void testPrecise() throws InterruptedException
	{
		when(config.splitsFileTimerMode()).thenReturn(TimerMode.PRECISE);
		fileWriter.queueWrite(List.of(
			new Split(1, 10, 10, 10),
			new Split(2, 15, 40, 25),
			new Split(3, 30, 100, 55)
		));
		fileWriter.es.awaitTermination(1, TimeUnit.SECONDS);
	}

	@Test
	@Disabled("writes to userhome, no verification mechanism")
	void testLax() throws InterruptedException
	{
		when(config.splitsFileTimerMode()).thenReturn(TimerMode.LAX);
		fileWriter.queueWrite(List.of(
			new Split(1, 10, 10, 10),
			new Split(2, 15, 40, 25),
			new Split(3, 30, 100, 55)
		));
		fileWriter.es.awaitTermination(1, TimeUnit.SECONDS);
	}

	@Test
	@Disabled("writes to userhome, no verification mechanism")
	void testTicks() throws InterruptedException
	{
		when(config.splitsFileTimerMode()).thenReturn(TimerMode.TICKS);
		fileWriter.queueWrite(List.of(
			new Split(1, 10, 10, 10),
			new Split(2, 15, 40, 25),
			new Split(3, 30, 100, 55)
		));
		fileWriter.es.awaitTermination(1, TimeUnit.SECONDS);
	}

}

package com.duckblade.osrs.fortis.features.timetracking;

import com.duckblade.osrs.fortis.features.timetracking.livesplit.LiveSplitManager;
import java.util.List;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
public class SplitsTrackerTest
{

	@SuppressWarnings("unused") // void onSplit hook needs to be mocked
	@Mock
	LiveSplitManager liveSplitManager;

	@InjectMocks
	SplitsTracker splitsTracker;

	@Test
	void wave12DurationShouldBeParsedFromOverallTime()
	{
		splitsTracker.onChatMessage(buildChatMessage("Wave 1 completed! Wave duration: 0:31.80"));
		splitsTracker.onChatMessage(buildChatMessage("Wave 2 completed! Wave duration: 1:01.80"));
		splitsTracker.onChatMessage(buildChatMessage("Wave 3 completed! Wave duration: 2:42.60"));
		splitsTracker.onChatMessage(buildChatMessage("Wave 4 completed! Wave duration: 1:46.20"));
		splitsTracker.onChatMessage(buildChatMessage("Wave 5 completed! Wave duration: 2:03.60"));
		splitsTracker.onChatMessage(buildChatMessage("Wave 6 completed! Wave duration: 3:10.20"));
		splitsTracker.onChatMessage(buildChatMessage("Wave 7 completed! Wave duration: 3:15.00"));
		splitsTracker.onChatMessage(buildChatMessage("Wave 8 completed! Wave duration: 3:02.40"));
		splitsTracker.onChatMessage(buildChatMessage("Wave 9 completed! Wave duration: 1:57.00"));
		splitsTracker.onChatMessage(buildChatMessage("Wave 10 completed! Wave duration: 3:21.00"));
		splitsTracker.onChatMessage(buildChatMessage("Wave 11 completed! Wave duration: 4:07.80"));
		splitsTracker.onChatMessage(buildChatMessage("Colosseum duration: 29:42.60"));

		List<Split> splits = splitsTracker.getSplits();
		assertEquals(272, splits.get(11).getWaveDuration());
	}

	@Test
	void cumulativeWaveTimeShouldBeComputedFromTheSumOfAllWaves()
	{
		splitsTracker.onChatMessage(buildChatMessage("Wave 1 completed! Wave duration: 0:31.80"));
		splitsTracker.onChatMessage(buildChatMessage("Wave 2 completed! Wave duration: 1:01.80"));
		splitsTracker.onChatMessage(buildChatMessage("Wave 3 completed! Wave duration: 2:42.60"));
		splitsTracker.onChatMessage(buildChatMessage("Wave 4 completed! Wave duration: 1:46.20"));
		splitsTracker.onChatMessage(buildChatMessage("Wave 5 completed! Wave duration: 2:03.60"));
		splitsTracker.onChatMessage(buildChatMessage("Wave 6 completed! Wave duration: 3:10.20"));
		splitsTracker.onChatMessage(buildChatMessage("Wave 7 completed! Wave duration: 3:15.00"));
		splitsTracker.onChatMessage(buildChatMessage("Wave 8 completed! Wave duration: 3:02.40"));
		splitsTracker.onChatMessage(buildChatMessage("Wave 9 completed! Wave duration: 1:57.00"));
		splitsTracker.onChatMessage(buildChatMessage("Wave 10 completed! Wave duration: 3:21.00"));
		splitsTracker.onChatMessage(buildChatMessage("Wave 11 completed! Wave duration: 4:07.80"));
		splitsTracker.onChatMessage(buildChatMessage("Colosseum duration: 29:42.60"));

		List<Split> splits = splitsTracker.getSplits();
		assertEquals(53, splits.get(0).getCumulativeWaveDuration());
		assertEquals(156, splits.get(1).getCumulativeWaveDuration());
		assertEquals(427, splits.get(2).getCumulativeWaveDuration());
		assertEquals(2971, splits.get(11).getCumulativeWaveDuration());
	}

	private ChatMessage buildChatMessage(String msg)
	{
		return new ChatMessage(null, ChatMessageType.GAMEMESSAGE, null, msg, null, 0);
	}

}

package com.duckblade.osrs.fortis.util;

import java.util.Collection;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class DebugColosseumStateTrackerInterface
{

	private final ColosseumStateTracker stateTracker;

	public void setModifiers(Collection<Modifier> modifiers)
	{
		stateTracker.getModifiers().clear();
		stateTracker.getModifiers().addAll(modifiers);
	}

}

