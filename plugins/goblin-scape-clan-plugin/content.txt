package com.goblinscape;
import com.google.gson.*;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;
import okhttp3.*;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Base64;
import javax.inject.Inject;
@Slf4j
public class GoblinScapeAPI {
    private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");
    @Inject
    private OkHttpClient okHttpClient;

    @Inject
    private Gson gson;
    @Inject
    private ConfigManager configManager;
    @Inject
    private GoblinScapePlugin plugin;


    protected void makePostRequest(Object temp)
    {
        try
        {
            Request r = new Request.Builder()
                    .url(plugin.getPostEndpoint())
                    .addHeader("Authorization", plugin.getSharedKey())
                    .post(RequestBody.create(JSON, gson.toJson(temp)))
                    .build();

            okHttpClient.newCall(r).enqueue(new Callback()
            {
                @Override
                public void onFailure(Call call, IOException e)
                {
                    plugin.setPostError(true);
                }

                @Override
                public void onResponse(Call call, Response response)
                {
                    if (response.isSuccessful())
                    {
                        try {
                            JsonArray j = gson.fromJson(response.body().string(), JsonArray.class);
                            log.debug(j.toString());
                            plugin.setPostError(false);
                            response.close();
                        }
                        catch (IOException | JsonSyntaxException e)
                        {
                            plugin.setGetError(true);
                            log.error(e.getMessage());
                        }
                    }
                    else
                    {
                        log.error("Post request unsuccessful");
                        plugin.setPostError(true);
                    }
                    response.close();
                }
            });
        }
        catch (IllegalArgumentException e)
        {
            log.error("Bad URL given: " + e.getLocalizedMessage());
            plugin.setPostError(true);
        }
    }

    protected void makeMessageRequest(Object msg)
    {
        try
        {
            Request req = new Request.Builder()
                    .url(plugin.getMessageEndpoint())
                    .addHeader("Authorization", plugin.getSharedKey())
                    .post(RequestBody.create(JSON, gson.toJson(msg)))
                    .build();

            okHttpClient.newCall(req).enqueue(new Callback()
            {
                @Override
                public void onFailure(Call call, IOException e)
                {
                    plugin.setMsgError(true);
                }

                @Override
                public void onResponse(Call call, Response response)
                {
                    if (response.isSuccessful())
                    {
                        try {
                            JsonArray j = gson.fromJson(response.body().string(), JsonArray.class);
                            log.debug(j.toString());
                            plugin.setMsgError(false);
                            response.close();
                        }
                        catch (IOException | JsonSyntaxException e)
                        {
                            plugin.setGetError(true);
                            log.error(e.getMessage());
                        }
                    }
                    else
                    {
                        log.error("Message request unsuccessful");
                        plugin.setMsgError(true);
                    }
                    response.close();
                }
            });
        }
        catch (IllegalArgumentException e)
        {
            log.error("Bad URL given: " + e.getLocalizedMessage());
            plugin.setMsgError(true);
        }
    }

    protected void sendOnlinePlayers(JsonObject payload)
    {
        try
        {
            Request req = new Request.Builder()
                    .url(plugin.getOnlineEndpoint())
                    .addHeader("Authorization", plugin.getSharedKey())
                    .post(RequestBody.create(JSON, gson.toJson(payload)))
                    .build();

            okHttpClient.newCall(req).enqueue(new Callback()
            {
                @Override
                public void onFailure(Call call, IOException e)
                {
                    log.error("Failed to send online players: " + e.getMessage());
                }

                @Override
                public void onResponse(Call call, Response response)
                {
                    if (response.isSuccessful())
                    {
                        log.info("Online players updated successfully.");
                    }
                    else
                    {
                        log.error("Failed to update online players. HTTP Code: " + response.code());
                    }
                    response.close();
                }
            });
        }
        catch (Exception e)
        {
            log.error("Error sending online players: " + e.getMessage());
        }
    }


    protected void sendAllMembers(JsonObject payload)
    {
        try
        {
            Request req = new Request.Builder()
                    .url(plugin.getMemberEndpoint())
                    .addHeader("Authorization", plugin.getSharedKey())
                    .post(RequestBody.create(JSON, gson.toJson(payload)))
                    .build();

            okHttpClient.newCall(req).enqueue(new Callback()
            {
                @Override
                public void onFailure(Call call, IOException e)
                {
                    log.error("Failed to send members: " + e.getMessage());
                }

                @Override
                public void onResponse(Call call, Response response)
                {
                    if (response.isSuccessful())
                    {
                        log.info("Members updated successfully.");
                    }
                    else
                    {
                        log.error("Failed to update members. HTTP Code: " + response.code());
                    }
                    response.close();
                }
            });
        }
        catch (Exception e)
        {
            log.error("Error sending members: " + e.getMessage());
        }
    }

    public void uploadPlayerModel(String playerName, byte[] modelData)
    {
        try
        {
            String base64Model = Base64.getEncoder().encodeToString(modelData);

            JsonObject payload = new JsonObject();
            payload.addProperty("player", playerName);
            payload.addProperty("model", base64Model);

            Request request = new Request.Builder()
                    .url(plugin.getUploadModelEndpoint())
                    .addHeader("Authorization", plugin.getSharedKey())
                    .post(RequestBody.create(JSON, gson.toJson(payload)))
                    .build();

            okHttpClient.newCall(request).enqueue(new Callback()
            {
                @Override
                public void onFailure(Call call, IOException e)
                {
                    log.error("Failed to upload player model: " + e.getMessage());
                }

                @Override
                public void onResponse(Call call, Response response)
                {
                    try
                    {
                        if (response.isSuccessful())
                        {
                            log.info("Player model uploaded successfully.");
                        }
                        else
                        {
                            log.error("Failed to upload player model. HTTP Code: " + response.code());
                        }
                    }
                    finally
                    {
                        response.close();
                    }
                }
            });
        }
        catch (Exception e)
        {
            log.error("Error preparing model upload: " + e.getMessage());
        }
    }
}


package com.goblinscape;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("goblinscape")
public interface GoblinScapeConfig extends Config
{
	@ConfigItem(
		keyName = "APIUrl",
		name = "API URL",
		position = 1,
		secret = true,
		description = "Enter the API URL for the plugin. Message Solved or an Admin for this"
	)
	default String getEndpoint()
	{
		return "";
	}
	@ConfigItem(
			keyName = "sharedKey",
			name = "API Shared Key",
			position = 2,
			secret = true,
			description = "Enter the API Shared Key for the plugin. Message Solved or an Admin for this"
	)
	default String sharedKey()
	{
		return "";
	}

	@ConfigItem(
			keyName = "filterWilderness",
			name = "Send wilderness location",
			position = 3,
			description = "Sends your location if you are in the Wilderness"
	)
	default boolean filterWilderness() {return false; }

}

package com.goblinscape;
import lombok.Data;
import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

@Data
public class GoblinScapeMessage {
    @Getter
    private final String player;
    @Getter
    private final String message;
    @Getter
    private final String type;
    @Getter
    private final Integer timestamp;

    public GoblinScapeMessage(String player, String message, String type, int timestamp) {
        this.player = player;
        this.message = message;
        this.type = type;
        this.timestamp = timestamp;
    }
}

package com.goblinscape;
import lombok.Data;
import lombok.Getter;
import net.runelite.api.coords.WorldPoint;
@Data
public class GoblinScapePlayerData {
    @Getter
    private final String name;
    @Getter
    private final String title;
    @Getter
    private final WorldPoint waypoint;
    @Getter
    private final int world;

    public GoblinScapePlayerData(String name, int x, int y, int plane, String title, int world) {
        this.name = name;
        this.waypoint = new WorldPoint(x, y, plane);
        this.title = title;
        this.world = world;
    }
}

package com.goblinscape;

import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.inject.Provides;
import javax.inject.Inject;
import java.io.IOException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.clan.ClanChannel;
import net.runelite.api.clan.ClanChannelMember;
import net.runelite.api.clan.ClanMember;
import net.runelite.api.clan.ClanSettings;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.api.worldmap.WorldMap;
import net.runelite.api.worldmap.WorldMapData;
import net.runelite.api.ChatMessageType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.SessionOpen;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.worldmap.WorldMapPoint;

import java.util.ArrayList;


@PluginDescriptor(
	name = "Goblin Scape Clan Plugin"
)
@Slf4j
public class GoblinScapePlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	@Getter
	private ClientThread clientThread;

	@Inject
	private GoblinScapeAPI api;

	@Inject
	private GoblinScapeConfig config;

	@Inject
	private ConfigManager configManager;

	@Getter
	@Setter
	private String playerName;

	@Getter
	@Setter
	private int playerWorld;

	@Getter
	@Setter
	private String playerTitle;

	@Getter
	@Setter
	private ArrayList<GoblinScapePlayerData> PlayerData = new ArrayList<>();



	@Getter
	@Setter
	private boolean postError = false;

	@Setter
	private boolean msgError = false;

	@Getter
	@Setter
	private boolean getError = false;
	@Provides
	GoblinScapeConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(GoblinScapeConfig.class);
	}


	@Subscribe
	public void onClanChannelChanged(ClanChannelChanged clanChannel) {
		String clanName = client.getClanChannel().getName();
		clanName = clanName.replace((char)160, ' ');

		if (clanName.equals("Goblin Scape"))
		{
			sendOnlineMembers();
			sendAllMembers();
		}
	}

	@Subscribe
	public void onClanMemberJoined(ClanMemberJoined clanMemberJoin)
	{
		String clanName = client.getClanChannel().getName();
		clanName = clanName.replace((char)160, ' ');

		if (clanName.equals("Goblin Scape"))
		{
			// Delay until after the client updates the member list
			clientThread.invokeLater(this::sendOnlineMembers);
		}
	}

	@Subscribe
	public void onClanMemberLeft(ClanMemberLeft clanMemberLeft)
	{
		String clanName = client.getClanChannel().getName();
		clanName = clanName.replace((char)160, ' ');

		if (clanName.equals("Goblin Scape"))
		{
			// Delay until after the client updates the member list
			clientThread.invokeLater(this::sendOnlineMembers);
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage chatMessage)
	{
		String clanName = client.getClanChannel().getName();
		clanName = clanName.replace((char)160, ' ');
		if (chatMessage.getType() == ChatMessageType.CLAN_MESSAGE && clanName.equals("Goblin Scape"))
		{
			String player = extractUsername(chatMessage.getMessage());
			String type = getType(chatMessage.getMessage());
			String message = chatMessage.getMessage();
			int timestamp = chatMessage.getTimestamp();
			GoblinScapeMessage m = new GoblinScapeMessage(player, message, type, timestamp);
			api.makeMessageRequest(m);
		}
	}
	private ArrayList<String> getOnlineMembers()
	{
		ArrayList<String> onlinePlayers = new ArrayList<>();

		ClanChannel channel = client.getClanChannel();
		if (channel != null)
		{
			for (ClanChannelMember member : channel.getMembers())
			{
				onlinePlayers.add(member.getName());
			}
		}

		return onlinePlayers;
	}


	private void sendOnlineMembers()
	{
		ArrayList<String> onlinePlayers = getOnlineMembers();

		JsonObject payload = new JsonObject();
		JsonArray playersJson = new JsonArray();

		for (String name : onlinePlayers)
		{
			playersJson.add(name);
		}

		payload.add("players", playersJson);

		api.sendOnlinePlayers(payload);
	}

	private ArrayList<JsonObject> getAllMembers()
	{
		ArrayList<JsonObject> membersList = new ArrayList<>();

		ClanSettings settings = client.getClanSettings();
		if (settings != null)
		{
			for (ClanMember member : settings.getMembers())
			{
				JsonObject obj = new JsonObject();
				obj.addProperty("name", member.getName());
				String title = settings.titleForRank(member.getRank()).getName();
				obj.addProperty("title", title);
				membersList.add(obj);
			}
		}

		return membersList;
	}

	private void sendAllMembers()
	{
		ArrayList<JsonObject> members = getAllMembers();

		JsonObject payload = new JsonObject();
		JsonArray membersJson = new JsonArray();

		for (JsonObject memberObj : members)
		{
			membersJson.add(memberObj);
		}

		payload.add("members", membersJson);
		api.sendAllMembers(payload);

	}
	private String extractUsername(String message) {
		String[] patterns = {
				"^(.+?) has reached ",
				"^(.+?) received a new collection log item:",
				"^(.+?) received a drop:",
				"^(.+?) received special loot from a raid:",
				"^(.+?) received a clue item:",
				"^(.+?) has a funny feeling like",
				"^(.+?) feels something weird sneaking",
				"^(.+?) feels like",
				"^(.+?) has achieved a new ",
				"^(.+?) has completed a quest:",
				"^(.+?) has completed the",
				"^(.+?) has unlocked the",
				"^(.+?) has deposited",
				"^(.+?) has withdrawn",
				"^(.+?) has defeated ",
				"^(.+?) has been defeated ",
				"^(.+?) has left the clan",
				"^(.+?) has been invited into the clan"
		};

		for (String regex : patterns) {
			Pattern pattern = Pattern.compile(regex);
			Matcher matcher = pattern.matcher(message);
			if (matcher.find()) {
				return matcher.group(1).trim();
			}
		}

		return null;
	}

	private String getType(String message) {
		if (message.contains("has reached ") && (message.contains("level") || message.contains("XP")))
		{
			return "Level";
		}
		else if (message.contains("received a new collection log item"))
		{
			return "Collection_Log";
		}
		else if (message.contains("received a drop:"))
		{
			return "Loot";
		}
		else if (message.contains("received special loot from a raid:"))
		{
			return "Loot";
		}
		else if (message.contains("received a clue item:"))
		{
			return "Clue";
		}
		else if (message.contains("has a funny feeling like") || message.contains("feels something weird sneaking") || message.contains("acquired something special:"))
		{
			return "Pet";
		}
		else if (message.contains("has completed a quest:"))
		{
			return "Quest";
		}
		else if (message.contains("has completed the") && message.contains("diary"))
		{
			return "Diary";
		}
		else if (message.contains("tier of rewards from Combat Achievements!") || (message.contains("has completed") && message.contains("combat task")))
		{
			return "Combat_Task";
		}
		else if (message.contains("personal best:"))
		{
			return "Personal_Best";
		}
		else if (message.contains("has defeated") || message.contains("has been defeated"))
		{
			return "PK";
		}
		else if (message.contains("into the coffer") || message.contains("from the coffer") || message.contains("has left the clan") || message.contains("has been invited into the clan"))
		{
			return "Clan";
		}
		else {
			return "Other";
		}
	}

	@Subscribe
	public void onGameTick(GameTick tick) {

		if (isValidURL(config.getEndpoint())) {
			String clanName = client.getClanChannel().getName();
			clanName = clanName.replace((char)160, ' ');
			if (wildernessChecker() && clanName.equals("Goblin Scape")) {
			playerTitle = getTitle();
				Player player = client.getLocalPlayer();
				LocalPoint localPoint = player.getLocalLocation();
				WorldPoint worldPoint = WorldPoint.fromLocalInstance(client, localPoint);
			GoblinScapePlayerData p = new GoblinScapePlayerData(playerName, worldPoint.getX(), worldPoint.getY(), worldPoint.getPlane(), playerTitle, playerWorld);
			api.makePostRequest(p);
		       }
			}


		}

public boolean isValidURL(String url)
{
	String regex = "((http|https)://)(www.)?"
			+ "[a-zA-Z0-9@:%._\\-\\+~#?&//=]"
			+ "{2,256}(\\.|\\:)[a-z0-9]"
			+ "{2,6}\\b([-a-zA-Z0-9@:%"
			+ "._\\+~#?&//=]*)";

	Pattern p = Pattern.compile(regex);

	if (url == null) {
		return false;
	}

	Matcher m = p.matcher(url);

	return m.matches();
}
	public String getGetEndpoint()
	{
		return config.getEndpoint();
	}

	public String getPostEndpoint()
	{
		String url = config.getEndpoint();
		//redirect for members that have the old URL in their config
		if (url.contains("goblin-scape-2cb7a2ad634e"))
		{
			url = "https://app.goblinscape.net/api/v1/";
			return url + "post";
		}
		if (url.substring(url.length() - 1).equals("/"))
		{
			return url + "post";
		}
		return url + "/post";
	}

	public String getMessageEndpoint()
	{
		String url = config.getEndpoint();
		//redirect for members that have the old URL in their config
		if (url.contains("goblin-scape-2cb7a2ad634e"))
		{
			url = "https://app.goblinscape.net/api/v1/";
			return url + "message";
		}
		if (url.substring(url.length() - 1).equals("/"))
		{
			return url + "message";
		}
		return url + "/message";
	}

	public String getOnlineEndpoint()
	{
		String url = config.getEndpoint();
		//redirect for members that have the old URL in their config
		if (url.contains("goblin-scape-2cb7a2ad634e"))
		{
			url = "https://app.goblinscape.net/api/v1/";
			return url + "online";
		}
		if (url.substring(url.length() - 1).equals("/"))
		{
			return url + "online";
		}
		return url + "/online";
	}

	public String getMemberEndpoint()
	{
		String url = config.getEndpoint();
		//redirect for members that have the old URL in their config
		if (url.contains("goblin-scape-2cb7a2ad634e"))
		{
			url = "https://app.goblinscape.net/api/v1/";
			return url + "members";
		}
		if (url.substring(url.length() - 1).equals("/"))
		{
			return url + "members";
		}
		return url + "/members";
	}

	public String getUploadModelEndpoint()
	{
		String url = config.getEndpoint();
		//redirect for members that have the old URL in their config
		if (url.contains("goblin-scape-2cb7a2ad634e"))
		{
			url = "https://app.goblinscape.net/api/v1/";
			return url + "members/upload-model";
		}
		if (url.substring(url.length() - 1).equals("/"))
		{
			return url + "members/upload-model";
		}
		return url + "/members/upload-model";
	}
	public String getSharedKey()
	{
		return config.sharedKey();
	}
private String getTitle()
{
	ClanSettings clanSettings = client.getClanSettings();
	if (clanSettings == null) {
		return "";
	}
	ClanMember member = clanSettings.findMember(playerName);
	if (member == null) {
		return "";
	}

	return clanSettings.titleForRank(member.getRank()).getName();
}

	protected void sendPlayerModel()
	{
		if (client.getLocalPlayer() == null)
		{
			log.warn("Local player not found, cannot export model.");
			return;
		}

		Model model = client.getLocalPlayer().getModel();
		if (model == null)
		{
			log.warn("Player model not yet available.");
			return;
		}

		try
		{
			byte[] plyData = ModelExporter.toBytes(client, model);
			api.uploadPlayerModel(client.getLocalPlayer().getName(), plyData);
		}
		catch (Exception e)
		{
			log.error("Error exporting model: " + e.getMessage());
		}
	}

	public boolean wildernessChecker()
	{
		if (config.filterWilderness())
		{
			return true;
		}
		else return client.getVarbitValue(Varbits.IN_WILDERNESS) == 0;
	}

	@Override
	protected void shutDown() throws Exception
	{
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{if (gameStateChanged.getGameState() == GameState.LOGGED_IN) {
		clientThread.invokeLater(() ->
		{
			playerName = client.getLocalPlayer().getName();
			if (playerName == null)
			{
				return false;
			}
			sendPlayerModel();
			playerWorld = client.getWorld();
			return true;
		});
	}

	}


}

/*
 * Copyright (c) 2020 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.goblinscape;

import java.awt.*;

// Originally from RuneLite cache
// Additions made for calculating average of 3 colors
public final class JagexColor
{
    public static final double BRIGHTNESS_MAX = .6;
    public static final double BRIGHTNESS_HIGH = .7;
    public static final double BRIGHTNESS_LOW = .8;
    public static final double BRIGHTNESS_MIN = .9;

    private static final double HUE_OFFSET = (.5 / 64.D);
    private static final double SATURATION_OFFSET = (.5 / 8.D);

    private JagexColor()
    {
    }

    // take 3 Jagex HSL colors and make a single RGB color to represent them
    public static Color HSLtoRGBAvg(int hsl1, int hsl2, int hsl3)
    {
        Color c1 = new Color(HSLtoRGB((short) hsl1, BRIGHTNESS_MIN));
        Color c2 = new Color(HSLtoRGB((short) hsl2, BRIGHTNESS_MIN));
        Color c3 = new Color(HSLtoRGB((short) hsl3, BRIGHTNESS_MIN));

        // compute color average using squares
        // uses squared approach from https://sighack.com/post/averaging-rgb-colors-the-right-way
        int r = c1.getRed()*c1.getRed() + c2.getRed()*c2.getRed() + c3.getRed()*c3.getRed();
        int g = c1.getGreen()*c1.getGreen() + c2.getGreen()*c2.getGreen() + c3.getGreen()*c3.getGreen();
        int b = c1.getBlue()*c1.getBlue() + c2.getBlue()*c2.getBlue() + c3.getBlue()*c3.getBlue();

        r = (int) Math.round(Math.sqrt((double) r / 3.0d));
        g = (int) Math.round(Math.sqrt((double) g / 3.0d));
        b = (int) Math.round(Math.sqrt((double) b / 3.0d));

        return new Color(r, g, b);
    }

    public static short packHSL(int hue, int saturation, int luminance)
    {
        return (short) ((short) (hue & 63) << 10
                | (short) (saturation & 7) << 7
                | (short) (luminance & 127));
    }

    public static int unpackHue(short hsl)
    {
        return hsl >> 10 & 63;
    }

    public static int unpackSaturation(short hsl)
    {
        return hsl >> 7 & 7;
    }

    public static int unpackLuminance(short hsl)
    {
        return hsl & 127;
    }

    public static String formatHSL(short hsl)
    {
        return String.format("%02Xh%Xs%02Xl", unpackHue(hsl), unpackSaturation(hsl), unpackLuminance(hsl));
    }

    public static int HSLtoRGB(short hsl, double brightness)
    {
        double hue = (double) unpackHue(hsl) / 64.D + HUE_OFFSET;
        double saturation = (double) unpackSaturation(hsl) / 8.D + SATURATION_OFFSET;
        double luminance = (double) unpackLuminance(hsl) / 128.D;

        // This is just a standard hsl to rgb transform
        // the only difference is the offsets above and the brightness transform below
        double chroma = (1.D - Math.abs((2.D * luminance) - 1.D)) * saturation;
        double x = chroma * (1 - Math.abs(((hue * 6.D) % 2.D) - 1.D));
        double lightness = luminance - (chroma / 2);

        double r = lightness, g = lightness, b = lightness;
        switch ((int) (hue * 6.D))
        {
            case 0:
                r += chroma;
                g += x;
                break;
            case 1:
                g += chroma;
                r += x;
                break;
            case 2:
                g += chroma;
                b += x;
                break;
            case 3:
                b += chroma;
                g += x;
                break;
            case 4:
                b += chroma;
                r += x;
                break;
            default:
                r += chroma;
                b += x;
                break;
        }

        int rgb = ((int) (r * 256.0D) << 16)
                | ((int) (g * 256.0D) << 8)
                | (int) (b * 256.0D);

        rgb = adjustForBrightness(rgb, brightness);

        if (rgb == 0)
        {
            rgb = 1;
        }
        return rgb;
    }

    public static int adjustForBrightness(int rgb, double brightness)
    {
        double r = (double) (rgb >> 16) / 256.0D;
        double g = (double) (rgb >> 8 & 255) / 256.0D;
        double b = (double) (rgb & 255) / 256.0D;

        r = Math.pow(r, brightness);
        g = Math.pow(g, brightness);
        b = Math.pow(b, brightness);

        return ((int) (r * 256.0D) << 16)
                | ((int) (g * 256.0D) << 8)
                | (int) (b * 256.0D);
    }

    public static int[] createPalette(double brightness)
    {
        int[] colorPalette = new int[65536];
        for (int i = 0; i < colorPalette.length; i++)
        {
            colorPalette[i] = HSLtoRGB((short) i, brightness);
        }
        return colorPalette;
    }
}
/*
 * Copyright (c) 2020, bram91
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.goblinscape;

import lombok.NonNull;
import net.runelite.api.Client;
import net.runelite.api.Model;

import java.awt.Color;
import java.io.PrintWriter;
import java.io.IOException;
import java.io.ByteArrayOutputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

public class ModelExporter {
    private final static int[] colorPalette = JagexColor.createPalette(JagexColor.BRIGHTNESS_MIN);

    public static byte[] toBytes(@NonNull Client client, Model m) throws IOException {
        List<Vertex> vertices = new ArrayList<>();
        for (int fi = 0; fi < m.getFaceCount(); fi++) {
            // determine vertex colors (textured or colored?)
            Color vc1;
            Color vc2;
            Color vc3;
            int textureId = -1;
            if (m.getFaceTextures() != null)
                textureId = m.getFaceTextures()[fi];
            if (textureId != -1) {
                // get average color of texture
                vc1 = TextureColor.getColor(client, textureId);
                vc2 = vc1;
                vc3 = vc1;
            } else {
                if (m.getFaceColors3()[fi] == -1) {
                    // face should be shaded flat
                    int colorIndex = m.getFaceColors1()[fi];
                    int rgbColor = colorPalette[colorIndex];
                    vc1 = vc2 = vc3 = new Color(rgbColor);
                } else {
                    // get color for each vertex
                    vc1 = new Color(JagexColor.HSLtoRGB((short) m.getFaceColors1()[fi], JagexColor.BRIGHTNESS_MIN));
                    vc2 = new Color(JagexColor.HSLtoRGB((short) m.getFaceColors2()[fi], JagexColor.BRIGHTNESS_MIN));
                    vc3 = new Color(JagexColor.HSLtoRGB((short) m.getFaceColors3()[fi], JagexColor.BRIGHTNESS_MIN));
                }
            }

            int vi1 = m.getFaceIndices1()[fi];
            int vi2 = m.getFaceIndices2()[fi];
            int vi3 = m.getFaceIndices3()[fi];

            int vx1 = (int) m.getVerticesX()[vi1];
            int vx2 = (int) m.getVerticesX()[vi2];
            int vx3 = (int) m.getVerticesX()[vi3];
            int vy1 = (int) -m.getVerticesY()[vi1];
            int vy2 = (int) -m.getVerticesY()[vi2];
            int vy3 = (int) -m.getVerticesY()[vi3];
            int vz1 = (int) m.getVerticesZ()[vi1];
            int vz2 = (int) m.getVerticesZ()[vi2];
            int vz3 = (int) m.getVerticesZ()[vi3];

            vertices.add(new Vertex(vx1, vy1, vz1, vc1.getRed(), vc1.getGreen(), vc1.getBlue()));
            vertices.add(new Vertex(vx2, vy2, vz2, vc2.getRed(), vc2.getGreen(), vc2.getBlue()));
            vertices.add(new Vertex(vx3, vy3, vz3, vc3.getRed(), vc3.getGreen(), vc3.getBlue()));
        }

        ByteArrayOutputStream ply = new ByteArrayOutputStream();
        PrintWriter plyHeader = new PrintWriter(ply);
        plyHeader.println("ply");
        plyHeader.println("format binary_little_endian 1.0");
        plyHeader.println("element vertex " + vertices.size());
        plyHeader.println("property int16 x");
        plyHeader.println("property int16 y");
        plyHeader.println("property int16 z");
        plyHeader.println("property uint8 red");
        plyHeader.println("property uint8 green");
        plyHeader.println("property uint8 blue");
        plyHeader.println("element face " + m.getFaceCount());
        plyHeader.println("property list uint8 int16 vertex_indices");
        plyHeader.println("end_header");
        plyHeader.flush();

        ByteArrayOutputStream w = new ByteArrayOutputStream();

        for (Vertex v : vertices) {
            // Y and Z axes are flipped
            w.write(le(v.x));
            w.write(le(v.z));
            w.write(le(v.y));
            w.write((byte) v.r);
            w.write((byte) v.g);
            w.write((byte) v.b);
        }

        for (int i = 0; i < m.getFaceCount(); ++i) {
            int vi = i * 3;
            w.write((byte) 3);
            w.write(le(vi));
            w.write(le(vi + 1));
            w.write(le(vi + 2));
        }

        w.flush();
        ply.write(w.toByteArray());
        return ply.toByteArray();
    }

    // int to little endian byte array
    private static byte[] le(int n) {
        byte[] b = new byte[2];
        b[0] = (byte) n;
        b[1] = (byte) (n >> 8);
        return b;
    }

    private static class Vertex {
        public int x, y, z;
        public int r, g, b;

        public Vertex(int x, int y, int z, int r, int g, int b) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.r = r;
            this.g = g;
            this.b = b;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Vertex vertex = (Vertex) o;
            return x == vertex.x && y == vertex.y && z == vertex.z && r == vertex.r && g == vertex.g && b == vertex.b;
        }

        @Override
        public int hashCode() {
            return Objects.hash(x, y, z, r, g, b);
        }
    }

}
/*
 * Copyright (c) 2020, bram91
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.goblinscape;

import lombok.NonNull;
import net.runelite.api.Client;

import java.awt.Color;
import java.util.HashMap;
import java.util.Map;

public class TextureColor {
    private static final Map<Integer, Color> colorCache = new HashMap<>();

    // get single average color from Jagex texture id
    public static Color getColor(@NonNull Client client, int textureId) {
        if (colorCache.containsKey(textureId))
            return colorCache.get(textureId);

        int[] pixels = client.getTextureProvider().load(textureId);

        int r = 0;
        int g = 0;
        int b = 0;
        int n = 0;
        for (int pixel : pixels) {
            // skip transparent (black)
            if (pixel == 0)
                continue;

            Color c = new Color(pixel);
            r += c.getRed();
            g += c.getGreen();
            b += c.getBlue();
            n++;
        }

        Color c = new Color(r / n, g / n, b / n);
        colorCache.put(textureId, c);
        return c;
    }

}
package com.goblinscape;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class GoblinScapePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(GoblinScapePlugin.class);
		RuneLite.main(args);
	}
}
