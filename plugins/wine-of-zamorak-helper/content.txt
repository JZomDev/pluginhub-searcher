package com.wineofzamorakhelper;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("wineofzamorakhelper")
public interface WineOfZamorakHelperConfig extends Config {
    @ConfigItem(
            keyName = "showWineCounterBox",
            name = "Show Wine Counter",
            description = "Toggle whether the Wine of Zamorak counter box is shown"
    )
    default boolean showWineCounterBox() {
        return true;
    }
}

package com.wineofzamorakhelper;

import net.runelite.api.Tile;
import net.runelite.api.TileItem;

import java.time.Instant;

public class TimedItem {
    private final Tile tile;
    private final TileItem item;
    private final Instant spawnTime;

    public TimedItem(Tile tile, TileItem item, Instant spawnTime) {
        this.tile = tile;
        this.item = item;
        this.spawnTime = spawnTime;
    }

    public Tile getTile() {
        return tile;
    }

    public TileItem getItem() {
        return item;
    }

    public Instant getSpawnTime() {
        return spawnTime;
    }
}


package com.wineofzamorakhelper;

import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.*;

@Singleton
public class TimerOverlay extends Overlay {
    private final Client client;
    private final WineOfZamorakHelperPlugin plugin;

    @Inject
    private TimerOverlay(Client client, WineOfZamorakHelperPlugin plugin) {
        super(plugin);
        this.client = client;
        this.plugin = plugin;

        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!plugin.isMonkOfZamorakNearby()) {
            return null;
        }

        for (TimedItem ti : plugin.getActiveItems()) {
            int remaining = plugin.getRemainingSeconds(ti);
            if (remaining <= 0) {
                continue;
            }

            WorldPoint wp = ti.getTile().getWorldLocation();
            LocalPoint lp = LocalPoint.fromWorld(client, wp);
            if (lp == null) {
                continue;
            }

            String text = remaining + "s";
            Point textLocation = Perspective.getCanvasTextLocation(client, graphics, lp, text, 0);

            if (textLocation != null) {
                OverlayUtil.renderTextLocation(graphics, textLocation, text, Color.YELLOW);
            }
        }

        return null;
    }

}

package com.wineofzamorakhelper;

import com.google.inject.Provides;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;

import javax.inject.Inject;
import java.awt.image.BufferedImage;
import java.time.Duration;
import java.time.Instant;
import java.util.*;

@Slf4j
@PluginDescriptor(name = "Wine of Zamorak Helper")
public class WineOfZamorakHelperPlugin extends Plugin {
    private static final int WINE_OF_ZAMORAK_ITEM_ID = 245;
    private static final int DEFAULT_TIMER_DURATION = 23;
    private static final Set<Integer> MONK_OF_ZAMORAK_NPCS_IDS = Set.of(527, 3484, 8400);

    @Inject
    private Client client;
    @Inject
    private OverlayManager overlayManager;
    @Inject
    private TimerOverlay overlay;
    @Inject
    private ItemManager itemManager;
    @Inject
    private InfoBoxManager infoBoxManager;
    @Inject
    private WineOfZamorakHelperConfig config;

    private WineCounterBox wineCounterBox;

    private Integer measuredRespawnSeconds = null;
    private final Map<Tile, Instant> despawnTimes = new HashMap<>();

    @Getter
    private final List<TimedItem> activeItems = new ArrayList<>();
    private static final Set<NPC> MONKS_OF_ZAMORAK_NPCS = new HashSet<>();

    @Override
    protected void startUp() {
        overlayManager.add(overlay);
    }

    @Override
    protected void shutDown() {
        overlayManager.remove(overlay);
        activeItems.clear();
        despawnTimes.clear();
        MONKS_OF_ZAMORAK_NPCS.clear();

        if (wineCounterBox != null) {
            infoBoxManager.removeInfoBox(wineCounterBox);
            wineCounterBox = null;
        }
    }

    @Provides
    WineOfZamorakHelperConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(WineOfZamorakHelperConfig.class);
    }

    @Subscribe
    public void onNpcSpawned(NpcSpawned event) {
        if (MONK_OF_ZAMORAK_NPCS_IDS.contains(event.getNpc().getId())) {
            MONKS_OF_ZAMORAK_NPCS.add(event.getNpc());
            updateWineCounterBox();
        }
    }

    @Subscribe
    public void onNpcDespawned(NpcDespawned event) {
        if (MONK_OF_ZAMORAK_NPCS_IDS.contains(event.getNpc().getId())) {
            MONKS_OF_ZAMORAK_NPCS.remove(event.getNpc());
            updateWineCounterBox();
        }
    }

    @Subscribe
    public void onItemSpawned(ItemSpawned event) {
        TileItem item = event.getItem();
        if (item.getId() != WINE_OF_ZAMORAK_ITEM_ID || !isMonkOfZamorakNearby()) {
            return;
        }

        activeItems.removeIf(activeItem -> activeItem.getTile().equals(event.getTile()));

        Instant despawnTime = despawnTimes.remove(event.getTile());
        if (despawnTime != null && measuredRespawnSeconds == null) {
            long respawn = Duration.between(despawnTime, Instant.now()).getSeconds();
            measuredRespawnSeconds = (int) respawn;
        }
    }

    @Subscribe
    public void onItemDespawned(ItemDespawned event) {
        TileItem item = event.getItem();
        if (!isMonkOfZamorakNearby() || item.getId() != WINE_OF_ZAMORAK_ITEM_ID) {
            return;
        }


        boolean alreadyExists = activeItems.stream().anyMatch(activeItem -> activeItem.getTile().equals(event.getTile()));
        if (!alreadyExists) {
            activeItems.add(new TimedItem(event.getTile(), item, Instant.now()));
        }

        despawnTimes.put(event.getTile(), Instant.now());
    }

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event) {
        if (event.getContainerId() != InventoryID.INVENTORY.getId()) {
            return;
        }

        updateWineCounterBox();
    }

    @Subscribe
    public void onWorldChanged(WorldChanged event) {
        resetRespawnTimers();
        resetRespawnMeasurement();
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event) {
        switch (event.getGameState()) {
            case HOPPING:
            case LOGIN_SCREEN:
                resetRespawnTimers();
                resetRespawnMeasurement();
                break;
        }
    }

    @Subscribe
    public void onConfigChanged(net.runelite.client.events.ConfigChanged event) {
        if (event.getGroup().equals("wineofzamorakhelper")) {
            updateWineCounterBox();
        }
    }

    public int getRemainingSeconds(TimedItem ti) {
        int duration = measuredRespawnSeconds != null ? measuredRespawnSeconds : DEFAULT_TIMER_DURATION;
        long elapsed = Duration.between(ti.getSpawnTime(), Instant.now()).getSeconds();
        return (int) Math.max(0, duration - elapsed);
    }

    public boolean isMonkOfZamorakNearby() {
        return !MONKS_OF_ZAMORAK_NPCS.isEmpty();
    }

    private void resetRespawnTimers() {
        activeItems.clear();
    }

    private void resetRespawnMeasurement() {
        measuredRespawnSeconds = null;
        despawnTimes.clear();
    }

    private void updateWineCounterBox() {
        if (wineCounterBox != null) {
            infoBoxManager.removeInfoBox(wineCounterBox);
            wineCounterBox = null;
        }

        if (config.showWineCounterBox() && isMonkOfZamorakNearby()) {
            BufferedImage wineImage = itemManager.getImage(WINE_OF_ZAMORAK_ITEM_ID);
            wineCounterBox = new WineCounterBox(client, WINE_OF_ZAMORAK_ITEM_ID, wineImage, this);
            infoBoxManager.addInfoBox(wineCounterBox);
        }
    }
}

package com.wineofzamorakhelper;

import net.runelite.api.Client;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.ui.overlay.infobox.InfoBox;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.Arrays;

public class WineCounterBox extends InfoBox {
    private final Client client;

    private static final int INVENTORY_SIZE = 28;
    private final int itemId;

    public WineCounterBox(Client client, int itemId, BufferedImage image, Plugin plugin) {
        super(image, plugin);
        this.client = client;
        this.itemId = itemId;
    }

    @Override
    public String getText() {
        int count = getWineCount();
        return String.valueOf(count);
    }

    @Override
    public Color getTextColor() {
        int invCount = getInventoryCount();
        return invCount >= INVENTORY_SIZE ? Color.RED : Color.YELLOW;
    }

    private int getWineCount() {
        ItemContainer inv = client.getItemContainer(InventoryID.INVENTORY);
        if (inv == null) {
            return 0;
        }
        return (int) Arrays.stream(inv.getItems())
                .filter(i -> i != null && i.getId() == itemId)
                .mapToLong(Item::getQuantity)
                .sum();
    }

    private int getInventoryCount() {
        ItemContainer inv = client.getItemContainer(InventoryID.INVENTORY);
        if (inv == null) {
            return 0;
        }
        return (int) Arrays.stream(inv.getItems())
                .filter(i -> i != null && i.getId() != -1) // count only real items
                .count();
    }
}

package com.wineofzamorakhelper;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class WineOfZamorakHelperPluginTest {
    public static void main(String[] args) throws Exception {
        ExternalPluginManager.loadBuiltin(WineOfZamorakHelperPlugin.class);
        RuneLite.main(args);
    }
}
