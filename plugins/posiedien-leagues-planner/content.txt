package pathfinder;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

public class TransportJsConverter {
    public static void main(String[] args) throws IOException {
        for (String transport : Files.readAllLines(Paths.get("src/main/resources/transports.txt"))) {
            if (transport.startsWith("#") || transport.isEmpty()) {
                continue;
            }

            transport = transport.split(" \"")[0];
            transport = transport.substring(0, transport.lastIndexOf(" "));
            String[] parts = transport.split(" ");

            String p1 = "new Position(" + parts[0] + ", " + parts[1] + ", " + parts[2] + ")";
            String p2 = "new Position(" + parts[3] + ", " + parts[4] + ", " + parts[5] + ")";
            StringBuilder rest = new StringBuilder();

            for (int i = 6; i < parts.length; i++) {
                rest.append(parts[i]);
                if (i < parts.length - 1) rest.append(" ");
            }

            System.out.println("this.addTransport(" + p1 + ", " + p2 + ", \"" + rest.toString() + "\");");
        }
    }
}

package pathfinder;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Quest;
import net.runelite.api.QuestState;
import net.runelite.api.Skill;
import net.runelite.api.coords.WorldPoint;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import static org.junit.Assert.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import org.mockito.Mock;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.when;
import org.mockito.junit.MockitoJUnitRunner;
import Posiedien_Leagues_Planner.PosiedienLeaguesPlannerPlugin;
import Posiedien_Leagues_Planner.LeaguesPlannerConfig;
import Posiedien_Leagues_Planner.Transport;
import Posiedien_Leagues_Planner.Util;
import Posiedien_Leagues_Planner.pathfinder.Pathfinder;
import Posiedien_Leagues_Planner.pathfinder.PathfinderConfig;
import Posiedien_Leagues_Planner.pathfinder.SplitFlagMap;

@RunWith(MockitoJUnitRunner.class)
public class PathfinderTest {
    private static final SplitFlagMap map = SplitFlagMap.fromResources(null,null);
    private static final Map<WorldPoint, List<Transport>> transports = Transport.loadAllFromResources();
    private static PathfinderConfig pathfinderConfig;

    @Mock
    Client client;

    @Mock
    LeaguesPlannerConfig config;

    @Before
    public void before() {
        when(5/* config.calculationCutoff()*/).thenReturn(30);
    }

    @Test
    public void testAgilityShortcuts() {
        when(config.useAgilityShortcuts()).thenReturn(true);
        when(config.useGrappleShortcuts()).thenReturn(true);
        testPathLength(2, "agility_shortcuts.txt", QuestState.FINISHED, 99);
    }

    @Test
    public void testBoats() {
        when(config.useBoats()).thenReturn(true);
        testPathLength(2, "boats.txt", QuestState.FINISHED);
    }

    @Test
    public void testCanoes() {
        when(config.useCanoes()).thenReturn(true);
        testPathLength(2, "canoes.txt", QuestState.NOT_STARTED, 99);
    }

    @Test
    public void testCharterShips() {
        when(config.useCharterShips()).thenReturn(true);
        testPathLength(2, "charter_ships.txt", QuestState.FINISHED);
    }

    @Test
    public void testShips() {
        when(config.useShips()).thenReturn(true);
        testPathLength(2, "ships.txt", QuestState.FINISHED);
    }

    @Test
    public void testGnomeGliders() {
        when(config.useGnomeGliders()).thenReturn(true);
        testPathLength(2, "gnome_gliders.txt", QuestState.FINISHED);
    }

    @Test
    public void testSpiritTrees() {
        when(config.useSpiritTrees()).thenReturn(true);
        testPathLength(2, "spirit_trees.txt", QuestState.FINISHED);
    }

    private void testPathLength(int expectedLength, String path, QuestState questState) {
        testPathLength(expectedLength, path, questState, -1);
    }

    private void testPathLength(int expectedLength, String path, QuestState questState, int skillLevel) {
        if (skillLevel > -1) {
            setupSkills(skillLevel);
        }
        setupQuests(questState);

        int counter = 0;
        for (int[] startAndTargetCoords : transportCoordinatesFromFile("/" + path)) {
            counter++;
            assertEquals(expectedLength, calculatePathLength(startAndTargetCoords));
        }
        System.out.println(String.format("Completed %d " + path + " path length tests successfully", counter));
    }

    private void setupSkills(int skillLevel) {
        when(client.getBoostedSkillLevel((Skill) any(Object.class))).thenReturn(skillLevel);
    }

    private void setupQuests(QuestState questState) {
        when(client.getGameState()).thenReturn(GameState.LOGGED_IN);
        when(client.getClientThread()).thenReturn(Thread.currentThread());
        pathfinderConfig = spy(new PathfinderConfig(map, transports, client, config));
        doReturn(questState).when(pathfinderConfig).getQuestState((Quest) any(Object.class));
    }

    private int[][] transportCoordinatesFromFile(String path) {
        List<int[]> populateCoords = new ArrayList<>();
        try {
            String s = new String(Util.readAllBytes(PosiedienLeaguesPlannerPlugin.class.getResourceAsStream(path)), StandardCharsets.UTF_8);
            Scanner scanner = new Scanner(s);
            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();
                if (line.startsWith("#") || line.isBlank()) {
                    continue;
                }
                String[] parts = line.split("\t");
                final String DELIM = " ";
                String[] parts_origin = parts[0].split(DELIM);
                String[] parts_destination = parts[1].split(DELIM);
                populateCoords.add(new int[] {
                    Integer.parseInt(parts_origin[0]),
                    Integer.parseInt(parts_origin[1]),
                    Integer.parseInt(parts_origin[2]),
                    Integer.parseInt(parts_destination[0]),
                    Integer.parseInt(parts_destination[1]),
                    Integer.parseInt(parts_destination[2])});
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        return populateCoords.toArray(new int[0][0]);
    }

    private int calculatePathLength(int[] coords) {
        return calculatePathLength(coords[0], coords[1], coords[2], coords[3], coords[4], coords[5]);
    }

    private int calculatePathLength(int startX, int startY, int startZ, int endX, int endY, int endZ) {
        pathfinderConfig.refresh();
        Pathfinder pathfinder = new Pathfinder(
            pathfinderConfig,
            new WorldPoint(startX, startY, startZ),
            new WorldPoint(endX, endY, endZ),
                false);

        pathfinder.run();
        return pathfinder.getPath().size();
    }
}

package pathfinder;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;
import Posiedien_Leagues_Planner.PosiedienLeaguesPlannerPlugin;

public class ShortestPathPluginTest {
    public static void main(String[] args) throws Exception {
        ExternalPluginManager.loadBuiltin(PosiedienLeaguesPlannerPlugin.class);
        RuneLite.main(args);
    }
}

package pathfinder;

import net.runelite.api.coords.WorldPoint;
import org.junit.Assert;
import org.junit.Test;
import Posiedien_Leagues_Planner.PrimitiveIntHashMap;
import Posiedien_Leagues_Planner.Transport;
import Posiedien_Leagues_Planner.WorldPointUtil;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class PrimitiveIntHashMapTests {
    @Test(expected=IllegalArgumentException.class)
    public void checkNullValueProhibited() {
        PrimitiveIntHashMap<Boolean> map = new PrimitiveIntHashMap<>(8);
        map.put(0, null);
    }

    @Test
    public void tryInsertTransports() {
        HashMap<WorldPoint, List<Transport>> transports = Transport.loadAllFromResources();
        PrimitiveIntHashMap<List<Transport>> map = new PrimitiveIntHashMap<>(transports.size());

        for (Map.Entry<WorldPoint, List<Transport>> entry : transports.entrySet()) {
            int packedPoint = WorldPointUtil.packWorldPoint(entry.getKey());
            map.put(packedPoint, entry.getValue());
        }

        for (Map.Entry<WorldPoint, List<Transport>> entry : transports.entrySet()) {
            int packedPoint = WorldPointUtil.packWorldPoint(entry.getKey());
            Assert.assertEquals("World Point " + entry.getKey() + " did not map to the correct value", entry.getValue(), map.get(packedPoint));
        }
    }

    @Test
    public void tryGrowMap() {
        PrimitiveIntHashMap<Integer> map = new PrimitiveIntHashMap<>(8);
        for (int i = 0; i < 1024; ++i) {
            map.put(i, i);
        }

        Assert.assertEquals(1024, map.size());

        for (int i = 0; i < 1024; ++i) {
            Assert.assertEquals(i, map.get(i).intValue());
        }
    }

    @Test
    public void checkNonexistentEntries() {
        PrimitiveIntHashMap<Integer> map = new PrimitiveIntHashMap<>(8);
        Assert.assertNull(map.get(667215));
    }

    @Test
    public void tryOverwriteValues() {
        final int keyStart = 9875643; // Use keys that aren't 0 or all low bits

        PrimitiveIntHashMap<Integer> map = new PrimitiveIntHashMap<>(2048);
        for (int i = 0; i < 1024; ++i) {
            map.put(i + keyStart, i);
        }

        // Overwrite values
        for (int i = 0; i < 1024; ++i) {
            map.put(i + keyStart, i + 1);
        }

        // Now check overwritten values stuck
        for (int i = 0; i < 1024; ++i) {
            Assert.assertEquals(i + 1, map.get(i + keyStart).intValue());
        }
    }

    @Test
    public void checkClearMap() {
        PrimitiveIntHashMap<Integer> map = new PrimitiveIntHashMap<>(8);
        for (int i = 0; i < 1024; ++i) {
            map.put(i, i);
        }

        Assert.assertEquals(1024, map.size());
        Assert.assertEquals(364, map.get(364).intValue());

        map.clear();
        Assert.assertEquals(0, map.size());
        Assert.assertNull(map.get(364));
    }

    @Test
    public void checkInsertOrderIrrelevant() {
        final int keyStart = 9875643; // Use keys that aren't 0 or all low bits
        PrimitiveIntHashMap<Integer> mapForward = new PrimitiveIntHashMap<>(8);
        PrimitiveIntHashMap<Integer> mapReversed = new PrimitiveIntHashMap<>(8);
        for (int i = 0; i < 1024; ++i) {
            mapForward.put(i + keyStart, i);
            mapReversed.put(1023 - i + keyStart, 1023 - i);
        }

        for (int i = 0; i < 1024; ++i) {
            Assert.assertEquals(mapForward.get(i + keyStart), mapReversed.get(i + keyStart));
        }
    }
}

package pathfinder;

import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import org.junit.Assert;
import org.junit.Test;

import java.util.ArrayList;
import java.util.List;

import static Posiedien_Leagues_Planner.WorldPointUtil.distanceBetween;
import static Posiedien_Leagues_Planner.WorldPointUtil.distanceToArea;
import static Posiedien_Leagues_Planner.WorldPointUtil.packWorldPoint;
import static Posiedien_Leagues_Planner.WorldPointUtil.unpackWorldPlane;
import static Posiedien_Leagues_Planner.WorldPointUtil.unpackWorldPoint;
import static Posiedien_Leagues_Planner.WorldPointUtil.unpackWorldX;
import static Posiedien_Leagues_Planner.WorldPointUtil.unpackWorldY;

public class WorldPointTests {
    private static final WorldArea WILDERNESS_ABOVE_GROUND = new WorldArea(2944, 3523, 448, 448, 0);

    @Test
    public void testDistanceToArea() {
        List<WorldPoint> testPoints = new ArrayList<>(10);
        testPoints.add(new WorldPoint(2900, 3500, 0));
        testPoints.add(new WorldPoint(3000, 3500, 0));
        testPoints.add(new WorldPoint(3600, 3500, 0));
        testPoints.add(new WorldPoint(2900, 3622, 0));
        testPoints.add(new WorldPoint(3000, 3622, 0));
        testPoints.add(new WorldPoint(3600, 3622, 0));
        testPoints.add(new WorldPoint(2900, 4300, 0));
        testPoints.add(new WorldPoint(3000, 4300, 0));
        testPoints.add(new WorldPoint(3600, 4300, 0));
        testPoints.add(new WorldPoint(3600, 4200, 1));

        for (WorldPoint point : testPoints) {
            final int areaDistance = WILDERNESS_ABOVE_GROUND.distanceTo(point);
            final int packedPoint = packWorldPoint(point);
            final int worldUtilDistance = distanceToArea(packedPoint, WILDERNESS_ABOVE_GROUND);
            Assert.assertEquals("Calculating distance to " + point + " failed", areaDistance, worldUtilDistance);
        }
    }

    @Test
    public void testWorldPointPacking() {
        WorldPoint point = new WorldPoint(13, 24685, 1);

        final int packedPoint = packWorldPoint(point);
        Assert.assertEquals(0x7036800D, packedPoint); // Manually verified

        final int unpackedX = unpackWorldX(packedPoint);
        Assert.assertEquals(point.getX(), unpackedX);

        final int unpackedY = unpackWorldY(packedPoint);
        Assert.assertEquals(point.getY(), unpackedY);

        final int unpackedPlane = unpackWorldPlane(packedPoint);
        Assert.assertEquals(point.getPlane(), unpackedPlane);

        WorldPoint unpackedPoint = unpackWorldPoint(packedPoint);
        Assert.assertEquals(point, unpackedPoint);
    }

    @Test
    public void testDistanceBetween() {
        WorldPoint pointA = new WorldPoint(13, 24685, 1);
        WorldPoint pointB = new WorldPoint(29241, 3384, 1);
        WorldPoint pointC = new WorldPoint(292, 3384, 0); // Test point on different plane

        Assert.assertEquals(0, distanceBetween(pointA, pointA));
        Assert.assertEquals(29228, distanceBetween(pointA, pointB));
        Assert.assertEquals(29228, distanceBetween(pointB, pointA));
        Assert.assertEquals(21301, distanceBetween(pointA, pointC));

        // with diagonal = 2
        Assert.assertEquals(0, distanceBetween(pointA, pointA, 2));
        Assert.assertEquals(50529, distanceBetween(pointA, pointB, 2));
        Assert.assertEquals(50529, distanceBetween(pointB, pointA, 2));
        Assert.assertEquals(28949, distanceBetween(pointB, pointC, 2));
    }

    @Test
    public void testPackedDistanceBetween() {
        WorldPoint pointA = new WorldPoint(13, 24685, 1);
        WorldPoint pointB = new WorldPoint(29241, 3384, 1);
        WorldPoint pointC = new WorldPoint(292, 3384, 0); // Test point on different plane
        final int packedPointA = packWorldPoint(pointA);
        final int packedPointB = packWorldPoint(pointB);
        final int packedPointC = packWorldPoint(pointC);

        Assert.assertEquals(0, distanceBetween(packedPointA, packedPointA));
        Assert.assertEquals(29228, distanceBetween(packedPointA, packedPointB));
        Assert.assertEquals(29228, distanceBetween(packedPointB, packedPointA));
        Assert.assertEquals(21301, distanceBetween(packedPointA, packedPointC));

        // with diagonal = 2
        Assert.assertEquals(0, distanceBetween(packedPointA, packedPointA, 2));
        Assert.assertEquals(50529, distanceBetween(packedPointA, packedPointB, 2));
        Assert.assertEquals(50529, distanceBetween(packedPointB, packedPointA, 2));
        Assert.assertEquals(28949, distanceBetween(packedPointB, packedPointC, 2));
    }
}

package Posiedien_Leagues_Planner;

import java.awt.Color;
import java.util.Comparator;
import java.util.HashMap;
import java.util.UUID;

import net.runelite.api.coords.WorldPoint;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;
import net.runelite.client.config.Units;
import net.runelite.client.ui.PluginPanel;

@ConfigGroup(PosiedienLeaguesPlannerPlugin.CONFIG_GROUP)
public interface LeaguesPlannerConfig extends Config
{
    public FullRegionData RegionData = new FullRegionData();

    public FullTaskData TaskData = new FullTaskData();

    public FullUserData UserData = new FullUserData();

    @ConfigSection(
            position = 3,
            name = "Region Editor",
            description = "Editor functions",
            closedByDefault = true
    )
    String editorSection = "editorSection";

    @ConfigItem(
            keyName = "GetEditRegion",
            name = "Edit Region Bounds",
            description = "Current region bounds we want to edit",
            section = editorSection
    )
    default RegionType GetEditRegion()
    {
        return RegionType.NONE;
    }

    @ConfigItem(
            keyName = "DebugColorAlpha",
            name = "Debug Color Alpha (0-255)",
            description = "Alpha value for any debug color (value 0-255)",
            section = editorSection
    )
    default int DebugColorAlpha()
    {
        return 40;
    }

    @ConfigItem(
            keyName = "DebugColorDisabledAlpha",
            name = "Debug Color Disabled Alpha (0-255)",
            description = "Alpha value for disabled debug color (value 0-255)",
            section = editorSection
    )
    default int DebugColorDisabledAlpha()
    {
        return 255;
    }

    @ConfigSection(
            position = 2,
            name = "Region Plugin Colors",
            description = "The colors to use for our regions",
            closedByDefault = true
    )
    String regionColors = "regionColors";

    @ConfigItem(
            keyName = "MisthalinColor",
            name = "Misthalin Color",
            description = "The color for the region",
            section = regionColors
    )
    default Color MisthalinColor()
    {
        return new Color(255, 2, 2, DebugColorAlpha());
    }

    @ConfigItem(
            keyName = "KaramjaColor",
            name = "Karamja Color",
            description = "The color for the region",
            section = regionColors
    )
    default Color KaramjaColor()
    {
        return new Color(46, 108, 23, DebugColorAlpha());
    }

    @ConfigItem(
            keyName = "KandarinColor",
            name = "Kandarin Color",
            description = "The color for the region",
            section = regionColors
    )
    default Color KandarinColor()
    {
        return new Color(231, 143, 10, DebugColorAlpha());
    }

    @ConfigItem(
            keyName = "AsgarniaColor",
            name = "Asgarnia Color",
            description = "The color for the region",
            section = regionColors
    )
    default Color AsgarniaColor()
    {
        return new Color(46, 59, 234, DebugColorAlpha());
    }

    @ConfigItem(
            keyName = "FremennikColor",
            name = "Fremennik Color",
            description = "The color for the region",
            section = regionColors
    )
    default Color FremennikColor()
    {
        return new Color(121, 67, 3, DebugColorAlpha());
    }

    @ConfigItem(
            keyName = "KourendColor",
            name = "Kourend Color",
            description = "The color for the region",
            section = regionColors
    )
    default Color KourendColor()
    {
        return new Color(31, 224, 179, DebugColorAlpha());
    }

    @ConfigItem(
            keyName = "WildernessColor",
            name = "Wilderness Color",
            description = "The color for the region",
            section = regionColors
    )
    default Color WildernessColor()
    {
        return new Color(94, 14, 14, DebugColorAlpha());
    }

    @ConfigItem(
            keyName = "MorytaniaColor",
            name = "Morytania Color",
            description = "The color for the region",
            section = regionColors
    )
    default Color MorytaniaColor()
    {
        return new Color(102, 3, 114, DebugColorAlpha());
    }

    @ConfigItem(
            keyName = "TirannwnColor",
            name = "Tirannwn Color",
            description = "The color for the region",
            section = regionColors
    )
    default Color TirannwnColor()
    {
        return new Color(130, 255, 105, DebugColorAlpha());
    }

    @ConfigItem(
            keyName = "DesertColor",
            name = "Desert Color",
            description = "The color for the region",
            section = regionColors
    )
    default Color DesertColor()
    {
        return new Color(255, 226, 1, DebugColorAlpha());
    }


    @ConfigSection(
            position = 1,
            name = "Regions Unlocked",
            description = "The regions we currently have unlocked"
    )
    String regionUnlock = "regionUnlock";

    @ConfigItem(
            keyName = "FilteredDifficulty",
            name = "Filter Difficulty",
            description = "Task Difficulty Filter",
            section = regionUnlock
    )
    default TaskDifficulty FilteredDifficulty()
    {
        return TaskDifficulty.NONE;
    }

    @ConfigItem(
            keyName = "FilteredRequirements",
            name = "Filter Requirements",
            description = "Task Requirements Filter",
            section = regionUnlock
    )
    default FilterRequirements FilteredRequirements()
    {
        return FilterRequirements.NONE;
    }

    @ConfigItem(
            keyName = "FilteredOther",
            name = "Filter Other",
            description = "Task Other Filter",
            section = regionUnlock
    )
    default OtherFilter FilteredOther()
    {
        return OtherFilter.NONE;
    }

    @ConfigItem(
            keyName = "TaskSort",
            name = "Task Sort",
            description = "Task Sort",
            section = regionUnlock
    )
    default TaskSortMethod TaskSort()
    {
        return TaskSortMethod.DIFFICULTY;
    }

    @ConfigItem(
            keyName = "MisthalinUnlocked",
            name = "Misthalin Unlocked",
            description = "Whether or not Misthalin is unlocked",
            section = regionUnlock
    )
    default boolean MisthalinUnlocked()
    {
        return true;
    }

    @ConfigItem(
            keyName = "KaramjaUnlocked",
            name = "Karamja Unlocked",
            description = "Whether or not Karamja is unlocked",
            section = regionUnlock
    )
    default boolean KaramjaUnlocked()
    {
        return true;
    }

    @ConfigItem(
            keyName = "KandarinUnlocked",
            name = "Kandarin Unlocked",
            description = "Whether or not Kandarin is unlocked",
            section = regionUnlock
    )
    default boolean KandarinUnlocked()
    {
        return false;
    }

    @ConfigItem(
            keyName = "AsgarniaUnlocked",
            name = "Asgarnia Unlocked",
            description = "Whether or not Asgarnia is unlocked",
            section = regionUnlock
    )
    default boolean AsgarniaUnlocked()
    {
        return false;
    }

    @ConfigItem(
            keyName = "FremennikUnlocked",
            name = "Fremennik Unlocked",
            description = "Whether or not Fremennik is unlocked",
            section = regionUnlock
    )
    default boolean FremennikUnlocked()
    {
        return false;
    }

    @ConfigItem(
            keyName = "KourendUnlocked",
            name = "Kourend Unlocked",
            description = "Whether or not Kourend is unlocked",
            section = regionUnlock
    )
    default boolean KourendUnlocked()
    {
        return false;
    }

    @ConfigItem(
            keyName = "WildernessUnlocked",
            name = "Wilderness Unlocked",
            description = "Whether or not Wilderness is unlocked",
            section = regionUnlock
    )
    default boolean WildernessUnlocked()
    {
        return false;
    }

    @ConfigItem(
            keyName = "MorytaniaUnlocked",
            name = "Morytania Unlocked",
            description = "Whether or not Morytania is unlocked",
            section = regionUnlock
    )
    default boolean MorytaniaUnlocked()
    {
        return false;
    }

    @ConfigItem(
            keyName = "TirannwnUnlocked",
            name = "Tirannwn Unlocked",
            description = "Whether or not Tirannwn is unlocked",
            section = regionUnlock
    )
    default boolean TirannwnUnlocked()
    {
        return false;
    }

    @ConfigItem(
            keyName = "DesertUnlocked",
            name = "Desert Unlocked",
            description = "Whether or not Desert is unlocked",
            section = regionUnlock
    )
    default boolean DesertUnlocked()
    {
        return false;
    }

    @ConfigSection(
            position = 4,
            name = "Leagues Planner Settings",
            description = "Settings relating to the leagues planner plugin",
            closedByDefault = true
    )
    String leaguesPlannerSection = "leaguesPlannerSection";

    @ConfigItem(
            keyName = "TaskMapStackingDistance",
            name = "Task Map Stacking Distance",
            description = "The maximum distance between tasks to start stacking in the map interface (in pixels)",
            section = leaguesPlannerSection
    )
    default int TaskMapStackingDistance()
    {
        return 50;
    }

    @ConfigItem(
            keyName = "TaskMapIconSize",
            name = "Task map icon size",
            description = "Task map icon size (in pixels)",
            section = leaguesPlannerSection
    )
    default int TaskMapIconSize()
    {
        return 30;
    }

    @ConfigItem(
            keyName = "ScaleTaskMapIconBasedOnCount",
            name = "Scale Task Map Icon Based On Count",
            description = "Whether or not Scale Task Map Icon Based On Count",
            section = leaguesPlannerSection
    )
    default boolean ScaleTaskMapIconBasedOnCount()
    {
        return true;
    }

    @ConfigItem(
            keyName = "ScaleTaskMapIconBasedOnCountInvRate",
            name = "Scale Task Map Icon Based On Count, inverse rate",
            description = "Inverse rate on our scaling map icon based on count",
            section = leaguesPlannerSection
    )
    default int ScaleTaskMapIconBasedOnCountInvRate()
    {
        return 10;
    }

    @ConfigSection(
        name = "Pathfinding Settings",
        description = "Options for the pathfinding",
        position = 5,
            closedByDefault = true
    )
    String sectionSettings = "sectionSettings";

    @ConfigItem(
        keyName = "avoidWilderness",
        name = "Avoid wilderness",
        description = "Whether the wilderness should be avoided if possible<br>" +
            "(otherwise, will e.g. suggest using wilderness lever to travel from Edgeville to Ardougne)",
        position = 1,
        section = sectionSettings
    )
    default boolean avoidWilderness() {
        return true;
    }

    @ConfigItem(
        keyName = "useAgilityShortcuts",
        name = "Use agility shortcuts",
        description = "Whether to include agility shortcuts in the path.<br>You must also have the required agility level",
        position = 2,
        section = sectionSettings
    )
    default boolean useAgilityShortcuts() {
        return true;
    }

    @ConfigItem(
        keyName = "useGrappleShortcuts",
        name = "Use grapple shortcuts",
        description = "Whether to include crossbow grapple agility shortcuts in the path.<br>" +
            "You must also have the required agility, ranged and strength levels",
        position = 3,
        section = sectionSettings
    )
    default boolean useGrappleShortcuts() {
        return false;
    }

    @ConfigItem(
        keyName = "useBoats",
        name = "Use boats",
        description = "Whether to include small boats in the path<br>(e.g. the boat to Fishing Platform)",
        position = 4,
        section = sectionSettings
    )
    default boolean useBoats() {
        return true;
    }

    @ConfigItem(
        keyName = "useCanoes",
        name = "Use canoes",
        description = "Whether to include canoes in the path",
        position = 5,
        section = sectionSettings
    )
    default boolean useCanoes() {
        return false;
    }

    @ConfigItem(
        keyName = "useCharterShips",
        name = "Use charter ships",
        description = "Whether to include charter ships in the path",
        position = 6,
        section = sectionSettings
    )
    default boolean useCharterShips() {
        return false;
    }

    @ConfigItem(
        keyName = "useShips",
        name = "Use ships",
        description = "Whether to include passenger ships in the path<br>(e.g. the customs ships to Karamja)",
        position = 7,
        section = sectionSettings
    )
    default boolean useShips() {
        return true;
    }

    @ConfigItem(
        keyName = "useFairyRings",
        name = "Use fairy rings",
        description = "Whether to include fairy rings in the path.<br>" +
            "You must also have completed the required quests or miniquests",
        position = 8,
        section = sectionSettings
    )
    default boolean useFairyRings() {
        return true;
    }

    @ConfigItem(
        keyName = "useGnomeGliders",
        name = "Use gnome gliders",
        description = "Whether to include gnome gliders in the path",
        position = 9,
        section = sectionSettings
    )
    default boolean useGnomeGliders() {
        return true;
    }

    @ConfigItem(
        keyName = "useSpiritTrees",
        name = "Use spirit trees",
        description = "Whether to include spirit trees in the path",
        position = 10,
        section = sectionSettings
    )
    default boolean useSpiritTrees() {
        return true;
    }

    @ConfigItem(
        keyName = "useTeleportationLevers",
        name = "Use teleportation levers",
        description = "Whether to include teleportation levers in the path<br>(e.g. the lever from Edgeville to Wilderness)",
        position = 11,
        section = sectionSettings
    )
    default boolean useTeleportationLevers() {
        return true;
    }

    @ConfigItem(
        keyName = "useTeleportationPortals",
        name = "Use teleportation portals",
        description = "Whether to include teleportation portals in the path<br>(e.g. the portal from Ferox Enclave to Castle Wars)",
        position = 12,
        section = sectionSettings
    )
    default boolean useTeleportationPortals() {
        return true;
    }

    @ConfigItem(
        keyName = "cancelInstead",
        name = "Cancel instead of recalculating",
        description = "Whether the path should be cancelled rather than recalculated when the recalculate distance limit is exceeded",
        position = 13,
        section = sectionSettings
    )
    default boolean cancelInstead() {
        return false;
    }

    @Range(
        min = -1,
        max = 20000
    )
    @ConfigItem(
        keyName = "recalculateDistance",
        name = "Recalculate distance",
        description = "Distance from the path the player should be for it to be recalculated (-1 for never)",
        position = 14,
        section = sectionSettings
    )
    default int recalculateDistance() {
        return 10;
    }

    @Range(
        min = -1,
        max = 50
    )
    @ConfigItem(
        keyName = "finishDistance",
        name = "Finish distance",
        description = "Distance from the target tile at which the path should be ended (-1 for never)",
        position = 15,
        section = sectionSettings
    )
    default int reachedDistance() {
        return 5;
    }

    @ConfigItem(
        keyName = "showTileCounter",
        name = "Show tile counter",
        description = "Whether to display the number of tiles travelled, number of tiles remaining or disable counting",
        position = 16,
        section = sectionSettings
    )
    default TileCounter showTileCounter() {
        return TileCounter.DISABLED;
    }

    @ConfigItem(
        keyName = "tileCounterStep",
        name = "Tile counter step",
        description = "The number of tiles between the displayed tile counter numbers",
        position = 17,
        section = sectionSettings
    )
    default int tileCounterStep()
    {
        return 1;
    }

    /*@Units(
        value = Units.TICKS
    )
    @Range(
        min = 1,
        max = 30
    )
    @ConfigItem(
        keyName = "calculationCutoff",
        name = "Calculation cutoff",
        description = "The cutoff threshold in number of ticks (0.6 seconds) of no progress being<br>" +
            "made towards the path target before the calculation will be stopped",
        position = 18,
        section = sectionSettings
    )
    default int calculationCutoff()
    {
        return 5;
    }*/

    @ConfigSection(
        name = "Pathfinding Display",
        description = "Options for displaying the path on the world map, minimap and scene tiles",
        position = 19,
            closedByDefault = true
    )
    String sectionDisplay = "sectionDisplay";

    @ConfigItem(
        keyName = "drawMap",
        name = "Draw path on world map",
        description = "Whether the path should be drawn on the world map",
        position = 20,
        section = sectionDisplay
    )
    default boolean drawMap() {
        return true;
    }

    @ConfigItem(
        keyName = "drawMinimap",
        name = "Draw path on minimap",
        description = "Whether the path should be drawn on the minimap",
        position = 21,
        section = sectionDisplay
    )
    default boolean drawMinimap() {
        return true;
    }

    @ConfigItem(
        keyName = "drawTiles",
        name = "Draw path on tiles",
        description = "Whether the path should be drawn on the game tiles",
        position = 22,
        section = sectionDisplay
    )
    default boolean drawTiles() {
        return true;
    }

    @ConfigItem(
        keyName = "pathStyle",
        name = "Path style",
        description = "Whether to display the path as tiles or a segmented line",
        position = 23,
        section = sectionDisplay
    )
    default TileStyle pathStyle() {
        return TileStyle.TILES;
    }

    @ConfigSection(
        name = "Pathfinding Colors",
        description = "Colors for the path map, minimap and scene tiles",
        position = 24,
            closedByDefault = true
    )
    String sectionColours = "sectionColours";

    @Alpha
    @ConfigItem(
        keyName = "colourPath",
        name = "Path",
        description = "Colour of the path tiles on the world map, minimap and in the game scene",
        position = 25,
        section = sectionColours
    )
    default Color colourPath() {
        return new Color(255, 0, 0);
    }

    @Alpha
    @ConfigItem(
        keyName = "colourPathCalculating",
        name = "Calculating",
        description = "Colour of the path tiles while the pathfinding calculation is in progress",
        position = 26,
        section = sectionColours
    )
    default Color colourPathCalculating() {
        return new Color(0, 0, 255);
    }

    @Alpha
    @ConfigItem(
        keyName = "colourTransports",
        name = "Transports",
        description = "Colour of the transport tiles",
        position = 27,
        section = sectionColours
    )
    default Color colourTransports() {
        return new Color(0, 255, 0, 128);
    }

    @Alpha
    @ConfigItem(
        keyName = "colourCollisionMap",
        name = "Collision map",
        description = "Colour of the collision map tiles",
        position = 28,
        section = sectionColours
    )
    default Color colourCollisionMap() {
        return new Color(0, 128, 255, 128);
    }

    @Alpha
    @ConfigItem(
        keyName = "colourText",
        name = "Text",
        description = "Colour of the text of the tile counter and fairy ring codes",
        position = 29,
        section = sectionColours
    )
    default Color colourText() {
        return Color.WHITE;
    }

    @ConfigSection(
        name = "Pathfinding Debug Options",
        description = "Various options for debugging",
        position = 30,
        closedByDefault = true
    )
    String sectionDebug = "sectionDebug";

    @ConfigItem(
        keyName = "drawTransports",
        name = "Draw transports",
        description = "Whether transports should be drawn",
        position = 31,
        section = sectionDebug
    )
    default boolean drawTransports() {
        return false;
    }

    @ConfigItem(
        keyName = "drawCollisionMap",
        name = "Draw collision map",
        description = "Whether the collision map should be drawn",
        position = 32,
        section = sectionDebug
    )
    default boolean drawCollisionMap() {
        return false;
    }

    @ConfigItem(
        keyName = "drawDebugPanel",
        name = "Show debug panel",
        description = "Toggles displaying the pathfinding debug stats panel",
        position = 33,
        section = sectionDebug
    )
    default boolean drawDebugPanel() {
        return false;
    }

}

package Posiedien_Leagues_Planner;

import Posiedien_Leagues_Planner.pathfinder.PathfinderConfig;
import Posiedien_Leagues_Planner.pathfinder.SplitFlagMap;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.NavigationButton;

import java.awt.*;
import java.util.List;
import java.util.Map;

public class PluginInitializer implements Runnable
{
    PosiedienLeaguesPlannerPlugin plugin;
    PluginInitializer(PosiedienLeaguesPlannerPlugin InPlugin)
    {
        plugin = InPlugin;
    }
    @Override
    public void run()
    {
        plugin.InitializeFromOtherThread();
    }
}

package Posiedien_Leagues_Planner;

import com.google.inject.Inject;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.util.Arrays;
import java.util.List;
import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.widgets.WidgetID;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.JagexColors;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;

public class PathMapTooltipOverlay extends Overlay {
    private static final int TOOLTIP_OFFSET_HEIGHT = 25;
    private static final int TOOLTIP_OFFSET_WIDTH = 15;
    private static final int TOOLTIP_PADDING_HEIGHT = 1;
    private static final int TOOLTIP_PADDING_WIDTH = 2;
    private static final int TOOLTIP_TEXT_OFFSET_HEIGHT = -2;

    private final Client client;
    private final PosiedienLeaguesPlannerPlugin plugin;
    private final LeaguesPlannerConfig config;

    @Inject
    private PathMapTooltipOverlay(Client client, PosiedienLeaguesPlannerPlugin plugin, LeaguesPlannerConfig config) {
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(OverlayPriority.LOW);
        setLayer(OverlayLayer.MANUAL);
        drawAfterInterface(WidgetID.WORLD_MAP_GROUP_ID);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (plugin.bIsInitializing)
        {
            return null;
        }

        if (!config.drawMap() || client.getWidget(WidgetInfo.WORLD_MAP_VIEW) == null) {
            return null;
        }

        if (plugin.getPathfinder() != null) {
            List<WorldPoint> path = plugin.getPathfinder().getPath();
            Point cursorPos = client.getMouseCanvasPosition();
            for (int i = 0; i < path.size(); i++) {
                if (drawTooltip(graphics, cursorPos, path.get(i), i + 1)) {
                    return null;
                }
            }
        }

        return null;
    }

    private boolean drawTooltip(Graphics2D graphics, Point cursorPos, WorldPoint point, int n) {
        Point start = plugin.mapWorldPointToGraphicsPoint(point);
        Point end = plugin.mapWorldPointToGraphicsPoint(point.dx(1).dy(-1));

        if (start == null || end == null) {
            return false;
        }

        int width = end.getX() - start.getX();

        if (cursorPos.getX() < (start.getX() - width / 2) || cursorPos.getX() > (end.getX() - width / 2) ||
            cursorPos.getY() < (start.getY() - width / 2) || cursorPos.getY() > (end.getY() - width / 2)) {
            return false;
        }

        List<String> rows = Arrays.asList("Shortest path:", "Step " + n + " of " + plugin.getPathfinder().getPath().size());

        graphics.setFont(FontManager.getRunescapeFont());
        FontMetrics fm = graphics.getFontMetrics();
        int tooltipHeight = fm.getHeight();
        int tooltipWidth = rows.stream().map(fm::stringWidth).max(Integer::compareTo).get();

        int clippedHeight = tooltipHeight + TOOLTIP_PADDING_HEIGHT * 2;
        int clippedWidth = tooltipWidth + TOOLTIP_PADDING_WIDTH * 2;

        Rectangle worldMapBounds = client.getWidget(WidgetInfo.WORLD_MAP_VIEW).getBounds();
        int worldMapRightBoundary = worldMapBounds.width + worldMapBounds.x;
        int worldMapBottomBoundary = worldMapBounds.height + worldMapBounds.y;

        int drawPointX = start.getX() + TOOLTIP_OFFSET_WIDTH;
        int drawPointY = start.getY();
        if (drawPointX + clippedWidth > worldMapRightBoundary) {
            drawPointX = worldMapRightBoundary - clippedWidth;
        }
        if (drawPointY + clippedHeight > worldMapBottomBoundary) {
            drawPointY = start.getY() - TOOLTIP_OFFSET_HEIGHT * 2 - tooltipHeight;
        }
        drawPointY += TOOLTIP_OFFSET_HEIGHT;

        Rectangle tooltipRect = new Rectangle(
            drawPointX - TOOLTIP_PADDING_WIDTH,
            drawPointY - TOOLTIP_PADDING_HEIGHT,
            tooltipWidth + TOOLTIP_PADDING_WIDTH * 2,
            tooltipHeight * rows.size() + TOOLTIP_PADDING_HEIGHT * 2);

        graphics.setColor(JagexColors.TOOLTIP_BACKGROUND);
        graphics.fillRect(tooltipRect.x, tooltipRect.y, tooltipRect.width, tooltipRect.height);

        graphics.setColor(JagexColors.TOOLTIP_BORDER);
        graphics.drawRect(tooltipRect.x, tooltipRect.y, tooltipRect.width, tooltipRect.height);

        graphics.setColor(JagexColors.TOOLTIP_TEXT);
        for (int i = 0; i < rows.size(); i++) {
            graphics.drawString(rows.get(i), drawPointX, drawPointY + TOOLTIP_TEXT_OFFSET_HEIGHT + (i + 1) * tooltipHeight);
        }

        return true;
    }
}

package Posiedien_Leagues_Planner;

import com.google.common.base.Strings;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import lombok.Getter;
import net.runelite.api.Quest;
import net.runelite.api.Skill;
import net.runelite.api.coords.WorldPoint;

/**
 * This class represents a travel point between two WorldPoints.
 */
public class Transport {
    /** The locations of the fairy rings */
    @Getter
    private static final List<WorldPoint> fairyRings = new ArrayList<>();

    /** The codes of the fairy rings */
    @Getter
    private static final List<String> fairyRingCodes = new ArrayList<>();

    /** The starting point of this transport */
    @Getter
    private final WorldPoint origin;

    /** The ending point of this transport */
    @Getter
    private final WorldPoint destination;

    /** The skill levels required to use this transport */
    private final int[] skillLevels = new int[Skill.values().length];

    /** The quests required to use this transport */
    @Getter
    private List<Quest> quests = new ArrayList<>();

    /** Whether the transport is an agility shortcut */
    @Getter
    private boolean isAgilityShortcut;

    /** Whether the transport is a crossbow grapple shortcut */
    @Getter
    private boolean isGrappleShortcut;

    /** Whether the transport is a boat */
    @Getter
    private boolean isBoat;

    /** Whether the transport is a canoe */
    @Getter
    private boolean isCanoe;

    /** Whether the transport is a charter ship */
    @Getter
    private boolean isCharterShip;

    /** Whether the transport is a ship */
    @Getter
    private boolean isShip;

    /** Whether the transport is a fairy ring */
    @Getter
    private boolean isFairyRing;

    /** Whether the transport is a gnome glider */
    @Getter
    private boolean isGnomeGlider;

    /** Whether the transport is a spirit tree */
    @Getter
    private boolean isSpiritTree;

    /** Whether the transport is a teleportation lever */
    @Getter
    private boolean isTeleportationLever;

    /** Whether the transport is a teleportation portal */
    @Getter
    private boolean isTeleportationPortal;

    /** The additional travel time */
    @Getter
    private int wait;

    Transport(final WorldPoint origin, final WorldPoint destination) {
        this.origin = origin;
        this.destination = destination;
    }

    Transport(final String line, TransportType transportType) {
        final String DELIM = " ";

        String[] parts = line.split("\t");

        String[] parts_origin = parts[0].split(DELIM);
        String[] parts_destination = parts[1].split(DELIM);

        origin = new WorldPoint(
            Integer.parseInt(parts_origin[0]),
            Integer.parseInt(parts_origin[1]),
            Integer.parseInt(parts_origin[2]));
        destination = new WorldPoint(
            Integer.parseInt(parts_destination[0]),
            Integer.parseInt(parts_destination[1]),
            Integer.parseInt(parts_destination[2]));

        // Skill requirements
        if (parts.length >= 4 && !parts[3].isEmpty()) {
            String[] skillRequirements = parts[3].split(";");

            for (String requirement : skillRequirements) {
                String[] levelAndSkill = requirement.split(DELIM);

                int level = Integer.parseInt(levelAndSkill[0]);
                String skillName = levelAndSkill[1];

                Skill[] skills = Skill.values();
                for (int i = 0; i < skills.length; i++) {
                    if (skills[i].getName().equals(skillName)) {
                        skillLevels[i] = level;
                        break;
                    }
                }
            }
        }

        // Quest requirements
        if (parts.length >= 6 && !parts[5].isEmpty()) {
            this.quests = findQuests(parts[5]);
        }

        // Additional travel time
        if (parts.length >= 7 && !parts[6].isEmpty()) {
            this.wait = Integer.parseInt(parts[6]);
        }

        isAgilityShortcut = TransportType.AGILITY_SHORTCUT.equals(transportType);
        isGrappleShortcut = isAgilityShortcut && (getRequiredLevel(Skill.RANGED) > 1 || getRequiredLevel(Skill.STRENGTH) > 1);
        isBoat = TransportType.BOAT.equals(transportType);
        isCanoe = TransportType.CANOE.equals(transportType);
        isCharterShip = TransportType.CHARTER_SHIP.equals(transportType);
        isShip = TransportType.SHIP.equals(transportType);
        isGnomeGlider = TransportType.GNOME_GLIDER.equals(transportType);
        isSpiritTree = TransportType.SPIRIT_TREE.equals(transportType);
        isTeleportationLever = TransportType.TELEPORTATION_LEVER.equals(transportType);
        isTeleportationPortal = TransportType.TELEPORTATION_PORTAL.equals(transportType);
    }

    /** The skill level required to use this transport */
    public int getRequiredLevel(Skill skill) {
        return skillLevels[skill.ordinal()];
    }

    /** Whether the transport has one or more quest requirements */
    public boolean isQuestLocked() {
        return !quests.isEmpty();
    }

    private static List<Quest> findQuests(String questNamesCombined) {
        String[] questNames = questNamesCombined.split(";");
        List<Quest> quests = new ArrayList<>();
        for (String questName : questNames) {
            for (Quest quest : Quest.values()) {
                if (quest.getName().equals(questName)) {
                    quests.add(quest);
                    break;
                }
            }
        }
        return quests;
    }

    private static void addTransports(Map<WorldPoint, List<Transport>> transports, String path, TransportType transportType) {
        try {
            String s = new String(Util.readAllBytes(PosiedienLeaguesPlannerPlugin.class.getResourceAsStream(path)), StandardCharsets.UTF_8);
            Scanner scanner = new Scanner(s);
            List<String> fairyRingsQuestNames = new ArrayList<>();
            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();

                if (line.startsWith("#") || line.isBlank()) {
                    continue;
                }

                if (TransportType.FAIRY_RING.equals(transportType)) {
                    String[] p = line.split("\t");
                    fairyRings.add(new WorldPoint(Integer.parseInt(p[0]), Integer.parseInt(p[1]), Integer.parseInt(p[2])));
                    fairyRingCodes.add(p.length >= 4 ? p[3].replaceAll("_", " ") : null);
                    fairyRingsQuestNames.add(p.length >= 7 ? p[6] : "");
                } else {
                    Transport transport = new Transport(line, transportType);
                    WorldPoint origin = transport.getOrigin();
                    transports.computeIfAbsent(origin, k -> new ArrayList<>()).add(transport);
                }
            }
            if (TransportType.FAIRY_RING.equals(transportType)) {
                for (WorldPoint origin : fairyRings) {
                    for (int i = 0; i < fairyRings.size(); i++) {
                        WorldPoint destination = fairyRings.get(i);
                        String questName = fairyRingsQuestNames.get(i);
                        if (origin.equals(destination)) {
                            continue;
                        }
                        Transport transport = new Transport(origin, destination);
                        transport.isFairyRing = true;
                        transport.wait = 5;
                        transports.computeIfAbsent(origin, k -> new ArrayList<>()).add(transport);
                        if (!Strings.isNullOrEmpty(questName)) {
                            transport.quests = findQuests(questName);
                        }
                    }
                }
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public static HashMap<WorldPoint, List<Transport>> loadAllFromResources() {
        HashMap<WorldPoint, List<Transport>> transports = new HashMap<>();
        fairyRings.clear();
        fairyRingCodes.clear();

        addTransports(transports, "/transports.txt", TransportType.TRANSPORT);
        addTransports(transports, "/agility_shortcuts.txt", TransportType.AGILITY_SHORTCUT);
        addTransports(transports, "/boats.txt", TransportType.BOAT);
        addTransports(transports, "/canoes.txt", TransportType.CANOE);
        addTransports(transports, "/charter_ships.txt", TransportType.CHARTER_SHIP);
        addTransports(transports, "/ships.txt", TransportType.SHIP);
        addTransports(transports, "/fairy_rings.txt", TransportType.FAIRY_RING);
        addTransports(transports, "/gnome_gliders.txt", TransportType.GNOME_GLIDER);
        addTransports(transports, "/spirit_trees.txt", TransportType.SPIRIT_TREE);
        addTransports(transports, "/levers.txt", TransportType.TELEPORTATION_LEVER);
        addTransports(transports, "/portals.txt", TransportType.TELEPORTATION_PORTAL);

        return transports;
    }

    private enum TransportType {
        TRANSPORT,
        AGILITY_SHORTCUT,
        BOAT,
        CANOE,
        CHARTER_SHIP,
        SHIP,
        FAIRY_RING,
        GNOME_GLIDER,
        SPIRIT_TREE,
        TELEPORTATION_LEVER,
        TELEPORTATION_PORTAL
    }
}

package Posiedien_Leagues_Planner;

import Posiedien_Leagues_Planner.pathfinder.Pathfinder;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.Point;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.api.worldmap.WorldMap;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.worldmap.WorldMapOverlay;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import javax.swing.plaf.FontUIResource;
import java.awt.*;
import java.awt.geom.Area;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.util.*;

public class TaskOverlay extends Overlay
{
    private final Client client;
    private final PosiedienLeaguesPlannerPlugin plugin;
    private final LeaguesPlannerConfig config;

    public WorldMapOverlay worldMapOverlay;

    private Area WorldMapClipArea;

    HashMap<UUID, TaskDisplayPoint> CachedTaskDisplayPoints = new HashMap<>();
    HashMap<UUID, HashSet<UUID> > TaskToDisplayPoints = new HashMap<>();

    float CachedZoomLevel = -100.0f;

    public ArrayList<TaskDisplayPoint> GetClickedDisplayPoint(WorldPoint ClickedPoint)
    {
        ArrayList<TaskDisplayPoint> OutDisplayPointsClicked = new ArrayList<>();
        Point ClickedGraphicsPoint = worldMapOverlay.mapWorldPointToGraphicsPoint(ClickedPoint);
        for (Map.Entry<UUID, TaskDisplayPoint> CurrentTaskPair : CachedTaskDisplayPoints.entrySet())
        {
            TaskDisplayPoint CurrentDisplayPoint = CurrentTaskPair.getValue();
            Point DisplayGraphicsPoint = worldMapOverlay.mapWorldPointToGraphicsPoint(CurrentDisplayPoint.MapDisplayPoint);
            if (DisplayGraphicsPoint == null)
            {
                continue;
            }
            int TaskIconSize = config.TaskMapIconSize();

            int TaskCount = Math.min(CurrentDisplayPoint.Tasks.size(), 5);

            if (config.ScaleTaskMapIconBasedOnCount())
            {
                TaskIconSize += (int) (config.TaskMapIconSize() * TaskCount * (1.0f / config.ScaleTaskMapIconBasedOnCountInvRate()));
            }

            if (ClickedGraphicsPoint.distanceTo(DisplayGraphicsPoint) < TaskIconSize)
            {
                OutDisplayPointsClicked.add(CurrentDisplayPoint);
            }

        }

        return OutDisplayPointsClicked;
    }

    private boolean ShouldMergeIntoDisplayPoint(TaskDisplayPoint DisplayPoint, WorldPoint InWorldPoint)
    {
        // Need to be on same plane
        if (DisplayPoint.MapDisplayPoint.getPlane() != InWorldPoint.getPlane())
        {
            return false;
        }

        Point GraphicsPoint = worldMapOverlay.mapWorldPointToGraphicsPoint(InWorldPoint);
        Point DisplayGraphicsPoint = worldMapOverlay.mapWorldPointToGraphicsPoint(DisplayPoint.MapDisplayPoint);

        if (GraphicsPoint == null)
        {
            return false;
        }

        if (DisplayGraphicsPoint == null)
        {
            return false;
        }

        float DistanceBetweenPoints = GraphicsPoint.distanceTo(DisplayGraphicsPoint);
        float MaxStackingDistance = config.TaskMapStackingDistance();

        return DistanceBetweenPoints < MaxStackingDistance;
    }

    private void AddTaskWorldPointToDisplayPoints(UUID TaskGUID, boolean bIsCustomTask, WorldPoint InWorldPoint, boolean IsOverworldDungeon)
    {
        // First see if there is an existing display point we can be assigned to, if not create a new one
        for (Map.Entry<UUID, TaskDisplayPoint> CurrentTaskPair : CachedTaskDisplayPoints.entrySet())
        {
            TaskDisplayPoint CurrentDisplayPoint = CurrentTaskPair.getValue();
            if (ShouldMergeIntoDisplayPoint(CurrentDisplayPoint, InWorldPoint))
            {
                // Merge
                CurrentDisplayPoint.TaskWorldPoints.add(InWorldPoint);
                CurrentDisplayPoint.Tasks.put(TaskGUID, bIsCustomTask);

                if (IsOverworldDungeon)
                {
                    CurrentDisplayPoint.DungeonTasks.put(TaskGUID, bIsCustomTask);
                }
                CurrentDisplayPoint.UpdateMapDisplayPoint();
                TaskToDisplayPoints.putIfAbsent(TaskGUID, new HashSet<>(Collections.singleton(CurrentDisplayPoint.DisplayPointGUID)));
                TaskToDisplayPoints.get(TaskGUID).add(CurrentDisplayPoint.DisplayPointGUID);
                return;
            }
        }

        // No existing display points close enough to merge, so make a new one
        TaskDisplayPoint NewDisplayPoint = new TaskDisplayPoint();

        NewDisplayPoint.TaskWorldPoints.add(InWorldPoint);
        NewDisplayPoint.Tasks.put(TaskGUID, bIsCustomTask);

        if (IsOverworldDungeon)
        {
            NewDisplayPoint.DungeonTasks.put(TaskGUID, bIsCustomTask);
        }
        NewDisplayPoint.UpdateMapDisplayPoint();
        NewDisplayPoint.DisplayPointGUID = UUID.randomUUID();

        CachedTaskDisplayPoints.put(NewDisplayPoint.DisplayPointGUID, NewDisplayPoint);

        TaskToDisplayPoints.putIfAbsent(TaskGUID, new HashSet<>(Collections.singleton(NewDisplayPoint.DisplayPointGUID)));
        TaskToDisplayPoints.get(TaskGUID).add(NewDisplayPoint.DisplayPointGUID);
    }

    public TaskDifficulty DiffFilter = TaskDifficulty.NONE;
    public OtherFilter OthFilter = OtherFilter.NONE;
    public FilterRequirements ReqFilter = FilterRequirements.NONE;

    public HashSet<RegionType> RegionsUnlocked = new HashSet<>();

    public HashSet<RegionType> TempRegionsUnlocked = new HashSet<>();

    private void AddTaskListToDisplayPointCache(HashMap<UUID, TaskData> TaskCache)
    {

        for (Map.Entry<UUID, TaskData> CurrentTaskPair : TaskCache.entrySet())
        {
            // Skip due to some filter
            boolean bIsPartOfPlan = config.UserData.PlannedTasks.containsKey(CurrentTaskPair.getKey());
            if (!bIsPartOfPlan && DiffFilter != TaskDifficulty.NONE && DiffFilter != CurrentTaskPair.getValue().Difficulty)
            {
                continue;
            }

            // Don't display hidden on map
            boolean bIsHidden = plugin.config.UserData.HiddenTasks.contains(CurrentTaskPair.getKey());
            if (bIsHidden)
            {
                continue;
            }

            // Don't display completed on map
            boolean bIsCompleted = plugin.config.UserData.CompletedTasks.contains(CurrentTaskPair.getKey());
            if (bIsCompleted)
            {
                continue;
            }

            int ReqDifferent = CurrentTaskPair.getValue().CalculateNeededRequirementsForTask(plugin.client);
            if (ReqFilter == FilterRequirements.MEETS_REQ)
            {
                if (ReqDifferent != 0)
                {
                    continue;
                }
            }
            else if (ReqFilter == FilterRequirements.NEAR_REQ)
            {
                // 10 levels away
                if (ReqDifferent > 10)
                {
                    continue;
                }
            }

            if (OthFilter == OtherFilter.ONLY_MAP_PLAN ||
                    OthFilter == OtherFilter.ONLY_PLAN)
            {
                if (!bIsPartOfPlan && !CurrentTaskPair.getValue().bIsCustomTask)
                {
                    continue;
                }
            }

            boolean bSkipTask = false;
            for (RegionType ReqRegion : CurrentTaskPair.getValue().Regions)
            {
                if (!RegionType.GetRegionUnlocked(config, ReqRegion))
                {
                    bSkipTask = true;
                    break;
                }
            }
            if (bSkipTask)
            {
                continue;
            }

            // Full cancel
            if (bCancelDisplayPointTaskInProgress)
            {
                return;
            }

            // Go through all the task locations
            for (WorldPoint TaskWorldPoint : CurrentTaskPair.getValue().Locations)
            {
                if (config.RegionData.IsTileInUnlockedRegion(config, TaskWorldPoint))
                {
                    AddTaskWorldPointToDisplayPoints(CurrentTaskPair.getKey(), CurrentTaskPair.getValue().bIsCustomTask, TaskWorldPoint, false);
                }
            }

            // Go through all the task overworld location
            for (WorldPoint TaskOverworldWorldPoint : CurrentTaskPair.getValue().OverworldLocations)
            {
                if (config.RegionData.IsTileInUnlockedRegion(config, TaskOverworldWorldPoint))
                {
                    AddTaskWorldPointToDisplayPoints(CurrentTaskPair.getKey(), CurrentTaskPair.getValue().bIsCustomTask, TaskOverworldWorldPoint, true);
                }
            }
        }
    }

    boolean bDisplayPointTaskInProgress = false;
    boolean bCancelDisplayPointTaskInProgress = false;

    private void CacheDisplayPointsIfDirty()
    {
        WorldMap worldMap = client.getWorldMap();
        float zoom = worldMap.getWorldMapZoom();

        TempRegionsUnlocked.clear();
        for (RegionType CurrentRegion : RegionType.values())
        {
            if (RegionType.GetRegionUnlocked(config, CurrentRegion))
            {
                TempRegionsUnlocked.add(CurrentRegion);
            }
        }

        if (plugin.bMapDisplayPointsDirty ||
                zoom != CachedZoomLevel ||
                DiffFilter != config.FilteredDifficulty() ||
                OthFilter != config.FilteredOther() ||
                ReqFilter != config.FilteredRequirements() ||
                !RegionsUnlocked.containsAll(TempRegionsUnlocked) ||
                !TempRegionsUnlocked.containsAll(RegionsUnlocked) )
        {

            if (!bDisplayPointTaskInProgress)
            {
                plugin.bMapDisplayPointsDirty = false;
                CachedZoomLevel = zoom;
                DiffFilter = config.FilteredDifficulty();
                OthFilter = config.FilteredOther();
                ReqFilter = config.FilteredRequirements();
                RegionsUnlocked.clear();
                RegionsUnlocked.addAll(TempRegionsUnlocked);

                bDisplayPointTaskInProgress = true;
                plugin.getClientThread().invokeLater(() ->
                {
                    // Go through all of our tasks and figure out our display points for rendering
                    CachedTaskDisplayPoints.clear();
                    TaskToDisplayPoints.clear();

                    AddTaskListToDisplayPointCache(config.TaskData.LeaguesTaskList);
                    AddTaskListToDisplayPointCache(config.UserData.CustomTasks);

                    config.UserData.CacheSortedPlannedTasks();

                    bCancelDisplayPointTaskInProgress = false;
                    bDisplayPointTaskInProgress = false;
                });
            }
            else
            {
                bCancelDisplayPointTaskInProgress = true;
            }
        }
    }

    @Inject
    public TaskOverlay(Client Inclient, PosiedienLeaguesPlannerPlugin InPlugin, LeaguesPlannerConfig Inconfig)
    {
        client = Inclient;
        plugin = InPlugin;
        config = Inconfig;

        setPosition(OverlayPosition.DYNAMIC);
        setPriority(OverlayPriority.LOW);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }
    private static final BufferedImage TASK_IMAGE = ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/TaskIcon.png");

    private static final BufferedImage HIGHLIGHTED_TASK_IMAGE = ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/HighlightedTaskIcon.png");

    private static final BufferedImage PLANNED_TASK_IMAGE = ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/PlannedTaskIcon.png");

    private static final BufferedImage PLANNED_HIGHLIGHTED_TASK_IMAGE = ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/HighlightedPlannedTaskIcon.png");

    private static final BufferedImage TASK_IMAGE_DUNGEON = ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/TaskIconDungeon.png");

    private static final BufferedImage HIGHLIGHTED_TASK_IMAGE_DUNGEON = ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/HighlightedTaskIconDungeon.png");

    private static final BufferedImage PLANNED_TASK_IMAGE_DUNGEON = ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/PlannedTaskIconDungeon.png");
    private static final BufferedImage PLANNED_HIGHLIGHTED_TASK_IMAGE_DUNGEON = ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/HighlightedPlannedTaskIconDungeon.png");

    private static final BufferedImage BEGINNER_IMAGE = ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/Beginner.png");
    private static final BufferedImage EASY_IMAGE = ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/Easy.png");
    private static final BufferedImage MEDIUM_IMAGE = ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/Medium.png");
    private static final BufferedImage HARD_IMAGE = ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/Hard.png");
    private static final BufferedImage ELITE_IMAGE = ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/Elite.png");
    private static final BufferedImage MASTER_IMAGE = ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/Master.png");
    private static final BufferedImage CUSTOM_IMAGE = ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/Custom.png");
    private static final BufferedImage DUNGEON_IMAGE = ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/DungeonIcon.png");
    private static final BufferedImage BLANK_IMAGE = ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/BlankIcon.png");
    private BufferedImage GetImageFromDifficulty(TaskDifficulty difficulty)
    {
        switch (difficulty)
        {
            case BEGINNER:
                return BEGINNER_IMAGE;
            case EASY:
                return EASY_IMAGE;
            case MEDIUM:
                return MEDIUM_IMAGE;
            case HARD:
                return HARD_IMAGE;
            case ELITE:
                return ELITE_IMAGE;
            case MASTER:
                return MASTER_IMAGE;
            case CUSTOM:
                return CUSTOM_IMAGE;
        }

        return BEGINNER_IMAGE;
    }


    public void RenderingChangingIconUI(Graphics2D graphics)
    {
        Point HighlightGraphicsPoint = new Point(0,0);
        if (plugin.getSelectedWorldPoint() != null)
        {
            HighlightGraphicsPoint = worldMapOverlay.mapWorldPointToGraphicsPoint(plugin.getSelectedWorldPoint());
            if (HighlightGraphicsPoint == null)
            {
                HighlightGraphicsPoint = new Point(0,0);
            }
        }

        // Render all of our options centered around the center of the screen
        int TotalIconCount = plugin.CustomIconsMap.size();
        int IconSize = 30;
        int IconSizeHalf = IconSize / 2;

        Rectangle2D Bounds = WorldMapClipArea.getBounds2D();

        int RowAndHeightSize = (int) Math.sqrt(TotalIconCount);
        int i = 0;
        for (Map.Entry<String, BufferedImage> CustomIcon : plugin.CustomIconsMap.entrySet())
        {
            int OffsetX = (int) (Bounds.getCenterX() - (RowAndHeightSize / 2) * IconSize);
            int OffsetY = (int) (Bounds.getCenterY() - (RowAndHeightSize / 2) * IconSize);

            OffsetX += ((i % RowAndHeightSize) * IconSize);
            OffsetY += ((i / RowAndHeightSize) * IconSize);

            Point IconPoint = new Point(OffsetX, OffsetY);
            if (HighlightGraphicsPoint.distanceTo(IconPoint) < IconSizeHalf)
            {
                int HighlightedSize = (int) (IconSize * 1.5f);
                int HighlightedHalf = HighlightedSize / 2;
                graphics.drawImage(PosiedienLeaguesPlannerPlugin.BOUNDS_SELECTED, (int) OffsetX - HighlightedHalf, (int) OffsetY - HighlightedHalf, HighlightedSize, HighlightedSize, null);
            }
            graphics.drawImage(CustomIcon.getValue(), (int) OffsetX - IconSizeHalf, (int) OffsetY - IconSizeHalf, IconSize, IconSize, null);

            ++i;
        }

    }

    static class OverlayQueuedText
    {
        String TextValue;
        Font FontValue;
        Color ColorValue;
        int Offset;
        int X;
        int Y;

        public OverlayQueuedText(String taskWorldPointCountSize,
                                 int InOffset,
                                 int InX,
                                 int InY,
                                 Font taskIconFont,
                                 Color taskIconFontColor)
        {
            TextValue = taskWorldPointCountSize;
            FontValue = taskIconFont;
            ColorValue = taskIconFontColor;
            Offset = InOffset;
            X = InX;
            Y = InY;
        }
    };

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (plugin.bIsInitializing)
        {
            return null;
        }

        if (client.getWidget(WidgetInfo.WORLD_MAP_VIEW) == null)
        {
            return null;
        }

        WorldMapClipArea = plugin.ObtainWorldMapClipArea(Objects.requireNonNull(client.getWidget(WidgetInfo.WORLD_MAP_VIEW)).getBounds());
        graphics.setClip(WorldMapClipArea);

        // We are selecting a custom icon, do not render anything else
        if (plugin.CustomTask_ChangingIcon != null)
        {
            RenderingChangingIconUI(graphics);
            return null;
        }

        CacheDisplayPointsIfDirty();

        if (bDisplayPointTaskInProgress)
        {
            return null;
        }
        ArrayList<OverlayQueuedText> QueuedTextCommands = new ArrayList<>();

        // Go through all of our display points and render on our map
        Color taskIconFontColor = new Color(31, 58, 70,255);

        Color highlightnamecolor2 = new Color(0, 0, 0,255);

        boolean bSetHighlighted = false;
        for (Map.Entry<UUID, TaskDisplayPoint> CurrentTaskPair : CachedTaskDisplayPoints.entrySet())
        {
            TaskDisplayPoint CurrentDisplayPoint = CurrentTaskPair.getValue();
            Point GraphicsPoint = worldMapOverlay.mapWorldPointToGraphicsPoint(CurrentDisplayPoint.MapDisplayPoint);
            if (GraphicsPoint == null || !WorldMapClipArea.contains(GraphicsPoint.getX(), GraphicsPoint.getY()))
            {
                continue;
            }

            ArrayList<BufferedImage> ImageModifiers = new ArrayList<>();
            HashSet<TaskDifficulty> DisplayPointDifficulties = new HashSet<>();

            // Fill our image modifiers based on the tasks we represent
            BufferedImage OverrideImage = null;
            for (HashMap.Entry<UUID, Boolean > mapElement : CurrentDisplayPoint.Tasks.entrySet())
            {
                TaskData CurrentTask = plugin.GetTaskData(mapElement.getKey(), mapElement.getValue());

                if (CurrentTask != null && !DisplayPointDifficulties.contains(CurrentTask.Difficulty))
                {
                    ImageModifiers.add(GetImageFromDifficulty(CurrentTask.Difficulty));
                    DisplayPointDifficulties.add(CurrentTask.Difficulty);
                }

                if (CurrentTask != null && CurrentTask.CustomIcon != null)
                {
                    OverrideImage = plugin.CustomIconsMap.get(CurrentTask.CustomIcon);
                }
            }

            int TaskCount = Math.min(CurrentDisplayPoint.Tasks.size(), 5);

            int TaskIconSize = config.TaskMapIconSize();

            if (config.ScaleTaskMapIconBasedOnCount())
            {
                TaskIconSize += (int) (config.TaskMapIconSize() * TaskCount * (1.0f / config.ScaleTaskMapIconBasedOnCountInvRate()));
            }

            int TaskIconSizeHalf = TaskIconSize / 2;

            String TaskWorldPointCountSize = String.valueOf(TaskCount);
            if (CurrentDisplayPoint.Tasks.size() > 9)
            {
                TaskWorldPointCountSize = "9+";
            }

            int TaskCharacterSize = TaskWorldPointCountSize.length();

            Point HighlightGraphicsPoint = new Point(0,0);
            if (plugin.getSelectedWorldPoint() != null)
            {
                HighlightGraphicsPoint = worldMapOverlay.mapWorldPointToGraphicsPoint(plugin.getSelectedWorldPoint());
                if (HighlightGraphicsPoint == null)
                {
                    HighlightGraphicsPoint = new Point(0,0);
                }
            }

            boolean bIsTaskPlanned = false;
            for (HashMap.Entry<UUID, Boolean > mapElement : CurrentDisplayPoint.Tasks.entrySet())
            {
                if (config.UserData.PlannedTasks.containsKey(mapElement.getKey()))
                {
                    bIsTaskPlanned = true;
                }
            }

            BufferedImage DrawImage = null;
            int HighlightedSize = (int) (TaskIconSize * 1.5f);
            int HighlightedHalf = HighlightedSize / 2;

            boolean bIsHighlighted = false;
            if (!bSetHighlighted && HighlightGraphicsPoint.distanceTo(GraphicsPoint) < TaskIconSize)
            {
                bIsHighlighted = true;
                bSetHighlighted = true;
                if (CurrentDisplayPoint.Tasks.size() == CurrentDisplayPoint.DungeonTasks.size())
                {
                    if (bIsTaskPlanned)
                    {
                        DrawImage = PLANNED_HIGHLIGHTED_TASK_IMAGE_DUNGEON;
                    }
                    else
                    {
                        DrawImage = HIGHLIGHTED_TASK_IMAGE_DUNGEON;
                    }
                }
                else
                {
                    if (bIsTaskPlanned)
                    {
                        DrawImage = PLANNED_HIGHLIGHTED_TASK_IMAGE;
                    }
                    else
                    {
                        DrawImage = HIGHLIGHTED_TASK_IMAGE;
                    }
                }

                if (OverrideImage != null)
                {
                    graphics.drawImage(PosiedienLeaguesPlannerPlugin.BOUNDS_SELECTED, (int) GraphicsPoint.getX() - HighlightedHalf, (int) GraphicsPoint.getY()  - HighlightedHalf, HighlightedSize, HighlightedSize, null);
                }
            }
            else
            {
                if (CurrentDisplayPoint.Tasks.size() == CurrentDisplayPoint.DungeonTasks.size())
                {
                    if (bIsTaskPlanned)
                    {
                        DrawImage = PLANNED_TASK_IMAGE_DUNGEON;
                        if (OverrideImage != null)
                        {
                            graphics.drawImage(PosiedienLeaguesPlannerPlugin.BOUNDS_SELECTED, (int) GraphicsPoint.getX() - HighlightedHalf, (int) GraphicsPoint.getY()  - HighlightedHalf, HighlightedSize, HighlightedSize, null);
                        }
                    }
                    else
                    {
                        DrawImage = TASK_IMAGE_DUNGEON;
                    }
                }
                else
                {
                    if (bIsTaskPlanned)
                    {
                        DrawImage = PLANNED_TASK_IMAGE;
                        if (OverrideImage != null)
                        {
                            graphics.drawImage(PosiedienLeaguesPlannerPlugin.BOUNDS_SELECTED, (int) GraphicsPoint.getX() - HighlightedHalf, (int) GraphicsPoint.getY()  - HighlightedHalf, HighlightedSize, HighlightedSize, null);
                        }
                    }
                    else
                    {
                        DrawImage = TASK_IMAGE;
                    }
                }
            }

            if (OverrideImage != null)
            {
                DrawImage = OverrideImage;
            }

            graphics.drawImage(DrawImage, GraphicsPoint.getX() - TaskIconSizeHalf, GraphicsPoint.getY() - TaskIconSizeHalf, TaskIconSize, TaskIconSize, null);

            int TaskIconModifierSize = TaskIconSize / 3;

            // Rows of 4 and start stacking on top
            int RowCount = 4;
            for (int i = 0; i < ImageModifiers.size(); ++i)
            {
                BufferedImage Image = ImageModifiers.get(i);
                graphics.drawImage(Image,
                        GraphicsPoint.getX() + ((i % RowCount) - 2) * TaskIconModifierSize,
                        GraphicsPoint.getY() - TaskIconSize + TaskIconModifierSize / 2 - (i / RowCount) * TaskIconModifierSize,
                        TaskIconModifierSize,
                        TaskIconModifierSize,
                        null);
            }

            // Dungeon icon
            if (!CurrentDisplayPoint.DungeonTasks.isEmpty())
            {
                graphics.drawImage(DUNGEON_IMAGE,
                        GraphicsPoint.getX(),
                        GraphicsPoint.getY(),
                        (int)(TaskIconModifierSize * 2.0f),
                        (int)(TaskIconModifierSize * 2.0f),
                        null);
            }

            Font taskIconFont = new FontUIResource("TaskCountFont", Font.BOLD, TaskIconSizeHalf);
            int TextIconTextOffsetY = -TaskIconSizeHalf / 2;
            int TextIconTextOffsetX = (TaskIconSizeHalf / 4);

            QueuedTextCommands.add(new OverlayQueuedText(TaskWorldPointCountSize,
                    0,
                    GraphicsPoint.getX() - TextIconTextOffsetX,
                    GraphicsPoint.getY() - TextIconTextOffsetY,
                    taskIconFont,
                    taskIconFontColor));

            boolean bIsCloseToMouse = bIsHighlighted;
            if (bIsTaskPlanned || bIsCloseToMouse)
            {
                Font taskhighlightFont2 = new FontUIResource("taskhighlightFont2", Font.BOLD, 15);

                int TaskNum2 = 0;
                for (HashMap.Entry<UUID, Boolean > mapElement : CurrentDisplayPoint.Tasks.entrySet())
                {
                    TaskData CurrentTask = plugin.GetTaskData(mapElement.getKey(), mapElement.getValue());
                    String ModifiedString = CurrentTask.TaskName;

                    if (config.UserData.PlannedTasks.containsKey(CurrentTask.GUID))
                    {
                        ModifiedString += " (" + config.UserData.PlannedTasks.get(CurrentTask.GUID).LastSortOrder + ")";
                    }

                    if (bIsCloseToMouse)
                    {
                        QueuedTextCommands.add(new OverlayQueuedText(ModifiedString,
                                0,
                                HighlightGraphicsPoint.getX() - 1,
                                HighlightGraphicsPoint.getY() - TaskNum2 * 15 + 1,
                                taskhighlightFont2,
                                highlightnamecolor2));

                        ++TaskNum2;
                    }
                    // bIsTaskPlanned
                    else if (config.UserData.PlannedTasks.containsKey(CurrentTask.GUID))
                    {
                        QueuedTextCommands.add(new OverlayQueuedText(ModifiedString,
                                0,
                                GraphicsPoint.getX() - 1,
                                GraphicsPoint.getY() - TaskNum2 * 15 + 1,
                                taskhighlightFont2,
                                highlightnamecolor2));

                        ++TaskNum2;
                    }
                }
                Font taskhighlightFont = new FontUIResource("taskhighlightFont", Font.BOLD, 15);

                int TaskNum = 0;
                for (HashMap.Entry<UUID, Boolean > mapElement : CurrentDisplayPoint.Tasks.entrySet())
                {
                    TaskData CurrentTask = plugin.GetTaskData(mapElement.getKey(), mapElement.getValue());
                    String ModifiedString = CurrentTask.TaskName;

                    if (config.UserData.PlannedTasks.containsKey(CurrentTask.GUID))
                    {
                        ModifiedString += " (" + config.UserData.PlannedTasks.get(CurrentTask.GUID).LastSortOrder + ")";
                    }

                    if (bIsCloseToMouse)
                    {
                        QueuedTextCommands.add(new OverlayQueuedText(ModifiedString,
                                0,
                                HighlightGraphicsPoint.getX(),
                                HighlightGraphicsPoint.getY() - TaskNum * 15,
                                taskhighlightFont,
                                TaskDifficulty.GetTaskDifficultyColor(CurrentTask.Difficulty)));

                        ++TaskNum;
                    }
                    // bIsTaskPlanned
                    else if (config.UserData.PlannedTasks.containsKey(CurrentTask.GUID))
                    {
                        QueuedTextCommands.add(new OverlayQueuedText(ModifiedString,
                                0,
                                GraphicsPoint.getX(),
                                GraphicsPoint.getY() - TaskNum * 15,
                                taskhighlightFont,
                                TaskDifficulty.GetTaskDifficultyColor(CurrentTask.Difficulty)));

                        ++TaskNum;
                    }
                }
            }
        }

        // Go through our plan and draw lines connecting them
        Player player = plugin.client.getLocalPlayer();
        ArrayList<Pathfinder> pathfinderArray = plugin.panel.getPathfinderArray();
        if (player != null)
        {
            graphics.setColor(new Color(255, 226, 1,255));
            WorldPoint LastWorldPoint = player.getWorldLocation();
            WorldPoint LastActualWorldPoint = player.getWorldLocation();

            int SortTaskIter = 0;
            for (SortedTask SortedTaskIter : config.UserData.SortedPlannedTasks)
            {
                TaskData CurrentTask = plugin.GetTaskData(SortedTaskIter.TaskGUID, SortedTaskIter.bIsCustomTask);

                // Find our display points with this task
                float ClosestDistance = 9000000.0f;
                float ClosestActualDistance = 9000000.0f;
                WorldPoint ClosestWorldPoint = null;
                WorldPoint ClosestActualWorldPoint = null;
                if (CurrentTask == null || !TaskToDisplayPoints.containsKey(CurrentTask.GUID))
                {
                    continue;
                }

                for (UUID DisplayPointGUID : TaskToDisplayPoints.get(CurrentTask.GUID))
                {
                    WorldPoint CurrentWorldPoint =  CachedTaskDisplayPoints.get(DisplayPointGUID).MapDisplayPoint;
                    float NextDistance = LastWorldPoint.distanceTo(CurrentWorldPoint);
                    if ( NextDistance < ClosestDistance)
                    {
                        ClosestDistance = NextDistance;
                        ClosestWorldPoint = CurrentWorldPoint;
                    }
                }

                for (WorldPoint ActualLocation : CurrentTask.Locations)
                {
                    float NextDistance = LastActualWorldPoint.distanceTo(ActualLocation);
                    if ( NextDistance < ClosestActualDistance)
                    {
                        ClosestActualDistance = NextDistance;
                        ClosestActualWorldPoint = ActualLocation;
                    }
                }

                if (plugin.panel.CurrentPathfinderIndex == SortTaskIter && pathfinderArray != null)
                {
                    boolean bIsCurrentPathfindingDone = false;
                    synchronized (plugin.panel.pathfinderMutex)
                    {
                        bIsCurrentPathfindingDone = pathfinderArray.isEmpty() ||
                                pathfinderArray.get(SortTaskIter - 1).isDone();
                    }

                    // Start next path
                    if (bIsCurrentPathfindingDone)
                    {
                        ++plugin.panel.CurrentPathfinderIndex;
                        WorldPoint finalLastWorldPoint = LastActualWorldPoint;
                        WorldPoint finalClosestWorldPoint = ClosestActualWorldPoint;
                        plugin.getClientThread().invokeLater(() ->
                        {
                            plugin.pathfinderConfig.refresh();
                            synchronized (plugin.panel.pathfinderMutex)
                            {
                                Pathfinder NewPathfinder = new Pathfinder(plugin.pathfinderConfig, finalLastWorldPoint, finalClosestWorldPoint, false);
                                plugin.panel.pathfinderArray.add(NewPathfinder);
                                plugin.panel.pathfinderFuture = plugin.panel.pathfindingExecutor.submit(NewPathfinder);
                            }
                        });
                    }
                }

                ++SortTaskIter;
                LastActualWorldPoint = ClosestActualWorldPoint;

                // Draw arrow from closest distance to next task
                Point GraphicsStart = worldMapOverlay.mapWorldPointToGraphicsPoint(ClosestWorldPoint);
                if (GraphicsStart == null)
                {
                    LastWorldPoint = ClosestWorldPoint;
                    continue;
                }

                Point GraphicsEnd = worldMapOverlay.mapWorldPointToGraphicsPoint(LastWorldPoint);
                if (GraphicsEnd == null)
                {
                    LastWorldPoint = ClosestWorldPoint;
                    continue;
                }

                graphics.drawLine(GraphicsStart.getX(), GraphicsStart.getY(), GraphicsEnd.getX(), GraphicsEnd.getY());
                LastWorldPoint = ClosestWorldPoint;
            }


        }

        for (OverlayQueuedText CurrentTextCommand :QueuedTextCommands)
        {
            graphics.setFont(CurrentTextCommand.FontValue);
            graphics.setColor(CurrentTextCommand.ColorValue);
            graphics.drawChars(CurrentTextCommand.TextValue.toCharArray(),
                    CurrentTextCommand.Offset,
                    CurrentTextCommand.TextValue.length(),
                    CurrentTextCommand.X,
                    CurrentTextCommand.Y);
        }

        return null;
    }
}

package Posiedien_Leagues_Planner;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.UUID;
import net.runelite.api.coords.WorldPoint;
import org.apache.commons.lang3.tuple.Pair;

public class TaskDisplayPoint
{
    UUID DisplayPointGUID;

    // Boolean whether or not the task is a custom task
    HashMap<UUID, Boolean> Tasks = new HashMap<>();
    HashMap<UUID, Boolean> DungeonTasks = new HashMap<>();

    ArrayList<WorldPoint> TaskWorldPoints = new ArrayList<>();

    WorldPoint MapDisplayPoint;

    // An average map display point
    void UpdateMapDisplayPoint()
    {
        int averageX = 0;
        int averageY = 0;
        int averageZ = 0;

        for (WorldPoint TaskPoint : TaskWorldPoints)
        {
            averageX += TaskPoint.getX();
            averageY += TaskPoint.getY();
            averageZ += TaskPoint.getPlane();
        }
        averageX /= TaskWorldPoints.size();
        averageY /= TaskWorldPoints.size();
        averageZ /= TaskWorldPoints.size();

        MapDisplayPoint = new WorldPoint(averageX, averageY, averageZ);
    }
}

package Posiedien_Leagues_Planner;

import net.runelite.api.Skill;
import net.runelite.api.World;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.plugins.achievementdiary.CombatLevelRequirement;
import net.runelite.client.plugins.achievementdiary.SkillRequirement;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.*;

public class FullTaskData
{

    ArrayList<SortedTask> SortedLeaguesTaskList = new ArrayList<SortedTask>();

    HashMap<UUID, TaskData> LeaguesTaskList = new HashMap<UUID, TaskData>();
    HashMap<String, UUID> StringToTask = new HashMap<String, UUID>();

    void AddNewTaskToDataBase(TaskData newTask)
    {
        if (newTask.GUID == null)
        {
            newTask.GUID = UUID.randomUUID();
        }
        LeaguesTaskList.put(newTask.GUID, newTask);
        StringToTask.put(newTask.TaskName, newTask.GUID);
    }

    public void CalculateAndCacheOverworldLocations(PosiedienLeaguesPlannerPlugin posiedienLeaguesPlannerPlugin)
    {
        // Go through all of our points on our tasks
        for (HashMap.Entry<UUID, TaskData> entry : LeaguesTaskList.entrySet())
        {
            for (WorldPoint NextLocation : entry.getValue().Locations)
            {
                if (!IsOverworldLocation(NextLocation))
                {
                    posiedienLeaguesPlannerPlugin.restartPathfinding(NextLocation, new WorldPoint(3000,3000,0), true);
                    while (posiedienLeaguesPlannerPlugin.getPathfinder() == null ||
                            !posiedienLeaguesPlannerPlugin.getPathfinder().isDone() ||
                            posiedienLeaguesPlannerPlugin.bQueuedPathfinderTask)
                    {
                        try {
                            Thread.sleep(500);
                        }
                        catch (Exception e) {
                        }
                    }
                    WorldPoint LastLocation = posiedienLeaguesPlannerPlugin.getPathfinder().getPath().get(posiedienLeaguesPlannerPlugin.getPathfinder().getPath().size() - 1);

                    if (IsOverworldLocation(LastLocation) && !entry.getValue().OverworldLocations.contains(LastLocation))
                    {
                        entry.getValue().OverworldLocations.add(LastLocation);
                    }
                }
            }
        }
    }

    public boolean IsOverworldLocation(WorldPoint testPoint)
    {
        // Just hard code the overworld bounds
        if (testPoint.getPlane() == 0)
        {
            if (testPoint.getX() > 1022 && testPoint.getX() < 3968)
            {
                return testPoint.getY() > 2494 && testPoint.getY() < 4160;
            }
        }

        return false;
    }
    public String GetNextIgnoreBlank(Scanner sc)
    {
        while (true)
        {
            if (!sc.hasNext())
            {
                return null;
            }

            String NextString = sc.next();
            if (!Objects.equals(NextString, "")
                    && !Objects.equals(NextString, "\r\n"))
            {
                NextString = NextString.replace("\r\n", "");
                return NextString;
            }
        }

    }

    public void importFromConverted(File file)
    {
        if (file.exists())
        {
            try (Scanner sc = new Scanner(file))
            {
                // CSV file, so comma delimiter
                sc.useDelimiter(",");

                GetNextIgnoreBlank(sc); // "Task Count:"
                GetNextIgnoreBlank(sc); // #

                // Go through every task in the csv
                while(sc.hasNext())
                {
                    String TaskName = GetNextIgnoreBlank(sc);
                    if (TaskName == null)
                    {
                        break;
                    }

                    // Task already exists, so lets work off that one
                    TaskData newTask = null;
                    boolean bIsNewTask = false;
                    if (StringToTask.containsKey(TaskName))
                    {
                        newTask = LeaguesTaskList.get(StringToTask.get(TaskName));
                    }
                    else
                    {
                        bIsNewTask = true;
                        newTask = new TaskData();
                    }

                    String DifficultyName = GetNextIgnoreBlank(sc);
                    newTask.TaskName = TaskName;
                    newTask.Difficulty = TaskDifficulty.valueOf(DifficultyName);

                    newTask.TaskDescription = GetNextIgnoreBlank(sc);

                    if (!bIsNewTask)
                    {
                        GetNextIgnoreBlank(sc); // Throw out guid
                    }
                    else
                    {
                        newTask.GUID = UUID.fromString(GetNextIgnoreBlank(sc));
                    }

                    newTask.bIsCustomTask = Boolean.valueOf(GetNextIgnoreBlank(sc));
                    newTask.CustomIcon = GetNextIgnoreBlank(sc);
                    if (newTask.CustomIcon.contains("null"))
                    {
                        newTask.CustomIcon = null;
                    }

                    GetNextIgnoreBlank(sc); // "Regions Count: "

                    int RegionCount = Integer.parseInt(GetNextIgnoreBlank(sc));
                    for (int i = 0; i < RegionCount; ++i)
                    {
                        newTask.Regions.add(RegionType.valueOf(GetNextIgnoreBlank(sc)));
                    }

                    GetNextIgnoreBlank(sc); // "Overworld Location Count (Auto-generated): ,"
                    int OverworldPointCount = Integer.parseInt(GetNextIgnoreBlank(sc));
                    for (int i = 0; i < OverworldPointCount; ++i)
                    {
                        WorldPoint newWorldPoint = new WorldPoint(
                                Integer.parseInt(GetNextIgnoreBlank(sc)),
                                Integer.parseInt(GetNextIgnoreBlank(sc)),
                                Integer.parseInt(GetNextIgnoreBlank(sc)));

                        if (!newTask.OverworldLocations.contains(newWorldPoint))
                        {
                            newTask.OverworldLocations.add(newWorldPoint);
                        }
                    }

                    GetNextIgnoreBlank(sc); // "POSITIONS_START"
                    GetNextIgnoreBlank(sc); // "NO_POSITIONS"
                    GetNextIgnoreBlank(sc); // "X"
                    GetNextIgnoreBlank(sc); // "Y"
                    GetNextIgnoreBlank(sc); // "Z"

                    int IterationNum = 0;
                    int CurrentX = 0;
                    int CurrentY = 0;
                    int CurrentZ = 0;

                    String NextString = GetNextIgnoreBlank(sc);
                    while (!NextString.contains("POSITIONS_END"))
                    {
                        switch (IterationNum)
                        {
                            case 0: // X
                                CurrentX = Integer.parseInt(NextString);
                                break;
                            case 1: // Y
                                CurrentY = Integer.parseInt(NextString);
                                break;
                            case 2: // Z
                                CurrentZ = Integer.parseInt(NextString);
                                break;
                        }

                        NextString = GetNextIgnoreBlank(sc);

                        ++IterationNum;
                        // Add a new coord
                        if (IterationNum > 2)
                        {
                            IterationNum = 0;

                            WorldPoint newWorldPoint = new WorldPoint(
                                    CurrentX,
                                    CurrentY,
                                    CurrentZ
                            );

                            if (!newTask.Locations.contains(newWorldPoint))
                            {
                                newTask.Locations.add(newWorldPoint);
                            }
                        }
                    }

                    GetNextIgnoreBlank(sc); // REQUIREMENTS_START
                    GetNextIgnoreBlank(sc); // SKILL NAME
                    GetNextIgnoreBlank(sc); // LEVEL REQ
                    NextString = GetNextIgnoreBlank(sc);
                    IterationNum = 0;
                    String CurrentSkill = null;
                    int SkillReqLevel = 0;

                    while (!NextString.contains("REQUIREMENTS_END"))
                    {
                        switch (IterationNum)
                        {
                            case 0:
                                CurrentSkill = NextString;
                                break;
                            case 1:
                                SkillReqLevel = Integer.parseInt(NextString);
                                break;
                        }

                        NextString = GetNextIgnoreBlank(sc);

                        ++IterationNum;

                        // Add a new requirement
                        if (IterationNum > 1)
                        {
                            IterationNum = 0;

                            if (CurrentSkill.contains("COMBAT"))
                            {
                                newTask.Requirements.add(new CombatLevelRequirement(SkillReqLevel));
                            }
                            else
                            {
                                Skill AddedSkill = Skill.valueOf(CurrentSkill);
                                newTask.Requirements.add(new SkillRequirement(AddedSkill, SkillReqLevel));
                            }
                        }
                    }

                    if (bIsNewTask)
                    {
                        AddNewTaskToDataBase(newTask);
                    }
                }

            }
            catch (IOException ignored)
            {
            }
        }

        // Construct String to UUID lookup
        StringToTask.clear();
        for (HashMap.Entry<UUID, TaskData> entry : LeaguesTaskList.entrySet())
        {
            StringToTask.put(entry.getValue().TaskName, entry.getKey());
        }
    }

    public String ExportData(PosiedienLeaguesPlannerPlugin plugin)
    {
        StringBuilder Converted = new StringBuilder();

        Converted.append("Task Count: ,");
        Converted.append(LeaguesTaskList.size());
        Converted.append(",");
        Converted.append("\r\n");

        SortedLeaguesTaskList.clear();
        plugin.panel.AddTaskListToSortedLeaguesTasks(null, LeaguesTaskList);

        SortedLeaguesTaskList.sort(new Comparator<SortedTask>() {
            @Override
            public int compare(SortedTask o1, SortedTask o2)
            {
                return (o1.SortPriority.compareTo(o2.SortPriority));
            }
        });


        for (SortedTask SortedTaskIter : SortedLeaguesTaskList)
        {
            TaskData data = plugin.GetTaskData(SortedTaskIter.TaskGUID, SortedTaskIter.bIsCustomTask);

            Converted.append(data.ExportData());
            Converted.append(",");
            Converted.append("\r\n");
        }

        return Converted.toString();
    }

    public void exportToConverted(File file, PosiedienLeaguesPlannerPlugin plugin) throws IOException
    {
        try (FileWriter fw = new FileWriter(file))
        {
            fw.write(ExportData(plugin));
        }
    }

    public void importFromRaw()
    {
        // All the tasks found in our raw
        HashSet<UUID> TaskGUIDSet = new HashSet<>();

        // Go through each region
        for (RegionType CurrentRegion : RegionType.values())
        {
            // We open a file for each of our regions
            File file = new File("RawWikiTaskData/" + CurrentRegion.toString() + ".txt");
            if (file.exists())
            {
                try (Scanner sc = new Scanner(file))
                {
                    TaskDifficulty CurrentDifficulty = null;

                    // New line delimiter
                    sc.useDelimiter("\n");

                    while(sc.hasNext())
                    {
                        // Find next difficulty
                        while (CurrentDifficulty == null)
                        {
                            if (!sc.hasNext())
                            {
                                break;
                            }

                            String NextString = sc.next();

                            if (NextString.contains("==="))
                            {
                                NextString = NextString.replaceAll("===", "");
                                NextString = NextString.replaceAll("\r", "");
                                NextString = NextString.toUpperCase();
                                CurrentDifficulty = TaskDifficulty.valueOf(NextString);
                            }
                        }

                        // Difficulty found, lets skip until we reach our first task "LeagueTaskRow"
                        TaskData newTask = null;
                        while (CurrentDifficulty != null && newTask == null)
                        {
                            if (!sc.hasNext())
                            {
                                break;
                            }
                            String NextString = sc.next();
                            if (NextString.contains("LeagueTaskRow"))
                            {
                                // Remove the league task row start string
                                NextString = NextString.replaceAll("\\{\\{LeagueTaskRow\\|", "");
                                NextString = NextString.replaceAll("\\{\\{sic}}", "");

                                // Remove wiki links
                                while (NextString.contains("[["))
                                {
                                    int StartSubstring = NextString.indexOf("[[");
                                    int EndSubstring = NextString.indexOf("]]");

                                    String OriginalSubString = NextString.substring(StartSubstring, EndSubstring + 2);

                                    // If there is a pipe, that means we have multiple options, just choose the first
                                    if (OriginalSubString.contains("|"))
                                    {
                                        EndSubstring = OriginalSubString.indexOf("|");
                                    }
                                    else
                                    {
                                        EndSubstring = OriginalSubString.length();
                                    }

                                    String ModifiedSubString = OriginalSubString.substring(2, EndSubstring - 2);
                                    NextString = NextString.replace(OriginalSubString, ModifiedSubString);
                                }

                                String TaskName = NextString.substring(0, NextString.indexOf("|"));
                                NextString = NextString.substring(NextString.indexOf("|") + 1);

                                // No commas aloud
                                TaskName = TaskName.replace(",", "");

                                // Task already exists, keep the cached one instead and skip
                                boolean bIsNewTask = false;
                                if (StringToTask.containsKey(TaskName))
                                {
                                    newTask = LeaguesTaskList.get(StringToTask.get(TaskName));
                                }
                                else
                                {
                                    bIsNewTask = true;
                                    newTask = new TaskData();
                                }

                                newTask.Difficulty = CurrentDifficulty;
                                if (bIsNewTask)
                                {
                                    newTask.TaskName = TaskName;

                                    newTask.TaskDescription = NextString.substring(0, NextString.indexOf("|"));
                                    newTask.TaskDescription = newTask.TaskDescription.replace(",", "");
                                }
                                NextString = NextString.substring(NextString.indexOf("|") + 1);

                                // Skill requirements are next
                                String SkillRequirementString = "";
                                if (NextString.contains("|"))
                                {
                                    SkillRequirementString = NextString.substring(0, NextString.indexOf("|"));
                                    NextString = NextString.substring(NextString.indexOf("|") + 1);
                                }

                                while (SkillRequirementString.contains("{{"))
                                {
                                    // Probably a quest or other requirement
                                    if (!NextString.contains("|"))
                                    {
                                        break;
                                    }
                                    SkillRequirementString =  NextString.substring(0, NextString.indexOf("|"));
                                    NextString = NextString.substring(NextString.indexOf("|") + 1);

                                    if (!NextString.contains("|"))
                                    {
                                        break;
                                    }
                                    String SkillName = SkillRequirementString.toUpperCase();

                                    // Isn't a skill
                                    try
                                    {
                                        Skill.valueOf(SkillName);
                                    } catch (IllegalArgumentException ignored)
                                    {
                                        break;
                                    }

                                    SkillRequirementString =  NextString.substring(0, NextString.indexOf("|"));
                                    NextString = NextString.substring(NextString.indexOf("|") + 1);

                                    // Could have no link or sort strings
                                    if (SkillRequirementString.contains("}}"))
                                    {
                                        SkillRequirementString = SkillRequirementString.replace("}}", "");
                                    }

                                    if (SkillRequirementString.contains(","))
                                    {
                                        SkillRequirementString = SkillRequirementString.substring(0, SkillRequirementString.indexOf(","));
                                    }

                                    int SkillRequirementLevel = Integer.parseInt(SkillRequirementString);
                                    if (SkillName.equals("COMBAT"))
                                    {
                                        CombatLevelRequirement newCombatReq = new CombatLevelRequirement(SkillRequirementLevel);
                                        newTask.Requirements.add(newCombatReq);
                                    }
                                    else
                                    {
                                        Skill ConvertedSkill = Skill.valueOf(SkillName);
                                        SkillRequirement newSkillReq = new SkillRequirement(ConvertedSkill, SkillRequirementLevel);
                                        newTask.Requirements.add(newSkillReq);
                                    }


                                    if (!NextString.contains("|"))
                                    {
                                        break;
                                    }
                                    SkillRequirementString =  NextString.substring(0, NextString.indexOf("|"));
                                    if (SkillRequirementString.contains("link"))
                                    {
                                        NextString = NextString.substring(NextString.indexOf("|") + 1);
                                    }

                                    if (!NextString.contains("|"))
                                    {
                                        break;
                                    }
                                    SkillRequirementString =  NextString.substring(0, NextString.indexOf("|"));
                                    if (SkillRequirementString.contains("sort"))
                                    {
                                        NextString = NextString.substring(NextString.indexOf("|") + 1);
                                    }
                                }

                                // Other requirements are next, but just don't bother with other reqs right now

                                newTask.Regions.clear();
                                if (CurrentRegion != RegionType.GENERAL)
                                {
                                    newTask.Regions.add(CurrentRegion);
                                }

                                if (bIsNewTask)
                                {
                                    AddNewTaskToDataBase(newTask);
                                }
                                TaskGUIDSet.add(newTask.GUID);
                            }
                            // Finished all the tasks of this difficulty
                            else if (NextString.contains("LeagueTaskBottom"))
                            {
                                CurrentDifficulty = null;
                            }
                        }
                    }

                } catch (IOException ignored)
                {
                }

            }
        }

        // Figure out what tasks to remove (wasn't present in the raw data)
        HashSet<UUID> TasksToRemove = new HashSet<>();
        for (Map.Entry<UUID, TaskData> SearchingTask : LeaguesTaskList.entrySet())
        {
            if (!TaskGUIDSet.contains(SearchingTask.getKey()))
            {
                TasksToRemove.add(SearchingTask.getKey());
            }
        }

        for (UUID SearchingTask : TasksToRemove)
        {
            LeaguesTaskList.remove(SearchingTask);
        }

        // Re-construct String to UUID lookup
        StringToTask.clear();
        for (HashMap.Entry<UUID, TaskData> entry : LeaguesTaskList.entrySet())
        {
            StringToTask.put(entry.getValue().TaskName, entry.getKey());
        }
    }
}

package Posiedien_Leagues_Planner;

import Posiedien_Leagues_Planner.pathfinder.Pathfinder;
import com.google.inject.Inject;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.geom.Line2D;
import java.awt.geom.Rectangle2D;
import java.util.ArrayList;
import java.util.List;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.Tile;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import Posiedien_Leagues_Planner.pathfinder.CollisionMap;

public class PathTileOverlay extends Overlay {
    private final Client client;
    private final PosiedienLeaguesPlannerPlugin plugin;
    private final LeaguesPlannerConfig config;

    @Inject
    public PathTileOverlay(Client client, PosiedienLeaguesPlannerPlugin plugin, LeaguesPlannerConfig config) {
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(OverlayPriority.LOW);
        setLayer(OverlayLayer.ABOVE_SCENE);
    }

    private void renderTransports(Graphics2D graphics) {
        for (WorldPoint a : plugin.getTransports().keySet()) {
            drawTile(graphics, a, config.colourTransports(), -1, true);

            Point ca = tileCenter(a);

            if (ca == null) {
                continue;
            }

            StringBuilder s = new StringBuilder();
            for (Transport b : plugin.getTransports().getOrDefault(a, new ArrayList<>())) {
                for (WorldPoint origin : WorldPoint.toLocalInstance(client, b.getOrigin())) {
                    Point cb = tileCenter(origin);
                    if (cb != null) {
                        graphics.drawLine(ca.getX(), ca.getY(), cb.getX(), cb.getY());
                    }
                    if (origin.getPlane() > a.getPlane()) {
                        s.append("+");
                    } else if (origin.getPlane() < a.getPlane()) {
                        s.append("-");
                    } else {
                        s.append("=");
                    }
                }
            }
            graphics.setColor(Color.WHITE);
            graphics.drawString(s.toString(), ca.getX(), ca.getY());
        }
    }

    private void renderCollisionMap(Graphics2D graphics) {
        CollisionMap map = plugin.getMap();
        for (Tile[] row : client.getScene().getTiles()[client.getPlane()]) {
            for (Tile tile : row) {
                if (tile == null) {
                    continue;
                }

                Polygon tilePolygon = Perspective.getCanvasTilePoly(client, tile.getLocalLocation());

                if (tilePolygon == null) {
                    continue;
                }

                WorldPoint location = client.isInInstancedRegion() ?
                    WorldPoint.fromLocalInstance(client, tile.getLocalLocation()) : tile.getWorldLocation();
                int x = location.getX();
                int y = location.getY();
                int z = location.getPlane();

                String s = (!map.n(x, y, z) ? "n" : "") +
                        (!map.s(x, y, z) ? "s" : "") +
                        (!map.e(x, y, z) ? "e" : "") +
                        (!map.w(x, y, z) ? "w" : "");

                if (map.isBlocked(x, y, z)) {
                    graphics.setColor(config.colourCollisionMap());
                    graphics.fill(tilePolygon);
                }
                if (!s.isEmpty() && !s.equals("nsew")) {
                    graphics.setColor(Color.WHITE);
                    int stringX = (int) (tilePolygon.getBounds().getCenterX() - graphics.getFontMetrics().getStringBounds(s, graphics).getWidth() / 2);
                    int stringY = (int) tilePolygon.getBounds().getCenterY();
                    graphics.drawString(s, stringX, stringY);
                }
            }
        }
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (plugin.bIsInitializing)
        {
            return null;
        }

        if (config.drawTransports()) {
            this.renderTransports(graphics);
        }

        if (config.drawCollisionMap()) {
            this.renderCollisionMap(graphics);
        }

        if (config.drawTiles() && plugin.getPathfinder() != null && plugin.getPathfinder().getPath() != null)
        {
            Color color;
            if (plugin.getPathfinder().isDone()) {
                color = new Color(
                    config.colourPath().getRed(),
                    config.colourPath().getGreen(),
                    config.colourPath().getBlue(),
                    config.colourPath().getAlpha() / 2);
            } else {
                color = new Color(
                    config.colourPathCalculating().getRed(),
                    config.colourPathCalculating().getGreen(),
                    config.colourPathCalculating().getBlue(),
                    config.colourPathCalculating().getAlpha() / 2);
            }

            List<WorldPoint> path = plugin.getPathfinder().getPath();
            int counter = 0;
            if (TileStyle.LINES.equals(config.pathStyle())) {
                for (int i = 1; i < path.size(); i++) {
                    drawLine(graphics, path.get(i - 1), path.get(i), color, 1 + counter++);
                    drawFairyRingCode(graphics, path.get(i - 1), path.get(i));
                }
            } else {
                boolean showTiles = TileStyle.TILES.equals(config.pathStyle());
                for (int i = 0; i <  path.size(); i++) {
                    drawTile(graphics, path.get(i), color, counter++, showTiles);
                    drawFairyRingCode(graphics, path.get(i), (i + 1 == path.size()) ? null : path.get(i + 1));
                }
            }
        }

        ArrayList<Pathfinder> pathfinderArray = plugin.panel.getPathfinderArray() ;
        if (pathfinderArray != null)
        {
            for (Pathfinder CurrentPathfinder : pathfinderArray)
            {
                if (config.drawTiles() && CurrentPathfinder != null && CurrentPathfinder.getPath() != null)
                {
                    Color color;
                    if (CurrentPathfinder.isDone()) {
                        color = new Color(
                                Color.RED.getRed(),
                                Color.RED.getGreen(),
                                Color.RED.getBlue(),
                                Color.RED.getAlpha() / 4);
                    } else {
                        color = new Color(
                                Color.CYAN.getRed(),
                                Color.CYAN.getGreen(),
                                Color.CYAN.getBlue(),
                                Color.CYAN.getAlpha() / 4);
                    }

                    List<WorldPoint> path = CurrentPathfinder.getPath();
                    int counter = 0;
                    if (TileStyle.LINES.equals(config.pathStyle())) {
                        for (int i = 1; i < path.size(); i++) {
                            drawLine(graphics, path.get(i - 1), path.get(i), color, 1 + counter++);
                            drawFairyRingCode(graphics, path.get(i - 1), path.get(i));
                        }
                    } else {
                        boolean showTiles = TileStyle.TILES.equals(config.pathStyle());
                        for (int i = 0; i <  path.size(); i++) {
                            drawTile(graphics, path.get(i), color, counter++, showTiles);
                            drawFairyRingCode(graphics, path.get(i), (i + 1 == path.size()) ? null : path.get(i + 1));
                        }
                    }
                }
            }
        }

        return null;
    }

    private Point tileCenter(WorldPoint b) {
        if (b.getPlane() != client.getPlane()) {
            return null;
        }

        LocalPoint lp = LocalPoint.fromWorld(client, b);
        if (lp == null) {
            return null;
        }

        Polygon poly = Perspective.getCanvasTilePoly(client, lp);
        if (poly == null) {
            return null;
        }

        int cx = poly.getBounds().x + poly.getBounds().width / 2;
        int cy = poly.getBounds().y + poly.getBounds().height / 2;
        return new Point(cx, cy);
    }

    private void drawTile(Graphics2D graphics, WorldPoint location, Color color, int counter, boolean draw) {
        for (WorldPoint point : WorldPoint.toLocalInstance(client, location)) {
            if (point.getPlane() != client.getPlane()) {
                continue;
            }

            LocalPoint lp = LocalPoint.fromWorld(client, point);
            if (lp == null) {
                continue;
            }

            Polygon poly = Perspective.getCanvasTilePoly(client, lp);
            if (poly == null) {
                continue;
            }

            if (draw) {
                graphics.setColor(color);
                graphics.fill(poly);
            }

            drawCounter(graphics, poly.getBounds().getCenterX(), poly.getBounds().getCenterY(), counter);
        }
    }

    private void drawLine(Graphics2D graphics, WorldPoint startLoc, WorldPoint endLoc, Color color, int counter) {
        WorldPoint start = WorldPoint.toLocalInstance(client, startLoc).iterator().next();
        WorldPoint end = WorldPoint.toLocalInstance(client, endLoc).iterator().next();

        final int z = client.getPlane();
        if (start.getPlane() != z) {
            return;
        }

        LocalPoint lpStart = LocalPoint.fromWorld(client, start);
        LocalPoint lpEnd = LocalPoint.fromWorld(client, end);

        if (lpStart == null || lpEnd == null) {
            return;
        }

        final int startHeight = Perspective.getTileHeight(client, lpStart, z);
        final int endHeight = Perspective.getTileHeight(client, lpEnd, z);

        Point p1 = Perspective.localToCanvas(client, lpStart.getX(), lpStart.getY(), startHeight);
        Point p2 = Perspective.localToCanvas(client, lpEnd.getX(), lpEnd.getY(), endHeight);

        if (p1 == null || p2 == null) {
            return;
        }

        Line2D.Double line = new Line2D.Double(p1.getX(), p1.getY(), p2.getX(), p2.getY());

        graphics.setColor(color);
        graphics.setStroke(new BasicStroke(4));
        graphics.draw(line);

        if (counter == 1) {
            drawCounter(graphics, p1.getX(), p1.getY(), 0);
        }
        drawCounter(graphics, p2.getX(), p2.getY(), counter);
    }

    private void drawCounter(Graphics2D graphics, double x, double y, int counter) {
        if (counter >= 0 && !TileCounter.DISABLED.equals(config.showTileCounter())) {
            int n = config.tileCounterStep() > 0 ? config.tileCounterStep() : 1;
            int s = plugin.getPathfinder().getPath().size();
            if ((counter % n != 0) && (s != (counter + 1))) {
                return;
            }
            if (TileCounter.REMAINING.equals(config.showTileCounter())) {
                counter = s - counter - 1;
            }
            if (n > 1 && counter == 0) {
                return;
            }
            String counterText = Integer.toString(counter);
            graphics.setColor(config.colourText());
            graphics.drawString(
                counterText,
                (int) (x - graphics.getFontMetrics().getStringBounds(counterText, graphics).getWidth() / 2), (int) y);
        }
    }

    private void drawFairyRingCode(Graphics2D graphics, WorldPoint location, WorldPoint locationEnd) {
        for (WorldPoint point : WorldPoint.toLocalInstance(client, location)) {
            for (WorldPoint pointEnd : WorldPoint.toLocalInstance(client, locationEnd))
            {
                if (point.getPlane() != client.getPlane()) {
                    continue;
                }

                String codeText;
                if (fairyRingCode(point) == null || (codeText = fairyRingCode(pointEnd)) == null) {
                    continue;
                }

                LocalPoint lp = LocalPoint.fromWorld(client, point);
                if (lp == null) {
                    continue;
                }

                Point p = Perspective.localToCanvas(client, lp, client.getPlane());
                if (p == null) {
                    continue;
                }

                Rectangle2D textBounds = graphics.getFontMetrics().getStringBounds(codeText, graphics);
                int x = (int) (p.getX() - textBounds.getWidth() / 2);
                int y = (int) (p.getY() - textBounds.getHeight());
                graphics.setColor(Color.BLACK);
                graphics.drawString(codeText, x + 1, y + 1);
                graphics.setColor(config.colourText());
                graphics.drawString(codeText, x, y);
            }
        }
    }

    private String fairyRingCode(WorldPoint point) {
        if (point == null) {
            return null;
        }

        List<WorldPoint> fairyRings = Transport.getFairyRings();

        for (int i = 0; i < fairyRings.size(); i++) {
            if (point.equals(fairyRings.get(i))) {
                return Transport.getFairyRingCodes().get(i);
            }
        }

        return null;
    }
}

package Posiedien_Leagues_Planner;

public enum TileCounter {
    DISABLED,
    TRAVELLED,
    REMAINING
}

package Posiedien_Leagues_Planner;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.worldmap.WorldMapOverlay;
import net.runelite.api.Point;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;

import javax.inject.Inject;
import javax.sound.sampled.Line;
import java.awt.*;
import java.awt.geom.Area;
import java.util.*;

public class RegionBoundOverlay extends Overlay
{
    private final Client client;
    private final PosiedienLeaguesPlannerPlugin plugin;
    private final LeaguesPlannerConfig config;
    @Inject
    private WorldMapOverlay worldMapOverlay;

    private Area WorldMapClipArea;

    @Inject
    public RegionBoundOverlay(Client Inclient, PosiedienLeaguesPlannerPlugin InPlugin, LeaguesPlannerConfig Inconfig)
    {
        client = Inclient;
        plugin = InPlugin;
        config = Inconfig;

        setPosition(OverlayPosition.DYNAMIC);
        setPriority(OverlayPriority.LOW);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    private Area ObtainWorldMapClipArea(Rectangle baseRectangle)
    {
        final Widget overview = client.getWidget(WidgetInfo.WORLD_MAP_OVERVIEW_MAP);
        final Widget surfaceSelector = client.getWidget(WidgetInfo.WORLD_MAP_SURFACE_SELECTOR);

        Area clipArea = new Area(baseRectangle);

        if (overview != null && !overview.isHidden()) {
            clipArea.subtract(new Area(overview.getBounds()));
        }

        if (surfaceSelector != null && !surfaceSelector.isHidden()) {
            clipArea.subtract(new Area(surfaceSelector.getBounds()));
        }

        return clipArea;
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (plugin.bIsInitializing)
        {
            return null;
        }

        if (client.getWidget(WidgetInfo.WORLD_MAP_VIEW) == null)
        {
            return null;
        }
        WorldMapClipArea = ObtainWorldMapClipArea(client.getWidget(WidgetInfo.WORLD_MAP_VIEW).getBounds());
        graphics.setClip(WorldMapClipArea);

        // Display a line for all of our connections
        for (LeagueRegionBounds regionDatum : config.RegionData.RegionData)
        {
            Color DrawColor = RegionType.GetRegionColor(config, regionDatum.Type, true);
            graphics.setColor(DrawColor);

            if (config.GetEditRegion() != RegionType.NONE)
            {
                for (RegionLine line : regionDatum.RegionLines)
                {
                    GraphicsLine convertedLine = line.ConvertToGraphicsLine(worldMapOverlay);
                    if (convertedLine != null)
                    {
                        graphics.drawLine(convertedLine.x1, convertedLine.y1, convertedLine.x2, convertedLine.y2);
                    }
                }
            }

            for (WorldPointPolygon WorldPointPoly : regionDatum.RegionPolygons)
            {
                Polygon convertedPoly = WorldPointPoly.ConvertToGraphicsPolygon(worldMapOverlay);
                if (convertedPoly != null)
                {
                    graphics.fillPolygon(convertedPoly);
                }
            }
        }

        return null;
    }
}

package Posiedien_Leagues_Planner;

import Posiedien_Leagues_Planner.pathfinder.Pathfinder;
import com.google.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.util.ArrayList;
import java.util.List;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;

public class PathMinimapOverlay extends Overlay {
    private static final int TILE_WIDTH = 4;
    private static final int TILE_HEIGHT = 4;

    private final Client client;
    private final PosiedienLeaguesPlannerPlugin plugin;
    private final LeaguesPlannerConfig config;

    @Inject
    private PathMinimapOverlay(Client client, PosiedienLeaguesPlannerPlugin plugin, LeaguesPlannerConfig config) {
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(OverlayPriority.LOW);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (plugin.bIsInitializing)
        {
            return null;
        }

        if (!config.drawMinimap() || (plugin.getPathfinder() == null && (plugin.panel.getPathfinderArray() == null || plugin.panel.getPathfinderArray().isEmpty()))) {
            return null;
        }

        graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);
        graphics.setClip(plugin.getMinimapClipArea());

        if (plugin.getPathfinder() != null)
        {
            List<WorldPoint> pathPoints = plugin.getPathfinder().getPath();
            Color pathColor = plugin.getPathfinder().isDone() ? config.colourPath() : config.colourPathCalculating();
            for (WorldPoint pathPoint : pathPoints) {
                if (pathPoint.getPlane() != client.getPlane()) {
                    continue;
                }

                drawOnMinimap(graphics, pathPoint, pathColor);
            }
        }

        ArrayList<Pathfinder> pathfinderArray = plugin.panel.getPathfinderArray() ;
        if (pathfinderArray != null)
        {
            for (Pathfinder CurrentPathfinder : pathfinderArray)
            {
                List<WorldPoint> pathPoints = CurrentPathfinder.getPath();
                Color pathColor = CurrentPathfinder.isDone() ? Color.RED : Color.CYAN;
                for (WorldPoint pathPoint : pathPoints)
                {
                    if (pathPoint.getPlane() != client.getPlane())
                    {
                        continue;
                    }

                    drawOnMinimap(graphics, pathPoint, pathColor);
                }
            }
        }

        return null;
    }

    private void drawOnMinimap(Graphics2D graphics, WorldPoint location, Color color) {
        for (WorldPoint point : WorldPoint.toLocalInstance(client, location)) {
            LocalPoint lp = LocalPoint.fromWorld(client, point);

            if (lp == null) {
                continue;
            }

            Point posOnMinimap = Perspective.localToMinimap(client, lp);

            if (posOnMinimap == null) {
                continue;
            }

            renderMinimapRect(client, graphics, posOnMinimap, TILE_WIDTH, TILE_HEIGHT, color);
        }
    }

    public static void renderMinimapRect(Client client, Graphics2D graphics, Point center, int width, int height, Color color) {
        double angle = client.getCameraYawTarget() * Math.PI / 1024.0d;

        graphics.setColor(color);
        graphics.rotate(angle, center.getX(), center.getY());
        graphics.fillRect(center.getX() - width / 2, center.getY() - height / 2, width, height);
        graphics.rotate(-angle, center.getX(), center.getY());
    }
}

package Posiedien_Leagues_Planner;

public class GraphicsLine {
    int x1;
    int x2;

    int y1;
    int y2;
}


package Posiedien_Leagues_Planner;

import net.runelite.api.Player;
import net.runelite.api.Point;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.worldmap.WorldMap;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.ui.components.IconTextField;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.plaf.FontUIResource;
import java.awt.*;
import java.awt.event.*;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.HashMap;
import java.util.UUID;

public class TaskSelectPanel extends JPanel
{
    private static final ImageIcon START_ICON = new ImageIcon(ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/start.png"));
    private static final ImageIcon UNCHECKED_ICON = new ImageIcon(ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/unchecked.png"));
    private static final ImageIcon CHECKED_ICON = new ImageIcon(ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/checked.png"));
    private static final ImageIcon HIDDEN_ICON = new ImageIcon(ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/HIDDEN.png"));
    private static final ImageIcon SHOWN_ICON = new ImageIcon(ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/SHOWN.png"));

    private static final ImageIcon LOCATE_ICON = new ImageIcon(ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/taskMarker.png"));
    private static final ImageIcon LOCATE_BEGINNER_ICON = new ImageIcon(ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/taskMarkerBeginner.png"));

    private static final ImageIcon LOCATE_EASY_ICON = new ImageIcon(ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/taskMarkerEasy.png"));

    private static final ImageIcon LOCATE_MEDIUM_ICON = new ImageIcon(ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/taskMarkerMedium.png"));

    private static final ImageIcon LOCATE_HARD_ICON = new ImageIcon(ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/taskMarkerHard.png"));

    private static final ImageIcon LOCATE_ELITE_ICON = new ImageIcon(ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/taskMarkerElite.png"));

    private static final ImageIcon LOCATE_MASTER_ICON = new ImageIcon(ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/taskMarkerMaster.png"));

    private static final ImageIcon LOCATE_CUSTOM_ICON = new ImageIcon(ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/taskMarker.png"));

    private static final ImageIcon CLOSE_ICON = new ImageIcon(ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/close.png"));

    public PosiedienLeaguesPlannerPlugin plugin;
    public TaskData taskData;

    public TaskSelectPanel(PosiedienLeaguesPlannerPlugin InPlugin, TaskData inTask)
    {
        this.plugin = InPlugin;
        this.taskData = inTask;

        setLayout(new BorderLayout(3, 0));
        setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH, 70));


        double ShortestDistance = 1000000;
        Player player = plugin.client.getLocalPlayer();
        if (player != null)
        {
            WorldPoint playerLocation = player.getWorldLocation();

            for (WorldPoint CurrentLocation : taskData.Locations)
            {
                double TaskDistance = CurrentLocation.distanceTo(playerLocation);
                if (TaskDistance < ShortestDistance)
                {
                    ShortestDistance = TaskDistance;
                }
            }

            for (WorldPoint CurrentLocation : taskData.OverworldLocations)
            {
                double TaskDistance = CurrentLocation.distanceTo(playerLocation);
                if (TaskDistance < ShortestDistance)
                {
                    ShortestDistance = TaskDistance;
                }
            }
        }

        double DistanceFromPlayer = ShortestDistance;
        String DistanceText;
        if (DistanceFromPlayer > 900000)
        {
            DistanceFromPlayer = 0;
        }

        if (DistanceFromPlayer == 0)
        {
            DistanceText = "?";
        }
        else
        {
            DistanceText = String.valueOf(DistanceFromPlayer);
        }

        Color color = Color.LIGHT_GRAY;

        JPanel ButtonCombo = new JPanel();
        ButtonCombo.setBorder(new EmptyBorder(0, 0, 0, 0));
        ButtonCombo.setLayout(new BorderLayout());

        JButton markHiddenButton = new JButton();
        markHiddenButton.setBorder(new EmptyBorder(10, 0, 10, 0));

        boolean bIsPlanned = plugin.config.UserData.PlannedTasks.containsKey(taskData.GUID);
        if (bIsPlanned)
        {
            color = TaskDifficulty.GetTaskDifficultyColor(taskData.Difficulty);
        }

        // completed go to the end
        boolean bIsCompleted = plugin.config.UserData.CompletedTasks.contains(taskData.GUID);
        if (bIsCompleted)
        {
            color = Color.GREEN;
        }

        boolean bIsHidden = plugin.config.UserData.HiddenTasks.contains(taskData.GUID);
        if (bIsHidden)
        {
            markHiddenButton.setIcon(HIDDEN_ICON);
            color = Color.BLACK;
        }
        else
        {
            markHiddenButton.setIcon(SHOWN_ICON);
        }

        if (taskData.bIsCustomTask)
        {
            TextField editableText = new TextField();
            editableText.setText(String.valueOf(taskData.TaskName));
            editableText.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            Font EditTestFont = new FontUIResource("EditTestFont", Font.TRUETYPE_FONT, 10);
            editableText.setFont(EditTestFont);

            editableText.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e)
                {
                    plugin.QueueRefresh();
                }
            });
            editableText.addTextListener(new TextListener()
            {
                @Override
                public void textValueChanged(TextEvent e)
                {
                    taskData.TaskName = ((TextField)(e.getSource())).getText();
                }

            });
            add(editableText, BorderLayout.CENTER);
        }
        else
        {
            String LabelString = "Dist: " + DistanceText + ", " + taskData.TaskName;
            JLabel nameLabel = new JLabel("<html>"+ LabelString +"</html>");
            nameLabel.setForeground(color);
            add(nameLabel, BorderLayout.CENTER);
        }

        markHiddenButton.addActionListener(e ->
        {
            boolean bLocalIsHidden = plugin.config.UserData.HiddenTasks.contains(taskData.GUID);
            if (bLocalIsHidden)
            {
                plugin.config.UserData.HiddenTasks.remove(taskData.GUID);
            }
            else
            {
                plugin.config.UserData.HiddenTasks.add(taskData.GUID);
                plugin.config.UserData.PlannedTasks.remove(taskData.GUID);
            }
            plugin.QueueRefresh();
        });
        ButtonCombo.add(markHiddenButton, BorderLayout.NORTH);

        JPanel ButtonComboContainer = new JPanel();
        ButtonComboContainer.setBorder(new EmptyBorder(0, 0, 0, 0));
        ButtonComboContainer.setLayout(new BorderLayout());

        JPanel ButtonCombo2 = new JPanel();
        ButtonCombo2.setBorder(new EmptyBorder(0, 0, 0, 0));
        ButtonCombo2.setLayout(new BorderLayout());

        JButton locateTaskButton = new JButton();
        locateTaskButton.setBorder(new EmptyBorder(3, 0, 3, 0));

        switch (taskData.Difficulty)
        {
            case BEGINNER:
                locateTaskButton.setIcon(LOCATE_BEGINNER_ICON);
                break;
            case EASY:
                locateTaskButton.setIcon(LOCATE_EASY_ICON);
                break;
            case MEDIUM:
                locateTaskButton.setIcon(LOCATE_MEDIUM_ICON);
                break;
            case HARD:
                locateTaskButton.setIcon(LOCATE_HARD_ICON);
                break;
            case ELITE:
                locateTaskButton.setIcon(LOCATE_ELITE_ICON);
                break;
            case MASTER:
                locateTaskButton.setIcon(LOCATE_MASTER_ICON);
                break;
            case CUSTOM:
                locateTaskButton.setIcon(LOCATE_ICON);
                break;
        }

        locateTaskButton.addActionListener(e ->
        {
            plugin.FocusOnTaskOnWorldMap(taskData);
        });

        JButton removeTaskFromPlanButton = new JButton();
        removeTaskFromPlanButton.setBorder(new EmptyBorder(3, 0, 3, 0));
        removeTaskFromPlanButton.setIcon(CLOSE_ICON);

        removeTaskFromPlanButton.addActionListener(e ->
        {
            boolean bLocalIsPlanned = plugin.config.UserData.PlannedTasks.containsKey(taskData.GUID);
            if (bLocalIsPlanned)
            {
                plugin.config.UserData.PlannedTasks.remove(taskData.GUID);
            }
            else if (taskData.bIsCustomTask)
            {
                plugin.config.UserData.CustomTasks.remove(taskData.GUID);
                plugin.config.UserData.PlannedTasks.remove(taskData.GUID);
                plugin.bMapDisplayPointsDirty = true;
            }
            plugin.QueueRefresh();
        });

        ButtonCombo2.add(locateTaskButton, BorderLayout.NORTH);
        if (bIsPlanned || taskData.bIsCustomTask)
        {
            ButtonCombo2.add(removeTaskFromPlanButton, BorderLayout.SOUTH);
        }

        if (bIsPlanned)
        {
            /* Priority input */
            TextField activeOrder = new TextField();
            activeOrder.setPreferredSize(new Dimension(markHiddenButton.getWidth(), 30));
            activeOrder.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            activeOrder.setText(String.valueOf(plugin.config.UserData.PlannedTasks.get(taskData.GUID).SortPriority));

            activeOrder.addTextListener(new TextListener()
            {
                @Override
                public void textValueChanged(TextEvent e)
                {

                    try
                    {
                        int i = Integer.parseInt(((TextField)(e.getSource())).getText());
                    }
                    catch (NumberFormatException nfe)
                    {
                        plugin.QueueRefresh();
                        return;
                    }


                    plugin.config.UserData.PlannedTasks.remove(taskData.GUID);
                    plugin.config.UserData.PlannedTasks.put(taskData.GUID, new TaskSortData(Integer.valueOf(((TextField)(e.getSource())).getText()), taskData.bIsCustomTask));
                    plugin.config.UserData.HiddenTasks.remove(taskData.GUID);
                    plugin.QueueRefresh();
                }

            });
            ButtonCombo.add(activeOrder, BorderLayout.SOUTH);
        }
        else
        {
            JButton startButton = new JButton();
            startButton.setBorder(new EmptyBorder(10, 0, 10, 0));
            startButton.setIcon(START_ICON);
            startButton.addActionListener(e ->
            {
                // Find greatest value of planned tasks
                int CurrentOrder = 0;

                for (HashMap.Entry<UUID, TaskSortData> mapElement : plugin.config.UserData.PlannedTasks.entrySet())
                {
                    if (mapElement.getValue().SortPriority > CurrentOrder)
                    {
                        CurrentOrder = mapElement.getValue().SortPriority;
                    }

                }

                plugin.config.UserData.PlannedTasks.put(taskData.GUID, new TaskSortData(CurrentOrder + 1, taskData.bIsCustomTask));
                plugin.config.UserData.HiddenTasks.remove(taskData.GUID);
                plugin.bMapDisplayPointsDirty = true;
                plugin.QueueRefresh();
            });
            ButtonCombo.add(startButton, BorderLayout.SOUTH);
        }

        ButtonComboContainer.add(ButtonCombo, BorderLayout.EAST);
        ButtonComboContainer.add(ButtonCombo2, BorderLayout.WEST);
        add(ButtonComboContainer, BorderLayout.LINE_END);
    }
}
/*
 * Copyright (c) 2021, Zoinkwiz <https://github.com/Zoinkwiz>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package Posiedien_Leagues_Planner;

import java.awt.Color;
import java.awt.Component;
import javax.swing.DefaultListCellRenderer;
import javax.swing.JList;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.Text;

public final class DropdownRenderer extends DefaultListCellRenderer
{
    @Override
    public Component getListCellRendererComponent(JList<?> list, Object o, int i, boolean isSelected, boolean b1) {
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setForeground(Color.WHITE);
        setBorder(new EmptyBorder(0, 0, 0, 0));

        if (!isSelected)
        {
            setBackground(ColorScheme.DARK_GRAY_COLOR);
            setForeground(Color.WHITE);
        }
        else
        {
            setBackground(list.getBackground());
            setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        }

        setText(Text.titleCase((Enum) o));

        return this;
    }
}
package Posiedien_Leagues_Planner;

import Posiedien_Leagues_Planner.pathfinder.Pathfinder;
import com.google.inject.Inject;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.geom.Area;
import java.util.ArrayList;
import java.util.List;
import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.worldmap.WorldMapOverlay;
import Posiedien_Leagues_Planner.pathfinder.CollisionMap;

public class PathMapOverlay extends Overlay {
    private final Client client;
    private final PosiedienLeaguesPlannerPlugin plugin;
    private final LeaguesPlannerConfig config;

    @Inject
    private WorldMapOverlay worldMapOverlay;

    @Inject
    private PathMapOverlay(Client client, PosiedienLeaguesPlannerPlugin plugin, LeaguesPlannerConfig config) {
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(OverlayPriority.LOW);
        setLayer(OverlayLayer.MANUAL);
        drawAfterLayer(WidgetInfo.WORLD_MAP_VIEW);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {

        if (plugin.bIsInitializing)
        {
            return null;
        }

        if (!config.drawMap()) {
            return null;
        }

        if (client.getWidget(WidgetInfo.WORLD_MAP_VIEW) == null) {
            return null;
        }

        Area worldMapClipArea = getWorldMapClipArea(client.getWidget(WidgetInfo.WORLD_MAP_VIEW).getBounds());
        graphics.setClip(worldMapClipArea);

        if (config.drawCollisionMap()) {
            graphics.setColor(config.colourCollisionMap());
            Rectangle extent = getWorldMapExtent(client.getWidget(WidgetInfo.WORLD_MAP_VIEW).getBounds());
            final CollisionMap map = plugin.getMap();
            final int z = client.getPlane();
            for (int x = extent.x; x < (extent.x + extent.width + 1); x++) {
                for (int y = extent.y - extent.height; y < (extent.y + 1); y++) {
                    if (map.isBlocked(x, y, z)) {
                        drawOnMap(graphics, new WorldPoint(x, y, z), false);
                    }
                }
            }
        }

        if (config.drawTransports()) {
            graphics.setColor(Color.WHITE);
            for (WorldPoint a : plugin.getTransports().keySet()) {
                Point mapA = worldMapOverlay.mapWorldPointToGraphicsPoint(a);
                if (mapA == null || !worldMapClipArea.contains(mapA.getX(), mapA.getY())) {
                    continue;
                }

                for (Transport b : plugin.getTransports().getOrDefault(a, new ArrayList<>())) {
                    Point mapB = worldMapOverlay.mapWorldPointToGraphicsPoint(b.getDestination());
                    if (mapB == null || !worldMapClipArea.contains(mapB.getX(), mapB.getY())) {
                        continue;
                    }

                    graphics.drawLine(mapA.getX(), mapA.getY(), mapB.getX(), mapB.getY());
                }
            }
        }

        if (plugin.getPathfinder() != null) {
            Color colour = plugin.getPathfinder().isDone() ? config.colourPath() : config.colourPathCalculating();
            List<WorldPoint> path = plugin.getPathfinder().getPath();
            for (int i = 0; i < path.size(); i++) {
                graphics.setColor(colour);
                WorldPoint point = path.get(i);
                WorldPoint last = (i > 0) ? path.get(i - 1) : point;
                if (point.distanceTo(last) > 1) {
                    drawOnMap(graphics, last, point, true);
                }
                drawOnMap(graphics, point, true);
            }
        }

        ArrayList<Pathfinder> pathfinderArray = plugin.panel.getPathfinderArray();
        if (pathfinderArray != null)
        {
            for (Pathfinder CurrentPathfinder : pathfinderArray)
            {
                Color colour = CurrentPathfinder.isDone() ? Color.RED : Color.CYAN;
                List<WorldPoint> path = CurrentPathfinder.getPath();
                for (int i = 0; i < path.size(); i++) {
                    graphics.setColor(colour);
                    WorldPoint point = path.get(i);
                    WorldPoint last = (i > 0) ? path.get(i - 1) : point;
                    if (point.distanceTo(last) > 1) {
                        drawOnMap(graphics, last, point, true);
                    }
                    drawOnMap(graphics, point, true);
                }
            }
        }

        return null;
    }

    private void drawOnMap(Graphics2D graphics, WorldPoint point, boolean checkHover) {
        drawOnMap(graphics, point, point.dx(1).dy(-1), checkHover);
    }

    private void drawOnMap(Graphics2D graphics, WorldPoint point, WorldPoint offset, boolean checkHover) {
        Point start = plugin.mapWorldPointToGraphicsPoint(point);
        Point end = plugin.mapWorldPointToGraphicsPoint(offset);

        if (start == null || end == null) {
            return;
        }

        int x = start.getX();
        int y = start.getY();
        final int width = end.getX() - x;
        final int height = end.getY() - y;
        x -= width / 2;
        y -= height / 2;

        if (point.distanceTo(offset) > 1) {
            graphics.setStroke(new BasicStroke(1, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0, new float[]{9}, 0));
            graphics.drawLine(start.getX(), start.getY(), end.getX(), end.getY());
        } else {
            Point cursorPos = client.getMouseCanvasPosition();
            if (checkHover &&
                cursorPos.getX() >= x && cursorPos.getX() <= (end.getX() - width / 2) &&
                cursorPos.getY() >= y && cursorPos.getY() <= (end.getY() - width / 2)) {
                graphics.setColor(graphics.getColor().darker());
            }
            graphics.fillRect(x, y, width, height);
        }
    }

    private Area getWorldMapClipArea(Rectangle baseRectangle) {
        final Widget overview = client.getWidget(WidgetInfo.WORLD_MAP_OVERVIEW_MAP);
        final Widget surfaceSelector = client.getWidget(WidgetInfo.WORLD_MAP_SURFACE_SELECTOR);

        Area clipArea = new Area(baseRectangle);

        if (overview != null && !overview.isHidden()) {
            clipArea.subtract(new Area(overview.getBounds()));
        }

        if (surfaceSelector != null && !surfaceSelector.isHidden()) {
            clipArea.subtract(new Area(surfaceSelector.getBounds()));
        }

        return clipArea;
    }

    private Rectangle getWorldMapExtent(Rectangle baseRectangle) {
        WorldPoint topLeft = plugin.calculateMapPoint(new Point(baseRectangle.x, baseRectangle.y));
        WorldPoint bottomRight = plugin.calculateMapPoint(
            new Point(baseRectangle.x + baseRectangle.width, baseRectangle.y + baseRectangle.height));
        return new Rectangle(topLeft.getX(), topLeft.getY(), bottomRight.getX() - topLeft.getX(), topLeft.getY() - bottomRight.getY());
    }
}

package Posiedien_Leagues_Planner;

import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.worldmap.WorldMapPoint;

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.UUID;

public class LeagueRegionPoint
{

    public UUID GUID = null;
    public ArrayList<LeagueRegionPoint> ConnectedPoints = new ArrayList<>();

    // Temporary for setup
    public ArrayList<UUID> ConnectedPointGUIDs = new ArrayList<>();

    public WorldMapPoint OurPoint = null;
    public WorldPoint OurWorldPoint = null;

    RegionType Region = null;

    public String ExportData()
    {
        StringBuilder Converted = new StringBuilder();

        Converted.append(GUID);
        Converted.append(",");

        Converted.append(Region);
        Converted.append(",");

        Converted.append(ConnectedPoints.size());
        Converted.append(",");

        for (LeagueRegionPoint ConnectedPoint : ConnectedPoints)
        {
            Converted.append(ConnectedPoint.GUID);
            Converted.append(",");
        }

        Converted.append(OurWorldPoint.getX());
        Converted.append(",");

        Converted.append(OurWorldPoint.getY());
        Converted.append(",");

        Converted.append(OurWorldPoint.getPlane());
        Converted.append(",");

        return Converted.toString();
    }

    public void ImportData(Scanner sc)
    {
        GUID = UUID.fromString(sc.next());

        Region = RegionType.valueOf((sc.next()));

        int ConnectedPointsSize = Integer.parseInt(sc.next());
        for (int i = 0; i < ConnectedPointsSize; ++i)
        {
            ConnectedPointGUIDs.add(UUID.fromString(sc.next()));
        }

        OurWorldPoint = new WorldPoint(
                Integer.parseInt(sc.next()),
                Integer.parseInt(sc.next()),
                Integer.parseInt(sc.next()));
    }
}

package Posiedien_Leagues_Planner;

import lombok.Getter;
import lombok.Setter;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.ComponentConstants;
import net.runelite.client.ui.overlay.components.LayoutableRenderableEntity;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import Posiedien_Leagues_Planner.pathfinder.Pathfinder;

import javax.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.util.List;

public class DebugOverlayPanel extends OverlayPanel {
    private final PosiedienLeaguesPlannerPlugin plugin;
    private final SeparatorLine separator;

    @Inject
    public DebugOverlayPanel(PosiedienLeaguesPlannerPlugin plugin) {
        super(plugin);
        this.plugin = plugin;

        separator = new SeparatorLine();
        separator.setColor(new Color(0, true)); // Invisible color

        setPosition(OverlayPosition.TOP_LEFT);
    }

    private LineComponent makeLine(String left, String right) {
        return LineComponent.builder()
                .left(left)
                .right(right)
                .build();
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (plugin.bIsInitializing)
        {
            return null;
        }

        Pathfinder pathfinder = plugin.getPathfinder();
        Pathfinder.PathfinderStats stats;
        if (pathfinder == null || (stats = pathfinder.getStats()) == null) {
            return null;
        }

        List<LayoutableRenderableEntity> components = panelComponent.getChildren();

        components.add(
                TitleComponent.builder()
                        .text("Shortest Path Debug")
                        .color(Color.ORANGE)
                        .build()
        );

        components.add(separator);

        String pathLength = Integer.toString(pathfinder.getPath().size());
        components.add(makeLine("Path Length:", pathLength));

        components.add(separator);

        String nodes = Integer.toString(stats.getNodesChecked());
        components.add(makeLine("Nodes:", nodes));

        String transports = Integer.toString(stats.getTransportsChecked());
        components.add(makeLine("Transports:", transports));

        String totalNodes = Integer.toString(stats.getTotalNodesChecked());
        components.add(makeLine("Total:", totalNodes));

        components.add(separator);

        double milliTime = stats.getElapsedTimeNanos() / 1000000.0;
        String time = String.format("%.2fms", milliTime);
        components.add(makeLine("Time:", time));

        return super.render(graphics);
    }

    @Setter
    private static class SeparatorLine implements LayoutableRenderableEntity {
        private Color color = Color.GRAY;
        private Point preferredLocation = new Point();
        private Dimension preferredSize = new Dimension(ComponentConstants.STANDARD_WIDTH, 4);

        @Getter
        private final Rectangle bounds = new Rectangle();

        @Override
        public Dimension render(Graphics2D graphics)
        {
            final int separatorX = preferredLocation.x;
            final int separatorY = preferredLocation.y + 4;
            final int width = preferredSize.width;
            final int height = Math.max(preferredSize.height, 2);

            // Draw bar
            if (color != null && color.getAlpha() != 0) {
                graphics.setColor(color);
                graphics.fillRect(separatorX, separatorY, width, height);
            }

            final Dimension dimension = new Dimension(width, height + 4);
            bounds.setLocation(preferredLocation);
            bounds.setSize(dimension);

            return dimension;
        }
    }
}

package Posiedien_Leagues_Planner;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;

public class Util {
    public static byte[] readAllBytes(InputStream in) throws IOException {
        ByteArrayOutputStream result = new ByteArrayOutputStream();
        byte[] buffer = new byte[1024];

        while (true) {
            int read = in.read(buffer, 0, buffer.length);

            if (read == -1) {
                return result.toByteArray();
            }

            result.write(buffer, 0, read);
        }
    }
}

package Posiedien_Leagues_Planner;

import Posiedien_Leagues_Planner.pathfinder.Pathfinder;
import Posiedien_Leagues_Planner.pathfinder.PathfinderConfig;
import Posiedien_Leagues_Planner.pathfinder.SplitFlagMap;
import com.google.common.util.concurrent.ThreadFactoryBuilder;
import lombok.Getter;
import net.runelite.api.Player;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.nio.file.Path;
import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ThreadFactory;

public class LeaguesPlannerPanel extends PluginPanel
{
    private LeaguesPlannerConfig config = null;
    private PosiedienLeaguesPlannerPlugin plugin = null;
    private final FixedWidthPanel taskOverviewWrapper = new FixedWidthPanel();

    private JPanel NoSearchPanel = new JPanel();
    private final FixedWidthPanel taskListWrapper = new FixedWidthPanel();

    private static final ImageIcon START_ICON = new ImageIcon(ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/start.png"));
    private static final ImageIcon UNCHECKED_ICON = new ImageIcon(ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/unchecked.png"));
    private static final ImageIcon CHECKED_ICON = new ImageIcon(ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/checked.png"));

    private final JPanel allDropdownSections = new JPanel();
    private final JPanel allDropdownSections2 = new JPanel();
    private final JComboBox<Enum> filterDropdown;
    private final JComboBox<Enum> filterDropdown2;
    private final JComboBox<Enum> filterDropdown3;
    private final JComboBox<Enum> filterDropdown4;
    private JPanel searchTasksPanel;


    private final FixedWidthPanel regionsUnlockedListPanel = new FixedWidthPanel();
    private final FixedWidthPanel taskListPanel = new FixedWidthPanel();
    private final JScrollPane scrollableContainer;
    private final JScrollPane regionUnlockedScrollableContainer;
    private final int DROPDOWN_HEIGHT = 20;

    public Thread longRunningTask = null;
    public SplitFlagMap NewMap = null;


    JButton autostartButton = new JButton();
    public ActionListener autoRecalculateCallback = e->
            {
                plugin.enableAutoRecalculate = !plugin.enableAutoRecalculate;
                if (plugin.enableAutoRecalculate)
                {
                    autostartButton.setIcon(CHECKED_ICON);
                }
                else
                {
                    autostartButton.setIcon(UNCHECKED_ICON);
                }

                plugin.QueueRefresh();
            };


    JButton misthalinUnlockedButton = new JButton();
    public ActionListener misthalinUnlockedCallback = e->
    {
        plugin.getConfigManager().setConfiguration(
                PosiedienLeaguesPlannerPlugin.CONFIG_GROUP,
                "MisthalinUnlocked",
                !config.MisthalinUnlocked());

        if (config.MisthalinUnlocked())
        {
            misthalinUnlockedButton.setIcon(CHECKED_ICON);
        }
        else
        {
            misthalinUnlockedButton.setIcon(UNCHECKED_ICON);
        }

        RecreateBoundData();
        plugin.QueueRefresh();
    };

    public void RecreateBoundData()
    {
        if (NewMap != null && longRunningTask != null && longRunningTask.isAlive())
        {
            NewMap.cancel();
            longRunningTask.interrupt();
        }

        NewMap = SplitFlagMap.fromResources(plugin, config);

        longRunningTask = new Thread(NewMap);
        longRunningTask.start();
    }

    JButton karamjaUnlockedButton = new JButton();

    public ActionListener karamjaUnlockedCallback = e->
    {
        plugin.getConfigManager().setConfiguration(
                PosiedienLeaguesPlannerPlugin.CONFIG_GROUP,
                "KaramjaUnlocked",
                !config.KaramjaUnlocked());

        if (config.KaramjaUnlocked())
        {
            karamjaUnlockedButton.setIcon(CHECKED_ICON);
        }
        else
        {
            karamjaUnlockedButton.setIcon(UNCHECKED_ICON);
        }

        RecreateBoundData();
        plugin.QueueRefresh();
    };

    JButton kandarinUnlockedButton = new JButton();
    public ActionListener kandarinUnlockedCallback = e->
    {
        plugin.getConfigManager().setConfiguration(
                PosiedienLeaguesPlannerPlugin.CONFIG_GROUP,
                "KandarinUnlocked",
                !config.KandarinUnlocked());

        if (config.KandarinUnlocked())
        {
            kandarinUnlockedButton.setIcon(CHECKED_ICON);
        }
        else
        {
            kandarinUnlockedButton.setIcon(UNCHECKED_ICON);
        }

        RecreateBoundData();
        plugin.QueueRefresh();
    };

    JButton asgarniaUnlockedButton = new JButton();
    public ActionListener asgarniaUnlockedCallback = e->
    {
        plugin.getConfigManager().setConfiguration(
                PosiedienLeaguesPlannerPlugin.CONFIG_GROUP,
                "AsgarniaUnlocked",
                !config.AsgarniaUnlocked());

        if (config.AsgarniaUnlocked())
        {
            asgarniaUnlockedButton.setIcon(CHECKED_ICON);
        }
        else
        {
            asgarniaUnlockedButton.setIcon(UNCHECKED_ICON);
        }

        RecreateBoundData();
        plugin.QueueRefresh();
    };

    JButton fremennikUnlockedButton = new JButton();
    public ActionListener fremennikUnlockedCallback = e->
    {
        plugin.getConfigManager().setConfiguration(
                PosiedienLeaguesPlannerPlugin.CONFIG_GROUP,
                "FremennikUnlocked",
                !config.FremennikUnlocked());

        if (config.FremennikUnlocked())
        {
            fremennikUnlockedButton.setIcon(CHECKED_ICON);
        }
        else
        {
            fremennikUnlockedButton.setIcon(UNCHECKED_ICON);
        }

        RecreateBoundData();
        plugin.QueueRefresh();
    };

    JButton kourendUnlockedButton = new JButton();
    public ActionListener kourendUnlockedCallback = e->
    {
        plugin.getConfigManager().setConfiguration(
                PosiedienLeaguesPlannerPlugin.CONFIG_GROUP,
                "KourendUnlocked",
                !config.KourendUnlocked());

        if (config.KourendUnlocked())
        {
            kourendUnlockedButton.setIcon(CHECKED_ICON);
        }
        else
        {
            kourendUnlockedButton.setIcon(UNCHECKED_ICON);
        }

        RecreateBoundData();
        plugin.QueueRefresh();
    };

    JButton wildernessUnlockedButton = new JButton();
    public ActionListener wildernessUnlockedCallback = e->
    {
        plugin.getConfigManager().setConfiguration(
                PosiedienLeaguesPlannerPlugin.CONFIG_GROUP,
                "WildernessUnlocked",
                !config.WildernessUnlocked());

        if (config.WildernessUnlocked())
        {
            wildernessUnlockedButton.setIcon(CHECKED_ICON);
        }
        else
        {
            wildernessUnlockedButton.setIcon(UNCHECKED_ICON);
        }

        RecreateBoundData();
        plugin.QueueRefresh();
    };

    JButton morytaniaUnlockedButton = new JButton();
    public ActionListener morytaniaUnlockedCallback = e->
    {
        plugin.getConfigManager().setConfiguration(
                PosiedienLeaguesPlannerPlugin.CONFIG_GROUP,
                "MorytaniaUnlocked",
                !config.MorytaniaUnlocked());

        if (config.MorytaniaUnlocked())
        {
            morytaniaUnlockedButton.setIcon(CHECKED_ICON);
        }
        else
        {
            morytaniaUnlockedButton.setIcon(UNCHECKED_ICON);
        }

        RecreateBoundData();
        plugin.QueueRefresh();
    };

    JButton tirannwnUnlockedButton = new JButton();
    public ActionListener tirannwnUnlockedCallback = e->
    {
        plugin.getConfigManager().setConfiguration(
                PosiedienLeaguesPlannerPlugin.CONFIG_GROUP,
                "TirannwnUnlocked",
                !config.TirannwnUnlocked());

        if (config.TirannwnUnlocked())
        {
            tirannwnUnlockedButton.setIcon(CHECKED_ICON);
        }
        else
        {
            tirannwnUnlockedButton.setIcon(UNCHECKED_ICON);
        }

        RecreateBoundData();
        plugin.QueueRefresh();
    };

    JButton desertUnlockedButton = new JButton();
    public ActionListener desertUnlockedCallback = e->
    {
        plugin.getConfigManager().setConfiguration(
                PosiedienLeaguesPlannerPlugin.CONFIG_GROUP,
                "DesertUnlocked",
                !config.DesertUnlocked());

        if (config.DesertUnlocked())
        {
            desertUnlockedButton.setIcon(CHECKED_ICON);
        }
        else
        {
            desertUnlockedButton.setIcon(UNCHECKED_ICON);
        }

        RecreateBoundData();
        plugin.QueueRefresh();
    };


    public JPanel CreateClickableOption(JButton inJButton, String OptionName, boolean bInitialValue, Color ForegroundColor, Color BackgroundColor, ActionListener Callback)
    {
        JPanel buttonPanel = new JPanel();
        buttonPanel.setBorder(new EmptyBorder(5, 10, 5, 10));
        buttonPanel.setLayout(new BorderLayout());

        JLabel buttonPanelLabel = new JLabel();
        buttonPanelLabel.setText(OptionName);
        buttonPanelLabel.setBorder(new EmptyBorder(5, 10, 5, 10));
        buttonPanelLabel.setLayout(new BorderLayout(0, BORDER_OFFSET));

        int R = ForegroundColor.getRed();
        int G = ForegroundColor.getGreen();
        int B = ForegroundColor.getBlue();

        // Adjust to make sure its bright
        int MaxVal = Math.max(Math.max(R, G), B);
        int Adjuster = 255 - MaxVal;

        Color ConvertedColor = new Color(R + Adjuster,G + Adjuster,B + Adjuster , 255);

        buttonPanelLabel.setForeground(ConvertedColor);
        buttonPanelLabel.setBackground(BackgroundColor);
        buttonPanel.add(buttonPanelLabel, BorderLayout.WEST);

        if (bInitialValue)
        {
            inJButton.setIcon(CHECKED_ICON);
        }
        else
        {
            inJButton.setIcon(UNCHECKED_ICON);
        }

        inJButton.setBorder(new EmptyBorder(5, 10, 5, 10));
        inJButton.setLayout(new BorderLayout(0, BORDER_OFFSET));
        inJButton.addActionListener(Callback);
        buttonPanel.add(inJButton, BorderLayout.EAST);

        return buttonPanel;
    }


    public ItemListener filterCallbackDifficulty = e->
    {
        if (e.getStateChange() == ItemEvent.SELECTED)
        {
            Enum source = (Enum) e.getItem();
            plugin.getConfigManager().setConfiguration(
                    PosiedienLeaguesPlannerPlugin.CONFIG_GROUP,
                    "FilteredDifficulty",
                    source);

            plugin.QueueRefresh();
        }

    };

    public ItemListener filterCallbackOther = e->
    {
        if (e.getStateChange() == ItemEvent.SELECTED)
        {
            Enum source = (Enum) e.getItem();
            plugin.getConfigManager().setConfiguration(
                    PosiedienLeaguesPlannerPlugin.CONFIG_GROUP,
                    "FilteredOther",
                    source);

            plugin.QueueRefresh();
        }

    };

    public ItemListener filterCallbackRequirements = e->
    {
        if (e.getStateChange() == ItemEvent.SELECTED)
        {
            Enum source = (Enum) e.getItem();
            plugin.getConfigManager().setConfiguration(
                    PosiedienLeaguesPlannerPlugin.CONFIG_GROUP,
                    "FilteredRequirements",
                    source);

            plugin.QueueRefresh();
        }

    };

    public ItemListener filterCallbackSort = e->
    {
        if (e.getStateChange() == ItemEvent.SELECTED)
        {
            Enum source = (Enum) e.getItem();
            plugin.getConfigManager().setConfiguration(
                    PosiedienLeaguesPlannerPlugin.CONFIG_GROUP,
                    "TaskSort",
                    source);

            plugin.QueueRefresh();
        }

    };

    public LeaguesPlannerPanel(PosiedienLeaguesPlannerPlugin plugin)
    {
        super(false);

        this.plugin = plugin;
        this.config = plugin.config;

        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new BorderLayout());

        /* Setup overview panel */
        JPanel titlePanel = new JPanel();
        titlePanel.setBorder(new EmptyBorder(10, 10, 5, 10));
        titlePanel.setLayout(new BorderLayout());

        JLabel title = new JLabel();
        title.setText("Posiedien's Leagues Planner");
        title.setForeground(Color.WHITE);
        titlePanel.add(title, BorderLayout.WEST);

        // Options
        final JPanel viewControls = new JPanel(new GridLayout(1, 3, 5, 0));
        viewControls.setBackground(ColorScheme.DARK_GRAY_COLOR);

        titlePanel.add(viewControls, BorderLayout.EAST);

        JLabel pleaseLoginLabel = new JLabel();
        pleaseLoginLabel.setForeground(Color.GRAY);
        pleaseLoginLabel.setText("<html><body style='text-align:left'>Please log in to use the leagues planner plugin" +
                ".</body></html>");

        NoSearchPanel.setLayout(new BorderLayout());
        NoSearchPanel.setBorder(new EmptyBorder(5, 10, 5, 10));
        NoSearchPanel.add(pleaseLoginLabel);
        NoSearchPanel.setVisible(false);

/*
        JPanel reloadActionsPanel = new JPanel();
        reloadActionsPanel.setBorder(new EmptyBorder(5, 10, 5, 10));
        reloadActionsPanel.setLayout(new BorderLayout());
        JLabel reloadallActions = new JLabel();
        reloadallActions.setText("Reload all Actions -> ");
        reloadallActions.setForeground(Color.WHITE);
        reloadallActions.setBorder(new EmptyBorder(5, 10, 5, 10));
        reloadallActions.setLayout(new BorderLayout(0, BORDER_OFFSET));
        reloadActionsPanel.add(reloadallActions, BorderLayout.WEST);
        JButton reloadbutton = new JButton();
        reloadbutton.setIcon(START_ICON);
        reloadbutton.setBorder(new EmptyBorder(5, 10, 5, 10));
        reloadbutton.setLayout(new BorderLayout(0, BORDER_OFFSET));
        reloadbutton.addActionListener(e ->
        {
            plugin.QueueRefresh();
            plugin.CurrentStepSelected = null;
            if (plugin.getSelectedQuest() != null)
            {
                plugin.getSelectedQuest().setCurrentStep(questHelperPlugin.OldStepSelected);
            }

            plugin.startUpQuest(null);
            plugin.recreateActions();
            plugin.loadQuestList = true;
            plugin.MarkUIAndActionRefresh(true, true);
        });
        reloadActionsPanel.add(reloadbutton, BorderLayout.EAST);
*/

        JPanel recalculatePanel = new JPanel();
        recalculatePanel.setBorder(new EmptyBorder(5, 10, 5, 10));
        recalculatePanel.setLayout(new BorderLayout());

        JLabel RecaculateLabel = new JLabel();
        RecaculateLabel.setText("Refresh Panel -> ");
        RecaculateLabel.setBorder(new EmptyBorder(5, 10, 5, 10));
        RecaculateLabel.setLayout(new BorderLayout(0, BORDER_OFFSET));
        RecaculateLabel.setForeground(Color.WHITE);
        recalculatePanel.add(RecaculateLabel, BorderLayout.WEST);

        JButton startButton = new JButton();
        startButton.setIcon(START_ICON);
        startButton.setBorder(new EmptyBorder(5, 10, 5, 10));
        startButton.setLayout(new BorderLayout(0, BORDER_OFFSET));
        startButton.addActionListener(e ->
        {
            plugin.QueueRefresh();
            /*plugin.loadQuestList = true;
            plugin.updateShortestPath();
            plugin.MarkUIAndActionRefresh(true, true);*/
        });
        recalculatePanel.add(startButton, BorderLayout.EAST);

        searchTasksPanel = new JPanel();
        searchTasksPanel.setBorder(new EmptyBorder(5, 10, 5, 10));
        searchTasksPanel.setLayout(new BorderLayout(0, BORDER_OFFSET));
        searchTasksPanel.add(NoSearchPanel, BorderLayout.SOUTH);

        taskListPanel.setBorder(new EmptyBorder(8, 10, 0, 10));
        taskListPanel.setLayout(new DynamicGridLayout(0, 1, 0, 5));
        taskListPanel.setAlignmentX(Component.LEFT_ALIGNMENT);

        // Filters
        filterDropdown = makeNewDropdown(TaskDifficulty.values(), "filterListBy", filterCallbackDifficulty);
        JPanel filtersPanel = makeDropdownPanel(filterDropdown, "Difficulty Filter");
        filtersPanel.setPreferredSize(new Dimension(PANEL_WIDTH, DROPDOWN_HEIGHT));

        filterDropdown2 = makeNewDropdown(OtherFilter.values(), "filterListBy2", filterCallbackOther);
        JPanel filtersPanel2 = makeDropdownPanel(filterDropdown2, "Planning Filter");
        filtersPanel2.setPreferredSize(new Dimension(PANEL_WIDTH, DROPDOWN_HEIGHT));

        filterDropdown4 = makeNewDropdown(FilterRequirements.values(), "filterListBy4", filterCallbackRequirements);
        JPanel filtersPanel4 = makeDropdownPanel(filterDropdown4, "Skill Req Filter");
        filtersPanel4.setPreferredSize(new Dimension(PANEL_WIDTH, DROPDOWN_HEIGHT));

        filterDropdown3 = makeNewDropdown(TaskSortMethod.values(), "filterListBy3", filterCallbackSort);
        JPanel filtersPanel3 = makeDropdownPanel(filterDropdown3, "Task Sort Method");
        filtersPanel3.setPreferredSize(new Dimension(PANEL_WIDTH, DROPDOWN_HEIGHT));

        allDropdownSections.setBorder(new EmptyBorder(0, 0, 10, 0));
        allDropdownSections.setLayout(new BorderLayout(0, 0));

        allDropdownSections2.setBorder(new EmptyBorder(0, 0, 10, 0));
        allDropdownSections2.setLayout(new BorderLayout(0, 0));

        allDropdownSections.add(filtersPanel, BorderLayout.NORTH);
        allDropdownSections.add(filtersPanel2, BorderLayout.SOUTH);
        allDropdownSections2.add(filtersPanel4, BorderLayout.NORTH);
        allDropdownSections2.add(filtersPanel3, BorderLayout.SOUTH);

        searchTasksPanel.add(allDropdownSections, BorderLayout.NORTH);
        searchTasksPanel.add(allDropdownSections2, BorderLayout.CENTER);

        // Wrapper
        taskListWrapper.setLayout(new BorderLayout());
        taskListWrapper.add(taskListPanel, BorderLayout.NORTH);

        scrollableContainer = new JScrollPane(taskListWrapper);
        scrollableContainer.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);


        JPanel OptionsPanel = new JPanel();
        OptionsPanel.setLayout(new BorderLayout());

        JPanel introOptionsPanel = new JPanel();
        introOptionsPanel.setLayout(new BorderLayout());
        introOptionsPanel.add(titlePanel, BorderLayout.NORTH);
        //introOptionsPanel.add(reloadActionsPanel, BorderLayout.CENTER);
        introOptionsPanel.add(recalculatePanel, BorderLayout.SOUTH);

        OptionsPanel.add(introOptionsPanel, BorderLayout.NORTH);

        JPanel autoRecalculatePanel = CreateClickableOption(autostartButton, "Enable Auto Refresh -> ", plugin.enableAutoRecalculate, Color.WHITE, Color.DARK_GRAY, autoRecalculateCallback);
        OptionsPanel.add(autoRecalculatePanel, BorderLayout.SOUTH);

        regionsUnlockedListPanel.setBorder(new EmptyBorder(8, 10, 0, 10));
        regionsUnlockedListPanel.setLayout(new DynamicGridLayout(0, 1, 0, 5));
        regionsUnlockedListPanel.setAlignmentX(Component.LEFT_ALIGNMENT);

        JLabel RegionsUnlockedtitle = new JLabel();
        RegionsUnlockedtitle.setText("- Regions Unlocked -");
        RegionsUnlockedtitle.setForeground(Color.WHITE);

        regionsUnlockedListPanel.add(RegionsUnlockedtitle);

        JPanel misthalinPanel = CreateClickableOption(misthalinUnlockedButton, "Misthalin Unlocked ", config.MisthalinUnlocked(), RegionType.GetRegionColor(config, RegionType.MISTHALIN, false), Color.WHITE, misthalinUnlockedCallback);
        regionsUnlockedListPanel.add(misthalinPanel);

        JPanel karamjaPanel = CreateClickableOption(karamjaUnlockedButton, "Karamja Unlocked ", config.KaramjaUnlocked(), RegionType.GetRegionColor(config, RegionType.KARAMJA, false), Color.WHITE,karamjaUnlockedCallback);
        regionsUnlockedListPanel.add(karamjaPanel);

        JPanel kandarinPanel = CreateClickableOption(kandarinUnlockedButton, "Kandarin Unlocked ", config.KandarinUnlocked(), RegionType.GetRegionColor(config, RegionType.KANDARIN, false), Color.WHITE,kandarinUnlockedCallback);
        regionsUnlockedListPanel.add(kandarinPanel);

        JPanel asgarniaPanel = CreateClickableOption(asgarniaUnlockedButton, "Asgarnia Unlocked ", config.AsgarniaUnlocked(), RegionType.GetRegionColor(config, RegionType.ASGARNIA, false), Color.WHITE,asgarniaUnlockedCallback);
        regionsUnlockedListPanel.add(asgarniaPanel);

        JPanel fremennikPanel = CreateClickableOption(fremennikUnlockedButton, "Fremennik Unlocked ", config.FremennikUnlocked(), RegionType.GetRegionColor(config, RegionType.FREMENNIK, false), Color.WHITE,fremennikUnlockedCallback);
        regionsUnlockedListPanel.add(fremennikPanel);

        JPanel kourendPanel = CreateClickableOption(kourendUnlockedButton, "Kourend Unlocked ", config.KourendUnlocked(), RegionType.GetRegionColor(config, RegionType.KOUREND, false), Color.WHITE,kourendUnlockedCallback);
        regionsUnlockedListPanel.add(kourendPanel);

        JPanel wildernessPanel = CreateClickableOption(wildernessUnlockedButton, "Wilderness Unlocked ", config.WildernessUnlocked(), RegionType.GetRegionColor(config, RegionType.WILDERNESS, false), Color.WHITE,wildernessUnlockedCallback);
        regionsUnlockedListPanel.add(wildernessPanel);

        JPanel morytaniaPanel = CreateClickableOption(morytaniaUnlockedButton, "Morytania Unlocked ", config.MorytaniaUnlocked(), RegionType.GetRegionColor(config, RegionType.MORYTANIA, false), Color.WHITE,morytaniaUnlockedCallback);
        regionsUnlockedListPanel.add(morytaniaPanel);

        JPanel tirannwnPanel = CreateClickableOption(tirannwnUnlockedButton, "Tirannwn Unlocked ", config.TirannwnUnlocked(), RegionType.GetRegionColor(config, RegionType.TIRANNWN, false), Color.WHITE,tirannwnUnlockedCallback);
        regionsUnlockedListPanel.add(tirannwnPanel);

        JPanel desertPanel = CreateClickableOption(desertUnlockedButton, "Desert Unlocked ", config.DesertUnlocked(), RegionType.GetRegionColor(config, RegionType.DESERT, false), Color.WHITE,desertUnlockedCallback);
        regionsUnlockedListPanel.add(desertPanel);

        regionUnlockedScrollableContainer = new JScrollPane(regionsUnlockedListPanel);
        regionUnlockedScrollableContainer.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        JPanel introDetailsPanel = new JPanel();
        introDetailsPanel.setLayout(new BorderLayout());
        introDetailsPanel.add(OptionsPanel, BorderLayout.NORTH);
        introDetailsPanel.add(regionUnlockedScrollableContainer, BorderLayout.CENTER);
        introDetailsPanel.add(searchTasksPanel, BorderLayout.SOUTH);

        add(introDetailsPanel, BorderLayout.NORTH);
        add(scrollableContainer, BorderLayout.CENTER);

        /* Layout */

        taskOverviewWrapper.setLayout(new BorderLayout());
    }

    private JPanel makeDropdownPanel(JComboBox dropdown, String name)
    {
        // Filters
        JLabel filterName = new JLabel(name);
        filterName.setForeground(Color.WHITE);

        JPanel filtersPanel = new JPanel();
        filtersPanel.setLayout(new BorderLayout());
        filtersPanel.setMinimumSize(new Dimension(PANEL_WIDTH, 0));
        filtersPanel.add(filterName, BorderLayout.CENTER);
        filtersPanel.add(dropdown, BorderLayout.EAST);

        return filtersPanel;
    }

    private JComboBox<Enum> makeNewDropdown(Enum[] values, String key, ItemListener callback)
    {
        JComboBox<Enum> dropdown = new JComboBox<>(values);
        dropdown.setFocusable(false);
        dropdown.setForeground(Color.WHITE);
        dropdown.setRenderer(new DropdownRenderer());
        dropdown.addItemListener(callback);

        return dropdown;
    }

    ArrayList<TaskSelectPanel> FilteredTaskListPanels = new ArrayList<>();

    public void CacheFilteredTaskList()
    {
        FilteredTaskListPanels.clear();

        TaskDifficulty DiffFilter = config.FilteredDifficulty();
        OtherFilter OthFilter = config.FilteredOther();
        FilterRequirements ReqFilter = config.FilteredRequirements();

        // Go through all of our tasks and filter out anything that doesn't belong
        for (SortedTask SortedTaskIter : config.TaskData.SortedLeaguesTaskList)
        {
            TaskData data = plugin.GetTaskData(SortedTaskIter.TaskGUID, SortedTaskIter.bIsCustomTask);

            // Skip due to some filter
            boolean bIsPartOfPlan = config.UserData.PlannedTasks.containsKey(SortedTaskIter.TaskGUID);
            if (!bIsPartOfPlan && DiffFilter != TaskDifficulty.NONE && DiffFilter != data.Difficulty)
            {
                continue;
            }

            int ReqDifferent = data.CalculateNeededRequirementsForTask(plugin.client);
            if (ReqFilter == FilterRequirements.MEETS_REQ)
            {
                if (ReqDifferent != 0)
                {
                    continue;
                }
            }
            else if (ReqFilter == FilterRequirements.NEAR_REQ)
            {
                // 10 levels away
                if (ReqDifferent > 10)
                {
                    continue;
                }
            }


            if (OthFilter == OtherFilter.ONLY_PLAN)
            {
                if (!bIsPartOfPlan)
                {
                    continue;
                }
            }

            boolean bSkipTask = false;
            for (RegionType ReqRegion : data.Regions)
            {
                if (!RegionType.GetRegionUnlocked(config, ReqRegion))
                {
                    bSkipTask = true;
                    break;
                }
            }

            // Go through all the task locations
            int PointsInRegions = 0;
            for (WorldPoint TaskWorldPoint : data.Locations)
            {
                if (config.RegionData.IsTileInUnlockedRegion(config, TaskWorldPoint))
                {
                    ++PointsInRegions;
                }
            }

            // Go through all the task overworld location
            for (WorldPoint TaskOverworldWorldPoint : data.OverworldLocations)
            {
                if (config.RegionData.IsTileInUnlockedRegion(config, TaskOverworldWorldPoint))
                {
                    ++PointsInRegions;
                }
            }

            if (!data.Locations.isEmpty() && PointsInRegions == 0)
            {
                bSkipTask = true;
            }

            if (bSkipTask)
            {
                continue;
            }

            FilteredTaskListPanels.add(new TaskSelectPanel(plugin, data));
        }
    }


    public void ApplyFilteredTaskListToPanel()
    {
        taskListPanel.removeAll();
        FilteredTaskListPanels.forEach(taskListPanel::add);
    }

    public ExecutorService pathfindingExecutor = Executors.newSingleThreadExecutor();
    public Future<?> pathfinderFuture;
    public Object pathfinderMutex = new Object();

    int CurrentPathfinderIndex = 0;

    @Getter
    public ArrayList<Pathfinder> pathfinderArray = new ArrayList<>();

    public int AddTaskListToSortedLeaguesTasks(WorldPoint PlayerLocation, HashMap<UUID, TaskData> TaskCache)
    {
        TaskSortMethod SortConfig = config.TaskSort();
        int NeededPathFinderSize = 0;

        for (HashMap.Entry<UUID, TaskData> entry : TaskCache.entrySet())
        {
            // Calculate our sort value
            int SortValue = 0;

            // Hidden values bumped to the end
            boolean bIsHidden = plugin.config.UserData.HiddenTasks.contains(entry.getKey());
            if (bIsHidden)
            {
                SortValue += 100000;
            }

            // completed go to the end
            boolean bIsCompleted = plugin.config.UserData.CompletedTasks.contains(entry.getKey());
            if (bIsCompleted)
            {
                SortValue += 100000;
            }

            // Always put things on the plan first
            if (config.UserData.PlannedTasks.containsKey(entry.getKey()))
            {
                SortValue += config.UserData.PlannedTasks.get(entry.getKey()).SortPriority;
                ++NeededPathFinderSize;
            }
            else
            {
                SortValue += 100000;
                if (SortConfig == TaskSortMethod.DISTANCE && PlayerLocation != null)
                {
                    float ClosestDistance = 90000;
                    for (WorldPoint NextLocation : entry.getValue().Locations)
                    {
                        float NextDistance = PlayerLocation.distanceTo(NextLocation);
                        if (ClosestDistance > NextDistance)
                        {
                            ClosestDistance = NextDistance;
                        }
                    }
                    SortValue += (int) ClosestDistance;
                }

                // Fallback with difficulty
                {
                    if (entry.getValue().Difficulty == TaskDifficulty.EASY)
                    {
                        SortValue += 100;
                    }
                    else if (entry.getValue().Difficulty == TaskDifficulty.MEDIUM)
                    {
                        SortValue += 200;
                    }
                    else if (entry.getValue().Difficulty == TaskDifficulty.HARD)
                    {
                        SortValue += 300;
                    }
                    else if (entry.getValue().Difficulty == TaskDifficulty.ELITE)
                    {
                        SortValue += 400;
                    }
                    else if (entry.getValue().Difficulty == TaskDifficulty.MASTER)
                    {
                        SortValue += 500;
                    }
                    else if (entry.getValue().Difficulty == TaskDifficulty.CUSTOM)
                    {
                        SortValue += 600;
                    }
                }

                // Region tie breakers
                {
                    if (!entry.getValue().Regions.isEmpty())
                    {
                        RegionType FirstRegion = entry.getValue().Regions.get(0);
                        SortValue += RegionType.GetRegionValue(FirstRegion);
                    }
                }
            }

            config.TaskData.SortedLeaguesTaskList.add(new SortedTask(entry.getKey(), SortValue, entry.getValue().bIsCustomTask));
        }
        return NeededPathFinderSize;
    }

    void CacheSortedLeaguesTasks(WorldPoint PlayerLocation)
    {
        config.TaskData.SortedLeaguesTaskList.clear();

        int NeededPathFinderSize = 0;
        NeededPathFinderSize += AddTaskListToSortedLeaguesTasks(PlayerLocation, config.TaskData.LeaguesTaskList);
        NeededPathFinderSize += AddTaskListToSortedLeaguesTasks(PlayerLocation, config.UserData.CustomTasks);

        config.TaskData.SortedLeaguesTaskList.sort(new Comparator<SortedTask>() {
            @Override
            public int compare(SortedTask o1, SortedTask o2)
            {
                return (o1.SortPriority.compareTo(o2.SortPriority));
            }
        });

        // Restart pathfinding settings
        ResetPathfindingSettings(NeededPathFinderSize);

        // Start a pathfinding task for each planned task
        Player player = plugin.client.getLocalPlayer();
        WorldPoint PreviousPointPosition = null;
        if (player != null)
        {
            PreviousPointPosition = player.getWorldLocation();
        }

        for (SortedTask sortTask : config.TaskData.SortedLeaguesTaskList)
        {
            // We are done with queueing our tasks
            if (!config.UserData.PlannedTasks.containsKey(sortTask.TaskGUID))
            {
                break;
            }

            float ClosestDistance = 9000000.0f;
            WorldPoint ClosestWorldPoint = null;
            TaskData data = plugin.GetTaskData(sortTask.TaskGUID, sortTask.bIsCustomTask
            );
            for (WorldPoint TaskPoint : data.Locations)
            {
                float NextDistance = 0.0f;
                if (PreviousPointPosition != null)
                {
                    NextDistance = PreviousPointPosition.distanceTo(TaskPoint);;
                }

                if ( NextDistance < ClosestDistance)
                {
                    ClosestDistance = NextDistance;
                    ClosestWorldPoint = TaskPoint;
                }
            }
            PreviousPointPosition = ClosestWorldPoint;
        }
    }

    public boolean bPathfindingReset = false;
    private void ResetPathfindingSettings(int NeededPathFinderSize)
    {
        config.UserData.CacheSortedPlannedTasks();

        for (int i = 0; i < pathfinderArray.size(); ++i)
        {
            synchronized (pathfinderMutex)
            {
                if (pathfinderArray.get(i) != null)
                {
                    pathfinderArray.get(i).cancel();
                    pathfinderFuture.cancel(true);
                }
            }
        }
        pathfinderArray.clear();

        if (pathfindingExecutor == null)
        {
            ThreadFactory shortestPathNaming = new ThreadFactoryBuilder().setNameFormat("shortest-path-%d").build();
            pathfindingExecutor = Executors.newSingleThreadExecutor(shortestPathNaming);
        }

        CurrentPathfinderIndex = 0;
        bPathfindingReset = true;
    }

    public void refresh()
    {
        Player player = plugin.client.getLocalPlayer();
        WorldPoint playerLocation = null;
        if (player != null)
        {
            playerLocation = player.getWorldLocation();
        }
        CacheSortedLeaguesTasks(playerLocation);

        filterDropdown4.setSelectedItem(config.FilteredRequirements());
        filterDropdown3.setSelectedItem(config.TaskSort());
        filterDropdown2.setSelectedItem(config.FilteredOther());
        filterDropdown.setSelectedItem(config.FilteredDifficulty());

        CacheFilteredTaskList();
        ApplyFilteredTaskListToPanel();

        autostartButton.repaint();
        autostartButton.revalidate();

        if (FilteredTaskListPanels.isEmpty())
        {
            NoSearchPanel.setVisible(true);
            NoSearchPanel.removeAll();
            JLabel noMatch = new JLabel();
            noMatch.setForeground(Color.GRAY);
            noMatch.setText("<html><body style='text-align:left'>No tasks are available that match your current filters</body></html>");
            NoSearchPanel.add(noMatch);
        }
        else
        {
            NoSearchPanel.setVisible(false);
        }

        repaint();
        revalidate();
    }
}

package Posiedien_Leagues_Planner;

import net.runelite.api.Point;
import net.runelite.api.World;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.worldmap.WorldMapOverlay;

import java.awt.*;
import java.awt.geom.Area;
import java.util.ArrayList;

public class WorldPointPolygon
{
    ArrayList<WorldPoint> WorldPoints = new ArrayList<>();
    Polygon WorldPoly = new Polygon();
    int WorldPolyZ = 0;

    public void CacheWorldPoly()
    {
        WorldPoly.reset();
        for (WorldPoint currentPoint : WorldPoints)
        {
            WorldPoly.addPoint(currentPoint.getX(), currentPoint.getY());

            // Should be all the same
            WorldPolyZ = currentPoint.getPlane();
        }
    }

    void AddWorldPoint(WorldPoint newWorldPoint)
    {
        WorldPoints.add(newWorldPoint);
    }

    public Polygon ConvertToGraphicsPolygon(WorldMapOverlay worldMapOverlay)
    {
        Polygon newPoly = new Polygon();
        boolean shouldDraw = true;
        for (WorldPoint currentPoint : WorldPoints)
        {
            Point GraphicsPoint = worldMapOverlay.mapWorldPointToGraphicsPoint(currentPoint);
            if (GraphicsPoint == null)
            {
                return null;
            }

            newPoly.addPoint(GraphicsPoint.getX(), GraphicsPoint.getY());
        }

        return newPoly;
    }
}

package Posiedien_Leagues_Planner;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import net.runelite.api.Tile;
import net.runelite.api.World;
import net.runelite.api.coords.WorldPoint;

import java.awt.*;
import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Scanner;
import java.util.UUID;

public class FullRegionData
{
    public ArrayList<LeagueRegionBounds> RegionData = new ArrayList<>();

    public boolean IsTileInUnlockedRegion(LeaguesPlannerConfig config, WorldPoint TileLocation)
    {
        ArrayList<RegionType> RegionsForTile = GetTileRegions(TileLocation);

        // If not in any region, that means it available for all reasons
        if (!RegionsForTile.isEmpty())
        {
            for (RegionType regionType : RegionsForTile)
            {
                if (RegionType.GetRegionUnlocked(config, regionType))
                {
                    return true;
                }
            }
        }
        else
        {
            return true;
        }

        return false;
    }

    public ArrayList<RegionType> GetTileRegions(WorldPoint TileLocation)
    {
        ArrayList<RegionType> OutRegions = new ArrayList<RegionType>();
        for (LeagueRegionBounds regionDatum : RegionData)
        {
            ArrayList<WorldPointPolygon> RegionPolygons = regionDatum.RegionPolygons;
            for (WorldPointPolygon regionPolygon : RegionPolygons)
            {
                Polygon WorldPoly = regionPolygon.WorldPoly;
                int WorldPolyZ = regionPolygon.WorldPolyZ;
                if (WorldPolyZ == TileLocation.getPlane() && WorldPoly.contains(TileLocation.getX(), TileLocation.getY()))
                {
                    OutRegions.add(regionDatum.Type);
                    break;
                }
            }
        }

        return OutRegions;
    }

    public void exportTo(File file) throws IOException
    {
        try (FileWriter fw = new FileWriter(file))
        {
            fw.write(ExportData());
        }
    }

    // Fixup all of our linkage
    private void FixupAfterImport()
    {
        for (LeagueRegionBounds Region : RegionData)
        {
            for (HashMap.Entry<UUID, LeagueRegionPoint> entry : Region.RegionPoints.entrySet())
            {
                entry.getValue().ConnectedPoints.clear();
                for (UUID ConnectedGUID : entry.getValue().ConnectedPointGUIDs)
                {
                    entry.getValue().ConnectedPoints.add(Region.RegionPoints.get(ConnectedGUID));
                }
            }
        }
    }

    public void importFrom(File file)
    {
        try (Scanner sc = new Scanner(file))
        {
            sc.useDelimiter(",");
            ImportData(sc);
        } catch (IOException ignored)
        {
        }

        FixupAfterImport();
    }
    public String ExportData()
    {
        StringBuilder Converted = new StringBuilder();

        Converted.append(RegionData.size());
        Converted.append(",");

        for (LeagueRegionBounds Region : RegionData)
        {
            Converted.append(Region.ExportData());
        }
        
        return Converted.toString();
    }

    public void ImportData(Scanner sc)
    {
        RegionData.clear();
        int RegionSize = Integer.parseInt(sc.next());

        for (int i = 0; i < RegionSize; ++i)
        {
            LeagueRegionBounds NewRegionBounds = new LeagueRegionBounds();
            NewRegionBounds.ImportData(sc);
            RegionData.add(NewRegionBounds);
        }
    }
}

package Posiedien_Leagues_Planner;

public enum TileStyle {
    TILES,
    LINES
}

package Posiedien_Leagues_Planner;

import java.awt.*;
import java.awt.geom.Area;

import net.runelite.api.Point;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.worldmap.WorldMapOverlay;

public class RegionLine
{
    WorldPoint Start;
    WorldPoint End;

    public RegionLine(WorldPoint start, WorldPoint end)
    {
        Start = start;
        End = end;
    }

    public GraphicsLine ConvertToGraphicsLine(WorldMapOverlay worldMapOverlay)
    {
        GraphicsLine newLine = new GraphicsLine();
        Point GraphicsStart = worldMapOverlay.mapWorldPointToGraphicsPoint(Start);
        if (GraphicsStart == null)
        {
            return null;
        }

        newLine.x1 = GraphicsStart.getX();
        newLine.y1 = GraphicsStart.getY();

        Point GraphicsEnd = worldMapOverlay.mapWorldPointToGraphicsPoint(End);
        if (GraphicsEnd == null)
        {
            return null;
        }

        newLine.x2 = GraphicsEnd.getX();
        newLine.y2 = GraphicsEnd.getY();

        return newLine;
    }
}

package Posiedien_Leagues_Planner;

import java.awt.*;

public enum RegionType
{
    NONE,
    GENERAL,
    MISTHALIN,
    KARAMJA,
    KANDARIN,
    ASGARNIA,
    FREMENNIK,
    KOUREND,
    WILDERNESS,
    MORYTANIA,
    TIRANNWN,
    DESERT;

    static public boolean GetRegionUnlocked(LeaguesPlannerConfig config, RegionType Type)
    {
        switch (Type)
        {
            case MISTHALIN:
                return config.MisthalinUnlocked();
            case KARAMJA:
                return config.KaramjaUnlocked();
            case KANDARIN:
                return config.KandarinUnlocked();
            case ASGARNIA:
                return config.AsgarniaUnlocked();
            case FREMENNIK:
                return config.FremennikUnlocked();
            case KOUREND:
                return config.KourendUnlocked();
            case WILDERNESS:
                return config.WildernessUnlocked();
            case MORYTANIA:
                return config.MorytaniaUnlocked();
            case TIRANNWN:
                return config.TirannwnUnlocked();
            case DESERT:
                return config.DesertUnlocked();
        }

        return true;
    }

    static public int GetRegionValue(RegionType Type) {
        switch (Type)
        {
            case MISTHALIN:
                return 1;
            case KARAMJA:
                return 2;
            case KANDARIN:
                return 3;
            case ASGARNIA:
                return 4;
            case FREMENNIK:
                return 5;
            case KOUREND:
                return 6;
            case WILDERNESS:
                return 7;
            case MORYTANIA:
                return 8;
            case TIRANNWN:
                return 9;
            case DESERT:
                return 10;
        }
        return 0;
    }

    static public Color GetRegionColor(LeaguesPlannerConfig config, RegionType Type, boolean bConsiderUnlocked)
    {
        Color OutColor = Color.WHITE;

        switch (Type)
        {
            case MISTHALIN:
                OutColor = config.MisthalinColor();
                break;
            case KARAMJA:
                OutColor = config.KaramjaColor();
                break;
            case KANDARIN:
                OutColor = config.KandarinColor();
                break;
            case ASGARNIA:
                OutColor = config.AsgarniaColor();
                break;
            case FREMENNIK:
                OutColor = config.FremennikColor();
                break;
            case KOUREND:
                OutColor = config.KourendColor();
                break;
            case WILDERNESS:
                OutColor = config.WildernessColor();
                break;
            case MORYTANIA:
                OutColor = config.MorytaniaColor();
                break;
            case TIRANNWN:
                OutColor = config.TirannwnColor();
                break;
            case DESERT:
                OutColor = config.DesertColor();
                break;
        }

        int DebugColorAlpha = 0;
        if (bConsiderUnlocked && !GetRegionUnlocked(config, Type))
        {
            OutColor = new Color(42, 42, 42,100);
            DebugColorAlpha = Math.max(0, Math.min(config.DebugColorDisabledAlpha(), 255));
        }
        else
        {
            DebugColorAlpha = Math.max(0, Math.min(config.DebugColorAlpha(), 255));
        }

        OutColor = new Color(OutColor.getRed(), OutColor.getGreen(), OutColor.getBlue(), DebugColorAlpha);
        return OutColor;
    }
}

package Posiedien_Leagues_Planner;

import java.awt.*;

public enum TaskDifficulty
{
    NONE,
    BEGINNER,
    EASY,
    MEDIUM,
    HARD,
    ELITE,
    MASTER,
    CUSTOM;

    static Color GetTaskDifficultyColor(TaskDifficulty InTaskDiff)
    {
        switch (InTaskDiff)
        {
            case BEGINNER:
            return new Color(255, 142, 9,255);
            case EASY:
                return new Color(190, 190, 190,255);
            case MEDIUM:
                return new Color(161, 255, 132,255);
            case HARD:
                return new Color(70, 255, 207,255);
            case ELITE:
                return new Color(6, 160, 255,255);
            case MASTER:
                return new Color(255, 0, 0, 255);
            case CUSTOM:
                return new Color(255, 242, 0, 255);
        }
        return new Color(253, 253, 253, 255);
    }
}

package Posiedien_Leagues_Planner;

import java.util.UUID;

public class SortedTask
{
    UUID TaskGUID;
    Integer SortPriority;

    Boolean bIsCustomTask;

    public SortedTask(UUID key, Integer value, Boolean bCustomTask)
    {
        TaskGUID = key;
        SortPriority = value;
        bIsCustomTask = bCustomTask;
    }
}

package Posiedien_Leagues_Planner;

import java.util.Arrays;

// This class is not intended as a general purpose replacement for a hashmap; it lacks convenience features
// found in regular maps and has no way to remove elements or get a list of keys/values.
public class PrimitiveIntHashMap<V> {
    private static final int MINIMUM_SIZE = 8;

    // Unless the hash function is really unbalanced, most things should fit within at least 8-element buckets
    // Buckets will grow as needed without forcing a rehash of the whole map
    private static final int DEFAULT_BUCKET_SIZE = 4;

    // How full the map should get before growing it again. Smaller values speed up lookup times at the expense of space
    private static final float DEFAULT_LOAD_FACTOR = 0.75f;

    private static class IntNode<V> {
        private int key;
        private V value;

        private IntNode(int key, V value) {
            this.key = key;
            this.value = value;
        }
    }

    // If buckets become too large then it may be worth converting large buckets into an array-backed binary tree
    private IntNode<V>[][] buckets;
    private int size;
    private int capacity;
    private int maxSize;
    private int mask;
    private final float loadFactor;

    public PrimitiveIntHashMap(int initialSize) {
        this(initialSize, DEFAULT_LOAD_FACTOR);
    }

    public PrimitiveIntHashMap(int initialSize, float loadFactor) {
        if (loadFactor < 0.0f || loadFactor > 1.0f) {
            throw new IllegalArgumentException("Load factor must be between 0 and 1");
        }

        this.loadFactor = loadFactor;
        size = 0;
        setNewSize(initialSize);
        recreateArrays();
    }

    public int size() {
        return size;
    }

    public V get(int key) {
        return getOrDefault(key, null);
    }

    public V getOrDefault(int key, V defaultValue) {
        int bucket = getBucket(key);
        int index = bucketIndex(key, bucket);
        if (index == -1) {
            return defaultValue;
        }
        return buckets[bucket][index].value;
    }

    public V put(int key, V value) {
        if (value == null) {
            throw new IllegalArgumentException("Cannot insert a null value");
        }

        int bucketIndex = getBucket(key);
        IntNode<V>[] bucket = buckets[bucketIndex];

        if (bucket == null) {
            buckets[bucketIndex] = createBucket(DEFAULT_BUCKET_SIZE);
            buckets[bucketIndex][0] = new IntNode<>(key, value);
            incrementSize();
            return null;
        }

        for (int i = 0; i < bucket.length; ++i) {
            if (bucket[i] == null) {
                bucket[i] = new IntNode<>(key, value);
                incrementSize();
                return null;
            } else if (bucket[i].key == key) {
                V previous = bucket[i].value;
                bucket[i].value = value;
                return previous;
            }
        }

        // No space in the bucket, grow it
        growBucket(bucketIndex)[bucket.length] = new IntNode<>(key, value);
        incrementSize();
        return null;
    }

    // This hash seems to be most effective for packed WorldPoint's
    private static int hash(int value) {
        return value ^ (value >>> 5) ^ (value >>> 25);
    }

    private int getBucket(int key) {
        return (hash(key) & 0x7FFFFFFF) & mask;
    }

    private int bucketIndex(int key, int bucketIndex) {
        IntNode<V>[] bucket = buckets[bucketIndex];
        if (bucket == null) {
            return -1;
        }

        for (int i = 0; i < bucket.length; ++i) {
            if (bucket[i] == null) {
                break;
            }
            if (bucket[i].key == key) {
                return i;
            }
        }

        // Searched the bucket and found nothing
        return -1;
    }

    private void incrementSize() {
        size++;
        if (size >= capacity) {
            rehash();
        }
    }

    private IntNode<V>[] growBucket(int bucketIndex) {
        IntNode<V>[] oldBucket = buckets[bucketIndex];
        IntNode<V>[] newBucket = createBucket(oldBucket.length * 2);
        System.arraycopy(oldBucket, 0, newBucket, 0, oldBucket.length);
        buckets[bucketIndex] = newBucket;
        return newBucket;
    }

    private int getNewMaxSize(int size) {
        int nextPow2 = -1 >>> Integer.numberOfLeadingZeros(size);
        if (nextPow2 >= (Integer.MAX_VALUE >>> 1)) {
            return (Integer.MAX_VALUE >>> 1) + 1;
        }
        return nextPow2 + 1;
    }

    private void setNewSize(int size) {
        if (size < MINIMUM_SIZE) {
            size = MINIMUM_SIZE - 1;
        }

        maxSize = getNewMaxSize(size);
        mask = maxSize - 1;
        capacity = (int)(maxSize * loadFactor);
    }

    private void growCapacity() {
        setNewSize(maxSize);
    }

    // Grow the bucket array then rehash all the values into new buckets and discard the old ones
    private void rehash() {
        growCapacity();

        IntNode<V>[][] oldBuckets = buckets;
        recreateArrays();

        for (int i = 0; i < oldBuckets.length; ++i) {
            IntNode<V>[] oldBucket = oldBuckets[i];
            if (oldBucket == null) {
                continue;
            }

            for (int ind = 0; ind < oldBucket.length; ++ind) {
                if (oldBucket[ind] == null) {
                    break;
                }

                int bucketIndex = getBucket(oldBucket[ind].key);
                IntNode<V>[] newBucket = buckets[bucketIndex];
                if (newBucket == null) {
                    newBucket = createBucket(DEFAULT_BUCKET_SIZE);
                    newBucket[0] = oldBucket[ind];
                    buckets[bucketIndex] = newBucket;
                } else {
                    int bInd;
                    for (bInd = 0; bInd < newBucket.length; ++bInd) {
                        if (newBucket[bInd] == null) {
                            newBucket[bInd] = oldBucket[ind];
                            break;
                        }
                    }

                    if (bInd >= newBucket.length) {
                        growBucket(bucketIndex)[newBucket.length] = oldBucket[ind];
                        return;
                    }
                }
            }
        }
    }

    private void recreateArrays() {
        @SuppressWarnings({"unchecked", "SuspiciousArrayCast"})
        IntNode<V>[][] temp = (IntNode<V>[][])new IntNode[maxSize][];
        buckets = temp;
    }

    private IntNode<V>[] createBucket(int size) {
        @SuppressWarnings({"unchecked", "SuspiciousArrayCast"})
        IntNode<V>[] temp = (IntNode<V>[])new IntNode[size];
        return temp;
    }

    // Debug helper to understand how effective a given hash may be at distributing values
    public double calculateFullness() {
        int size = 0;
        int usedSize = 0;
        for (int i = 0; i < buckets.length; ++i) {
            if (buckets[i] == null) continue;
            size += buckets[i].length;
            for (int j = 0; j < buckets[i].length; ++j) {
                if (buckets[i][j] == null) {
                    usedSize += j;
                    break;
                }
            }
        }
        return 100.0 * (double)usedSize / (double)size;
    }

    public void clear() {
        size = 0;
        Arrays.fill(buckets, null);
    }
}

package Posiedien_Leagues_Planner;

import ch.qos.logback.core.BasicStatusManager;
import net.runelite.api.Skill;
import net.runelite.api.World;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.plugins.achievementdiary.CombatLevelRequirement;
import net.runelite.client.plugins.achievementdiary.Requirement;
import net.runelite.client.plugins.achievementdiary.SkillRequirement;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Array;
import java.util.*;

public class FullUserData
{
    HashMap<UUID, TaskData>  CustomTasks = new HashMap<>();
    HashMap<UUID, TaskSortData> PlannedTasks = new HashMap<UUID, TaskSortData>();

    HashSet<UUID> HiddenTasks = new HashSet<UUID>();

    HashSet<UUID> CompletedTasks = new HashSet<>();

    ArrayList<SortedTask> SortedPlannedTasks = new ArrayList<>();

    void CacheSortedPlannedTasks()
    {
        SortedPlannedTasks.clear();

        for (HashMap.Entry<UUID, TaskSortData> mapElement : PlannedTasks.entrySet())
        {
            SortedPlannedTasks.add(new SortedTask(mapElement.getKey(), mapElement.getValue().SortPriority, mapElement.getValue().bIsCustomTask));
        }

        SortedPlannedTasks.sort(new Comparator<SortedTask>() {
            @Override
            public int compare(SortedTask o1, SortedTask o2)
            {
                return (o1.SortPriority.compareTo(o2.SortPriority));
            }
        });

        for (int i = 0; i < SortedPlannedTasks.size(); ++i)
        {
            PlannedTasks.get(SortedPlannedTasks.get(i).TaskGUID).LastSortOrder = i + 1;
        }


    }

    public String GetNextIgnoreBlank(Scanner sc)
    {
        while (true)
        {
            if (!sc.hasNext())
            {
                return null;
            }

            String NextString = sc.next();
            if (!Objects.equals(NextString, "")
                    && !Objects.equals(NextString, "\r\n"))
            {
                NextString = NextString.replace("\r\n", "");
                return NextString;
            }
        }

    }

    public void importFrom(File targ)
    {
        if (targ.exists())
        {
            try (Scanner sc = new Scanner(targ))
            {
                // CSV file, so comma delimiter
                sc.useDelimiter(",");

                Integer CustomTaskSize = Integer.valueOf(GetNextIgnoreBlank(sc));

                for (int i = 0; i < CustomTaskSize; ++i)
                {
                    TaskData NewCustomTask = new TaskData();

                    NewCustomTask.TaskName = GetNextIgnoreBlank(sc);
                    NewCustomTask.Difficulty = TaskDifficulty.valueOf(GetNextIgnoreBlank(sc));
                    NewCustomTask.TaskDescription = GetNextIgnoreBlank(sc);
                    NewCustomTask.GUID = UUID.fromString(GetNextIgnoreBlank(sc));
                    NewCustomTask.bIsCustomTask = Boolean.valueOf((GetNextIgnoreBlank(sc)));
                    NewCustomTask.CustomIcon = (GetNextIgnoreBlank(sc));

                    Integer RegionSize = Integer.valueOf((GetNextIgnoreBlank(sc)));
                    for (int j = 0; j < RegionSize; ++j)
                    {
                        RegionType NewRegionType = RegionType.valueOf(GetNextIgnoreBlank(sc));
                        NewCustomTask.Regions.add(NewRegionType);
                    }

                    Integer OverworldLocationsSize = Integer.valueOf((GetNextIgnoreBlank(sc)));
                    for (int j = 0; j < OverworldLocationsSize; ++j)
                    {
                        int WorldPointX = Integer.parseInt(GetNextIgnoreBlank(sc));
                        int WorldPointY = Integer.parseInt(GetNextIgnoreBlank(sc));
                        int WorldPointZ = Integer.parseInt(GetNextIgnoreBlank(sc));

                        NewCustomTask.OverworldLocations.add(new WorldPoint(WorldPointX, WorldPointY, WorldPointZ));
                    }

                    Integer LocationsSize = Integer.valueOf((GetNextIgnoreBlank(sc)));
                    for (int j = 0; j < LocationsSize; ++j)
                    {
                        int WorldPointX = Integer.parseInt(GetNextIgnoreBlank(sc));
                        int WorldPointY = Integer.parseInt(GetNextIgnoreBlank(sc));
                        int WorldPointZ = Integer.parseInt(GetNextIgnoreBlank(sc));

                        NewCustomTask.Locations.add(new WorldPoint(WorldPointX, WorldPointY, WorldPointZ));
                    }

                    Integer RequirementSize = Integer.valueOf((GetNextIgnoreBlank(sc)));
                    for (int j = 0; j < RequirementSize; ++j)
                    {
                        String ReqType = GetNextIgnoreBlank(sc);
                        Integer SkillLevel = Integer.valueOf(GetNextIgnoreBlank(sc));
                        if (ReqType.contains("COMBAT"))
                        {
                            CombatLevelRequirement CombatReq = new CombatLevelRequirement(SkillLevel);
                            NewCustomTask.Requirements.add(CombatReq);
                        }
                        else
                        {
                            Skill SkillVal = Skill.valueOf(ReqType);
                            SkillRequirement SkillReq = new SkillRequirement(SkillVal, SkillLevel);
                            NewCustomTask.Requirements.add(SkillReq);
                        }
                    }

                    CustomTasks.put(NewCustomTask.GUID, NewCustomTask);
                }

                Integer PlannedTaskSize = Integer.valueOf(GetNextIgnoreBlank(sc));
                for (int i = 0; i < PlannedTaskSize; ++i)
                {
                    UUID GUID = UUID.fromString(GetNextIgnoreBlank(sc));

                    Integer NewSortPriority = Integer.valueOf(GetNextIgnoreBlank(sc));
                    Integer NewLastSortOrder = Integer.valueOf(GetNextIgnoreBlank(sc));
                    Boolean bNewIsCustomTask = Boolean.valueOf(GetNextIgnoreBlank(sc));
                    TaskSortData NewSortData = new TaskSortData(NewSortPriority, bNewIsCustomTask);
                    NewSortData.LastSortOrder = NewLastSortOrder;

                    PlannedTasks.put(GUID, NewSortData);
                }


                Integer HiddenTaskSize = Integer.valueOf(GetNextIgnoreBlank(sc));
                for (int i = 0; i < HiddenTaskSize; ++i)
                {
                    UUID GUID = UUID.fromString(GetNextIgnoreBlank(sc));
                    HiddenTasks.add(GUID);
                }

                Integer CompletedTaskSize = Integer.valueOf(GetNextIgnoreBlank(sc));
                for (int i = 0; i < CompletedTaskSize; ++i)
                {
                    UUID GUID = UUID.fromString(GetNextIgnoreBlank(sc));
                    CompletedTasks.add(GUID);
                }

            } catch (IOException ignored)
            {
            }
        }
    }


    public void exportTo(File targ)
    {
        try (FileWriter fw = new FileWriter(targ))
        {
            StringBuilder Converted = new StringBuilder();

            Converted.append(CustomTasks.size());
            Converted.append(",");
            for (HashMap.Entry<UUID, TaskData> entry : CustomTasks.entrySet())
            {
                Converted.append(entry.getValue().ExportUserDataFormat());
            }

            Converted.append(PlannedTasks.size());
            Converted.append(",");
            for (HashMap.Entry<UUID, TaskSortData> entry : PlannedTasks.entrySet())
            {
                Converted.append(entry.getKey());
                Converted.append(",");

                Converted.append(entry.getValue().ExportData());
            }


            Converted.append(HiddenTasks.size());
            Converted.append(",");
            for (UUID entry : HiddenTasks)
            {
                Converted.append(entry);
                Converted.append(",");
            }

            Converted.append(CompletedTasks.size());
            Converted.append(",");
            for (UUID entry : CompletedTasks)
            {
                Converted.append(entry);
                Converted.append(",");
            }

            fw.write(Converted.toString());
        }
        catch (IOException e)
        {
        }
    }
}

package Posiedien_Leagues_Planner;

public enum TaskSortMethod
{
    DISTANCE,
    DIFFICULTY;
}

package Posiedien_Leagues_Planner;

import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.World;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.plugins.achievementdiary.CombatLevelRequirement;
import net.runelite.client.plugins.achievementdiary.Requirement;
import net.runelite.client.plugins.achievementdiary.SkillRequirement;

import javax.swing.plaf.synth.Region;
import java.util.ArrayList;
import java.util.UUID;

public class TaskData
{
    UUID GUID = null;

    TaskDifficulty Difficulty;

    String TaskName = "Blank";

    String TaskDescription = "Blank";

    Boolean bIsCustomTask = false;

    String CustomIcon = null;

    ArrayList<RegionType> Regions = new ArrayList<>();

    ArrayList<WorldPoint> Locations = new ArrayList<>();


    // Keep a separate cache for overworld locations so we can show those on the dungeon entrances
    ArrayList<WorldPoint> OverworldLocations = new ArrayList<>();

    ArrayList<Requirement> Requirements = new ArrayList<>();

    int CalculateNeededRequirementsForTask(Client client)
    {
        int OutReqDiff = 0;
        for (Requirement req : Requirements)
        {
            if (req.getClass() == SkillRequirement.class)
            {
                SkillRequirement SkillReq = (SkillRequirement)req;

                int SkillDiff = SkillReq.getLevel() - client.getRealSkillLevel(SkillReq.getSkill());
                if (SkillDiff > 0)
                {
                    OutReqDiff += SkillDiff;
                }
            }
            else if (req.getClass() == CombatLevelRequirement.class)
            {
                CombatLevelRequirement CombatReq = (CombatLevelRequirement)req;

                int SkillDiff = CombatReq.getLevel() - client.getLocalPlayer().getCombatLevel();
                if (SkillDiff > 0)
                {
                    OutReqDiff += SkillDiff;
                }
            }
            else
            {
                if (!req.satisfiesRequirement(client))
                {
                    ++OutReqDiff;
                }
            }
        }

        return OutReqDiff;
    }

    public String ExportUserDataFormat()
    {
        StringBuilder Converted = new StringBuilder();

        Converted.append(TaskName);
        Converted.append(",");
        Converted.append(Difficulty);
        Converted.append(",");
        Converted.append(TaskDescription);
        Converted.append(",");
        Converted.append(GUID);
        Converted.append(",");
        Converted.append(bIsCustomTask);
        Converted.append(",");
        Converted.append(CustomIcon);
        Converted.append(",");
        Converted.append(Regions.size());
        Converted.append(",");
        for (RegionType CurrentRegion : Regions)
        {
            Converted.append(CurrentRegion);
            Converted.append(",");
        }

        Converted.append(OverworldLocations.size());
        Converted.append(",");
        for (WorldPoint CurrentPoint : OverworldLocations)
        {
            Converted.append(CurrentPoint.getX());
            Converted.append(",");
            Converted.append(CurrentPoint.getY());
            Converted.append(",");
            Converted.append(CurrentPoint.getPlane());
            Converted.append(",");
        }

        Converted.append(Locations.size());
        Converted.append(",");
        for (WorldPoint CurrentPosition : Locations)
        {
            Converted.append(CurrentPosition.getX());
            Converted.append(",");
            Converted.append(CurrentPosition.getY());
            Converted.append(",");
            Converted.append(CurrentPosition.getPlane());
            Converted.append(",");
        }

        Converted.append(Requirements.size());
        Converted.append(",");
        for (Requirement CurrentRequirement : Requirements)
        {
            if (CurrentRequirement.getClass() == SkillRequirement.class)
            {
                SkillRequirement SkillReq = (SkillRequirement)CurrentRequirement;
                Converted.append(SkillReq.getSkill());
                Converted.append(",");
                Converted.append(SkillReq.getLevel());
            }
            else if (CurrentRequirement.getClass() == CombatLevelRequirement.class)
            {
                CombatLevelRequirement CombatReq = (CombatLevelRequirement)CurrentRequirement;
                Converted.append("COMBAT");
                Converted.append(",");
                Converted.append(CombatReq.getLevel());
            }
            Converted.append(",");
            Converted.append("\r\n");
        }

        return Converted.toString();
    }

    public String ExportData()
    {
        StringBuilder Converted = new StringBuilder();

        Converted.append(TaskName);
        Converted.append(",");
        Converted.append(Difficulty);
        Converted.append(",");
        Converted.append(TaskDescription);
        Converted.append(",");
        Converted.append(GUID);
        Converted.append(",");
        Converted.append(bIsCustomTask);
        Converted.append(",");
        Converted.append(CustomIcon);
        Converted.append(",");
        Converted.append("Regions Count: ,");
        Converted.append(Regions.size());
        Converted.append(",");
        for (RegionType CurrentRegion : Regions)
        {
            Converted.append(CurrentRegion);
            Converted.append(",");
        }

        Converted.append("Overworld Location Count (Auto-generated): ,");
        Converted.append(OverworldLocations.size());
        Converted.append(",");
        for (WorldPoint CurrentPoint : OverworldLocations)
        {
            Converted.append(CurrentPoint.getX());
            Converted.append(",");
            Converted.append(CurrentPoint.getY());
            Converted.append(",");
            Converted.append(CurrentPoint.getPlane());
            Converted.append(",");
        }

        Converted.append(",");
        Converted.append("\r\n");
        Converted.append("POSITIONS_START,");
        if (Locations.size() == 0)
        {
            Converted.append("NO_POSITIONS");
        }
        else
        {
            Converted.append("HAS_POSITIONS");
        }
        Converted.append(",");
        Converted.append("\r\n");
        Converted.append("X");
        Converted.append(",");
        Converted.append("Y");
        Converted.append(",");
        Converted.append("Z");
        Converted.append("\r\n");
        Converted.append(",");

        // Set up for manually adding things
        if (Locations.isEmpty())
        {
            Converted.append("\r\n");
            Converted.append(",");
        }

        for (WorldPoint CurrentPosition : Locations)
        {
            Converted.append(CurrentPosition.getX());
            Converted.append(",");
            Converted.append(CurrentPosition.getY());
            Converted.append(",");
            Converted.append(CurrentPosition.getPlane());
            Converted.append(",");
            Converted.append("\r\n");
        }

        Converted.append("POSITIONS_END");
        Converted.append(",");
        Converted.append("\r\n");

        Converted.append(",");
        Converted.append("\r\n");
        Converted.append("REQUIREMENTS_START");
        Converted.append(",");
        Converted.append("\r\n");
        Converted.append("SKILL NAME");
        Converted.append(",");
        Converted.append("LEVEL REQUIREMENT");
        Converted.append(",");
        Converted.append("\r\n");

        for (Requirement CurrentRequirement : Requirements)
        {
            if (CurrentRequirement.getClass() == SkillRequirement.class)
            {
                SkillRequirement SkillReq = (SkillRequirement)CurrentRequirement;
                Converted.append(SkillReq.getSkill());
                Converted.append(",");
                Converted.append(SkillReq.getLevel());
            }
            else if (CurrentRequirement.getClass() == CombatLevelRequirement.class)
            {
                CombatLevelRequirement CombatReq = (CombatLevelRequirement)CurrentRequirement;
                Converted.append("COMBAT");
                Converted.append(",");
                Converted.append(CombatReq.getLevel());
            }
            Converted.append(",");
            Converted.append("\r\n");
        }

        Converted.append("REQUIREMENTS_END");
        Converted.append(",");
        Converted.append("\r\n");
        Converted.append(",");
        Converted.append("\r\n");

        return Converted.toString();
    }
}

package Posiedien_Leagues_Planner;

public enum OtherFilter
{
    NONE,
    ONLY_PLAN,
    ONLY_MAP_PLAN;
}

package Posiedien_Leagues_Planner;

public class TaskSortData
{
    Integer SortPriority;
    Integer LastSortOrder = 0;
    Boolean bIsCustomTask = false;

    public TaskSortData(int i, Boolean bCustomTask)
    {
        SortPriority = i;
        bIsCustomTask = bCustomTask;
    }

    public String ExportData()
    {
        StringBuilder Converted = new StringBuilder();

        Converted.append(SortPriority);
        Converted.append(",");

        Converted.append(LastSortOrder);
        Converted.append(",");

        Converted.append(bIsCustomTask);
        Converted.append(",");

        return Converted.toString();
    }
}

package Posiedien_Leagues_Planner;

import net.runelite.client.ui.overlay.worldmap.WorldMapPoint;

import javax.sound.sampled.Line;
import java.awt.*;
import java.util.*;

public class LeagueRegionBounds
{
    public RegionType Type = null;

    // Basically a linked list of points
    public HashMap<UUID, LeagueRegionPoint> RegionPoints = new HashMap<UUID, LeagueRegionPoint>();

    // Transient
    public ArrayList<WorldPointPolygon> RegionPolygons = new ArrayList<>();
    public ArrayList<RegionLine> RegionLines = new ArrayList<>();

    public LeagueRegionBounds()
    {
    }
    public LeagueRegionBounds(RegionType currentRegion)

    {
        Type = currentRegion;
    }

    public String ExportData()
    {
        StringBuilder ExportString = new StringBuilder();
        ExportString.append(Type);
        ExportString.append(",");

        ExportString.append(RegionPoints.size());
        ExportString.append(",");

        for (HashMap.Entry<UUID, LeagueRegionPoint> entry : RegionPoints.entrySet())
        {
            ExportString.append(entry.getValue().ExportData());
        }

        return ExportString.toString();
    }

    public void ImportData(Scanner sc)
    {
        Type = RegionType.valueOf(sc.next());

        int RegionPointSize = Integer.parseInt(sc.next());
        for (int i = 0; i < RegionPointSize; ++i)
        {
            LeagueRegionPoint NewRegionPoint = new LeagueRegionPoint();
            NewRegionPoint.ImportData(sc);
            RegionPoints.put(NewRegionPoint.GUID, NewRegionPoint);
        }

    }
}

/*
 * Copyright (c) 2017, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package Posiedien_Leagues_Planner;

import java.awt.Dimension;
import javax.swing.JPanel;
import net.runelite.client.ui.PluginPanel;

public class FixedWidthPanel extends JPanel
{
    @Override
    public Dimension getPreferredSize()
    {
        return new Dimension(PluginPanel.PANEL_WIDTH, super.getPreferredSize().height);
    }

}
package Posiedien_Leagues_Planner;

import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;

public class WorldPointUtil {
    public static int packWorldPoint(WorldPoint point) {
        return packWorldPoint(point.getX(), point.getY(), point.getPlane());
    }

    // Packs a world point into a single int
    // First 15 bits are x, next 15 are y, last 2 bits are the plane
    public static int packWorldPoint(int x, int y, int plane) {
        return (x & 0x7FFF) | ((y & 0x7FFF) << 15) | ((plane & 0x3) << 30);
    }

    public static WorldPoint unpackWorldPoint(int packedPoint) {
        final int x = unpackWorldX(packedPoint);
        final int y = unpackWorldY(packedPoint);
        final int plane = unpackWorldPlane(packedPoint);
        return new WorldPoint(x, y, plane);
    }

    public static int unpackWorldX(int packedPoint) {
        return packedPoint & 0x7FFF;
    }

    public static int unpackWorldY(int packedPoint) {
        return (packedPoint >> 15) & 0x7FFF;
    }

    public static int unpackWorldPlane(int packedPoint) {
        return (packedPoint >> 30) & 0x3;
    }

    public static int distanceBetween(int previousPacked, int currentPacked) {
        return distanceBetween(previousPacked, currentPacked, 1);
    }

    public static int distanceBetween(int previousPacked, int currentPacked, int diagonal) {
        final int previousX = WorldPointUtil.unpackWorldX(previousPacked);
        final int previousY = WorldPointUtil.unpackWorldY(previousPacked);
        final int currentX = WorldPointUtil.unpackWorldX(currentPacked);
        final int currentY = WorldPointUtil.unpackWorldY(currentPacked);
        final int dx = Math.abs(previousX - currentX);
        final int dy = Math.abs(previousY - currentY);

        if (diagonal == 1) {
            return Math.max(dx, dy);
        } else if (diagonal == 2) {
            return dx + dy;
        }

        return Integer.MAX_VALUE;
    }

    public static int distanceBetween(WorldPoint previous, WorldPoint current) {
        return distanceBetween(previous, current, 1);
    }

    public static int distanceBetween(WorldPoint previous, WorldPoint current, int diagonal) {
        final int dx = Math.abs(previous.getX() - current.getX());
        final int dy = Math.abs(previous.getY() - current.getY());

        if (diagonal == 1) {
            return Math.max(dx, dy);
        } else if (diagonal == 2) {
            return dx + dy;
        }

        return Integer.MAX_VALUE;
    }

    // Matches WorldArea.distanceTo
    public static int distanceToArea(int packedPoint, WorldArea area) {
        final int plane = unpackWorldPlane(packedPoint);
        if (area.getPlane() != plane) {
            return Integer.MAX_VALUE;
        }

        final int y = unpackWorldY(packedPoint);
        final int x = unpackWorldX(packedPoint);
        final int areaMaxX = area.getX() + area.getWidth() - 1;
        final int areaMaxY = area.getY() + area.getHeight() - 1;
        final int dx = Math.max(Math.max(area.getX() - x, 0), x - areaMaxX);
        final int dy = Math.max(Math.max(area.getY() - y, 0), y - areaMaxY);

        return Math.max(dx, dy);
    }
}

package Posiedien_Leagues_Planner;

import com.google.common.util.concurrent.ThreadFactoryBuilder;
import com.google.inject.Inject;
import com.google.inject.Provides;

import java.awt.*;
import java.awt.datatransfer.StringSelection;
import java.awt.event.MouseEvent;
import java.awt.geom.Area;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.*;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ThreadFactory;
import java.util.function.Consumer;
import java.util.regex.Pattern;

import net.runelite.client.input.MouseListener;
import net.runelite.client.input.MouseManager;

import lombok.Getter;
import net.runelite.api.*;
import net.runelite.api.Point;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.api.worldmap.WorldMap;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.JagexColors;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.worldmap.WorldMapOverlay;
import net.runelite.client.ui.overlay.worldmap.WorldMapPoint;
import net.runelite.client.ui.overlay.worldmap.WorldMapPointManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;
import Posiedien_Leagues_Planner.pathfinder.CollisionMap;
import Posiedien_Leagues_Planner.pathfinder.Pathfinder;
import Posiedien_Leagues_Planner.pathfinder.PathfinderConfig;
import Posiedien_Leagues_Planner.pathfinder.SplitFlagMap;

import net.runelite.client.plugins.PluginDescriptor;

@PluginDescriptor(
        name = "Posiedien Leagues Planner",
        description = "The plugin allows people to put in their own custom tasks or hook into tasks I've manually added into the planning.",
        tags = {"leagues", "trailblazer", "posiedien", "planning", "pathfinder", "map", "waypoint", "navigation"}
)

public class PosiedienLeaguesPlannerPlugin extends Plugin {
    protected static final String CONFIG_GROUP = "Posiedien_Leagues_Planner";
    private static final String ADD_START = "Add start";
    private static final String ADD_END = "Add end";
    private static final String CLEAR = "Clear";
    private static final String PATH = ColorUtil.wrapWithColorTag("Path", JagexColors.MENU_TARGET);
    private static final String SET = "Set";
    private static final String START = ColorUtil.wrapWithColorTag("Pathfinding Start", JagexColors.MENU_TARGET);
    private static final String TARGET = ColorUtil.wrapWithColorTag("Pathfinding Target", JagexColors.MENU_TARGET);
    private static final String TRANSPORT = ColorUtil.wrapWithColorTag("Transport", JagexColors.MENU_TARGET);
    private static final String WALK_HERE = "Walk here";
    private static final BufferedImage MARKER_IMAGE = ImageUtil.loadImageResource(PosiedienLeaguesPlannerPlugin.class, "/marker.png");
    private static final BufferedImage TASK_IMAGE = ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/TaskIcon.png");
    public boolean enableAutoRecalculate = false;

    @Inject
    public Client client;
    public boolean bMapDisplayPointsDirty;

    @Getter
    @Inject
    ConfigManager configManager;


    @Inject
    private MouseManager mouseManager;

    @Getter
    @Inject
    private ClientThread clientThread;

    @Inject
    public LeaguesPlannerConfig config;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private PathTileOverlay pathOverlay;

    @Inject
    private PathMinimapOverlay pathMinimapOverlay;

    @Inject
    private PathMapOverlay pathMapOverlay;

    @Inject
    private PathMapTooltipOverlay pathMapTooltipOverlay;

    @Inject
    private DebugOverlayPanel debugOverlayPanel;

    @Inject
    private SpriteManager spriteManager;

    @Inject
    private ClientToolbar clientToolbar;

    @Inject
    private WorldMapPointManager worldMapPointManager;

    @Inject
    private WorldMapOverlay worldMapOverlay;

    private Point lastMenuOpenedPoint;
    private WorldMapPoint marker;
    private WorldPoint transportStart;
    private WorldPoint lastLocation = new WorldPoint(0, 0, 0);
    private MenuEntry lastClick;
    private Shape minimapClipFixed;
    private Shape minimapClipResizeable;
    private BufferedImage minimapSpriteFixed;
    private BufferedImage minimapSpriteResizeable;
    private Rectangle minimapRectangle = new Rectangle();

    private ExecutorService pathfindingExecutor = Executors.newSingleThreadExecutor();
    private ExecutorService initExecutor = Executors.newSingleThreadExecutor();
    private Future<?> pathfinderFuture;
    private final Object pathfinderMutex = new Object();
    @Getter
    private Pathfinder pathfinder;
    public PathfinderConfig pathfinderConfig;
    @Getter
    private boolean startPointSet = false;

    public LeaguesPlannerPanel panel;
    public NavigationButton navButton;

    public volatile boolean bIsInitializing = false;


    private boolean isTaskWindowOpen()
    {
        Widget widget = client.getWidget(657, 10);
        return widget != null && !widget.isHidden();
    }

    public void InitializeFromOtherThread()
    {
        taskOverlay = new TaskOverlay(client, this, config);
        taskOverlay.worldMapOverlay = worldMapOverlay;

        Map<WorldPoint, List<Transport>> transports = Transport.loadAllFromResources();
        if (bCalculateOverworldPositions)
        {
            SplitFlagMap map = SplitFlagMap.fromResources(null, null);
            pathfinderConfig = new PathfinderConfig(map, transports, client, config);
        }

        overlayManager.add(pathOverlay);
        overlayManager.add(pathMinimapOverlay);
        overlayManager.add(pathMapOverlay);
        overlayManager.add(pathMapTooltipOverlay);

        if (config.drawDebugPanel()) {
            overlayManager.add(debugOverlayPanel);
        }

        try {
            InitializeRegionData();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        try {
            InitializeTaskData();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        InitializeCustomIconsMap();

        mouseManager.registerMouseListener(MouseListenerObject);

        SplitFlagMap NewMap = SplitFlagMap.fromResources(this, config);
        pathfinderConfig = new PathfinderConfig(NewMap, transports, client, config);

        EventQueue.invokeLater(() ->
        {
            panel = new LeaguesPlannerPanel(this);
            navButton = NavigationButton.builder()
                    .tooltip("Posiedien's Leagues Planner")
                    .icon(TASK_IMAGE)
                    .priority(7)
                    .panel(panel)
                    .build();
            clientToolbar.addNavigation(navButton);
            panel.refresh();

            bIsInitializing = false;
        });
    }

    @Override
    protected void startUp() throws Exception
    {
        bIsInitializing = true;

        PluginInitializer newPluginInitializer = new PluginInitializer(this);

        if (initExecutor == null)
        {
            initExecutor = Executors.newSingleThreadExecutor();
        }
        initExecutor.submit(newPluginInitializer);
    }

    @Override
    protected void shutDown() throws IOException
    {
        SaveRegionBounds();
        SaveTaskData();

        ShutdownRegionData();
        ShutdownTaskData();

        overlayManager.remove(pathOverlay);
        overlayManager.remove(pathMinimapOverlay);
        overlayManager.remove(pathMapOverlay);
        overlayManager.remove(pathMapTooltipOverlay);
        overlayManager.remove(debugOverlayPanel);

        mouseManager.unregisterMouseListener(MouseListenerObject);

        if (initExecutor != null) {
            initExecutor.shutdownNow();
            initExecutor = null;
        }


        if (pathfindingExecutor != null) {
            pathfindingExecutor.shutdownNow();
            pathfindingExecutor = null;
        }

        if (panel.pathfindingExecutor != null) {
            panel.pathfindingExecutor.shutdownNow();
            panel.pathfindingExecutor = null;
        }

        clientToolbar.removeNavigation(navButton);

        taskOverlay = null;
        panel = null;
        navButton = null;
    }

    private void SaveTaskData() throws IOException
    {
        if (bSaveTaskData)
        {
            // Task info
            File targ = new File("TaskData.csv");
            config.TaskData.exportToConverted(targ, this);
        }

        {
            // Task info
            File targ = new File("UserData.csv");
            config.UserData.exportTo(targ);
        }
    }

    public boolean bQueuedPathfinderTask = false;
    public void restartPathfinding(WorldPoint start, WorldPoint end, boolean bJustFindOverworld)
    {
        synchronized (pathfinderMutex) {
            if (pathfinder != null) {
                bQueuedPathfinderTask = true;
                pathfinder.cancel();
                pathfinderFuture.cancel(true);
            }

            if (pathfindingExecutor == null) {
                ThreadFactory shortestPathNaming = new ThreadFactoryBuilder().setNameFormat("shortest-path-%d").build();
                pathfindingExecutor = Executors.newSingleThreadExecutor(shortestPathNaming);
            }
        }

        getClientThread().invokeLater(() -> {
            bQueuedPathfinderTask = false;
            pathfinderConfig.refresh();
            synchronized (pathfinderMutex)
            {
                pathfinder = new Pathfinder(pathfinderConfig, start, end, bJustFindOverworld);
                pathfinderFuture = pathfindingExecutor.submit(pathfinder);
            }
        });
    }

    public boolean isNearPath(WorldPoint location) {
        if (pathfinder == null || pathfinder.getPath() == null || pathfinder.getPath().isEmpty() ||
            config.recalculateDistance() < 0 || lastLocation.equals(lastLocation = location)) {
            return true;
        }

        for (WorldPoint point : pathfinder.getPath()) {
            if (location.distanceTo2D(point) < config.recalculateDistance()) {
                return true;
            }
        }

        return false;
    }

    private final Pattern TRANSPORT_OPTIONS_REGEX = Pattern.compile("^(avoidWilderness|use\\w+)$");

    @Subscribe
    public void onConfigChanged(ConfigChanged event)
    {
        if (bIsInitializing)
        {
            return;
        }

        CurrentRegion = GetRegionBounds(config.GetEditRegion());
        if (event.getKey().equals("GetEditRegion"))
        {
            if (config.GetEditRegion() == RegionType.NONE)
            {
                worldMapPointManager.removeIf(x -> x.getName() != null && x.getName().contains("LP: Region Bounds:"));
            }
            else
            {
                // Add all the serialized markers
                for (LeagueRegionBounds LocalCurrentRegion : config.RegionData.RegionData)
                {
                    LocalCurrentRegion.RegionPoints.forEach((key, value) ->
                    {
                        SetMarkerActivation(value, false);
                    });
                }
            }
        }

        if (!CONFIG_GROUP.equals(event.getGroup())) {
            return;
        }

        if ("drawDebugPanel".equals(event.getKey())) {
            if (config.drawDebugPanel()) {
                overlayManager.add(debugOverlayPanel);
            } else {
                overlayManager.remove(debugOverlayPanel);
            }
            return;
        }

        // Transport option changed; rerun pathfinding
        if (TRANSPORT_OPTIONS_REGEX.matcher(event.getKey()).find()) {
            if (pathfinder != null) {
                restartPathfinding(pathfinder.getStart(), pathfinder.getTarget(), false);
            }
        }
    }

    @Subscribe
    public void onMenuOpened(MenuOpened event)
    {
        if (bIsInitializing)
        {
            return;
        }

        final Widget map = client.getWidget(WidgetInfo.WORLD_MAP_VIEW);
        if (map == null)
        {
            return;
        }

        if (!map.getBounds().contains(client.getMouseCanvasPosition().getX(), client.getMouseCanvasPosition().getY()))
        {
            return;
        }

        CurrentRegion = GetRegionBounds(config.GetEditRegion());
        AddRightClickMenuEntries(event);

        lastMenuOpenedPoint = client.getMouseCanvasPosition();
    }

    public void QueueRefresh()
    {
        if (bIsInitializing)
        {
            return;
        }

        EventQueue.invokeLater(() -> {
            if (panel != null)
            {
                panel.refresh();
            }
            bMapDisplayPointsDirty = true;
                }
        );
    }

    Player CachedPlayer = null;
    float Timer = 0.0f;
    double SinceLastInputTimer = 0.0f;

    // Taken from osleague-runelite-plugin
    private boolean isTaskCompleted(Widget taskLabel)
    {
        return taskLabel.getTextColor() != 0x9f9f9f;
    }

    // Taken from osleague-runelite-plugin
    private void MarkCompletedTasksFromList()
    {
        Widget taskLabelsWidget = client.getWidget(657, 10);
        Widget taskPointsWidget = client.getWidget(657, 11);
        Widget taskDifficultiesWidget = client.getWidget(657, 16);
        if (taskLabelsWidget == null || taskPointsWidget == null || taskDifficultiesWidget == null)
        {
            return;
        }

        Widget[] taskLabels = taskLabelsWidget.getDynamicChildren();
        Widget[] taskPoints = taskPointsWidget.getDynamicChildren();
        Widget[] taskDifficulties = taskDifficultiesWidget.getDynamicChildren();
        if (taskLabels.length != taskPoints.length || taskPoints.length != taskDifficulties.length)
        {
            return;
        }

        for (Widget taskLabel : taskLabels)
        {
            String name = taskLabel.getText();

            // Find our task from the name
            for (Map.Entry<UUID, TaskData> SearchingTask : config.TaskData.LeaguesTaskList.entrySet())
            {
                if (SearchingTask.getValue().TaskName.contains(name))
                {
                    if (isTaskCompleted(taskLabel))
                    {
                        config.UserData.CompletedTasks.add(SearchingTask.getKey());
                    }
                }
            }
        }
    }

    boolean bWasTaskWindowOpen = false;

    @Subscribe
    public void onGameTick(GameTick tick)
    {
        if (bIsInitializing)
        {
            return;
        }
        Player localPlayer = client.getLocalPlayer();

        SinceLastInputTimer += 0.6f;
        if (enableAutoRecalculate)
        {
            // Each tick is around 0.6 seconds according to docs
            Timer += 0.6f;
            if (Timer > 5.0f)
            {
                Timer = 0.0f;
                QueueRefresh();
            }
        }

        if (isTaskWindowOpen())
        {
            if (!bWasTaskWindowOpen)
            {
                MarkCompletedTasksFromList();
            }
            bWasTaskWindowOpen = true;
        }
        else
        {
            bWasTaskWindowOpen = false;
        }

        CachedPlayer = localPlayer;
        if (localPlayer == null || pathfinder == null)
        {
            return;
        }

        WorldPoint currentLocation = client.isInInstancedRegion() ?
            WorldPoint.fromLocalInstance(client, localPlayer.getLocalLocation()) : localPlayer.getWorldLocation();
        if (currentLocation.distanceTo(pathfinder.getTarget()) < config.reachedDistance()) {
            setTarget(null);
            return;
        }

        if (!startPointSet && !isNearPath(currentLocation)) {
            if (config.cancelInstead()) {
                setTarget(null);
                return;
            }
            restartPathfinding(currentLocation, pathfinder.getTarget(), false);
        }
    }

    @Subscribe
    public void onMenuEntryAdded(MenuEntryAdded event)
    {
        if (bIsInitializing)
        {
            return;
        }

        if (client.isKeyPressed(KeyCode.KC_SHIFT) && event.getOption().equals(WALK_HERE) && event.getTarget().isEmpty()) {
            if (config.drawTransports()) {
                addMenuEntry(event, ADD_START, TRANSPORT, 1);
                addMenuEntry(event, ADD_END, TRANSPORT, 1);
                // addMenuEntry(event, "Copy Position");
            }

            addMenuEntry(event, SET, TARGET, 1);
            if (pathfinder != null) {
                if (pathfinder.getTarget() != null) {
                    addMenuEntry(event, SET, START, 1);
                }
                WorldPoint selectedTile = getSelectedWorldPoint();
                if (pathfinder.getPath() != null) {
                    for (WorldPoint tile : pathfinder.getPath()) {
                        if (tile.equals(selectedTile)) {
                            addMenuEntry(event, CLEAR, PATH, 1);
                            break;
                        }
                    }
                }
            }
        }

        final Widget map = client.getWidget(WidgetInfo.WORLD_MAP_VIEW);

        if (map != null && map.getBounds().contains(client.getMouseCanvasPosition().getX(), client.getMouseCanvasPosition().getY())) {
            addMenuEntry(event, SET, TARGET, 0);
            if (pathfinder != null) {
                if (pathfinder.getTarget() != null) {
                    addMenuEntry(event, SET, START, 0);
                    addMenuEntry(event, CLEAR, PATH, 0);
                }
            }
        }

        final Shape minimap = getMinimapClipArea();

        if (minimap != null && pathfinder != null &&
            minimap.contains(client.getMouseCanvasPosition().getX(), client.getMouseCanvasPosition().getY())) {
            addMenuEntry(event, CLEAR, PATH, 0);
        }

        if (minimap != null && pathfinder != null &&
            ("Floating World Map".equals(Text.removeTags(event.getOption())) ||
             "Close Floating panel".equals(Text.removeTags(event.getOption())))) {
            addMenuEntry(event, CLEAR, PATH, 1);
        }
    }

    public Map<WorldPoint, List<Transport>> getTransports() {
        return pathfinderConfig.getTransports();
    }

    public CollisionMap getMap() {
        return pathfinderConfig.getMap();
    }

    public Area ObtainWorldMapClipArea(Rectangle baseRectangle)
    {
        final Widget overview = client.getWidget(WidgetInfo.WORLD_MAP_OVERVIEW_MAP);
        final Widget surfaceSelector = client.getWidget(WidgetInfo.WORLD_MAP_SURFACE_SELECTOR);

        Area clipArea = new Area(baseRectangle);

        if (overview != null && !overview.isHidden())
        {
            clipArea.subtract(new Area(overview.getBounds()));
        }

        if (surfaceSelector != null && !surfaceSelector.isHidden())
        {
            clipArea.subtract(new Area(surfaceSelector.getBounds()));
        }

        return clipArea;
    }

    MouseListener MouseListenerObject = new MouseListener()
    {
        @Override
        public MouseEvent mouseClicked(MouseEvent e)
        {
            if (CustomTask_ChangingIcon == null)
            {
                return e;
            }

            if (SinceLastInputTimer < 0.7f)
            {
                return e;
            }

            getClientThread().invokeLater(() ->
            {
                Area WorldMapClipArea = ObtainWorldMapClipArea(Objects.requireNonNull(client.getWidget(WidgetInfo.WORLD_MAP_VIEW)).getBounds());
                Point HighlightGraphicsPoint = new Point(0,0);
                if (getSelectedWorldPoint() != null)
                {
                    HighlightGraphicsPoint = worldMapOverlay.mapWorldPointToGraphicsPoint(getSelectedWorldPoint());
                    if (HighlightGraphicsPoint == null)
                    {
                        HighlightGraphicsPoint = new Point(0,0);
                    }
                }

                // Render all of our options centered around the center of the screen
                int TotalIconCount = CustomIconsMap.size();
                int IconSize = 30;
                int IconSizeHalf = IconSize / 2;

                Rectangle2D Bounds = WorldMapClipArea.getBounds2D();

                int RowAndHeightSize = (int) Math.sqrt(TotalIconCount);
                int i = 0;
                for (Map.Entry<String, BufferedImage> CustomIcon : CustomIconsMap.entrySet())
                {
                    int OffsetX = (int) (Bounds.getCenterX() - (RowAndHeightSize / 2) * IconSize);
                    int OffsetY = (int) (Bounds.getCenterY() - (RowAndHeightSize / 2) * IconSize);

                    OffsetX += ((i % RowAndHeightSize) * IconSize);
                    OffsetY += ((i / RowAndHeightSize) * IconSize);

                    Point IconPoint = new Point(OffsetX, OffsetY);
                    if (HighlightGraphicsPoint.distanceTo(IconPoint) < IconSizeHalf)
                    {
                        CustomTask_ChangingIcon.CustomIcon = CustomIcon.getKey();
                        break;
                    }

                    ++i;
                }

                CustomTask_ChangingIcon = null;
            });
            return e;
        }

        @Override
        public MouseEvent mousePressed(MouseEvent mouseEvent) {
            return mouseEvent;
        }

        @Override
        public MouseEvent mouseReleased(MouseEvent mouseEvent) {
            return mouseEvent;
        }

        @Override
        public MouseEvent mouseEntered(MouseEvent mouseEvent) {
            return mouseEvent;
        }

        @Override
        public MouseEvent mouseExited(MouseEvent mouseEvent) {
            return mouseEvent;
        }

        @Override
        public MouseEvent mouseDragged(MouseEvent mouseEvent) {
            return mouseEvent;
        }

        @Override
        public MouseEvent mouseMoved(MouseEvent mouseEvent) {
            return mouseEvent;
        }
    };

    private void onMenuOptionClicked(MenuEntry entry) {
        Player localPlayer = client.getLocalPlayer();
        if (localPlayer == null) {
            return;
        }

        WorldPoint currentLocation = client.isInInstancedRegion() ?
            WorldPoint.fromLocalInstance(client, localPlayer.getLocalLocation()) : localPlayer.getWorldLocation();
        if (entry.getOption().equals(ADD_START) && entry.getTarget().equals(TRANSPORT)) {
            transportStart = currentLocation;
        }

        if (entry.getOption().equals(ADD_END) && entry.getTarget().equals(TRANSPORT)) {
            WorldPoint transportEnd = client.isInInstancedRegion() ?
                WorldPoint.fromLocalInstance(client, localPlayer.getLocalLocation()) : localPlayer.getWorldLocation();
            System.out.println(transportStart.getX() + " " + transportStart.getY() + " " + transportStart.getPlane() + " " +
                    currentLocation.getX() + " " + currentLocation.getY() + " " + currentLocation.getPlane() + " " +
                    lastClick.getOption() + " " + Text.removeTags(lastClick.getTarget()) + " " + lastClick.getIdentifier()
            );
            Transport transport = new Transport(transportStart, transportEnd);
            pathfinderConfig.getTransports().computeIfAbsent(transportStart, k -> new ArrayList<>()).add(transport);
        }

        if (entry.getOption().equals("Copy Position")) {
            Toolkit.getDefaultToolkit().getSystemClipboard().setContents(
                    new StringSelection("(" + currentLocation.getX() + ", "
                            + currentLocation.getY() + ", "
                            + currentLocation.getPlane() + ")"), null);
        }

        if (entry.getOption().equals(SET) && entry.getTarget().equals(TARGET)) {
            setTarget(getSelectedWorldPoint());
        }

        if (entry.getOption().equals(SET) && entry.getTarget().equals(START)) {
            setStart(getSelectedWorldPoint());
        }

        if (entry.getOption().equals(CLEAR) && entry.getTarget().equals(PATH)) {
            setTarget(null);
        }

        if (entry.getType() != MenuAction.WALK) {
            lastClick = entry;
        }
    }

    public WorldPoint getSelectedWorldPoint() {
        if (client.getWidget(WidgetInfo.WORLD_MAP_VIEW) == null) {
            if (client.getSelectedSceneTile() != null) {
                return client.isInInstancedRegion() ?
                    WorldPoint.fromLocalInstance(client, client.getSelectedSceneTile().getLocalLocation()) :
                    client.getSelectedSceneTile().getWorldLocation();
            }
        } else {
            return calculateMapPoint(client.isMenuOpen() ? lastMenuOpenedPoint : client.getMouseCanvasPosition());
        }
        return null;
    }

    private void setTarget(WorldPoint target) {
        Player localPlayer = client.getLocalPlayer();
        if (!startPointSet && localPlayer == null) {
            return;
        }

        if (target == null) {
            synchronized (pathfinderMutex) {
                if (pathfinder != null) {
                    pathfinder.cancel();
                }
                pathfinder = null;
            }

            worldMapPointManager.remove(marker);
            marker = null;
            startPointSet = false;
        } else {
            worldMapPointManager.removeIf(x -> x == marker);
            marker = new WorldMapPoint(target, MARKER_IMAGE);
            marker.setName("Target");
            marker.setTarget(marker.getWorldPoint());
            marker.setJumpOnClick(true);
            worldMapPointManager.add(marker);

            WorldPoint start = client.isInInstancedRegion() ?
                WorldPoint.fromLocalInstance(client, localPlayer.getLocalLocation()) : localPlayer.getWorldLocation();
            lastLocation = start;
            if (startPointSet && pathfinder != null) {
                start = pathfinder.getStart();
            }
            restartPathfinding(start, target, false);
        }
    }

    private void setStart(WorldPoint start) {
        if (pathfinder == null) {
            return;
        }
        startPointSet = true;
        restartPathfinding(start, pathfinder.getTarget(), false);
    }

    public WorldPoint calculateMapPoint(Point point)
    {
        WorldMap worldMap = client.getWorldMap();
        float zoom = worldMap.getWorldMapZoom();
        final WorldPoint mapPoint = new WorldPoint(worldMap.getWorldMapPosition().getX(), worldMap.getWorldMapPosition().getY(), 0);
        final Point middle = mapWorldPointToGraphicsPoint(mapPoint);

        if (point == null || middle == null) {
            return null;
        }

        final int dx = (int) ((point.getX() - middle.getX()) / zoom);
        final int dy = (int) ((-(point.getY() - middle.getY())) / zoom);

        return mapPoint.dx(dx).dy(dy);
    }

    public Point mapWorldPointToGraphicsPoint(WorldPoint worldPoint) {
        WorldMap worldMap = client.getWorldMap();

        float pixelsPerTile = worldMap.getWorldMapZoom();

        Widget map = client.getWidget(WidgetInfo.WORLD_MAP_VIEW);
        if (map != null) {
            Rectangle worldMapRect = map.getBounds();

            int widthInTiles = (int) Math.ceil(worldMapRect.getWidth() / pixelsPerTile);
            int heightInTiles = (int) Math.ceil(worldMapRect.getHeight() / pixelsPerTile);

            Point worldMapPosition = worldMap.getWorldMapPosition();

            int yTileMax = worldMapPosition.getY() - heightInTiles / 2;
            int yTileOffset = (yTileMax - worldPoint.getY() - 1) * -1;
            int xTileOffset = worldPoint.getX() + widthInTiles / 2 - worldMapPosition.getX();

            int xGraphDiff = ((int) (xTileOffset * pixelsPerTile));
            int yGraphDiff = (int) (yTileOffset * pixelsPerTile);

            yGraphDiff -= pixelsPerTile - Math.ceil(pixelsPerTile / 2);
            xGraphDiff += pixelsPerTile - Math.ceil(pixelsPerTile / 2);

            yGraphDiff = worldMapRect.height - yGraphDiff;
            yGraphDiff += (int) worldMapRect.getY();
            xGraphDiff += (int) worldMapRect.getX();

            return new Point(xGraphDiff, yGraphDiff);
        }
        return null;
    }

    private void addMenuEntry(MenuEntryAdded event, String option, String target, int position) {
        List<MenuEntry> entries = new LinkedList<>(Arrays.asList(client.getMenuEntries()));

        if (entries.stream().anyMatch(e -> e.getOption().equals(option) && e.getTarget().equals(target))) {
            return;
        }

        client.createMenuEntry(position)
            .setOption(option)
            .setTarget(target)
            .setParam0(event.getActionParam0())
            .setParam1(event.getActionParam1())
            .setIdentifier(event.getIdentifier())
            .setType(MenuAction.RUNELITE)
            .onClick(this::onMenuOptionClicked);
    }

    private Widget getMinimapDrawWidget() {
        if (client.isResized()) {
            if (client.getVarbitValue(Varbits.SIDE_PANELS) == 1) {
                return client.getWidget(WidgetInfo.RESIZABLE_MINIMAP_DRAW_AREA);
            }
            return client.getWidget(WidgetInfo.RESIZABLE_MINIMAP_STONES_DRAW_AREA);
        }
        return client.getWidget(WidgetInfo.FIXED_VIEWPORT_MINIMAP_DRAW_AREA);
    }

    private Shape getMinimapClipAreaSimple() {
        Widget minimapDrawArea = getMinimapDrawWidget();

        if (minimapDrawArea == null || minimapDrawArea.isHidden()) {
            return null;
        }

        Rectangle bounds = minimapDrawArea.getBounds();

        return new Ellipse2D.Double(bounds.getX(), bounds.getY(), bounds.getWidth(), bounds.getHeight());
    }

    public Shape getMinimapClipArea() {
        Widget minimapWidget = getMinimapDrawWidget();

        if (minimapWidget == null || minimapWidget.isHidden() || !minimapRectangle.equals(minimapRectangle = minimapWidget.getBounds())) {
            minimapClipFixed = null;
            minimapClipResizeable = null;
            minimapSpriteFixed = null;
            minimapSpriteResizeable = null;
        }

        if (client.isResized()) {
            if (minimapClipResizeable != null) {
                return minimapClipResizeable;
            }
            if (minimapSpriteResizeable == null) {
                minimapSpriteResizeable = spriteManager.getSprite(SpriteID.RESIZEABLE_MODE_MINIMAP_ALPHA_MASK, 0);
            }
            if (minimapSpriteResizeable != null) {
                minimapClipResizeable = bufferedImageToPolygon(minimapSpriteResizeable);
                return minimapClipResizeable;
            }
            return getMinimapClipAreaSimple();
        }
        if (minimapClipFixed != null) {
            return minimapClipFixed;
        }
        if (minimapSpriteFixed == null) {
            minimapSpriteFixed = spriteManager.getSprite(SpriteID.FIXED_MODE_MINIMAP_ALPHA_MASK, 0);
        }
        if (minimapSpriteFixed != null) {
            minimapClipFixed = bufferedImageToPolygon(minimapSpriteFixed);
            return minimapClipFixed;
        }
        return getMinimapClipAreaSimple();
    }

    private Polygon bufferedImageToPolygon(BufferedImage image) {
        Color outsideColour = null;
        Color previousColour;
        final int width = image.getWidth();
        final int height = image.getHeight();
        List<java.awt.Point> points = new ArrayList<>();
        for (int y = 0; y < height; y++) {
            previousColour = outsideColour;
            for (int x = 0; x < width; x++) {
                int rgb = image.getRGB(x, y);
                int a = (rgb & 0xff000000) >>> 24;
                int r = (rgb & 0x00ff0000) >> 16;
                int g = (rgb & 0x0000ff00) >> 8;
                int b = (rgb & 0x000000ff) >> 0;
                Color colour = new Color(r, g, b, a);
                if (x == 0 && y == 0) {
                    outsideColour = colour;
                    previousColour = colour;
                }
                if (!colour.equals(outsideColour) && previousColour.equals(outsideColour)) {
                    points.add(new java.awt.Point(x, y));
                }
                if ((colour.equals(outsideColour) || x == (width - 1)) && !previousColour.equals(outsideColour)) {
                    points.add(0, new java.awt.Point(x, y));
                }
                previousColour = colour;
            }
        }
        int offsetX = minimapRectangle.x;
        int offsetY = minimapRectangle.y;
        Polygon polygon = new Polygon();
        for (java.awt.Point point : points) {
            polygon.addPoint(point.x + offsetX, point.y + offsetY);
        }
        return polygon;
    }


    public LeagueRegionBounds CurrentRegion = null;
    public LeagueRegionPoint LastClickedRegionPoint = null;
    @Inject
    public RegionBoundOverlay regionBoundOverlay = new RegionBoundOverlay(client, this, config);

    @Inject
    public TaskOverlay taskOverlay = null;

    public LeagueRegionPoint CurrentFocusedPoint;


    // Debug flags for saving/loading new data
    private boolean bLoadRawWikiData = false;
    private boolean bCalculateOverworldPositions = false;
    private boolean bSaveTaskData = false;
    private boolean bSaveRegionData = false;

    void SaveRegionBounds() throws IOException
    {
        if (bSaveRegionData)
        {
            File targ = new File("RegionBoundData.csv");
            config.RegionData.exportTo(targ);
        }
    }

    void LoadRegionBounds() throws IOException
    {
        File targ = new File("RegionBoundData.csv");
        config.RegionData.importFrom(targ);
    }

    void LoadTaskData() throws IOException
    {
        config.TaskData.LeaguesTaskList.clear();
        config.TaskData.StringToTask.clear();

        {
            // Task info, Trailblazer
            File targ = new File("ConvertedTaskData/TrailblazerTaskData.csv");
            config.TaskData.importFromConverted(targ);
        }

        {
            // Task info, Shattered
            File targ = new File("ConvertedTaskData/ShatteredTaskData.csv");
            config.TaskData.importFromConverted(targ);
        }

        if (bLoadRawWikiData)
        {
            config.TaskData.importFromRaw();
        }

        if (bCalculateOverworldPositions)
        {
            config.TaskData.CalculateAndCacheOverworldLocations(this);
        }

        {
            // Custom Task/Plan info
            File targ = new File("UserData.csv");
            config.UserData.importFrom(targ);
        }

    }

    private boolean GatherRegionBounds(WorldPointPolygon poly, ArrayList<RegionLine> regionLines, Set<UUID> VisitedPoints, LeagueRegionPoint nextPoint, LeagueRegionPoint parentPoint)
    {
        if (VisitedPoints.contains(nextPoint.GUID))
        {
            // Connected back!
            return true;
        }
        VisitedPoints.add(nextPoint.GUID);
        WorldPoint end = nextPoint.OurWorldPoint;
        poly.AddWorldPoint(end);

        if (parentPoint != null)
        {
            WorldPoint start = parentPoint.OurWorldPoint;
            regionLines.add(new RegionLine(start, end));
        }

        // Recursively visit all the points and draw a polygon if one exists
        for (LeagueRegionPoint connectedPoint : nextPoint.ConnectedPoints)
        {
            // don't go backwards
            if (parentPoint == connectedPoint)
            {
                continue;
            }

            if (GatherRegionBounds(poly, regionLines, VisitedPoints, connectedPoint, nextPoint))
            {
                // Connected back!
                return true;
            }
        }

        return false;
    }

    private void RefreshRegionBounds()
    {
        Set<UUID> VisitedPoints = new HashSet<>();
        for (LeagueRegionBounds regionDatum : config.RegionData.RegionData)
        {
            Color DrawColor = RegionType.GetRegionColor(config, regionDatum.Type, true);
            regionDatum.RegionPolygons.clear();
            regionDatum.RegionLines.clear();

            regionDatum.RegionPoints.forEach((key, value) ->
            {
                // Early out
                if (VisitedPoints.contains(value.GUID))
                {
                    return;
                }

                WorldPointPolygon newPolygon = new WorldPointPolygon();

                if (GatherRegionBounds(newPolygon, regionDatum.RegionLines, VisitedPoints, value, null))
                {
                    regionDatum.RegionPolygons.add(newPolygon);
                    newPolygon.CacheWorldPoly();
                }
            });
        }
    }

    public void InitializeRegionData() throws Exception
    {
        config.RegionData.RegionData.clear();
        for (RegionType CurrentRegion : RegionType.values())
        {
            if (CurrentRegion == RegionType.NONE)
            {
                continue;
            }

            config.RegionData.RegionData.add(new LeagueRegionBounds(CurrentRegion));
        }

        LoadRegionBounds();
        // Add all the serialized markers
        for (LeagueRegionBounds LocalCurrentRegion : config.RegionData.RegionData)
        {
            LocalCurrentRegion.RegionPoints.forEach((key, value) ->
            {
                SetMarkerActivation(value, false);
            });
        }

        RefreshRegionBounds();
        overlayManager.add(regionBoundOverlay);
    }

    public void ShutdownRegionData()
    {
        overlayManager.remove(regionBoundOverlay);
        worldMapPointManager.removeIf(x -> x.getName() != null && x.getName().contains("LP:"));
    }

    public LeagueRegionBounds GetRegionBounds(RegionType Type)
    {
        for (LeagueRegionBounds CurrentBounds : config.RegionData.RegionData)
        {
            if (CurrentBounds.Type == Type)
            {
                return CurrentBounds;
            }
        }

        return null;
    }


    public void InitializeTaskData() throws Exception
    {
        config.TaskData.LeaguesTaskList.clear();
        LoadTaskData();

        overlayManager.add(taskOverlay);
    }

    public void ShutdownTaskData()
    {
        overlayManager.remove(taskOverlay);
    }

    public WorldPoint LastDisplayedWorldPoint;

    private static final BufferedImage ACTIVE_MARKER_IMAGE = ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/activemarker.png");

    public static final BufferedImage BOUNDS_SELECTED = ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/BoundPoint_Selected.png");
    private static final BufferedImage BOUNDS_MISTHALIN = ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/BoundPoint_Misthalin.png");
    private static final BufferedImage BOUNDS_KARAMJA = ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/BoundPoint_Karamja.png");
    private static final BufferedImage BOUNDS_KANDARIN = ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/BoundPoint_Kandarin.png");
    private static final BufferedImage BOUNDS_ASGARNIA = ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/BoundPoint_Asgarnia.png");
    private static final BufferedImage BOUNDS_FREMENNIK = ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/BoundPoint_Fremennik.png");
    private static final BufferedImage BOUNDS_KOUREND = ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/BoundPoint_Kourend.png");
    private static final BufferedImage BOUNDS_WILDERNESS = ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/BoundPoint_Wilderness.png");
    private static final BufferedImage BOUNDS_MORYTANIA = ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/BoundPoint_Morytania.png");
    private static final BufferedImage BOUNDS_TIRANNWN = ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/BoundPoint_Tirannwn.png");
    private static final BufferedImage BOUNDS_DESERT = ImageUtil.getResourceStreamFromClass(PosiedienLeaguesPlannerPlugin.class, "/BoundPoint_Desert.png");

    public BufferedImage GetRegionImage(RegionType Type)
    {
        switch(Type)
        {
            case MISTHALIN:
                return BOUNDS_MISTHALIN;
            case KARAMJA:
                return BOUNDS_KARAMJA;
            case KANDARIN:
                return BOUNDS_KANDARIN;
            case ASGARNIA:
                return BOUNDS_ASGARNIA;
            case FREMENNIK:
                return BOUNDS_FREMENNIK;
            case KOUREND:
                return BOUNDS_KOUREND;
            case WILDERNESS:
                return BOUNDS_WILDERNESS;
            case MORYTANIA:
                return BOUNDS_MORYTANIA;
            case TIRANNWN:
                return BOUNDS_TIRANNWN;
            case DESERT:
                return BOUNDS_DESERT;
        }
        return MARKER_IMAGE;
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged)
    {
        if (gameStateChanged.getGameState() == GameState.LOGGED_IN)
        {
            //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Posiedien Leagues Planner says " + config.greeting(), null);
        }
    }

    @Subscribe
    public void onMenuOptionClicked(MenuOptionClicked event)
    {
        if (bIsInitializing)
        {
            return;
        }

        final Widget map = client.getWidget(WidgetInfo.WORLD_MAP_VIEW);
        if (map == null)
        {
            return;
        }

        if (!map.getBounds().contains(client.getMouseCanvasPosition().getX(), client.getMouseCanvasPosition().getY()))
        {
            return;
        }

        LeagueRegionPoint ClickedPoint = GetClickedRegionPoint(Collections.singletonList(event.getMenuEntry()));
        if (ClickedPoint != null && event.getMenuOption().contains("Focus on"))
        {
            // Toggle activation
            SetMarkerActivation(ClickedPoint, CurrentFocusedPoint != ClickedPoint);

            RefreshRegionBounds();
        }
    }

    @Provides
    LeaguesPlannerConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(LeaguesPlannerConfig.class);
    }

    private WorldPoint CalculateMapPoint(Point point)
    {
        if (point == null)
        {
            return null;
        }

        float zoom = client.getRenderOverview().getWorldMapZoom();
        RenderOverview renderOverview = client.getRenderOverview();
        final WorldPoint mapPoint = new WorldPoint(renderOverview.getWorldMapPosition().getX(), renderOverview.getWorldMapPosition().getY(), 0);
        final Point middle = worldMapOverlay.mapWorldPointToGraphicsPoint(mapPoint);
        if (middle == null)
        {
            return null;
        }

        final int dx = (int) ((point.getX() - middle.getX()) / zoom);
        final int dy = (int) ((-(point.getY() - middle.getY())) / zoom);

        return mapPoint.dx(dx).dy(dy);
    }

    private final void SetMarkerActivation(LeagueRegionPoint RegionPoint, boolean shouldActivate)
    {
        if (config.GetEditRegion() == RegionType.NONE)
        {
            return;
        }

        if (shouldActivate)
        {
            if (CurrentFocusedPoint != null)
            {
                SetMarkerActivation(CurrentFocusedPoint, false);
            }

            CurrentFocusedPoint = RegionPoint;

            WorldMapPoint OldMarker = RegionPoint.OurPoint;
            worldMapPointManager.removeIf(x -> x == OldMarker);

            WorldPoint WorldPointLocation;
            if (RegionPoint.OurWorldPoint == null)
            {
                WorldPointLocation = LastDisplayedWorldPoint;
            }
            else
            {
                WorldPointLocation = RegionPoint.OurWorldPoint;
            }

            RegionPoint.OurPoint = new WorldMapPoint(WorldPointLocation, BOUNDS_SELECTED);
            RegionPoint.OurWorldPoint = WorldPointLocation;
            WorldMapPoint NewMarker = RegionPoint.OurPoint;
            NewMarker.setTarget(WorldPointLocation);
            NewMarker.setJumpOnClick(true);
            NewMarker.setName("LP: Region Bounds: " + RegionPoint.Region+ " " + WorldPointLocation + " guid:"+ RegionPoint.GUID);
            worldMapPointManager.add(NewMarker);
        }
        else
        {
            WorldMapPoint OldMarker = RegionPoint.OurPoint;
            worldMapPointManager.removeIf(x -> x == OldMarker);

            WorldPoint WorldPointLocation;
            if (RegionPoint.OurWorldPoint == null)
            {
                WorldPointLocation = LastDisplayedWorldPoint;
            }
            else
            {
                WorldPointLocation = RegionPoint.OurWorldPoint;
            }

            RegionPoint.OurPoint = new WorldMapPoint(WorldPointLocation, GetRegionImage(RegionPoint.Region));
            RegionPoint.OurWorldPoint = WorldPointLocation;
            WorldMapPoint NewMarker = RegionPoint.OurPoint;
            NewMarker.setTarget(WorldPointLocation);
            NewMarker.setJumpOnClick(true);
            NewMarker.setName("LP: Region Bounds: " + RegionPoint.Region + " " + WorldPointLocation + " guid:"+ RegionPoint.GUID);
            worldMapPointManager.add(NewMarker);
        }
    }

    private final Consumer<MenuEntry> SetNextRegionPointEntryCallback = n ->
    {
        LeagueRegionPoint LastRegionPoint = CurrentFocusedPoint;
        LeagueRegionPoint NewRegionPoint = new LeagueRegionPoint();

        UUID uuid = UUID.randomUUID();
        NewRegionPoint.GUID = uuid;
        NewRegionPoint.Region = CurrentRegion.Type;
        CurrentRegion.RegionPoints.put(NewRegionPoint.GUID, NewRegionPoint);

        SetMarkerActivation(NewRegionPoint, true);

        if (LastRegionPoint != null)
        {
            // At capacity, remove last added
            if (LastRegionPoint.ConnectedPoints.size() == 2)
            {
                LastRegionPoint.ConnectedPoints.get(1).ConnectedPoints.remove(LastRegionPoint);
                LastRegionPoint.ConnectedPoints.remove(1);
            }

            LastRegionPoint.ConnectedPoints.add(NewRegionPoint);
            NewRegionPoint.ConnectedPoints.add(LastRegionPoint);
        }


        RefreshRegionBounds();
    };

    HashMap<Integer, TaskData> HashCodeToHash = new HashMap<>();

    private final Consumer<MenuEntry> AddTaskToBackOfPlan = n ->
    {
        TaskData CurrentTask = HashCodeToHash.get(n.getParam0());

        // Find greatest value of planned tasks
        int CurrentOrder = -1;

        for (HashMap.Entry<UUID, TaskSortData> mapElement : config.UserData.PlannedTasks.entrySet())
        {
            if (mapElement.getValue().SortPriority > CurrentOrder)
            {
                CurrentOrder = mapElement.getValue().SortPriority;
            }

        }

        config.UserData.PlannedTasks.put(CurrentTask.GUID, new TaskSortData(CurrentOrder + 1, CurrentTask.bIsCustomTask));

        config.UserData.HiddenTasks.remove(CurrentTask.GUID);
        QueueRefresh();
    };

    TaskData GetTaskData(UUID TaskID, Boolean bIsCustomTask)
    {
        if (bIsCustomTask)
        {
            return config.UserData.CustomTasks.get(TaskID);
        }

        return config.TaskData.LeaguesTaskList.get(TaskID);
    }

    ArrayList<UUID> TempArray = new ArrayList<>();
    private final Consumer<MenuEntry> AddTaskToFrontOfPlan = n ->
    {
        TaskData CurrentTask = HashCodeToHash.get(n.getParam0());

        // Find smallest value of planned tasks
        int CurrentOrder = 9000000;

        TempArray.clear();
        for (HashMap.Entry<UUID, TaskSortData> mapElement : config.UserData.PlannedTasks.entrySet())
        {
            if (mapElement.getValue().SortPriority < CurrentOrder)
            {
                CurrentOrder = mapElement.getValue().SortPriority;
            }
            TempArray.add(mapElement.getKey());
        }

        for (UUID SearchingTaskGUID : TempArray)
        {
            int OldOrder = config.UserData.PlannedTasks.get(SearchingTaskGUID).SortPriority;
            Boolean bOldIsCustomTask = config.UserData.PlannedTasks.get(SearchingTaskGUID).bIsCustomTask;

            config.UserData.PlannedTasks.remove(SearchingTaskGUID);
            config.UserData.PlannedTasks.put(SearchingTaskGUID, new TaskSortData(OldOrder + 1, bOldIsCustomTask));

            config.UserData.HiddenTasks.remove(SearchingTaskGUID);
        }

        if (CurrentOrder == 9000000)
        {
            CurrentOrder = 0;
        }

        config.UserData.PlannedTasks.put(CurrentTask.GUID, new TaskSortData(CurrentOrder, CurrentTask.bIsCustomTask));
        config.UserData.HiddenTasks.remove(CurrentTask.GUID);
        QueueRefresh();
    };

    private final Consumer<MenuEntry> RemoveTaskFromPlan = n ->
    {
        TaskData CurrentTask = HashCodeToHash.get(n.getParam0());
        config.UserData.PlannedTasks.remove(CurrentTask.GUID);
        QueueRefresh();
    };

    private final Consumer<MenuEntry> MoveForwardOnPlan = n ->
    {
        TaskData CurrentTask = HashCodeToHash.get(n.getParam0());

        // Find value closest to our order that is smallest
        // Between these two values, closest to current
        int CurrentHighest = -1;
        int CurrentOrder = config.UserData.PlannedTasks.get(CurrentTask.GUID).SortPriority;
        UUID ClosestTask = null;

        TempArray.clear();
        for (HashMap.Entry<UUID, TaskSortData> mapElement : config.UserData.PlannedTasks.entrySet())
        {
            if (!mapElement.getKey().equals(CurrentTask.GUID) && mapElement.getValue().SortPriority <= CurrentOrder && mapElement.getValue().SortPriority > CurrentHighest)
            {
                CurrentHighest = mapElement.getValue().SortPriority;
                ClosestTask = mapElement.getKey();
            }
            TempArray.add(mapElement.getKey());
        }

        // Replace at closest task (otherwise we are first!)
        if (ClosestTask != null)
        {
            // Replace this spot
            config.UserData.PlannedTasks.remove(CurrentTask.GUID);
            config.UserData.PlannedTasks.put(CurrentTask.GUID, new TaskSortData(CurrentHighest, CurrentTask.bIsCustomTask));

            config.UserData.HiddenTasks.remove(CurrentTask.GUID);
            for (UUID SearchingTaskGUID : TempArray)
            {
                if (SearchingTaskGUID.equals(CurrentTask.GUID))
                {
                    continue;
                }

                // Push these all back (insert)
                int OldOrder = config.UserData.PlannedTasks.get(SearchingTaskGUID).SortPriority;
                Boolean bOldCustomTask = config.UserData.PlannedTasks.get(SearchingTaskGUID).bIsCustomTask;
                if (OldOrder >= CurrentHighest)
                {
                    config.UserData.PlannedTasks.remove(SearchingTaskGUID);
                    config.UserData.PlannedTasks.put(SearchingTaskGUID, new TaskSortData(OldOrder + 1, bOldCustomTask));
                    config.UserData.HiddenTasks.remove(SearchingTaskGUID);
                }
            }

            QueueRefresh();
        }
    };

    private final Consumer<MenuEntry> MoveBackOnPlan = n ->
    {
        TaskData CurrentTask = HashCodeToHash.get(n.getParam0());

        // Find value closest to our order that is smallest
        // Between these two values, closest to current
        int CurrentLowest = 900000;
        int CurrentOrder = config.UserData.PlannedTasks.get(CurrentTask.GUID).SortPriority;
        UUID ClosestTask = null;

        TempArray.clear();
        for (HashMap.Entry<UUID, TaskSortData> mapElement : config.UserData.PlannedTasks.entrySet())
        {
            if (!mapElement.getKey().equals(CurrentTask.GUID) && mapElement.getValue().SortPriority >= CurrentOrder && mapElement.getValue().SortPriority < CurrentLowest)
            {
                CurrentLowest = mapElement.getValue().SortPriority;
                ClosestTask = mapElement.getKey();
            }
            TempArray.add(mapElement.getKey());
        }

        // Replace at closest task (otherwise we are first!)
        if (ClosestTask != null)
        {
            // Move up a little
            Boolean bOldCustomTaskClosest = config.UserData.PlannedTasks.get(ClosestTask).bIsCustomTask;
            config.UserData.PlannedTasks.remove(ClosestTask);
            config.UserData.PlannedTasks.put(ClosestTask, new TaskSortData(CurrentLowest - 1, bOldCustomTaskClosest));

            config.UserData.HiddenTasks.remove(ClosestTask);

            // Replace this spot
            config.UserData.PlannedTasks.remove(CurrentTask.GUID);
            config.UserData.PlannedTasks.put(CurrentTask.GUID, new TaskSortData(CurrentLowest, CurrentTask.bIsCustomTask));

            config.UserData.HiddenTasks.remove(CurrentTask.GUID);

            for (UUID SearchingTaskGUID : TempArray)
            {
                if (SearchingTaskGUID.equals(CurrentTask.GUID))
                {
                    continue;
                }

                // Push these all back (insert)
                int OldOrder = config.UserData.PlannedTasks.get(SearchingTaskGUID).SortPriority;
                Boolean bOldCustomTask = config.UserData.PlannedTasks.get(SearchingTaskGUID).bIsCustomTask;
                if (OldOrder >= CurrentLowest)
                {
                    config.UserData.PlannedTasks.remove(SearchingTaskGUID);
                    config.UserData.PlannedTasks.put(SearchingTaskGUID, new TaskSortData(OldOrder + 1, bOldCustomTask));
                    config.UserData.HiddenTasks.remove(SearchingTaskGUID);

                }
            }

            QueueRefresh();
        }
    };

    public void FocusOnTaskOnWorldMap(TaskData CurrentTask)
    {
        if (bIsInitializing)
        {
            return;
        }

        if (client != null && client.getWorldMap() != null)
        {
            double ShortestMapViewDistance = 1000000;
            WorldPoint ShortestMapViewWorldPoint = null;
            WorldMap worldMap = client.getWorldMap();
            if (worldMap != null)
            {
                WorldPoint mapPoint = new WorldPoint(worldMap.getWorldMapPosition().getX(), worldMap.getWorldMapPosition().getY(), 0);
                for (WorldPoint CurrentLocation : CurrentTask.Locations)
                {
                    double TaskDistance = CurrentLocation.distanceTo(mapPoint);
                    if (TaskDistance < ShortestMapViewDistance)
                    {
                        ShortestMapViewDistance = TaskDistance;
                        ShortestMapViewWorldPoint = CurrentLocation;
                    }
                }

                for (WorldPoint CurrentLocation : CurrentTask.OverworldLocations)
                {
                    double TaskDistance = CurrentLocation.distanceTo(mapPoint);
                    if (TaskDistance < ShortestMapViewDistance)
                    {
                        ShortestMapViewDistance = TaskDistance;
                        ShortestMapViewWorldPoint = CurrentLocation;
                    }
                }
            }

            WorldPoint FocusLocation = ShortestMapViewWorldPoint;

            if (FocusLocation == null && !CurrentTask.Locations.isEmpty())
            {
                FocusLocation = CurrentTask.Locations.get(0);
            }

            if (FocusLocation != null)
            {
                client.getWorldMap().setWorldMapPositionTarget(FocusLocation);
            }
        }
    }
    private final Consumer<MenuEntry> FocusOnTaskLocation = n ->
    {
        TaskData CurrentTask = HashCodeToHash.get(n.getParam0());
        FocusOnTaskOnWorldMap(CurrentTask);
    };

    private final Consumer<MenuEntry> CreateCustomTask = n ->
    {
        UUID newCustomTaskGUID = UUID.randomUUID();
        TaskData newTask = new TaskData();

        newTask.GUID = newCustomTaskGUID;
        newTask.Locations.add(LastDisplayedWorldPoint);
        newTask.Difficulty = TaskDifficulty.CUSTOM;
        newTask.TaskName = "Edit task in Panel";
        newTask.bIsCustomTask = true;

        config.UserData.CustomTasks.put(newCustomTaskGUID, newTask);

        bMapDisplayPointsDirty = true;
        QueueRefresh();
    };

    private final Consumer<MenuEntry> DestroyCustomTask = n ->
    {
        TaskData CurrentTask = HashCodeToHash.get(n.getParam0());
        config.UserData.CustomTasks.remove(CurrentTask.GUID);
        config.UserData.PlannedTasks.remove(CurrentTask.GUID);

        bMapDisplayPointsDirty = true;
        QueueRefresh();
    };


    HashMap<String, BufferedImage> CustomIconsMap = new HashMap<>();

    public void RegisterCustomIcon(String CustomIconName)
    {
        CustomIconsMap.put(CustomIconName, ImageUtil.loadImageResource(PosiedienLeaguesPlannerPlugin.class, CustomIconName));
    }
    public void InitializeCustomIconsMap()
    {
        RegisterCustomIcon("/AGILITY.png");
        RegisterCustomIcon("/ATTACK.png");
        RegisterCustomIcon("/CONSTRUCTION.png");
        RegisterCustomIcon("/COOKING.png");
        RegisterCustomIcon("/CRAFTING.png");
        RegisterCustomIcon("/DEFENCE.png");
        RegisterCustomIcon("/FARMING.png");
        RegisterCustomIcon("/FIREMAKING.png");
        RegisterCustomIcon("/FISHING.png");
        RegisterCustomIcon("/FLETCHING.png");
        RegisterCustomIcon("/HERBLORE.png");
        RegisterCustomIcon("/HITPOINTS.png");
        RegisterCustomIcon("/HUNTER.png");
        RegisterCustomIcon("/MAGIC.png");
        RegisterCustomIcon("/MINING.png");
        RegisterCustomIcon("/PRAYER.png");
        RegisterCustomIcon("/RANGED.png");
        RegisterCustomIcon("/RUNECRAFT.png");
        RegisterCustomIcon("/SMITHING.png");
        RegisterCustomIcon("/STRENGTH.png");
        RegisterCustomIcon("/THIEVING.png");
        RegisterCustomIcon("/taskMarkerPurp.png");
        RegisterCustomIcon("/taskMarkerRed.png");
        RegisterCustomIcon("/taskMarker.png");
        RegisterCustomIcon("/taskMarkerGreen.png");
        RegisterCustomIcon("/taskMarkerGreenEasy.png");
        RegisterCustomIcon("/taskMarkerGreenElite.png");
        RegisterCustomIcon("/taskMarkerGreenHard.png");
        RegisterCustomIcon("/taskMarkerGreenMedium.png");
        RegisterCustomIcon("/STRENGTH.png");
        RegisterCustomIcon("/icon_background.png");
        RegisterCustomIcon("/BlankIcon.png");
    }

    TaskData CustomTask_ChangingIcon = null;


    private final Consumer<MenuEntry> ChangeIconCustomTask = n ->
    {
        CustomTask_ChangingIcon = HashCodeToHash.get(n.getParam0());
        SinceLastInputTimer = 0.0f;
    };


    private final Consumer<MenuEntry> SetActiveRegionPointEntryCallback = n ->
    {
        SetMarkerActivation(LastClickedRegionPoint, true);


        RefreshRegionBounds();
    };

    private final Consumer<MenuEntry> DeleteRegionPointEntryCallback = n ->
    {
        // Remove connections
        for (LeagueRegionPoint ConnectedPoint : LastClickedRegionPoint.ConnectedPoints)
        {
            ConnectedPoint.ConnectedPoints.remove(LastClickedRegionPoint);
        }
        LastClickedRegionPoint.ConnectedPoints.clear();

        worldMapPointManager.removeIf(x -> x == LastClickedRegionPoint.OurPoint);

        CurrentRegion.RegionPoints.remove(LastClickedRegionPoint.GUID);
        if (LastClickedRegionPoint == CurrentFocusedPoint)
        {
            CurrentFocusedPoint = null;
        }


        RefreshRegionBounds();
    };

    private final Consumer<MenuEntry> ConnectRegionPointEntryCallback = n ->
    {
        // If we are already connected, disconnect instead
        for (LeagueRegionPoint ConnectedPoint : CurrentFocusedPoint.ConnectedPoints)
        {
            if (ConnectedPoint == LastClickedRegionPoint)
            {
                ConnectedPoint.ConnectedPoints.remove(CurrentFocusedPoint);
                CurrentFocusedPoint.ConnectedPoints.remove(ConnectedPoint);

                RefreshRegionBounds();
                return;
            }
        }

        // At capacity, remove last added
        if (CurrentFocusedPoint.ConnectedPoints.size() == 2)
        {
            CurrentFocusedPoint.ConnectedPoints.get(1).ConnectedPoints.remove(CurrentFocusedPoint);
            CurrentFocusedPoint.ConnectedPoints.remove(1);
        }

        CurrentFocusedPoint.ConnectedPoints.add(LastClickedRegionPoint);

        // At capacity, remove last added
        if (LastClickedRegionPoint.ConnectedPoints.size() == 2)
        {
            LastClickedRegionPoint.ConnectedPoints.get(1).ConnectedPoints.remove(LastClickedRegionPoint);
            LastClickedRegionPoint.ConnectedPoints.remove(1);
        }

        LastClickedRegionPoint.ConnectedPoints.add(CurrentFocusedPoint);


        RefreshRegionBounds();
    };

    private final LeagueRegionPoint GetClickedRegionPoint(List<MenuEntry> entries)
    {
        for (MenuEntry CurrentEntry : entries)
        {
            if (!CurrentEntry.getOption().contains("Focus"))
            {
                continue;
            }

            String TargetString = CurrentEntry.getTarget();
            if (CurrentRegion != null && TargetString.contains("Region Bounds: "))
            {
                int index = TargetString.indexOf("guid:");

                // Guids are 36 indices long
                String SubString = TargetString.substring(index + 5, index + 5 + 36);

                UUID FoundGUID = UUID.fromString(SubString);
                LeagueRegionPoint FoundPoint = CurrentRegion.RegionPoints.get(FoundGUID);
                if (FoundPoint != null)
                {
                    return FoundPoint;
                }
            }
        }

        return null;
    }

    private void AddRightClickMenuEntries(MenuOpened event)
    {
        List<MenuEntry> entries = new LinkedList<>(Arrays.asList(event.getMenuEntries()));

        LastDisplayedWorldPoint = CalculateMapPoint(client.isMenuOpen() ? lastMenuOpenedPoint : client.getMouseCanvasPosition());
        if (LastDisplayedWorldPoint == null)
        {
            return;
        }

        LastClickedRegionPoint = GetClickedRegionPoint(entries);
        if (CurrentFocusedPoint != null && CurrentRegion != null && CurrentRegion.Type != CurrentFocusedPoint.Region)
        {
            SetMarkerActivation(CurrentFocusedPoint, false);
            CurrentFocusedPoint = null;
        }

        // How many tasks are we colliding with?
        if (taskOverlay != null)
        {
            MenuEntry customtaskMenu = client.createMenuEntry(-1);
            customtaskMenu.setTarget(ColorUtil.wrapWithColorTag("Custom Task", Color.YELLOW));
            customtaskMenu.setOption("Create");
            customtaskMenu.onClick(this.CreateCustomTask);
            customtaskMenu.setType(MenuAction.RUNELITE);
            entries.add(0, customtaskMenu);

            HashCodeToHash.clear();
            ArrayList<TaskDisplayPoint> ClickedPoints = taskOverlay.GetClickedDisplayPoint(getSelectedWorldPoint());

            for (TaskDisplayPoint CurrentDisplayPoint : ClickedPoints)
            {
                for (HashMap.Entry<UUID, Boolean> mapElement : CurrentDisplayPoint.Tasks.entrySet())
                {
                    UUID TaskGUID = mapElement.getKey();
                    boolean bIsCustomTask = mapElement.getValue();
                    TaskData CurrentTask = GetTaskData(TaskGUID, bIsCustomTask);

                    HashCodeToHash.put(TaskGUID.hashCode(), CurrentTask);

                    if (bIsCustomTask)
                    {
                        MenuEntry customtaskMenu2 = client.createMenuEntry(-1);
                        customtaskMenu2.setTarget(ColorUtil.wrapWithColorTag("Custom Task", Color.YELLOW));
                        customtaskMenu2.setOption("Destroy");
                        customtaskMenu2.onClick(this.DestroyCustomTask);
                        customtaskMenu2.setType(MenuAction.RUNELITE);
                        customtaskMenu2.setParam0(TaskGUID.hashCode());
                        entries.add(0, customtaskMenu2);


                        MenuEntry customtaskMenu3 = client.createMenuEntry(-1);
                        customtaskMenu3.setTarget(ColorUtil.wrapWithColorTag("Custom Task", Color.YELLOW));
                        customtaskMenu3.setOption("Change Icon");
                        customtaskMenu3.onClick(this.ChangeIconCustomTask);
                        customtaskMenu3.setType(MenuAction.RUNELITE);
                        customtaskMenu3.setParam0(TaskGUID.hashCode());
                        entries.add(0, customtaskMenu3);
                    }

                    /*
                    We don't need this option, but good to have in case we want to debug

                    MenuEntry taskMenu = client.createMenuEntry(-1);
                    taskMenu.setTarget(ColorUtil.wrapWithColorTag(CurrentTask.TaskName, TaskDifficulty.GetTaskDifficultyColor(CurrentTask.Difficulty)));
                    taskMenu.setOption("Focus on");
                    taskMenu.onClick(this.FocusOnTaskLocation);
                    taskMenu.setType(MenuAction.RUNELITE);
                    taskMenu.setParam0(TaskGUID.hashCode());
                    entries.add(0, taskMenu);
                    */

                    if (!config.UserData.PlannedTasks.containsKey(TaskGUID))
                    {
                        MenuEntry plannedTaskMenu = client.createMenuEntry(-1);
                        plannedTaskMenu.setTarget(ColorUtil.wrapWithColorTag(CurrentTask.TaskName, TaskDifficulty.GetTaskDifficultyColor(CurrentTask.Difficulty)));
                        plannedTaskMenu.setOption("Add to plan (back)");
                        plannedTaskMenu.onClick(this.AddTaskToBackOfPlan);
                        plannedTaskMenu.setType(MenuAction.RUNELITE);
                        plannedTaskMenu.setParam0(TaskGUID.hashCode());
                        entries.add(0, plannedTaskMenu);

                        MenuEntry plannedTaskMenu2 = client.createMenuEntry(-1);
                        plannedTaskMenu2.setTarget(ColorUtil.wrapWithColorTag(CurrentTask.TaskName, TaskDifficulty.GetTaskDifficultyColor(CurrentTask.Difficulty)));
                        plannedTaskMenu2.setOption("Add to plan (front)");
                        plannedTaskMenu2.onClick(this.AddTaskToFrontOfPlan);
                        plannedTaskMenu2.setType(MenuAction.RUNELITE);
                        plannedTaskMenu2.setParam0(TaskGUID.hashCode());
                        entries.add(0, plannedTaskMenu2);

                    }
                    else
                    {
                        MenuEntry plannedTaskMenu3 = client.createMenuEntry(-1);
                        plannedTaskMenu3.setTarget(ColorUtil.wrapWithColorTag(CurrentTask.TaskName, TaskDifficulty.GetTaskDifficultyColor(CurrentTask.Difficulty)));
                        plannedTaskMenu3.setOption("Move back on plan");
                        plannedTaskMenu3.onClick(this.MoveBackOnPlan);
                        plannedTaskMenu3.setType(MenuAction.RUNELITE);
                        plannedTaskMenu3.setParam0(TaskGUID.hashCode());
                        entries.add(0, plannedTaskMenu3);

                        MenuEntry plannedTaskMenu2 = client.createMenuEntry(-1);
                        plannedTaskMenu2.setTarget(ColorUtil.wrapWithColorTag(CurrentTask.TaskName, TaskDifficulty.GetTaskDifficultyColor(CurrentTask.Difficulty)));
                        plannedTaskMenu2.setOption("Move forward on plan");
                        plannedTaskMenu2.onClick(this.MoveForwardOnPlan);
                        plannedTaskMenu2.setType(MenuAction.RUNELITE);
                        plannedTaskMenu2.setParam0(TaskGUID.hashCode());
                        entries.add(0, plannedTaskMenu2);

                        MenuEntry plannedTaskMenu = client.createMenuEntry(-1);
                        plannedTaskMenu.setTarget(ColorUtil.wrapWithColorTag(CurrentTask.TaskName, TaskDifficulty.GetTaskDifficultyColor(CurrentTask.Difficulty)));
                        plannedTaskMenu.setOption("Remove from plan");
                        plannedTaskMenu.onClick(this.RemoveTaskFromPlan);
                        plannedTaskMenu.setType(MenuAction.RUNELITE);
                        plannedTaskMenu.setParam0(TaskGUID.hashCode());
                        entries.add(0, plannedTaskMenu);

                    }

                }
            }
        }

        String nextOption = null;
        if (config.GetEditRegion() != RegionType.NONE)
        {
            if (LastClickedRegionPoint == null)
            {
                nextOption = "Set Next Region Point";
                String finalNextOption1 = nextOption;
                if (entries.stream().noneMatch(e -> e.getOption().equals(finalNextOption1)))
                {
                    MenuEntry SetNextRegionPointEntry = client.createMenuEntry(-1);
                    SetNextRegionPointEntry.setOption(nextOption);
                    SetNextRegionPointEntry.setType(MenuAction.RUNELITE);
                    SetNextRegionPointEntry.onClick(this.SetNextRegionPointEntryCallback);
                    entries.add(0, SetNextRegionPointEntry);
                }
            }
            else
            {
                if (CurrentFocusedPoint != LastClickedRegionPoint)
                {
                    nextOption = "Set Active Region Point";
                    String finalNextOption2 = nextOption;
                    if (entries.stream().noneMatch(e -> e.getOption().equals(finalNextOption2)))
                    {
                        MenuEntry SetActiveRegionPointEntry = client.createMenuEntry(-1);
                        SetActiveRegionPointEntry.setOption(nextOption);
                        SetActiveRegionPointEntry.setType(MenuAction.RUNELITE);
                        SetActiveRegionPointEntry.onClick(this.SetActiveRegionPointEntryCallback);
                        entries.add(0, SetActiveRegionPointEntry);
                    }

                    if (CurrentFocusedPoint != null)
                    {
                        nextOption = "Connect Region Point";
                        String finalNextOption4 = nextOption;
                        if (entries.stream().noneMatch(e -> e.getOption().equals(finalNextOption4)))
                        {
                            MenuEntry ConnectRegionPointEntry = client.createMenuEntry(-1);
                            ConnectRegionPointEntry.setOption(nextOption);
                            ConnectRegionPointEntry.setType(MenuAction.RUNELITE);
                            ConnectRegionPointEntry.onClick(this.ConnectRegionPointEntryCallback);
                            entries.add(0, ConnectRegionPointEntry);
                        }
                    }
                }

                nextOption = "Delete Region Point";
                String finalNextOption3 = nextOption;
                if (entries.stream().noneMatch(e -> e.getOption().equals(finalNextOption3)))
                {
                    MenuEntry DeleteRegionPointEntry = client.createMenuEntry(-1);
                    DeleteRegionPointEntry.setOption(nextOption);
                    DeleteRegionPointEntry.setType(MenuAction.RUNELITE);
                    DeleteRegionPointEntry.onClick(this.DeleteRegionPointEntryCallback);
                    entries.add(0, DeleteRegionPointEntry);
                }

            }
        }

        // Debug helper
        //if (0 == 1)
        {
            if (config.GetEditRegion() == RegionType.NONE)
            {
                nextOption = "Map Coordinate: " + LastDisplayedWorldPoint;
                String finalNextOption = nextOption;
                if (entries.stream().noneMatch(e -> e.getOption().equals(finalNextOption)))
                {
                    MenuEntry MapCoordEntry = client.createMenuEntry(-1);
                    MapCoordEntry.setOption(nextOption);
                    MapCoordEntry.setType(MenuAction.RUNELITE);
                    entries.add(0, MapCoordEntry);
                }
            }
        }

        client.setMenuEntries(entries.toArray(new MenuEntry[0]));
    }
}

package Posiedien_Leagues_Planner;

public enum FilterRequirements
{
    NONE,
    NEAR_REQ,
    MEETS_REQ;
}

package Posiedien_Leagues_Planner.pathfinder;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import net.runelite.api.coords.WorldPoint;
import Posiedien_Leagues_Planner.WorldPointUtil;

public class Node {
    public final int packedPosition;
    public final Node previous;
    public final int cost;

    public Node(WorldPoint position, Node previous, int wait) {
        this.packedPosition = WorldPointUtil.packWorldPoint(position);
        this.previous = previous;
        this.cost = cost(previous, wait);
    }

    public Node(WorldPoint position, Node previous) {
        this(position, previous, 0);
    }

    public Node(int packedPosition, Node previous, int wait) {
        this.packedPosition = packedPosition;
        this.previous = previous;
        this.cost = cost(previous, wait);
    }

    public Node(int packedPosition, Node previous) {
        this(packedPosition, previous, 0);
    }

    public List<WorldPoint> getPath() {
        List<WorldPoint> path = new LinkedList<>();
        Node node = this;

        while (node != null) {
            WorldPoint position = WorldPointUtil.unpackWorldPoint(node.packedPosition);
            path.add(0, position);
            node = node.previous;
        }

        return new ArrayList<>(path);
    }

    public List<Integer> getPathPacked() {
        List<Integer> path = new LinkedList<>();
        Node node = this;

        while (node != null) {
            path.add(0, node.packedPosition);
            node = node.previous;
        }

        return new ArrayList<>(path);
    }

    private int cost(Node previous, int wait) {
        int previousCost = 0;
        int distance = 0;

        if (previous != null) {
            previousCost = previous.cost;
            distance = WorldPointUtil.distanceBetween(previous.packedPosition, packedPosition);
            final int previousPlane = WorldPointUtil.unpackWorldPlane(previous.packedPosition);
            final int currentPlane = WorldPointUtil.unpackWorldPlane(previous.packedPosition);
            boolean isTransport = distance > 1 || previousPlane != currentPlane;
            if (isTransport) {
                distance = wait;
            }
        }

        return previousCost + distance;
    }
}

package Posiedien_Leagues_Planner.pathfinder;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import Posiedien_Leagues_Planner.RegionType;
import Posiedien_Leagues_Planner.Transport;
import Posiedien_Leagues_Planner.WorldPointUtil;
import net.runelite.api.coords.WorldPoint;

public class CollisionMap {

    PathfinderConfig CachedConfig = null;
    public boolean bJustFindingOverworld = false;

    // Enum.values() makes copies every time which hurts performance in the hotpath
    private static final OrdinalDirection[] ORDINAL_VALUES = OrdinalDirection.values();

    private final SplitFlagMap collisionData;

    public byte[] getPlanes() {
        return collisionData.getRegionMapPlaneCounts();
    }

    public CollisionMap(SplitFlagMap collisionData) {
        this.collisionData = collisionData;
    }

    private boolean get(int x, int y, int z, int flag)
    {
        return collisionData.get(x, y, z, flag);
    }

    public boolean n(int x, int y, int z) {
        return get(x, y, z, 0);
    }

    public boolean s(int x, int y, int z) {
        return n(x, y - 1, z);
    }

    public boolean e(int x, int y, int z) {
        return get(x, y, z, 1);
    }

    public boolean w(int x, int y, int z) {
        return e(x - 1, y, z);
    }

    private boolean ne(int x, int y, int z) {
        return n(x, y, z) && e(x, y + 1, z) && e(x, y, z) && n(x + 1, y, z);
    }

    private boolean nw(int x, int y, int z) {
        return n(x, y, z) && w(x, y + 1, z) && w(x, y, z) && n(x - 1, y, z);
    }

    private boolean se(int x, int y, int z) {
        return s(x, y, z) && e(x, y - 1, z) && e(x, y, z) && s(x + 1, y, z);
    }

    private boolean sw(int x, int y, int z) {
        return s(x, y, z) && w(x, y - 1, z) && w(x, y, z) && s(x - 1, y, z);
    }

    public boolean isBlocked(int x, int y, int z) {
        return !n(x, y, z) && !s(x, y, z) && !e(x, y, z) && !w(x, y, z);
    }

    private static int packedPointFromOrdinal(int startPacked, OrdinalDirection direction) {
        final int x = WorldPointUtil.unpackWorldX(startPacked);
        final int y = WorldPointUtil.unpackWorldY(startPacked);
        final int plane = WorldPointUtil.unpackWorldPlane(startPacked);
        return WorldPointUtil.packWorldPoint(x + direction.x, y + direction.y, plane);
    }

    // This is only safe if pathfinding is single-threaded
    private final List<Node> neighbors = new ArrayList<>(16);
    private final boolean[] traversable = new boolean[8];

    public List<Node> getNeighbors(Node node, VisitedTiles visited, PathfinderConfig config) {
        final int x = WorldPointUtil.unpackWorldX(node.packedPosition);
        final int y = WorldPointUtil.unpackWorldY(node.packedPosition);
        final int z = WorldPointUtil.unpackWorldPlane(node.packedPosition);

        neighbors.clear();

        @SuppressWarnings("unchecked") // Casting EMPTY_LIST to List<Transport> is safe here
        List<Transport> transports = config.getTransportsPacked().getOrDefault(node.packedPosition, (List<Transport>)Collections.EMPTY_LIST);

        CachedConfig = config;

        // Transports are pre-filtered by PathfinderConfig.refreshTransportData
        // Thus any transports in the list are guaranteed to be valid per the user's settings
        for (int i = 0; i < transports.size(); ++i) {
            Transport transport = transports.get(i);
            if (visited.get(transport.getDestination())) continue;
            neighbors.add(new TransportNode(transport.getDestination(), node, transport.getWait()));
        }

        if (isBlocked(x, y, z)) {
            boolean westBlocked = isBlocked(x - 1, y, z);
            boolean eastBlocked = isBlocked(x + 1, y, z);
            boolean southBlocked = isBlocked(x, y - 1, z);
            boolean northBlocked = isBlocked(x, y + 1, z);
            boolean southWestBlocked = isBlocked(x - 1, y - 1, z);
            boolean southEastBlocked = isBlocked(x + 1, y - 1, z);
            boolean northWestBlocked = isBlocked(x - 1, y + 1, z);
            boolean northEastBlocked = isBlocked(x + 1, y + 1, z);
            traversable[0] = !westBlocked;
            traversable[1] = !eastBlocked;
            traversable[2] = !southBlocked;
            traversable[3] = !northBlocked;
            traversable[4] = !southWestBlocked && !westBlocked && !southBlocked;
            traversable[5] = !southEastBlocked && !eastBlocked && !southBlocked;
            traversable[6] = !northWestBlocked && !westBlocked && !northBlocked;
            traversable[7] = !northEastBlocked && !eastBlocked && !northBlocked;
        } else {
            traversable[0] = w(x, y, z);
            traversable[1] = e(x, y, z);
            traversable[2] = s(x, y, z);
            traversable[3] = n(x, y, z);
            traversable[4] = sw(x, y, z);
            traversable[5] = se(x, y, z);
            traversable[6] = nw(x, y, z);
            traversable[7] = ne(x, y, z);
        }

        for (int i = 0; i < traversable.length; i++) {
            OrdinalDirection d = ORDINAL_VALUES[i];
            int neighborPacked = packedPointFromOrdinal(node.packedPosition, d);
            if (visited.get(neighborPacked)) continue;

            if (traversable[i]) {
                neighbors.add(new Node(neighborPacked, node));
            } else if (Math.abs(d.x + d.y) == 1 && isBlocked(x + d.x, y + d.y, z)) {
                @SuppressWarnings("unchecked") // Casting EMPTY_LIST to List<Transport> is safe here
                List<Transport> neighborTransports = config.getTransportsPacked().getOrDefault(neighborPacked, (List<Transport>)Collections.EMPTY_LIST);
                for (int t = 0; t < neighborTransports.size(); ++t) {
                    Transport transport = neighborTransports.get(t);
                    if (visited.get(transport.getOrigin())) continue;
                    neighbors.add(new Node(transport.getOrigin(), node));
                }
            }
        }

        return neighbors;
    }
}

package Posiedien_Leagues_Planner.pathfinder;

import java.awt.*;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import Posiedien_Leagues_Planner.*;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.coords.WorldPoint;

import static net.runelite.api.Constants.REGION_SIZE;

public class SplitFlagMap implements Runnable{
    @Getter
    private static RegionExtent regionExtents;

    @Getter
    private final byte[] regionMapPlaneCounts;
    // Size is automatically chosen based on the max extents of the collision data
    final FlagMap[] regionMaps;
    private final int widthInclusive;
    private final PosiedienLeaguesPlannerPlugin plugin;

    private LeaguesPlannerConfig config;

    public SplitFlagMap(Map<Integer, byte[]> compressedRegions, PosiedienLeaguesPlannerPlugin plugin, LeaguesPlannerConfig config)
    {
        this.plugin = plugin;
        this.config = config;

        widthInclusive = regionExtents.getWidth() + 1;
        final int heightInclusive = regionExtents.getHeight() + 1;
        regionMaps = new FlagMap[widthInclusive * heightInclusive];
        regionMapPlaneCounts = new byte[regionMaps.length];

        for (Map.Entry<Integer, byte[]> entry : compressedRegions.entrySet()) {
            final int pos = entry.getKey();
            final int x = unpackX(pos);
            final int y = unpackY(pos);
            final int index = getIndex(x, y);
            FlagMap flagMap = new FlagMap(x * REGION_SIZE, y * REGION_SIZE, entry.getValue());
            regionMaps[index] = flagMap;
            regionMapPlaneCounts[index] = flagMap.getPlaneCount();
        }
    }

    public boolean get(int x, int y, int z, int flag) {
        final int index = getIndex(x / REGION_SIZE, y / REGION_SIZE);
        if (index < 0 || index >= regionMaps.length || regionMaps[index] == null) {
            return false;
        }

        return regionMaps[index].get(x, y, z, flag);
    }

    private int getIndex(int regionX, int regionY) {
        return (regionX - regionExtents.getMinX()) + (regionY - regionExtents.getMinY()) * widthInclusive;
    }

    public static int unpackX(int position) {
        return position & 0xFFFF;
    }

    public static int unpackY(int position) {
        return (position >> 16) & 0xFFFF;
    }

    public static int packPosition(int x, int y) {
        return (x & 0xFFFF) | ((y & 0xFFFF) << 16);
    }

    public static SplitFlagMap fromResources(PosiedienLeaguesPlannerPlugin plugin, LeaguesPlannerConfig config)
    {
        Map<Integer, byte[]> compressedRegions = new HashMap<>();
        try (ZipInputStream in = new ZipInputStream(PosiedienLeaguesPlannerPlugin.class.getResourceAsStream("/collision-map.zip"))) {
            int minX = Integer.MAX_VALUE;
            int minY = Integer.MAX_VALUE;
            int maxX = 0;
            int maxY = 0;

            ZipEntry entry;
            while ((entry = in.getNextEntry()) != null) {
                String[] n = entry.getName().split("_");
                final int x = Integer.parseInt(n[0]);
                final int y = Integer.parseInt(n[1]);
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                maxX = Math.max(maxX, x);
                maxY = Math.max(maxY, y);

                compressedRegions.put(SplitFlagMap.packPosition(x, y), Util.readAllBytes(in));
            }

            regionExtents = new RegionExtent(minX, minY, maxX, maxY);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }

        return new SplitFlagMap(compressedRegions, plugin, config);
    }

    @Override
    public void run()
    {
        Map<WorldPoint, List<Transport>> transports = Transport.loadAllFromResources();
        PathfinderConfig newPathfinderConfig = new PathfinderConfig(this, transports, plugin.client, config);

        if (!bCanceled)
        {
            EventQueue.invokeLater(() ->
                    {
                        plugin.pathfinderConfig = newPathfinderConfig;
                    }
            );
        }
    }

    boolean bCanceled = false;
    public void cancel()
    {
        bCanceled = true;
    }

    @RequiredArgsConstructor
    @Getter
    public static class RegionExtent {
        public final int minX, minY, maxX, maxY;

        public int getWidth() {
            return maxX - minX;
        }

        public int getHeight() {
            return maxY - minY;
        }
    }
}

package Posiedien_Leagues_Planner.pathfinder;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.GameState;
import net.runelite.api.Quest;
import net.runelite.api.QuestState;
import net.runelite.api.Skill;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import Posiedien_Leagues_Planner.LeaguesPlannerConfig;
import Posiedien_Leagues_Planner.PrimitiveIntHashMap;
import Posiedien_Leagues_Planner.Transport;
import Posiedien_Leagues_Planner.WorldPointUtil;

import static net.runelite.api.Constants.REGION_SIZE;

public class PathfinderConfig {
    private static final WorldArea WILDERNESS_ABOVE_GROUND = new WorldArea(2944, 3523, 448, 448, 0);
    private static final WorldArea WILDERNESS_UNDERGROUND = new WorldArea(2944, 9918, 320, 442, 0);

    private final SplitFlagMap mapData;
    private final ThreadLocal<CollisionMap> map;
    private final Map<WorldPoint, List<Transport>> allTransports;
    @Getter
    private Map<WorldPoint, List<Transport>> transports;

    // Copy of transports with packed positions for the hotpath; lists are not copied and are the same reference in both maps
    @Getter
    private PrimitiveIntHashMap<List<Transport>> transportsPacked;

    private final Client client;
    final LeaguesPlannerConfig config;

    @Getter
    private long calculationCutoffMillis;
    @Getter
    private boolean avoidWilderness;
    private boolean useAgilityShortcuts,
        useGrappleShortcuts,
        useBoats,
        useCanoes,
        useCharterShips,
        useShips,
        useFairyRings,
        useGnomeGliders,
        useSpiritTrees,
        useTeleportationLevers,
        useTeleportationPortals;
    private int agilityLevel;
    private int rangedLevel;
    private int strengthLevel;
    private int prayerLevel;
    private int woodcuttingLevel;
    private Map<Quest, QuestState> questStates = new HashMap<>();

    public PathfinderConfig(SplitFlagMap mapData, Map<WorldPoint, List<Transport>> transports, Client client,
                            LeaguesPlannerConfig config) {
        this.mapData = mapData;
        this.map = ThreadLocal.withInitial(() -> new CollisionMap(this.mapData));
        this.allTransports = transports;
        this.transports = new HashMap<>(allTransports.size());
        this.transportsPacked = new PrimitiveIntHashMap<>(allTransports.size());
        this.client = client;
        this.config = config;


        // Go through every flag map
        if (config != null)
        {
            for (FlagMap regionMap : mapData.regionMaps)
            {
                if (regionMap == null)
                {
                    continue;
                }
                for (int x = 0; x < REGION_SIZE; ++x)
                {
                    int AdjustedX = regionMap.minX + x;
                    for (int y = 0; y < REGION_SIZE; ++y)
                    {
                        int AdjustedY = regionMap.minY + y;
                        for (int z = 0; z < regionMap.getPlaneCount(); ++z)
                        {
                            if (mapData.bCanceled)
                            {
                                return;
                            }
                            WorldPoint ConvertedPoint = new WorldPoint(AdjustedX, AdjustedY, z);

                            // Not in region, mark as blocked
                            if (!config.RegionData.IsTileInUnlockedRegion(config, ConvertedPoint))
                            {
                                regionMap.set(AdjustedX, AdjustedY, z, 0, false);
                                regionMap.set(AdjustedX, AdjustedY, z, 1, false);
                            }
                        }
                    }
                }
            }
        }
    }

    public CollisionMap getMap() {
        return map.get();
    }

    public void refresh() {
        //calculationCutoffMillis = config.calculationCutoff() * Constants.GAME_TICK_LENGTH;
        if (GameState.LOGGED_IN.equals(client.getGameState()))
        {
            avoidWilderness = config.avoidWilderness();
            useAgilityShortcuts = config.useAgilityShortcuts();
            useGrappleShortcuts = config.useGrappleShortcuts();
            useBoats = config.useBoats();
            useCanoes = config.useCanoes();
            useCharterShips = config.useCharterShips();
            useShips = config.useShips();
            useFairyRings = config.useFairyRings();
            useSpiritTrees = config.useSpiritTrees();
            useGnomeGliders = config.useGnomeGliders();
            useTeleportationLevers = config.useTeleportationLevers();
            useTeleportationPortals = config.useTeleportationPortals();

            agilityLevel = client.getBoostedSkillLevel(Skill.AGILITY);
            rangedLevel = client.getBoostedSkillLevel(Skill.RANGED);
            strengthLevel = client.getBoostedSkillLevel(Skill.STRENGTH);
            prayerLevel = client.getBoostedSkillLevel(Skill.PRAYER);
            woodcuttingLevel = client.getBoostedSkillLevel(Skill.WOODCUTTING);

            refreshTransportData();
        }
        // Not logged in
        else
        {
            avoidWilderness = false;
            useAgilityShortcuts = true;
            useGrappleShortcuts = true;
            useBoats = true;
            useCanoes = true;
            useCharterShips = true;
            useShips = true;
            useFairyRings = false;
            useSpiritTrees = false;
            useGnomeGliders = false;
            useTeleportationLevers = false;
            useTeleportationPortals = false;

            agilityLevel = 99;
            rangedLevel = 99;
            strengthLevel = 99;
            prayerLevel = 99;
            woodcuttingLevel = 99;

            refreshTransportData();
        }
    }

    private void refreshTransportData() {
        if (!Thread.currentThread().equals(client.getClientThread())) {
            return; // Has to run on the client thread; data will be refreshed when path finding commences
        }

        useFairyRings &= !QuestState.NOT_STARTED.equals(getQuestState(Quest.FAIRYTALE_II__CURE_A_QUEEN));
        useGnomeGliders &= QuestState.FINISHED.equals(getQuestState(Quest.THE_GRAND_TREE));
        useSpiritTrees &= QuestState.FINISHED.equals(getQuestState(Quest.TREE_GNOME_VILLAGE));

        transports.clear();
        transportsPacked.clear();
        for (Map.Entry<WorldPoint, List<Transport>> entry : allTransports.entrySet()) {
            List<Transport> usableTransports = new ArrayList<>(entry.getValue().size());
            for (Transport transport : entry.getValue()) {
                for (Quest quest : transport.getQuests()) {
                    try {
                        questStates.put(quest, getQuestState(quest));
                    } catch (NullPointerException ignored) {
                    }
                }

                if (useTransport(transport)) {
                    usableTransports.add(transport);
                }
            }

            WorldPoint point = entry.getKey();
            transports.put(point, usableTransports);
            transportsPacked.put(WorldPointUtil.packWorldPoint(point), usableTransports);
        }
    }

    public static boolean isInWilderness(WorldPoint p) {
        return WILDERNESS_ABOVE_GROUND.distanceTo(p) == 0 || WILDERNESS_UNDERGROUND.distanceTo(p) == 0;
    }

    public static boolean isInWilderness(int packedPoint) {
        return WorldPointUtil.distanceToArea(packedPoint, WILDERNESS_ABOVE_GROUND) == 0 || WorldPointUtil.distanceToArea(packedPoint, WILDERNESS_UNDERGROUND) == 0;
    }

    public boolean avoidWilderness(int packedPosition, int packedNeightborPosition, boolean targetInWilderness) {
        return avoidWilderness && !isInWilderness(packedPosition) && isInWilderness(packedNeightborPosition) && !targetInWilderness;
    }

    public QuestState getQuestState(Quest quest)
    {
        if (client == null)
        {
            return QuestState.FINISHED;
        }

        return quest.getState(client);
    }

    private boolean completedQuests(Transport transport) {
        for (Quest quest : transport.getQuests()) {
            if (!QuestState.FINISHED.equals(questStates.getOrDefault(quest, QuestState.NOT_STARTED))) {
                return false;
            }
        }
        return true;
    }

    private boolean useTransport(Transport transport) {
        final int transportAgilityLevel = transport.getRequiredLevel(Skill.AGILITY);
        final int transportRangedLevel = transport.getRequiredLevel(Skill.RANGED);
        final int transportStrengthLevel = transport.getRequiredLevel(Skill.STRENGTH);
        final int transportPrayerLevel = transport.getRequiredLevel(Skill.PRAYER);
        final int transportWoodcuttingLevel = transport.getRequiredLevel(Skill.WOODCUTTING);

        final boolean isAgilityShortcut = transport.isAgilityShortcut();
        final boolean isGrappleShortcut = transport.isGrappleShortcut();
        final boolean isBoat = transport.isBoat();
        final boolean isCanoe = transport.isCanoe();
        final boolean isCharterShip = transport.isCharterShip();
        final boolean isShip = transport.isShip();
        final boolean isFairyRing = transport.isFairyRing();
        final boolean isGnomeGlider = transport.isGnomeGlider();
        final boolean isSpiritTree = transport.isSpiritTree();
        final boolean isTeleportationLever = transport.isTeleportationLever();
        final boolean isTeleportationPortal = transport.isTeleportationPortal();
        final boolean isPrayerLocked = transportPrayerLevel > 1;
        final boolean isQuestLocked = transport.isQuestLocked();

        if (isAgilityShortcut) {
            if (!useAgilityShortcuts || agilityLevel < transportAgilityLevel) {
                return false;
            }

            if (isGrappleShortcut && (!useGrappleShortcuts || rangedLevel < transportRangedLevel || strengthLevel < transportStrengthLevel)) {
                return false;
            }
        }

        if (isBoat && !useBoats) {
            return false;
        }

        if (isCanoe && (!useCanoes || woodcuttingLevel < transportWoodcuttingLevel)) {
            return false;
        }

        if (isCharterShip && !useCharterShips) {
            return false;
        }

        if (isShip && !useShips) {
            return false;
        }

        if (isFairyRing && !useFairyRings) {
            return false;
        }

        if (isGnomeGlider && !useGnomeGliders) {
            return false;
        }

        if (isSpiritTree && !useSpiritTrees) {
            return false;
        }

        if (isTeleportationLever && !useTeleportationLevers) {
            return false;
        }

        if (isTeleportationPortal && !useTeleportationPortals) {
            return false;
        }

        if (isPrayerLocked && prayerLevel < transportPrayerLevel) {
            return false;
        }

        if (isQuestLocked && !completedQuests(transport)) {
            return false;
        }

        return true;
    }
}

package Posiedien_Leagues_Planner.pathfinder;

public enum OrdinalDirection {
    WEST(-1, 0),
    EAST(1, 0),
    SOUTH(0, -1),
    NORTH(0, 1),
    SOUTH_WEST(-1, -1),
    SOUTH_EAST(1, -1),
    NORTH_WEST(-1, 1),
    NORTH_EAST(1, 1);

    final int x;
    final int y;

    OrdinalDirection(int x, int y) {
        this.x = x;
        this.y = y;
    }
}

package Posiedien_Leagues_Planner.pathfinder;

import java.util.BitSet;
import java.util.Locale;
import lombok.Getter;
import static net.runelite.api.Constants.REGION_SIZE;

public class FlagMap {
    private static final byte FLAG_COUNT = 2;
    private final BitSet flags;
    @Getter
    private final byte planeCount;
    public final int minX;
    public final int minY;

    public FlagMap(int minX, int minY, byte planeCount) {
        this.minX = minX;
        this.minY = minY;
        this.planeCount = planeCount;
        flags = new BitSet(REGION_SIZE * REGION_SIZE * planeCount * FLAG_COUNT);
    }

    public FlagMap(int minX, int minY, byte[] bytes) {
        this.minX = minX;
        this.minY = minY;
        flags = BitSet.valueOf(bytes);
        int scale = REGION_SIZE * REGION_SIZE * FLAG_COUNT;
        this.planeCount = (byte) ((flags.size() + scale - 1) / scale);
    }

    public byte[] toBytes() {
        return flags.toByteArray();
    }

    public boolean get(int x, int y, int z, int flag) {
        if (x < minX || x >= (minX + REGION_SIZE) || y < minY || y >= (minY + REGION_SIZE) || z < 0 || z >= planeCount) {
            return false;
        }

        return flags.get(index(x, y, z, flag));
    }

    public void set(int x, int y, int z, int flag, boolean value) {
        flags.set(index(x, y, z, flag), value);
    }

    private int index(int x, int y, int z, int flag) {
        if (x < minX || x >= (minX + REGION_SIZE) || y < minY || y >= (minY + REGION_SIZE) || z < 0 || z >= planeCount || flag < 0 || flag >= FLAG_COUNT) {
            throw new IndexOutOfBoundsException(
                String.format(Locale.ENGLISH, "[%d,%d,%d,%d] when extents are [>=%d,>=%d,>=%d,>=%d] - [<=%d,<=%d,<%d,<%d]",
                        x, y, z, flag,
                        minX, minY, 0, 0,
                        minX + REGION_SIZE - 1, minY + REGION_SIZE - 1, planeCount, FLAG_COUNT
                )
            );
        }

        return (z * REGION_SIZE * REGION_SIZE + (y - minY) * REGION_SIZE + (x - minX)) * FLAG_COUNT + flag;
    }
}

package Posiedien_Leagues_Planner.pathfinder;

import net.runelite.api.coords.WorldPoint;
import Posiedien_Leagues_Planner.WorldPointUtil;

import static net.runelite.api.Constants.REGION_SIZE;

public class VisitedTiles {
    private final SplitFlagMap.RegionExtent regionExtents;
    private final int widthInclusive;

    private final VisitedRegion[] visitedRegions;
    private final byte[] visitedRegionPlanes;

    public VisitedTiles(CollisionMap map) {
        regionExtents = SplitFlagMap.getRegionExtents();
        widthInclusive = regionExtents.getWidth() + 1;
        final int heightInclusive = regionExtents.getHeight() + 1;

        visitedRegions = new VisitedRegion[widthInclusive * heightInclusive];
        visitedRegionPlanes = map.getPlanes();
    }

    public boolean get(WorldPoint point) {
        return get(point.getX(), point.getY(), point.getPlane());
    }

    public boolean get(int packedPoint) {
        final int x = WorldPointUtil.unpackWorldX(packedPoint);
        final int y = WorldPointUtil.unpackWorldY(packedPoint);
        final int plane = WorldPointUtil.unpackWorldPlane(packedPoint);
        return get(x, y, plane);
    }

    public boolean get(int x, int y, int plane) {
        final int regionIndex = getRegionIndex(x / REGION_SIZE, y / REGION_SIZE);
        if (regionIndex < 0 || regionIndex >= visitedRegions.length) {
            return true; // Region is out of bounds; report that it's been visited to avoid exploring it further
        }

        final VisitedRegion region = visitedRegions[regionIndex];
        if (region == null) {
            return false;
        }

        return region.get(x % REGION_SIZE, y % REGION_SIZE, plane);
    }

    public boolean set(int packedPoint) {
        final int x = WorldPointUtil.unpackWorldX(packedPoint);
        final int y = WorldPointUtil.unpackWorldY(packedPoint);
        final int plane = WorldPointUtil.unpackWorldPlane(packedPoint);
        return set(x, y, plane);
    }

    public boolean set(int x, int y, int plane) {
        final int regionIndex = getRegionIndex(x / REGION_SIZE, y / REGION_SIZE);
        if (regionIndex < 0 || regionIndex >= visitedRegions.length) {
            return false; // Region is out of bounds; report that it's been visited to avoid exploring it further
        }

        VisitedRegion region = visitedRegions[regionIndex];
        if (region == null) {
            region = new VisitedRegion(visitedRegionPlanes[regionIndex]);
            visitedRegions[regionIndex] = region;
        }

        return region.set(x % REGION_SIZE, y % REGION_SIZE, plane);
    }

    public void clear() {
        for (int i = 0; i < visitedRegions.length; ++i) {
            if (visitedRegions[i] != null) {
                visitedRegions[i] = null;
            }
        }
    }

    private int getRegionIndex(int regionX, int regionY) {
        return (regionX - regionExtents.minX) + (regionY - regionExtents.minY) * widthInclusive;
    }

    private static class VisitedRegion {
        // This assumes a row is at most 64 tiles and fits in a long
        private final long[] planes;
        private final byte planeCount;

        VisitedRegion(byte planeCount) {
            this.planeCount = planeCount;
            this.planes = new long[planeCount * REGION_SIZE];
        }

        // Sets a tile as visited in the tile bitset
        // Returns true if the tile is unique and hasn't been seen before or false if it was seen before
        public boolean set(int x, int y, int plane) {
            if (plane >= planeCount) {
                // Plane is out of bounds; report that it has been visited to avoid further exploration
                return false;
            }
            final int index = y + plane * REGION_SIZE;
            boolean unique = (planes[index] & (1L << x)) == 0;
            planes[index] |= 1L << x;
            return unique;
        }

        public boolean get(int x, int y, int plane) {
            if (plane >= planeCount) {
                // This check is necessary since we check visited tiles before checking the collision map, e.g. the node
                // at (2816, 3455, 1) will check its neighbour to the north which is in a new region with no plane = 1
                return true;
            }
            return (planes[y + plane * REGION_SIZE] & (1L << x)) != 0;
        }
    }
}

package Posiedien_Leagues_Planner.pathfinder;

import java.util.ArrayDeque;
import java.util.Collections;
import java.util.Deque;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Queue;

import lombok.Getter;
import net.runelite.api.coords.WorldPoint;
import Posiedien_Leagues_Planner.WorldPointUtil;

public class Pathfinder implements Runnable {
    private PathfinderStats stats;
    private volatile boolean done = false;
    private volatile boolean cancelled = false;

    @Getter
    private final WorldPoint start;
    @Getter
    private final WorldPoint target;

    private final int targetPacked;

    private final PathfinderConfig config;
    private final CollisionMap map;
    private final boolean targetInWilderness;

    // Capacities should be enough to store all nodes without requiring the queue to grow
    // They were found by checking the max queue size
    private final Deque<Node> boundary = new ArrayDeque<>(4096);
    private final Queue<Node> pending = new PriorityQueue<>(256);
    private final VisitedTiles visited;

    @SuppressWarnings("unchecked") // Casting EMPTY_LIST is safe here
    private List<WorldPoint> path = (List<WorldPoint>)Collections.EMPTY_LIST;
    private boolean pathNeedsUpdate = false;
    private Node bestLastNode;
    private boolean bJustFindOverworld = false;

    public Pathfinder(PathfinderConfig config, WorldPoint start, WorldPoint target, boolean bInJustFindOverworld) {
        stats = new PathfinderStats();
        this.config = config;
        this.map = config.getMap();
        this.map.bJustFindingOverworld = bInJustFindOverworld;
        this.start = start;
        this.target = target;
        visited = new VisitedTiles(map);
        targetPacked = WorldPointUtil.packWorldPoint(target);
        targetInWilderness = PathfinderConfig.isInWilderness(target);
        bJustFindOverworld = bInJustFindOverworld;
    }

    public boolean isDone() {
        return done;
    }

    public void cancel() {
        cancelled = true;
    }

    public PathfinderStats getStats() {
        if (stats.started && stats.ended) {
            return stats;
        }

        // Don't give incomplete results
        return null;
    }

    public List<WorldPoint> getPath() {
        Node lastNode = bestLastNode; // For thread safety, read bestLastNode once
        if (lastNode == null) {
            return path;
        }

        if (pathNeedsUpdate) {
            path = lastNode.getPath();
            pathNeedsUpdate = false;
        }

        return path;
    }

    private Node addNeighbors(Node node) {
        List<Node> nodes = map.getNeighbors(node, visited, config);
        for (int i = 0; i < nodes.size(); ++i) {
            Node neighbor = nodes.get(i);
            if (neighbor.packedPosition == targetPacked) {
                return neighbor;
            }

            if (config.isAvoidWilderness() && config.avoidWilderness(node.packedPosition, neighbor.packedPosition, targetInWilderness)) {
                continue;
            }

            visited.set(neighbor.packedPosition);
            if (neighbor instanceof TransportNode) {
                pending.add(neighbor);
                ++stats.transportsChecked;
            } else {
                boundary.addLast(neighbor);
                ++stats.nodesChecked;
            }
        }

        return null;
    }

    public boolean IsOverworldLocation(WorldPoint testPoint)
    {
        // Just hard code the overworld bounds
        if (testPoint.getPlane() == 0)
        {
            if (testPoint.getX() > 1022 && testPoint.getX() < 3968)
            {
                return testPoint.getY() > 2494 && testPoint.getY() < 4160;
            }
        }

        return false;
    }
    @Override
    public void run() {
        stats.start();
        boundary.addFirst(new Node(start, null));

        int bestDistance = Integer.MAX_VALUE;
        long bestHeuristic = Integer.MAX_VALUE;
        long cutoffDurationMillis = 0;//config.getCalculationCutoffMillis();
        long cutoffTimeMillis = System.currentTimeMillis() + cutoffDurationMillis;

        while (!cancelled && (!boundary.isEmpty() || !pending.isEmpty())) {
            Node node = boundary.peekFirst();
            Node p = pending.peek();

            if (p != null && (node == null || p.cost < node.cost)) {
                boundary.addFirst(p);
                pending.poll();
            }

            node = boundary.removeFirst();

            if (node.packedPosition == targetPacked) {
                bestLastNode = node;
                pathNeedsUpdate = true;
                break;
            }

            int distance = WorldPointUtil.distanceBetween(node.packedPosition, targetPacked);
            long heuristic = distance + WorldPointUtil.distanceBetween(node.packedPosition, targetPacked, 2);
            if (heuristic < bestHeuristic || (heuristic <= bestHeuristic && distance < bestDistance)) {
                bestLastNode = node;
                pathNeedsUpdate = true;
                bestDistance = distance;
                bestHeuristic = heuristic;
                cutoffTimeMillis = System.currentTimeMillis() + cutoffDurationMillis;
            }

            // No limit
            if (System.currentTimeMillis() > cutoffTimeMillis) {
                //break;
            }

            // Check if target was found without processing the queue to find it
            if ((p = addNeighbors(node)) != null
                || (bJustFindOverworld && IsOverworldLocation(WorldPointUtil.unpackWorldPoint(node.packedPosition))))
            {
                if (p != null)
                {
                    bestLastNode = p;
                }
                else
                {
                    bestLastNode = node;
                }
                pathNeedsUpdate = true;
                break;
            }
        }

        done = !cancelled;

        boundary.clear();
        visited.clear();
        pending.clear();

        stats.end(); // Include cleanup in stats to get the total cost of pathfinding
    }

    public static class PathfinderStats {
        @Getter
        private int nodesChecked = 0, transportsChecked = 0;
        private long startNanos, endNanos;
        private volatile boolean started = false, ended = false;

        public int getTotalNodesChecked() {
            return nodesChecked + transportsChecked;
        }

        public long getElapsedTimeNanos() {
            return endNanos - startNanos;
        }

        private void start() {
            started = true;
            nodesChecked = 0;
            transportsChecked = 0;
            startNanos = System.nanoTime();
        }

        private void end() {
            endNanos = System.nanoTime();
            ended = true;
        }
    }
}

package Posiedien_Leagues_Planner.pathfinder;

import net.runelite.api.coords.WorldPoint;

public class TransportNode extends Node implements Comparable<TransportNode> {
    public TransportNode(WorldPoint position, Node previous, int wait) {
        super(position, previous, wait);
    }

    @Override
    public int compareTo(TransportNode other) {
        return Integer.compare(cost, other.cost);
    }
}

