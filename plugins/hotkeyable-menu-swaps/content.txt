package com.hotkeyablemenuswaps;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.MenuAction;
import net.runelite.client.config.Keybind;
import net.runelite.client.plugins.menuentryswapper.ShiftDepositMode;
import net.runelite.client.plugins.menuentryswapper.ShiftWithdrawMode;

import java.util.function.Function;

@Getter
@RequiredArgsConstructor
enum BankSwapMode implements HotkeyableMenuSwapsPlugin.hasKeybind {
    OFF(ShiftDepositMode.OFF, ShiftWithdrawMode.OFF, config -> Keybind.NOT_SET),
    SWAP_1(ShiftDepositMode.DEPOSIT_1, ShiftWithdrawMode.WITHDRAW_1, HotkeyableMenuSwapsConfig::getBankSwap1Hotkey, 2, 1),
    SWAP_5(ShiftDepositMode.DEPOSIT_5, ShiftWithdrawMode.WITHDRAW_5, HotkeyableMenuSwapsConfig::getBankSwap5Hotkey, 3, 2),
    SWAP_10(ShiftDepositMode.DEPOSIT_10, ShiftWithdrawMode.WITHDRAW_10, HotkeyableMenuSwapsConfig::getBankSwap10Hotkey, 4, 3),
    SWAP_X(ShiftDepositMode.DEPOSIT_X, ShiftWithdrawMode.WITHDRAW_X, HotkeyableMenuSwapsConfig::getBankSwapXHotkey, 5, 5),
    SWAP_SET_X(7, 6, 5, 6 /* TODO is this correct? */, MenuAction.CC_OP_LOW_PRIORITY, 6, 5, 6, -1, HotkeyableMenuSwapsConfig::getBankSwapSetXHotkey),
    SWAP_ALL(ShiftDepositMode.DEPOSIT_ALL, ShiftWithdrawMode.WITHDRAW_ALL, HotkeyableMenuSwapsConfig::getBankSwapAllHotkey, 7, 4),
    SWAP_ALL_BUT_1(-1, -1, -1, -1, ShiftWithdrawMode.WITHDRAW_ALL_BUT_1.getMenuAction(), ShiftWithdrawMode.WITHDRAW_ALL_BUT_1.getIdentifier(), ShiftWithdrawMode.WITHDRAW_ALL_BUT_1.getIdentifierChambersStorageUnit(), 7, 4, HotkeyableMenuSwapsConfig::getBankSwapAllBut1Hotkey),
    SWAP_EXTRA_OP(ShiftDepositMode.EXTRA_OP, ShiftWithdrawMode.OFF, HotkeyableMenuSwapsConfig::getBankSwapExtraOpHotkey),
    LOCK_UNLOCK_SLOT(10, 10, -1, -1, ShiftWithdrawMode.OFF.getMenuAction(), -1, -1, -1, -1, HotkeyableMenuSwapsConfig::lockUnlockSlotHotkey)
    ;

    private final int depositIdentifier;
    private final int depositIdentifierDepositBox;
    private final int depositIdentifierChambersStorageUnit;
	private final int depositIdentifierGroupStorage;

	private final MenuAction withdrawMenuAction;
    private final int withdrawIdentifier;
    private final int withdrawIdentifierChambersStorageUnit;

	private final int identifierSeedVault;
	private final int priceCheckerIdentifier;

	private final Function<HotkeyableMenuSwapsConfig, Keybind> keybindFunction;

	BankSwapMode(ShiftDepositMode depositMode, ShiftWithdrawMode withdrawMode, Function<HotkeyableMenuSwapsConfig, Keybind> keybindFunction) {
		this(depositMode, withdrawMode, keybindFunction, -1, -1);
	}

	BankSwapMode(ShiftDepositMode depositMode, ShiftWithdrawMode withdrawMode, Function<HotkeyableMenuSwapsConfig, Keybind> keybindFunction, int identifierSeedVault, int priceCheckerIdentifier) {
        depositIdentifier = depositMode.getIdentifier();
        depositIdentifierDepositBox = depositMode.getIdentifierDepositBox();
        depositIdentifierChambersStorageUnit = depositMode.getIdentifierChambersStorageUnit();
        depositIdentifierGroupStorage = depositMode.getIdentifierGroupStorage();
        withdrawMenuAction = withdrawMode.getMenuAction();
        withdrawIdentifier = withdrawMode.getIdentifier();
        withdrawIdentifierChambersStorageUnit = withdrawMode.getIdentifierChambersStorageUnit();
		this.keybindFunction = keybindFunction;
		this.identifierSeedVault = identifierSeedVault;
		this.priceCheckerIdentifier = priceCheckerIdentifier;
	}

    public Keybind getKeybind(HotkeyableMenuSwapsConfig config) {
        return keybindFunction.apply(config);
    }
}

package com.hotkeyablemenuswaps;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Keybind;

import static com.hotkeyablemenuswaps.OccultAltarSwap.*;

@ConfigGroup("hotkeyablemenuswaps")
public interface HotkeyableMenuSwapsConfig extends Config
{
	@ConfigSection(name = "Custom Swaps", description = "Text-based custom swaps", position = -110, closedByDefault = true)
	String customSwapsSection = "Custom Swaps";

	@ConfigItem(
		keyName = "customSwaps",
		name = "Custom swaps",
		description = "Options to swap to the top.",
		section = customSwapsSection,
		position = 0
	)
	default String customSwaps() {
		return "";
	}

	@ConfigSection(name = "Custom Swaps (shift)", description = "Text-based custom swaps", position = -100, closedByDefault = true)
	String customShiftSwapsSection = "Custom Swaps (shift)";

	@ConfigItem(
		keyName = "customShiftSwaps",
		name = "Custom swaps (shift)",
		description = "Options to swap to the top when shift is held.",
		section = customShiftSwapsSection,
		position = 0
	)
	default String customShiftSwaps() {
		return "";
	}

	@ConfigSection(name = "Custom Swaps (hotkeys)", description = "Hotkey-based swaps.", position = -90, closedByDefault = true)
	String hotkeys = "hotkeys";

	@ConfigItem(keyName = "hotkey1", name = "hotkey 1", description = "", section = hotkeys, position = 0) default Keybind hotkey1() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey1Swaps", name = "", description = "", section = hotkeys, position = 1) default String hotkey1Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey2", name = "hotkey 2", description = "", section = hotkeys, position = 2) default Keybind hotkey2() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey2Swaps", name = "", description = "", section = hotkeys, position = 3) default String hotkey2Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey3", name = "hotkey 3", description = "", section = hotkeys, position = 4) default Keybind hotkey3() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey3Swaps", name = "", description = "", section = hotkeys, position = 5) default String hotkey3Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey4", name = "hotkey 4", description = "", section = hotkeys, position = 6) default Keybind hotkey4() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey4Swaps", name = "", description = "", section = hotkeys, position = 7) default String hotkey4Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey5", name = "hotkey 5", description = "", section = hotkeys, position = 8) default Keybind hotkey5() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey5Swaps", name = "", description = "", section = hotkeys, position = 9) default String hotkey5Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey6", name = "hotkey 6", description = "", section = hotkeys, position = 10) default Keybind hotkey6() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey6Swaps", name = "", description = "", section = hotkeys, position = 11) default String hotkey6Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey7", name = "hotkey 7", description = "", section = hotkeys, position = 12) default Keybind hotkey7() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey7Swaps", name = "", description = "", section = hotkeys, position = 13) default String hotkey7Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey8", name = "hotkey 8", description = "", section = hotkeys, position = 14) default Keybind hotkey8() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey8Swaps", name = "", description = "", section = hotkeys, position = 15) default String hotkey8Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey9", name = "hotkey 9", description = "", section = hotkeys, position = 16) default Keybind hotkey9() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey9Swaps", name = "", description = "", section = hotkeys, position = 17) default String hotkey9Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey10", name = "hotkey 10", description = "", section = hotkeys, position = 18) default Keybind hotkey10() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey10Swaps", name = "", description = "", section = hotkeys, position = 19) default String hotkey10Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey11", name = "hotkey 11", description = "", section = hotkeys, position = 20) default Keybind hotkey11() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey11Swaps", name = "", description = "", section = hotkeys, position = 21) default String hotkey11Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey12", name = "hotkey 12", description = "", section = hotkeys, position = 22) default Keybind hotkey12() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey12Swaps", name = "", description = "", section = hotkeys, position = 23) default String hotkey12Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey13", name = "hotkey 13", description = "", section = hotkeys, position = 24) default Keybind hotkey13() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey13Swaps", name = "", description = "", section = hotkeys, position = 25) default String hotkey13Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey14", name = "hotkey 14", description = "", section = hotkeys, position = 26) default Keybind hotkey14() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey14Swaps", name = "", description = "", section = hotkeys, position = 27) default String hotkey14Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey15", name = "hotkey 15", description = "", section = hotkeys, position = 28) default Keybind hotkey15() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey15Swaps", name = "", description = "", section = hotkeys, position = 29) default String hotkey15Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey16", name = "hotkey 16", description = "", section = hotkeys, position = 30) default Keybind hotkey16() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey16Swaps", name = "", description = "", section = hotkeys, position = 31) default String hotkey16Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey17", name = "hotkey 17", description = "", section = hotkeys, position = 32) default Keybind hotkey17() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey17Swaps", name = "", description = "", section = hotkeys, position = 33) default String hotkey17Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey18", name = "hotkey 18", description = "", section = hotkeys, position = 34) default Keybind hotkey18() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey18Swaps", name = "", description = "", section = hotkeys, position = 35) default String hotkey18Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey19", name = "hotkey 19", description = "", section = hotkeys, position = 36) default Keybind hotkey19() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey19Swaps", name = "", description = "", section = hotkeys, position = 37) default String hotkey19Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey20", name = "hotkey 20", description = "", section = hotkeys, position = 38) default Keybind hotkey20() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey20Swaps", name = "", description = "", section = hotkeys, position = 39) default String hotkey20Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey21", name = "hotkey 21", description = "", section = hotkeys, position = 40) default Keybind hotkey21() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey21Swaps", name = "", description = "", section = hotkeys, position = 41) default String hotkey21Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey22", name = "hotkey 22", description = "", section = hotkeys, position = 42) default Keybind hotkey22() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey22Swaps", name = "", description = "", section = hotkeys, position = 43) default String hotkey22Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey23", name = "hotkey 23", description = "", section = hotkeys, position = 44) default Keybind hotkey23() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey23Swaps", name = "", description = "", section = hotkeys, position = 45) default String hotkey23Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey24", name = "hotkey 24", description = "", section = hotkeys, position = 46) default Keybind hotkey24() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey24Swaps", name = "", description = "", section = hotkeys, position = 47) default String hotkey24Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey25", name = "hotkey 25", description = "", section = hotkeys, position = 48) default Keybind hotkey25() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey25Swaps", name = "", description = "", section = hotkeys, position = 49) default String hotkey25Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey26", name = "hotkey 26", description = "", section = hotkeys, position = 50) default Keybind hotkey26() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey26Swaps", name = "", description = "", section = hotkeys, position = 51) default String hotkey26Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey27", name = "hotkey 27", description = "", section = hotkeys, position = 52) default Keybind hotkey27() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey27Swaps", name = "", description = "", section = hotkeys, position = 53) default String hotkey27Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey28", name = "hotkey 28", description = "", section = hotkeys, position = 54) default Keybind hotkey28() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey28Swaps", name = "", description = "", section = hotkeys, position = 55) default String hotkey28Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey29", name = "hotkey 29", description = "", section = hotkeys, position = 56) default Keybind hotkey29() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey29Swaps", name = "", description = "", section = hotkeys, position = 57) default String hotkey29Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey30", name = "hotkey 30", description = "", section = hotkeys, position = 58) default Keybind hotkey30() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey30Swaps", name = "", description = "", section = hotkeys, position = 59) default String hotkey30Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey31", name = "hotkey 31", description = "", section = hotkeys, position = 60) default Keybind hotkey31() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey31Swaps", name = "", description = "", section = hotkeys, position = 61) default String hotkey31Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey32", name = "hotkey 32", description = "", section = hotkeys, position = 62) default Keybind hotkey32() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey32Swaps", name = "", description = "", section = hotkeys, position = 63) default String hotkey32Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey33", name = "hotkey 33", description = "", section = hotkeys, position = 64) default Keybind hotkey33() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey33Swaps", name = "", description = "", section = hotkeys, position = 65) default String hotkey33Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey34", name = "hotkey 34", description = "", section = hotkeys, position = 66) default Keybind hotkey34() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey34Swaps", name = "", description = "", section = hotkeys, position = 67) default String hotkey34Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey35", name = "hotkey 35", description = "", section = hotkeys, position = 68) default Keybind hotkey35() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey35Swaps", name = "", description = "", section = hotkeys, position = 69) default String hotkey35Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey36", name = "hotkey 36", description = "", section = hotkeys, position = 70) default Keybind hotkey36() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey36Swaps", name = "", description = "", section = hotkeys, position = 71) default String hotkey36Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey37", name = "hotkey 37", description = "", section = hotkeys, position = 72) default Keybind hotkey37() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey37Swaps", name = "", description = "", section = hotkeys, position = 73) default String hotkey37Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey38", name = "hotkey 38", description = "", section = hotkeys, position = 74) default Keybind hotkey38() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey38Swaps", name = "", description = "", section = hotkeys, position = 75) default String hotkey38Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey39", name = "hotkey 39", description = "", section = hotkeys, position = 76) default Keybind hotkey39() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey39Swaps", name = "", description = "", section = hotkeys, position = 77) default String hotkey39Swaps() { return ""; }
	@ConfigItem(keyName = "hotkey40", name = "hotkey 40", description = "", section = hotkeys, position = 78) default Keybind hotkey40() { return Keybind.NOT_SET; }
	@ConfigItem(keyName = "hotkey40Swaps", name = "", description = "", section = hotkeys, position = 79) default String hotkey40Swaps() { return ""; }

	@ConfigSection(name = "Custom Hides", description = "Text-based custom menu entry hides", position = -9, closedByDefault = true)
	String customHidesSection = "Custom Hides";

	@ConfigItem(
		keyName = "customHides",
		name = "Custom hides",
		description = "Options to remove from the menu.",
		section = customHidesSection,
		position = 1
	)
	default String customHides() {
		return "";
	}

	@ConfigSection(name = "Custom swap instructions", description = "instructions", position = -7, closedByDefault = true)
	String customSwapInstructions = "Custom swap instructions";

	@ConfigItem(
		keyName = "customSwapperInstructions",
		name = "Instructions",
		description = "Options to swap to the top.",
		section = customSwapInstructions,
		position = 2
	)
	default String customSwapperInstructions() {
		return "https://github.com/geheur/More-menu-entry-swaps/wiki/Custom-swaps";
	}

	@ConfigSection(name = "Advanced", description = "Advanced options", position = -6, closedByDefault = true)
	String advancedSection = "Advanced";

	@ConfigItem(
		keyName = "examineCancelLateRemoval",
		name = "Examine/Cancel late removal",
		description = "Keep enabled if you don't understand what this option does.<br>Disabling it can prevent runelite's regular menu swapper from adding its shift-click config options, as well as interfere with cancelling a targeted spell.<br>Specifically, this option prevents the \"Examine\" and \"Cancel\" options from being removed until you open the right-click menu.",
		section = advancedSection,
		position = 0
	)
	default boolean examineCancelLateRemoval() {
		return true;
	}

	@ConfigItem(
		keyName = "doNotSwapOverMinimapOrbs",
		name = "Don't swap minimap orbs",
		description = "Do not swap entries over the minimap orbs such as quick-prayer and special attack.",
		section = advancedSection,
		position = 1
	)
	default boolean doNotSwapOverMinimapOrbs()
	{
		return true;
	}

	@ConfigSection(name = "Ground Item Sort", description = "", position = -8, closedByDefault = true)
	String groundItemSortSection = "Ground Item Sort";

	@ConfigItem(
		keyName = "groundItemSortCustomValues",
		name = "Ground item order",
		description = "Put item names on separate lines in the order you want them to appear in the top of the menu.<br>" +
			"Wildcards (*) are supported.<br>" +
			"You can assign values e.g. \"*defender,100000\" instead of changing the order, but note that lines with no value have a very high value (approximately 2.147b), and items not in the list have value 0.<br>" +
			"Negative values are supported \"bones,-1\".<br>" +
			"Noted items supported via \"noted:iron ore\" \"unnoted:iron ore\".<br>" +
			"\"###highlighted###\" and \"###hidden###\" represent any item that is in those lists in the ground items plugin.<br>" +
			"No support for item quantities.",
		section = groundItemSortSection,
		position = 1
	)
	default String groundItemSortCustomValues() {
		return "";
	}

	@ConfigItem(
		keyName = "doNotSwapDeprioritizedGroundItems",
		name = "Don't swap deprioritized \"Take\"",
		description = "Do not allow custom swaps like \"take,*\" to swap \"Take\" options that are deprioritized (below the \"Walk here\" option), such as those deprioritized via the Ground Items plugin.",
		section = groundItemSortSection,
		position = 2
	)
	default boolean doNotSwapDeprioritizedGroundItems() {
		return false;
	}

	@ConfigItem(
		keyName = "groundItemsPriceSortMode",
		name = "Price Sort",
		description =
			"Grand Exchange: Use Grand Exchange price<br>" +
			"max(GE, High Alch): Use highest of Grand Exchange price and High Alchemy price<br>" +
			"Items you've entered into the ground item sort list will use that list's value instead.",
		section = groundItemSortSection,
		position = 3
	)
	default GroundItemPriceSortMode groundItemsPriceSortMode() {
		return GroundItemPriceSortMode.DISABLED;
	}

	@ConfigSection(name = "Bank", description = "Swap menu entries in the bank, deposit box, seed vault, price checker interface, and chambers storage unit.", position = 0, closedByDefault = true)
	String bankSection = "bank";

	@ConfigItem(
			keyName = "bankSwap1Hotkey",
			name = "1",
			description = "The hotkey which, when held, swaps the withdraw/deposit 1 option",
			section = bankSection,
			position = 0
	)
	default Keybind getBankSwap1Hotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "bankSwap5Hotkey",
			name = "5",
			description = "The hotkey which, when held, swaps the withdraw/deposit 5 option",
			section = bankSection,
			position = 1
	)
	default Keybind getBankSwap5Hotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "bankSwap10Hotkey",
			name = "10",
			description = "The hotkey which, when held, swaps the withdraw/deposit 10 option",
			section = bankSection,
			position = 2
	)
	default Keybind getBankSwap10Hotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "bankSwapXHotkey",
			name = "X",
			description = "The hotkey which, when held, swaps the withdraw/deposit X option",
			section = bankSection,
			position = 3
	)
	default Keybind getBankSwapXHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "bankSwapSetXHotkey",
			name = "Set-X",
			description = "The hotkey which, when held, swaps the withdraw/deposit SetX option",
			section = bankSection,
			position = 4
	)
	default Keybind getBankSwapSetXHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "bankSwapAllHotkey",
			name = "All",
			description = "The hotkey which, when held, swaps the withdraw/deposit All option",
			section = bankSection,
			position = 5
	)
	default Keybind getBankSwapAllHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "bankSwapAllBut1Hotkey",
			name = "All-But-1",
			description = "The hotkey which, when held, swaps the withdraw AllBut1 option",
			section = bankSection,
			position = 6
	)
	default Keybind getBankSwapAllBut1Hotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "bankSwapExtraOpHotkey",
			name = "Eat/Wield/Etc.",
			description = "The hotkey which, when held, swaps the bank's Eat/Wield/etc. option.<br>Remember to enable this feature in the jagex bank settings (top right button in the bank).",
			section = bankSection,
			position = 7
	)
	default Keybind getBankSwapExtraOpHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "lockUnlockSlotHotkey",
			name = "Lock/unlock-slot",
			description = "The hotkey which, when held, lets you lock and unlock slots with left click.<br>Remember to enable this feature in the jagex bank settings (top right button in the bank).",
			section = bankSection,
			position = 8
	)
	default Keybind lockUnlockSlotHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigSection(
			name = "Spirit tree/Fairy ring",
			description = "All options that swap entries on a spirit tree or fairy ring",
			position = 1,
			closedByDefault = true
	)
	String treeRingSection = "treeRing";

	@ConfigItem(
			keyName = "swapZanaris",
			name = "Zanaris",
			description = "The hotkey which swaps \"Zanaris\"",
			section = treeRingSection,
			position = 0
	)
	default Keybind getSwapZanarisHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "swapTree",
			name = "Tree",
			description = "The hotkey which swaps \"Tree\"",
			section = treeRingSection,
			position = 1
	)
	default Keybind getSwapTreeHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "swapConfigure",
			name = "Configure",
			description = "The hotkey which swaps \"Configure\"",
			section = treeRingSection,
			position = 2
	)
	default Keybind getSwapConfigureHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "swapLastDestination",
			name = "Last-destination",
			description = "The hotkey which swaps \"Last-destination\"",
			section = treeRingSection,
			position = 3
	)
	default Keybind getSwapLastDestinationHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigSection(
			name = "Occult Altar/Spellbook swap",
			description = "Occult altar menu entry swaps",
			position = 2,
			closedByDefault = true
	)
	String occultAltarSection = "occultAltar";

	@Getter
	@RequiredArgsConstructor
	enum OccultAltarLeftClick {
		OFF(VENERATE, VENERATE),

		STANDARD_VENERATE(STANDARD, VENERATE),
		STANDARD_ANCIENT(STANDARD, ANCIENT),
		STANDARD_LUNAR(STANDARD, LUNAR),
		STANDARD_ARCEUUS(STANDARD, ARCEUUS),

		ANCIENT_VENERATE(ANCIENT, VENERATE),
		ANCIENT_STANDARD(ANCIENT, STANDARD),
		ANCIENT_LUNAR(ANCIENT, LUNAR),
		ANCIENT_ARCEUUS(ANCIENT, ARCEUUS),

		LUNAR_VENERATE(LUNAR, VENERATE),
		LUNAR_STANDARD(LUNAR, STANDARD),
		LUNAR_ANCIENT(LUNAR, ANCIENT),
		LUNAR_ARCEUUS(LUNAR, ARCEUUS),

		ARCEUUS_VENERATE(ARCEUUS, VENERATE),
		ARCEUUS_STANDARD(ARCEUUS, STANDARD),
		ARCEUUS_ANCIENT(ARCEUUS, ANCIENT),
		ARCEUUS_LUNAR(ARCEUUS, LUNAR),
		;

		private final OccultAltarSwap firstOption;
		private final OccultAltarSwap secondOption;
	}

	@ConfigItem(
			keyName = "occultAltarLeftClick",
			name = "Left click",
			description = "The occult altar's left-click option. The second option is used if you are already on the spellbook of the first option. If you want to swap the spellbook swap spell's left-click option, use the runelite menu entry swapper plugin instead.",
			section = occultAltarSection,
			position = 0
	)
	default OccultAltarLeftClick getOccultAltarLeftClickSwap()
	{
		return OccultAltarLeftClick.OFF;
	}

	@ConfigItem(
			keyName = "swapVenerateHotkey",
			name = "Venerate/Cast",
			description = "The hotkey which swaps \"Venerate\" on the Occult Altar and \"Cast\" on Spellbook swap",
			section = occultAltarSection,
			position = 1
	)
	default Keybind getSwapVenerateHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "swapStandardHotkey",
			name = "Standard",
			description = "The hotkey which swaps \"Standard\"",
			section = occultAltarSection,
			position = 2
	)
	default Keybind getSwapStandardHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "swapAncientHotkey",
			name = "Ancient",
			description = "The hotkey which swaps \"Ancient\"",
			section = occultAltarSection,
			position = 3
	)
	default Keybind getSwapAncientHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "swapLunarHotkey",
			name = "Lunar",
			description = "The hotkey which swaps \"Lunar\"",
			section = occultAltarSection,
			position = 4
	)
	default Keybind getSwapLunarHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "swapArceuusHotkey",
			name = "Arceuus",
			description = "The hotkey which swaps \"Arceuus\"",
			section = occultAltarSection,
			position = 5
	)
	default Keybind getSwapArceuusHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(name=
		"Spellbook swap",
		description = "Make the hotkeys work on spellbook swap.", keyName = "swapSpellbookSwap", section = occultAltarSection, position = 6
	) default boolean swapSpellbookSwap() { return true; }

	@ConfigSection(
		name = "Jewellery box",
		description = "The jewellery box in a player owned house.",
		position = 3,
		closedByDefault = true
	)
	String jewelleryBoxSection = "jewelleryBox";

	@ConfigItem(
		keyName = "swapJewelleryBoxHotkey",
		name = "Swap Jewellery Box",
		description = "swap the second with the first menu option on the Jewellery Box. Left-click swaps can be changed in the default Menu Entry Swapper.",
		section = jewelleryBoxSection,
		position = 0
	)
	default Keybind getSwapJewelleryBoxHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigSection(
		name = "Portal Nexus",
		description = "Things in the player owned house portal nexus.",
		position = 4,
		closedByDefault = true
	)
	String portalNexusSection = "portalNexus";

	@ConfigItem(
		keyName = "portalNexusDestinationSwapHotKey",
		name = "Nexus Destination",
		description = "The configured default destination",
		section = portalNexusSection,
		position = 0
	)
	default Keybind portalNexusDestinationSwapHotKey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
		keyName = "portalNexusTeleportMenuSwapHotKey",
		name = "Nexus Teleport Menu",
		description = "",
		section = portalNexusSection,
		position = 1
	)
	default Keybind portalNexusTeleportMenuSwapHotKey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
		keyName = "portalNexusConfigurationSwapHotKey",
		name = "Nexus Configuration",
		description = "The option named \"Configuration\"",
		section = portalNexusSection,
		position = 2
	)
	default Keybind portalNexusConfigurationSwapHotKey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
		keyName = "pohXericsTalismanLeftClick",
		name = "Xeric's Left Click",
		description = "",
		section = portalNexusSection,
		position = 3
	)
	default HotkeyableMenuSwapsPlugin.PortalNexusXericsTalismanSwap pohXericsTalismanLeftClick()
	{
		return HotkeyableMenuSwapsPlugin.PortalNexusXericsTalismanSwap.DESTINATION;
	}

	@ConfigItem(
		keyName = "pohXericsTalismanDestination",
		name = "Xeric's Destination",
		description = "The configured default destination",
		section = portalNexusSection,
		position = 4
	)
	default Keybind pohXericsTalismanDestination()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
		keyName = "pohXericsTalismanTeleportMenu",
		name = "Xeric's Teleport Menu",
		description = "",
		section = portalNexusSection,
		position = 5
	)
	default Keybind pohXericsTalismanTeleportMenu()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
		keyName = "pohXericsTalismanConfiguration",
		name = "Xeric's Configuration",
		description = "The option named \"Configuration\"",
		section = portalNexusSection,
		position = 6
	)
	default Keybind pohXericsTalismanConfiguration()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
		keyName = "pohDigsitePendantLeftClick",
		name = "Digsite Left Click",
		description = "",
		section = portalNexusSection,
		position = 7
	)
	default HotkeyableMenuSwapsPlugin.PortalNexusDigsitePendantSwap pohDigsitePendantLeftClick()
	{
		return HotkeyableMenuSwapsPlugin.PortalNexusDigsitePendantSwap.DESTINATION;
	}

	@ConfigItem(
		keyName = "pohDigsitePendantDestination",
		name = "Digsite Destination",
		description = "The configured default destination",
		section = portalNexusSection,
		position = 8
	)
	default Keybind pohDigsitePendantDestination()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
		keyName = "pohDigsitePendantTeleportMenu",
		name = "Digsite Teleport Menu",
		description = "",
		section = portalNexusSection,
		position = 9
	)
	default Keybind pohDigsitePendantTeleportMenu()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
		keyName = "pohDigsitePendantConfiguration",
		name = "Digsite Configuration",
		description = "The option named \"Configuration\"",
		section = portalNexusSection,
		position = 10
	)
	default Keybind pohDigsitePendantConfiguration()
	{
		return Keybind.NOT_SET;
	}

	@ConfigSection(
			name = "Inventory",
			description = "Inventory menu entry swaps",
			position = 5,
			closedByDefault = true
	)
	String inventorySection = "inventory";

	@ConfigItem(
			keyName = "swapUseHotkey",
			name = "Swap Use",
			description = "swap \"Use\" on items in the inventory",
			section = inventorySection,
			position = 0
	)
	default Keybind getSwapUseHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigSection(
		name = "Old options",
		description = "Old options that aren't very useful anymore.",
		position = 6,
		closedByDefault = true
	)
	String oldOptionsSection = "oldOptions";

	@ConfigItem(name = "Max Cape (equipped)",
		keyName = "oldHeading1", description = "", section = oldOptionsSection, position = 0)
	default void oldHeading1() {}

	@ConfigItem(
		keyName = "maxCapeCraftingGuildSwapHotKey",
		name = "Crafting Guild",
		description = "",
		section = oldOptionsSection, position = 1)
	default Keybind maxCapeCraftingGuildSwapHotKey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
		keyName = "maxCapeWarriorsGuildSwapHotKey", 
		name = "Warriors Guild",
		description = "",
		section = oldOptionsSection, position = 2)
	default Keybind maxCapeWarriorsGuildSwapHotKey() {
		return Keybind.NOT_SET;
	}

	@ConfigItem(
		keyName = "maxCapeTelePOHSwapHotKey", 
		name = "Tele to POH",
		description = "",
		section = oldOptionsSection, position = 3)
	default Keybind maxCapeTelePOHSwapHotKey() {
		return Keybind.NOT_SET;
	}

	@ConfigItem(name = "Book of the dead (equipped)",
		keyName = "oldHeading2", description = "", section = oldOptionsSection, position = 4)
	default void oldHeading2() {}

	@ConfigItem(
		keyName = "botdHosidiusHotKey",
		name = "Hosidius",
		description = "",
		section = oldOptionsSection, position = 5)
	default Keybind botdHosidiusHotKey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
		keyName = "botdPiscariliusHotKey",
		name = "Piscarilius",
		description = "",
		section = oldOptionsSection, position = 6)
	default Keybind botdPiscariliusHotKey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
		keyName = "botdShayzeinHotKey",
		name = "Shayzein",
		description = "",
		section = oldOptionsSection, position = 7)
	default Keybind botdShayzeinHotKey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
		keyName = "botdLovakengjHotKey",
		name = "Lovakengj",
		description = "",
		section = oldOptionsSection, position = 8)
	default Keybind botdLovakengjHotKey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
		keyName = "botdArceuusHotKey",
		name = "Arceuus",
		description = "",
		section = oldOptionsSection, position = 9)
	default Keybind botdArceuusHotKey()
	{
		return Keybind.NOT_SET;
	}
}

package com.hotkeyablemenuswaps;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.config.Keybind;

import java.util.function.Function;

@Getter
@RequiredArgsConstructor
enum MaxCapeSwap implements HotkeyableMenuSwapsPlugin.hasKeybind {
    CRAFTING_GUILD("crafting guild", HotkeyableMenuSwapsConfig::maxCapeCraftingGuildSwapHotKey),
    WARRIORS_GUILD("warriors' guild", HotkeyableMenuSwapsConfig::maxCapeWarriorsGuildSwapHotKey),
    TELE_POH("tele to poh", HotkeyableMenuSwapsConfig::maxCapeTelePOHSwapHotKey),
    ;

    private final String menuOptionName;
    private final Function<HotkeyableMenuSwapsConfig, Keybind> keybindFunction;

    public Keybind getKeybind(HotkeyableMenuSwapsConfig config) {
        return keybindFunction.apply(config);
    }
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.hotkeyablemenuswaps;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

enum MatchType
{
	EQUALS,
	STARTS_WITH,
	ENDS_WITH,
	CONTAINS,
	WILDCARD,
	IGNORE,
	;

	public boolean matches(String menuText, String swapText)
	{
		switch (this) {
			case IGNORE:
				return true;
			case EQUALS:
				return menuText.equals(swapText);
			case STARTS_WITH:
				return menuText.startsWith(swapText);
			case ENDS_WITH:
				return menuText.endsWith(swapText);
			case CONTAINS:
				return menuText.contains(swapText);
			case WILDCARD:
				return menuText.matches(swapText);
			default:
				// shouldn't happen.
				throw new IllegalStateException();
		}
	}

	public static MatchType getType(String s)
	{
		if (s == null) return MatchType.IGNORE;

		int star = s.indexOf('*');
		if (star == -1) return MatchType.EQUALS;
		if (star == 0) {
			if (s.length() == 1) return MatchType.IGNORE;
			star = s.indexOf('*', star + 1);
			if (star == -1) return MatchType.ENDS_WITH;
			if (star == s.length() - 1) return MatchType.CONTAINS;
		} else if (star == s.length() - 1) {
			return MatchType.STARTS_WITH;
		}

		return MatchType.WILDCARD;
	}

	public static String prepareMatch(String option, MatchType optionType)
	{
		return optionType == MatchType.WILDCARD ? generateWildcardMatcher(option) : removeStars(option);
	}

	private static String removeStars(String s)
	{
		return s == null ? s : s.replaceAll("\\*", "");
	}

	// copied from runelite.
	private static final Pattern WILDCARD_PATTERN = Pattern.compile("(?i)[^*]+|(\\*)");
	private static String generateWildcardMatcher(String pattern)
	{
		final Matcher matcher = WILDCARD_PATTERN.matcher(pattern);
		final StringBuffer buffer = new StringBuffer();

		buffer.append("(?i)");
		while (matcher.find())
		{
			if (matcher.group(1) != null)
			{
				matcher.appendReplacement(buffer, ".*");
			}
			else
			{
				matcher.appendReplacement(buffer, Matcher.quoteReplacement(Pattern.quote(matcher.group(0))));
			}
		}

		matcher.appendTail(buffer);
		return buffer.toString();
	}
}


package com.hotkeyablemenuswaps;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.client.config.Keybind;

import java.util.function.Function;

@Getter
@RequiredArgsConstructor
enum OccultAltarSwap implements HotkeyableMenuSwapsPlugin.hasKeybind {
    VENERATE("venerate", "Cast", HotkeyableMenuSwapsConfig::getSwapVenerateHotkey),
    STANDARD("standard", "Standard", HotkeyableMenuSwapsConfig::getSwapStandardHotkey),
    ANCIENT("ancient", "Ancient", HotkeyableMenuSwapsConfig::getSwapAncientHotkey),
    LUNAR("lunar", "", HotkeyableMenuSwapsConfig::getSwapLunarHotkey),
    ARCEUUS("arceuus", "Arceuus", HotkeyableMenuSwapsConfig::getSwapArceuusHotkey),
    ;

    public static OccultAltarSwap getCurrentSpellbookMenuOption(Client client) {
        return values()[client.getVarbitValue(4070) + 1]; // 4070 indicated the player's current spellbook.
    }

    private final String menuOptionName;
	private final String spellbookSwapMenuOptionName;
	private final Function<HotkeyableMenuSwapsConfig, Keybind> keybindFunction;

    public Keybind getKeybind(HotkeyableMenuSwapsConfig config) {
        return keybindFunction.apply(config);
    }
}

/*
 * Copyright (c) 2017, Aria <aria@ar1as.space>
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * Copyright (c) 2018, Tomas Slusny <slusnucky@gmail.com>
 * Copyright (c) 2020, dekvall <https://github.com/dekvall>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.hotkeyablemenuswaps;

import com.google.common.base.Strings;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import com.google.common.collect.HashBasedTable;
import com.google.common.collect.Table;
import com.google.inject.Inject;
import java.time.Instant;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import lombok.Builder;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameState;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemID;
import net.runelite.api.Tile;
import net.runelite.api.TileItem;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.ItemDespawned;
import net.runelite.api.events.ItemQuantityChanged;
import net.runelite.api.events.ItemSpawned;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.GameEventManager;
import net.runelite.client.util.Text;
import net.runelite.client.util.WildcardMatcher;

// Mostly copypasted stuff from runelite's ground items plugin. Used to access highlighted and hidden item lists.
@Slf4j
public class GroundItemsStuff
{
	@Inject private ItemManager itemManager;
	@Inject private ConfigManager configManager;
	@Inject private GameEventManager gameEventManager;
	@Inject private EventBus eventBus;

	public final Table<WorldPoint, Integer, GroundItem> collectedGroundItems = HashBasedTable.create();
	public LoadingCache<NamedQuantity, Boolean> highlightedItems;
	public LoadingCache<NamedQuantity, Boolean> hiddenItems;

	@Subscribe
	public void onGameStateChanged(final GameStateChanged event)
	{
		if (event.getGameState() == GameState.LOADING)
		{
			// log.debug("[GIS-onGameStateChanged] Clearing collected ground items");
			collectedGroundItems.clear();
		}
	}

	@Subscribe
	public void onItemSpawned(ItemSpawned itemSpawned)
	{
		TileItem item = itemSpawned.getItem();
		Tile tile = itemSpawned.getTile();

		GroundItem groundItem = buildGroundItem(tile, item);
		GroundItem existing = collectedGroundItems.get(tile.getWorldLocation(), item.getId());
		if (existing != null)
		{
			existing.setQuantity(existing.getQuantity() + groundItem.getQuantity());
			// The spawn time remains set at the oldest spawn
			// log.debug("[GIS-onItemSpawned] Updated ground item in collectedGroundItems: {}", groundItem.getName());
		}
		else
		{
			collectedGroundItems.put(tile.getWorldLocation(), item.getId(), groundItem);
			// log.debug("[GIS-onItemSpawned] Added ground item to collectedGroundItems: {}", groundItem.getName());
		}
	}

	@Subscribe
	public void onItemDespawned(ItemDespawned itemDespawned)
	{
		TileItem item = itemDespawned.getItem();
		Tile tile = itemDespawned.getTile();

		GroundItem groundItem = collectedGroundItems.get(tile.getWorldLocation(), item.getId());
		if (groundItem == null)
		{
			// log.debug("[GIS-onItemDespawned] Ground item despawned, but not found in collectedGroundItems: {}", itemManager.getItemComposition(item.getId()).getName());
			return;
		}

		if (groundItem.getQuantity() <= item.getQuantity())
		{
			// log.debug("[GIS-onItemDespawned] Removed ground item from collectedGroundItems: {}", groundItem.getName());
			collectedGroundItems.remove(tile.getWorldLocation(), item.getId());
		}
		else
		{
			groundItem.setQuantity(groundItem.getQuantity() - item.getQuantity());
			// When picking up an item when multiple stacks appear on the ground,
			// it is not known which item is picked up, so we invalidate the spawn
			// time
			groundItem.setSpawnTime(null);
			// log.debug("[GIS-onItemDespawned] Updated ground item in collectedGroundItems: {} from {}->{]", groundItem.getName(), groundItem.getQuantity() + item.getQuantity(), groundItem.getQuantity());
		}
	}

	@Subscribe
	public void onItemQuantityChanged(ItemQuantityChanged itemQuantityChanged)
	{
		TileItem item = itemQuantityChanged.getItem();
		Tile tile = itemQuantityChanged.getTile();
		int oldQuantity = itemQuantityChanged.getOldQuantity();
		int newQuantity = itemQuantityChanged.getNewQuantity();

		int diff = newQuantity - oldQuantity;
		GroundItem groundItem = collectedGroundItems.get(tile.getWorldLocation(), item.getId());
		if (groundItem != null)
		{
			// log.debug("[GIS-onItemQuantityChanged] Ground item quantity changed: {} from {}->{}", groundItem.getName(), oldQuantity, newQuantity);
			groundItem.setQuantity(groundItem.getQuantity() + diff);
		}
	}

	@Data
	@Builder
	static class GroundItem
	{
		private int id;
		private int itemId;
		private String name;
		private int quantity;
		private WorldPoint location;
		private int height;
		private int haPrice;
		private int gePrice;
		private int offset;
		private boolean tradeable;
		@Nullable
		private Instant spawnTime;
		private boolean stackable;

		int getHaPrice()
		{
			return haPrice * quantity;
		}

		int getGePrice()
		{
			return gePrice * quantity;
		}
	}

	private GroundItem buildGroundItem(final Tile tile, final TileItem item)
	{
		// Collect the data for the item
		final int itemId = item.getId();
		final ItemComposition itemComposition = itemManager.getItemComposition(itemId);
		final int realItemId = itemComposition.getNote() != -1 ? itemComposition.getLinkedNoteId() : itemId;
		final int alchPrice = itemComposition.getHaPrice();

		final GroundItem groundItem = GroundItem.builder()
			.id(itemId)
			.location(tile.getWorldLocation())
			.itemId(realItemId)
			.quantity(item.getQuantity())
			.name(itemComposition.getName())
			.haPrice(alchPrice)
			.height(tile.getItemLayer().getHeight())
			.tradeable(itemComposition.isTradeable())
			.spawnTime(Instant.now())
			.stackable(itemComposition.isStackable())
			.build();

		switch(realItemId)
		{
			case ItemID.COINS_995:
				groundItem.setGePrice(1);
				groundItem.setHaPrice(1);
				break;
			case ItemID.PLATINUM_TOKEN:
				groundItem.setGePrice(1000);
				groundItem.setHaPrice(1000);
				break;
			default:
				groundItem.setGePrice(itemManager.getItemPrice(realItemId));
				break;
		}

		// log.debug("Built new ground item {}", groundItem);
		return groundItem;
	}

	@Value
	@RequiredArgsConstructor
	public static class NamedQuantity
	{
		private final String name;
		private final int quantity;

		NamedQuantity(GroundItem groundItem)
		{
			this(groundItem.getName(), groundItem.getQuantity());
		}
	}

	class WildcardMatchLoader extends CacheLoader<NamedQuantity, Boolean>
	{
		private final List<ItemThreshold> itemThresholds;

		WildcardMatchLoader(List<String> configEntries)
		{
			this.itemThresholds = configEntries.stream()
				.map(ItemThreshold::fromConfigEntry)
				.filter(Objects::nonNull)
				.collect(Collectors.toList());
		}

		@Override
		public Boolean load(@Nonnull final NamedQuantity key)
		{
			if (Strings.isNullOrEmpty(key.getName()))
			{
				return false;
			}

			final String filteredName = key.getName().trim();

			for (final ItemThreshold entry : itemThresholds)
			{
				if (WildcardMatcher.matches(entry.getItemName(), filteredName)
					&& entry.quantityHolds(key.getQuantity()))
				{
					return true;
				}
			}

			return false;
		}
	}

	@Value
	static class ItemThreshold
	{
		enum Inequality
		{
			LESS_THAN,
			MORE_THAN
		}

		private final String itemName;
		private final int quantity;
		private final ItemThreshold.Inequality inequality;

		static ItemThreshold fromConfigEntry(String entry)
		{
			if (Strings.isNullOrEmpty(entry))
			{
				return null;
			}

			ItemThreshold.Inequality operator = ItemThreshold.Inequality.MORE_THAN;
			int qty = 0;

			for (int i = entry.length() - 1; i >= 0; i--)
			{
				char c = entry.charAt(i);
				if (c >= '0' && c <= '9' || Character.isWhitespace(c))
				{
					continue;
				}
				switch (c)
				{
					case '<':
						operator = ItemThreshold.Inequality.LESS_THAN;
						// fallthrough
					case '>':
						if (i + 1 < entry.length())
						{
							try
							{
								qty = Integer.parseInt(entry.substring(i + 1).trim());
							}
							catch (NumberFormatException e)
							{
								qty = 0;
								operator = ItemThreshold.Inequality.MORE_THAN;
							}
							entry = entry.substring(0, i);
						}
				}
				break;
			}

			return new ItemThreshold(entry.trim(), qty, operator);
		}

		boolean quantityHolds(int itemCount)
		{
			if (inequality == ItemThreshold.Inequality.LESS_THAN)
			{
				return itemCount < quantity;
			}
			else
			{
				return itemCount > quantity;
			}
		}
	}

	private boolean registered = false;

	public void reloadGroundItemPluginLists(boolean shouldSortByPrice, boolean highlightedList, boolean hiddenList, boolean listsChanged)
	{
		if (highlightedList || hiddenList || shouldSortByPrice) {
			if (!registered) {
				gameEventManager.simulateGameEvents(this);
				eventBus.register(this);
				registered = true;
				log.debug("Registered GroundItemsStuff");
			}
		} else {
			eventBus.unregister(this);
			registered = false;
			collectedGroundItems.clear();
			log.debug("Unregistered GroundItemsStuff");
		}

		if (highlightedList) {
			if (highlightedItems == null || listsChanged) {
				List<String> highlightedItemsList = Text.fromCSV(configManager.getConfiguration("grounditems", "highlightedItems"));
				highlightedItems = CacheBuilder.newBuilder()
					.maximumSize(512L)
					.expireAfterAccess(10, TimeUnit.MINUTES)
					.build(new WildcardMatchLoader(highlightedItemsList));
			}
		} else {
			highlightedItems = null;
		}

		if (hiddenList) {
			if (hiddenItems == null || listsChanged) {
				List<String> hiddenItemsList = Text.fromCSV(configManager.getConfiguration("grounditems", "hiddenItems"));
				hiddenItems = CacheBuilder.newBuilder()
					.maximumSize(512L)
					.expireAfterAccess(10, TimeUnit.MINUTES)
					.build(new WildcardMatchLoader(hiddenItemsList));
			}
		} else {
			hiddenItems = null;
		}
	}
}

package com.hotkeyablemenuswaps;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.config.Keybind;

import java.util.function.Function;

@Getter
@RequiredArgsConstructor
enum TreeRingSwap implements HotkeyableMenuSwapsPlugin.hasKeybind {
    TREE("tree", HotkeyableMenuSwapsConfig::getSwapTreeHotkey),
    ZANARIS("zanaris", HotkeyableMenuSwapsConfig::getSwapZanarisHotkey),
    LAST_DESTINATION("last-destination", HotkeyableMenuSwapsConfig::getSwapLastDestinationHotkey),
    CONFIGURE("configure", HotkeyableMenuSwapsConfig::getSwapConfigureHotkey),
    ;

    private final String menuOptionName;
    private final Function<HotkeyableMenuSwapsConfig, Keybind> keybindFunction;

    public Keybind getKeybind(HotkeyableMenuSwapsConfig config) {
        return keybindFunction.apply(config);
    }
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * Copyright (c) 2018, Kamiel
 * Copyright (c) 2019, Rami <https://github.com/Rami-J>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.hotkeyablemenuswaps;

import static com.google.common.base.Predicates.alwaysTrue;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.LinkedHashMultimap;
import com.google.common.collect.Multimap;
import com.google.inject.Inject;
import com.google.inject.Provides;
import static com.hotkeyablemenuswaps.GroundItemPriceSortMode.DISABLED;
import com.hotkeyablemenuswaps.GroundItemsStuff.GroundItem;
import com.hotkeyablemenuswaps.GroundItemsStuff.NamedQuantity;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.ToString;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.api.KeyCode;
import net.runelite.api.Menu;
import net.runelite.api.MenuAction;
import static net.runelite.api.MenuAction.*;
import net.runelite.api.MenuEntry;
import net.runelite.api.Varbits;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.FocusChanged;
import net.runelite.api.events.MenuOpened;
import net.runelite.api.events.PostMenuSort;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.Keybind;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.ProfileChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.menuentryswapper.MenuEntrySwapperConfig;
import net.runelite.client.plugins.menuentryswapper.MenuEntrySwapperPlugin;
import net.runelite.client.util.Text;
import org.apache.commons.lang3.tuple.Pair;

// TODO when you press a key, then press and release a different key, the original key is no longer used for the keybind.
// Also, modifier keys cannot be activated if they are pressed when the client does not have focus, which is annoying.
// TODO mystery bug where my "T" for tree keybind stopped working entirely.
// wont-fix - when using shift as a hotkey it prevents some other hotkeys (e.g. lowercase "t") from being activated while shift is down.

@PluginDescriptor(
	name = "Custom Menu Swaps",
	tags = {"entry", "swapper", "custom", "text"}
)
@PluginDependency(MenuEntrySwapperPlugin.class)
@Slf4j
public class HotkeyableMenuSwapsPlugin extends Plugin implements KeyListener
{
	@Inject private Client client;
	@Inject private HotkeyableMenuSwapsConfig config;
	@Inject private KeyManager keyManager;
	@Inject private ConfigManager configManager;
	@Inject private MenuEntrySwapperConfig menuEntrySwapperConfig;
	@Inject private ItemManager itemManager;
	@Inject private GroundItemsStuff groundItemsStuff;

	// If a hotkey corresponding to a swap is currently held, these variables will be non-null. currentBankModeSwap is an exception because it uses menu entry swapper's bank swap enum, which already has an "off" value.
	// These variables do not factor in left-click swaps.
	private BankSwapMode currentBankModeSwap;
	private BankSwapMode currentNonBankModeSwap;
	private OccultAltarSwap hotkeyOccultAltarSwap;
	private TreeRingSwap hotkeyTreeRingSwap;
	private MaxCapeSwap hotkeyMaxCapeSwap;
	private BookOfTheDeadSwap hotkeyBOTDSwap;
	private boolean swapUse;
	private boolean swapJewelleryBox;
	private PortalNexusSwap swapPortalNexus;
	private PortalNexusXericsTalismanSwap swapPortalNexusXericsTalisman;
	private PortalNexusDigsitePendantSwap swapPortalNexusDigsitePendant;

	final List<CustomSwap> customSwaps = new ArrayList<>();
	final List<CustomSwap>[] customHotkeySwaps = new List[HOTKEY_COUNT];
	final List<CustomSwap> customShiftSwaps = new ArrayList<>();
	final List<CustomSwap> customHides = new ArrayList<>();

	private static final int HOTKEY_COUNT = 40;
	private long hotkeys = 0; // bitfield.
	private List<Keybind> customSwapKeybinds = new ArrayList<>();

	// Mirrors config field. This field is read quite often so doing this might be good for performance.
	private boolean examineCancelLateRemoval = true;

	@Provides
	HotkeyableMenuSwapsConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(HotkeyableMenuSwapsConfig.class);
	}

	@Override
	protected void startUp() {

		migrate();

		reloadCustomSwaps();
		reloadGroundItemSort();

		resetHotkeys();

		keyManager.registerKeyListener(this);

		examineCancelLateRemoval = config.examineCancelLateRemoval();

		swapContains("venerate", "altar of the occult"::equals, "standard", () -> getCurrentOccultAltarSwap() == OccultAltarSwap.STANDARD);
		swapContains("venerate", "altar of the occult"::equals, "ancient", () -> getCurrentOccultAltarSwap() == OccultAltarSwap.ANCIENT);
		swapContains("venerate", "altar of the occult"::equals, "lunar", () -> getCurrentOccultAltarSwap() == OccultAltarSwap.LUNAR);
		swapContains("venerate", "altar of the occult"::equals, "arceuus", () -> getCurrentOccultAltarSwap() == OccultAltarSwap.ARCEUUS);

		for (String option : new String[]{"last-destination", "zanaris", "configure", "tree"}) {
			swapContains(option, alwaysTrue(), "zanaris", () -> getCurrentTreeRingSwap() == TreeRingSwap.ZANARIS);
			swapContains(option, alwaysTrue(), "last-destination", () -> getCurrentTreeRingSwap() == TreeRingSwap.LAST_DESTINATION);
			swapContains(option, alwaysTrue(), "configure", () -> getCurrentTreeRingSwap() == TreeRingSwap.CONFIGURE);
			swapContains(option, alwaysTrue(), "tree", () -> getCurrentTreeRingSwap() == TreeRingSwap.TREE);
		}

		for (String option : new String[] { "crafting guild", "warriors' guild", "fishing teleports", "remove",
				"tele to poh", "poh portals", "other teleports", "spellbook", "features", "examine" }) {
			swapContains(option, "max cape"::equals, "crafting guild", () -> getCurrentMaxCapeSwap() == MaxCapeSwap.CRAFTING_GUILD);
			swapContains(option, "max cape"::equals, "warriors' guild", () -> getCurrentMaxCapeSwap() == MaxCapeSwap.WARRIORS_GUILD);
			swapContains(option, "max cape"::equals, "tele to poh", () -> getCurrentMaxCapeSwap() == MaxCapeSwap.TELE_POH);
		}

		Predicate<String> botdMatcher = s -> s.equals("book of the dead") || s.equals("kharedst's memoirs");
		for (String option : new String[] { "lunch by the lancalliums", "the fisher's flute", "history and hearsay",
				"jewellery of jubilation", "a dark disposition", "check", "remove", "examine" }) {
			swapContains(option, botdMatcher, "lunch by the lancalliums", () -> getCurrentBOTDSwap() == BookOfTheDeadSwap.HOSIDIUS);
			swapContains(option, botdMatcher, "the fisher's flute", () -> getCurrentBOTDSwap() == BookOfTheDeadSwap.PISCARILIUS);
			swapContains(option, botdMatcher, "history and hearsay", () -> getCurrentBOTDSwap() == BookOfTheDeadSwap.SHAYZEIN);
			swapContains(option, botdMatcher, "jewellery of jubilation", () -> getCurrentBOTDSwap() == BookOfTheDeadSwap.LOVAKENGJ);
			swapContains(option, botdMatcher, "a dark disposition", () -> getCurrentBOTDSwap() == BookOfTheDeadSwap.ARCEUUS);
		}
	}

	@Override
	protected void shutDown() {
		keyManager.unregisterKeyListener(this);
		groundItemsStuff.reloadGroundItemPluginLists(false, false, false, false);
	}

	@Subscribe
	public void onProfileChanged(ProfileChanged e) {
		migrate();
	}

	private void migrate()
	{
		String serialVersion = configManager.getConfiguration("hotkeyablemenuswaps", "serialVersion");
		if (serialVersion == null) {
			if (
				"Shift".equals(config.getSwapVenerateHotkey().toString()) ||
				"Shift".equals(config.getSwapStandardHotkey().toString()) ||
				"Shift".equals(config.getSwapAncientHotkey().toString()) ||
				"Shift".equals(config.getSwapArceuusHotkey().toString())
			) {
				// avoid interfering with runelite MES shift-clicks.
				configManager.setConfiguration("hotkeyablemenuswaps", "swapSpellbookSwap", false);
			}
		}
		configManager.setConfiguration("hotkeyablemenuswaps", "serialVersion", 2);
	}

	private OccultAltarSwap getCurrentOccultAltarSwap() {
		OccultAltarSwap currentSpellbook = OccultAltarSwap.getCurrentSpellbookMenuOption(client);
		if (hotkeyOccultAltarSwap == null || hotkeyOccultAltarSwap == currentSpellbook) {
			HotkeyableMenuSwapsConfig.OccultAltarLeftClick leftClickSwap = config.getOccultAltarLeftClickSwap();
			return (leftClickSwap.getFirstOption() == currentSpellbook)
				? leftClickSwap.getSecondOption()
				: leftClickSwap.getFirstOption();
		} else {
			return hotkeyOccultAltarSwap;
		}
	}

	private boolean swapJewelleryBoxSpecificOption() {
		return swapJewelleryBox && !vanillaJewelleryBoxSwapEnabled();
	}

	private boolean swapJewelleryBoxTeleportMenuOption() {
		return swapJewelleryBox && vanillaJewelleryBoxSwapEnabled();
	}

	private boolean vanillaJewelleryBoxSwapEnabled()
	{
		return (boolean) configManager.getConfiguration(RuneLiteConfig.GROUP_NAME, "menuentryswapperplugin", Boolean.class) && menuEntrySwapperConfig.swapJewelleryBox();
	}

	private boolean vanillaPortalNexusSwapEnabled() {
		return (boolean) configManager.getConfiguration(RuneLiteConfig.GROUP_NAME, "menuentryswapperplugin", Boolean.class) && menuEntrySwapperConfig.swapPortalNexus();
	}

	/**
	 * Takes into account left-click swap in addition to any hotkeys held down.
	 */
	private PortalNexusDigsitePendantSwap getPortalNexusDigsitePendantSwap()
	{
		return swapPortalNexusDigsitePendant != null ? swapPortalNexusDigsitePendant : config.pohDigsitePendantLeftClick();
	}

	/**
	 * Takes into account left-click swap in addition to any hotkeys held down.
	 */
	private PortalNexusXericsTalismanSwap getPortalNexusXericsTalismanSwap()
	{
		return swapPortalNexusXericsTalisman != null ? swapPortalNexusXericsTalisman : config.pohXericsTalismanLeftClick();
	}

//	@Getter
//	@AllArgsConstructor
//	public enum JewelleryBoxSwap {
//		TELEPORT_MENU(MenuAction.GAME_OBJECT_SECOND_OPTION, HotkeyableMenuSwapsConfig::pohXericsTalismanTeleportMenu),
//		DESTINATION(MenuAction.GAME_OBJECT_THIRD_OPTION, HotkeyableMenuSwapsConfig::pohXericsTalismanTeleportMenu),
//		;
//
//		private final MenuAction menuAction;
//		private final Function<HotkeyableMenuSwapsConfig, Keybind> keybindFunction;
//
//		public Keybind getKeybind(HotkeyableMenuSwapsConfig config) {
//			return keybindFunction.apply(config);
//		}
//	}
//
	private Map<Object, Keybind> keybindCache = new HashMap<>();

	interface hasKeybind {
		default Keybind getKeybind(HotkeyableMenuSwapsConfig config, Map<Object, Keybind> keybindCache) {
			return keybindCache.computeIfAbsent(this, o -> getKeybind(config));
		}

		Keybind getKeybind(HotkeyableMenuSwapsConfig config);
	}

	@Getter
	@AllArgsConstructor
	public enum PortalNexusSwap implements hasKeybind {
		DESTINATION(MenuAction.GAME_OBJECT_FIRST_OPTION, HotkeyableMenuSwapsConfig::portalNexusDestinationSwapHotKey),
		TELEPORT_MENU(MenuAction.GAME_OBJECT_SECOND_OPTION, HotkeyableMenuSwapsConfig::portalNexusTeleportMenuSwapHotKey),
		CONFIGURATION(MenuAction.GAME_OBJECT_THIRD_OPTION, HotkeyableMenuSwapsConfig::portalNexusConfigurationSwapHotKey),
		;

		private final MenuAction menuAction;
		private final Function<HotkeyableMenuSwapsConfig, Keybind> keybindFunction;

		public Keybind getKeybind(HotkeyableMenuSwapsConfig config) {
			return keybindFunction.apply(config);
		}
	}

	@Getter
	@AllArgsConstructor
	public enum PortalNexusXericsTalismanSwap implements hasKeybind {
		DESTINATION(MenuAction.GAME_OBJECT_FIRST_OPTION, HotkeyableMenuSwapsConfig::pohXericsTalismanDestination),
		TELEPORT_MENU(MenuAction.GAME_OBJECT_SECOND_OPTION, HotkeyableMenuSwapsConfig::pohXericsTalismanTeleportMenu),
		CONFIGURATION(MenuAction.GAME_OBJECT_THIRD_OPTION, HotkeyableMenuSwapsConfig::pohXericsTalismanConfiguration),
		;

		private final MenuAction menuAction;
		private final Function<HotkeyableMenuSwapsConfig, Keybind> keybindFunction;

		public Keybind getKeybind(HotkeyableMenuSwapsConfig config) {
			return keybindFunction.apply(config);
		}
	}

	@Getter
	@AllArgsConstructor
	public enum PortalNexusDigsitePendantSwap implements hasKeybind
	{
		DESTINATION(MenuAction.GAME_OBJECT_FIRST_OPTION, HotkeyableMenuSwapsConfig::pohDigsitePendantDestination),
		TELEPORT_MENU(MenuAction.GAME_OBJECT_SECOND_OPTION, HotkeyableMenuSwapsConfig::pohDigsitePendantTeleportMenu),
		CONFIGURATION(MenuAction.GAME_OBJECT_THIRD_OPTION, HotkeyableMenuSwapsConfig::pohDigsitePendantConfiguration),
		;

		private final MenuAction menuAction;
		private final Function<HotkeyableMenuSwapsConfig, Keybind> keybindFunction;

		public Keybind getKeybind(HotkeyableMenuSwapsConfig config) {
			return keybindFunction.apply(config);
		}
	}

	private TreeRingSwap getCurrentTreeRingSwap() {
		return hotkeyTreeRingSwap;
	}

	private MaxCapeSwap getCurrentMaxCapeSwap() {
		return hotkeyMaxCapeSwap;
	}

	private BookOfTheDeadSwap getCurrentBOTDSwap() {
		return hotkeyBOTDSwap;
	}

	@Override
	public void keyTyped(KeyEvent e) {
		// not used.
	}

	private int bankSwapVarbit = 0;

	@Subscribe
	public void onVarbitChanged(VarbitChanged event)
	{
		int setting = client.getVarbitValue(6590);

		if (bankSwapVarbit != setting)
		{
			bankSwapVarbit = client.getVarbitValue(6590);
		}
	}

	// indexes correspond to values of the varbit that represents the current left-click option.
	private static final BankSwapMode[] bankSwapModes = {
			BankSwapMode.SWAP_1,
			BankSwapMode.SWAP_5,
			BankSwapMode.SWAP_10,
			BankSwapMode.SWAP_X,
			BankSwapMode.SWAP_ALL
	};

	@Override
	public void keyPressed(KeyEvent e)
	{
		for (int i = 0; i < customSwapKeybinds.size(); i++) {
			if (customSwapKeybinds.get(i).matches(e)) {
				hotkeys |= 1L << i;
			}
		}

		// ignoring the current left click option allows one keybind to be used for two different swaps - e.g. the
		// same keybind for both "1" and "all", which makes bank-1 accessible while the left-click option is set
		// to "all" via the vanilla bank interface, without requiring an additional keybind.
		// Currently only applies to the bank.
		BankSwapMode currentLeftClick = bankSwapModes[bankSwapVarbit];

		for (BankSwapMode swapMode : BankSwapMode.values()) {
			if ((swapMode.getKeybind(config, keybindCache)).matches(e)) {
				if (swapMode != currentLeftClick) {
					currentBankModeSwap = swapMode;
				}
				currentNonBankModeSwap = swapMode;
			}
		}

		for (OccultAltarSwap altarOption : OccultAltarSwap.values()) {
			if ((altarOption.getKeybind(config, keybindCache)).matches(e)) {
				hotkeyOccultAltarSwap = altarOption;
				break;
			}
		}

		for (TreeRingSwap treeRingSwap : TreeRingSwap.values()) {
			if ((treeRingSwap.getKeybind(config, keybindCache)).matches(e)) {
				hotkeyTreeRingSwap = treeRingSwap;
				break;
			}
		}

		for (MaxCapeSwap maxCapeSwap : MaxCapeSwap.values()) {
			if ((maxCapeSwap.getKeybind(config, keybindCache)).matches(e)) {
				hotkeyMaxCapeSwap = maxCapeSwap;
				break;
			}
		}

		for (BookOfTheDeadSwap botdSwap : BookOfTheDeadSwap.values()) {
			if ((botdSwap.getKeybind(config, keybindCache)).matches(e)) {
				hotkeyBOTDSwap = botdSwap;
				break;
			}
		}

		for (PortalNexusSwap option : PortalNexusSwap.values()) {
			if ((option.getKeybind(config, keybindCache)).matches(e)) {
				swapPortalNexus = option;
				break;
			}
		}

		for (PortalNexusXericsTalismanSwap option : PortalNexusXericsTalismanSwap.values()) {
			if ((option.getKeybind(config, keybindCache)).matches(e)) {
				swapPortalNexusXericsTalisman = option;
				break;
			}
		}

		for (PortalNexusDigsitePendantSwap option : PortalNexusDigsitePendantSwap.values()) {
			if ((option.getKeybind(config, keybindCache)).matches(e)) {
				swapPortalNexusDigsitePendant = option;
				break;
			}
		}

		if (config.getSwapUseHotkey().matches(e)) {
			swapUse = true;
		}

		if (config.getSwapJewelleryBoxHotkey().matches(e)) {
			swapJewelleryBox = true;
		}
	}

	@Override
	public void keyReleased(KeyEvent e)
	{
		for (int i = 0; i < customSwapKeybinds.size(); i++) {
			if (customSwapKeybinds.get(i).matches(e)) {
				hotkeys &= ~(1L << i);
			}
		}

		for (BankSwapMode swapMode : BankSwapMode.values()) {
			boolean matchesBankMode = swapMode == currentBankModeSwap;
			boolean matchesNonBankMode = swapMode == currentNonBankModeSwap;
			if (!matchesBankMode && !matchesNonBankMode) continue;
			if ((swapMode.getKeybind(config, keybindCache)).matches(e)) {
				if (matchesBankMode) {
					currentBankModeSwap = BankSwapMode.OFF;
				}
				if (matchesNonBankMode) {
					currentNonBankModeSwap = BankSwapMode.OFF;
				}
			}
		}

		for (OccultAltarSwap altarOption : OccultAltarSwap.values()) {
			if ((altarOption.getKeybind(config, keybindCache)).matches(e) && altarOption == hotkeyOccultAltarSwap) {
				hotkeyOccultAltarSwap = null;
				break;
			}
		}

		for (TreeRingSwap treeRingSwap : TreeRingSwap.values()) {
			if ((treeRingSwap.getKeybind(config, keybindCache)).matches(e) && treeRingSwap == hotkeyTreeRingSwap) {
				hotkeyTreeRingSwap = null;
				break;
			}
		}

		for (MaxCapeSwap maxCapeSwap : MaxCapeSwap.values()) {
			if ((maxCapeSwap.getKeybind(config, keybindCache)).matches(e) && maxCapeSwap == hotkeyMaxCapeSwap) {
				hotkeyMaxCapeSwap = null;
				break;
			}
		}

		for (BookOfTheDeadSwap botdSwap : BookOfTheDeadSwap.values()) {
			if ((botdSwap.getKeybind(config, keybindCache)).matches(e) && botdSwap == hotkeyBOTDSwap) {
				hotkeyBOTDSwap = null;
				break;
			}
		}

		for (PortalNexusSwap option : PortalNexusSwap.values()) {
			if ((option.getKeybind(config, keybindCache)).matches(e) && option == swapPortalNexus) {
				swapPortalNexus = null;
				break;
			}
		}

		for (PortalNexusXericsTalismanSwap option : PortalNexusXericsTalismanSwap.values()) {
			if ((option.getKeybind(config, keybindCache)).matches(e) && option == swapPortalNexusXericsTalisman) {
				swapPortalNexusXericsTalisman = null;
				break;
			}
		}

		for (PortalNexusDigsitePendantSwap option : PortalNexusDigsitePendantSwap.values()) {
			if ((option.getKeybind(config, keybindCache)).matches(e) && option == swapPortalNexusDigsitePendant) {
				swapPortalNexusDigsitePendant = null;
				break;
			}
		}

		if (config.getSwapUseHotkey().matches(e)) {
			swapUse = false;
		}

		if (config.getSwapJewelleryBoxHotkey().matches(e)) {
			swapJewelleryBox = false;
		}
	}

	@Subscribe
	public void onFocusChanged(FocusChanged event)
	{
		if (!event.isFocused())
		{
			resetHotkeys();
		}
	}

	private void resetHotkeys()
	{
		currentBankModeSwap = BankSwapMode.OFF;
		currentNonBankModeSwap = BankSwapMode.OFF;
		hotkeyOccultAltarSwap = null;
		hotkeyTreeRingSwap = null;
		hotkeyMaxCapeSwap = null;
		hotkeyBOTDSwap = null;
		hotkeys = 0;
		swapUse = false;
		swapJewelleryBox = false;
		swapPortalNexus = null;
		swapPortalNexusXericsTalisman = null;
		swapPortalNexusDigsitePendant = null;
	}

	// Copy-pasted from the official runelite menu entry swapper plugin, with some modification.
	private boolean swapBank(MenuEntry menuEntry, BankSwapMode mode)
	{
		MenuAction type = menuEntry.getType();
		if (type != CC_OP && type != CC_OP_LOW_PRIORITY)
		{
			return false;
		}

		final int widgetGroupId = WidgetUtil.componentToInterface(menuEntry.getParam1());
		final boolean isDepositBoxPlayerInventory = widgetGroupId == InterfaceID.DEPOSIT_BOX;
		final boolean isChambersOfXericStorageUnitPlayerInventory = widgetGroupId == InterfaceID.CHAMBERS_OF_XERIC_INVENTORY;
		final boolean isGroupStoragePlayerInventory = widgetGroupId == InterfaceID.GROUP_STORAGE_INVENTORY;
		final boolean isPriceChecker = widgetGroupId == InterfaceID.GUIDE_PRICES_INVENTORY || widgetGroupId == InterfaceID.GUIDE_PRICES;
		// Deposit- op 1 is the current withdraw amount 1/5/10/x for deposit box interface and chambers of xeric storage unit.
		// Deposit- op 2 is the current withdraw amount 1/5/10/x for bank interface
		if (
			mode != BankSwapMode.SWAP_ALL_BUT_1
			&& (menuEntry.getOption().startsWith("Deposit-")
					|| menuEntry.getOption().startsWith("Store")
					|| menuEntry.getOption().startsWith("Donate")
					|| menuEntry.getOption().endsWith("-slot")
					|| (isPriceChecker && menuEntry.getOption().startsWith("Add")))
		) {
			final int opId = isDepositBoxPlayerInventory ? mode.getDepositIdentifierDepositBox()
				: isChambersOfXericStorageUnitPlayerInventory ? mode.getDepositIdentifierChambersStorageUnit()
				: isGroupStoragePlayerInventory ? mode.getDepositIdentifierGroupStorage()
				: widgetGroupId == InterfaceID.SEED_VAULT_INVENTORY ? mode.getIdentifierSeedVault()
				: isPriceChecker ? mode.getPriceCheckerIdentifier()
				: mode.getDepositIdentifier();
			bankModeSwap(opId);
			return true;
		}

		// Deposit- op 1 is the current withdraw amount 1/5/10/x
		if (mode != BankSwapMode.SWAP_EXTRA_OP) {
			int opId = -1;
			if (menuEntry.getOption().startsWith("Withdraw")) {
				if (widgetGroupId == InterfaceID.CHAMBERS_OF_XERIC_STORAGE_UNIT_PRIVATE || widgetGroupId == InterfaceID.CHAMBERS_OF_XERIC_STORAGE_UNIT_SHARED) {
					opId = mode.getWithdrawIdentifierChambersStorageUnit();
				} else if (widgetGroupId == InterfaceID.SEED_VAULT) {
					opId = mode.getIdentifierSeedVault();
				} else if (widgetGroupId == InterfaceID.BANK || widgetGroupId == InterfaceID.GROUP_STORAGE) {
					opId = mode.getWithdrawIdentifier();
				}
			} else if (isPriceChecker && menuEntry.getOption().startsWith("Remove")) {
				opId = mode.getPriceCheckerIdentifier();
			}

			if (opId != -1)
			{
				bankModeSwap(opId);
				return true;
			}
		}

		return false;
	}

	// Copy-pasted from the official runelite menu entry swapper plugin.
	private void bankModeSwap(int entryIdentifier)
	{
		MenuEntry[] menuEntries = client.getMenuEntries();

		for (int i = menuEntries.length - 1; i >= 0; --i)
		{
			MenuEntry entry = menuEntries[i];

			if (entry.getIdentifier() == entryIdentifier)
			{
				// Raise the priority of the op so it doesn't get sorted later
				entry.setType(CC_OP);

				menuEntries[i] = menuEntries[menuEntries.length - 1];
				menuEntries[menuEntries.length - 1] = entry;

				client.setMenuEntries(menuEntries);
				break;
			}
		}
	}

	// Copy-pasted from the official runelite menu entry swapper plugin.
	private final Multimap<String, Swap> swaps = LinkedHashMultimap.create();
	private final ArrayListMultimap<String, Integer> optionIndexes = ArrayListMultimap.create();

	@Subscribe(priority = -1) // This will run after the normal menu entry swapper, so it won't interfere with that plugin.
	public void onMenuOpened(MenuOpened e) {
		if (!examineCancelLateRemoval) return;

		MenuEntry[] menuEntries = filterEntries(client.getMenuEntries(), true);
		client.setMenuEntries(menuEntries);
	}

	private String[] groundItemSortNames = new String[0];
	private MatchType[] groundItemSortTypes = new MatchType[0];
	private int[] groundItemSortValues = new int[0];
	private Boolean[] groundItemSortNoted = new Boolean[0];
	private Integer highlightedItemValue = null;
	private Integer hiddenItemValue = null;
	private GroundItemPriceSortMode groundItemsPriceSortMode = DISABLED;

	private void reloadGroundItemSort() {
		String s = config.groundItemSortCustomValues();
		List<String> groundItemSortNames = new ArrayList<>();
		List<MatchType> groundItemSortTypes = new ArrayList<>();
		List<Integer> groundItemSortValues = new ArrayList<>();
		List<Boolean> groundItemSortNoted = new ArrayList<>();
		highlightedItemValue = null;
		hiddenItemValue = null;
		groundItemsPriceSortMode = config.groundItemsPriceSortMode();
		int defaultValue = Integer.MAX_VALUE;
		for (String line : s.split("\n"))
		{
			if (line.trim().equals("")) continue;
			String[] split = line.split(",");
			if (split.length > 2) {
				// TODO chat mesage.
				continue;
			}

			int value = defaultValue;
			if (split.length > 1)
			{
				try
				{
					value = Integer.parseInt(split[1].trim());
				} catch (NumberFormatException e) {
					value = 0;
				}
			} else {
				defaultValue--;
			}

			String itemWildcard = split[0].trim().toLowerCase();
			if (itemWildcard.equals("###highlighted###") || itemWildcard.equals("###highlight###")) {
				highlightedItemValue = value;
				continue;
			} else if (itemWildcard.equals("###hidden###")) {
				hiddenItemValue = value;
				continue;
			}

			Boolean noted = null;
			if (itemWildcard.startsWith("unnoted:")) {
				noted = Boolean.FALSE;
				itemWildcard = itemWildcard.substring(itemWildcard.indexOf(':') + 1);
			}
			else if (itemWildcard.startsWith("noted:") || itemWildcard.startsWith("note:")) {
				noted = Boolean.TRUE;
				itemWildcard = itemWildcard.substring(itemWildcard.indexOf(':') + 1);
			}

			MatchType type = MatchType.getType(itemWildcard);
			String matchString = MatchType.prepareMatch(itemWildcard, type);
			groundItemSortNames.add(matchString);
			groundItemSortTypes.add(type);
			groundItemSortValues.add(value);
			groundItemSortNoted.add(noted);
//			System.out.println(matchString + " " + value + " " + noted + " " + type);
		}
		this.groundItemSortNames = groundItemSortNames.toArray(new String[groundItemSortNames.size()]);
		this.groundItemSortTypes = groundItemSortTypes.toArray(new MatchType[groundItemSortTypes.size()]);
		this.groundItemSortValues = groundItemSortValues.stream().mapToInt(i -> i).toArray();
		this.groundItemSortNoted = groundItemSortNoted.toArray(new Boolean[groundItemSortNoted.size()]);

		groundItemsStuff.reloadGroundItemPluginLists(groundItemsPriceSortMode != DISABLED, highlightedItemValue != null, hiddenItemValue != null, false);
	}

	@Subscribe(priority = -1) // This will run after the normal menu entry swapper, so it won't interfere with this plugin.
	public void onPostMenuSort(PostMenuSort e)
	{
		sortGroundItems();
		customSwaps();

		MenuEntry[] menuEntries = client.getMenuEntries();

		if (menuEntries.length == 0) return;

		spellbookSwapSwaps(menuEntries);

		mesPluginStyleSwaps(menuEntries);
	}

	private void mesPluginStyleSwaps(MenuEntry[] menuEntries)
	{
		// Build option map for quick lookup in findIndex
		int idx = 0;
		optionIndexes.clear();
		for (MenuEntry entry : menuEntries)
		{
			String option = Text.removeTags(entry.getOption()).toLowerCase();
			optionIndexes.put(option, idx++);
		}

		boolean bankOpen = client.getWidget(ComponentID.BANK_CONTAINER) != null;
		BankSwapMode mode = bankOpen ? currentBankModeSwap : currentNonBankModeSwap;
		if (mode != BankSwapMode.OFF)
		{
			for (int i = menuEntries.length - 1; i >= 0; i--)
			{
				if (swapBank(menuEntries[i], mode)) return;
			}
		}

		// Perform swaps
		for (int i = 0; i < menuEntries.length; i++)
		{
			swapMenuEntry(menuEntries, i);
		}
	}

	@RequiredArgsConstructor
	private static class MenuEntryWithValue {
		private final MenuEntry entry;
		private final int value;
	}

	private void sortGroundItems()
	{
		if (groundItemsPriceSortMode == DISABLED && groundItemSortTypes.length == 0 && highlightedItemValue == null && hiddenItemValue == null) return;

		// find a group of contiguous ground items while recording the value of each entry, then sort the block of ground items.
		MenuEntry[] menuEntries = client.getMenuEntries();
		int groundItemBlockStart = -1;
		List<MenuEntryWithValue> groundItemEntries = new ArrayList<>(menuEntries.length);
		nextMenuEntry:
		for (int i = 0; i < menuEntries.length; i++)
		{
			MenuEntry menuEntry = menuEntries[i];

			// menu entry is not a ground item menu entry. This may be the end of a take menu entry block, so sort any take menu entries that have been collected so far.
			if (menuEntry.getType().getId() < WIDGET_TARGET_ON_GROUND_ITEM.getId() || menuEntry.getType().getId() > GROUND_ITEM_FIFTH_OPTION.getId()) {
				if (groundItemBlockStart != -1) {
					groundItemEntries.sort(Comparator.comparingInt(e -> e.value));
					for (int j = 0; j < groundItemEntries.size(); j++) {
						menuEntries[groundItemBlockStart + j] = groundItemEntries.get(j).entry;
					}
					groundItemEntries.clear();
					groundItemBlockStart = -1;
				}
				continue nextMenuEntry;
			}

			// menu entry is a ground item menu entry
			if (groundItemBlockStart == -1) groundItemBlockStart = i;

			groundItemEntries.add(new MenuEntryWithValue(menuEntry, getValue(menuEntry)));
		}
		if (groundItemBlockStart != -1) {
			groundItemEntries.sort(Comparator.comparingInt(e -> e.value));
			for (int j = 0; j < groundItemEntries.size(); j++) {
				// log.debug("Sorted ground item: {} with value {}", itemManager.getItemComposition(groundItemEntries.get(j).entry.getIdentifier()).getName(), groundItemEntries.get(j).value);
				menuEntries[groundItemBlockStart + j] = groundItemEntries.get(j).entry;
			}
		}
		client.setMenuEntries(menuEntries);
	}

	private int getValue(MenuEntry menuEntry)
	{
		int itemId = menuEntry.getIdentifier();
		ItemComposition itemComposition = itemManager.getItemComposition(itemId);
		String itemName = itemComposition.getName().toLowerCase();
//		System.out.println("\t" + "a ground item " + itemName + " " + menuEntry.getItemId() + " " + menuEntry.getIdentifier() + " " + menuEntry.getParam1() + " " + menuEntry.getParam0());
		for (int j = 0; j < groundItemSortTypes.length; j++)
		{
			if (groundItemSortTypes[j].matches(itemName, groundItemSortNames[j])) {
				if (groundItemSortNoted[j] != null) {
					boolean noted = itemComposition.getNote() == 799;
					if (noted ^ groundItemSortNoted[j]) continue;
				}
				// log.debug("Adding ground item " + itemName + " to the list with custom? value " + groundItemSortValues[j] + " " + groundItemSortTypes[j]);
				return groundItemSortValues[j];
			}
		}
		GroundItem groundItem = getGroundItemFromScene(menuEntry);
		if (highlightedItemValue != null || hiddenItemValue != null) {
			NamedQuantity key = new NamedQuantity(groundItem.getName(), groundItem.getQuantity());
			if (highlightedItemValue != null && groundItemsStuff.highlightedItems.getUnchecked(key) == Boolean.TRUE) {
				// log.debug("Adding ground item " + itemName + " to the list with highlighted value " + highlightedItemValue);
				return highlightedItemValue;
			}
			if (hiddenItemValue != null && groundItemsStuff.hiddenItems.getUnchecked(key) == Boolean.TRUE) {
				// log.debug("Adding ground item " + itemName + " to the list with hidden value " + hiddenItemValue);
				return hiddenItemValue;
			}
		}
		if (groundItemsPriceSortMode != DISABLED) {
			// log.debug("Adding ground item {}x {} to the list with {} value {} max({},{})", groundItem.getQuantity(), itemName, groundItemsPriceSortMode.toString(), groundItemsPriceSortMode.getItemPrice(groundItem), groundItem.getGePrice(), groundItem.getHaPrice());
			return groundItemsPriceSortMode.getItemPrice(groundItem);
		}
		return 0;
	}

	private GroundItem getGroundItemFromScene(MenuEntry menuEntry) {
		int sceneX = menuEntry.getParam0();
		int sceneY = menuEntry.getParam1();
		final WorldPoint worldPoint = WorldPoint.fromScene(client, sceneX, sceneY, client.getPlane());
		int itemId = menuEntry.getIdentifier();
		GroundItem groundItem = groundItemsStuff.collectedGroundItems.get(worldPoint, itemId);
		// log.debug("[Ground Item Menu Entry] Scene ({}, {}, {}) at WorldPoint {} | Item: {}", sceneX, sceneY, client.getPlane(), worldPoint, groundItem);
		return groundItem;
	}

	// Copy-pasted from the official runelite menu entry swapper plugin.
	@Value
	class Swap
	{
		private Predicate<String> optionPredicate;
		private Predicate<String> targetPredicate;
		private String swappedOption;
		private Supplier<Boolean> enabled;
		private boolean strict;
	}

	/*
	 * Note to self: The way the menu entry swapper does most swaps is that it looks through the menu from bottom (0) to top (menuEntries.length) until it find the option to swap *with* (i.e. the top option e.g. "talk-to"), then it goes back in the menu to find the most recent menuentry that matches the criteria of the *swapped* option (e.g. "teleport").
	 */

	// Copy-pasted from the official runelite menu entry swapper plugin, with some modification.
	private void swapMenuEntry(MenuEntry[] menuEntries, int index)
	{
		MenuEntry menuEntry = menuEntries[index];
		String option = Text.removeTags(menuEntry.getOption()).toLowerCase();
		String target = Text.removeTags(menuEntry.getTarget()).toLowerCase();
		MenuAction menuAction = menuEntry.getType();

		if (menuAction == WIDGET_TARGET)
		{
			if (swapUse && option.equals("use"))
			{
				swap(optionIndexes, menuEntries, index, menuEntries.length - 1);
			}
			return;
		}

		if (target.equals("portal nexus") && swapPortalNexus != null) {
			boolean vanillaMesSwapEnabled = vanillaPortalNexusSwapEnabled();
			boolean hasLeftClickTeleportConfigured = menuEntry.getIdentifier() < 33408 || menuEntry.getIdentifier() > 33410;
			boolean destinationIsLeftClick = !vanillaMesSwapEnabled && hasLeftClickTeleportConfigured;
			if (destinationIsLeftClick && menuAction == MenuAction.GAME_OBJECT_FIRST_OPTION)
			{
				swap(swapPortalNexus.menuAction, target, index);
				return;
			} else if (!destinationIsLeftClick && menuAction == MenuAction.GAME_OBJECT_SECOND_OPTION) {
				swap(swapPortalNexus.menuAction, target, index);
				return;
			}
		}

		if (target.equals("xeric's talisman")) {
			PortalNexusXericsTalismanSwap portalNexusXericsTalismanSwap = getPortalNexusXericsTalismanSwap();
			if (portalNexusXericsTalismanSwap != null)
			{
				// https://chisel.weirdgloop.org/moid/object_name.html#/xeric's%20talisman/
				boolean hasLeftClickTeleportConfigured = menuEntry.getIdentifier() != 33419;
				if (hasLeftClickTeleportConfigured && menuAction == MenuAction.GAME_OBJECT_FIRST_OPTION)
				{
					swap(portalNexusXericsTalismanSwap.menuAction, target, index);
					return;
				}
				else if (!hasLeftClickTeleportConfigured && menuAction == MenuAction.GAME_OBJECT_SECOND_OPTION)
				{
					swap(portalNexusXericsTalismanSwap.menuAction, target, index);
					return;
				}
			}
		}

		if (target.equals("digsite pendant")) {
			PortalNexusDigsitePendantSwap portalNexusDigsitePendantSwap = getPortalNexusDigsitePendantSwap();
			if (portalNexusDigsitePendantSwap != null)
			{
				// https://chisel.weirdgloop.org/moid/object_name.html#/digsite%20pendant/
				boolean hasLeftClickTeleportConfigured = menuEntry.getIdentifier() != 33420;
				if (hasLeftClickTeleportConfigured && menuAction == MenuAction.GAME_OBJECT_FIRST_OPTION)
				{
					swap(portalNexusDigsitePendantSwap.menuAction, target, index);
					return;
				}
				else if (!hasLeftClickTeleportConfigured && menuAction == MenuAction.GAME_OBJECT_SECOND_OPTION)
				{
					swap(portalNexusDigsitePendantSwap.menuAction, target, index);
					return;
				}
			}
		}

		if (menuAction == MenuAction.GAME_OBJECT_SECOND_OPTION && target.endsWith("jewellery box") && swapJewelleryBoxSpecificOption()) { // second option is teleport menu
			swap(MenuAction.GAME_OBJECT_THIRD_OPTION, target, index);
			return;
		} else if (menuAction == MenuAction.GAME_OBJECT_THIRD_OPTION && target.endsWith("jewellery box") && swapJewelleryBoxTeleportMenuOption()) { // third option is the specific option (e.g. "Edgeville")
			swap(MenuAction.GAME_OBJECT_SECOND_OPTION, target, index);
			return;
		}

		// disgusting. But there isn't an easy way to implement some kind of custom predicate function or regex for the menu entry option without rewriting a lot of code.
		if (target.equals("fairy ring") || target.equals("spiritual fairy tree")) {
			if (option.startsWith("ring-")) {
				option = option.substring("ring-".length());
			}
			if (option.startsWith("last-destination")) {
				option = "last-destination";
			}
		}

		Collection<Swap> swaps = this.swaps.get(option);
		for (Swap swap : swaps)
		{
			if (swap.getTargetPredicate().test(target) && swap.getEnabled().get())
			{
				if (swap(swap.getSwappedOption(), target, index, swap.isStrict()))
				{
					break;
				}
			}
		}
	}

	private void spellbookSwapSwaps(MenuEntry[] menuEntries)
	{
		MenuEntry topMenuEntry = menuEntries[menuEntries.length - 1];
		Widget widget = topMenuEntry.getWidget();
		if (widget == null) return;
		int spriteId = widget.getSpriteId();
		// The disabled icon is also necessary since it's possible to cast the spell even when the icon is disabled, if you will be able to cast it on the next tick.
		if ((spriteId != 582 && spriteId != 632) || !config.swapSpellbookSwap()) return;

		OccultAltarSwap currentSwap = this.hotkeyOccultAltarSwap;
		if (currentSwap != null) {
			for (int i = menuEntries.length - 1; i >= 0; i--) {
				if (currentSwap.getSpellbookSwapMenuOptionName().equals(menuEntries[i].getOption())) {
					MenuEntry temp = menuEntries[i];
					menuEntries[i] = menuEntries[menuEntries.length - 1];
					menuEntries[menuEntries.length - 1] = temp;
					client.setMenuEntries(menuEntries);
					return;
				}
			}
		}
	}

	// Copy-pasted from the official runelite menu entry swapper plugin.
	private void swap(String option, Predicate<String> targetPredicate, String swappedOption, Supplier<Boolean> enabled)
	{
		swaps.put(option, new Swap(alwaysTrue(), targetPredicate, swappedOption, enabled, true));
	}

	// Copy-pasted from the official runelite menu entry swapper plugin.
	private boolean swap(String option, String target, int index, boolean strict)
	{
		MenuEntry[] menuEntries = client.getMenuEntries();

		// find option to swap with
		int optionIdx = findIndex(menuEntries, index, option, target, strict);

		if (optionIdx >= 0)
		{
			swap(optionIndexes, menuEntries, optionIdx, index);
			return true;
		}

		return false;
	}

	private boolean swap(MenuAction menuAction, String target, int index)
	{
		MenuEntry[] menuEntries = client.getMenuEntries();

		// find option to swap with
		int optionIdx = findIndex(menuEntries, index, menuAction, target);

		if (optionIdx >= 0)
		{
			swap(optionIndexes, menuEntries, optionIdx, index);
			return true;
		}

		return false;
	}

	private int findIndex(MenuEntry[] entries, int limit, MenuAction menuAction, String target)
	{
		// We want the last index which matches the target, as that is what is top-most
		// on the menu
		for (int i = limit - 1; i >= 0; --i)
		{
			MenuEntry entry = entries[i];

			if (entry.getType() != menuAction) continue;

			String entryTarget = Text.removeTags(entry.getTarget()).toLowerCase();
			if (entryTarget.equals(target))
			{
				return i;
			}
		}

		return -1;
	}

	// Copy-pasted from the official runelite menu entry swapper plugin.
	private int findIndex(MenuEntry[] entries, int limit, String option, String target, boolean strict)
	{
		if (strict)
		{
			List<Integer> indexes = optionIndexes.get(option.toLowerCase());

			// We want the last index which matches the target, as that is what is top-most
			// on the menu
			for (int i = indexes.size() - 1; i >= 0; --i)
			{
				int idx = indexes.get(i);
				MenuEntry entry = entries[idx];
				String entryTarget = Text.removeTags(entry.getTarget()).toLowerCase();

				// Limit to the last index which is prior to the current entry
				if (idx < limit && entryTarget.equals(target))
				{
					return idx;
				}
			}
		}
		else
		{
			// Without strict matching we have to iterate all entries up to the current limit...
			for (int i = limit - 1; i >= 0; i--)
			{
				MenuEntry entry = entries[i];
				String entryOption = Text.removeTags(entry.getOption()).toLowerCase();
				String entryTarget = Text.removeTags(entry.getTarget()).toLowerCase();

				if (entryOption.contains(option.toLowerCase()) && entryTarget.equals(target))
				{
					return i;
				}
			}

		}

		return -1;
	}

	// Copy-pasted from the official runelite menu entry swapper plugin.
	private void swap(ArrayListMultimap<String, Integer> optionIndexes, MenuEntry[] entries, int index1, int index2)
	{
		MenuEntry entry1 = entries[index1],
				entry2 = entries[index2];

		entries[index1] = entry2;
		entries[index2] = entry1;

		client.setMenuEntries(entries);

		// Update optionIndexes
		String option1 = Text.removeTags(entry1.getOption()).toLowerCase(),
				option2 = Text.removeTags(entry2.getOption()).toLowerCase();

		List<Integer> list1 = optionIndexes.get(option1),
				list2 = optionIndexes.get(option2);

		// call remove(Object) instead of remove(int)
		list1.remove((Integer) index1);
		list2.remove((Integer) index2);

		sortedInsert(list1, index2);
		sortedInsert(list2, index1);
	}

	// Copy-pasted from the official runelite menu entry swapper plugin.
	private static <T extends Comparable<? super T>> void sortedInsert(List<T> list, T value) // NOPMD: UnusedPrivateMethod: false positive
	{
		int idx = Collections.binarySearch(list, value);
		list.add(idx < 0 ? -idx - 1 : idx, value);
	}

	// Copy-pasted from the official runelite menu entry swapper plugin.
	private void swapContains(String option, Predicate<String> targetPredicate, String swappedOption, Supplier<Boolean> enabled)
	{
		swaps.put(option, new Swap(alwaysTrue(), targetPredicate, swappedOption, enabled, false));
	}

	@Getter
	@ToString
	@RequiredArgsConstructor
	@EqualsAndHashCode
	static class CustomSwap
	{
		private final String option;
		private final String target;
		private final String topOption;
		private final String topTarget;

		private final MatchType optionType;
		private final MatchType targetType;
		private final MatchType topOptionType;
		private final MatchType topTargetType;

		public static CustomSwap fromString(String s)
		{
			String[] split = s.split(",");
			return new CustomSwap(
				split[0].toLowerCase().trim(),
				split.length > 1 ? split[1].toLowerCase().trim() : "",
				split.length > 2 ? split[2].toLowerCase().trim() : null,
				split.length > 3 ? split[3].toLowerCase().trim() : null
			);
		}

		CustomSwap(String option, String target)
		{
			this(option, target, null, null);
		}

		CustomSwap(String option, String target, String topOption, String topTarget)
		{
			this.optionType = MatchType.getType(option);
			this.option = MatchType.prepareMatch(option, optionType);
			this.targetType = MatchType.getType(target);
			this.target = MatchType.prepareMatch(target, targetType);
			this.topOptionType = MatchType.getType(topOption);
			this.topOption = MatchType.prepareMatch(topOption, topOptionType);
			this.topTargetType = MatchType.getType(topTarget);
			this.topTarget = MatchType.prepareMatch(topTarget, topTargetType);
//			System.out.println("types for " + option + " " + target + " "+ topOption + " " + topTarget + " " + optionType + " " + targetType + " " + topOptionType + " " + topTargetType);
		}

		/** skip top option comparison, for testing */
		boolean matches(String option, String target)
		{
			return matches(option, target, "", "");
		}

		public boolean matches(String option, String target, String topOption, String topTarget)
		{
			return optionType.matches(option, this.option) &&
				targetType.matches(target, this.target) &&
				topOptionType.matches(topOption, this.topOption) &&
				topTargetType.matches(topTarget, this.topTarget);
		}

		public boolean matches(String option, String target, String topOption, String topTarget, MenuIterator iter)
		{
			boolean targetMatches = targetType.matches(target, this.target);
			// Allows the more intuitive syntax `Crafting guild,Max cape` instead of the unintuitive `Crafting guild,,*,Max cape`.
			// Also keeps compatibility with config users created before the jan 22 2025 submenu change.
			if (!targetMatches && iter.inSubmenu() && target.isEmpty()) {
				// I want to check everything else first to avoid wasting time on Text.standardize.
				boolean everythingElseMatches = optionType.matches(option, this.option) &&
					topOptionType.matches(topOption, this.topOption) &&
					topTargetType.matches(topTarget, this.topTarget);
				if (!everythingElseMatches) return false;
				target = Text.standardize(iter.getMenuEntries()[iter.getIndex()].getTarget());
				return targetType.matches(target, this.target);
			} else {
				return targetMatches &&
					optionType.matches(option, this.option) &&
					topOptionType.matches(topOption, this.topOption) &&
					topTargetType.matches(topTarget, this.topTarget);
			}
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged) {
		if (configChanged.getGroup().equals("hotkeyablemenuswaps")) {
			keybindCache.clear();
			reloadCustomSwaps();
			reloadGroundItemSort();
			examineCancelLateRemoval = config.examineCancelLateRemoval();
		} else if (configChanged.getGroup().equals("grounditems") && (configChanged.getKey().equals("highlightedItems") || configChanged.getKey().equals("hiddenItems"))) {
			groundItemsStuff.reloadGroundItemPluginLists(groundItemsPriceSortMode != DISABLED, highlightedItemValue != null, hiddenItemValue != null, true);
		}
	}

	private void reloadCustomSwaps()
	{
		customSwaps.clear();
		customSwaps.addAll(loadCustomSwaps(config.customSwaps()));

		customSwapKeybinds.clear();
		for (int i = 0; i < HOTKEY_COUNT; i++)
		{
			customSwapKeybinds.add(configManager.getConfiguration("hotkeyablemenuswaps", "hotkey" + (i + 1), Keybind.class));
			customHotkeySwaps[i] = new ArrayList<>();
			customHotkeySwaps[i].addAll(loadCustomSwaps(configManager.getConfiguration("hotkeyablemenuswaps", "hotkey" + (i + 1) + "Swaps", String.class)));
		}

		customShiftSwaps.clear();
		customShiftSwaps.addAll(loadCustomSwaps(config.customShiftSwaps()));

		customHides.clear();
		customHides.addAll(loadCustomSwaps(config.customHides()));
	}

	private Collection<? extends CustomSwap> loadCustomSwaps(String customSwaps)
	{
		if (customSwaps == null) return Collections.emptyList();
		List<CustomSwap> swaps = new ArrayList<>();
		for (String customSwap : customSwaps.split("\n"))
		{
			if (customSwap.trim().equals("")) continue;
			swaps.add(CustomSwap.fromString(customSwap));
		}
		return swaps;
	}

	private boolean shiftModifier()
	{
		return client.isKeyPressed(KeyCode.KC_SHIFT);
	}

	public void customSwaps()
	{
		MenuEntry[] menuEntries = client.getMenuEntries();
		if (menuEntries.length == 0) return;

		menuEntries = filterEntries(menuEntries, false);
		client.setMenuEntries(menuEntries);
		int topEntryIndex = menuEntries.length - 1;
		if (topEntryIndex == -1) { // The filtering removed all the menu options. No swaps can happen, so return early.
			return;
		}
		MenuEntry topEntry = menuEntries[topEntryIndex];
		if (mayNotBeLeftClick(topEntry)) {
			return;
		}

		List<CustomSwap> swaps = shiftModifier() ? customShiftSwaps : customSwaps;
		if (hotkeys > 0)
		{
			List<CustomSwap> temp = swaps;
			swaps = new ArrayList<>();
			swaps.addAll(temp);
			for (int i = 0; i < HOTKEY_COUNT; i++)
			{
				if ((hotkeys & (1L << i)) > 0)
				{
					swaps.addAll(customHotkeySwaps[i]);
				}
			}
		}
		var p = getEntryIndexToSwap(menuEntries, swaps);
		int index = p.getLeft();
		int submenuIndex = p.getRight();
		if (index >= 0)
		{
			MenuEntry entryToSwap = submenuIndex != -1
				? menuEntries[index].getSubMenu().getMenuEntries()[submenuIndex]
				: menuEntries[index];
			if (isProtected(topEntry) || isProtected(entryToSwap)) {
				return;
			}

			boolean doNotSwapOverMinimapOrbs = topEntry.getWidget() != null && WidgetUtil.componentToInterface(topEntry.getWidget().getId()) == 160 && entryToSwap.getWidget() == null && config.doNotSwapOverMinimapOrbs();
			if (!doNotSwapOverMinimapOrbs && (topEntryIndex > index || submenuIndex != -1)) {
				// the client will open the right-click menu on left-click if the entry at the top is a CC_OP_LOW_PRIORITY.
				if (entryToSwap.getType() == MenuAction.CC_OP_LOW_PRIORITY)
				{
					entryToSwap.setType(CC_OP);
				}

				if (submenuIndex != -1) {
//					Menu submenu = menuEntries[index].getSubMenu();
//					MenuEntry[] entries = submenu.getMenuEntries();
//					entryToSwap = entries[submenuIndex];
//					entries[submenuIndex] = topEntry;
//					submenu.setMenuEntries(entries);
					client.getMenu()
						.createMenuEntry(-1)
						.setIdentifier(entryToSwap.getIdentifier())
						.setOption(entryToSwap.getOption())
						.setTarget(entryToSwap.getTarget())
						.setParam0(entryToSwap.getParam0())
						.setParam1(entryToSwap.getParam1())
						.setItemId(entryToSwap.getItemId())
						.setType(entryToSwap.getType())
						.setWorldViewId(entryToSwap.getWorldViewId())
						.onClick(entryToSwap.onClick());
				} else {
					menuEntries[index] = topEntry;
					menuEntries[topEntryIndex] = entryToSwap;
					client.setMenuEntries(menuEntries);
				}
			}
		}
	}

	private interface MenuIterator extends Iterator<MenuEntry> {
		MenuEntry[] getMenuEntries();
		int getIndex();
		int getSubmenuIndex();
		default boolean inSubmenu() {
			return getSubmenuIndex() != -1;
		}
	}

	final static class ForwardsMenuIterator implements MenuIterator {
		Menu submenu = null;
		@Getter int index = -1;
		@Getter int submenuIndex = -1;
		int nextIndex = 0;
		int nextSubmenuIndex = -1;
		@Getter MenuEntry[] menuEntries;

		public ForwardsMenuIterator(MenuEntry[] menuEntries)
		{
			this.menuEntries = menuEntries;
		}

		@Override
		public boolean hasNext()
		{
			return nextIndex < menuEntries.length;
		}

		@Override
		public MenuEntry next()
		{
			index = nextIndex;
			submenuIndex = nextSubmenuIndex;
			MenuEntry entry = submenuIndex != -1 ? submenu.getMenuEntries()[submenuIndex] : menuEntries[index];
			if (submenuIndex == -1) submenu = entry.getSubMenu();

			if (submenu != null && submenuIndex + 1 < submenu.getMenuEntries().length) {
				nextSubmenuIndex++;
			} else if (submenu != null && submenuIndex == -1 && submenu.getMenuEntries().length > 0) {
				nextSubmenuIndex = 0;
			} else {
				nextIndex++;
				nextSubmenuIndex = -1;
			}
			return entry;
		}
//
//		public MenuEntry peek() {
//			return submenu != null ? submenu.getMenuEntries()[nextSubmenuIndex] : menuEntries[nextIndex];
//		}
	}

	final static class ReverseMenuIterator implements MenuIterator {
		List<MenuEntry> entries = new ArrayList<>();
		List<Integer> indexes = new ArrayList<>();
		List<Integer> submenuIndexes = new ArrayList<>();
		@Getter MenuEntry[] menuEntries;

		int i;
		@Getter int index;
		@Getter int submenuIndex;

		public ReverseMenuIterator(MenuEntry[] menuEntries) {
			ForwardsMenuIterator menuIterator = new ForwardsMenuIterator(menuEntries);
			while (menuIterator.hasNext()) {
				entries.add(menuIterator.next());
				indexes.add(menuIterator.index);
				submenuIndexes.add(menuIterator.submenuIndex);
			}
			i = entries.size() - 1;
			this.menuEntries = menuEntries;
		}

		@Override public boolean hasNext() {
			return i >= 0;
		}

		@Override public MenuEntry next() {
			MenuEntry entry = entries.get(i);
			index = indexes.get(i);
			submenuIndex = submenuIndexes.get(i);
			i--;
			return entry;
		}
	}

	private Pair<Integer, Integer> getEntryIndexToSwap(MenuEntry[] menuEntries, List<CustomSwap> swaps)
	{
		int latestMatchingSwapIndex = -1;
		MenuEntry topEntry = menuEntries[menuEntries.length - 1];
		String topEntryOption = Text.standardize(topEntry.getOption());
		String topEntryTarget = Text.standardize(topEntry.getTarget());
		boolean doNotSwapDeprioritizedTake = config.doNotSwapDeprioritizedGroundItems();
		boolean seenWalkHere = false;
		// prefer to swap menu entries that are already at or near the top of the list.
		int bestMenuEntryIndex = -1;
		int bestMenuEntrySubmenuIndex = -1;

//		if (client.getGameCycle() % 50 == 0) System.out.println("menu entries:");
		MenuIterator menuIterator = new ReverseMenuIterator(menuEntries);
		while (menuIterator.hasNext())
		{
			MenuEntry entry = menuIterator.next();
//			if (client.getGameCycle() % 50 == 0) System.out.println("\t" + menuIterator.index + " " + menuIterator.submenuIndex + " " + entry.getOption() + " " + entry.getTarget());

			if (doNotSwapDeprioritizedTake) {
				if (entry.getType() == MenuAction.WALK) {
					seenWalkHere = true;
				} else if (seenWalkHere && entry.getType().getId() >= WIDGET_TARGET_ON_GROUND_ITEM.getId() && entry.getType().getId() <= GROUND_ITEM_FIFTH_OPTION.getId()) {
					continue;
				}
			}

			String option = Text.standardize(entry.getOption());
			String target = Text.standardize(entry.getTarget());
			int swapIndex = matches(option, target, topEntryOption, topEntryTarget, swaps, menuIterator);
			if (swapIndex > latestMatchingSwapIndex)
			{
				bestMenuEntryIndex = menuIterator.getIndex();
				bestMenuEntrySubmenuIndex = menuIterator.getSubmenuIndex();

				latestMatchingSwapIndex = swapIndex;
//				if (client.getGameCycle() % 50 == 0) System.out.println("\t\tmatch found " + menuIterator.index + " " + menuIterator.submenuIndex);
			}
		}
		return Pair.of(bestMenuEntryIndex, bestMenuEntrySubmenuIndex);
	}

	private boolean isProtected(MenuEntry entry)
	{
		MenuAction type = entry.getType();
		if (type == WIDGET_TARGET_ON_PLAYER || type == WIDGET_TARGET_ON_NPC) {
			if (WidgetUtil.componentToInterface(client.getSelectedWidget().getId()) == InterfaceID.SPELLBOOK) {
				return true;
			}
		}
		if (mayNotBeLeftClick(entry)) {
			return true;
		}
		return false;
	}

	private boolean mayNotBeLeftClick(MenuEntry entry)
	{
		MenuAction type = entry.getType();
		if (type.getId() >= PLAYER_FIRST_OPTION.getId() && type.getId() <= PLAYER_EIGHTH_OPTION.getId()) {
			return true;
		}
		if (type == MenuAction.NPC_FOURTH_OPTION || type == MenuAction.NPC_FIFTH_OPTION) {
			if (entry.getNpc() != null) {
				String[] actions = entry.getNpc().getTransformedComposition().getActions();
				if ("Lure".equals(actions[3]) || "Knock-out".equals(actions[4])) {
					return true;
				}
			}
		}
		return false;
	}

	private MenuEntry[] filterEntries(MenuEntry[] menuEntries, boolean isInOnMenuOpened)
	{
		List<MenuEntry> filtered = new ArrayList<>();
		List<MenuEntry> submenuFiltered = new ArrayList<>();
		MenuEntry topEntry = menuEntries[menuEntries.length - 1];
		String topEntryOption = Text.standardize(topEntry.getOption());
		String topEntryTarget = Text.standardize(topEntry.getTarget());
		ForwardsMenuIterator menuIterator = new ForwardsMenuIterator(menuEntries);
		while (menuIterator.hasNext())
		{
//			if (client.getGameCycle() % 50 == 0) System.out.println(menuIterator.index + " " + menuIterator.nextIndex + " " + menuIterator.submenu);
			if (menuIterator.submenu != null && menuIterator.nextIndex != menuIterator.index) {
				menuIterator.submenu.setMenuEntries(submenuFiltered.toArray(new MenuEntry[0]));
				submenuFiltered.clear();
			}

			MenuEntry entry = menuIterator.next();
//			if (client.getGameCycle() % 50 == 0) System.out.println(entry.getOption());
			boolean isSubmenu = menuIterator.submenu != null && menuIterator.submenuIndex != -1;
			var entryList = isSubmenu ? submenuFiltered : filtered;
			// Skips applying custom hides to examine/cancel in PostMenuSwap, and to all other entries in MenuOpened.
			if (examineCancelLateRemoval) {
				boolean isExamineOrCancel = entry.getType() == MenuAction.CANCEL || entry.getOption().equals("Examine");

				if (isInOnMenuOpened ^ isExamineOrCancel)
				{
					entryList.add(entry);
					continue;
				}
			}

			String option = Text.standardize(entry.getOption());
			String target = Text.standardize(entry.getTarget());
			if (matches(option, target, topEntryOption, topEntryTarget, customHides, menuIterator) == -1 || isProtected(entry))
			{
				entryList.add(entry);
			}
		}
		if (menuIterator.submenu != null && menuIterator.nextIndex != menuIterator.index) {
			menuIterator.submenu.setMenuEntries(submenuFiltered.toArray(new MenuEntry[0]));
			submenuFiltered.clear();
		}
		return filtered.toArray(new MenuEntry[0]);
	}

	private static int matches(String entryOption, String entryTarget, String topEntryOption, String topEntryTarget, List<CustomSwap> swaps, MenuIterator iter)
	{
		for (int i = 0; i < swaps.size(); i++)
		{
			CustomSwap swap = swaps.get(i);
			if (swap.matches(entryOption, entryTarget, topEntryOption, topEntryTarget, iter)) {
				return i;
			}
		}
		return -1;
	}
}

package com.hotkeyablemenuswaps;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum GroundItemPriceSortMode
{
	DISABLED("Disabled")
		{
			@Override
			public Integer getItemPrice(GroundItemsStuff.GroundItem groundItem)
			{
				return groundItem.getHaPrice(); // Just in case,
			}
		},
	GE_PRICE("Grand Exchange")
		{
			@Override
			public Integer getItemPrice(GroundItemsStuff.GroundItem groundItem)
			{
				return groundItem.getGePrice();
			}
		},
	MAX_GE_OR_ALCH_PRICE("max(GE, High Alch)")
		{
			@Override
			public Integer getItemPrice(GroundItemsStuff.GroundItem groundItem)
			{
				return Math.max(groundItem.getGePrice(), groundItem.getHaPrice());
			}
		};

	private final String displayName; // For combo box.

	public abstract Integer getItemPrice(GroundItemsStuff.GroundItem groundItem);

	@Override
	public String toString()
	{
		return displayName;
	}

}

package com.hotkeyablemenuswaps;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.config.Keybind;

import java.util.function.Function;

@Getter
@RequiredArgsConstructor
enum BookOfTheDeadSwap implements HotkeyableMenuSwapsPlugin.hasKeybind {
    HOSIDIUS("lunch by the lancalliums", HotkeyableMenuSwapsConfig::botdHosidiusHotKey),
    PISCARILIUS("the fisher's flute", HotkeyableMenuSwapsConfig::botdPiscariliusHotKey),
    SHAYZEIN("history and hearsay", HotkeyableMenuSwapsConfig::botdShayzeinHotKey),
    LOVAKENGJ("jewellery of jubilation", HotkeyableMenuSwapsConfig::botdLovakengjHotKey),
    ARCEUUS("a dark disposition", HotkeyableMenuSwapsConfig::botdArceuusHotKey),
    ;

    private final String menuOptionName;
    private final Function<HotkeyableMenuSwapsConfig, Keybind> keybindFunction;

    public Keybind getKeybind(HotkeyableMenuSwapsConfig config) {
        return keybindFunction.apply(config);
    }
}

package com.hotkeyablemenuswaps;

import com.google.inject.Guice;
import com.google.inject.Inject;
import com.google.inject.testing.fieldbinder.Bind;
import com.google.inject.testing.fieldbinder.BoundFieldModule;
import com.hotkeyablemenuswaps.HotkeyableMenuSwapsPlugin.CustomSwap;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import static net.runelite.api.MenuAction.*;
import net.runelite.api.MenuEntry;
import net.runelite.api.NPC;
import net.runelite.api.NPCComposition;
import net.runelite.api.events.PostMenuSort;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.menuentryswapper.MenuEntrySwapperConfig;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class CustomSwapperTest
{
	@Inject
	HotkeyableMenuSwapsPlugin plugin;

	@Mock
	@Bind
	ConfigManager configManager;

	@Mock
	@Bind
	HotkeyableMenuSwapsConfig config;

	@Mock
	@Bind
	Client client;

	@Mock
	@Bind
	private KeyManager keyManager;

	@Mock
	@Bind
	private MenuEntrySwapperConfig menuEntrySwapperConfig;

	@Getter
	String customSwapConfig = "";

	@Getter
	String customShiftSwapConfig = "";

	@Getter
	String customHideConfig = "";

	void setConfig(String newSwapConfig, String newHideConfig) {
		setConfig(newSwapConfig, newHideConfig, "");
	}

	void setConfig(String newSwapConfig, String newHideConfig, String newShiftSwapConfig) {
		customSwapConfig = newSwapConfig;
		customHideConfig = newHideConfig;
		customShiftSwapConfig = newShiftSwapConfig;
		ConfigChanged configChanged = new ConfigChanged();
		configChanged.setGroup("hotkeyablemenuswaps");
		plugin.onConfigChanged(configChanged);
	}

	@Getter
	MenuEntry[] menuEntries = new MenuEntry[0];

	@Before
	public void setup() {
		Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);
		Mockito.when(config.customSwaps()).thenAnswer(a -> getCustomSwapConfig());
		Mockito.when(config.customHides()).thenAnswer(a -> getCustomHideConfig());
		Mockito.when(config.customShiftSwaps()).thenAnswer(a -> getCustomShiftSwapConfig());
		Mockito.when(client.getMenuEntries()).thenAnswer(a -> getMenuEntries());
//		Mockito.when(client.getGameState()).thenReturn(GameState.LOGGED_IN);
		Mockito.doAnswer(a -> {
			if ((int) a.getArgument(0) == 2176) {
				return 1;
			} else {
				throw new UnsupportedOperationException();
			}
		}).when(client).getVarbitValue(Mockito.anyInt());
//		Mockito.when(client.isMenuOpen()).thenReturn(false);
		Mockito.doAnswer(a -> {
			menuEntries = a.getArgument(0);
			return null;
		}).when(client).setMenuEntries(Mockito.any());
	}

	@Test
	public void testMatching() {
		Assert.assertTrue(customSwap("sell,sanguinesti*").matches("sell", "sanguinesti staff"));
		Assert.assertTrue(customSwap("sell,sanguinesti*").matches("sell", "sanguinesti staff (empty)"));
		Assert.assertTrue(customSwap("sell,sanguinesti*").matches("sell", "sanguinesti"));
		Assert.assertFalse(customSwap("sell,sanguinesti*").matches("sell", "A sanguinesti"));
		Assert.assertFalse(customSwap("sell,sanguinesti*").matches("sell", "sanguinest"));

		Assert.assertTrue(customSwap("sell,*******").matches("sell", "A sanguinesti"));
		Assert.assertTrue(customSwap("sell,*******").matches("sell", ""));

		Assert.assertTrue(customSwap("sell,***cat***dog***").matches("sell", "catdog"));
		Assert.assertTrue(customSwap("sell,***cat***dog***").matches("sell", "a cat with dog"));
		Assert.assertTrue(customSwap("sell,***cat***dog***").matches("sell", "a cat with dog "));
		Assert.assertTrue(customSwap("sell,*cat*dog*").matches("sell", "a cat with dog "));
		Assert.assertFalse(customSwap("sell,*cat*dog*").matches("sell", "fish"));

		Assert.assertTrue(customSwap("sell,*").matches("sell", "sanguinesti staff"));
		Assert.assertTrue(customSwap("sell,*").matches("sell", "twisted bow"));
		Assert.assertTrue(customSwap("sell,*").matches("sell", "mr mammal"));
		Assert.assertTrue(customSwap("sell,*").matches("sell", ""));

		Assert.assertTrue(customSwap("*,cow*").matches("attack", "cow (level-2)"));
		Assert.assertTrue(customSwap("*,cow*").matches("examine", "cow (level-2)"));
		Assert.assertFalse(customSwap("*,cow*").matches("examine", "goblin (level-2)"));

		Assert.assertTrue(customSwap("*,*(4)").matches("drink", "prayer potion (4)"));
		Assert.assertTrue(customSwap("*,*(4)").matches("drink", "(4)"));
		Assert.assertFalse(customSwap("*,*(4)").matches("drink", "prayer potion (3)"));

		Assert.assertTrue(customSwap("*,*potion*").matches("drink", "prayer potion (3)"));
		Assert.assertTrue(customSwap("*,*potion*").matches("drink", "super restore potion (4)"));
		Assert.assertFalse(customSwap("*,*potion*").matches("drink", "prayer pot (4)"));

		Assert.assertTrue(customSwap("*,PRAYER*(4)").matches("drink", "prayer potion (4)"));
		Assert.assertTrue(customSwap("*,PRAYER*(4)").matches("drink", "prayer pot (4)"));
		Assert.assertFalse(customSwap("*,PRAYER*(4)").matches("drink", "prayer pot (3)"));
		Assert.assertTrue(customSwap("*,PRAYER POTION (*)").matches("drink", "prayer potion (4)"));
		Assert.assertTrue(customSwap("*,PRAYER POTION (*)").matches("drink", "prayer potion (3)"));
		Assert.assertFalse(customSwap("*,PRAYER POTION (*)").matches("drink", "super restore potion (3)"));

		Assert.assertTrue(customSwap("walk here,").matches("walk here", ""));
		Assert.assertFalse(customSwap("walk here,").matches("walk here", "here"));
		Assert.assertTrue(customSwap("walk here").matches("walk here", ""));
		Assert.assertFalse(customSwap("walk here").matches("walk here", "here"));

		Assert.assertTrue(customSwap("take,*,attack,brutal black dragon*").matches("take", "big dragon bones", "attack", "brutal black dragon (level-100)"));
		Assert.assertTrue(customSwap("use,cannonball -> dwarf*").matches("use", "cannonball -> dwarf multicannon"));
	}

	private CustomSwap customSwap(String s)
	{
		return CustomSwap.fromString(s);
	}

	@Test
	public void testRemoveAllOptionsAboveOptionThatMayNotBeLeftClick() {
		setConfig("", "attack,*\nlure,*\npickpocket,*\ntalk-to,*");
		NPC menaphiteThug = generateNpc(new String[]{"Talk-to", "Attack", "Pickpocket", "Lure", "Knock-Out"});
		menuEntries = new MenuEntry[]{
			new TestMenuEntry().setOption("Cancel").setTarget("").setIdentifier(0).setType(CANCEL).setParam0(0).setParam1(0).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(null),
			new TestMenuEntry().setOption("Examine").setTarget("<col=ffff00>Menaphite Thug<col=ff00>  (level-55)").setIdentifier(14805).setType(EXAMINE_NPC).setParam0(0).setParam1(0).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(menaphiteThug),
			new TestMenuEntry().setOption("Walk here").setTarget("").setIdentifier(0).setType(WALK).setParam0(371).setParam1(142).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(null),
			new TestMenuEntry().setOption("Knock-Out").setTarget("<col=ffff00>Menaphite Thug<col=ff00>  (level-55)").setIdentifier(14805).setType(NPC_FIFTH_OPTION).setParam0(0).setParam1(0).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(menaphiteThug),
			new TestMenuEntry().setOption("Lure").setTarget("<col=ffff00>Menaphite Thug<col=ff00>  (level-55)").setIdentifier(14805).setType(NPC_FOURTH_OPTION).setParam0(0).setParam1(0).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(menaphiteThug),
			new TestMenuEntry().setOption("Pickpocket").setTarget("<col=ffff00>Menaphite Thug<col=ff00>  (level-55)").setIdentifier(14805).setType(NPC_THIRD_OPTION).setParam0(0).setParam1(0).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(menaphiteThug),
			new TestMenuEntry().setOption("Talk-to").setTarget("<col=ffff00>Menaphite Thug<col=ff00>  (level-55)").setIdentifier(14805).setType(NPC_FIRST_OPTION).setParam0(0).setParam1(0).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(menaphiteThug),
			new TestMenuEntry().setOption("Attack").setTarget("<col=ffff00>Menaphite Thug<col=ff00>  (level-55)").setIdentifier(14805).setType(NPC_SECOND_OPTION).setParam0(0).setParam1(0).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(menaphiteThug)
		};
		plugin.onPostMenuSort(new PostMenuSort());
		Mockito.verify(client, Mockito.never()).setMenuEntries(Mockito.any());
	}

	@Test
	public void testLookupSwapInFriendsListMenu() {
		setConfig("lookup,*", "");
		menuEntries = new MenuEntry[]{
			new TestMenuEntry().setOption("Cancel").setTarget("").setIdentifier(610).setType(CANCEL).setParam0(0).setParam1(0).setForceLeftClick(false).setDeprioritized(true).setItemOp(-1).setItemId(-1).setActor(null),
			new TestMenuEntry().setOption("Message").setTarget("<col=ff9040>420kc</col>").setIdentifier(2).setType(CC_OP).setParam0(39).setParam1(28114955).setForceLeftClick(false).setDeprioritized(true).setItemOp(-1).setItemId(-1)/*.setWidget(28114955)*/.setActor(null),
			new TestMenuEntry().setOption("Delete").setTarget("<col=ff9040>420kc</col>").setIdentifier(3).setType(CC_OP).setParam0(39).setParam1(28114955).setForceLeftClick(false).setDeprioritized(true).setItemOp(-1).setItemId(-1)/*.setWidget(28114955)*/.setActor(null),
			new TestMenuEntry().setOption("Lookup").setTarget("<col=ff9040>420kc</col>").setIdentifier(3).setType(RUNELITE).setParam0(0).setParam1(0).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setActor(null),
			new TestMenuEntry().setOption("Hide notifications").setTarget("<col=ff9040>420kc</col>").setIdentifier(0).setType(RUNELITE).setParam0(0).setParam1(0).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setActor(null),
			new TestMenuEntry().setOption("Add Note").setTarget("<col=ff9040>420kc</col>").setIdentifier(0).setType(RUNELITE).setParam0(0).setParam1(0).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setActor(null)
		};
		plugin.onPostMenuSort(new PostMenuSort());
		Assert.assertTrue(client.getMenuEntries()[client.getMenuEntries().length - 1].getOption().equals("Lookup"));
	}

	@Test
	public void swapEntriesWhileProtectedEntriesAreInMenu() {
		// TODO figure out priority system.
		setConfig("Knock-Out,*\nLure,*\nPickpocket,*", "");
		NPC menaphiteThug = generateNpc(new String[]{"Talk-to", "Attack", "Pickpocket", "Lure", "Knock-Out"});
		menuEntries = new MenuEntry[]{
			new TestMenuEntry().setOption("Cancel").setTarget("").setIdentifier(0).setType(CANCEL).setParam0(0).setParam1(0).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(null),
			new TestMenuEntry().setOption("Examine").setTarget("<col=ffff00>Menaphite Thug<col=ff00>  (level-55)").setIdentifier(14805).setType(EXAMINE_NPC).setParam0(0).setParam1(0).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(menaphiteThug),
			new TestMenuEntry().setOption("Walk here").setTarget("").setIdentifier(0).setType(WALK).setParam0(371).setParam1(142).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(null),
			new TestMenuEntry().setOption("Knock-Out").setTarget("<col=ffff00>Menaphite Thug<col=ff00>  (level-55)").setIdentifier(14805).setType(NPC_FIFTH_OPTION).setParam0(0).setParam1(0).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(menaphiteThug),
			new TestMenuEntry().setOption("Lure").setTarget("<col=ffff00>Menaphite Thug<col=ff00>  (level-55)").setIdentifier(14805).setType(NPC_FOURTH_OPTION).setParam0(0).setParam1(0).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(menaphiteThug),
			new TestMenuEntry().setOption("Pickpocket").setTarget("<col=ffff00>Menaphite Thug<col=ff00>  (level-55)").setIdentifier(14805).setType(NPC_THIRD_OPTION).setParam0(0).setParam1(0).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(menaphiteThug),
			new TestMenuEntry().setOption("Talk-to").setTarget("<col=ffff00>Menaphite Thug<col=ff00>  (level-55)").setIdentifier(14805).setType(NPC_FIRST_OPTION).setParam0(0).setParam1(0).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(menaphiteThug),
			new TestMenuEntry().setOption("Attack").setTarget("<col=ffff00>Menaphite Thug<col=ff00>  (level-55)").setIdentifier(14805).setType(NPC_SECOND_OPTION).setParam0(0).setParam1(0).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(menaphiteThug)
		};
		plugin.onPostMenuSort(new PostMenuSort());
//		Mockito.verify(client, Mockito.calls(1)).setMenuEntries(Mockito.any());
		Assert.assertTrue(client.getMenuEntries()[client.getMenuEntries().length - 1].getOption().equals("Pickpocket"));
	}

	@Test
	public void cannotSwapBlackjackOptions() {
		setConfig("Knock-Out,*\nLure,*", "");
		NPC menaphiteThug = generateNpc(new String[]{"Talk-to", "Attack", "Pickpocket", "Lure", "Knock-Out"});
		menuEntries = new MenuEntry[]{
			new TestMenuEntry().setOption("Cancel").setTarget("").setIdentifier(0).setType(CANCEL).setParam0(0).setParam1(0).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(null),
			new TestMenuEntry().setOption("Examine").setTarget("<col=ffff00>Menaphite Thug<col=ff00>  (level-55)").setIdentifier(14805).setType(EXAMINE_NPC).setParam0(0).setParam1(0).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(menaphiteThug),
			new TestMenuEntry().setOption("Walk here").setTarget("").setIdentifier(0).setType(WALK).setParam0(371).setParam1(142).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(null),
			new TestMenuEntry().setOption("Knock-Out").setTarget("<col=ffff00>Menaphite Thug<col=ff00>  (level-55)").setIdentifier(14805).setType(NPC_FIFTH_OPTION).setParam0(0).setParam1(0).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(menaphiteThug),
			new TestMenuEntry().setOption("Lure").setTarget("<col=ffff00>Menaphite Thug<col=ff00>  (level-55)").setIdentifier(14805).setType(NPC_FOURTH_OPTION).setParam0(0).setParam1(0).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(menaphiteThug),
			new TestMenuEntry().setOption("Pickpocket").setTarget("<col=ffff00>Menaphite Thug<col=ff00>  (level-55)").setIdentifier(14805).setType(NPC_THIRD_OPTION).setParam0(0).setParam1(0).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(menaphiteThug),
			new TestMenuEntry().setOption("Talk-to").setTarget("<col=ffff00>Menaphite Thug<col=ff00>  (level-55)").setIdentifier(14805).setType(NPC_FIRST_OPTION).setParam0(0).setParam1(0).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(menaphiteThug),
			new TestMenuEntry().setOption("Attack").setTarget("<col=ffff00>Menaphite Thug<col=ff00>  (level-55)").setIdentifier(14805).setType(NPC_SECOND_OPTION).setParam0(0).setParam1(0).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(menaphiteThug)
		};
		plugin.onPostMenuSort(new PostMenuSort());
		Mockito.verify(client, Mockito.never()).setMenuEntries(Mockito.any());
	}

	public NPC generateNpc(String[] actions) {
		NPC mock = Mockito.mock(NPC.class);
		Mockito.when(mock.getTransformedComposition()).thenAnswer(a -> {
			NPCComposition mock1 = Mockito.mock(NPCComposition.class);
			Mockito.when(mock1.getActions()).thenReturn(actions);
			return mock1;
		});
		return mock;
	}

	// TODO test that swaps can still happen while protected menu entries exist.

	@Test
	public void cannotSwapBuildModeFifthOption() {
		setConfig("Remove,*\nBuild,*", "");
		menuEntries = new MenuEntry[]{
			new TestMenuEntry().setOption("Cancel").setTarget("").setIdentifier(0).setType(CANCEL).setParam0(0).setParam1(0).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(null),
			new TestMenuEntry().setOption("Build").setTarget("<col=ffff>Adventure log space").setIdentifier(29141).setType(GAME_OBJECT_FIFTH_OPTION).setParam0(48).setParam1(62).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(null),
			new TestMenuEntry().setOption("Examine").setTarget("<col=ffff>Adventure log space").setIdentifier(29141).setType(EXAMINE_OBJECT).setParam0(48).setParam1(62).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(null),
			new TestMenuEntry().setOption("Walk here").setTarget("").setIdentifier(0).setType(WALK).setParam0(351).setParam1(89).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(null)
		};
		plugin.onPostMenuSort(new PostMenuSort());
		Mockito.verify(client, Mockito.never()).setMenuEntries(Mockito.any());

		setConfig("Remove,*\nBuild,*", "");
		menuEntries = new MenuEntry[]{
			new TestMenuEntry().setOption("Cancel").setTarget("").setIdentifier(0).setType(CANCEL).setParam0(0).setParam1(0).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(null),
			new TestMenuEntry().setOption("Remove").setTarget("<col=ffff>Adventure log space").setIdentifier(29141).setType(GAME_OBJECT_FIFTH_OPTION).setParam0(48).setParam1(62).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(null),
			new TestMenuEntry().setOption("Examine").setTarget("<col=ffff>Adventure log space").setIdentifier(29141).setType(EXAMINE_OBJECT).setParam0(48).setParam1(62).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(null),
			new TestMenuEntry().setOption("Walk here").setTarget("").setIdentifier(0).setType(WALK).setParam0(351).setParam1(89).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(null)
		};
		plugin.onPostMenuSort(new PostMenuSort());
		Mockito.verify(client, Mockito.never()).setMenuEntries(Mockito.any());

		setConfig("", "Burthorpe,*\nTeleport Menu,*\nwalk here\nexamine,*");
		menuEntries = new MenuEntry[]{
			new TestMenuEntry().setOption("Cancel").setTarget("").setIdentifier(16444).setType(CANCEL).setParam0(0).setParam1(0).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(null),
			new TestMenuEntry().setOption("Remove").setTarget("<col=ffff>Ornate Jewellery Box").setIdentifier(29156).setType(GAME_OBJECT_FIFTH_OPTION).setParam0(49).setParam1(57).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(null),
			new TestMenuEntry().setOption("Examine").setTarget("<col=ffff>Ornate Jewellery Box").setIdentifier(37524).setType(EXAMINE_OBJECT).setParam0(49).setParam1(57).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(null),
			new TestMenuEntry().setOption("Walk here").setTarget("").setIdentifier(0).setType(WALK).setParam0(432).setParam1(265).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(null),
			new TestMenuEntry().setOption("Burthorpe").setTarget("<col=ffff>Ornate Jewellery Box").setIdentifier(29156).setType(GAME_OBJECT_THIRD_OPTION).setParam0(49).setParam1(57).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(null),
			new TestMenuEntry().setOption("Teleport Menu").setTarget("<col=ffff>Ornate Jewellery Box").setIdentifier(29156).setType(GAME_OBJECT_SECOND_OPTION).setParam0(49).setParam1(57).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(null)
		};
		plugin.onPostMenuSort(new PostMenuSort());
		Mockito.verify(client, Mockito.never()).setMenuEntries(Mockito.any());

		setConfig("cancel", "examine,*");
		menuEntries = new MenuEntry[]{
			new TestMenuEntry().setOption("Cancel").setTarget("").setIdentifier(0).setType(CANCEL).setParam0(0).setParam1(0).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(null),
			new TestMenuEntry().setOption("Remove").setTarget("<col=ffff>Adventure log space").setIdentifier(29141).setType(GAME_OBJECT_FIFTH_OPTION).setParam0(48).setParam1(62).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(null),
			new TestMenuEntry().setOption("Examine").setTarget("<col=ffff>Adventure log space").setIdentifier(29141).setType(EXAMINE_OBJECT).setParam0(48).setParam1(62).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(null),
			new TestMenuEntry().setOption("Walk here").setTarget("").setIdentifier(0).setType(WALK).setParam0(351).setParam1(89).setForceLeftClick(false).setDeprioritized(false).setItemOp(-1).setItemId(-1).setWidget(null).setActor(null)
		};
		plugin.onPostMenuSort(new PostMenuSort());
		Assert.assertFalse(client.getMenuEntries()[client.getMenuEntries().length - 1].getOption().equals("Remove"));
	}

}

package com.hotkeyablemenuswaps;

import java.util.Arrays;
import java.util.stream.Collectors;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.Menu;
import net.runelite.api.MenuEntry;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.CommandExecuted;
import net.runelite.api.events.MenuOpened;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.PluginDescriptor;

@PluginDescriptor(
	name = "[Tools] Hotkeyable menu swaps",
	description = "",
	tags = {"entry", "swapper"}
)
@PluginDependency(HotkeyableMenuSwapsPlugin.class)
public class HotkeyableMenuSwapsToolsPlugin extends Plugin
{

	@Inject
	private HotkeyableMenuSwapsPlugin plugin;

	@Inject
	private ItemManager itemManager;

	int demoanim = -1;
	int demogfx = -1;

	@Subscribe
	public void onCommandExecuted(CommandExecuted commandExecuted) {
		String[] arguments = commandExecuted.getArguments();
		String command = commandExecuted.getCommand();
		System.out.println(arguments.length);

		if (command.equals("record")) {
			recordMenuEntries = true;
		}
	}

	private boolean recordMenuEntries = false;

	@Inject
	private Client client;

	@Subscribe(priority = -1000f) public void onMenuOpened(MenuOpened e) {
		System.out.println("===menu opened===");
		HotkeyableMenuSwapsPlugin.ForwardsMenuIterator menuIterator = new HotkeyableMenuSwapsPlugin.ForwardsMenuIterator(client.getMenuEntries());
		while (menuIterator.hasNext())
		{
			MenuEntry menuEntry = menuIterator.next();
			Menu subMenu = menuEntry.getSubMenu();
			Widget widget = menuEntry.getWidget();
			int interfaceId = widget != null ? WidgetUtil.componentToInterface(widget.getId()) : -1;
//			System.out.println(menuEntry.getOption() + " " + menuEntry.getTarget() + " " + menuEntry.getType() + " " + menuEntry.getIdentifier() + " " + interfaceId);
			if (menuIterator.inSubmenu()) System.out.print("\t");
			System.out.println(menuEntry.getOption() + " " + menuEntry.getTarget() + " " + menuIterator.submenuIndex);
			if (menuIterator.inSubmenu()) System.out.println("\t" + " parent: " + menuIterator.index + " " + menuIterator.getMenuEntries()[menuIterator.index].getOption() + "," + menuIterator.getMenuEntries()[menuIterator.index].getTarget());
		}
	}

	@Subscribe(priority = -2) // This will run after our swaps.
	public void onClientTick(ClientTick clientTick) {
		if (recordMenuEntries)
		{
			recordMenuEntries = false;
			if (client.isMenuOpen()) {
				System.out.println("do not do this with the menu open.");
				return;
			}
			System.out.println("printing menu:");

			for (MenuEntry menuEntry : client.getMenuEntries())
			{
//				System.out.println(
//					"\"" + menuEntry.getOption() + "\", \"" + menuEntry.getTarget() + "\", "
//					+ menuEntry.getType() + ", "
//					+ menuEntry.getIdentifier() + ", "
//					+ menuEntry.isDeprioritized() + ", "
//				);
				System.out.println("new TestMenuEntry().setOption(\"" + menuEntry.getOption() + "\").setTarget(\"" + menuEntry.getTarget() + "\").setIdentifier(" + menuEntry.getIdentifier() + ").setType(" + menuEntry.getType() + ").setParam0(" + menuEntry.getParam0() + ").setParam1(" + menuEntry.getParam1() + ").setForceLeftClick(" + menuEntry.isForceLeftClick() + ").setDeprioritized(" + menuEntry.isDeprioritized() + ").setItemOp(" + menuEntry.getItemOp() + ").setItemId(" + menuEntry.getItemId() + ").setWidget(" + menuEntry.getWidget() + ").setActor(" + menuEntry.getActor() + ")");
				if (menuEntry.getNpc() != null) {
					String[] actions = menuEntry.getNpc().getTransformedComposition().getActions();
					System.out.println("actions is " + Arrays.asList(actions).stream().map(s -> "\"" + s + "\"").collect(Collectors.toList()));
				}
			}
		}

//		for (int i = 0; i < Math.min(100, client.getLocalPlayer().getModel().getFaceColors1().length); i++)
//		for (int i = 0; i < client.getLocalPlayer().getModel().getFaceColors1().length; i++)
//		{
//			client.getLocalPlayer().getModel().getFaceColors1()[i] = 0;
//		}
//		if (demoanim != -1) {
//			client.getLocalPlayer().setAnimation(demoanim);
//			client.getLocalPlayer().setAnimationFrame(0);
//		}
		if (demogfx != -1) {
			client.getLocalPlayer().setGraphic(demogfx);
			client.getLocalPlayer().setSpotAnimFrame(0);
		}
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked menuOptionClicked)
	{
//		if (menuOptionClicked.getMenuOption().equals("Use") && menuOptionClicked.getId() == 563) {
//			if (demoanim != -1) {
//				demoanim--;
//				for (Constants.ActorAnimation value : values())
//				{
//					value.setAnimation(client.getLocalPlayer(), demoanim);
//				}
//				System.out.println("demo anim " + demoanim);
//			}
//			if (demogfx != -1) {
//				demogfx--;
//				System.out.println("demo gfx " + demogfx);
//			}
//		} else if (menuOptionClicked.getMenuOption().equals("Use") && menuOptionClicked.getId() == 995){
//			if (demoanim != -1) {
//				demoanim++;
//				for (Constants.ActorAnimation value : values())
//				{
//					value.setAnimation(client.getLocalPlayer(), demoanim);
//				}
//				System.out.println("demo anim " + demoanim);
//			}
//			if (demogfx != -1) {
//				demogfx++;
//				System.out.println("demo gfx " + demogfx);
//			}
//		}
//		System.out.println(menuOptionClicked.getMenuOption() + " " + Text.removeTags(menuOptionClicked.getMenuTarget()));
	}

}

/*
 * Copyright (c) 2021, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.hotkeyablemenuswaps;

import java.util.function.Consumer;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import lombok.EqualsAndHashCode;
import net.runelite.api.Actor;
import net.runelite.api.Menu;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.widgets.Widget;

@EqualsAndHashCode
public class TestMenuEntry implements MenuEntry
{
	private String option;
	private String target;
	private int identifier;
	private int type;
	private int param0;
	private int param1;
	private boolean forceLeftClick;
	private int itemOp = -1;
	private int itemId = -1;
	private Widget widget;
	private Actor actor;

	@Override
	public String getOption()
	{
		return option;
	}

	@Override
	public TestMenuEntry setOption(String option)
	{
		this.option = option;
		return this;
	}

	@Override
	public String getTarget()
	{
		return target;
	}

	@Override
	public TestMenuEntry setTarget(String target)
	{
		this.target = target;
		return this;
	}

	@Override
	public int getIdentifier()
	{
		return this.identifier;
	}

	@Override
	public TestMenuEntry setIdentifier(int identifier)
	{
		this.identifier = identifier;
		return this;
	}

	@Override
	public MenuAction getType()
	{
		return MenuAction.of(this.type);
	}

	@Override
	public TestMenuEntry setType(MenuAction type)
	{
		this.type = type.getId();
		return this;
	}

	@Override
	public int getParam0()
	{
		return this.param0;
	}

	@Override
	public TestMenuEntry setParam0(int param0)
	{
		this.param0 = param0;
		return this;
	}

	@Override
	public int getParam1()
	{
		return this.param1;
	}

	@Override
	public TestMenuEntry setParam1(int param1)
	{
		this.param1 = param1;
		return this;
	}

	@Override
	public boolean isForceLeftClick()
	{
		return this.forceLeftClick;
	}

	@Override
	public TestMenuEntry setForceLeftClick(boolean forceLeftClick)
	{
		this.forceLeftClick = forceLeftClick;
		return this;
	}

	@Override
	public int getWorldViewId()
	{
		return 0;
	}

	@Override
	public MenuEntry setWorldViewId(int worldViewId)
	{
		return null;
	}

	@Override
	public boolean isDeprioritized()
	{
		return type >= MenuAction.MENU_ACTION_DEPRIORITIZE_OFFSET;
	}

	@Override
	public TestMenuEntry setDeprioritized(boolean deprioritized)
	{
		if (deprioritized)
		{
			if (type < MenuAction.MENU_ACTION_DEPRIORITIZE_OFFSET)
			{
				type += MenuAction.MENU_ACTION_DEPRIORITIZE_OFFSET;
			}
		}
		else
		{
			if (type >= MenuAction.MENU_ACTION_DEPRIORITIZE_OFFSET)
			{
				type -= MenuAction.MENU_ACTION_DEPRIORITIZE_OFFSET;
			}
		}

		return this;
	}

	@Override
	public MenuEntry onClick(Consumer<MenuEntry> callback)
	{
		return this;
	}

	@Override
	public Consumer<MenuEntry> onClick()
	{
		return null;
	}

	@Override
	public boolean isItemOp()
	{
		return itemOp != -1;
	}

	@Override
	public int getItemOp()
	{
		return itemOp;
	}

	public TestMenuEntry setItemOp(int itemOp)
	{
		this.itemOp = itemOp;
		return this;
	}

	@Override
	public int getItemId()
	{
		return itemId;
	}

	public TestMenuEntry setItemId(int itemId)
	{
		this.itemId = itemId;
		return this;
	}

	@Nullable
	@Override
	public Widget getWidget()
	{
		return widget;
	}

	public TestMenuEntry setWidget(Widget widget)
	{
		this.widget = widget;
		return this;
	}

	public TestMenuEntry setActor(Actor actor)
	{
		this.actor = actor;
		return this;
	}

	@Nullable
	@Override
	public NPC getNpc()
	{
		return actor instanceof NPC ? (NPC) actor : null;
	}

	@Nullable
	@Override
	public Player getPlayer()
	{
		return actor instanceof Player ? (Player) actor : null;
	}

	@Nullable
	@Override
	public Actor getActor()
	{
		return actor;
	}

	@Nullable
	@Override
	public Menu getSubMenu()
	{
		return null;
	}

	@Nonnull
	@Override
	public Menu createSubMenu()
	{
		return null;
	}

	@Override
	public void deleteSubMenu()
	{

	}
}

package com.hotkeyablemenuswaps;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.lang.reflect.Field;
import java.util.Properties;
import net.runelite.client.RuneLite;
import net.runelite.client.RuneLiteProperties;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class HotkeyableMenuSwapsPluginTest
{
	public static void main(String[] args) throws Exception
	{
		setWindowTitle("hotkeyable-menu-swaps (" + getCurrentGitBranch() + ") RL-" + RuneLiteProperties.getVersion());

//		System.setProperty("runelite.pluginhub.version", "1.8.24.1");
		ExternalPluginManager.loadBuiltin(HotkeyableMenuSwapsPlugin.class, HotkeyableMenuSwapsToolsPlugin.class);
		RuneLite.main(args);
	}

	private static void setWindowTitle(String title) throws NoSuchFieldException, IllegalAccessException
	{
		Field propertiesField = RuneLiteProperties.class.getDeclaredField("properties");
		propertiesField.setAccessible(true);
		Properties properties = (Properties) propertiesField.get(null);
		properties.setProperty("runelite.title", title);
	}

	public static String getCurrentGitBranch() {
		try
		{
			Process process = Runtime.getRuntime().exec("git rev-parse --abbrev-ref HEAD");
			process.waitFor();

			BufferedReader reader = new BufferedReader(
				new InputStreamReader(process.getInputStream()));

			return reader.readLine();
		}catch (Exception e) {
			return "threw exception";
		}
	}

}
