package dev.blonks.kitchenrunning.utils;

public enum HideOthersState
{
	EVERYONE,
	FOLLOWING_CONDUCTOR,
	NOT_FOLLOWING_CONDUCTOR,
	NO_ONE,

}

package dev.blonks.kitchenrunning.utils;

import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import net.runelite.api.InventoryID;

public class InventoryUtils
{
	public static boolean itemContainerContainsGreaves(Client client, int inventoryID, boolean defaultBool) {
		ItemContainer container = client.getItemContainer(inventoryID);
		if (container == null) {
			return defaultBool;
		}

		for (Item item : container.getItems()) {
			if (item.getId() == ItemID.SAGES_GREAVES) {
				return true;
			}
		}
		return false;
	}
}

package dev.blonks.kitchenrunning.utils;

public enum HideMode
{
	FOLLOWING_CONDUCTOR,
	NOT_FOLLOWING_CONDUCTOR,
	ALWAYS,
	NEVER,

}

package dev.blonks.kitchenrunning.utils;

import com.google.common.collect.ImmutableSet;
import dev.blonks.kitchenrunning.config.KitchenRunningConfig;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.WorldType;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;

import java.util.Set;

/**
 * A class that contains static properties and methods that aid in working with the player location
 * data, as well as general map location
 */
public class PlayerPositionUtils {
    public static final WorldArea LUMBRIDGE_KITCHEN = new WorldArea(3205, 3212, 8, 6, 0);
    public static final Set<WorldPoint> GOOD_TILES = ImmutableSet.of(
            new WorldPoint(3207, 3213, 0),
            new WorldPoint(3209, 3213, 0),
            new WorldPoint(3211, 3213, 0),
            new WorldPoint(3207, 3215, 0),
            new WorldPoint(3209, 3215, 0),
            new WorldPoint(3211, 3215, 0)
    );
    public static final Set<WorldPoint> BAD_TILES = ImmutableSet.of(
            new WorldPoint(3208, 3215, 0),
            new WorldPoint(3210, 3215, 0),
            new WorldPoint(3211, 3214, 0),
            new WorldPoint(3210, 3213, 0),
            new WorldPoint(3208, 3213, 0),
            new WorldPoint(3207, 3214, 0)
    );

	public static boolean shouldProcess(Client client) {
		return isInKitchen(client) && !isPvpOrNonLeagues(client);
	}

    public static boolean isInKitchen(Client client) {
        return isInKitchen(client, client.getLocalPlayer());
    }

	public static boolean isInKitchen(Client client, Player player) {
		if (player == null)
			return false;

		WorldPoint playerLocation = player.getWorldLocation();
		return playerLocation.isInArea(LUMBRIDGE_KITCHEN);
	}

	public static boolean isConductorNearby(Client client, KitchenRunningConfig config) {
		var playerOptional = getConductorPlayer(client, config);

		if (playerOptional.isEmpty())
		{
			return false;
		}

		return isInKitchen(client, playerOptional.get());
	}

	/**
	 * Tries to grab the specified conductor from the nearby players
	 * @return An {@link Optional<? extends Player> optional} that may contain the conductor {@Player}
	 */
	public static Optional<? extends Player> getConductorPlayer(Client client, KitchenRunningConfig config) {
		String conductorName = config.activeConductor();
		if (conductorName == null)
			return Optional.empty();

		Optional<? extends Player> playerOptional = client.getTopLevelWorldView().players().stream()
			.filter(player -> conductorName.strip().equalsIgnoreCase(player.getName()))
			.findFirst();

		return playerOptional;
	}

	public static Optional<? extends Player> getAnyConductorPlayer(Client client, KitchenRunningConfig config) {
		if (config.conductorUsernames() == null || config.conductorUsernames().isBlank())
			return Optional.empty();

		/*
		Always split on line separators if present, else split on commas
		 */
		String splitOn = config.conductorUsernames().contains(System.lineSeparator()) ? System.lineSeparator() : ",";
		List<String> potentialConductors = Arrays.stream(config.conductorUsernames().split(splitOn))
			.map(String::toLowerCase)
			.map(str -> str.replace(",", "")) // make sure to remove any commas in case people mixed commas and newlines
			.map(str -> str.replace(System.lineSeparator(), "")) // same here
			.collect(Collectors.toList());


		return client.getTopLevelWorldView().players().stream()
			.filter(player -> potentialConductors.contains(player.getName().toLowerCase()))
			.min(Comparator.comparingInt((Player p) -> potentialConductors.indexOf(p.getName().toLowerCase())));
	}

    public static CycleState getPlayerCycleState(KitchenRunningConfig config, Player player) {
        boolean isOnGoodTile = isOnGoodTile(player);
        boolean isFollowingConductor = isFollowingConductor(config, player);

        if (isOnGoodTile && isFollowingConductor)
            return CycleState.FOLLOWING_CONDUCTOR;

        return CycleState.NOT_FOLLOWING_CONDUCTOR;
    }

    public static boolean isInCycle(KitchenRunningConfig config, Player player) {
        return isOnTileSet(player, GOOD_TILES) && isFollowingConductor(config, player);
    }

    public static boolean isOnGoodTile(Player player) {
        return isOnTileSet(player, GOOD_TILES);
    }

    public static boolean isOnBadTile(Player player) {
        return isOnTileSet(player, BAD_TILES);
    }

    private static boolean isOnTileSet(Player player, Set<WorldPoint> tileSet) {
        if (player == null)
            return false;

        WorldPoint worldPoint = player.getWorldLocation();
        if (worldPoint == null)
            return false;

        for (WorldPoint point : tileSet) {
            if (point.distanceTo(worldPoint) == 0)
                return true;
        }
        return false;
    }

    public static LocalPoint getLocalPoint(Client client, Player player) {
        if (player == null)
            return null;

        WorldPoint worldPoint = player.getWorldLocation();
        if (worldPoint == null)
            return null;

        return LocalPoint.fromWorld(client, worldPoint);
    }

    public static boolean isFollowingConductor(KitchenRunningConfig config, Player player) {
        if (player == null)
            return false;

        Actor interacting = player.getInteracting();
        if (interacting == null)
            return false;

        String actorName = interacting.getName();
        if (actorName == null)
            return false;

        return actorName.equalsIgnoreCase(config.activeConductor());
    }

    public static boolean isPvpOrNonLeagues(Client client) {
        // render everyone on pvp worlds
        if (WorldType.isPvpWorld(client.getWorldType())) {
            return true;
        }

        // render everyone when its not a seasonal or tournament world (i.e. leagues or grid master)
        if (!client.getWorldType().contains(WorldType.SEASONAL) && !client.getWorldType().contains(WorldType.TOURNAMENT_WORLD)) {
            return true;
        }

        return false;
    }
}

package dev.blonks.kitchenrunning.utils;

public enum CycleState {
	FOLLOWING_CONDUCTOR,
	NOT_FOLLOWING_CONDUCTOR,

}

package dev.blonks.kitchenrunning.utils;

import com.google.common.collect.ImmutableSet;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;

import java.util.Set;
import net.runelite.api.gameval.NpcID;

public class KitchenRunningConstants
{
	public static final Set<Integer> THRALL_IDS = ImmutableSet.of(
		NpcID.ARCEUUS_THRALL_GHOST_LESSER, NpcID.ARCEUUS_THRALL_SKELETON_LESSER, NpcID.ARCEUUS_THRALL_ZOMBIE_LESSER,  // Lesser Thrall (ghost, skeleton, zombie)
		NpcID.ARCEUUS_THRALL_GHOST_SUPERIOR, NpcID.ARCEUUS_THRALL_SKELETON_SUPERIOR, NpcID.ARCEUUS_THRALL_ZOMBIE_SUPERIOR,  // Superior Thrall (ghost, skeleton, zombie)
		NpcID.ARCEUUS_THRALL_GHOST_GREATER, NpcID.ARCEUUS_THRALL_SKELETON_GREATER, NpcID.ARCEUUS_THRALL_ZOMBIE_GREATER   // Greater Thrall (ghost, skeleton, zombie)
	);
	public static final Set<Integer> RANDOM_EVENT_NPC_IDS = ImmutableSet.of(
		NpcID.MACRO_BEEKEEPER_INVITATION,
		NpcID.MACRO_COMBILOCK_PIRATE,
		NpcID.MACRO_JEKYLL, NpcID.MACRO_JEKYLL_UNDERWATER,
		NpcID.MACRO_DWARF,
		NpcID.PATTERN_INVITATION,
		NpcID.MACRO_EVIL_BOB_OUTSIDE, NpcID.MACRO_EVIL_BOB_PRISON,
		NpcID.PINBALL_INVITATION,
		NpcID.MACRO_FORESTER_INVITATION,
		NpcID.MACRO_FROG_CRIER, NpcID.MACRO_FROG_GENERIC, NpcID.MACRO_FROG_SULKING, NpcID.MACRO_FROG_NONCOMBAT, NpcID.MACRO_FROG_NOHAT, NpcID.MACRO_FROG_PRIN_HE, NpcID.MACRO_FROG_PRIN_SHE, NpcID.MACRO_FROG_PRIN_A, NpcID.MACRO_FROG_PRIN_B,
		NpcID.MACRO_GENI, NpcID.MACRO_GENI_UNDERWATER,
		NpcID.MACRO_GILES, NpcID.MACRO_GILES_UNDERWATER,
		NpcID.MACRO_GRAVEDIGGER_INVITATION,
		NpcID.MACRO_MILES, NpcID.MACRO_MILES_UNDERWATER,
		NpcID.MACRO_MYSTERIOUS_OLD_MAN, NpcID.MACRO_MYSTERIOUS_OLD_MAN_UNDERWATER,
		NpcID.MACRO_MAZE_INVITATION, NpcID.MACRO_MIME_INVITATION,
		NpcID.MACRO_NILES, NpcID.MACRO_NILES_UNDERWATER,
		NpcID.MACRO_PILLORY_GUARD,
		NpcID.GRAB_POSTMAN,
		NpcID.MACRO_MAGNESON_INVITATION,
		NpcID.MACRO_HIGHWAYMAN, NpcID.MACRO_HIGHWAYMAN_UNDERWATER,
		NpcID.MACRO_SANDWICH_LADY_NPC,
		NpcID.MACRO_DRILLDEMON_INVITATION,
		NpcID.MACRO_COUNTCHECK_SURFACE, NpcID.MACRO_COUNTCHECK_UNDERWATER
	);
}

package dev.blonks.kitchenrunning.config;

import dev.blonks.kitchenrunning.utils.HideMode;
import net.runelite.client.config.*;

import java.awt.*;

@ConfigGroup(KitchenRunningConfig.KITCHEN_GROUP)
public interface KitchenRunningConfig extends Config
{
    String KITCHEN_GROUP = "kitchenrunning";

    @ConfigSection(
            name = "Instructions",
            description = "Look here for instructions",
            position = -1
    )
    String instructions = "instructions";

    @ConfigItem(
            keyName = "kitchenRunningInstructions",
            name = "Instructions",
            description = "A set of instructions on how to use this plugin",
            section = instructions
    )
    default String kitchenRunningInstructions() {
        return "1. Stand on one of the 6 tiles that are highlighted in the lumbridge kitchen\n\n" +
                "2. Enter the username of the player who is conducting the agility circle\n\n" +
                "3. Wait for their highlighted tile to pass yours, and then follow them\n\n" +
                "4. Enjoy the xp";
    }

    @ConfigSection(
            name = "General Settings",
            description = "General settings/config options.",
            position = 0
    )
    String generalConfig = "generalConfig";

    @ConfigItem(
            keyName = "conductorUsernames",
            name = "Conductor usernames",
            description = "The username(s) of the player that is leading the kitchen loop (commas or new lines)",
            section = generalConfig
    )
    default String conductorUsernames()
    {
        return "";
    }


	@ConfigItem(
		keyName = "activeConductor",
		name = "",
		description = "",
		hidden = true
	)
	default String activeConductor() {
		return "";
	}
	@ConfigItem(
		keyName = "activeConductor",
		name = "",
		description = "",
		hidden = true
	)
	void activeConductor(String conductorUsername);

	@ConfigItem(
		keyName = "sidebarPriority",
		name = "Sidebar Priority",
		description = "Customize the priority of the panel in the sidebar",
		hidden = true,
		section = generalConfig
	)
	default int sidebarPriority() {
		return 25;
	}


    @ConfigSection(
            name = "Conductor Tile",
            description = "Conductor Tiles Configuration.",
            position = 1
    )
    String conductorTile = "conductorTile";

//    @ConfigItem(
//            keyName = "conductorTile",
//            name = "Conductor tile",
//            description = "Configures when the conductor tile should be drawn",
//            section = conductorTile,
//            position = 0
//    )
//    default CycleState conductorTile() {
//        return CycleState.OUT_OF_CYCLE;
//    }

    @Alpha
    @ConfigItem(
            keyName = "conductorPlayerTileBorder",
            name = "Conductor player tile border",
            description = "Highlights the tile of the conductor",
            section = conductorTile,
            position = 1
    )
    default Color conductorPlayerTileBorder() {
        return Color.CYAN;
    }

    @Alpha
    @ConfigItem(
            keyName = "conductorPlayerTileFill",
            name = "Conductor player tile fill",
            description = "Highlights the tile of the conductor",
            section = conductorTile,
            position = 2
    )
    default Color conductorPlayerTileFill() {
        return new Color(0, 255, 255, 50);
    }


    @ConfigSection(
            name = "Player Tile",
            description = "Player Tile Configuration.",
            position = 2
    )
    String playerTile = "playerTile";

//    @ConfigItem(
//            keyName = "playerTile",
//            name = "Player tile",
//            description = "Configures when the player tile should be drawn",
//            section = playerTile,
//            position = 0
//    )
//    default CycleState playerTile() {
//        return CycleState.OUT_OF_CYCLE;
//    }

    @Alpha
    @ConfigItem(
            keyName = "playerTileBorder",
            name = "Player tile border",
            description = "Highlights the player tile",
            section = playerTile,
            position = 1
    )
    default Color playerTileBorder() {
        return new Color(0, 255, 0, 255);
    }

    @Alpha
    @ConfigItem(
            keyName = "playerTileFill",
            name = "Player tile fill",
            description = "Highlights the player tile",
            section = playerTile,
            position = 2
    )
    default Color playerTileFill() {
        return new Color(0, 255, 0, 50);
    }


    @ConfigSection(
            name = "Starting Tiles",
            description = "Starting Tiles Configuration.",
            position = 3
    )
    String startingTiles = "startingTiles";

//    @ConfigItem(
//            keyName = "startingTiles",
//            name = "Starting tiles",
//            description = "Configures when the starting tiles should be drawn",
//            section = startingTiles,
//            position = 0
//    )
//    default CycleState startingTiles() {
//        return CycleState.OUT_OF_CYCLE;
//    }

    @Alpha
    @ConfigItem(
            keyName = "startingTilesBorder",
            name = "Starting tiles border",
            description = "Highlights the correct starting tiles.",
            section = startingTiles,
            position = 1
    )
    default Color startingTilesBorder() {
        return new Color(255, 255, 255, 255);
    }

    @Alpha
    @ConfigItem(
            keyName = "startingTilesFill",
            name = "Starting tiles fill",
            description = "Highlights the correct starting tiles.",
            section = startingTiles,
            position = 2
    )
    default Color startingTilesFill() {
        return new Color(255, 255, 255, 100);
    }

    @ConfigSection(
            name = "Entity Hider Settings",
            description = "General settings for hiding entities in the area",
            position = 4
    )
    String entityHiderSection = "entityHiderSection";

    @ConfigItem(
            keyName = "hidingMode",
            name = "Hiding mode",
            description = "Configure when other player entities should be hidden so you can find the conductor",
            section = entityHiderSection,
            position = 0
    )
    default HideMode hideOtherEntities() {
        return HideMode.NOT_FOLLOWING_CONDUCTOR;
    }


    @ConfigSection(
            name = "Notification Settings",
            description = "Configuration of different notifications",
            position = 5
    )
    String notificationSettings = "notificationSettings";

    @ConfigItem(
            keyName = "stoppedFollowing",
            name = "Stopped following notification",
            description = "Configures notifications for when you have stopped following the conductor",
            section = notificationSettings,
            position = 0
    )
    default Notification stoppedFollowing() {
        return Notification.ON;
    }

    @ConfigItem(
            keyName = "conductorAlert",
            name = "Conductor alert notification",
            description = "Configures notifications for when the conductor sends out an alert message",
            section =  notificationSettings,
            position = 1
    )
    default Notification conductorAlert() {
        return Notification.OFF;
    }


}

package dev.blonks.kitchenrunning.ui;

import dev.blonks.kitchenrunning.KitchenRunningPlugin;
import dev.blonks.kitchenrunning.ui.dashboard.DashboardPanel;
import java.awt.BorderLayout;
import java.awt.CardLayout;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Font;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.PluginPanel;

@Slf4j
public class MainPanel extends PluginPanel
{
	private KitchenRunningPlugin plugin;
	private final JComboBox<String> viewSelector;
	private final JPanel contentPanel;
	private final CardLayout cardLayout;

	public MainPanel(KitchenRunningPlugin plugin) {
		super();
		setLayout(new BorderLayout());

		String[] views = { "Dashboard" };
		viewSelector = new JComboBox<>(views);
		viewSelector.setFocusable(false);
		viewSelector.addActionListener(e -> switchView());

		JPanel topPanel = new JPanel(new BorderLayout());
		topPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
		topPanel.add(viewSelector, BorderLayout.CENTER);

		add(topPanel, BorderLayout.NORTH);

		cardLayout = new CardLayout();
		contentPanel = new JPanel(cardLayout);

		contentPanel.add("Dashboard", new DashboardPanel(plugin));

		add(contentPanel, BorderLayout.CENTER);
	}

	private void switchView() {
		String selected = (String) viewSelector.getSelectedItem();
		if (selected == null)
			selected = "Dashboard";

		cardLayout.show(contentPanel, selected);
	}
}

package dev.blonks.kitchenrunning.ui.stats;

import dev.blonks.kitchenrunning.KitchenRunningPlugin;
import java.awt.BorderLayout;
import java.util.ArrayList;
import java.util.List;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JPanel;

public class StatsPanel extends JPanel
{
	private KitchenRunningPlugin plugin;
	private List<JPanel> statPanes;
	private JPanel statPanel;

	public StatsPanel(KitchenRunningPlugin plugin) {
		this.plugin = plugin;
		statPanes = new ArrayList<>();

		statPanel = new JPanel();
		JLabel tempLabel = new JLabel();
		tempLabel.setText("Temp");
		statPanel.add(tempLabel);
		statPanes.add(statPanel);
		add(statPanel, BorderLayout.CENTER);
	}
}

package dev.blonks.kitchenrunning.ui.dashboard;

import dev.blonks.kitchenrunning.KitchenRunningPlugin;
import dev.blonks.kitchenrunning.ui.stats.StatsPanel;
import java.awt.BorderLayout;
import java.awt.Dimension;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JPanel;

public class DashboardPanel extends JPanel
{
	private KitchenRunningPlugin plugin;
	private StatsPanel statsPanel;

	public DashboardPanel(KitchenRunningPlugin plugin) {
		super();
		this.plugin = plugin;

		statsPanel = new StatsPanel(plugin);
		add(statsPanel, BorderLayout.CENTER);
	}
}

package dev.blonks.kitchenrunning.overlay;

import dev.blonks.kitchenrunning.KitchenRunningPlugin;
import dev.blonks.kitchenrunning.config.KitchenRunningConfig;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.TitleComponent;

@Slf4j
public class ForgottenGreavesOverlay extends OverlayPanel
{
	private final KitchenRunningPlugin plugin;

	@Inject
	private ForgottenGreavesOverlay(KitchenRunningPlugin plugin) {
		super(plugin);
		setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
		this.plugin = plugin;
	}

	@Override
	public Dimension render(Graphics2D graphics) {
		boolean enabled = plugin.isEnabled();
		if (!enabled || plugin.isWearingGreaves()) {
			panelComponent.getChildren().clear();
			return super.render(graphics);
		}

		final String missingGreavesMessage = "WARNING: You are not currently wearing Sage's greaves!";
		panelComponent.getChildren().add(TitleComponent.builder()
			.text(missingGreavesMessage)
			.color(Color.RED)
			.build()
		);

		panelComponent.setPreferredSize(new Dimension(
			graphics.getFontMetrics().stringWidth(missingGreavesMessage) + 5,
			0
		));

		return super.render(graphics);
	}
}

package dev.blonks.kitchenrunning.overlay;

import dev.blonks.kitchenrunning.config.KitchenRunningConfig;
import dev.blonks.kitchenrunning.utils.PlayerPositionUtils;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Player;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.inject.Inject;
import java.awt.*;
import java.util.Optional;

public class KitchenRunningOverlay extends Overlay {
    private final Client client;
    private final KitchenRunningConfig config;


    @Inject
    private KitchenRunningOverlay(Client client, KitchenRunningConfig config) {
        this.client = client;
        this.config = config;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
        setPriority(PRIORITY_MED);
    }

    @Override
    public Dimension render(Graphics2D graphics2D) {
        if (!PlayerPositionUtils.isInKitchen(client)) {
            return null;
        }

        if (PlayerPositionUtils.isPvpOrNonLeagues(client)) {
            return null;
        }

        // renders good tile starting point markers
        boolean isOnGoodTile = PlayerPositionUtils.isOnGoodTile(client.getLocalPlayer());
        if (!isOnGoodTile) {
            for (WorldPoint point : PlayerPositionUtils.GOOD_TILES) {
                renderPlayerTile(graphics2D, LocalPoint.fromWorld(client, point), config.startingTilesBorder(), config.startingTilesFill());
            }
        }

        // renders nothing if the player is in cycle
        if (PlayerPositionUtils.isFollowingConductor(config, client.getLocalPlayer()) && isOnGoodTile)
            return null;

        final LocalPoint playerLocalPoint = PlayerPositionUtils.getLocalPoint(client, client.getLocalPlayer());
        if (playerLocalPoint == null)
            return null;


        Optional<? extends Player> conductorPlayer = client.getTopLevelWorldView().players().stream()
                .filter(player -> player.getName().equalsIgnoreCase(config.activeConductor()))
                .findFirst();

        if (conductorPlayer.isEmpty())
            return null;

        WorldPoint conductorWorldPoint = conductorPlayer.get().getWorldLocation();
        if (conductorWorldPoint == null)
            return null;

        final LocalPoint conductorLocalPoint = LocalPoint.fromWorld(client, conductorWorldPoint);

        renderPlayerTile(graphics2D, playerLocalPoint, config.playerTileBorder(), config.playerTileFill());
        renderPlayerTile(graphics2D, conductorLocalPoint, config.conductorPlayerTileBorder(), config.conductorPlayerTileFill());

        return null;
    }

    private void renderPlayerTile(Graphics2D graphics2D, final LocalPoint tile, Color borderColor, Color fillColor) {
        if (tile == null)
            return;

        final Polygon polygon = Perspective.getCanvasTilePoly(client, tile);

        if (polygon == null)
            return;

        OverlayUtil.renderPolygon(graphics2D, polygon, borderColor, fillColor, new BasicStroke((float) 2));
    }
}

package dev.blonks.kitchenrunning;

import com.google.inject.Provides;
import dev.blonks.kitchenrunning.config.KitchenRunningConfig;
import dev.blonks.kitchenrunning.overlay.ForgottenGreavesOverlay;
import dev.blonks.kitchenrunning.overlay.KitchenRunningOverlay;
import dev.blonks.kitchenrunning.ui.MainPanel;
import dev.blonks.kitchenrunning.utils.HideMode;
import dev.blonks.kitchenrunning.utils.InventoryUtils;
import dev.blonks.kitchenrunning.utils.KitchenRunningConstants;
import dev.blonks.kitchenrunning.utils.PlayerPositionUtils;
import java.util.Optional;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.gameval.InventoryID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.Hooks;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;

import javax.inject.Inject;
import net.runelite.client.util.ImageUtil;

@Slf4j
@PluginDescriptor(
	name = "Kitchen Running",
    description = "Helpful utilities for getting in cycle with the Sage's Greaves",
    tags = {"greaves", "leagues", "kitchen", "fountain", "grid", "gridmaster", "grid master", "table", "run", "running", "agility"}
)
public class KitchenRunningPlugin extends Plugin
{
    @Inject
	private Client client;

	@Inject
	private ClientToolbar clientToolbar;
	private NavigationButton navButton;
	private MainPanel mainPanel;

	@Inject
	private KitchenRunningConfig config;

    @Inject
    private OverlayManager overlayManager;

	@Inject
	private KitchenRunningOverlay tileOverlay;

	@Inject
	private ForgottenGreavesOverlay greavesWarningOverlay;

    @Inject
    private Notifier notifier;

    @Inject
    private Hooks hooks;
    private final Hooks.RenderableDrawListener renderableDrawListener = this::shouldDraw;

    private IndexedObjectSet<? extends Player> localPlayers;

	@Getter
	private String activeConductor = "";
	@Getter
	private boolean inKitchen = false;
	@Getter
	private boolean wasFollowingConductor = false;
	/**
	 * Main state tracking variable for when features should be enabled.<br/>
	 * When true, this means that the player is on leagues/grid and in the kitchen.<br/>
	 * When false, this would mean that NO features of this plugin should execute.
	 */
	@Getter
	private boolean enabled = false;
	/**
	 * A more granular flag than {@link #enabled}. This will always be false when {@link #enabled} is false,
	 * but there may be cases where some features should be disabled to not disrupt players' experience,
	 * such as disabling entity hiding if they are ready to start running, but no conductor can be found.
	 */
	@Getter
	private boolean conductorNearby = false;
	@Getter
	private boolean loggedIn = false;
	@Getter
	private boolean wearingGreaves = true;
	@Getter
	private boolean forgotGreaves = false;


	// feature flags
	private static final boolean sidebar = false;

    @Provides
    KitchenRunningConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(KitchenRunningConfig.class);
    }

    @Override
    protected void startUp() throws Exception
    {
		updateState();
        overlayManager.add(tileOverlay);
		overlayManager.add(greavesWarningOverlay);
        hooks.registerRenderableDrawListener(renderableDrawListener);

		if (KitchenRunningPlugin.sidebar) {
			mainPanel = new MainPanel(this);
			navButton = createNavButton(config.sidebarPriority());
			clientToolbar.addNavigation(navButton);
		}
    }

    @Override
    protected void shutDown() throws Exception {
		updateState();
        overlayManager.remove(tileOverlay);
		overlayManager.remove(greavesWarningOverlay);
        hooks.unregisterRenderableDrawListener(renderableDrawListener);
		if (KitchenRunningPlugin.sidebar) {
			clientToolbar.removeNavigation(navButton);
		}
    }

	@Subscribe
	public void onConfigChanged(ConfigChanged e) {
		if (e.getKey().equalsIgnoreCase("sidebarPriority")) {
			if (e.getNewValue() == null)
				return;

			NavigationButton newNavButton = createNavButton(Integer.valueOf(e.getNewValue()));
			clientToolbar.removeNavigation(navButton);
			navButton = newNavButton;
			clientToolbar.addNavigation(navButton);
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged e) {
		if (e.getGameState() == GameState.LOGIN_SCREEN) {
			updateState();
		}
	}

    @Subscribe
    public void onGameTick(GameTick e) {
		updateState();
    }

    @Subscribe
    public void onInteractingChanged(InteractingChanged e) {
        Player local = client.getLocalPlayer();
        if (local == null)
            return;

        if (!local.equals(e.getSource()))
            return;


		boolean isFollowingConductor = PlayerPositionUtils.isFollowingConductor(config, local);
		if (wasFollowingConductor && !isFollowingConductor)
		{
			wasFollowingConductor = false;
			notifier.notify(config.stoppedFollowing(), "You are no longer following the conductor!");
		} else if (isFollowingConductor)
		{
			wasFollowingConductor = true;
		}
    }

    @Subscribe
    public void onChatMessage(ChatMessage e) {
        if (!e.getType().equals(ChatMessageType.PUBLICCHAT))
            return;

        if (e.getName() == null)
            return;

        if (!inKitchen)
            return;

        String senderName = e.getName();
        senderName = senderName.substring(Math.max(senderName.indexOf('>')+1, 1));
        if (senderName.equalsIgnoreCase(config.activeConductor())) {
            if (e.getMessage().toLowerCase().startsWith("alert:"))
                notifier.notify(config.conductorAlert(), "The conductor says: " + e.getMessage().toLowerCase().replace("alert:", ""));
        }
    }

	/**
	 * Sets {@link #inKitchen} boolean based on player location<br/>
	 * Sets {@link #wasFollowingConductor}  and {@link #enabled} to false when not in kitchen<br/>
	 * Sets {@link #conductorNearby} if player is in kitchen based on whether the conductor is in the kitchen<br/>
	 */
	private void updateState() {
		// Completely wipe state variables if the user is not logged in
		if (client.getGameState() != GameState.LOGGED_IN) {
			resetStateVariables();
			return;
		}
		loggedIn = true;

		// Completely wipe state variables if the user is on a non-leagues/gridmaster world
		if (PlayerPositionUtils.isPvpOrNonLeagues(client)) {
			resetStateVariables();
			return;
		}

		/* Completely wipe state variables if the user IS logged in and on a leagues/gridmaster world, but not
		 * currently looking to train agility in the kitchen
		 */
		if (!PlayerPositionUtils.isInKitchen(client)) {
			resetStateVariables();
			return;
		}

		String tempConductorConfig = config.conductorUsernames();
		if (tempConductorConfig == null) {
			resetStateVariables();
			return;
		}

		Optional<? extends Player> foundConductor = PlayerPositionUtils.getAnyConductorPlayer(client, config);
		if (foundConductor.isPresent()) {
			conductorNearby = true;
			config.activeConductor(foundConductor.get().getName());
			activeConductor = foundConductor.get().getName();
		} else {
			conductorNearby = false;
			config.activeConductor("");
			activeConductor = "";
		}

		inKitchen = true;
		wearingGreaves = InventoryUtils.itemContainerContainsGreaves(client, InventoryID.WORN, true);
		forgotGreaves = InventoryUtils.itemContainerContainsGreaves(client, InventoryID.INV, false);
		enabled = true;
	}

	private void resetStateVariables() {
		inKitchen = false;
		conductorNearby = false;
		wasFollowingConductor = false;
		enabled = false;
		wearingGreaves = true;
		forgotGreaves = false;
		activeConductor = null;
		config.activeConductor("");
	}

    private boolean shouldDraw(Renderable renderable, boolean b) {
		if (!enabled)
			return true;

		// Always render when the specified conductor is not around
        if (!conductorNearby)
			return true;

        // entity hider settings are disabled
        if (config.hideOtherEntities().equals(HideMode.NEVER))
            return true;

        if (renderable instanceof NPC) {
            NPC npc = (NPC) renderable;
            if (KitchenRunningConstants.RANDOM_EVENT_NPC_IDS.contains(npc.getId()))
                return false;

            if (KitchenRunningConstants.THRALL_IDS.contains(npc.getId()))
                return false;
        }

        if (renderable instanceof Player) {
            Player player = (Player) renderable;

            // draw the local player
            if (player.equals(client.getLocalPlayer()))
                return true;

            // draw the conductor
            if (config.activeConductor() != null && player.getName() != null
                    && player.getName().equalsIgnoreCase(config.activeConductor()))
                return true;

            return shouldRenderOthers(config, player);
        }

        return true;
    }

    private boolean shouldRenderOthers(KitchenRunningConfig config, Player other) {
        boolean playerInCycle = PlayerPositionUtils.isInCycle(config, client.getLocalPlayer());
        boolean otherInCycle = PlayerPositionUtils.isInCycle(config, other);

        HideMode playerCycleConfig = config.hideOtherEntities();

        // Hide other entities when player is following and config is set to hide on following
        if (playerCycleConfig.equals(HideMode.FOLLOWING_CONDUCTOR) && playerInCycle) {
            return false;
        }

		// Hide other entities when player is not following and config is set to hide on not following
        if (playerCycleConfig.equals(HideMode.NOT_FOLLOWING_CONDUCTOR) && !playerInCycle) {
            return false;
        }

		// Hide other entities when config is set to always hide
        if (playerCycleConfig.equals(HideMode.ALWAYS)) {
            return false;
        }

		// Don't hide when config is set to never hide
        if (playerCycleConfig.equals(HideMode.NEVER)) {
            return true;
        }

        return true;
    }

	private NavigationButton createNavButton(int priority) {
		return NavigationButton.builder()
			.tooltip("Kitchen Running")
			.icon(ImageUtil.loadImageResource(getClass(), "/greaves.png"))
			.panel(mainPanel)
			.priority(priority)
			.build();
	}
}

package dev.blonks.kitchenrunning;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class KitchenRunningTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(KitchenRunningPlugin.class);
		RuneLite.main(args);
	}
}
