package dev.blonks.kitchenrunning;

import net.runelite.client.config.*;

import java.awt.*;

@ConfigGroup(KitchenRunningConfig.KITCHEN_GROUP)
public interface KitchenRunningConfig extends Config
{
    String KITCHEN_GROUP = "kitchenrunning";

    @ConfigSection(
            name = "Instructions",
            description = "Look here for instructions",
            position = -1
    )
    String instructions = "instructions";

    @ConfigItem(
            keyName = "kitchenRunningInstructions",
            name = "Instructions",
            description = "A set of instructions on how to use this plugin",
            section = instructions
    )
    default String kitchenRunningInstructions() {
        return "1. Stand on one of the 6 tiles that are highlighted in the lumbridge kitchen\n\n" +
                "2. Enter the username of the player who is conducting the agility circle\n\n" +
                "3. Wait for their highlighted tile to pass yours, and then follow them\n\n" +
                "4. Enjoy the xp";
    }

    @ConfigSection(
            name = "General Settings",
            description = "General settings/config options.",
            position = 0
    )
    String generalConfig = "generalConfig";

    @ConfigItem(
            keyName = "conductorUsername",
            name = "Conductor username",
            description = "The username of the player that is leading the kitchen loop",
            section = generalConfig
    )
    default String conductorUsername()
    {
        return "";
    }


    @ConfigSection(
            name = "Conductor Tile",
            description = "Conductor Tiles Configuration.",
            position = 1
    )
    String conductorTile = "conductorTile";

//    @ConfigItem(
//            keyName = "conductorTile",
//            name = "Conductor tile",
//            description = "Configures when the conductor tile should be drawn",
//            section = conductorTile,
//            position = 0
//    )
//    default CycleState conductorTile() {
//        return CycleState.OUT_OF_CYCLE;
//    }

    @Alpha
    @ConfigItem(
            keyName = "conductorPlayerTileBorder",
            name = "Conductor player tile border",
            description = "Highlights the tile of the conductor",
            section = conductorTile,
            position = 1
    )
    default Color conductorPlayerTileBorder() {
        return Color.CYAN;
    }

    @Alpha
    @ConfigItem(
            keyName = "conductorPlayerTileFill",
            name = "Conductor player tile fill",
            description = "Highlights the tile of the conductor",
            section = conductorTile,
            position = 2
    )
    default Color conductorPlayerTileFill() {
        return new Color(0, 255, 255, 50);
    }


    @ConfigSection(
            name = "Player Tile",
            description = "Player Tile Configuration.",
            position = 2
    )
    String playerTile = "playerTile";

//    @ConfigItem(
//            keyName = "playerTile",
//            name = "Player tile",
//            description = "Configures when the player tile should be drawn",
//            section = playerTile,
//            position = 0
//    )
//    default CycleState playerTile() {
//        return CycleState.OUT_OF_CYCLE;
//    }

    @Alpha
    @ConfigItem(
            keyName = "playerTileBorder",
            name = "Player tile border",
            description = "Highlights the player tile",
            section = playerTile,
            position = 1
    )
    default Color playerTileBorder() {
        return new Color(0, 255, 0, 255);
    }

    @Alpha
    @ConfigItem(
            keyName = "playerTileFill",
            name = "Player tile fill",
            description = "Highlights the player tile",
            section = playerTile,
            position = 2
    )
    default Color playerTileFill() {
        return new Color(0, 255, 0, 50);
    }


    @ConfigSection(
            name = "Starting Tiles",
            description = "Starting Tiles Configuration.",
            position = 3
    )
    String startingTiles = "startingTiles";

//    @ConfigItem(
//            keyName = "startingTiles",
//            name = "Starting tiles",
//            description = "Configures when the starting tiles should be drawn",
//            section = startingTiles,
//            position = 0
//    )
//    default CycleState startingTiles() {
//        return CycleState.OUT_OF_CYCLE;
//    }

    @Alpha
    @ConfigItem(
            keyName = "startingTilesBorder",
            name = "Starting tiles border",
            description = "Highlights the correct starting tiles.",
            section = startingTiles,
            position = 1
    )
    default Color startingTilesBorder() {
        return new Color(255, 255, 255, 255);
    }

    @Alpha
    @ConfigItem(
            keyName = "startingTilesFill",
            name = "Starting tiles fill",
            description = "Highlights the correct starting tiles.",
            section = startingTiles,
            position = 2
    )
    default Color startingTilesFill() {
        return new Color(255, 255, 255, 100);
    }

    @ConfigSection(
            name = "Entity Hider Settings",
            description = "General settings for hiding entities in the area",
            position = 4
    )
    String entityHiderSection = "entityHiderSection";

    @ConfigItem(
            keyName = "hideOtherEntities",
            name = "Hide other entities",
            description = "Configure when other player entities should be hidden so you can find the conductor",
            section = entityHiderSection,
            position = 0
    )
    default CycleState hideOtherEntities() {
        return CycleState.OUT_OF_CYCLE;
    }


    @ConfigSection(
            name = "Notification Settings",
            description = "Configuration of different notifications",
            position = 5
    )
    String notificationSettings = "notificationSettings";

    @ConfigItem(
            keyName = "stoppedFollowing",
            name = "Stopped following notification",
            description = "Configures notifications for when you have stopped following the conductor",
            section = notificationSettings,
            position = 0
    )
    default Notification stoppedFollowing() {
        return Notification.ON;
    }

    @ConfigItem(
            keyName = "conductorAlert",
            name = "Conductor alert notification",
            description = "Configures notifications for when the conductor sends out an alert message",
            section =  notificationSettings,
            position = 1
    )
    default Notification conductorAlert() {
        return Notification.OFF;
    }


}

package dev.blonks.kitchenrunning;

import com.google.common.collect.ImmutableSet;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;

import java.util.Set;

public class KitchenRunnerConstants {
    public static final WorldArea LUMBRIDGE_KITCHEN = new WorldArea(3205, 3212, 8, 6, 0);
    public static final Set<WorldPoint> GOOD_TILES = ImmutableSet.of(
            new WorldPoint(3207, 3213, 0),
            new WorldPoint(3209, 3213, 0),
            new WorldPoint(3211, 3213, 0),
            new WorldPoint(3207, 3215, 0),
            new WorldPoint(3209, 3215, 0),
            new WorldPoint(3211, 3215, 0)
    );
    public static final Set<WorldPoint> BAD_TILES = ImmutableSet.of(
            new WorldPoint(3208, 3215, 0),
            new WorldPoint(3210, 3215, 0),
            new WorldPoint(3211, 3214, 0),
            new WorldPoint(3210, 3213, 0),
            new WorldPoint(3208, 3213, 0),
            new WorldPoint(3207, 3214, 0)
    );
}

package dev.blonks.kitchenrunning;

import com.google.common.collect.ImmutableSet;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.WorldType;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;

import java.util.Set;

public class PlayerPositionUtils {
    public static final WorldArea LUMBRIDGE_KITCHEN = new WorldArea(3205, 3212, 8, 6, 0);
    public static final Set<WorldPoint> GOOD_TILES = ImmutableSet.of(
            new WorldPoint(3207, 3213, 0),
            new WorldPoint(3209, 3213, 0),
            new WorldPoint(3211, 3213, 0),
            new WorldPoint(3207, 3215, 0),
            new WorldPoint(3209, 3215, 0),
            new WorldPoint(3211, 3215, 0)
    );
    public static final Set<WorldPoint> BAD_TILES = ImmutableSet.of(
            new WorldPoint(3208, 3215, 0),
            new WorldPoint(3210, 3215, 0),
            new WorldPoint(3211, 3214, 0),
            new WorldPoint(3210, 3213, 0),
            new WorldPoint(3208, 3213, 0),
            new WorldPoint(3207, 3214, 0)
    );

    public static boolean isInKitchen(Client client) {
        Player localPlayer = client.getLocalPlayer();
        if (localPlayer != null) {
            WorldPoint playerLocation = localPlayer.getWorldLocation();
            return playerLocation.isInArea(LUMBRIDGE_KITCHEN);
        }
        return false;
    }

    public static CycleState getPlayerCycleState(KitchenRunningConfig config, Player player) {
        boolean isOnGoodTile = isOnGoodTile(player);
        boolean isFollowingConductor = isFollowingConductor(config, player);

        if (isOnGoodTile && isFollowingConductor)
            return CycleState.IN_CYCLE;

        return CycleState.OUT_OF_CYCLE;
    }

    public static boolean isInCycle(KitchenRunningConfig config, Player player) {
        return isOnTileSet(player, GOOD_TILES) && isFollowingConductor(config, player);
    }

    public static boolean isOnGoodTile(Player player) {
        return isOnTileSet(player, GOOD_TILES);
    }

    public static boolean isOnBadTile(Player player) {
        return isOnTileSet(player, BAD_TILES);
    }

    private static boolean isOnTileSet(Player player, Set<WorldPoint> tileSet) {
        if (player == null)
            return false;

        WorldPoint worldPoint = player.getWorldLocation();
        if (worldPoint == null)
            return false;

        for (WorldPoint point : tileSet) {
            if (point.distanceTo(worldPoint) == 0)
                return true;
        }
        return false;
    }

    public static LocalPoint getLocalPoint(Client client, Player player) {
        if (player == null)
            return null;

        WorldPoint worldPoint = player.getWorldLocation();
        if (worldPoint == null)
            return null;

        return LocalPoint.fromWorld(client, worldPoint);
    }

    public static boolean isFollowingConductor(KitchenRunningConfig config, Player player) {
        if (player == null)
            return false;

        Actor interacting = player.getInteracting();
        if (interacting == null)
            return false;

        String actorName = interacting.getName();
        if (actorName == null)
            return false;

        return actorName.equalsIgnoreCase(config.conductorUsername());
    }

    public static boolean isPvpOrNonLeagues(Client client) {
        // render everyone on pvp worlds
        if (WorldType.isPvpWorld(client.getWorldType())) {
            return true;
        }

        // render everyone when its not a seasonal or tournament world (i.e. leagues or grid master)
        if (!client.getWorldType().contains(WorldType.SEASONAL) && !client.getWorldType().contains(WorldType.TOURNAMENT_WORLD)) {
            return true;
        }

        return false;
    }
}

package dev.blonks.kitchenrunning;

import com.google.common.collect.ImmutableSet;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Player;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.inject.Inject;
import java.awt.*;
import java.util.Optional;
import java.util.Set;

public class KitchenRunningOverlay extends Overlay {
    private final Client client;
    private final KitchenRunningConfig config;


    @Inject
    private KitchenRunningOverlay(Client client, KitchenRunningConfig config) {
        this.client = client;
        this.config = config;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
        setPriority(PRIORITY_MED);
    }

    @Override
    public Dimension render(Graphics2D graphics2D) {
        if (!PlayerPositionUtils.isInKitchen(client)) {
            return null;
        }

        if (PlayerPositionUtils.isPvpOrNonLeagues(client)) {
            return null;
        }

        // renders good tile starting point markers
        boolean isOnGoodTile = PlayerPositionUtils.isOnGoodTile(client.getLocalPlayer());
        if (!isOnGoodTile) {
            for (WorldPoint point : PlayerPositionUtils.GOOD_TILES) {
                renderPlayerTile(graphics2D, LocalPoint.fromWorld(client, point), config.startingTilesBorder(), config.startingTilesFill());
            }
        }

        // renders nothing if the player is in cycle
        if (PlayerPositionUtils.isFollowingConductor(config, client.getLocalPlayer()) && isOnGoodTile)
            return null;

        final LocalPoint playerLocalPoint = PlayerPositionUtils.getLocalPoint(client, client.getLocalPlayer());
        if (playerLocalPoint == null)
            return null;


        Optional<? extends Player> conductorPlayer = client.getTopLevelWorldView().players().stream()
                .filter(player -> player.getName().equalsIgnoreCase(config.conductorUsername()))
                .findFirst();

        if (conductorPlayer.isEmpty())
            return null;

        WorldPoint conductorWorldPoint = conductorPlayer.get().getWorldLocation();
        if (conductorWorldPoint == null)
            return null;

        final LocalPoint conductorLocalPoint = LocalPoint.fromWorld(client, conductorWorldPoint);

        renderPlayerTile(graphics2D, playerLocalPoint, config.playerTileBorder(), config.playerTileFill());
        renderPlayerTile(graphics2D, conductorLocalPoint, config.conductorPlayerTileBorder(), config.conductorPlayerTileFill());

        return null;
    }

    private void renderPlayerTile(Graphics2D graphics2D, final LocalPoint tile, Color borderColor, Color fillColor) {
        if (tile == null)
            return;

        final Polygon polygon = Perspective.getCanvasTilePoly(client, tile);

        if (polygon == null)
            return;

        OverlayUtil.renderPolygon(graphics2D, polygon, borderColor, fillColor, new BasicStroke((float) 2));
    }
}

package dev.blonks.kitchenrunning;

import com.google.common.collect.ImmutableSet;
import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.gameval.NpcID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.Hooks;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

import javax.inject.Inject;
import java.util.Set;

@Slf4j
@PluginDescriptor(
	name = "Kitchen Runner",
    description = "Helpful utilities for getting in cycle with the Sage's Greaves",
    tags = {"greaves", "leagues", "kitchen", "fountain", "grid", "gridmaster", "grid master"}
)
public class KitchenRunningPlugin extends Plugin
{
    private boolean overlayEnabled = false;

    private static final Set<Integer> THRALL_IDS = ImmutableSet.of(
            NpcID.ARCEUUS_THRALL_GHOST_LESSER, NpcID.ARCEUUS_THRALL_SKELETON_LESSER, NpcID.ARCEUUS_THRALL_ZOMBIE_LESSER,  // Lesser Thrall (ghost, skeleton, zombie)
            NpcID.ARCEUUS_THRALL_GHOST_SUPERIOR, NpcID.ARCEUUS_THRALL_SKELETON_SUPERIOR, NpcID.ARCEUUS_THRALL_ZOMBIE_SUPERIOR,  // Superior Thrall (ghost, skeleton, zombie)
            NpcID.ARCEUUS_THRALL_GHOST_GREATER, NpcID.ARCEUUS_THRALL_SKELETON_GREATER, NpcID.ARCEUUS_THRALL_ZOMBIE_GREATER   // Greater Thrall (ghost, skeleton, zombie)
    );
    private static final Set<Integer> RANDOM_EVENT_NPC_IDS = ImmutableSet.of(
            NpcID.MACRO_BEEKEEPER_INVITATION,
            NpcID.MACRO_COMBILOCK_PIRATE,
            NpcID.MACRO_JEKYLL, NpcID.MACRO_JEKYLL_UNDERWATER,
            NpcID.MACRO_DWARF,
            NpcID.PATTERN_INVITATION,
            NpcID.MACRO_EVIL_BOB_OUTSIDE, NpcID.MACRO_EVIL_BOB_PRISON,
            NpcID.PINBALL_INVITATION,
            NpcID.MACRO_FORESTER_INVITATION,
            NpcID.MACRO_FROG_CRIER, NpcID.MACRO_FROG_GENERIC, NpcID.MACRO_FROG_SULKING, NpcID.MACRO_FROG_NONCOMBAT, NpcID.MACRO_FROG_NOHAT, NpcID.MACRO_FROG_PRIN_HE, NpcID.MACRO_FROG_PRIN_SHE, NpcID.MACRO_FROG_PRIN_A, NpcID.MACRO_FROG_PRIN_B,
            NpcID.MACRO_GENI, NpcID.MACRO_GENI_UNDERWATER,
            NpcID.MACRO_GILES, NpcID.MACRO_GILES_UNDERWATER,
            NpcID.MACRO_GRAVEDIGGER_INVITATION,
            NpcID.MACRO_MILES, NpcID.MACRO_MILES_UNDERWATER,
            NpcID.MACRO_MYSTERIOUS_OLD_MAN, NpcID.MACRO_MYSTERIOUS_OLD_MAN_UNDERWATER,
            NpcID.MACRO_MAZE_INVITATION, NpcID.MACRO_MIME_INVITATION,
            NpcID.MACRO_NILES, NpcID.MACRO_NILES_UNDERWATER,
            NpcID.MACRO_PILLORY_GUARD,
            NpcID.GRAB_POSTMAN,
            NpcID.MACRO_MAGNESON_INVITATION,
            NpcID.MACRO_HIGHWAYMAN, NpcID.MACRO_HIGHWAYMAN_UNDERWATER,
            NpcID.MACRO_SANDWICH_LADY_NPC,
            NpcID.MACRO_DRILLDEMON_INVITATION,
            NpcID.MACRO_COUNTCHECK_SURFACE, NpcID.MACRO_COUNTCHECK_UNDERWATER
    );

	@Inject
	private Client client;

	@Inject
	private KitchenRunningConfig config;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private Notifier notifier;

    @Inject
    private Hooks hooks;
    private final Hooks.RenderableDrawListener renderableDrawListener = this::shouldDraw;

    private IndexedObjectSet<? extends Player> localPlayers;

    @Inject
    private KitchenRunningOverlay overlay;

    private boolean inKitchen = false;
	private boolean wasFollowingConductor = false;

    @Provides
    KitchenRunningConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(KitchenRunningConfig.class);
    }

    @Override
    protected void startUp() throws Exception
    {
        log.info("startup");
        checkLocation();
        overlayManager.add(overlay);
        hooks.registerRenderableDrawListener(renderableDrawListener);
    }

    @Override
    protected void shutDown() throws Exception {
        overlayManager.remove(overlay);
        hooks.unregisterRenderableDrawListener(renderableDrawListener);
    }

    @Subscribe
    public void onGameTick(GameTick e) {
        checkLocation();
    }

    @Subscribe
    public void onInteractingChanged(InteractingChanged e) {
        Player local = client.getLocalPlayer();
        if (local == null)
            return;

        if (!local.equals(e.getSource()))
            return;


		boolean isFollowingConductor = PlayerPositionUtils.isFollowingConductor(config, local);
		if (wasFollowingConductor && !isFollowingConductor)
		{
			wasFollowingConductor = false;
			notifier.notify(config.stoppedFollowing(), "You are no longer following the conductor!");
		} else if (isFollowingConductor)
		{
			wasFollowingConductor = true;
		}
    }

    @Subscribe
    public void onChatMessage(ChatMessage e) {
        if (!e.getType().equals(ChatMessageType.PUBLICCHAT))
            return;

        if (e.getName() == null)
            return;

        if (!inKitchen)
            return;

        String senderName = e.getName();
        senderName = senderName.substring(Math.max(senderName.indexOf('>')+1, 1));
        if (senderName.equalsIgnoreCase(config.conductorUsername())) {
            if (e.getMessage().toLowerCase().startsWith("alert:"))
                notifier.notify(config.conductorAlert(), "The conductor says: " + e.getMessage().toLowerCase().replace("alert:", ""));
        }
    }

    private void checkLocation() {
        boolean newIsKitchen = PlayerPositionUtils.isInKitchen(client);

        if (newIsKitchen == inKitchen)
            return;

        inKitchen = newIsKitchen;

        if (inKitchen) {
            // have moved into the kitchen

        } else {
            // have left the kitchen
        }


    }

    private boolean shouldDraw(Renderable renderable, boolean b) {
        // always draw others outside of the kitchen
        if (!inKitchen)
            return true;

        if (PlayerPositionUtils.isPvpOrNonLeagues(client)) {
            return true;
        }

        // entity hider settings are disabled
        if (config.hideOtherEntities().equals(CycleState.NONE))
            return true;

        if (renderable instanceof NPC) {
            NPC npc = (NPC) renderable;
            if (RANDOM_EVENT_NPC_IDS.contains(npc.getId()))
                return false;

            if (THRALL_IDS.contains(npc.getId()))
                return false;
        }

        if (renderable instanceof Player) {
            Player player = (Player) renderable;

            // draw the local player
            if (player.equals(client.getLocalPlayer()))
                return true;

            // draw the conductor
            if (config.conductorUsername() != null && player.getName() != null
                    && player.getName().equalsIgnoreCase(config.conductorUsername()))
                return true;

            return shouldRender(config, player);
        }

        return true;
    }

    private boolean shouldRender(KitchenRunningConfig config, Player other) {
        boolean playerInCycle = PlayerPositionUtils.isInCycle(config, client.getLocalPlayer());
        boolean otherInCycle = PlayerPositionUtils.isInCycle(config, other);

        CycleState playerCycleConfig = config.hideOtherEntities();

        // guard statement that returns when the current player state is not in line with when entities should hide
        if (playerCycleConfig.equals(CycleState.IN_CYCLE) && playerInCycle) {
            return false;
        }

        if (playerCycleConfig.equals(CycleState.OUT_OF_CYCLE) && !playerInCycle) {
            return false;
        }

        if (playerCycleConfig.equals(CycleState.BOTH)) {
            return false;
        }

        if (playerCycleConfig.equals(CycleState.NONE)) {
            return true;
        }

        return true;
    }



    private void disableOverlay() {
        if (overlayEnabled)
            overlayEnabled = false;
    }


}

package dev.blonks.kitchenrunning;

public enum CycleState {
    IN_CYCLE,
    OUT_OF_CYCLE,
    BOTH,
    NONE
}

package dev.blonks.kitchenrunning;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class KitchenRunningTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(KitchenRunningPlugin.class);
		RuneLite.main(args);
	}
}
