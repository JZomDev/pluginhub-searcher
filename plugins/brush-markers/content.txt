/*
 * Copyright (c) 2018, TheLonelyDev <https://github.com/TheLonelyDev>
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * Copyright (c) 2020, Bram91 <https://github.com/Bram91>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.bram91.brushmarkers;

import java.awt.Color;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Keybind;
import net.runelite.client.config.Range;

@ConfigGroup("brushMarkers")
public interface BrushMarkerConfig extends Config
{
	@ConfigSection(
		name = "Color Palette",
		description = "Contains all the colors",
		position = 0,
		closedByDefault = true
	)
	String colorSection = "colors";

	@Alpha
	@ConfigItem(
		keyName = "brushColor1",
		name = "Color1",
		description = "Configures the color of marked tile",
		section = colorSection,
		position = 0
	)
	default Color markerColor1()
	{
		return Color.RED;
	}

	@Alpha
	@ConfigItem(
		keyName = "brushColor2",
		name = "Color 2",
		description = "Configures the color of marked tile",
		section = colorSection,
		position = 1
	)
	default Color markerColor2()
	{
		return Color.GREEN;
	}

	@Alpha
	@ConfigItem(
		keyName = "brushColor3",
		name = "Color 3",
		description = "Configures the color of marked tile",
		section = colorSection,
		position = 2
	)
	default Color markerColor3()
	{
		return Color.BLUE;
	}

	@Alpha
	@ConfigItem(
		keyName = "brushColor4",
		name = "Color 4",
		description = "Configures the color of marked tile",
		section = colorSection,
		position = 3
	)
	default Color markerColor4()
	{
		return Color.YELLOW;
	}

	@Alpha
	@ConfigItem(
		keyName = "brushColor5",
		name = "Color 5",
		description = "Configures the color of marked tile",
		section = colorSection,
		position = 4
	)
	default Color markerColor5()
	{
		return Color.CYAN;
	}

	@Alpha
	@ConfigItem(
		keyName = "brushColor6",
		name = "Color 6",
		description = "Configures the color of marked tile",
		section = colorSection,
		position = 5
	)
	default Color markerColor6()
	{
		return Color.MAGENTA;
	}

	@ConfigItem(
		keyName = "brushdDoubleColors",
		name = "Enable color 7-12",
		description = "Enables color 7-12 for double the fun!",
		section = colorSection,
		position = 6
	)
	default boolean doubleColors()
	{
		return false;
	}

	@Alpha
	@ConfigItem(
		keyName = "brushColor7",
		name = "Color 7",
		description = "Configures the color of marked tile",
		section = colorSection,
		position = 7
	)
	default Color markerColor7()
	{
		return Color.RED;
	}

	@Alpha
	@ConfigItem(
		keyName = "brushColor8",
		name = "Color 8",
		description = "Configures the color of marked tile",
		section = colorSection,
		position = 8
	)
	default Color markerColor8()
	{
		return Color.GREEN;
	}

	@Alpha
	@ConfigItem(
		keyName = "brushColor9",
		name = "Color 9",
		description = "Configures the color of marked tile",
		section = colorSection,
		position = 9
	)
	default Color markerColor9()
	{
		return Color.BLUE;
	}

	@Alpha
	@ConfigItem(
		keyName = "brushColor10",
		name = "Color 10",
		description = "Configures the color of marked tile",
		section = colorSection,
		position = 10
	)
	default Color markerColor10()
	{
		return Color.YELLOW;
	}

	@Alpha
	@ConfigItem(
		keyName = "brushColor11",
		name = "Color 11",
		description = "Configures the color of marked tile",
		section = colorSection,
		position = 11
	)
	default Color markerColor11()
	{
		return Color.CYAN;
	}

	@Alpha
	@ConfigItem(
		keyName = "brushColor12",
		name = "Color 12",
		description = "Configures the color of marked tile",
		section = colorSection,
		position = 12
	)
	default Color markerColor12()
	{
		return Color.MAGENTA;
	}

	@ConfigItem(
		keyName = "brushdrawOnMinimap",
		name = "Draw tiles on minimap",
		description = "Configures whether marked tiles should be drawn on minimap",
		position = 2
	)
	default boolean drawTileOnMinimmap()
	{
		return false;
	}

	@ConfigItem(
		keyName = "brushdrawOnworldmap",
		name = "Draw tiles on worldmap",
		description = "Configures whether marked tiles should be drawn on the worldmap",
		position = 3
	)
	default boolean drawTilesOnWorldMap()
	{
		return false;
	}

	@ConfigItem(
		keyName = "brushreplaceMode",
		name = "Replace mode",
		description = "Allows you to draw over existing tiles",
		position = 4
	)
	default boolean replaceMode()
	{
		return false;
	}

	@ConfigItem(
		keyName = "brushFillPoly",
		name = "Fill tiles",
		description = "Fills the tiles you have drawn.",
		position = 5
	)
	default boolean fillPoly()
	{
		return false;
	}

	@Range(
		max = 128
	)
	@ConfigItem(
		keyName = "brushPolyAlpha",
		name = "Set fill transparency",
		description = "Allows you to change the transparency of the tile fill.",
		position = 6
	)
	default int polyAlpha()
	{
		return 64;
	}

	@ConfigItem(
		keyName = "brushBorderWidth",
		name = "Tile border width",
		description = "Set the width of the tile borders.",
		position = 7
	)
	default double strokeWidth()
	{
		return 2;
	}

	@ConfigItem(
		keyName = "brushSize",
		name = "Brush Size",
		description = "Changes the brush size",
		position = 8
	)
	default BrushSize brushSize()
	{
		return BrushSize.ONE;
	}

	@ConfigItem(
		keyName = "brushpaintMode",
		name = "Paint Mode",
		description = "Enables paint mode",
		position = 9
	)
	default boolean paintMode()
	{
		return false;
	}

	@ConfigItem(
		keyName = "brushHotkey",
		name = "Brush Hotkey",
		description = "Enables paint mode through a hotkey",
		position = 10
	)
	default Keybind brushHotkey()
	{
		return null;
	}
}

/*
 * Copyright (c) 2019, Benjamin <https://github.com/genetic-soybean>
 * Copyright (c) 2020, Bram91 <https://github.com/Bram91>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.bram91.brushmarkers;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.util.Collection;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

class BrushMarkerMinimapOverlay extends Overlay
{
	private static final int[][] RECT_TRANSFORMS = {
		{ 0, 0 },
		{ 0, Perspective.LOCAL_TILE_SIZE },
		{ Perspective.LOCAL_TILE_SIZE, Perspective.LOCAL_TILE_SIZE },
		{ Perspective.LOCAL_TILE_SIZE, 0 }
	};

	private final Client client;
	private final BrushMarkerConfig config;
	private final BrushMarkerPlugin plugin;

	@Inject
	private BrushMarkerMinimapOverlay(Client client, BrushMarkerConfig config, BrushMarkerPlugin plugin)
	{
		this.client = client;
		this.config = config;
		this.plugin = plugin;
		setPosition(OverlayPosition.DYNAMIC);
		setPriority(PRIORITY_LOW);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!config.drawTileOnMinimmap())
		{
			return null;
		}

		final Collection<ColorTileMarker> points = plugin.getPoints();
		for (final ColorTileMarker point : points)
		{
			WorldPoint worldPoint = point.getWorldPoint();
			if (worldPoint.getPlane() != client.getPlane())
			{
				continue;
			}

			Color tileColor = point.getColor();
			if (tileColor == null)
			{
				// If this is an old tile which has no color, or rememberTileColors is off, use marker color
				tileColor = plugin.getColor();
			}

			drawOnMinimap(graphics, worldPoint, tileColor);
		}

		return null;
	}

	private void drawOnMinimap(Graphics2D graphics, WorldPoint point, Color color)
	{
		if (!point.isInScene(client))
		{
			return;
		}

		int x = (point.getX() - client.getBaseX()) << Perspective.LOCAL_COORD_BITS;
		int y = (point.getY() - client.getBaseY()) << Perspective.LOCAL_COORD_BITS;
		int maxDist = (int) ((20 << Perspective.LOCAL_COORD_BITS) * 4.0 / client.getMinimapZoom());

		Polygon rect = new Polygon();
		for (int[] transform : RECT_TRANSFORMS)
		{
			LocalPoint vertex = new LocalPoint(x + transform[0], y + transform[1]);
			Point mp = Perspective.localToMinimap(client, vertex, maxDist);
			if (mp == null)
			{
				return;
			}
			rect.addPoint(mp.getX(), mp.getY());
		}

		graphics.setColor(color);
		graphics.setStroke(new BasicStroke());
		graphics.drawPolygon(rect);
	}
}

/*
 * Copyright (c) 2018, TheLonelyDev <https://github.com/TheLonelyDev>
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * Copyright (c) 2020, Bram91 <https://github.com/Bram91>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.bram91.brushmarkers;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Polygon;
import java.awt.image.BufferedImage;
import java.util.Collection;
import java.util.ConcurrentModificationException;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

public class BrushMarkerOverlay extends Overlay
{
	private static final int MAX_DRAW_DISTANCE = 32;

	private final Client client;
	private final BrushMarkerConfig config;
	private final BrushMarkerPlugin plugin;
	@Inject
	ItemManager itemManager;

	@Inject
	private BrushMarkerOverlay(Client client, BrushMarkerConfig config, BrushMarkerPlugin plugin)
	{
		this.client = client;
		this.config = config;
		this.plugin = plugin;
		setPosition(OverlayPosition.DYNAMIC);
		setPriority(PRIORITY_LOW);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		final Collection<ColorTileMarker> points = plugin.getPoints();
		try
		{
			for (final ColorTileMarker point : points)
			{
				WorldPoint worldPoint = point.getWorldPoint();
				if (worldPoint.getPlane() != client.getPlane())
				{
					continue;
				}

				Color tileColor = point.getColor();
				if (tileColor == null)
				{
					// If this is an old tile which has no color, or rememberTileColors is off, use marker color
					tileColor = plugin.getColor();
				}

				drawTile(graphics, worldPoint, tileColor);
			}

			if (config.paintMode() && client.getSelectedSceneTile() != null)
			{
				final Polygon poly = Perspective.getCanvasTileAreaPoly(client, client.getSelectedSceneTile().getLocalLocation(), config.brushSize().getSize());

				if (poly != null)
				{
					final BufferedImage image = resize(itemManager.getImage(670), poly.getBounds().width, poly.getBounds().height);
					final Point imageLoc = Perspective.getCanvasImageLocation(client, client.getSelectedSceneTile().getLocalLocation(), image, 0);
					OverlayUtil.renderImageLocation(graphics, imageLoc, image);
					OverlayUtil.renderPolygon(graphics, poly, plugin.getColor());
				}
			}
		}
		catch(ConcurrentModificationException e)
		{

		}

		return null;
	}

	public static BufferedImage resize(BufferedImage img, int newW, int newH)
	{
		if(newH > img.getHeight() || newW > img.getWidth())
		{
			return img;
		}
		Image tmp = img.getScaledInstance(newW / 2, newH / 2, Image.SCALE_SMOOTH);
		BufferedImage dimg = new BufferedImage(newW / 2, newH / 2, BufferedImage.TYPE_INT_ARGB);

		Graphics2D g2d = dimg.createGraphics();
		g2d.drawImage(tmp, 0, 0, null);
		g2d.dispose();

		return dimg;
	}

	private void drawTile(Graphics2D graphics, WorldPoint point, Color color)
	{
		WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();

		if (point.distanceTo(playerLocation) >= MAX_DRAW_DISTANCE)
		{
			return;
		}

		LocalPoint lp = LocalPoint.fromWorld(client, point);
		if (lp == null)
		{
			return;
		}

		Polygon poly = Perspective.getCanvasTilePoly(client, lp);
		if (poly == null)
		{
			return;
		}
		if (config.fillPoly())
		{
			graphics.setColor(new Color(color.getRed(), color.getGreen(), color.getBlue(), config.polyAlpha()));
			graphics.fillPolygon(poly);
		}
		OverlayUtil.renderPolygon(graphics, poly, color, new BasicStroke((float) config.strokeWidth()));
	}
}

/*
 * Copyright (c) 2018, TheLonelyDev <https://github.com/TheLonelyDev>
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * Copyright (c) 2020, Bram91 <https://github.com/Bram91>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.bram91.brushmarkers;

import com.google.common.base.Strings;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Provides;
import java.awt.Color;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Stack;
import java.util.stream.Collectors;
import javax.inject.Inject;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.HotkeyListener;

@Slf4j
@PluginDescriptor(
	name = "Brush Markers",
	description = "Enable marking of tiles using the Shift key",
	tags = {"overlay", "tiles", "paint"}
)
public class BrushMarkerPlugin extends Plugin implements KeyListener
{
	private static final String CONFIG_GROUP = "brushMarkers";
	private static final String REGION_PREFIX = "region_";
	private static final String PAINT_MODE = "brushpaintMode";

	@Inject
	private Gson gson;

	@Getter(AccessLevel.PACKAGE)
	private final List<ColorTileMarker> points = new ArrayList<>();

	@Inject
	private Client client;

	@Inject
	private BrushMarkerConfig config;

	@Inject
	private ConfigManager configManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private BrushMarkerOverlay overlay;

	@Inject
	private PaintModeOverlay paintOverlay;

	@Inject
	private BrushMarkerMinimapOverlay minimapOverlay;

	@Inject
	private BrushMarkerWorldmapOverlay worldmapOverlay;

	@Inject
	private KeyManager keyManager;

	private boolean ctrlHeld;
	private boolean shiftHeld;
	private int currentColor = 0;
	private Stack<BrushMemento> undoStack;
	private Stack<BrushMemento> redoStack;
	private Color pickedColor;

	private void savePoints(int regionId, Collection<BrushMarkerPoint> points)
	{
		if (points == null || points.isEmpty())
		{
			configManager.unsetConfiguration(CONFIG_GROUP, REGION_PREFIX + regionId);
			return;
		}

		String json = gson.toJson(points);
		configManager.setConfiguration(CONFIG_GROUP, REGION_PREFIX + regionId, json);
	}

	private Collection<BrushMarkerPoint> getPoints(int regionId)
	{
		String json = configManager.getConfiguration(CONFIG_GROUP, REGION_PREFIX + regionId);
		if (Strings.isNullOrEmpty(json))
		{
			return Collections.emptyList();
		}

		// CHECKSTYLE:OFF
		return gson.fromJson(json, new TypeToken<List<BrushMarkerPoint>>()
		{
		}.getType());
		// CHECKSTYLE:ON
	}

	public Collection<BrushMarkerPoint> getWorldPoints(int regionId)
	{
		String json = configManager.getConfiguration(CONFIG_GROUP, REGION_PREFIX + regionId);
		if (Strings.isNullOrEmpty(json))
		{
			return Collections.emptyList();
		}

		// CHECKSTYLE:OFF
		return gson.fromJson(json, new TypeToken<List<BrushMarkerPoint>>()
		{
		}.getType());
		// CHECKSTYLE:ON
	}

	@Provides
	BrushMarkerConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(BrushMarkerConfig.class);
	}

	private void loadPoints()
	{
		points.clear();

		int[] regions = client.getMapRegions();

		if (regions == null)
		{
			return;
		}

		for (int regionId : regions)
		{
			// load points for region
			log.debug("Loading points for region {}", regionId);
			Collection<BrushMarkerPoint> regionPoints = getPoints(regionId);
			Collection<ColorTileMarker> colorTileMarkers = translateToColorTileMarker(regionPoints);
			points.addAll(colorTileMarkers);
		}
	}

	/**
	 * Translate a collection of ground marker points to color tile markers, accounting for instances
	 *
	 * @param points {@link BrushMarkerPoint}s to be converted to {@link ColorTileMarker}s
	 * @return A collection of color tile markers, converted from the passed ground marker points, accounting for local
	 * instance points. See {@link WorldPoint#toLocalInstance(Client, WorldPoint)}
	 */
	private Collection<ColorTileMarker> translateToColorTileMarker(Collection<BrushMarkerPoint> points)
	{
		if (points.isEmpty())
		{
			return Collections.emptyList();
		}

		return points.stream()
			.map(point -> new ColorTileMarker(
				WorldPoint.fromRegion(point.getRegionId(), point.getRegionX(), point.getRegionY(), point.getZ()),
				point.getColor()))
			.flatMap(colorTile ->
			{
				final Collection<WorldPoint> localWorldPoints = WorldPoint.toLocalInstance(client, colorTile.getWorldPoint());
				return localWorldPoints.stream().map(wp -> new ColorTileMarker(wp, colorTile.getColor()));
			})
			.collect(Collectors.toList());
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		if (gameStateChanged.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		// map region has just been updated
		loadPoints();
	}

	@Override
	protected void startUp()
	{
		overlayManager.add(overlay);
		overlayManager.add(paintOverlay);
		overlayManager.add(minimapOverlay);
		overlayManager.add(worldmapOverlay);
		keyManager.registerKeyListener(this);
		undoStack = new Stack<>();
		redoStack = new Stack<>();
		loadPoints();
	}

	@Override
	protected void shutDown()
	{
		overlayManager.remove(overlay);
		overlayManager.remove(paintOverlay);
		overlayManager.remove(minimapOverlay);
		overlayManager.remove(worldmapOverlay);
		keyManager.unregisterKeyListener(this);
		points.clear();
	}

	@Override
	public void keyPressed(KeyEvent e)
	{
		if (!config.paintMode())
		{
			return;
		}
		if (e.getKeyCode() == KeyEvent.VK_TAB)
		{
			if (config.doubleColors())
			{
				if (currentColor >= 11)
				{
					currentColor = 0;
				}
				else
				{
					currentColor++;
				}
			}
			else
			{
				if (currentColor >= 5)
				{
					currentColor = 0;
				}
				else
				{
					currentColor++;
				}
			}

			e.consume();
		}
		if (e.getKeyCode() == KeyEvent.VK_BACK_QUOTE)
		{
			if (config.doubleColors())
			{
				if (currentColor <= 0)
				{
					currentColor = 11;
				}
				else
				{
					currentColor--;
				}
			}
			else
			{
				if (currentColor <= 0)
				{
					currentColor = 5;
				}
				else
				{
					currentColor--;
				}
			}
		}
		else if (e.getKeyCode() == KeyEvent.VK_CONTROL)
		{
			ctrlHeld = true;
		}
		else if (e.getKeyCode() == KeyEvent.VK_SHIFT)
		{
			shiftHeld = true;
		}
	}

	@Override
	public void keyReleased(KeyEvent e)
	{
		if (e.getKeyCode() == KeyEvent.VK_CONTROL)
		{
			ctrlHeld = false;
		}
		else if (e.getKeyCode() == KeyEvent.VK_SHIFT)
		{
			shiftHeld = false;
		}
		else if (config.paintMode() && e.getKeyCode() == KeyEvent.VK_Z)
		{
			undo();
		}
		else if (config.paintMode() && e.getKeyCode() == KeyEvent.VK_X)
		{
			redo();
		}
		else if (config.paintMode() && e.getKeyCode() == KeyEvent.VK_Q)
		{
			pickColor();
		}

		else if(config.brushHotkey() != null && config.brushHotkey().getKeyCode() == e.getKeyCode())
		{
			configManager.setConfiguration(CONFIG_GROUP, PAINT_MODE, !config.paintMode());
		}
	}

	private void pickColor()
	{
		if(client.getSelectedSceneTile() != null)
		{
			WorldPoint worldPoint = WorldPoint.fromLocalInstance(client, client.getSelectedSceneTile().getLocalLocation());
			int regionId = worldPoint.getRegionID();
			List<BrushMarkerPoint> brushMarkerPoints = new ArrayList<>(getPoints(regionId));
			BrushMarkerPoint point = new BrushMarkerPoint(regionId, worldPoint.getRegionX(), worldPoint.getRegionY(), client.getPlane(), getColor());
			if(brushMarkerPoints.contains(point))
			{
				for (BrushMarkerPoint markerPoint : brushMarkerPoints)
				{
					if (markerPoint.getRegionY() == point.getRegionY() && markerPoint.getRegionX() == point.getRegionX())
					{
						pickedColor = markerPoint.getColor();
						currentColor = 12;
						break;
					}
				}
			}
		}
	}

	@Override
	public void keyTyped(KeyEvent e)
	{

	}


	@Subscribe
	public void onClientTick(ClientTick tick)
	{
		if (config.paintMode() && client.getSelectedSceneTile() != null)
		{
			WorldPoint worldPoint = WorldPoint.fromLocalInstance(client, client.getSelectedSceneTile().getLocalLocation());
			int regionId = worldPoint.getRegionID();
			BrushMarkerPoint point = new BrushMarkerPoint(regionId, worldPoint.getRegionX(), worldPoint.getRegionY(), client.getPlane(), getColor());

			List<BrushMarkerPoint> brushMarkerPoints = new ArrayList<>(getPoints(regionId));

			if (shiftHeld)
			{
				for (BrushMarkerPoint brushMarkerPoint : getSelectedTiles(point))
				{
					if (brushMarkerPoint.getRegionX() >= 0 && brushMarkerPoint.getRegionX() < 64 && brushMarkerPoint.getRegionY() >= 0 && brushMarkerPoint.getRegionY() < 64)
					{
						redoStack.clear();
						if (config.replaceMode() && brushMarkerPoints.contains(brushMarkerPoint))
						{
							for (BrushMarkerPoint markerPoint : brushMarkerPoints)
							{
								if (markerPoint.getRegionY() == brushMarkerPoint.getRegionY() && markerPoint.getRegionX() == brushMarkerPoint.getRegionX())
								{
									if (undoStack.size() == 0 || !undoStack.peek().getPoint().equals(markerPoint))
									{
										undoStack.push(new BrushMemento(markerPoint, false));
									}
									break;
								}
							}
						}
						if (undoStack.size() == 0 || !undoStack.peek().getPoint().equals(brushMarkerPoint))
						{
							undoStack.push(new BrushMemento(brushMarkerPoint, true));
						}
						if (config.replaceMode())
						{
							brushMarkerPoints.remove(brushMarkerPoint);
							brushMarkerPoints.add(brushMarkerPoint);
						}
						else if (!brushMarkerPoints.contains(brushMarkerPoint))
						{
							brushMarkerPoints.add(brushMarkerPoint);
						}
					}
				}
				savePoints(regionId, brushMarkerPoints);
				loadPoints();
			}
			else if (ctrlHeld)
			{
				redoStack.clear();
				for (BrushMarkerPoint brushMarkerPoint : getSelectedTiles(point))
				{
					if (brushMarkerPoints.contains(brushMarkerPoint))
					{
						for (BrushMarkerPoint markerPoint : brushMarkerPoints)
						{
							if (markerPoint.getRegionY() == brushMarkerPoint.getRegionY() && markerPoint.getRegionX() == brushMarkerPoint.getRegionX())
							{
								undoStack.push(new BrushMemento(markerPoint, false));
								break;
							}
						}
					}
					brushMarkerPoints.remove(brushMarkerPoint);
				}

				savePoints(regionId, brushMarkerPoints);

				loadPoints();
			}
		}
	}

	public ArrayList<BrushMarkerPoint> getSelectedTiles(BrushMarkerPoint point)
	{
		ArrayList<BrushMarkerPoint> points = new ArrayList<>();
		int size = config.brushSize().getSize();
		int offset = size / 2;

		for (int x = 0; x < size; x++)
		{
			for (int y = 0; y < size; y++)
			{
				points.add(new BrushMarkerPoint(point.getRegionId(), point.getRegionX() + x - offset, point.getRegionY() + y - offset, point.getZ(), point.getColor()));
			}
		}
		log.trace("{}-{}", size, offset);
		return points;
	}

	public void undo()
	{
		if (undoStack.size() == 0)
		{
			return;
		}
		BrushMemento memento = undoStack.pop();
		redoStack.push(memento);
		List<BrushMarkerPoint> brushMarkerPoints = new ArrayList<>(getPoints(memento.getPoint().getRegionId()));
		if (!memento.isDraw())
		{
			while(brushMarkerPoints.contains(memento.getPoint()))
			{
				brushMarkerPoints.remove(memento.getPoint());
			}
			brushMarkerPoints.add(memento.getPoint());
		}
		else
		{
			while(brushMarkerPoints.contains(memento.getPoint()))
			{
				brushMarkerPoints.remove(memento.getPoint());
			}
		}
		savePoints(memento.getPoint().getRegionId(), brushMarkerPoints);
		loadPoints();
	}

	public void redo()
	{
		if (redoStack.size() == 0)
		{
			return;
		}
		BrushMemento memento = redoStack.pop();
		undoStack.push(memento);
		List<BrushMarkerPoint> brushMarkerPoints = new ArrayList<>(getPoints(memento.getPoint().getRegionId()));
		if (memento.isDraw())
		{
			brushMarkerPoints.remove(memento.getPoint());
			brushMarkerPoints.add(memento.getPoint());
		}
		else
		{
			brushMarkerPoints.remove(memento.getPoint());
		}
		savePoints(memento.getPoint().getRegionId(), brushMarkerPoints);
		loadPoints();
	}

	public Color getColor()
	{
		switch (currentColor)
		{
			case 0:
				return config.markerColor1();
			case 1:
				return config.markerColor2();
			case 2:
				return config.markerColor3();
			case 3:
				return config.markerColor4();
			case 4:
				return config.markerColor5();
			case 6:
				return config.markerColor7();
			case 7:
				return config.markerColor8();
			case 8:
				return config.markerColor9();
			case 9:
				return config.markerColor10();
			case 10:
				return config.markerColor11();
			case 11:
				return config.markerColor12();
			case 12:
				return pickedColor;
			default:
				return config.markerColor6();
		}
	}
}

/*
 * Copyright (c) 2018, TheLonelyDev <https://github.com/TheLonelyDev>
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.bram91.brushmarkers;

import java.awt.Color;
import lombok.EqualsAndHashCode;
import lombok.Value;

/**
 * Used for serialization of ground marker points.
 */
@Value
@EqualsAndHashCode(exclude = { "color" })
class BrushMarkerPoint
{
	private int regionId;
	private int regionX;
	private int regionY;
	private int z;
	private Color color;
}

/*
 * Copyright (c) 2019, Benjamin <https://github.com/genetic-soybean>
 * Copyright (c) 2020, Bram91 <https://github.com/Bram91>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.bram91.brushmarkers;

import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.worldmap.WorldMap;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;

class BrushMarkerWorldmapOverlay extends Overlay
{
	private static final int REGION_SIZE = 1 << 6;
	// Bitmask to return first coordinate in region
	private static final int REGION_TRUNCATE = ~((1 << 6) - 1);

	private final Client client;
	private final BrushMarkerConfig config;
	private final BrushMarkerPlugin plugin;

	@Inject
	private BrushMarkerWorldmapOverlay(Client client, BrushMarkerConfig config, BrushMarkerPlugin plugin)
	{
		this.client = client;
		this.config = config;
		this.plugin = plugin;
		setPosition(OverlayPosition.DYNAMIC);
		setPriority(PRIORITY_LOW);
		setLayer(OverlayLayer.MANUAL);
		drawAfterInterface(InterfaceID.WORLD_MAP);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!config.drawTilesOnWorldMap())
		{
			return null;
		}

		drawOnWorldMap(graphics);

		return null;
	}

	private void drawOnWorldMap(Graphics2D graphics)
	{
		WorldMap worldMap = client.getWorldMap();
		Widget map = client.getWidget(ComponentID.WORLD_MAP_MAPVIEW);
		float pixelsPerTile = worldMap.getWorldMapZoom();
		if (map == null)
		{
			return;
		}
		Rectangle worldMapRect = map.getBounds();
		graphics.setClip(worldMapRect);


		int widthInTiles = (int) Math.ceil(worldMapRect.getWidth() / pixelsPerTile);
		int heightInTiles = (int) Math.ceil(worldMapRect.getHeight() / pixelsPerTile);

		Point worldMapPosition = worldMap.getWorldMapPosition();

		// Offset in tiles from anchor sides
		int yTileMin = worldMapPosition.getY() - heightInTiles / 2;
		int xRegionMin = (worldMapPosition.getX() - widthInTiles / 2) & REGION_TRUNCATE;
		int xRegionMax = ((worldMapPosition.getX() + widthInTiles / 2) & REGION_TRUNCATE) + REGION_SIZE;
		int yRegionMin = (yTileMin & REGION_TRUNCATE);
		int yRegionMax = ((worldMapPosition.getY() + heightInTiles / 2) & REGION_TRUNCATE) + REGION_SIZE;
		int regionPixelSize = (int) Math.ceil(REGION_SIZE * pixelsPerTile);

		for (int x = xRegionMin; x < xRegionMax; x += REGION_SIZE)
		{
			for (int y = yRegionMin; y < yRegionMax; y += REGION_SIZE)
			{
				int regionId = ((x >> 6) << 8) | (y >> 6);
				for (final BrushMarkerPoint point : plugin.getWorldPoints(regionId))
				{
					int yTileOffset = -(yTileMin - y);
					int xTileOffset = x + widthInTiles / 2 - worldMapPosition.getX();
					int xPos = ((int) (xTileOffset * pixelsPerTile)) + (int) worldMapRect.getX();
					int yPos = (worldMapRect.height - (int) (yTileOffset * pixelsPerTile)) + (int) worldMapRect.getY();
					int size = regionPixelSize / 64;

					graphics.setColor(point.getColor());
					graphics.drawRect(xPos + (point.getRegionX() * size), yPos - (point.getRegionY() * size) + size, size - 1, size - 1);

				}
			}
		}

	}
}

package com.bram91.brushmarkers;


import lombok.Getter;

public class BrushMemento
{
	@Getter
	private BrushMarkerPoint point;
	@Getter
	private boolean draw;

	public BrushMemento(BrushMarkerPoint point, boolean draw)
	{
		this.point = point;
		this.draw = draw;
	}
}

package com.bram91.brushmarkers;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum BrushSize
{
	ONE("1",1),
	THREE("3",3),
	FIVE("5", 5);

	private final String name;
	@Getter
	private final int size;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2019, Jordan Atwood <nightfirecat@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.bram91.brushmarkers;

import java.awt.Color;
import lombok.Value;
import net.runelite.api.coords.WorldPoint;

/**
 * Used to denote marked tiles and their colors.
 * Note: This is not used for serialization of ground markers; see {@link BrushMarkerPoint}
 */
@Value
class ColorTileMarker
{
	private WorldPoint worldPoint;
	private Color color;
}

package com.bram91.brushmarkers;

import com.google.inject.Inject;
import java.awt.Dimension;
import java.awt.Graphics2D;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import java.awt.Color;
import net.runelite.client.ui.overlay.components.TitleComponent;

public class PaintModeOverlay extends OverlayPanel
{
	private static final Color DANGER = new Color(255, 0, 0, 150);

	private final BrushMarkerConfig config;

	@Inject
	private PaintModeOverlay(BrushMarkerConfig config)
	{
		this.config = config;
		setPosition(OverlayPosition.TOP_LEFT);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!config.paintMode())
		{
			return null;
		}
		panelComponent.getChildren().add(TitleComponent.builder()
			.text("Brush Markers")
			.build());
		panelComponent.getChildren().add(LineComponent.builder()
			.left("Brush mode enabled")
			.build());
		if(config.brushHotkey() != null)
		{
			panelComponent.getChildren().add(LineComponent.builder()
				.left("Hotkey set to: " + config.brushHotkey())
				.build());
		}

		panelComponent.setBackgroundColor(DANGER);

		return super.render(graphics);
	}
}

package com.bram91.brushmarkers;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class BrushMarkersPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(BrushMarkerPlugin.class);
		RuneLite.main(args);
	}
}
