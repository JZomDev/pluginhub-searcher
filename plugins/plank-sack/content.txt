package io.github.talkarcabbage.planksack.overlayenums;

public enum OverlayStyle {

    DYNAMIC,
    TOOLTIP_ONLY,
    ONE_BIG_NUMBER,
    ONE_SMALL_NUMBER,
    VERTICAL,
    VERTICAL_GRID,
    HORIZONTAL_GRID,
}

package io.github.talkarcabbage.planksack.overlayenums;

public enum SmallNumberPlacement {
    BOTTOM,
    TOP
}

package io.github.talkarcabbage.planksack.overlayenums;

public enum OverlayTextType {
    NONE,
    LETTER,
    LONG
}

package io.github.talkarcabbage.planksack;

import com.google.inject.Provides;
import io.github.talkarcabbage.planksack.overlay.gameoverlay.PlankSackBoxOverlay;
import io.github.talkarcabbage.planksack.overlay.PlankSackOverlay;
import io.github.talkarcabbage.planksack.planksack.PlankSackManager;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;

import javax.inject.Inject;

@Slf4j
@PluginDescriptor(
        name = "Plank Sack",
        description = "Show customizable overlays for the contents of the plank sack",
        configName = "PlankSackPlugin"
)
public class PlankSackPlugin extends Plugin {
    @Inject
    Client client;
    @Inject
    @Getter
    private SackTrackerConfig config;
    @Inject
    private OverlayManager overlayManager;
    private PlankSackOverlay overlay = null;


    @Inject
    private TooltipManager tooltipManager;
    private PlankSackBoxOverlay boxOverlay;

    @Inject
    private ItemManager itemManager;

    @Override
    protected void startUp() {
        PlankSackManager sackManager = new PlankSackManager(client);
        overlay = new PlankSackOverlay(sackManager, config, client, tooltipManager );
        overlayManager.add(overlay);
        boxOverlay = new PlankSackBoxOverlay(this, sackManager, itemManager, client, config);
        overlayManager.add(boxOverlay);
    }

    @Override
    protected void shutDown() {
        overlayManager.remove(overlay);
        overlayManager.remove(boxOverlay);
    }

    @Provides
    SackTrackerConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(SackTrackerConfig.class);
    }
}

package io.github.talkarcabbage.planksack.util;

import lombok.Getter;

public class Entry<K,V> {
    @Getter
    private final K key;
    @Getter
    private final V value;
    public Entry(K key, V value){
        this.key=key;
        this.value=value;
    }
}

package io.github.talkarcabbage.planksack;

import io.github.talkarcabbage.planksack.overlayenums.OverlayStyle;
import io.github.talkarcabbage.planksack.overlayenums.OverlayTextType;
import io.github.talkarcabbage.planksack.overlayenums.SmallNumberPlacement;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

import java.awt.*;

import static io.github.talkarcabbage.planksack.overlayenums.SmallNumberPlacement.TOP;

@ConfigGroup("planksacktracker")
public interface SackTrackerConfig extends Config {

    String TEXT_COLOR = "textcolor";
    String NUMBER_COLOR = "numbercolor";
    String PLANK_ICONS = "plankicons";
    String OVERLAY_STYLE = "overlaystyle";
    String PLANK_NAMES = "planknames";
    String DISPLAY_ZERO = "displayzerowhenempty";
    String ENABLE_ICON_FOR_ONE_NUMBER = "disableonebignumbericon";
    String ALWAYS_DISABLE_LABELS_IN_GRID = "disablelabelsingrid";
    String TOOLTIP_TEXT_COLOR = "tooltiptextcolor";
    String TOOLTIP_NUMBER_COLOR = "tooltipnumbercolor";
    String ENABLE_TOOLTIP = "enabletooltip";

    String ENABLE_GAMEVIEW_OVERLAY = "enableinfobox";

    @ConfigSection(
            name = "Item Overlay",
            description = "Item overlay settings",
            position = 0
    )
    String overlaySettings = "overlaysettings";

    @ConfigItem(
            keyName = TEXT_COLOR,
            name="Overlay text color",
            description = "The font color used to display the names of planks.",
            position = 1,
            section=overlaySettings
    )
    default Color textColor() { return Color.WHITE; }
    @ConfigItem(
            keyName = NUMBER_COLOR,
            name="Overlay number color",
            description = "The font color used to display the plank quantities on the plank sack.",
            position = 2,
            section=overlaySettings
    )
    default Color numberColor() { return Color.YELLOW; }

    @ConfigItem(
            keyName = OVERLAY_STYLE,
            name="Overlay style",
            description = "Change the style of how the item overlay renders. " +
                    "<br/><br/>" +
                    "Dynamic (default) - Switch between One Big Number/Vertical/Horizontal Grid based on how many different types of planks are in the sack.<br/>" +
                    "Tooltip Only (disable overlay) - Disable the overlay; the tooltip will still show when hovering the plank sack.<br/>" +
                    "One Big Number - Show the entire contents as one large number, with or without icons.<br/>" +
                    "One Small Number - Show the entire contents as one small number on the bottom left corner, with or without icons.<br/>" +
                    "Vertical - Show each plank in the sack on its own line.<br/>" +
                    "Vertical/Horizontal Grids - Show the planks in a 2-wide or 2-tall grid. Does not support showing long plank names.",
            position = 3,
            section=overlaySettings
    )
    default OverlayStyle overlayStyle() {
        return OverlayStyle.DYNAMIC;
    }


    @ConfigSection(
            name = "Item Overlay Styles",
            description = "Tweaks that apply to specific item overlay styles",
            position = 4
    )
    String styleTweaks = "styleTweaks";

    @ConfigItem(
            keyName = PLANK_NAMES,
            name = "Plank name display",
            description =  "Change if/how the names of each plank in the plank sack are displayed on the overlay. Affects the vertical display style, and grids if labels for grids are not set to always hidden.",
            position = 5,
            section=styleTweaks
    )
    default OverlayTextType textType() {
        return OverlayTextType.LETTER;
    }

    @ConfigItem(
            keyName = ALWAYS_DISABLE_LABELS_IN_GRID,
            name = "Always hide labels in grids",
            description =  "Hides labels when using the grid view, regardless of if they are enabled. Only short labels will be used, if enabled, to reduce text overlap.",
            position = 6,
            section=styleTweaks
    )
    default boolean alwaysDisableLabelsInGrid() {
        return true;
    }

    @ConfigItem(
            keyName = DISPLAY_ZERO,
            name = "Display zero when empty",
            description =  "If enabled, displays a zero on the overlay when the sack is empty.",
            position = 7,
            section=styleTweaks
    )
    default boolean displayZeroWhenEmpty() {
        return true;
    }

    @ConfigItem(
            keyName = PLANK_ICONS,
            name="Show plank icons",
            description = "Enable or disable the plank icons on the overlay.",
            position = 8,
            section=styleTweaks
    )
    default boolean showOverlayIcons() { return true; }

    @ConfigItem(
            keyName = ENABLE_ICON_FOR_ONE_NUMBER,
            name = "Show One Big/Small Number icons",
            description =  "If this is disabled, the One Big Number and One Small Number styles will not show icons, even if icons are enabled.",
            position = 9,
            section=styleTweaks
    )
    default boolean enableIconOneNumber() {
        return true;
    }

    String ONE_SMALL_NUMBER_PLACEMENT = "onesmallnumberplacement";
    @ConfigItem(
            keyName = ONE_SMALL_NUMBER_PLACEMENT,
            name = "Small Number Position",
            description =  "Determines whether the One Small Number style shows at the top or bottom of the item.",
            position = 10,
            section=styleTweaks
    )
    default SmallNumberPlacement smallNumberPlacement() {
        return TOP;
    }

    @ConfigSection(
            name = "Tooltip",
            description = "Settings for the tooltip, shown when hovering on the plank sack.",
            position = 11,
            closedByDefault = true
    )
    String tooltipSettings = "tooltipsettings";

    @ConfigItem(
            keyName = TOOLTIP_TEXT_COLOR,
            name = "Tooltip text color",
            description =  "The color of the plank name in the tooltip, shown when hovering on the plank sack, if enabled.",
            position = 12,
            section=tooltipSettings
    )
    default Color tooltipTextColor() {
        return Color.YELLOW;
    }

    @ConfigItem(
            keyName = TOOLTIP_NUMBER_COLOR,
            name = "Tooltip number color",
            description =  "The color of the quantity of each plank in the tooltip, shown when hovering on the plank sack, if enabled.",
            position = 13,
            section=tooltipSettings
    )
    default Color tooltipNumberColor() {
        return Color.WHITE;
    }

    @ConfigItem(
            keyName = ENABLE_TOOLTIP,
            name = "Show tooltip",
            description =  "When enabled, display a tooltip when hovering on the plank sack listing the current contents.",
            position = 14,
            section=tooltipSettings
    )
    default boolean enableTooltip() {
        return true;
    }

    @ConfigSection(
            name = "Game View Overlay",
            description = "Enable/configure the moveable game-window overlay",
            position = 15,
            closedByDefault = true
    )
    String gameOverlaySection = "gameviewoverlaysection";

    @ConfigItem(
            keyName = ENABLE_GAMEVIEW_OVERLAY,
            name = "Show game overlay",
            description =  "When enabled, displays an infobox-style overlay in the main game window.",
            position = 16,
            section= gameOverlaySection
    )
    default boolean enableInfoBox() {
        return false;
    }


    String GAME_OVERLAY_TEXT_COLOR = "gameoverlaytextcolor";

    @ConfigItem(
            keyName = GAME_OVERLAY_TEXT_COLOR,
            name = "Text color",
            description =  "The color of the plank name in the info box, shown as a moveable overlay on the game window, if enabled.",
            position = 17,
            section= gameOverlaySection
    )
    default Color infoboxTextColor() {
        return Color.WHITE;
    }

    String GAME_OVERLAY_NUMBER_COLOR = "gameoverlaynumbercolor";

    @ConfigItem(
            keyName = GAME_OVERLAY_NUMBER_COLOR,
            name = "Number color",
            description =  "The color of the quantity of each plank in the info box, shown as a moveable overlay on the game window, if enabled.",
            position = 18,
            section= gameOverlaySection
    )
    default Color infoboxNumberColor() {
        return Color.YELLOW;
    }

    String INFO_BOX_PLANK_NAMES = "infoboxplanknames";
    @ConfigItem(
            keyName = INFO_BOX_PLANK_NAMES,
            name = "Plank names",
            description =  "Change if/how the names of each plank in the plank sack are displayed on the game window overlay.",
            position = 19,
            section= gameOverlaySection
    )
    default OverlayTextType infoBoxPlankNames() {
        return OverlayTextType.LONG;
    }

    String INFO_BOX_PLANK_ICONS = "infoboxplankicons";
    @ConfigItem(
            keyName = INFO_BOX_PLANK_ICONS,
            name="Plank icons",
            description = "Enable or disable the plank icons on the game window overlay.",
            position = 20,
            section= gameOverlaySection
    )
    default boolean showInfoBoxPlankIcons() { return true; }

    String SHOW_GAME_OVERLAY_ALWAYS = "showgameoverlayalways";
    @ConfigItem(
            keyName = SHOW_GAME_OVERLAY_ALWAYS,
            name="Show when not carried",
            description = "If checked, the game window overlay will always be shown, even if the plank sack is not in the inventory.",
            position = 21,
            section= gameOverlaySection
    )
    default boolean alwaysShowGameOverlay() { return false; }


}

package io.github.talkarcabbage.planksack.overlay;

import io.github.talkarcabbage.planksack.*;
import io.github.talkarcabbage.planksack.planksack.PlankSackManager;
import io.github.talkarcabbage.planksack.planksack.PlankStorageSet;
import io.github.talkarcabbage.planksack.planksack.PlankTier;
import io.github.talkarcabbage.planksack.util.Entry;
import net.runelite.api.Point;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.OverlayUtil;

import java.awt.*;
import java.awt.image.BufferedImage;

public class OneBigNumber {
    private final PlankSackManager manager;
    private final SackTrackerConfig config;

    public OneBigNumber(PlankSackManager manager, SackTrackerConfig config) {
        this.manager = manager;
        this.config = config;
    }

    public void drawOneBigNumber(Graphics2D graphics, WidgetItem widgetItem) {
        var currentPlankSack = manager.getCurrentPlankSack();
        graphics.setFont(FontManager.getRunescapeFont());
        int startingDrawX = widgetItem.getCanvasLocation().getX();
        int startingDrawY = widgetItem.getCanvasLocation().getY() + 24;
        BufferedImage image = null;
        var horizontalOffset = (currentPlankSack.getTotalPlanks()>9?-1:1);

        if (config.showOverlayIcons()) {
            if (currentPlankSack.isMonoContent()) {
                image = Images.getIconForTier(currentPlankSack.getMonoType());
            } else {
                image = Images.plankImage;
            }
        }
        if (currentPlankSack.isEmpty() && config.displayZeroWhenEmpty()) {
            drawBigStringThickShadowed(graphics, FontManager.getRunescapeFont(), "0", startingDrawX+9+horizontalOffset, startingDrawY, config.numberColor());
        } else if (!currentPlankSack.isEmpty()){
            if (image!=null && config.enableIconOneNumber()) {
                drawStackedPlankIcons(graphics, startingDrawX+horizontalOffset, startingDrawY-(graphics.getFontMetrics().getHeight()-2), currentPlankSack) ;
            }
            drawBigStringThickShadowed(graphics, FontManager.getRunescapeFont(), ""+currentPlankSack.getTotalPlanks(), startingDrawX+9+horizontalOffset, startingDrawY, config.numberColor());
        }
    }

    private static final Color SLIGHTLY_FADED_BLACK = new Color(0f,0f,0f,0.7f);
    private static final Color MEDIUM_FADED_BLACK = new Color(0f,0f,0f,0.45f);
    private static final Color VERY_FADED_BLACK = new Color(0f,0f,0f,0.3f);
    private void drawBigStringThickShadowed(Graphics2D graphics, Font font, String label, int x, int y, Color color) {
        graphics.setFont(font);
        graphics.setColor(SLIGHTLY_FADED_BLACK);
        graphics.drawString(label, x + 1, y + 1);
        graphics.setColor(MEDIUM_FADED_BLACK);
        graphics.drawString(label, x + 2, y + 1);
        graphics.setColor(VERY_FADED_BLACK);
        graphics.drawString(label, x + 1, y + 2);
        graphics.drawString(label, x + 2, y + 2);
        graphics.setColor(color);
        graphics.drawString(label, x, y);
    }

    //For drawing the plank icons to the left of the big number in a way that takes up minimal space
    private void drawStackedPlankIcons(Graphics2D graphics, int x, int y, PlankStorageSet planks) {
        var numDone = 0;
        var types = planks.countTypes();
        if (types>3) y-=6;
        for (Entry<PlankTier, Integer> plank : planks) {
            var tier = plank.getKey();
            var icon = Images.getIconForTier(tier);
            OverlayUtil.renderImageLocation(graphics, new Point(x, y), icon);
            x -= 4;
            numDone++;
            if (numDone==3) {
                y+=10;
                if (types>6) {
                    x+=11; //Make a little extra space for the 7th plank icon
                } else {
                    x+=10;
                }
            }
        }
    }

}

package io.github.talkarcabbage.planksack.overlay;

import io.github.talkarcabbage.planksack.util.Entry;
import io.github.talkarcabbage.planksack.planksack.PlankSackManager;
import io.github.talkarcabbage.planksack.planksack.PlankTier;
import io.github.talkarcabbage.planksack.SackTrackerConfig;
import io.github.talkarcabbage.planksack.overlayenums.OverlayTextType;
import net.runelite.api.Point;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.annotation.Nullable;
import java.awt.*;
import java.awt.image.BufferedImage;

import static io.github.talkarcabbage.planksack.overlay.PlankSackOverlay.ABBREVIATED_WIDTH_BUFFER;
import static io.github.talkarcabbage.planksack.overlay.PlankSackOverlay.NON_ABBREVIATED_WIDTH_BUFFER;

public class Vertical {
    private final PlankSackManager manager;
    private final SackTrackerConfig config;

    public Vertical(PlankSackManager manager, SackTrackerConfig config) {
        this.manager = manager;
        this.config = config;
    }

    void drawVertical(Graphics2D graphics, WidgetItem widgetItem) {
        var currentSack = manager.getCurrentPlankSack();
        var x = widgetItem.getCanvasLocation().getX();
        var y = widgetItem.getCanvasLocation().getY();
        var labelSize = getCurrentLabelValueOffset();
        var horizontalOffset = -4;
        var verticalSpacing = 12;

        if (config.textType()== OverlayTextType.LONG) {
            horizontalOffset -= 7;
        }

        for (Entry<PlankTier, Integer> nextPlank : currentSack) {
            var label = getVerticalOverlayLabel(nextPlank.getKey());
            if (label.isEmpty()) label=null;
            var image = config.showOverlayIcons()?(Images.getIconForTier(nextPlank.getKey())):null;
            drawSingleVerticalEntry(graphics, image, label, config.textColor(), config.numberColor(), nextPlank.getValue(),x+horizontalOffset,y+=verticalSpacing, labelSize);
        }
    }
    private int getCurrentLabelValueOffset() {
        switch (config.textType()) {
            case NONE:
                return 0;
            case LETTER:
                return ABBREVIATED_WIDTH_BUFFER;
            case LONG:
                return NON_ABBREVIATED_WIDTH_BUFFER;
            default:
                return 0;
        }
    }

    static protected void drawSingleVerticalEntry(Graphics2D graphics, @Nullable BufferedImage icon, @Nullable String label, Color textColor, Color numberColor, int amount, int x, int y, int labelWidth) {
        var font = FontManager.getRunescapeSmallFont();
        var runningXOffset = 0;
        graphics.setFont(font);
        int fontHeight = graphics.getFontMetrics(font).getHeight();
        if (label!=null && label.isEmpty()) label=null;

        if (label==null) runningXOffset+=7;

        if (icon!=null) {
            OverlayUtil.renderImageLocation(graphics, new Point(x+runningXOffset, y-(fontHeight+1)), icon);
            runningXOffset+=6;
        }
        runningXOffset+=5;
        if (label!=null) {
            PlankSackOverlay.drawStringShadowed(graphics, font, label, x+runningXOffset, y, textColor);
        } else {
            runningXOffset+=10; // Since the number amount right-justifies, if we don't add this it will overlap into the plank icon area.
        }
        runningXOffset-=rightJustifyXValue(graphics, ""+amount);
        PlankSackOverlay.drawStringShadowed(graphics, font, ""+amount,x+runningXOffset+labelWidth, y, numberColor);
    }

    static private int rightJustifyXValue(Graphics2D graphics, String string) {
        return graphics.getFontMetrics().stringWidth(string);
    }

    protected String getVerticalOverlayLabel(PlankTier tier) {
        switch (config.textType()) {
            case NONE:
                return "";
            case LETTER:
                switch (tier) {
                    case PLANK:
                        return "P:";
                    case OAK:
                        return "O:";
                    case TEAK:
                        return "T:";
                    case MAHOGANY:
                        return "M:";
                    case ROSEWOOD:
                        return "R:";
                    case IRONWOOD:
                        return "I:";
                    case CAMPHOR:
                        return "C:";
                }
            case LONG:
                switch (tier) {
                    case PLANK:
                        return "Plank:\t";
                    case OAK:
                        return "Oak:\t";
                    case TEAK:
                        return "Teak:\t";
                    case MAHOGANY:
                        return "Mahog:\t";
                    case ROSEWOOD:
                        return "Rose:\t";
                    case IRONWOOD:
                        return "Iron:\t";
                    case CAMPHOR:
                        return "Camph:\t";
                }
        }
        return "";
    }
}

package io.github.talkarcabbage.planksack.overlay.gameoverlay;

import io.github.talkarcabbage.planksack.SackTrackerConfig;
import io.github.talkarcabbage.planksack.PlankSackPlugin;
import io.github.talkarcabbage.planksack.planksack.PlankSackManager;
import net.runelite.api.Client;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.components.BackgroundComponent;
import net.runelite.client.ui.overlay.components.ComponentConstants;

import java.awt.*;
import java.awt.image.BufferedImage;

public class PlankSackBoxOverlay extends OverlayPanel {
    private final PlankSackManager plankSackManager;
    private final SackTrackerConfig config;
    private final PlankSackPlugin plugin;
    private final Client client;
    private final ItemManager itemManager;

    private final BufferedImage plankIcon;

    private final VerticalOverlayBox vobox;

    private Color backgroundColor = ComponentConstants.STANDARD_BACKGROUND_COLOR;


    public PlankSackBoxOverlay(PlankSackPlugin plugin, PlankSackManager plankSackManager, ItemManager itemManager, Client client, SackTrackerConfig config) {
        this.plankSackManager = plankSackManager;
        this.config = config;
        this.client = client;
        this.plugin = plugin;
        this.itemManager = itemManager;
        plankIcon = itemManager.getImage(ItemID.PLANK_SACK);
        vobox = new VerticalOverlayBox(plankSackManager, config);
        setResizable(false);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!config.enableInfoBox() || (!config.alwaysShowGameOverlay() && !plankSackManager.inventoryContainsPlankSack())) return super.render(graphics);

        graphics.setFont(FontManager.getRunescapeSmallFont());
        var bounds = new Dimension(getWidthByConfig(),14+(12 * plankSackManager.getCurrentPlankSack().countTypes()));
        var dims = new Rectangle(0,0, bounds.width, bounds.height);
        var backgroundComponent = new BackgroundComponent();
        backgroundComponent.setBackgroundColor(backgroundColor);
        backgroundComponent.setRectangle(dims);
        backgroundComponent.render(graphics);
        vobox.draw(graphics);
        return bounds;
    }
    private int getWidthByConfig() {
        var width = 4;
        if (config.showInfoBoxPlankIcons()) {
            width +=10;
        }
        switch (config.infoBoxPlankNames()) {
            case NONE:
                width += 15;
                break;
            case LETTER:
                width += 30;
                break;
            case LONG:
                width += 75;
                break;
        }
        return width;
    }
}

package io.github.talkarcabbage.planksack.overlay.gameoverlay;

import io.github.talkarcabbage.planksack.SackTrackerConfig;
import io.github.talkarcabbage.planksack.overlay.Images;
import io.github.talkarcabbage.planksack.overlay.PlankSackOverlay;
import io.github.talkarcabbage.planksack.planksack.PlankSackManager;
import io.github.talkarcabbage.planksack.planksack.PlankTier;
import io.github.talkarcabbage.planksack.util.Entry;
import net.runelite.api.Point;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.annotation.Nullable;
import java.awt.*;
import java.awt.image.BufferedImage;

public class VerticalOverlayBox  {
    private final PlankSackManager manager;
    private final SackTrackerConfig config;

    private static final int LONG_TEXT_WIDTH = 71;
    private static final int SHORT_TEXT_WIDTH = 25;

    public VerticalOverlayBox(PlankSackManager manager, SackTrackerConfig config) {
        this.manager = manager;
        this.config = config;

    }

    void draw(Graphics2D graphics) {
        var currentSack = manager.getCurrentPlankSack();
        var font = FontManager.getRunescapeSmallFont();
        var x = 3;
        var y = 12;
        var verticalSpacing = 12;

        drawTopLabel(graphics, font);
        for (Entry<PlankTier, Integer> nextPlank : currentSack) {
            var label = getLabel(nextPlank.getKey());
            if (label.isEmpty()) label=null;
            var image = config.showInfoBoxPlankIcons()?(Images.getIconForTier(nextPlank.getKey())):null;
            drawSingleEntry(graphics, image, label, config.infoboxTextColor(), config.infoboxNumberColor(), nextPlank.getValue(),x,y+=verticalSpacing);
        }
    }

    protected void drawTopLabel(Graphics2D graphics, Font font) {

        var topXPos = (config.showInfoBoxPlankIcons()?5:0);
        var label = "PS";
        switch (config.infoBoxPlankNames()) {
            case NONE:
                topXPos +=3;
                break;
            case LETTER:
                topXPos += 12;
                break;
            case LONG:
                label="Plank Sack";
                topXPos += 13;
                break;
        }

        PlankSackOverlay.drawStringShadowed(graphics, font, label, topXPos, 12, config.infoboxTextColor());

    }

    protected void drawSingleEntry(Graphics2D graphics, @Nullable BufferedImage icon, @Nullable String label, Color textColor, Color numberColor, int amount, int x, int y) {
        var font = FontManager.getRunescapeSmallFont();
        var runningXOffset = 0;
        graphics.setFont(font);
        int fontHeight = graphics.getFontMetrics(font).getHeight();
        if (label!=null && label.isEmpty()) label=null;

        var textWidth = 0;
        switch (config.infoBoxPlankNames()) {
            case LETTER:
                textWidth = SHORT_TEXT_WIDTH;
                break;
            case LONG:
                textWidth = LONG_TEXT_WIDTH;
                break;
        }

        if (icon!=null) {
            OverlayUtil.renderImageLocation(graphics, new Point(x+runningXOffset, y-(fontHeight+1)), icon);
            runningXOffset+=10;
        }
        //runningXOffset+=5;
        if (label!=null) {
            PlankSackOverlay.drawStringShadowed(graphics, font, label, x+runningXOffset, y, textColor);
        } else {
            runningXOffset+=10;
        }
        runningXOffset-=rightJustifyXValue(graphics, ""+amount);
        PlankSackOverlay.drawStringShadowed(graphics, font, ""+amount,x+runningXOffset+ textWidth, y, numberColor);
    }

    static private int rightJustifyXValue(Graphics2D graphics, String string) {
        var ret = 0;
        var metrics = graphics.getFontMetrics();
        for (byte aByte : string.getBytes()) {
            ret+=metrics.charWidth(aByte);
            ret-=1;
        }
        return ret;
    }

    protected String getLabel(PlankTier tier) {
        switch (config.infoBoxPlankNames()) {
            case NONE:
                return "";
            case LETTER:
                switch (tier) {
                    case PLANK:
                        return "P:";
                    case OAK:
                        return "O:";
                    case TEAK:
                        return "T:";
                    case MAHOGANY:
                        return "M:";
                    case ROSEWOOD:
                        return "R:";
                    case IRONWOOD:
                        return "I:";
                    case CAMPHOR:
                        return "C:";
                }
            case LONG:
                switch (tier) {
                    case PLANK:
                        return "Plank:\t";
                    case OAK:
                        return "Oak:\t";
                    case TEAK:
                        return "Teak:\t";
                    case MAHOGANY:
                        return "Mahogany:\t";
                    case ROSEWOOD:
                        return "Rosewood:\t";
                    case IRONWOOD:
                        return "Ironwood:\t";
                    case CAMPHOR:
                        return "Camphor:\t";
                }
        }
        return "";
    }
}

package io.github.talkarcabbage.planksack.overlay;

import io.github.talkarcabbage.planksack.planksack.PlankSackManager;
import io.github.talkarcabbage.planksack.SackTrackerConfig;
import io.github.talkarcabbage.planksack.overlayenums.OverlayStyle;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.WidgetItemOverlay;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;

import java.awt.*;

@Slf4j
public class PlankSackOverlay extends WidgetItemOverlay {
    private final SackTrackerConfig config;
    private final PlankSackManager manager;

    // Overlay styles
    private final OneBigNumber oneBigNumber;
    private final HorizontalGrid horizontalGrid;
    private final VerticalGrid verticalGrid;
    private final Vertical vertical;
    private final OneSmallNumber oneSmallNumber;

    //Tooltip renderer
    private final SackTooltip tooltip;

    public static final int ABBREVIATED_WIDTH_BUFFER = 23; // Used to set spacing for abbreviated text overlays
    public static final int NON_ABBREVIATED_WIDTH_BUFFER = 49; // Used to set spacing for long text overlays
    private final Client client;

    public PlankSackOverlay(PlankSackManager sackManager, SackTrackerConfig config, Client client, TooltipManager tooltipManager) {
        this.config = config;
        this.manager = sackManager;
        this.client = client;
        showOnInventory();

        oneBigNumber = new OneBigNumber(sackManager, config);
        horizontalGrid = new HorizontalGrid(sackManager, config);
        verticalGrid = new VerticalGrid(sackManager, config);
        vertical = new Vertical(sackManager, config);
        tooltip = new SackTooltip(sackManager, tooltipManager, config);
        oneSmallNumber = new OneSmallNumber(sackManager, config);
    }

    @Override
    public void renderItemOverlay(Graphics2D graphics, int itemId, WidgetItem widgetItem) {
        if (itemId!= ItemID.PLANK_SACK) return;
        var currentPlankSack = manager.getCurrentPlankSack();
        graphics.setFont(FontManager.getRunescapeSmallFont());

        if (currentPlankSack.isEmpty() && config.displayZeroWhenEmpty() && config.overlayStyle()!= OverlayStyle.TOOLTIP_ONLY) {
            if (config.overlayStyle()==OverlayStyle.ONE_SMALL_NUMBER) {
                oneSmallNumber.drawOneSmallNumber(graphics, widgetItem);
            } else {
                oneBigNumber.drawOneBigNumber(graphics, widgetItem);
            }
        } else {

            switch (config.overlayStyle()) {
                case TOOLTIP_ONLY:
                    break;
                case ONE_BIG_NUMBER:
                    oneBigNumber.drawOneBigNumber(graphics, widgetItem);
                    break;
                case ONE_SMALL_NUMBER:
                    oneSmallNumber.drawOneSmallNumber(graphics, widgetItem);
                    break;
                case DYNAMIC:
                    drawDynamic(graphics, widgetItem);
                    break;
                case VERTICAL_GRID:
                    verticalGrid.drawGridVertical(graphics, widgetItem);
                    break;
                case HORIZONTAL_GRID:
                    horizontalGrid.drawGridHorizontal(graphics, widgetItem);
                    break;
                case VERTICAL:
                    vertical.drawVertical(graphics, widgetItem);
                    break;
            }
        }
        if (config.enableTooltip() && isHovered(widgetItem, client.getMouseCanvasPosition())) {
            tooltip.renderTooltip();
        }
    }

    private boolean isHovered(WidgetItem widgetItem, Point mousePosition) {
        return (widgetItem.getCanvasBounds().contains(mousePosition.getX(), mousePosition.getY()));
    }

    private void drawDynamic(Graphics2D graphics, WidgetItem widgetItem) {
        var totalTypes = manager.getCurrentPlankSack().countTypes();
        switch (totalTypes) {
            case 0:
            case 1:
                oneBigNumber.drawOneBigNumber(graphics, widgetItem);
                break;
            case 2:
            case 3:
                vertical.drawVertical(graphics, widgetItem);
                break;
            case 4:
                horizontalGrid.drawGridHorizontal(graphics, widgetItem);
                break;
            case 5:
            case 6:
            case 7:
                oneBigNumber.drawOneBigNumber(graphics, widgetItem);
                break;
            default:
                log.warn("The plank sack, somehow, contains more plank types than should be possible! The overlay may not work correctly.");
                oneBigNumber.drawOneBigNumber(graphics, widgetItem);
        }
    }

    public static void drawStringShadowed(Graphics2D graphics, Font font, String label, int x, int y, Color color) {
        graphics.setColor(Color.BLACK);
        graphics.setFont(font);
        graphics.drawString(label, x + 1, y + 1);
        graphics.setColor(color);
        graphics.drawString(label, x, y);
    }

}

package io.github.talkarcabbage.planksack.overlay;

import io.github.talkarcabbage.planksack.planksack.PlankTier;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.util.ImageUtil;

import java.awt.image.BufferedImage;

@Slf4j
public class Images {
    @Getter static final BufferedImage plankImage = tryLoad("/plank_small.png");
    @Getter static final BufferedImage oakImage = tryLoad("/oak_small.png");
    @Getter static final BufferedImage teakImage = tryLoad("/teak_small.png");
    @Getter static final BufferedImage mahoganyImage = tryLoad("/mahogany_small.png");
    @Getter static final BufferedImage rosewoodImage = tryLoad("/rosewood_small.png");
    @Getter static final BufferedImage ironwoodImage = tryLoad("/ironwood_small.png");
    @Getter static final BufferedImage camphorImage = tryLoad("/camphor_small.png");

    private static BufferedImage tryLoad(String resource) {
        try {
            return ImageUtil.loadImageResource(Images.class, resource);
        } catch (RuntimeException e) {
            log.error("Encountered an error while loading some plank icons!");
            return null;
        }
    }

    public static BufferedImage getIconForTier(PlankTier tier) {
        switch (tier) {
            case PLANK:
                return plankImage;
            case OAK:
                return oakImage;
            case TEAK:
                return teakImage;
            case MAHOGANY:
                return mahoganyImage;
            case ROSEWOOD:
                return rosewoodImage;
            case IRONWOOD:
                return ironwoodImage;
            case CAMPHOR:
                return camphorImage;
            case UNKNOWN:
            default:
                return plankImage;
        }
    }
}

package io.github.talkarcabbage.planksack.overlay;

import io.github.talkarcabbage.planksack.*;
import io.github.talkarcabbage.planksack.planksack.PlankSackManager;
import io.github.talkarcabbage.planksack.planksack.PlankStorageSet;
import io.github.talkarcabbage.planksack.planksack.PlankTier;
import io.github.talkarcabbage.planksack.util.Entry;
import net.runelite.api.Point;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.annotation.Nullable;
import java.awt.*;
import java.awt.image.BufferedImage;

import static io.github.talkarcabbage.planksack.overlayenums.OverlayTextType.NONE;

public class VerticalGrid {
    private final PlankSackManager manager;
    private final SackTrackerConfig config;

    private static final int INITIAL_X_OFFSET = -2;
    private static final int INITIAL_Y_OFFSET = 12;

    public VerticalGrid(PlankSackManager manager, SackTrackerConfig config) {
        this.manager = manager;
        this.config = config;
    }

    void drawGridVertical(Graphics2D graphics, WidgetItem widgetItem) {
        var widthBetween = 20;


        var font = FontManager.getRunescapeSmallFont();
        var currentSack = manager.getCurrentPlankSack();
        boolean rowFinished = false;
        var x = widgetItem.getCanvasLocation().getX() + INITIAL_X_OFFSET + getStartingWidthOffset(currentSack);
        var y = widgetItem.getCanvasLocation().getY() + INITIAL_Y_OFFSET;
        var labelWidth = config.textType()==NONE?0:10;

        if (config.alwaysDisableLabelsInGrid()) {
            labelWidth=0;
        } else if (labelWidth>0) {
            widthBetween+=4;
            if (config.showOverlayIcons()) widthBetween+=6; // If icons are on AND labels are on
        }

        int column = 0;
        for (Entry<PlankTier, Integer> nextPlank : currentSack) {
            String label = null;
            BufferedImage image = config.showOverlayIcons()?Images.getIconForTier(nextPlank.getKey()):null;
            if (config.textType()!=NONE && !config.alwaysDisableLabelsInGrid()) {
                label = getGridOverlayTextByConfig(nextPlank.getKey());
            }
            if (rowFinished) {
                drawSingleSmallPlankOverlay(graphics, image, label, font, config.textColor(), config.numberColor(), ""+nextPlank.getValue(), x+(widthBetween*column), y+18, labelWidth);
                column++;
                rowFinished = false;
            } else {
                drawSingleSmallPlankOverlay(graphics, image, label, font, config.textColor(), config.numberColor(), ""+nextPlank.getValue(), x+(widthBetween*column), y, labelWidth);
                rowFinished = true;
            }
        }
    }

    static protected void drawSingleSmallPlankOverlay(Graphics2D graphics, @Nullable BufferedImage icon, @Nullable String label, Font font, Color textColor, Color numberColor, String amount, int x, int y, int labelWidth) {
        var runningXOffset = 0;
        graphics.setFont(font);
        int fontHeight = graphics.getFontMetrics(font).getHeight();
        if (label!=null && label.isEmpty()) label=null;

        if (icon!=null) {
            OverlayUtil.renderImageLocation(graphics, new Point(x+runningXOffset, y-(fontHeight+1)), icon);
            runningXOffset+=5;
        }
        runningXOffset+=5;
        if (label!=null) {
            PlankSackOverlay.drawStringShadowed(graphics, font, label, x+runningXOffset, y, textColor);
        }
        PlankSackOverlay.drawStringShadowed(graphics, font, amount,x+runningXOffset+labelWidth, y, numberColor);
    }

    private String getGridOverlayTextByConfig(PlankTier tier) {
        switch (tier) {
            case PLANK:
                return "P:";
            case OAK:
                return "O:";
            case TEAK:
                return "T:";
            case MAHOGANY:
                return "M:";
            case ROSEWOOD:
                return "R:";
            case IRONWOOD:
                return "I:";
            case CAMPHOR:
                return "C:";
        }
        return "";
    }
    private int getStartingWidthOffset(PlankStorageSet planks) {
        var count = planks.countTypes();
        if (count<=4) return 0;
        if (count<=6) return -6;
        return 0;
    }
}

package io.github.talkarcabbage.planksack.overlay;

import io.github.talkarcabbage.planksack.*;
import io.github.talkarcabbage.planksack.planksack.PlankSackManager;
import io.github.talkarcabbage.planksack.planksack.PlankStorageSet;
import io.github.talkarcabbage.planksack.planksack.PlankTier;
import io.github.talkarcabbage.planksack.util.Entry;
import net.runelite.api.Point;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.annotation.Nullable;
import java.awt.*;
import java.awt.image.BufferedImage;

import static io.github.talkarcabbage.planksack.overlayenums.OverlayTextType.NONE;

public class HorizontalGrid {

    private final PlankSackManager manager;
    private final SackTrackerConfig config;

    public HorizontalGrid(PlankSackManager manager, SackTrackerConfig config) {
        this.manager = manager;
        this.config = config;
    }

    void drawGridHorizontal(Graphics2D graphics, WidgetItem widgetItem) {
        var widthBetween = 20;
        var font = FontManager.getRunescapeSmallFont();
        var currentSack = manager.getCurrentPlankSack();
        boolean columnFinished = false;
        var x = widgetItem.getCanvasLocation().getX()-2;
        var y = widgetItem.getCanvasLocation().getY() + 10 + getHorizontalGridStartingHeightOffset(currentSack);
        var labelWidth = config.textType()==NONE?0: 10;
        var rowHeightMultiplier = getHorizontalGridHeightSpacing(currentSack);
        if (config.alwaysDisableLabelsInGrid()) {
            labelWidth=0;
        } else if (labelWidth>0) {
            widthBetween+=6;
            x-=4;
            if (config.showOverlayIcons()) {
                widthBetween+=6; // If icons are on AND labels are on
                x-=9;
            }
        }

        int row = 0;
        for (Entry<PlankTier, Integer> nextPlank : currentSack) {
            String label = null;
            BufferedImage image = config.showOverlayIcons()?Images.getIconForTier(nextPlank.getKey()):null;
            if (config.textType()!=NONE && !config.alwaysDisableLabelsInGrid()) {
                label = getOverlayText(nextPlank.getKey());
            }
            if (columnFinished) {
                drawSingleSmallPlankOverlay(graphics, image, label, font, config.textColor(), config.numberColor(), ""+nextPlank.getValue(), x+widthBetween, y+(rowHeightMultiplier*row), labelWidth);
                row++;
                columnFinished = false;
            } else {
                drawSingleSmallPlankOverlay(graphics, image, label, font, config.textColor(), config.numberColor(), ""+nextPlank.getValue(), x, y+(rowHeightMultiplier*row), labelWidth );
                columnFinished = true;
            }
        }
    }

    String getOverlayText(PlankTier tier) {
        switch (tier) {
            case PLANK:
                return "P:";
            case OAK:
                return "O:";
            case TEAK:
                return "T:";
            case MAHOGANY:
                return "M:";
            case ROSEWOOD:
                return "R:";
            case IRONWOOD:
                return "I:";
            case CAMPHOR:
                return "C:";
        }
        return "";
    }

    static protected void drawSingleSmallPlankOverlay(Graphics2D graphics, @Nullable BufferedImage icon, @Nullable String label, Font font, Color textColor, Color numberColor, String amount, int x, int y, int labelWidth) {
        var runningXOffset = 0;
        graphics.setFont(font);
        int fontHeight = graphics.getFontMetrics(font).getHeight();
        if (label!=null && label.isEmpty()) label=null;

        if (icon!=null) {
            OverlayUtil.renderImageLocation(graphics, new Point(x+runningXOffset, y-(fontHeight+1)), icon);
            runningXOffset+=5;
        }
        runningXOffset+=5;
        if (label!=null) {
            PlankSackOverlay.drawStringShadowed(graphics, font, label, x+runningXOffset, y, textColor);
        }
        PlankSackOverlay.drawStringShadowed(graphics, font, amount,x+runningXOffset+labelWidth, y, numberColor);
    }

    private int getHorizontalGridStartingHeightOffset(PlankStorageSet planks) {
        var count = planks.countTypes();
        if (count<=4) return 2;
        if (count<=6) return 0;
        return -4;
    }

    private int getHorizontalGridHeightSpacing(PlankStorageSet planks) {
        var count = planks.countTypes();
        if (count<=2) return 21;
        if (count<=4) return 18;
        if (count<=6) return 15;
        return 12;
    }

}

package io.github.talkarcabbage.planksack.overlay;

import io.github.talkarcabbage.planksack.planksack.PlankSackManager;
import io.github.talkarcabbage.planksack.planksack.PlankStorageSet;
import io.github.talkarcabbage.planksack.planksack.PlankTier;
import io.github.talkarcabbage.planksack.SackTrackerConfig;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;
import net.runelite.client.util.ColorUtil;

import java.awt.*;

public class SackTooltip {

    private static final String BR = "</br>";

    private final PlankSackManager manager;
    private final TooltipManager tooltipManager;
    private final SackTrackerConfig config;

    public SackTooltip(PlankSackManager manager, TooltipManager tooltipManager, SackTrackerConfig config) {
        this.manager = manager;
        this.tooltipManager = tooltipManager;
        this.config = config;
    }

    void renderTooltip() {
        var currentPlankSack = manager.getCurrentPlankSack();
        var brLength = 0;
        StringBuilder tb = new StringBuilder();

        if (currentPlankSack.isEmpty()) {
            tooltipManager.add(new Tooltip("Empty!"));
            return;
        }

        tb.append(currentPlankSack.getPlanks()>0? getTooltipTierText(PlankTier.PLANK, currentPlankSack)+"\n":"");
        if (tb.length()>brLength) {
            tb.append(BR);
            brLength = tb.length();
        }
        tb.append(currentPlankSack.getOaks()>0? getTooltipTierText(PlankTier.OAK, currentPlankSack)+"\n":"");
        if (tb.length()>brLength) {
            tb.append(BR);
            brLength = tb.length();
        }
        tb.append(currentPlankSack.getTeaks()>0? getTooltipTierText(PlankTier.TEAK, currentPlankSack)+"\n":"");
        if (tb.length()>brLength) {
            tb.append(BR);
            brLength = tb.length();
        }
        tb.append(currentPlankSack.getMahoganies()>0? getTooltipTierText(PlankTier.MAHOGANY, currentPlankSack)+"\n":"");
        if (tb.length()>brLength) {
            tb.append(BR);
            brLength = tb.length();
        }
        tb.append(currentPlankSack.getRosewoods()>0? getTooltipTierText(PlankTier.ROSEWOOD, currentPlankSack)+"\n":"");
        if (tb.length()>brLength) {
            tb.append(BR);
            brLength = tb.length();
        }
        tb.append(currentPlankSack.getIronwoods()>0? getTooltipTierText(PlankTier.IRONWOOD, currentPlankSack)+"\n":"");
        if (tb.length()>brLength) {
            tb.append(BR);
        }
        tb.append(currentPlankSack.getCamphors()>0? getTooltipTierText(PlankTier.CAMPHOR, currentPlankSack)+"\n":"");
        tooltipManager.add(new Tooltip(tb.toString()));
    }

    //Commonly shared method for getting overlay text used in other overlays
    String getTooltipTierText(PlankTier tier, PlankStorageSet storage) {
        var textColor = config.tooltipTextColor();
        var numberColor = config.tooltipNumberColor();

        switch (tier) {
            case PLANK:
                return color(padTwo(storage.getTierAmount(tier)), numberColor) + color(" Basic planks", textColor);
            case OAK:
                return color(padTwo(storage.getTierAmount(tier)), numberColor) + color(" Oak planks", textColor);
            case TEAK:
                return color(padTwo(storage.getTierAmount(tier)), numberColor) + color(" Teak planks", textColor);
            case MAHOGANY:
                return color(padTwo(storage.getTierAmount(tier)), numberColor) + color(" Mahogany planks", textColor);
            case ROSEWOOD:
                return color(padTwo(storage.getTierAmount(tier)), numberColor) + color(" Rosewood planks", textColor);
            case IRONWOOD:
                return color(padTwo(storage.getTierAmount(tier)), numberColor) + color(" Ironwood planks", textColor);
            case CAMPHOR:
                return color(padTwo(storage.getTierAmount(tier)), numberColor) + color(" Camphor planks", textColor);
        }
        return "";
    }

    private String padTwo(int number) {
        if (number==1) return number+"  "; //1 is very thin on rs font
        if (number<9) return number+" ";
        return number+"";
    }

    public static String color(String text, Color color) {
        return ColorUtil.wrapWithColorTag(text, color);
    }

}

package io.github.talkarcabbage.planksack.overlay;

import io.github.talkarcabbage.planksack.SackTrackerConfig;
import io.github.talkarcabbage.planksack.overlayenums.SmallNumberPlacement;
import io.github.talkarcabbage.planksack.planksack.PlankSackManager;
import io.github.talkarcabbage.planksack.planksack.PlankStorageSet;
import io.github.talkarcabbage.planksack.planksack.PlankTier;
import io.github.talkarcabbage.planksack.util.Entry;
import net.runelite.api.Point;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.OverlayUtil;

import java.awt.*;
import java.awt.image.BufferedImage;

//Definitely wasn't tempted to name this One Small Favour
public class OneSmallNumber {

    private final PlankSackManager manager;
    private final SackTrackerConfig config;


    public OneSmallNumber(PlankSackManager manager, SackTrackerConfig config) {
        this.manager = manager;
        this.config = config;
    }

    public void drawOneSmallNumber(Graphics2D graphics, WidgetItem widgetItem) {
        var currentPlankSack = manager.getCurrentPlankSack();
        graphics.setFont(FontManager.getRunescapeFont());
        int startingDrawX = widgetItem.getCanvasLocation().getX();
        int startingDrawY = widgetItem.getCanvasLocation().getY() + 31;
        int textDrawX = startingDrawX;
        int textDrawY = startingDrawY;
        if (config.smallNumberPlacement()== SmallNumberPlacement.TOP) {
            textDrawY-=20;
            textDrawX-=4;
            startingDrawY+=4;
        }
        BufferedImage image = null;
        var horizontalOffset = (currentPlankSack.getTotalPlanks()>9?-5:-3);

        if (config.showOverlayIcons()) {
            if (currentPlankSack.isMonoContent()) {
                image = Images.getIconForTier(currentPlankSack.getMonoType());
            } else {
                image = Images.plankImage;
            }
        }
        if (currentPlankSack.isEmpty() && config.displayZeroWhenEmpty()) {
            drawString(graphics, FontManager.getRunescapeSmallFont(), "0", textDrawX+9+horizontalOffset, textDrawY, config.numberColor());
        } else if (!currentPlankSack.isEmpty()){
            if (image!=null && config.enableIconOneNumber()) {
                drawStackedPlankIcons(graphics, startingDrawX+horizontalOffset+20, startingDrawY-(graphics.getFontMetrics().getHeight()+13), currentPlankSack) ;
            }
            drawString(graphics, FontManager.getRunescapeSmallFont(), ""+currentPlankSack.getTotalPlanks(), textDrawX+9+horizontalOffset, textDrawY, config.numberColor());
        }
    }
    private void drawString(Graphics2D graphics, Font font, String label, int x, int y, Color color) {
        graphics.setFont(font);
        graphics.setColor(Color.BLACK);
        graphics.drawString(label, x + 1, y + 1);
        graphics.setColor(color);
        graphics.drawString(label, x, y);
    }

    //For drawing the plank icons to the left of the big number in a way that takes up minimal space
    private void drawStackedPlankIcons(Graphics2D graphics, int x, int y, PlankStorageSet planks) {
        var numDone = 0;
        var types = planks.countTypes();
        if (types>3) y-=4;
        for (Entry<PlankTier, Integer> plank : planks) {
            var tier = plank.getKey();
            var icon = Images.getIconForTier(tier);
            OverlayUtil.renderImageLocation(graphics, new Point(x, y), icon);
            x -= 4;
            numDone++;
            if (numDone==3) {
                y+=7;
                if (types>6) {
                    x+=11; //Make a little extra space for the 7th plank icon
                } else {
                    x+=10;
                }
            }
        }
    }
}

package io.github.talkarcabbage.planksack.planksack;

public enum PlankTier {
    PLANK,
    OAK,
    TEAK,
    MAHOGANY,
    ROSEWOOD,
    IRONWOOD,
    CAMPHOR,
    UNKNOWN
}

package io.github.talkarcabbage.planksack.planksack;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;

@Slf4j
public class PlankSackManager {
    private final Client client;

    public PlankSackManager(Client client) {
        this.client = client;
    }
    private int cachedTick = 0;
    private PlankStorageSet cachedStorage = new PlankStorageSet(0,0,0,0,0,0,0);

    private boolean cachedSackInInventory = false;
    private int cachedSackInInventoryTick = 0;

    public PlankStorageSet getCurrentPlankSack() {
        if (client.getTickCount()==cachedTick) return cachedStorage;
        cachedTick = client.getTickCount();
        cachedStorage = new PlankStorageSet(
                client.getVarbitValue(VarbitID.PLANK_SACK_PLAIN),
                client.getVarbitValue(VarbitID.PLANK_SACK_OAK),
                client.getVarbitValue(VarbitID.PLANK_SACK_TEAK),
                client.getVarbitValue(VarbitID.PLANK_SACK_MAHOGANY),
                client.getVarbitValue(VarbitID.PLANK_SACK_ROSEWOOD),
                client.getVarbitValue(VarbitID.PLANK_SACK_IRONWOOD),
                client.getVarbitValue(VarbitID.PLANK_SACK_CAMPHOR)
        );
        return cachedStorage;
    }
    public boolean inventoryContainsPlankSack() {
        if (cachedSackInInventoryTick==client.getTickCount()) return cachedSackInInventory;
        var inv = client.getItemContainer(InventoryID.INV);
        if (inv!=null) { // It shouldn't ever be, I'd hope, but just in case.
            cachedSackInInventory = inv.contains(ItemID.PLANK_SACK);
        } else {
            cachedSackInInventory = false;
            log.warn("Inventory was detected as null when trying to determine whether to render the plank sack!");
        }
        cachedSackInInventoryTick = client.getTickCount();
        return cachedSackInInventory;
    }
}

package io.github.talkarcabbage.planksack.planksack;


import io.github.talkarcabbage.planksack.util.Entry;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import javax.annotation.Nonnull;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

@Getter
@Slf4j
public class PlankStorageSet implements Iterable<Entry<PlankTier, Integer>>{
    private final int planks;
    private final int oaks;
    private final int teaks;
    private final int mahoganies;
    private final int rosewoods;
    private final int ironwoods;
    private final int camphors;

    public PlankStorageSet(int planks, int oaks, int teaks, int mahoganies, int rosewoods, int ironwoods, int camphors) {
        this.planks=planks;
        this.oaks=oaks;
        this.teaks=teaks;
        this.mahoganies=mahoganies;
        this.rosewoods = rosewoods;
        this.ironwoods = ironwoods;
        this.camphors = camphors;
    }
    /**
     * Returns true if the storage set only contains one type of plank
     */
    public boolean isMonoContent() {
        return countTypes()==1;
    }

    public int countTypes() {
        int count = 0;
        if (planks != 0) count++;
        if (oaks != 0) count++;
        if (teaks != 0) count++;
        if (mahoganies != 0) count++;
        if (rosewoods != 0) count++;
        if (ironwoods != 0) count++;
        if (camphors != 0) count++;
        return count;
    }

    /**
     * Returns true if every plank value in this storage set is 0
     */
    public boolean isEmpty() {
        return planks == 0 && oaks == 0 && teaks == 0 && mahoganies == 0 && rosewoods==0&&ironwoods==0&&camphors==0;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        boolean comma = false;
        sb.append("[");
        if (planks!=0) {
            sb.append(planks).append(" planks");
            comma=true;
        }
        if (oaks!=0) {
            if (comma) sb.append(", ");
            sb.append(oaks).append(" oak planks");
            comma=true;
        }
        if (teaks!=0) {
            if (comma) sb.append(", ");
            sb.append(teaks).append(" teak planks");
            comma=true;
        }
        if (mahoganies!=0) {
            if (comma) sb.append(", ");
            sb.append(mahoganies).append(" mahogany planks");
            comma=true;
        }
        if (rosewoods != 0) {
            if (comma) sb.append(", ");
            sb.append(rosewoods).append(" rosewood planks");
            comma = true;
        }
        if (ironwoods != 0) {
            if (comma) sb.append(", ");
            sb.append(ironwoods).append(" ironwood planks");
            comma = true;
        }
        if (camphors != 0) {
            if (comma) sb.append(", ");
            sb.append(camphors).append(" camphor planks");
        }
        sb.append("]");
        return sb.toString();
    }

    public PlankTier getMonoType( ) {
        if (!this.isMonoContent()) return PlankTier.UNKNOWN;
        if (planks!=0) return PlankTier.PLANK;
        if (oaks!=0) return PlankTier.OAK;
        if (teaks!=0) return PlankTier.TEAK;
        if (mahoganies!=0) return PlankTier.MAHOGANY;
        if (rosewoods!=0) return PlankTier.ROSEWOOD;
        if (ironwoods!=0) return PlankTier.IRONWOOD;
        if (camphors!=0) return PlankTier.CAMPHOR;
        return PlankTier.UNKNOWN;
    }

    public int getTotalPlanks() {
        return planks+oaks+teaks+mahoganies+rosewoods+ironwoods+camphors;
    }

    /**
     * Returns the number of planks matching the given tier of plank
     */
    public int getTierAmount(PlankTier tier) {
        switch (tier){
            case PLANK: return planks;
            case OAK: return oaks;
            case TEAK: return teaks;
            case MAHOGANY: return mahoganies;
            case ROSEWOOD: return rosewoods;
            case IRONWOOD: return ironwoods;
            case CAMPHOR: return camphors;
            default: return 0;
        }
    }
    @Nonnull
    @Override
    public Iterator<Entry<PlankTier, Integer>> iterator() {
        List<Entry<PlankTier, Integer>> nonZeroEntries = new ArrayList<>();
        addToIteratorIfPresent(nonZeroEntries, PlankTier.PLANK, planks);
        addToIteratorIfPresent(nonZeroEntries, PlankTier.OAK, oaks);
        addToIteratorIfPresent(nonZeroEntries, PlankTier.TEAK, teaks);
        addToIteratorIfPresent(nonZeroEntries, PlankTier.MAHOGANY, mahoganies);
        addToIteratorIfPresent(nonZeroEntries, PlankTier.ROSEWOOD, rosewoods);
        addToIteratorIfPresent(nonZeroEntries, PlankTier.IRONWOOD, ironwoods);
        addToIteratorIfPresent(nonZeroEntries, PlankTier.CAMPHOR, camphors);
        return nonZeroEntries.iterator();
    }

    private void addToIteratorIfPresent(List<Entry<PlankTier, Integer>> list, PlankTier tier, int value) {
        if (value != 0) {
            list.add(new Entry<>(tier, value));
        }
    }

}

package io.github.talkarcabbage.planksack;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PlankSackTrackerTest {
    public static void main(String[] args) throws Exception {
        ExternalPluginManager.loadBuiltin(PlankSackPlugin.class);
        RuneLite.main(args);
    }

}
