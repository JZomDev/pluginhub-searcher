package com.specialattacktimers;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Stroke;
import java.awt.geom.Arc2D;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

/**
 * Circular overlay that draws a progress arc around the special attack orb,
 * similar to the Regeneration Meter plugin.
 *
 * The arc fills up as you get closer to the next spec regen tick:
 * - Empty arc = just regenerated, 30 seconds until next
 * - Full arc = about to regenerate
 * - No arc when spec is at 100% or between waves (timer resets on wave start anyway)
 */
public class SpecialAttackTimersCircleOverlay extends Overlay
{
	/**
	 * Offset from the widget bounds to position the arc.
	 */
	private static final int OFFSET = 27;

	/**
	 * Diameter of the circular arc.
	 */
	private static final int DIAMETER = 26;

	/**
	 * Stroke width for drawing the arc.
	 */
	private static final int STROKE_WIDTH = 2;

	private final Client client;
	private final SpecialAttackTimersPlugin plugin;
	private final SpecialAttackTimersConfig config;

	@Inject
	public SpecialAttackTimersCircleOverlay(Client client, SpecialAttackTimersPlugin plugin, SpecialAttackTimersConfig config)
	{
		super(plugin);
		this.client = client;
		this.plugin = plugin;
		this.config = config;

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		// Don't render if not logged in
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			return null;
		}

		// Don't render if circular overlay is disabled
		if (!config.showCircularOverlay())
		{
			return null;
		}

		// Don't render if spec is full (nothing to show)
		if (plugin.isSpecFull())
		{
			return null;
		}

		// Don't render between waves - timer resets on wave start anyway
		if (plugin.isBetweenWaves())
		{
			return null;
		}

		// Find the spec orb widget (try standard orbs first, then no-map variant)
		Widget specOrbWidget = client.getWidget(InterfaceID.Orbs.ORB_SPECENERGY);
		if (specOrbWidget == null || specOrbWidget.isHidden())
		{
			specOrbWidget = client.getWidget(InterfaceID.OrbsNomap.ORB_SPECENERGY);
		}
		if (specOrbWidget == null || specOrbWidget.isHidden())
		{
			return null;
		}

		Rectangle bounds = specOrbWidget.getBounds();
		if (bounds.getX() <= 0)
		{
			return null;
		}

		// Calculate progress percentage (0.0 = just reset, 1.0 = about to regen)
		// This makes the arc fill UP as you get closer to regen, matching RegenMeter behavior
		// Uses getMaxRegenTicks() to account for Lightbearer (25 ticks instead of 50)
		double progress = 1.0 - ((double) plugin.getTicksUntilRegen() / plugin.getMaxRegenTicks());

		// Draw the arc with the configured circle color
		drawArc(graphics, bounds, progress, config.circleColor());

		return null;
	}

	/**
	 * Draws a circular progress arc around the spec orb.
	 *
	 * @param graphics The graphics context
	 * @param bounds   The widget bounds
	 * @param progress Progress from 0.0 (empty) to 1.0 (full)
	 * @param color    The color to draw the arc
	 */
	private void drawArc(Graphics2D graphics, Rectangle bounds, double progress, Color color)
	{
		// Enable anti-aliasing for smooth arc
		graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
		graphics.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_PURE);

		// Calculate arc position (centered on the orb)
		double x = bounds.getX() + OFFSET;
		double y = bounds.getY() + (bounds.getHeight() / 2.0 - DIAMETER / 2.0);

		// Create arc starting at top (90 degrees) and sweeping clockwise
		// Progress of 1.0 = full circle, 0.0 = no arc
		double sweepAngle = -360.0 * progress;
		Arc2D.Double arc = new Arc2D.Double(x, y, DIAMETER, DIAMETER, 90.0, sweepAngle, Arc2D.OPEN);

		// Draw the arc with stroke
		Stroke originalStroke = graphics.getStroke();
		graphics.setStroke(new BasicStroke(STROKE_WIDTH, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL));
		graphics.setColor(color);
		graphics.draw(arc);
		graphics.setStroke(originalStroke);
	}
}

package com.specialattacktimers;

import java.awt.Color;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("specialattacktimers")
public interface SpecialAttackTimersConfig extends Config
{
	@Getter
	@RequiredArgsConstructor
	enum DisplayFormat
	{
		TICKS("Ticks"),
		SECONDS("Seconds"),
		DECIMALS("Decimals");

		private final String name;

		@Override
		public String toString()
		{
			return name;
		}
	}

	@ConfigSection(
		name = "Display",
		description = "Overlay display settings",
		position = 0
	)
	String displaySection = "display";

	@ConfigItem(
		keyName = "showInfoBox",
		name = "Show InfoBox",
		description = "Show the special attack timer infobox",
		position = 1,
		section = displaySection
	)
	default boolean showInfoBox()
	{
		return true;
	}

	@ConfigItem(
		keyName = "displayFormat",
		name = "Display Format",
		description = "Ticks (game ticks), Seconds (whole), or Decimals (e.g. 29.4s)",
		position = 2,
		section = displaySection
	)
	default DisplayFormat displayFormat()
	{
		return DisplayFormat.TICKS;
	}

	@ConfigItem(
		keyName = "showCircularOverlay",
		name = "Show Circular Overlay",
		description = "Show circular progress indicator on the spec orb (like Regeneration Meter)",
		position = 3,
		section = displaySection
	)
	default boolean showCircularOverlay()
	{
		return true;
	}

	@ConfigSection(
		name = "Surge Potion Timer",
		description = "Surge potion cooldown timer settings",
		position = 5
	)
	String surgeSection = "surge";

	@ConfigItem(
		keyName = "showSurgeInfoBox",
		name = "Show Surge Timer",
		description = "Show the surge potion cooldown timer infobox",
		position = 6,
		section = surgeSection
	)
	default boolean showSurgeInfoBox()
	{
		return true;
	}

	@ConfigItem(
		keyName = "surgeDisplayFormat",
		name = "Surge Display Format",
		description = "Ticks (game ticks), Seconds (whole), or Decimals (e.g. 29.4s)",
		position = 7,
		section = surgeSection
	)
	default DisplayFormat surgeDisplayFormat()
	{
		return DisplayFormat.SECONDS;
	}

	@ConfigSection(
		name = "Colors",
		description = "Color settings for the overlay",
		position = 10
	)
	String colorSection = "colors";

	@Alpha
	@ConfigItem(
		keyName = "activeColor",
		name = "Infobox Color",
		description = "Color for the spec regen timer infobox text",
		position = 11,
		section = colorSection
	)
	default Color activeColor()
	{
		return new Color(255, 255, 255, 255);
	}

	@Alpha
	@ConfigItem(
		keyName = "circleColor",
		name = "Circle Overlay Color",
		description = "Color for the circular progress indicator on the spec orb",
		position = 12,
		section = colorSection
	)
	default Color circleColor()
	{
		return new Color(0, 255, 255, 255);
	}

	@Alpha
	@ConfigItem(
		keyName = "surgeColor",
		name = "Surge Active Color",
		description = "Color for the surge potion cooldown timer when active (unpaused)",
		position = 13,
		section = colorSection
	)
	default Color surgeColor()
	{
		return new Color(255, 255, 255, 255);
	}

	@Alpha
	@ConfigItem(
		keyName = "surgePausedColor",
		name = "Surge Paused Color",
		description = "Color for the surge potion cooldown timer when paused (between waves/rooms)",
		position = 14,
		section = colorSection
	)
	default Color surgePausedColor()
	{
		return new Color(255, 165, 0, 255);
	}
}

package com.specialattacktimers;

import java.awt.Color;
import net.runelite.client.ui.overlay.infobox.InfoBox;

/**
 * InfoBox that displays the special attack regeneration timer as a simple tick count.
 * Shows "Spec Regen Timer" on hover.
 */
public class SpecialAttackTimersInfoBox extends InfoBox
{
	private final SpecialAttackTimersPlugin plugin;
	private final SpecialAttackTimersConfig config;

	public SpecialAttackTimersInfoBox(SpecialAttackTimersPlugin plugin, SpecialAttackTimersConfig config)
	{
		super(null, plugin);
		this.plugin = plugin;
		this.config = config;
	}

	@Override
	public String getText()
	{
		// Display tick 0 instead of max ticks (25 with LB, 50 without)
		int ticksUntilRegen = plugin.getTicksUntilRegen();
		int displayTicks = ticksUntilRegen == plugin.getMaxRegenTicks() ? 0 : ticksUntilRegen;

		switch (config.displayFormat())
		{
			case SECONDS:
				// Whole seconds (rounded up so you know when regen will happen)
				int wholeSeconds = (int) Math.ceil(displayTicks * 0.6);
				return String.valueOf(wholeSeconds);
			case DECIMALS:
				// Decimal seconds (e.g. 29.4s)
				double decimalSeconds = displayTicks * 0.6;
				return String.format("%.1fs", decimalSeconds);
			case TICKS:
			default:
				return String.valueOf(displayTicks);
		}
	}

	@Override
	public Color getTextColor()
	{
		return config.activeColor();
	}

	@Override
	public boolean render()
	{
		// Don't render if spec is full or between waves/delves (timer paused)
		return !plugin.isSpecFull() && !plugin.isBetweenWaves();
	}

	@Override
	public String getTooltip()
	{
		return "Spec Regen Timer";
	}
}

package com.specialattacktimers;

import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import java.time.Duration;
import java.time.Instant;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.Set;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.InventoryID;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.NPC;
import net.runelite.api.SpriteID;
import net.runelite.api.VarPlayer;
import net.runelite.api.Varbits;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.NpcChanged;
import net.runelite.api.events.NpcSpawned;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.Text;

/**
 * Special Attack Regen Timer Plugin for the Colosseum, Doom of Mokhaiotl, and Theatre of Blood.
 *
 * This plugin tracks special attack regeneration timing in content where the timer
 * pauses between encounters (waves/delves/rooms) and resets when a new encounter starts,
 * matching the game's behavior.
 * Supports Lightbearer ring which halves the regen time (25 ticks instead of 50).
 *
 * Colosseum transitions (via chat messages):
 * - "Wave X completed!": Wave finished, timer stops until next wave
 * - "Wave: X": New wave starting, timer resets to 30 seconds (or 15 with Lightbearer)
 * - "Search the chest nearby": Run over (claimed rewards), timer continues
 *
 * Doom of Mokhaiotl transitions:
 * - "Delve level: X duration: ..." or "Delve level: 8+ (X+ duration: ..." (chat): Delve finished, timer stops
 * - Boss NPC spawns: Timer resumes and resets (more accurate than chat message)
 *
 * Theatre of Blood transitions:
 * - "Wave 'Room Name' (...) complete!" (chat): Room finished, timer stops
 * - Room boss NPC spawns: Timer resumes and resets
 * - "Theatre of Blood total completion time:" (chat): Run completed, timer resumes
 *
 * The timer also resets whenever spec energy actually increases,
 * preventing drift between the overlay and actual game mechanics.
 */
@Slf4j
@PluginDescriptor(
	name = "Special Attack Timers",
	description = "Properly tracks special attack regeneration and surge potion cooldown in wave-based content (Colosseum, Doom of Mokhaiotl, Theatre of Blood)",
	tags = {"colosseum", "special", "attack", "spec", "timer", "regen", "lightbearer", "doom", "mokhaiotl", "delve", "tob", "theatre", "blood", "surge", "potion"}
)
public class SpecialAttackTimersPlugin extends Plugin
{
	/**
	 * Pattern to match the wave start message in chat.
	 * Matches "Wave: 1" through "Wave: 12".
	 */
	private static final Pattern WAVE_START_PATTERN = Pattern.compile("^Wave: (1[0-2]|[1-9])$");

	/**
	 * Pattern to match the wave completed message in chat.
	 * Matches "Wave 1 completed!" through "Wave 12 completed!" (with duration info after).
	 * This is when spec regen stops until the next wave.
	 */
	private static final Pattern WAVE_COMPLETED_PATTERN = Pattern.compile("^Wave (1[0-2]|[1-9]) completed!.*");

	/**
	 * Partial message that appears when the player claims rewards (run is over).
	 * Spec regen continues normally after this.
	 */
	private static final String CLAIM_REWARDS_MESSAGE = "Search the chest nearby";

	/**
	 * Region ID for Fortis Colosseum.
	 * Used to detect when the player leaves the area to unpause timers.
	 */
	private static final int COLOSSEUM_REGION_ID = 7216;

	/**
	 * Prefix for delve completed messages in Doom of Mokhaiotl.
	 * Regular delves: "Delve level: X duration: ..."
	 * Deep delves (8+): varies in format, but always starts with "Delve level:" and contains "duration:"
	 * This is when spec regen stops. Timer resumes when the boss NPC spawns.
	 */
	private static final String DELVE_COMPLETED_PREFIX = "Delve level:";
	private static final String DELVE_DURATION_MARKER = "duration:";

	/**
	 * Region IDs for Doom of Mokhaiotl content.
	 * Used to detect when the player leaves the area to unpause timers.
	 * Includes the delve areas and boss room.
	 */
	private static final Set<Integer> DOOM_REGION_IDS = Set.of(
		13668,  // Doom area
		14180   // Doom area
	);

	/**
	 * Doom exit tile coordinates.
	 * When leaving Doom normally (not teleporting), the player arrives at this tile
	 * in the hallway (region 5269). We check for this tile to unpause timers.
	 */
	private static final int DOOM_EXIT_TILE_X = 1311;
	private static final int DOOM_EXIT_TILE_Y = 9556;

	/**
	 * Message that appears when drinking a surge potion (restores 25% spec).
	 * We need to ignore the spec increase from this to avoid resetting the timer.
	 */
	private static final String SURGE_POTION_MESSAGE = "You drink some of your surge potion.";

	/**
	 * Message that appears when surge potion cooldown expires.
	 * Used to clear the cooldown timer.
	 */
	private static final String SURGE_COOLDOWN_EXPIRED_MESSAGE = "You now feel capable of drinking another dose of surge potion.";

	/**
	 * Spec energy restored by surge potion (25% = 250 internal units).
	 */
	private static final int SURGE_POTION_RESTORE = 250;

	/**
	 * Message that appears when Death Charge triggers (restores 15% spec on kill).
	 * We need to ignore the spec increase from this to avoid resetting the timer.
	 */
	private static final String DEATH_CHARGE_MESSAGE = "Some of your special attack energy has been restored";

	/**
	 * Spec energy restored by Death Charge (15% = 150 internal units).
	 */
	private static final int DEATH_CHARGE_RESTORE = 150;

	/**
	 * Surge potion cooldown duration in ticks (5 minutes = 300 seconds = 500 ticks).
	 */
	private static final int SURGE_COOLDOWN_TICKS = 500;

	/**
	 * Surge potion cooldown duration (5 minutes).
	 * Using wall-clock time for accurate display like RuneLite's timer system.
	 */
	private static final Duration SURGE_COOLDOWN_DURATION = Duration.ofMillis(SURGE_COOLDOWN_TICKS * 600L);


	// TOB

	/**
	 * Pattern to match TOB room completion messages.
	 * Matches "Wave 'Room Name' (...) complete!" for all rooms.
	 * Group 1 captures the room name.
	 */
	private static final Pattern TOB_ROOM_COMPLETED_PATTERN = Pattern.compile("^Wave '(.*)' \\(.*\\) complete!.*");

	/**
	 * Pattern to match TOB completion message (after Verzik).
	 */
	private static final Pattern TOB_COMPLETION_PATTERN = Pattern.compile("^Theatre of Blood total completion time:.*");

	/**
	 * Template region IDs for TOB boss rooms.
	 * TOB is instanced, so we use WorldPoint.fromLocalInstance() to convert
	 * the instanced coordinates to template region IDs.
	 * Based on tob-qol plugin: https://github.com/damencs/tob-qol
	 */
	private static final Set<Integer> TOB_BOSS_ROOM_REGIONS = Set.of(
		12613,  // Maiden
		13125,  // Bloat
		13122,  // Nylocas
		13123,  // Sotetseg (boss room)
		13379,  // Sotetseg (maze)
		12612,  // Xarpus
		12611   // Verzik
	);

	/**
	 * Bloat region ID (template). Bloat region includes a hallway before the combat area,
	 * so we use coordinate-based detection instead of region-based for this room.
	 */
	private static final int TOB_BLOAT_REGION = 13125;

	/**
	 * Bloat barrier tile coordinates (template coordinates).
	 * The barrier tiles are at X = 3303, Y = 4446-4449.
	 * Passing through these tiles (X <= 3303 at these Y values) means entering the combat area.
	 */
	private static final int BLOAT_BARRIER_X = 3303;
	private static final int BLOAT_BARRIER_MIN_Y = 4446;
	private static final int BLOAT_BARRIER_MAX_Y = 4449;

	/**
	 * Nylocas region ID (template). Like Bloat, Nylocas has a hallway before combat area.
	 */
	private static final int TOB_NYLOCAS_REGION = 13122;

	/**
	 * Nylocas barrier tile coordinates (template coordinates).
	 * The barrier tiles are at X = 3295-3296, Y = 4254.
	 */
	private static final int NYLOCAS_BARRIER_MIN_X = 3295;
	private static final int NYLOCAS_BARRIER_MAX_X = 3296;
	private static final int NYLOCAS_BARRIER_Y = 4254;

	/**
	 * Sotetseg region ID (template). Like Bloat/Nylocas, uses coordinate-based detection.
	 */
	private static final int TOB_SOTETSEG_REGION = 13123;

	/**
	 * Sotetseg barrier tile coordinates (template coordinates).
	 * The barrier tiles are at X = 3278-3281, Y = 4308.
	 */
	private static final int SOTETSEG_BARRIER_MIN_X = 3278;
	private static final int SOTETSEG_BARRIER_MAX_X = 3281;
	private static final int SOTETSEG_BARRIER_Y = 4308;

	/**
	 * Xarpus region ID (template). Uses coordinate-based detection.
	 */
	private static final int TOB_XARPUS_REGION = 12612;

	/**
	 * Xarpus barrier tile coordinates (template coordinates).
	 * The barrier tiles are at X = 3169-3171, Y = 4380.
	 */
	private static final int XARPUS_BARRIER_MIN_X = 3169;
	private static final int XARPUS_BARRIER_MAX_X = 3171;
	private static final int XARPUS_BARRIER_Y = 4380;

	/**
	 * Verzik P1 NPC IDs when the fight starts.
	 * Verzik transforms into these IDs (doesn't spawn as them), so we use NpcChanged event.
	 * 8370 = Normal Mode P1, 10831 = Entry Mode P1, 10848 = Hard Mode P1.
	 */
	private static final Set<Integer> VERZIK_FIGHT_START_NPC_IDS = Set.of(8370, 10831, 10848);

	/**
	 * TOB reward chest region ID (template).
	 * Surge potion timer should be hidden when entering this region.
	 */
	private static final int TOB_REWARD_REGION = 12867;

	/**
	 * Enum representing TOB rooms in order.
	 * Used to track which room should be checked next for entry detection,
	 * preventing re-triggering on the same tiles when leaving a room.
	 */
	@Getter
	@RequiredArgsConstructor
	private enum TobRoom
	{
		MAIDEN(12613),
		BLOAT(13125),
		NYLOCAS(13122),
		SOTETSEG(13123),
		XARPUS(12612),
		VERZIK(12611),
		COMPLETE(-1);

		private final int regionId;

		/**
		 * Gets the next room in sequence.
		 */
		public TobRoom next()
		{
			int nextOrdinal = this.ordinal() + 1;
			TobRoom[] values = TobRoom.values();
			if (nextOrdinal >= values.length)
			{
				return COMPLETE;
			}
			return values[nextOrdinal];
		}
	}

	/**
	 * Special attack regenerates 10% every 30 seconds (50 game ticks).
	 * Each game tick is 0.6 seconds.
	 */
	public static final int SPEC_REGEN_TICKS = 50;

	/**
	 * With Lightbearer equipped, spec regenerates twice as fast (25 ticks).
	 */
	public static final int LIGHTBEARER_REGEN_TICKS = SPEC_REGEN_TICKS / 2;

	/**
	 * Maximum special attack energy (displayed as 100%, stored as 1000 internally).
	 */
	private static final int MAX_SPEC_ENERGY = 1000;

	@Inject
	private Client client;

	@Inject
	private SpecialAttackTimersConfig config;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private SpecialAttackTimersCircleOverlay circleOverlay;

	@Inject
	private InfoBoxManager infoBoxManager;

	@Inject
	private SpriteManager spriteManager;

	@Inject
	private ItemManager itemManager;

	/**
	 * The infobox instance, created when useInfoBox config is enabled.
	 */
	private SpecialAttackTimersInfoBox infoBox;

	/**
	 * Whether we are currently between waves/delves (Colosseum or Doom of Mokhaiotl).
	 * When true, the spec regen timer is stopped and will reset when the next encounter starts.
	 */
	@Getter
	private boolean betweenWaves = false;

	/**
	 * Ticks remaining until the next spec regen tick.
	 * Counts down from SPEC_REGEN_TICKS (50) to 0, then resets.
	 */
	@Getter
	private int ticksUntilRegen = SPEC_REGEN_TICKS;

	/**
	 * Last known special attack energy value (0-1000).
	 * Used to detect when spec has regenerated or been used.
	 */
	private int lastSpecEnergy = -1;

	/**
	 * Whether the player is wearing a Lightbearer ring.
	 * When true, spec regenerates twice as fast (25 ticks instead of 50).
	 */
	@Getter
	private boolean wearingLightbearer = false;

	/**
	 * Game tick until which spec increases should be ignored (for surge potion, death charge, etc.).
	 * Set to client.getTickCount() + 2 when a spec restore message is detected.
	 * A value of -1 means no grace period is active.
	 */
	private int ignoreSpecIncreaseUntilTick = -1;

	/**
	 * Expected spec restore amount from the detected effect (surge potion or death charge).
	 * Used to detect if natural regen also occurred during the grace period.
	 */
	private int expectedSpecRestoreAmount = 0;

	/**
	 * Whether the player is currently inside Theatre of Blood.
	 * Used to determine if TOB room detection should be active.
	 */
	private boolean insideTob = false;

	/**
	 * Whether the player is currently inside Doom of Mokhaiotl.
	 * Used to detect when the player leaves to unpause timers.
	 */
	private boolean insideDoom = false;

	/**
	 * Whether the player is currently inside Fortis Colosseum.
	 * Used to detect when the player leaves to unpause timers.
	 */
	private boolean insideColosseum = false;

	/**
	 * Whether the player is currently between TOB rooms.
	 * Used to pause the surge cooldown timer (but not spec regen).
	 */
	private boolean tobBetweenRooms = false;

	/**
	 * Last known region ID, used to detect room transitions in TOB.
	 */
	private int lastRegionId = -1;

	/**
	 * Whether we have already triggered combat area entry for the current room.
	 * Prevents re-triggering after room completion while still in the same region.
	 * Reset when entering a new region or when a room completes.
	 */
	private boolean combatAreaEnteredThisRoom = false;

	/**
	 * The next TOB room we're expecting to enter.
	 * Only coordinate/NPC spawn checks for this room will unpause the timer.
	 * This prevents re-triggering when walking back over previous room's entry tiles.
	 */
	private TobRoom nextExpectedTobRoom = TobRoom.MAIDEN;

	/**
	 * Wall-clock time when the surge potion cooldown ends.
	 * Null when no cooldown is active or when paused.
	 */
	private Instant surgeEndTime = null;

	/**
	 * Remaining surge cooldown duration when paused (between waves/rooms).
	 * Null when not paused or no cooldown is active.
	 */
	private Duration surgePausedRemaining = null;

	/**
	 * The surge potion cooldown infobox instance.
	 */
	private SurgePotionInfoBox surgeInfoBox;

	/**
	 * Last known value of the surge potion varbit.
	 * Used to detect when the game clears the cooldown (varbit goes to 0).
	 */
	private int lastSurgeVarbitValue = 0;

	/**
	 * Flag to force syncing with the next varbit update.
	 * Set when resuming from pause, as the varbit might update to the correct
	 * value shortly after the wave/room starts.
	 */
	private boolean surgeNeedsVarbitSync = false;

	@Override
	protected void startUp() throws Exception
	{
		log.debug("Special Attack Timers plugin started");
		overlayManager.add(circleOverlay);
		updateInfoBox();
		updateSurgeInfoBox();
		resetState();
	}

	@Override
	protected void shutDown() throws Exception
	{
		log.debug("Special Attack Timers plugin stopped");
		overlayManager.remove(circleOverlay);
		removeInfoBox();
		removeSurgeInfoBox();
		resetState();
	}

	/**
	 * Updates the infobox visibility based on config.
	 */
	private void updateInfoBox()
	{
		if (config.showInfoBox())
		{
			addInfoBox();
		}
		else
		{
			removeInfoBox();
		}
	}

	/**
	 * Creates and adds the infobox if it doesn't exist.
	 * Uses async sprite loading to ensure the image is available before adding.
	 */
	private void addInfoBox()
	{
		if (infoBox == null)
		{
			infoBox = new SpecialAttackTimersInfoBox(this, config);
			// Load the sprite asynchronously - only add to manager once image is ready
			spriteManager.getSpriteAsync(SpriteID.MINIMAP_ORB_SPECIAL_ICON, 0, img ->
			{
				if (img != null && infoBox != null)
				{
					infoBox.setImage(img);
					infoBoxManager.addInfoBox(infoBox);
				}
			});
		}
	}

	/**
	 * Removes the infobox if it exists.
	 */
	private void removeInfoBox()
	{
		if (infoBox != null)
		{
			infoBoxManager.removeInfoBox(infoBox);
			infoBox = null;
		}
	}

	/**
	 * Updates the surge infobox visibility based on config.
	 */
	private void updateSurgeInfoBox()
	{
		if (config.showSurgeInfoBox())
		{
			addSurgeInfoBox();
		}
		else
		{
			removeSurgeInfoBox();
		}
	}

	/**
	 * Creates and adds the surge infobox if it doesn't exist.
	 * Uses the surge potion item image.
	 */
	private void addSurgeInfoBox()
	{
		if (surgeInfoBox == null)
		{
			surgeInfoBox = new SurgePotionInfoBox(this, config);
			// Use surge potion item image
			surgeInfoBox.setImage(itemManager.getImage(ItemID.SURGE_POTION1));
			infoBoxManager.addInfoBox(surgeInfoBox);
		}
	}

	/**
	 * Removes the surge infobox if it exists.
	 */
	private void removeSurgeInfoBox()
	{
		if (surgeInfoBox != null)
		{
			infoBoxManager.removeInfoBox(surgeInfoBox);
			surgeInfoBox = null;
		}
	}

	/**
	 * Resets all tracking state to initial values.
	 * Called on startup, shutdown, and login/logout transitions.
	 */
	private void resetState()
	{
		betweenWaves = false;
		ticksUntilRegen = SPEC_REGEN_TICKS;
		lastSpecEnergy = -1;
		wearingLightbearer = false;
		ignoreSpecIncreaseUntilTick = -1;
		expectedSpecRestoreAmount = 0;
		insideTob = false;
		insideDoom = false;
		insideColosseum = false;
		tobBetweenRooms = false;
		lastRegionId = -1;
		combatAreaEnteredThisRoom = false;
		nextExpectedTobRoom = TobRoom.MAIDEN;
		surgeEndTime = null;
		surgePausedRemaining = null;
		lastSurgeVarbitValue = 0;
		surgeNeedsVarbitSync = false;
	}

	@Provides
	SpecialAttackTimersConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(SpecialAttackTimersConfig.class);
	}

	/**
	 * Handles config changes to toggle infobox visibility.
	 */
	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (!"specialattacktimers".equals(event.getGroup()))
		{
			return;
		}

		if ("showInfoBox".equals(event.getKey()))
		{
			updateInfoBox();
		}
		else if ("showSurgeInfoBox".equals(event.getKey()))
		{
			updateSurgeInfoBox();
		}
	}

	/**
	 * Handles game state changes (login, logout, hopping).
	 * Resets state when transitioning to avoid stale data.
	 */
	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		GameState state = event.getGameState();

		// Reset state on logout or hopping to prevent carrying stale data
		if (state == GameState.LOGIN_SCREEN || state == GameState.HOPPING)
		{
			resetState();
		}
		else if (state == GameState.LOGGED_IN)
		{
			// Initialize lastSpecEnergy on login
			lastSpecEnergy = getSpecEnergy();
			// Note: Surge timer initialization is handled in onVarbitChanged,
			// which fires after LOGGED_IN once varbits are loaded from the server
		}
	}

	/**
	 * Handles varbit changes to detect entering/leaving Theatre of Blood
	 * and surge potion cooldown state changes.
	 * TOB varbit is 2 or 3 when inside, other values when outside.
	 * Surge varbit (2386) tracks the cooldown server-side; syncs our timer on changes.
	 */
	@Subscribe
	public void onVarbitChanged(VarbitChanged event)
	{
		// Check for surge potion varbit changes
		// This syncs our manual timer with the game state (handles login, death, world hop, etc.)
		if (event.getVarbitId() == VarbitID.SURGE_POTION_TIMER)
		{
			int newValue = event.getValue();
			if (newValue > 0)
			{
				// Varbit has a positive value - start/update surge timer
				// This handles login with existing cooldown, as varbits fire after LOGGED_IN
				int remainingTicks = newValue * 10;
				Duration remainingDuration = Duration.ofMillis(remainingTicks * 600L);

				// Update timer if:
				// 1. surgeNeedsVarbitSync is true (just resumed, need to sync with game)
				// 2. No timer exists OR new duration is longer than current
				//    (handles login where varbit may fire multiple times with increasing values)
				Duration currentRemaining = getSurgeCooldownRemaining();
				boolean shouldSync = surgeNeedsVarbitSync || remainingDuration.compareTo(currentRemaining) > 0;
				log.debug("Surge varbit changed: value={}, ticks={}, duration={}, currentRemaining={}, paused={}, needsSync={}, shouldSync={}",
					newValue, remainingTicks, remainingDuration, currentRemaining, surgePausedRemaining != null, surgeNeedsVarbitSync, shouldSync);

				if (shouldSync)
				{
					if (betweenWaves || tobBetweenRooms)
					{
						// Start in paused state
						surgePausedRemaining = remainingDuration;
						surgeEndTime = null;
					}
					else
					{
						surgeEndTime = Instant.now().plus(remainingDuration);
						surgePausedRemaining = null;
					}
					updateSurgeInfoBox();
					surgeNeedsVarbitSync = false;
				}
			}
			else if (lastSurgeVarbitValue > 0)
			{
				// Cooldown was cleared by the game (death, expiration, etc.)
				// Clear our manual timer to stay in sync
				log.debug("Surge varbit cleared by game (was {}, now 0), clearing manual timer", lastSurgeVarbitValue);
				clearSurgeCooldown();
				removeSurgeInfoBox();
			}
			lastSurgeVarbitValue = newValue;
		}

		// Check for TOB entry/exit
		int tobVar = client.getVarbitValue(Varbits.THEATRE_OF_BLOOD);
		boolean nowInsideTob = tobVar == 2 || tobVar == 3;

		if (nowInsideTob != insideTob)
		{
			insideTob = nowInsideTob;

			if (insideTob)
			{
				// Entered TOB - check if already in a boss room
				// Use template region ID for instanced content
				int currentRegion = getTemplateRegionId();

				if (TOB_BOSS_ROOM_REGIONS.contains(currentRegion))
				{
					// Already in a boss room, don't pause
					tobBetweenRooms = false;
				}
				else
				{
					// In lobby/transition area, pause until room entry
					tobBetweenRooms = true;
				}
			}
			else
			{
				// Left TOB, reset state for next raid
				tobBetweenRooms = false;
				nextExpectedTobRoom = TobRoom.MAIDEN;
			}
			updateSurgePauseState();
		}
	}

	/**
	 * Handles equipment changes to detect Lightbearer ring.
	 * When Lightbearer is equipped/unequipped, adjusts the timer appropriately.
	 */
	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event)
	{
		if (event.getContainerId() != InventoryID.EQUIPMENT.getId())
		{
			return;
		}

		ItemContainer equipment = event.getItemContainer();
		final boolean hasLightbearer = equipment.contains(ItemID.LIGHTBEARER);

		if (hasLightbearer == wearingLightbearer)
		{
			return;
		}

		if (hasLightbearer)
		{
			// Equipping Lightbearer: cap timer at 25 ticks (preserve progress if close to regen)
			ticksUntilRegen = Math.min(ticksUntilRegen, LIGHTBEARER_REGEN_TICKS);
		}
		else
		{
			// Unequipping Lightbearer: reset to full 50 tick cycle
			ticksUntilRegen = SPEC_REGEN_TICKS;
		}

		wearingLightbearer = hasLightbearer;
	}

	/**
	 * Detects when boss NPCs spawn to resume timers.
	 * Handles Doom of Mokhaiotl spec regen timer.
	 * Uses getMaxRegenTicks() - 2 for Doom because the game's internal timer starts
	 * 2 ticks before the NPC spawn event fires.
	 */
	@Subscribe
	public void onNpcSpawned(NpcSpawned event)
	{
		NPC npc = event.getNpc();
		String name = npc.getName();

		// Doom of Mokhaiotl boss spawn - resumes spec regen timer
		if (name != null && name.contains("Doom"))
		{
			log.debug("Doom boss '{}' spawned - resuming timers. Surge paused remaining: {}", name, surgePausedRemaining);
			betweenWaves = false;
			ticksUntilRegen = getMaxRegenTicks() - 2;
			updateSurgePauseState();
		}
	}

	/**
	 * Detects when Verzik transforms to her fighting form.
	 * Verzik doesn't spawn as her fight NPC ID - she transforms into it.
	 * This handles Entry Mode (10831), Normal Mode (8370), and Hard Mode (10848).
	 */
	@Subscribe
	public void onNpcChanged(NpcChanged event)
	{
		NPC npc = event.getNpc();

		// Verzik fight start - NPC transforms when the fight begins
		// Only trigger if Verzik is the next expected room
		if (VERZIK_FIGHT_START_NPC_IDS.contains(npc.getId())
			&& nextExpectedTobRoom == TobRoom.VERZIK
			&& tobBetweenRooms
			&& !combatAreaEnteredThisRoom)
		{
			log.debug("Verzik NPC {} transformed (fight started), unpausing timer", npc.getId());
			tobBetweenRooms = false;
			combatAreaEnteredThisRoom = true;
			updateSurgePauseState();
		}
	}

	/**
	 * Handles chat messages to detect wave/delve transitions.
	 * Colosseum:
	 * - "Wave X completed!": Wave finished, timer stops
	 * - "Wave: X" (1-12): Wave starting, timer resets to 30 seconds
	 * - "Search the chest...": Run over (claimed rewards), timer continues
	 * Doom of Mokhaiotl:
	 * - "Delve level: X duration: ..." or "Delve level: 8+ (X+ duration: ...": Delve finished, timer stops
	 * - "Delve level: X": New delve starting, timer resets
	 */
	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		// Guard: Only process when logged in
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		// Check GAMEMESSAGE for wave/reward announcements and death charge,
		// and SPAM for surge potion messages
		ChatMessageType type = event.getType();
		if (type != ChatMessageType.GAMEMESSAGE && type != ChatMessageType.SPAM)
		{
			return;
		}

		String message = event.getMessage();
		if (message == null)
		{
			return;
		}

		// Strip color tags from the message (e.g., "<col=ff3045>Wave: 1</col>" -> "Wave: 1")
		String strippedMessage = Text.removeTags(message);

		// Colo Checks

		// Check if wave was completed - this is when spec regen stops
		if (WAVE_COMPLETED_PATTERN.matcher(strippedMessage).matches())
		{
			insideColosseum = true; // Ensure we track that we're in Colosseum
			betweenWaves = true;
			updateSurgePauseState();
			return;
		}

		// Check if this is a wave start message - resume timer and reset to full cycle
		if (WAVE_START_PATTERN.matcher(strippedMessage).matches())
		{
			betweenWaves = false;
			ticksUntilRegen = getMaxRegenTicks();
			updateSurgePauseState();
			return;
		}

		// Check if the run is over (player claimed rewards) - timer continues
		if (strippedMessage.contains(CLAIM_REWARDS_MESSAGE))
		{
			betweenWaves = false;
			updateSurgePauseState();
			return;
		}

		// Doom Checks

		// Log any Delve-related messages for debugging
		if (strippedMessage.contains("Delve") || strippedMessage.contains("delve"))
		{
			log.debug("Doom-related message received: '{}'", strippedMessage);
		}

		// Check if delve was completed - this is when spec regen stops
		// Timer resumes when the boss NPC spawns (handled in onNpcSpawned)
		// Matches any message starting with "Delve level:" and containing "duration:"
		// This handles both regular delves and deep delves (8+) regardless of format
		if (strippedMessage.startsWith(DELVE_COMPLETED_PREFIX) && strippedMessage.contains(DELVE_DURATION_MARKER))
		{
			insideDoom = true; // Ensure we track that we're in Doom
			betweenWaves = true;
			log.debug("Doom delve completed - PAUSING timers. Message: '{}', Surge remaining before pause: {}",
				strippedMessage, getSurgeCooldownRemaining());
			updateSurgePauseState();
			return;
		}

		// TOB Checks
		// Check if TOB room was completed - this is when surge cooldown pauses
		// Timer resumes when entering the next room's combat area
		Matcher tobMatcher = TOB_ROOM_COMPLETED_PATTERN.matcher(strippedMessage);
		if (tobMatcher.matches())
		{
			insideTob = true; // Ensure we track that we're in TOB
			tobBetweenRooms = true;
			// Advance to the next expected room based on which room was completed
			String roomName = tobMatcher.group(1);
			advanceToNextTobRoom(roomName);
			updateSurgePauseState();
			return;
		}

		// Check if TOB run was completed (after Verzik) - surge cooldown resumes
		if (TOB_COMPLETION_PATTERN.matcher(strippedMessage).matches())
		{
			tobBetweenRooms = false;
			updateSurgePauseState();
			return;
		}

		// Spec restore checks (surge potion, death charge)

		// Detect spec restores to ignore the spec increase and not reset the timer.
		// Use a 2-tick grace period to handle event ordering (onGameTick may fire before onChatMessage).
		if (strippedMessage.equals(SURGE_POTION_MESSAGE))
		{
			ignoreSpecIncreaseUntilTick = client.getTickCount() + 2;
			expectedSpecRestoreAmount = SURGE_POTION_RESTORE;
			// Start surge cooldown timer (5 minutes) using wall-clock time
			startSurgeCooldown();
			return;
		}

		if (strippedMessage.contains(DEATH_CHARGE_MESSAGE))
		{
			ignoreSpecIncreaseUntilTick = client.getTickCount() + 2;
			expectedSpecRestoreAmount = DEATH_CHARGE_RESTORE;
			return;
		}

		// Detect surge cooldown expiry to clear the timer
		if (strippedMessage.equals(SURGE_COOLDOWN_EXPIRED_MESSAGE))
		{
			clearSurgeCooldown();
			removeSurgeInfoBox();
			return;
		}
	}

	/**
	 * Main timer logic executed every game tick.
	 * Handles spec regen countdown and detects actual spec changes.
	 */
	@Subscribe
	public void onGameTick(GameTick event)
	{
		// Guard: Only process when logged in
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		int currentSpec = getSpecEnergy();

		// Detect if spec has regenerated - reset timer to prevent drift
		// But ignore if spec was restored by an effect (surge potion, death charge, etc.)
		if (lastSpecEnergy != -1 && currentSpec > lastSpecEnergy)
		{
			int currentTick = client.getTickCount();
			int actualIncrease = currentSpec - lastSpecEnergy;
			int maxPossibleIncrease = MAX_SPEC_ENERGY - lastSpecEnergy;
			boolean inGracePeriod = currentTick <= ignoreSpecIncreaseUntilTick;

			// Check if natural regen also occurred alongside the effect
			// Natural regen would cause the increase to exceed the expected effect amount
			// (unless capped at max spec)
			boolean naturalRegenAlsoOccurred = inGracePeriod
				&& actualIncrease > expectedSpecRestoreAmount
				&& actualIncrease <= maxPossibleIncrease;

			if (inGracePeriod && !naturalRegenAlsoOccurred)
			{
				// Spec increased only from an effect, not natural regen - don't reset timer
			}
			else
			{
				// Natural spec regen occurred - reset timer
				ticksUntilRegen = getMaxRegenTicks();

				// Self-correction: if we were paused but spec is regenerating,
				// the player must have left the wave-based content (teleported out, etc.)
				// Unpause both the spec timer and surge timer.
				if (betweenWaves)
				{
					betweenWaves = false;
					updateSurgePauseState();
				}
			}
		}

		lastSpecEnergy = currentSpec;

		// Spec regen timer countdown
		// Don't count down if spec is full or if between waves (stopped)
		if (currentSpec >= MAX_SPEC_ENERGY)
		{
			ticksUntilRegen = getMaxRegenTicks();
		}
		else if (betweenWaves)
		{
			// Spec timer is stopped between waves - do not decrement
		}
		else
		{
			// Count down the spec regen timer
			ticksUntilRegen--;
			if (ticksUntilRegen <= 0)
			{
				// Timer expired, expect regen next tick - reset for next cycle
				ticksUntilRegen = getMaxRegenTicks();
			}
		}

		// Region-based detection for Colosseum, Doom of Mokhaiotl, and TOB
		int currentRegion = getTemplateRegionId();
		if (currentRegion != -1 && currentRegion != lastRegionId)
		{
			// Reset combat area flag when entering a new region
			combatAreaEnteredThisRoom = false;

			// Doom of Mokhaiotl: detect leaving the area to unpause timers
			boolean nowInDoom = DOOM_REGION_IDS.contains(currentRegion);
			if (insideDoom && !nowInDoom && betweenWaves)
			{
				// Left Doom while paused - unpause both spec and surge timers
				betweenWaves = false;
				updateSurgePauseState();
			}
			insideDoom = nowInDoom;

			// Fortis Colosseum: detect leaving the area to unpause timers
			boolean nowInColosseum = currentRegion == COLOSSEUM_REGION_ID;
			if (insideColosseum && !nowInColosseum && betweenWaves)
			{
				// Left Colosseum while paused - unpause both spec and surge timers
				betweenWaves = false;
				updateSurgePauseState();
			}
			insideColosseum = nowInColosseum;

			// Clear surge timer and reset TOB state when entering reward room
			if (currentRegion == TOB_REWARD_REGION)
			{
				clearSurgeCooldown();
				tobBetweenRooms = false;
				nextExpectedTobRoom = TobRoom.MAIDEN; // Reset for next raid
			}
			// Maiden uses pure region-based detection
			// Only trigger if Maiden is the next expected room
			else if (tobBetweenRooms
				&& nextExpectedTobRoom == TobRoom.MAIDEN
				&& currentRegion == TobRoom.MAIDEN.getRegionId())
			{
				tobBetweenRooms = false;
				combatAreaEnteredThisRoom = true;
				updateSurgePauseState();
			}
			lastRegionId = currentRegion;
		}

		// Doom exit tile detection - when leaving Doom normally (not teleporting),
		// the player arrives at this specific tile in the hallway
		if (betweenWaves && client.getLocalPlayer() != null)
		{
			WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();
			if (playerLocation.getX() == DOOM_EXIT_TILE_X && playerLocation.getY() == DOOM_EXIT_TILE_Y)
			{
				betweenWaves = false;
				insideDoom = false;
				updateSurgePauseState();
			}
		}

		// Coordinate-based detection for TOB rooms (Bloat, Nylocas, Sotetseg, Xarpus)
		// Only check for the next expected room to prevent re-triggering on previous room tiles
		if (tobBetweenRooms && !combatAreaEnteredThisRoom)
		{
			WorldPoint templatePoint = getTemplateWorldPoint();
			if (templatePoint != null)
			{
				int x = templatePoint.getX();
				int y = templatePoint.getY();
				boolean enteredCombatArea = false;

				// Only check for entry to the next expected room
				// Bloat: barrier at X=3303, Y=4446-4449
				if (nextExpectedTobRoom == TobRoom.BLOAT && currentRegion == TOB_BLOAT_REGION)
				{
					enteredCombatArea = x <= BLOAT_BARRIER_X
						&& y >= BLOAT_BARRIER_MIN_Y
						&& y <= BLOAT_BARRIER_MAX_Y;
				}
				// Nylocas: barrier at X=3295-3296, Y=4254
				else if (nextExpectedTobRoom == TobRoom.NYLOCAS && currentRegion == TOB_NYLOCAS_REGION)
				{
					enteredCombatArea = x >= NYLOCAS_BARRIER_MIN_X
						&& x <= NYLOCAS_BARRIER_MAX_X
						&& y == NYLOCAS_BARRIER_Y;
				}
				// Sotetseg: barrier at X=3278-3281, Y=4308
				else if (nextExpectedTobRoom == TobRoom.SOTETSEG && currentRegion == TOB_SOTETSEG_REGION)
				{
					enteredCombatArea = x >= SOTETSEG_BARRIER_MIN_X
						&& x <= SOTETSEG_BARRIER_MAX_X
						&& y == SOTETSEG_BARRIER_Y;
				}
				// Xarpus: barrier at X=3169-3171, Y=4380
				else if (nextExpectedTobRoom == TobRoom.XARPUS && currentRegion == TOB_XARPUS_REGION)
				{
					enteredCombatArea = x >= XARPUS_BARRIER_MIN_X
						&& x <= XARPUS_BARRIER_MAX_X
						&& y == XARPUS_BARRIER_Y;
				}

				if (enteredCombatArea)
				{
					tobBetweenRooms = false;
					combatAreaEnteredThisRoom = true;
					updateSurgePauseState();
				}
			}
		}
	}

	/**
	 * Gets the current special attack energy from the client.
	 *
	 * @return Special attack energy (0-1000, where 1000 = 100%)
	 */
	public int getSpecEnergy()
	{
		return client.getVarpValue(VarPlayer.SPECIAL_ATTACK_PERCENT);
	}

	/**
	 * Checks if special attack is at maximum.
	 *
	 * @return true if spec is 100%
	 */
	public boolean isSpecFull()
	{
		return getSpecEnergy() >= MAX_SPEC_ENERGY;
	}

	/**
	 * Gets the current max ticks for spec regen based on Lightbearer status.
	 *
	 * @return 25 if wearing Lightbearer, 50 otherwise
	 */
	public int getMaxRegenTicks()
	{
		return wearingLightbearer ? LIGHTBEARER_REGEN_TICKS : SPEC_REGEN_TICKS;
	}

	/**
	 * Gets the template region ID for the player's current location.
	 * For instanced content like TOB, this converts the instanced coordinates
	 * to the template region ID using WorldPoint.fromLocalInstance().
	 *
	 * @return Template region ID, or -1 if player is null
	 */
	private int getTemplateRegionId()
	{
		WorldPoint templatePoint = getTemplateWorldPoint();
		return templatePoint != null ? templatePoint.getRegionID() : -1;
	}

	/**
	 * Gets the template WorldPoint for the player's current location.
	 * For instanced content like TOB, this converts the instanced coordinates
	 * to template coordinates using WorldPoint.fromLocalInstance().
	 *
	 * @return Template WorldPoint, or null if player is null
	 */
	private WorldPoint getTemplateWorldPoint()
	{
		if (client.getLocalPlayer() == null)
		{
			return null;
		}

		WorldPoint worldPoint = client.getLocalPlayer().getWorldLocation();
		if (client.isInInstancedRegion())
		{
			// For instanced content, convert to template coordinates
			LocalPoint localPoint = LocalPoint.fromWorld(client, worldPoint);
			if (localPoint != null)
			{
				WorldPoint templatePoint = WorldPoint.fromLocalInstance(client, localPoint);
				if (templatePoint != null)
				{
					return templatePoint;
				}
			}
		}

		// Non-instanced or fallback to direct world point
		return worldPoint;
	}

	/**
	 * Advances nextExpectedTobRoom to the room after the one that was just completed.
	 * This ensures we only check for entry to the correct next room.
	 * @param roomName The name of the room that was completed (from chat message)
	 */
	private void advanceToNextTobRoom(String roomName)
	{
		if (roomName == null)
		{
			return;
		}

		// Map room names from chat messages to TobRoom enum
		String normalizedName = roomName.toLowerCase();
		TobRoom completedRoom = null;

		if (normalizedName.contains("maiden"))
		{
			completedRoom = TobRoom.MAIDEN;
		}
		else if (normalizedName.contains("bloat"))
		{
			completedRoom = TobRoom.BLOAT;
		}
		else if (normalizedName.contains("nylocas"))
		{
			completedRoom = TobRoom.NYLOCAS;
		}
		else if (normalizedName.contains("sotetseg"))
		{
			completedRoom = TobRoom.SOTETSEG;
		}
		else if (normalizedName.contains("xarpus"))
		{
			completedRoom = TobRoom.XARPUS;
		}
		else if (normalizedName.contains("verzik"))
		{
			completedRoom = TobRoom.VERZIK;
		}

		if (completedRoom != null)
		{
			nextExpectedTobRoom = completedRoom.next();
			log.debug("TOB room {} completed, next expected: {}", completedRoom, nextExpectedTobRoom);
		}
	}
	/**
	 * Gets the remaining surge potion cooldown duration.
	 * Uses wall-clock time for accurate display.
	 * @return Remaining duration, or Duration.ZERO if no cooldown is active
	 */
	public Duration getSurgeCooldownRemaining()
	{
		if (surgePausedRemaining != null)
		{
			return surgePausedRemaining;
		}
		if (surgeEndTime != null)
		{
			Duration remaining = Duration.between(Instant.now(), surgeEndTime);
			if (remaining.isNegative())
			{
				return Duration.ZERO;
			}
			return remaining;
		}
		return Duration.ZERO;
	}

	/**
	 * Checks if the surge cooldown timer is currently paused.
	 *
	 * @return true if paused (between waves/rooms), false otherwise
	 */
	public boolean isSurgeCooldownPaused()
	{
		return surgePausedRemaining != null;
	}

	/**
	 * Updates the surge cooldown pause state based on current wave/room status.
	 * Should be called whenever betweenWaves or tobBetweenRooms changes.
	 */
	private void updateSurgePauseState()
	{
		boolean shouldBePaused = betweenWaves || tobBetweenRooms;
		boolean isCurrentlyPaused = surgePausedRemaining != null;

		if (shouldBePaused && !isCurrentlyPaused && surgeEndTime != null)
		{
			// Transition to paused: save remaining duration
			surgePausedRemaining = Duration.between(Instant.now(), surgeEndTime);
			if (surgePausedRemaining.isNegative())
			{
				surgePausedRemaining = Duration.ZERO;
			}
			surgeEndTime = null;
			log.debug("Surge timer PAUSED with {} remaining (betweenWaves={}, tobBetweenRooms={})",
				surgePausedRemaining, betweenWaves, tobBetweenRooms);
		}
		else if (!shouldBePaused && isCurrentlyPaused)
		{
			// Transition to resumed: sync with game varbit (source of truth)
			// The game's varbit accurately reflects the paused duration, which may differ
			// slightly from what we saved due to timing differences in pause detection
			int varbitValue = client.getVarbitValue(VarbitID.SURGE_POTION_TIMER);
			if (varbitValue > 0)
			{
				int remainingTicks = varbitValue * 10;
				Duration varbitDuration = Duration.ofMillis(remainingTicks * 600L);
				log.debug("Surge timer RESUMED - syncing with varbit: value={}, {} ticks = {}, was paused at {}",
					varbitValue, remainingTicks, varbitDuration, surgePausedRemaining);
				surgeEndTime = Instant.now().plus(varbitDuration);
				// Set flag to accept the next varbit update, as the game may send a
				// corrected value shortly after the wave/room starts
				surgeNeedsVarbitSync = true;
			}
			else
			{
				// Varbit is 0 (cooldown expired during pause), clear the timer
				log.debug("Surge timer RESUMED but varbit is 0 (expired during pause), clearing timer");
				clearSurgeCooldown();
				removeSurgeInfoBox();
			}
			surgePausedRemaining = null;
		}
	}

	/**
	 * Starts the surge potion cooldown timer.
	 * Handles starting in either paused or active state.
	 * Also syncs the varbit tracking to detect game-side clears.
	 */
	private void startSurgeCooldown()
	{
		// Sync varbit tracking so we can detect when the game clears the cooldown
		lastSurgeVarbitValue = client.getVarbitValue(VarbitID.SURGE_POTION_TIMER);

		if (betweenWaves || tobBetweenRooms)
		{
			// Start in paused state
			surgePausedRemaining = SURGE_COOLDOWN_DURATION;
			surgeEndTime = null;
		}
		else
		{
			// Start in active state
			surgeEndTime = Instant.now().plus(SURGE_COOLDOWN_DURATION);
			surgePausedRemaining = null;
		}
	}

	/**
	 * Clears the surge potion cooldown timer.
	 * Called when the cooldown expires (game message), game clears it (death), or when resetting state.
	 */
	private void clearSurgeCooldown()
	{
		surgeEndTime = null;
		surgePausedRemaining = null;
		lastSurgeVarbitValue = 0;
		surgeNeedsVarbitSync = false;
	}
}

package com.specialattacktimers;

import java.awt.Color;
import java.time.Duration;
import net.runelite.client.ui.overlay.infobox.InfoBox;

/**
 * InfoBox that displays the surge potion cooldown timer.
 * Shows "Surge Cooldown" on hover.
 */
public class SurgePotionInfoBox extends InfoBox
{
	private final SpecialAttackTimersPlugin plugin;
	private final SpecialAttackTimersConfig config;

	public SurgePotionInfoBox(SpecialAttackTimersPlugin plugin, SpecialAttackTimersConfig config)
	{
		super(null, plugin);
		this.plugin = plugin;
		this.config = config;
	}

	@Override
	public String getText()
	{
		Duration remaining = plugin.getSurgeCooldownRemaining();
		long totalMillis = remaining.toMillis();

		switch (config.surgeDisplayFormat())
		{
			case SECONDS:
				// Minutes:seconds format (e.g. 4:30) using integer division like RuneLite
				int totalSeconds = (int) (totalMillis / 1000);
				int minutes = totalSeconds / 60;
				int seconds = totalSeconds % 60;
				return String.format("%d:%02d", minutes, seconds);
			case DECIMALS:
				// Minutes:seconds with decimal (e.g. 4:29.4)
				double totalSecondsDecimal = totalMillis / 1000.0;
				int mins = (int) (totalSecondsDecimal / 60);
				double secs = totalSecondsDecimal % 60;
				return String.format("%d:%04.1f", mins, secs);
			case TICKS:
			default:
				// Convert milliseconds back to ticks for display
				return String.valueOf((int) (totalMillis / 600));
		}
	}

	@Override
	public Color getTextColor()
	{
		if (plugin.isSurgeCooldownPaused())
		{
			return config.surgePausedColor();
		}
		return config.surgeColor();
	}

	@Override
	public boolean render()
	{
		// Only render if surge cooldown is active
		Duration remaining = plugin.getSurgeCooldownRemaining();
		return !remaining.isZero() && !remaining.isNegative();
	}

	@Override
	public String getTooltip()
	{
		return "Surge Cooldown";
	}
}

package com.specialattacktimers;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class SpecialAttackTimersPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(SpecialAttackTimersPlugin.class);
		RuneLite.main(args);
	}
}

