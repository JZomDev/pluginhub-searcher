package com.distractionreducer;

import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

import java.awt.Color;

@ConfigGroup("distractionreducer")
public interface DistractionReducerConfig extends Config {
    @ConfigSection(
            name = "Skilling Toggles",
            description = "Toggle overlay for different skilling activities",
            position = 0
    )
    String skillingToggles = "skillingToggles";

    @ConfigSection(
            name = "Combat",
            description = "Configure combat-based overlay activation",
            position = 1
    )
    String combatIntegration = "combatIntegration";

    @ConfigSection(
            name = "Color Picker",
            description = "Customize the overlay color",
            position = 2
    )
    String colorPicker = "colorPicker";

    @ConfigSection(
            name = "Timing",
            description = "Configure timing-related settings",
            position = 3
    )
    String timing = "timing";

    // Existing skilling toggles
    @ConfigItem(
            keyName = "woodcutting",
            name = "Woodcutting",
            description = "Display overlay while woodcutting",
            section = skillingToggles
    )
    default boolean woodcutting() {
        return true;
    }

    @ConfigItem(
            keyName = "fishing",
            name = "Fishing",
            description = "Display overlay while fishing",
            section = skillingToggles
    )
    default boolean fishing() {
        return true;
    }

    @ConfigItem(
            keyName = "mining",
            name = "Mining",
            description = "Display overlay while mining",
            section = skillingToggles
    )
    default boolean mining() {
        return true;
    }

    @ConfigItem(
            keyName = "cooking",
            name = "Cooking",
            description = "Display overlay while cooking",
            section = skillingToggles
    )
    default boolean cooking() {
        return true;
    }

    @ConfigItem(
            keyName = "herblore",
            name = "Herblore",
            description = "Display overlay while doing herblore",
            section = skillingToggles
    )
    default boolean herblore() {
        return true;
    }

    @ConfigItem(
            keyName = "crafting",
            name = "Crafting",
            description = "Display overlay while crafting",
            section = skillingToggles
    )
    default boolean crafting() {
        return true;
    }

    @ConfigItem(
            keyName = "fletching",
            name = "Fletching",
            description = "Display overlay while fletching",
            section = skillingToggles
    )
    default boolean fletching() {
        return true;
    }

    @ConfigItem(
            keyName = "smithing",
            name = "Smithing",
            description = "Display overlay while smithing",
            section = skillingToggles
    )
    default boolean smithing() {
        return true;
    }

    @ConfigItem(
            keyName = "magic",
            name = "Magic",
            description = "Display overlay while performing magic activities",
            section = skillingToggles
    )
    default boolean magic() {
        return true;
    }

    @ConfigItem(
            keyName = "firemaking",
            name = "Firemaking",
            description = "Display overlay while adding logs to fires",
            section = skillingToggles
    )
    default boolean firemaking() {
        return true;
    }

    @Alpha
    @ConfigItem(
            keyName = "overlayColor",
            name = "Overlay Color",
            description = "Configures the color of the overlay, including opacity",
            section = colorPicker
    )
    default Color overlayColor() {
        return new Color(0, 0, 0, 180);
    }

    @ConfigItem(
            keyName = "restoreDelay",
            name = "Restore Delay",
            description = "Number of ticks to wait before removing the overlay after stopping skilling",
            section = timing
    )
    default int restoreDelay() {
        return 3;
    }

    // Add this new section after the existing sections
    @ConfigSection(
            name = "Overlay Passthrough",
            description = "Configure which UI elements can pass through the overlay",
            position = 4
    )
    String overlaySettings = "overlaySettings";

    @ConfigSection(
            name = "Miscellaneous",
            description = "Toggle overlay for miscellaneous activities",
            position = 5
    )
    String miscellaneous = "miscellaneous";



    // Add this new config item
    @ConfigItem(
            keyName = "bakePie",
            name = "Bake Pie",
            description = "Display overlay while using Bake Pie spell (Warning: Shares animation with NPC Contact)",
            section = miscellaneous
    )
    default boolean bakePie() {
        return false;
    }

    @ConfigItem(
            keyName = "stringJewelry",
            name = "String Jewelry",
            description = "Display overlay while using String Jewelry spell (Warning: Problematic animation ID)",
            section = miscellaneous
    )
    default boolean stringJewelry() {
        return false;
    }

    @ConfigItem(
            keyName = "plankMake",
            name = "Plank Make",
            description = "Display overlay while using Plank Make spell (Warning: Problematic animation ID)",
            section = miscellaneous
    )
    default boolean plankMake() {
        return false;
    }

    @ConfigItem(
            keyName = "showChat",
            name = "Show Chat",
            description = "Show chat window in front of the overlay when active",
            section = overlaySettings
    )
    default boolean showChat() {
        return false;
    }

    @ConfigItem(
            keyName = "showInventory",
            name = "Show Inventory",
            description = "Show inventory in front of the overlay when active",
            section = overlaySettings
    )
    default boolean showInventory() {
        return false;
    }

    // Combat Settings
    @ConfigItem(
            keyName = "enableCombatBlackout",
            name = "Enable Combat Blackout",
            description = "Enable overlay blackout when fighting specific monsters",
            section = combatIntegration,
            position = 1
    )
    default boolean enableCombatBlackout() {
        return true;
    }

    @ConfigItem(
            keyName = "monsterNames",
            name = "Monster Names",
            description = "Comma-separated list of monster names to trigger blackout (e.g., Zulrah, Vorkath)",
            section = combatIntegration,
            position = 2
    )
    default String monsterNames() {
        return "Gemstone Crab";
    }

    @ConfigItem(
            keyName = "monsterIds",
            name = "Monster IDs",
            description = "Comma-separated list of monster IDs to trigger blackout. Use the Identificator plugin to find NPC IDs (e.g., 2042,2043,2044)",
            section = combatIntegration,
            position = 3
    )
    default String monsterIds() {
        return "";
    }

    @ConfigItem(
            keyName = "combatRestoreDelay",
            name = "Combat Restore Delay",
            description = "Duration in ticks to maintain blackout after combat ends",
            section = combatIntegration,
            position = 4
    )
    default int combatRestoreDelay() {
        return 8;
    }

    @ConfigItem(
            keyName = "enableHealthOverride",
            name = "Enable Health Override",
            description = "Disable blackout when health is below threshold",
            section = combatIntegration,
            position = 50
    )
    default boolean enableHealthOverride() {
        return true;
    }

    @ConfigItem(
            keyName = "healthThreshold",
            name = "Health Threshold",
            description = "Health points below which blackout is disabled",
            section = combatIntegration,
            position = 51
    )
    default int healthThreshold() {
        return 30;
    }

    @ConfigItem(
            keyName = "enablePrayerOverride",
            name = "Enable Prayer Override",
            description = "Disable blackout when prayer is below threshold",
            section = combatIntegration,
            position = 52
    )
    default boolean enablePrayerOverride() {
        return true;
    }

    @ConfigItem(
            keyName = "prayerThreshold",
            name = "Prayer Threshold",
            description = "Prayer points below which blackout is disabled",
            section = combatIntegration,
            position = 53
    )
    default int prayerThreshold() {
        return 20;
    }

    @ConfigItem(
            keyName = "enableWildernessOverride",
            name = "Enable in Wilderness",
            description = "Allow combat blackout to work in the Wilderness",
            section = combatIntegration,
            position = 54
    )
    default boolean enableWildernessOverride() {
        return false;
    }

}

package com.distractionreducer;

import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;

import javax.inject.Inject;
import java.awt.*;

import lombok.extern.slf4j.Slf4j;

@Slf4j
class DistractionReducerOverlay extends Overlay {
    private final DistractionReducerConfig config;
    private final Client client;
    private boolean renderOverlay = false;

    @Inject
    private DistractionReducerOverlay(DistractionReducerConfig config, Client client) {
        this.config = config;
        this.client = client;
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(OverlayPriority.HIGH);
        setLayer(OverlayLayer.ALWAYS_ON_TOP); // Static layer - never changes
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!renderOverlay) {
            return null;
        }

        Color color = config.overlayColor();
        graphics.setColor(color);
        
        // Check if any widgets should be visible through the overlay
        boolean anyWidgetVisible = config.showChat() || config.showInventory();
        
        if (anyWidgetVisible) {
            // Mask out areas for visible widgets
            java.util.List<Rectangle> exclusionAreas = new java.util.ArrayList<>();
            
            if (config.showChat()) {
                Rectangle chatArea = getChatArea();
                if (chatArea != null) {
                    exclusionAreas.add(chatArea);
                }
            }
            
            if (config.showInventory()) {
                Rectangle invArea = getInventoryArea();
                if (invArea != null) {
                    exclusionAreas.add(invArea);
                }
            }
            
            fillScreenExcludingAreas(graphics, exclusionAreas);
        } else {
            // No widgets should be visible, fill entire screen
            graphics.fillRect(0, 0, client.getCanvasWidth(), client.getCanvasHeight());
        }

        return new Dimension(client.getCanvasWidth(), client.getCanvasHeight());
    }

    public void setRenderOverlay(boolean render) {
        this.renderOverlay = render;
        log.debug("Overlay rendering set to: {}", render);
    }

    private Rectangle getChatArea() {
        java.util.List<Rectangle> chatAreas = new java.util.ArrayList<>();
        
        // Get main chatbox parent
        Widget chatboxParent = client.getWidget(InterfaceID.Chatbox.UNIVERSE);
        if (chatboxParent != null && !chatboxParent.isHidden()) {
            chatAreas.add(chatboxParent.getBounds());
        }
        
        // Get chatbox messages (the actual text area)
        Widget chatboxMessages = client.getWidget(InterfaceID.Chatbox.MES_TEXT);
        if (chatboxMessages != null && !chatboxMessages.isHidden()) {
            chatAreas.add(chatboxMessages.getBounds());
        }
        
        // Get chatbox input field
        Widget chatboxInput = client.getWidget(InterfaceID.Chatbox.MES_TEXT2);
        if (chatboxInput != null && !chatboxInput.isHidden()) {
            chatAreas.add(chatboxInput.getBounds());
        }
        
        // Get chat channel buttons (All, Game, Public, Private, etc.)
        Widget chatboxButtons = client.getWidget(InterfaceID.Chatbox.SCROLLAREA);
        if (chatboxButtons != null && !chatboxButtons.isHidden()) {
            chatAreas.add(chatboxButtons.getBounds());
        }
        
        // Note: Some chat widgets like tabs might not be directly accessible via InterfaceID
        // We'll rely on the main components with exact bounds (no padding)
        
        if (chatAreas.isEmpty()) {
            return null;
        }
        
        // Combine all chat areas into one bounding rectangle
        Rectangle combinedBounds = new Rectangle(chatAreas.get(0));
        for (int i = 1; i < chatAreas.size(); i++) {
            combinedBounds = combinedBounds.union(chatAreas.get(i));
        }
        
        log.debug("Combined chat area from {} components: {}", chatAreas.size(), combinedBounds);
        return combinedBounds;
    }
    
    private Rectangle getInventoryArea() {
        java.util.List<Rectangle> inventoryAreas = new java.util.ArrayList<>();
        
        // Get inventory widget
        Widget inventory = client.getWidget(InterfaceID.Inventory.ITEMS);
        if (inventory != null && !inventory.isHidden()) {
            inventoryAreas.add(inventory.getBounds());
        }
        
        // Get stats (skills) widget - included with inventory setting
        Widget stats = client.getWidget(InterfaceID.Stats.UNIVERSE);
        if (stats != null && !stats.isHidden()) {
            inventoryAreas.add(stats.getBounds());
        }
        
        if (inventoryAreas.isEmpty()) {
            return null;
        }
        
        // If only one area, return it directly
        if (inventoryAreas.size() == 1) {
            Rectangle bounds = inventoryAreas.get(0);
            log.debug("Single inventory/stats area: {}", bounds);
            return bounds;
        }
        
        // Combine inventory and stats areas into one bounding rectangle
        Rectangle combinedBounds = new Rectangle(inventoryAreas.get(0));
        for (int i = 1; i < inventoryAreas.size(); i++) {
            combinedBounds = combinedBounds.union(inventoryAreas.get(i));
        }
        
        log.debug("Combined inventory/stats area from {} components: {}", inventoryAreas.size(), combinedBounds);
        return combinedBounds;
    }
    

    
    private void fillScreenExcludingAreas(Graphics2D graphics, java.util.List<Rectangle> exclusionAreas) {
        int canvasWidth = client.getCanvasWidth();
        int canvasHeight = client.getCanvasHeight();
        
        if (exclusionAreas.isEmpty()) {
            // No exclusions, fill entire screen
            graphics.fillRect(0, 0, canvasWidth, canvasHeight);
            return;
        }
        
        // Create a complex shape that covers the screen but excludes widget areas
        java.awt.geom.Area screenArea = new java.awt.geom.Area(new Rectangle(0, 0, canvasWidth, canvasHeight));
        
        for (Rectangle exclusion : exclusionAreas) {
            // Make sure exclusion area is within screen bounds
            Rectangle clampedExclusion = exclusion.intersection(new Rectangle(0, 0, canvasWidth, canvasHeight));
            if (!clampedExclusion.isEmpty()) {
                screenArea.subtract(new java.awt.geom.Area(clampedExclusion));
            }
        }
        
        graphics.fill(screenArea);
    }
}
package com.distractionreducer;

import com.google.inject.Provides;
import javax.inject.Inject;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;  // Add this import
import net.runelite.api.coords.WorldArea;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.events.ConfigChanged;
import java.util.Set;
import java.util.HashSet;
import net.runelite.client.callback.ClientThread;
import lombok.extern.slf4j.Slf4j;

@PluginDescriptor(
        name = "Distraction Reducer",
        description = "Blacks out the screen while skilling to reduce distractions",
        tags = {"woodcutting", "fishing", "mining", "cooking", "herblore", "crafting", "fletching", "smithing", "magic", "skilling", "overlay"}
)
@Slf4j
public class DistractionReducerPlugin extends Plugin {
    @Inject
    private Client client;

    @Inject
    private ClientThread clientThread;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private DistractionReducerConfig config;

    @Inject
    private DistractionReducerOverlay distractionReducerOverlay;

    private int restoreDelayTicks = 0;
    private boolean wasSkilling = false;

    // Combat integration fields
    private int combatRestoreDelayTicks = 0;
    private boolean wasCombating = false;
    private Set<Integer> targetMonsterIds = new HashSet<>();
    private Set<String> targetMonsterNames = new HashSet<>();

    private static final int WALKING_POSE = 1205;
    private static final int RUNNING_POSE = 1210;
    private static final Set<Integer> TURNING_POSES = Set.of(1206, 1208);

    // TOA Region IDs
    private static final int TOA_LOBBY = 14160;
    private static final Set<Integer> TOA_REGIONS = Set.of(
            14162, // Croc
            14164, // Scarab
            14166, // Het
            14168, // Baba
            14170, // Zebak
            14172, // Kephri
            14160, // Lobby
            14674  // Wardens
    );

    // Duke Sucellus Region ID
    private static final int DUKE_SUCELLUS_REGION = 12132;

    // Updated Magic Animation IDs
    private static final Set<Integer> PLANK_MAKE_ANIMATION_IDS = Set.of(6298);
    private static final Set<Integer> ENCHANT_JEWELRY_ANIMATION_IDS = Set.of(
            619,  // Sapphire
            721,  // Emerald
            724,  // Ruby
            727,  // Diamond
            730,  // Dragonstone

            // Bulk enchantment animations
            719,  // Sapphire bulk
            722,  // Emerald bulk
            725,  // Ruby bulk
            728,  // Diamond bulk
            731,  // Dragonstone bulk

            // Special item-specific animations
            720,  // Games necklace (Sapphire)
            723,  // Ring of dueling (Emerald)
            726,  // Binding necklace (Ruby)
            729,  // Ring of life (Diamond)
            732,  // Combat bracelet (Dragonstone)

            // Modern universal animations
            7531, // Modern universal
            931   // Modern alternative
    );
    private static final Set<Integer> CHARGE_ORB_ANIMATION_IDS = Set.of(726);
    private static final Set<Integer> BAKE_PIE_ANIMATION_IDS = Set.of(4413);
    private static final Set<Integer> STRING_JEWELRY_ANIMATION_IDS = Set.of(4412);

    private static final Set<Integer> WOODCUTTING_ANIMATION_IDS = Set.of(
            AnimationID.WOODCUTTING_BRONZE, AnimationID.WOODCUTTING_IRON, AnimationID.WOODCUTTING_STEEL,
            AnimationID.WOODCUTTING_BLACK, AnimationID.WOODCUTTING_MITHRIL, AnimationID.WOODCUTTING_ADAMANT,
            AnimationID.WOODCUTTING_RUNE, AnimationID.WOODCUTTING_DRAGON, AnimationID.WOODCUTTING_INFERNAL,
            AnimationID.WOODCUTTING_3A_AXE, AnimationID.WOODCUTTING_CRYSTAL, AnimationID.WOODCUTTING_TRAILBLAZER,
            AnimationID.WOODCUTTING_2H_BRONZE, AnimationID.WOODCUTTING_2H_IRON, AnimationID.WOODCUTTING_2H_STEEL,
            AnimationID.WOODCUTTING_2H_BLACK, AnimationID.WOODCUTTING_2H_MITHRIL, AnimationID.WOODCUTTING_2H_ADAMANT,
            AnimationID.WOODCUTTING_2H_RUNE, AnimationID.WOODCUTTING_2H_DRAGON, AnimationID.WOODCUTTING_2H_CRYSTAL,
            AnimationID.WOODCUTTING_2H_CRYSTAL_INACTIVE, AnimationID.WOODCUTTING_2H_3A
    );

    private static final Set<Integer> SMITHING_ANIMATION_IDS = Set.of(
            AnimationID.SMITHING_ANVIL, AnimationID.SMITHING_SMELTING, AnimationID.SMITHING_IMCANDO_HAMMER
    );

    private static final Set<Integer> FISHING_ANIMATION_IDS = Set.of(
            AnimationID.FISHING_BARBARIAN_ROD, AnimationID.FISHING_BARBTAIL_HARPOON, AnimationID.FISHING_BAREHAND,
            AnimationID.FISHING_BIG_NET, AnimationID.FISHING_CAGE, AnimationID.FISHING_CRYSTAL_HARPOON,
            AnimationID.FISHING_DRAGON_HARPOON, AnimationID.FISHING_HARPOON, AnimationID.FISHING_INFERNAL_HARPOON,
            AnimationID.FISHING_KARAMBWAN, AnimationID.FISHING_NET, AnimationID.FISHING_OILY_ROD,
            AnimationID.FISHING_POLE_CAST, AnimationID.FISHING_PEARL_ROD, AnimationID.FISHING_PEARL_FLY_ROD,
            AnimationID.FISHING_PEARL_BARBARIAN_ROD, AnimationID.FISHING_PEARL_ROD_2,
            AnimationID.FISHING_PEARL_FLY_ROD_2, AnimationID.FISHING_PEARL_BARBARIAN_ROD_2,
            AnimationID.FISHING_TRAILBLAZER_HARPOON
    );

    private static final Set<Integer> COOKING_ANIMATION_IDS = Set.of(
            AnimationID.COOKING_FIRE, AnimationID.COOKING_RANGE, AnimationID.COOKING_WINE
    );

    private static final Set<Integer> HERBLORE_ANIMATION_IDS = Set.of(
            AnimationID.HERBLORE_POTIONMAKING, AnimationID.HERBLORE_MAKE_TAR
    );

    private static final Set<Integer> CRAFTING_ANIMATION_IDS = Set.of(
            AnimationID.CRAFTING_LEATHER, AnimationID.CRAFTING_GLASSBLOWING, AnimationID.CRAFTING_SPINNING,
            AnimationID.CRAFTING_POTTERS_WHEEL, AnimationID.CRAFTING_POTTERY_OVEN,
            // Gem cutting animations - verified unique IDs
            892,  // Sapphire
            891,  // Emerald
            890,  // Ruby
            889,  // Diamond
            888,  // Dragonstone
            887,  // Opal
            886,  // Jade
            885,  // Red topaz
            7531, // Battlestaff crafting
            7202  // Zeah: Chiseling dark essence blocks into fragments
    );

    private static final Set<Integer> FLETCHING_ANIMATION_IDS = Set.of(
            AnimationID.FLETCHING_BOW_CUTTING, AnimationID.FLETCHING_STRING_NORMAL_SHORTBOW,
            AnimationID.FLETCHING_STRING_NORMAL_LONGBOW, AnimationID.FLETCHING_STRING_OAK_SHORTBOW,
            AnimationID.FLETCHING_STRING_OAK_LONGBOW, AnimationID.FLETCHING_STRING_WILLOW_SHORTBOW,
            AnimationID.FLETCHING_STRING_WILLOW_LONGBOW, AnimationID.FLETCHING_STRING_MAPLE_SHORTBOW,
            AnimationID.FLETCHING_STRING_MAPLE_LONGBOW, AnimationID.FLETCHING_STRING_YEW_SHORTBOW,
            AnimationID.FLETCHING_STRING_YEW_LONGBOW, AnimationID.FLETCHING_STRING_MAGIC_SHORTBOW,
            AnimationID.FLETCHING_STRING_MAGIC_LONGBOW
    );

    private static final Set<Integer> MINING_ANIMATION_IDS = Set.of(
            AnimationID.MINING_BRONZE_PICKAXE, AnimationID.MINING_IRON_PICKAXE, AnimationID.MINING_STEEL_PICKAXE,
            AnimationID.MINING_BLACK_PICKAXE, AnimationID.MINING_MITHRIL_PICKAXE, AnimationID.MINING_ADAMANT_PICKAXE,
            AnimationID.MINING_RUNE_PICKAXE, AnimationID.MINING_DRAGON_PICKAXE, AnimationID.MINING_DRAGON_PICKAXE_UPGRADED,
            AnimationID.MINING_DRAGON_PICKAXE_OR, AnimationID.MINING_INFERNAL_PICKAXE, AnimationID.MINING_3A_PICKAXE,
            AnimationID.MINING_CRYSTAL_PICKAXE, AnimationID.MINING_TRAILBLAZER_PICKAXE, AnimationID.MINING_GILDED_PICKAXE,
            AnimationID.MINING_MOTHERLODE_BRONZE, AnimationID.MINING_MOTHERLODE_IRON, AnimationID.MINING_MOTHERLODE_STEEL,
            AnimationID.MINING_MOTHERLODE_BLACK, AnimationID.MINING_MOTHERLODE_MITHRIL, AnimationID.MINING_MOTHERLODE_ADAMANT,
            AnimationID.MINING_MOTHERLODE_RUNE, AnimationID.MINING_MOTHERLODE_DRAGON, AnimationID.MINING_MOTHERLODE_DRAGON_UPGRADED,
            AnimationID.MINING_MOTHERLODE_DRAGON_OR, AnimationID.MINING_MOTHERLODE_INFERNAL, AnimationID.MINING_MOTHERLODE_3A,
            AnimationID.MINING_MOTHERLODE_CRYSTAL, AnimationID.MINING_MOTHERLODE_TRAILBLAZER,
            6747, 6748, 6749, 6108, 6751, 6750, 6746, 8314, 7140, 643, 8349, 4483, 7284, 8350,
            7201
    );

    // Update the FIREMAKING_ANIMATION_IDS set with correct bonfire animations
    private static final Set<Integer> FIREMAKING_ANIMATION_IDS = Set.of(
            10565,  // Regular logs
            10569,  // Oak logs
            10572,  // Willow logs
            10568,  // Maple logs
            10573,  // Yew logs
            10566,  // Magic logs
            10570   // Redwood logs
    );

    @Provides
    DistractionReducerConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(DistractionReducerConfig.class);
    }

    @Override
    protected void startUp() {
        overlayManager.add(distractionReducerOverlay);
        clientThread.invoke(this::updateOverlayVisibility);
        updateTargetMonsterIds();
    }

    @Override
    protected void shutDown() {
        overlayManager.remove(distractionReducerOverlay);
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged configChanged) {
        if ("distractionreducer".equals(configChanged.getGroup())) {
            if ("monsterIds".equals(configChanged.getKey()) || 
                "monsterNames".equals(configChanged.getKey()) ||
                "enableCombatBlackout".equals(configChanged.getKey())) {
                updateTargetMonsterIds();
            }
        }
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        if (gameStateChanged.getGameState() == GameState.LOGGED_IN) {
            clientThread.invoke(this::updateOverlayVisibility);
        }
    }

    @Subscribe
    public void onGameTick(GameTick event) {
        Player player = client.getLocalPlayer();
        if (player == null) return;

        boolean currentlySkilling = isSkilling();
        boolean currentlyCombating = isCombatingTargetMonster();
        boolean isMoving = isPlayerMoving(player);

        // Immediately clear overlay if moving
        if (isMoving) {
            wasSkilling = false;
            wasCombating = false;
            restoreDelayTicks = 0;
            combatRestoreDelayTicks = 0;
            distractionReducerOverlay.setRenderOverlay(false);
            return;
        }

        // Handle skilling logic
        if (currentlySkilling) {
            wasSkilling = true;
            restoreDelayTicks = 0;
        } else if (wasSkilling) {
            restoreDelayTicks++;
            if (restoreDelayTicks >= config.restoreDelay()) {
                wasSkilling = false;
                restoreDelayTicks = 0;
            }
        }

        // Handle combat logic
        if (currentlyCombating) {
            wasCombating = true;
            combatRestoreDelayTicks = 0;
        } else if (wasCombating) {
            combatRestoreDelayTicks++;
            if (combatRestoreDelayTicks >= config.combatRestoreDelay()) {
                wasCombating = false;
                combatRestoreDelayTicks = 0;
            }
        }

        updateOverlayVisibility();
    }

    private boolean isPlayerMoving(Player player) {
        int poseAnimation = player.getPoseAnimation();

        // Store the current position
        if (lastPlayerPosition == null) {
            lastPlayerPosition = player.getWorldLocation();
            return false;
        }

        // Check if position changed since last tick
        WorldPoint currentPosition = player.getWorldLocation();
        boolean moved = !currentPosition.equals(lastPlayerPosition);
        lastPlayerPosition = currentPosition;

        return poseAnimation == WALKING_POSE ||
                poseAnimation == RUNNING_POSE ||
                TURNING_POSES.contains(poseAnimation) ||
                moved;
    }

    // Add this field at the class level (with other private fields)
    private WorldPoint lastPlayerPosition = null;

    private void updateOverlayVisibility() {
        Player player = client.getLocalPlayer();
        if (player == null) return;

        boolean isMoving = isPlayerMoving(player);
        boolean shouldRenderFromSkilling = (isSkilling() || wasSkilling) && !isMoving;
        boolean shouldRenderFromCombat = (isCombatingTargetMonster() || wasCombating) && !isMoving && !isHealthOrPrayerOverrideActive() && !isWildernessOverrideActive();
        
        boolean shouldRenderOverlay = shouldRenderFromSkilling || shouldRenderFromCombat;

        distractionReducerOverlay.setRenderOverlay(shouldRenderOverlay);
        log.debug("Overlay visibility updated. Rendering: {}, Skilling: {}, Combat: {}, Is Moving: {}, HP/Prayer Override: {}, Wilderness Override: {}",
                shouldRenderOverlay, shouldRenderFromSkilling, shouldRenderFromCombat, isMoving, isHealthOrPrayerOverrideActive(), isWildernessOverrideActive());
    }

    private boolean isSkilling() {
        Player player = client.getLocalPlayer();
        if (player == null) return false;

        int animation = player.getAnimation();

        // Failsafe for Chambers of Xeric
        if (client.getVarbitValue(Varbits.IN_RAID) > 0) {
            return false;
        }

        // Failsafe for The Gauntlet & The Corrupted Gauntlet
        // Varbit 9178 is for being inside The Gauntlet
        if (client.getVarbitValue(9178) > 0) {
            return false;
        }


        // Failsafe for various regions
        WorldPoint playerLocation = player.getWorldLocation();

        // Check for Duke Sucellus (non-instanced)
        if (playerLocation != null && playerLocation.getRegionID() == DUKE_SUCELLUS_REGION) {
            return false;
        }

        // Check for instanced regions (TOA and Duke Sucellus)
        if (client.isInInstancedRegion()) {
            WorldPoint instancePoint = WorldPoint.fromLocalInstance(client, player.getLocalLocation());
            if (instancePoint != null) {
                int regionID = instancePoint.getRegionID();
                // TOA puzzle rooms
                if (TOA_REGIONS.contains(regionID) && !isInToaBank()) {
                    return false;
                }
                // Duke Sucellus instanced area
                if (regionID == DUKE_SUCELLUS_REGION) {
                    return false;
                }
            }
        }

        return (WOODCUTTING_ANIMATION_IDS.contains(animation) && config.woodcutting()) ||
                (FISHING_ANIMATION_IDS.contains(animation) && config.fishing()) ||
                (MINING_ANIMATION_IDS.contains(animation) && config.mining()) ||
                (COOKING_ANIMATION_IDS.contains(animation) && config.cooking()) ||
                (HERBLORE_ANIMATION_IDS.contains(animation) && config.herblore()) ||
                (CRAFTING_ANIMATION_IDS.contains(animation) && config.crafting()) ||
                (FLETCHING_ANIMATION_IDS.contains(animation) && config.fletching()) ||
                (FIREMAKING_ANIMATION_IDS.contains(animation) && config.firemaking()) ||
                (isSmithing(animation) && config.smithing()) ||
                (isMagic(animation) && config.magic());
    }

    private boolean isInToaBank() {
        return client.getLocalPlayer().getWorldLocation().getRegionID() == TOA_LOBBY &&
                client.getVarbitValue(Varbits.TOA_RAID_LEVEL) > 0; // Check if in an active raid
    }

    private boolean isSmithing(int animation) {
        if (SMITHING_ANIMATION_IDS.contains(animation)) {
            return true;
        }

        if (animation == AnimationID.SMITHING_CANNONBALL) {
            ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);
            if (inventory == null) {
                return false;
            }
            return inventory.contains(ItemID.AMMO_MOULD) || inventory.contains(ItemID.DOUBLE_AMMO_MOULD);
        }

        return false;
    }

    private boolean isMagic(int animation) {
        return PLANK_MAKE_ANIMATION_IDS.contains(animation) ||
                isEnchantingJewelry(animation) ||
                CHARGE_ORB_ANIMATION_IDS.contains(animation) ||
                (BAKE_PIE_ANIMATION_IDS.contains(animation) && config.bakePie()) ||
                (animation == STRING_JEWELRY_ANIMATION_ID && config.stringJewelry()) ||
                (animation == PLANK_MAKE_ANIMATION_ID && config.plankMake());
    }

    private boolean isEnchantingJewelry(int animation) {
        if (!ENCHANT_JEWELRY_ANIMATION_IDS.contains(animation)) {
            return false;
        }

        // Check if the player is using the standard spellbook
        return client.getVarbitValue(Varbits.SPELLBOOK) == 0;
    }

    private boolean isNPCContact() {
        Player player = client.getLocalPlayer();
        if (player == null) return false;

        int animation = player.getAnimation();
        if (animation != NPC_CONTACT_ANIMATION_ID) return false;

        // Check if the player has the Lunar spellbook active
        return client.getVarbitValue(Varbits.SPELLBOOK) == 2;
    }

    private boolean isInWilderness() {
        Player player = client.getLocalPlayer();
        if (player == null) return false;
        
        WorldPoint location = player.getWorldLocation();
        return location.isInArea2D(WILDERNESS_ABOVE_GROUND, WILDERNESS_UNDERGROUND);
    }

    private boolean isWildernessOverrideActive() {
        // If in wilderness and wilderness is NOT enabled, then override (disable) combat blackout
        return isInWilderness() && !config.enableWildernessOverride();
    }

    // Add this constant with the other animation ID constants
    private static final int NPC_CONTACT_ANIMATION_ID = 4413;
    private static final int STRING_JEWELRY_ANIMATION_ID = 4412;
    private static final int PLANK_MAKE_ANIMATION_ID = 6298;

    // Add this constant for the standard spellbook ID
    private static final int STANDARD_SPELLBOOK_ID = 0;

    // Wilderness area constants for robust detection (from NPC Aggro Area plugin)
    private static final WorldArea WILDERNESS_ABOVE_GROUND = new WorldArea(2944, 3523, 448, 448, 0);
    private static final WorldArea WILDERNESS_UNDERGROUND = new WorldArea(2944, 9918, 320, 442, 0);

    private void updateTargetMonsterIds() {
        targetMonsterIds.clear();
        targetMonsterNames.clear();
        
        if (config.enableCombatBlackout()) {
            // Parse monster IDs
            if (!config.monsterIds().trim().isEmpty()) {
                String[] ids = config.monsterIds().split(",");
                for (String id : ids) {
                    try {
                        targetMonsterIds.add(Integer.parseInt(id.trim()));
                    } catch (NumberFormatException e) {
                        log.warn("Invalid monster ID: {}", id.trim());
                    }
                }
            }
            
            // Parse monster names
            if (!config.monsterNames().trim().isEmpty()) {
                String[] names = config.monsterNames().split(",");
                for (String name : names) {
                    targetMonsterNames.add(name.trim().toLowerCase());
                }
            }
        }
        
        log.debug("Updated target monster IDs: {}", targetMonsterIds);
        log.debug("Updated target monster names: {}", targetMonsterNames);
    }

    private boolean isCombatingTargetMonster() {
        if (!config.enableCombatBlackout() || (targetMonsterIds.isEmpty() && targetMonsterNames.isEmpty())) {
            return false;
        }

        Player player = client.getLocalPlayer();
        if (player == null) {
            return false;
        }

        Actor interacting = player.getInteracting();
        if (!(interacting instanceof NPC)) {
            return false;
        }

        NPC npc = (NPC) interacting;
        int npcId = npc.getId();
        String npcName = npc.getName();
        
        // Check by ID
        boolean isTargetById = targetMonsterIds.contains(npcId);
        
        // Check by name
        boolean isTargetByName = false;
        if (npcName != null && !targetMonsterNames.isEmpty()) {
            isTargetByName = targetMonsterNames.contains(npcName.toLowerCase());
        }
        
        boolean isTargetMonster = isTargetById || isTargetByName;
        if (isTargetMonster) {
            if (isTargetById) {
                log.debug("Player is combating target monster with ID: {}", npcId);
            }
            if (isTargetByName) {
                log.debug("Player is combating target monster with name: {}", npcName);
            }
        }
        
        return isTargetMonster;
    }

    private boolean isHealthOrPrayerOverrideActive() {
        if (!config.enableCombatBlackout()) {
            return false;
        }

        // Check health override
        if (config.enableHealthOverride()) {
            int currentHp = client.getBoostedSkillLevel(Skill.HITPOINTS);
            
            if (currentHp <= config.healthThreshold()) {
                log.debug("Health override active: {} HP <= {} HP", currentHp, config.healthThreshold());
                return true;
            }
        }

        // Check prayer override
        if (config.enablePrayerOverride()) {
            int currentPrayer = client.getBoostedSkillLevel(Skill.PRAYER);
            
            if (currentPrayer <= config.prayerThreshold()) {
                log.debug("Prayer override active: {} Prayer <= {} Prayer", currentPrayer, config.prayerThreshold());
                return true;
            }
        }

        return false;
    }
}

package com.distractionreducer;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;
import com.distractionreducer.DistractionReducerPlugin;

public class DistractionReducerTest
{
    public static void main(String[] args) throws Exception
    {
        ExternalPluginManager.loadBuiltin(DistractionReducerPlugin.class);
        RuneLite.main(args);
    }
}
