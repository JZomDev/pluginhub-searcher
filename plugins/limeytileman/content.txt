/*
 * Copyright (c) 2025, ModestLime <ModestLime@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.modestlime.limeytileman;

import com.modestlime.limeytileman.events.*;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;

@Slf4j
public class LimeyTileManPanel extends PluginPanel {

    private final LimeyTileManPlugin plugin;

    private final LimeyTileManImport limeyTileManImport;

    JButton copyTilesToClipboardButton;
    JButton importFromClipboardButton;
    JButton importTilesLeckeyButton;

    private final String deleteAllTilesString = "Delete ALL Tile Data";
    private final Timer deleteButtonTimer;
    JButton deleteAllTilesButton;
    private static final int clicksToDelete = 5;
    int deleteClicks;

    @Inject
    private ClientThread clientThread;

    @Inject
    private LimeyTileManPanel(LimeyTileManPlugin plugin, LimeyTileManImport limeyTileManImport){
        super();
        this.plugin = plugin;
        this.limeyTileManImport = limeyTileManImport;

        setBorder(new EmptyBorder(10, 10, 10, 10));

        JTextArea backUpWarning = createStyledTextArea("Please back up your tiles before importing from clipboard or Conor Leckey's tileMan!");
        backUpWarning.setForeground(Color.red);
        add(backUpWarning);
        add(Box.createRigidArea(new Dimension(0, 30)));


        JTextArea howToBackup = createStyledTextArea("To backup copy tiles to clipboard and paste somewhere safe.");
        add(howToBackup);


        copyTilesToClipboardButton = new JButton("Copy Tiles To ClipBoard");
        Insets currentMargins = copyTilesToClipboardButton.getMargin(); //so the success text fits cause its like 1 character to long
        copyTilesToClipboardButton.setMargin(new Insets(
                currentMargins.top,
                0,
                currentMargins.bottom,
                0
        ));
        add(copyTilesToClipboardButton);
        copyTilesToClipboardButton.addActionListener(e -> copyTilesToClipboard());
        add(Box.createRigidArea(new Dimension(0, 30)));


        JTextArea willMergeText = createStyledTextArea("Import will merge with current tiles.");
        add(willMergeText);


        importFromClipboardButton = new JButton("Import From ClipBoard");
        add(importFromClipboardButton);
        importFromClipboardButton.addActionListener(e -> importFromClipboard());
        add(Box.createRigidArea(new Dimension(0, 30)));


        JTextArea willMergeText2 = createStyledTextArea("Import will merge with current tiles.");
        add(willMergeText2);


        importTilesLeckeyButton = new JButton("Import From Leckey TileMan");
        add(importTilesLeckeyButton);
        importTilesLeckeyButton.addActionListener(e -> importTilesLeckey());
        add(Box.createRigidArea(new Dimension(0, 30)));


        JTextArea howToDeleteMode = createStyledTextArea("Hold delete and right click to toggle easy delete mode!\n\nWhile in this mode you can hold ctrl and drag your mouse to add tiles under you cursor or hold alt to remove tiles");
        howToDeleteMode.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        add(howToDeleteMode);


        add(Box.createRigidArea(new Dimension(0, 470)));
        JTextArea deleteTilesWarning = createStyledTextArea("Press 5 times in a row to delete ALL your tiles");
        add(deleteTilesWarning);


        deleteClicks = clicksToDelete;
        deleteButtonTimer = new Timer(5000, e -> {
            deleteClicks = clicksToDelete;
            deleteAllTilesButton.setText(deleteAllTilesString);
            deleteAllTilesButton.setForeground(Color.white);
        });
        deleteButtonTimer.setRepeats(false);
        deleteAllTilesButton = new JButton(deleteAllTilesString);
        deleteAllTilesButton.setForeground(Color.red);
        add(deleteAllTilesButton);
        deleteAllTilesButton.addActionListener(e -> deleteAllTiles());
    }

    private JTextArea createStyledTextArea(String text) {
        JTextArea textArea = new JTextArea(text);
        textArea.setEditable(false);
        textArea.setLineWrap(true);
        textArea.setWrapStyleWord(true);
        textArea.setFocusable(false);
        textArea.setAlignmentX(Component.CENTER_ALIGNMENT);
        textArea.setOpaque(true);
        return textArea;
    }

    private void deleteAllTiles(){
        if(deleteClicks == 0){return;}
        deleteButtonTimer.stop();
        deleteButtonTimer.start();
        deleteClicks--;
        deleteAllTilesButton.setText(deleteAllTilesString + " " + deleteClicks);
        if (deleteClicks == 0){
            deleteButtonTimer.stop();
            deleteAllTilesButton.setText("Deleting All Tiles!");
            deleteAllTilesButton.setForeground(Color.red);
            clientThread.invokeLater(plugin::deleteAllTiles);
        }
    }


    public void tilesDeleteSuccess(){
        deleteAllTilesButton.setText("Tiles Deleted Successfully!");
        deleteAllTilesButton.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
        deleteButtonTimer.start();
    }


    private void importFromClipboard(){
        importFromClipboardButton.setText("Importing Tiles....");
        clientThread.invokeLater(limeyTileManImport::importFromClipBoard);
    }


    @Subscribe
    public void onClipboardImported(ClipboardImported event){
        importFromClipboardButton.setText("Successfully Imported!");
        importFromClipboardButton.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
        Timer timer = new Timer(5000, e -> {
            importFromClipboardButton.setText("Import From ClipBoard");
            importFromClipboardButton.setForeground(Color.white);
        });
        timer.setRepeats(false);
        timer.start();
    }


    @Subscribe
    public void onClipboardImportFailed(ClipboardImportFailed event){
        importFromClipboardButton.setText("Failed to Import.");
        importFromClipboardButton.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
        Timer timer = new Timer(10000, e -> {
            importFromClipboardButton.setText("Import From ClipBoard");
            importFromClipboardButton.setForeground(Color.white);
        });
        timer.setRepeats(false);
        timer.start();
    }

    private void copyTilesToClipboard(){
        copyTilesToClipboardButton.setText("Copying...");
        clientThread.invokeLater(limeyTileManImport::copyTilesToClipBoard);
    }


    @Subscribe
    public void onTilesCopied(TilesCopied event){
        copyTilesToClipboardButton.setText("Successfully Copied To ClipBoard!");
        copyTilesToClipboardButton.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
        Timer timer = new Timer(5000, e -> {
            copyTilesToClipboardButton.setText("Copy Tiles To ClipBoard");
            copyTilesToClipboardButton.setForeground(Color.white);
        });
        timer.setRepeats(false);
        timer.start();
    }


    private void importTilesLeckey(){
        importTilesLeckeyButton.setText("Importing Tiles...");
        clientThread.invokeLater(limeyTileManImport::importTilesFromLeckey);
    }


    @Subscribe
    public void onLeckeyTilesImported(LeckeyTilesImported event){
        importTilesLeckeyButton.setText("Imported Tiles Successfully!");
        importTilesLeckeyButton.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
        Timer timer = new Timer(5000, e -> {
            importTilesLeckeyButton.setText("Import From Leckey TileMan");
            importTilesLeckeyButton.setForeground(Color.white);
        });
        timer.setRepeats(false);
        timer.start();
    }

    @Subscribe
    public void onLeckeyTilesImportFailed(LeckeyTilesImportFailed event) {
        importTilesLeckeyButton.setText("Imported Tiles Failed");
        importTilesLeckeyButton.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
        Timer timer = new Timer(5000, e -> {
            importTilesLeckeyButton.setText("Import From Leckey TileMan");
            importTilesLeckeyButton.setForeground(Color.white);
        });
        timer.setRepeats(false);
        timer.start();
    }

}

/*
 * Copyright (c) 2025, ModestLime <ModestLime@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.modestlime.limeytileman;

import com.google.gson.reflect.TypeToken;
import com.modestlime.limeytileman.events.*;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.config.ConfigManager;
import com.google.gson.Gson;
import net.runelite.client.eventbus.EventBus;

import javax.inject.Inject;
import java.awt.*;
import java.awt.datatransfer.*;
import java.io.IOException;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.stream.Collectors;



@Slf4j
public class LimeyTileManImport {

    @Inject
    private ConfigManager configManager;

    final private LimeyTileManPlugin plugin;

    final private EventBus eventBus;

    @Inject
    private Gson gson;

    private static final Type TILE_LIST_TYPE = new TypeToken<List<TileManModeTile>>() {}.getType();

    @Inject
    LimeyTileManImport(LimeyTileManPlugin plugin, EventBus eventBus){
        this.plugin = plugin;
        this.eventBus = eventBus;
    }


    public void importTilesFromLeckey(){
        List<String> tileManModeKeys = configManager.getConfigurationKeys("tilemanMode.region");
        List<String> regionKeys = tileManModeKeys.stream().map(key -> key.substring(12)).collect(Collectors.toList());

        List<TileManModeTile> tileManModeTiles = new ArrayList<>();
        for (String subKey: regionKeys) {
            String json = configManager.getConfiguration("tilemanMode", subKey);
            try{
                tileManModeTiles.addAll(gson.fromJson(json, TILE_LIST_TYPE));
            }catch (Exception ignored){}
        }

        if(tileManModeTiles.isEmpty()){
            eventBus.post(new LeckeyTilesImportFailed());
            return;
        }

        List<WorldPoint> worldPoints = tileManModeTiles.stream().map(tileManModeTile ->
                WorldPoint.fromRegion(tileManModeTile.getRegionId(), tileManModeTile.getRegionX(), tileManModeTile.getRegionY(), tileManModeTile.getZ())
        ).collect(Collectors.toList());


        for(WorldPoint point : worldPoints) {
            WorldPoint regionID = plugin.toRegion(point);
            List<WorldPoint> regionTiles = plugin.markedTiles.get(plugin.toHash(regionID));
            if (regionTiles == null) {
                regionTiles = new ArrayList<>(8 * 8);
            }
            if (!regionTiles.contains(point)) {
                regionTiles.add(point);
                plugin.markedTileCount++;
                plugin.availableTiles--;
            }
            plugin.markedTiles.put(plugin.toHash(regionID), regionTiles);
        }
        eventBus.post(new LeckeyTilesImported());
    }


    public void copyTilesToClipBoard(){
        String json = gson.toJson(plugin.markedTiles);
        StringSelection transferableJson = new StringSelection(json);
        Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
        clipboard.setContents(transferableJson,null);
        eventBus.post(new TilesCopied());
    }


    public void importFromClipBoard(){
        String json = "";
        Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
        Transferable contents = clipboard.getContents(null);
        if (contents != null && contents.isDataFlavorSupported(DataFlavor.stringFlavor)){
            try {
            json = (String) contents.getTransferData(DataFlavor.stringFlavor);
            } catch (UnsupportedFlavorException | IOException e) {
                eventBus.post(new ClipboardImportFailed());
                return;
            }
        }
        if(json.isBlank()){eventBus.post(new ClipboardImportFailed());}

        HashMap<Integer, List<WorldPoint>> importedTiles;
        try {
            importedTiles = gson.fromJson(json, new TypeToken<HashMap<Integer, List<WorldPoint>>>() {}.getType());
        } catch (Exception e){
            eventBus.post(new ClipboardImportFailed());
            return;
        }

        List<WorldPoint> combindedList = importedTiles.values().stream()
                .flatMap(List::stream)
                .collect(Collectors.toList());

        for(WorldPoint point : combindedList) {
            WorldPoint regionID = plugin.toRegion(point);
            List<WorldPoint> regionTiles = plugin.markedTiles.get(plugin.toHash(regionID));
            if (regionTiles == null) {
                regionTiles = new ArrayList<>(8 * 8);
            }
            if (!regionTiles.contains(point)) {
                regionTiles.add(point);
                plugin.markedTileCount++;
                plugin.availableTiles--;
            }
            plugin.markedTiles.put(plugin.toHash(regionID), regionTiles);
        }
        eventBus.post(new ClipboardImported());
    }
}


@Value
class TileManModeTile
{
    int regionId;
    int regionX;
    int regionY;
    int z;
}
/*
 * Copyright (c) 2025, ModestLime <ModestLime@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.modestlime.limeytileman;
import com.google.inject.Provides;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.Menu;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.PluginChanged;
import net.runelite.client.events.ProfileChanged;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.events.ClientShutdown;
import net.runelite.client.util.ImageUtil;

import javax.annotation.Nonnull;
import javax.inject.Inject;
import javax.swing.*;
import java.awt.*;
import java.awt.color.ColorSpace;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Timer;
import java.util.stream.Collectors;


@PluginDescriptor(
        name = "Limey Tile Man",
        description = "A Fast and Efficient TileMan Plugin With Extra Features"
)
@Slf4j
public class LimeyTileManPlugin extends Plugin{

    @Provides
    LimeyTileManConfig provideConfig(ConfigManager configManager){return configManager.getConfig(LimeyTileManConfig.class);}

    @Inject
    private LimeyTileManConfig config;

    @Inject
    private LimeyTileManOverlay overlay;

    @Inject
    private LimeyTileManTileInfoOverlay tileInfoOverlay;

    @Inject
    private LimeyTileManMiniMapOverlay limeyTileManMiniMapOverlay;

    @Inject
    private LimeyTileManWorldMapOverlay limeyTileManWorldMapOverlay;

    @Inject
    private Client client;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private Gson gson;

    @Inject
    private ConfigManager configManager;

    @Inject
    private ClientToolbar clientToolbar;

    @Inject
    private EventBus eventBus;

    @Inject
    private ClientThread clientThread;

    public List<WorldPoint> toRender;

    public List<WorldPoint> oneClickTiles;

    public long markedTileCount;

    public long xpToNextTile;

    public long availableTiles;

    private WorldPoint lastWorldPoint;

    public boolean easyDeleteMode;

    public HashMap<Integer, List<WorldPoint>> markedTiles;

    private static final Path tileManDir = RuneLite.RUNELITE_DIR.toPath().resolve("TileMan");

    private Path currentProfileFile;

    public Color tileColor;

    private static final ColorSpace linearRgbCS = ColorSpace.getInstance(ColorSpace.CS_LINEAR_RGB);

    private NavigationButton navButton;

    private LimeyTileManPanel limeyTileManPanel;

    private java.util.Timer autoSaveTimer;

    @Inject
    private PluginManager pluginManager;

    private Plugin gpuPlugin;

    private Plugin hdGpuPlugin;

    public boolean gpuEnabled;

    private static final String gpuPluginName = "GPU";
    private static final String hdGpuPluginName = "117 HD";


    @Override
    protected void startUp() throws Exception
    {

        log.warn("limey tile man started!");
//        log.info(String.valueOf(configManager.getProfile().getId()));

        currentProfileFile = tileManDir.resolve(configManager.getProfile().getId() + ".json");
        lastWorldPoint = null;
        markedTiles = new HashMap<>();
        toRender = new ArrayList<>();
        oneClickTiles = new ArrayList<>();
        markedTileCount = 0;
        xpToNextTile = 0;
        availableTiles = 0;
        easyDeleteMode = false;
        tileColor = config.tileColor();


        loadPoints();
        overlayManager.add(overlay);
        overlayManager.add(tileInfoOverlay);
        overlayManager.add(limeyTileManMiniMapOverlay);
        overlayManager.add(limeyTileManWorldMapOverlay);

        limeyTileManPanel = injector.getInstance(LimeyTileManPanel.class);

        final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "Lime.png");
        navButton = NavigationButton.builder()
                .tooltip("Limey Tile Man")
                .icon(icon)
                .priority(7)
                .panel(limeyTileManPanel)
                .build();
        clientToolbar.addNavigation(navButton);

        eventBus.register(limeyTileManPanel);

        Files.createDirectories(tileManDir);

        autoSaveTimer = new Timer();
        long fiveMinutesInMillis = 5 * 60 * 1000;
        autoSaveTimer.scheduleAtFixedRate(new TimerTask() {
            @Override
            public void run() {
                clientThread.invokeLater(LimeyTileManPlugin.this::savePoints);
            }
        },fiveMinutesInMillis,fiveMinutesInMillis);


        Collection<Plugin> pluginList = pluginManager.getPlugins();
        for(Plugin plugin : pluginList){
            if(plugin.getName().equals(gpuPluginName)){
                gpuPlugin = plugin;
            }
            if(plugin.getName().equals(hdGpuPluginName)){
                hdGpuPlugin = plugin;
            }
        }
        gpuEnabled = (gpuPlugin != null && pluginManager.isPluginEnabled(gpuPlugin)) || (hdGpuPlugin != null && pluginManager.isPluginEnabled(hdGpuPlugin));

    }


    @Override
    protected void shutDown() {
        overlayManager.remove(overlay);
        overlayManager.remove(tileInfoOverlay);
        overlayManager.remove(limeyTileManMiniMapOverlay);
        overlayManager.remove(limeyTileManWorldMapOverlay);
        clientToolbar.removeNavigation(navButton);
        eventBus.unregister(limeyTileManPanel);
        autoSaveTimer.cancel();
        savePoints(); //save tiles when plugin is disabled
    }


    @Subscribe
    public void onClientShutdown(ClientShutdown event){
        savePoints();  //save tiles when game is closed
    }


    @Subscribe
    public void onProfileChanged(ProfileChanged event)
    {
        savePoints();
        currentProfileFile = tileManDir.resolve(configManager.getProfile().getId() + ".json");
        markedTiles = new HashMap<>();
        loadPoints();
    }


    @Subscribe
    public void onPluginChanged(PluginChanged pluginChanged){
        if(pluginChanged.getPlugin().equals(gpuPlugin)){
            gpuEnabled = pluginChanged.isLoaded() || (hdGpuPlugin != null && pluginManager.isPluginEnabled(hdGpuPlugin));
        }
        if(pluginChanged.getPlugin().getName().equals(hdGpuPluginName)){
            if(!pluginChanged.getPlugin().equals(hdGpuPlugin)){
                hdGpuPlugin = pluginChanged.getPlugin();
            }
        }
        if(pluginChanged.getPlugin().getName().equals(hdGpuPluginName)){  //if 117hd gets uninstalled then set it to null
            if(!pluginChanged.isLoaded() && pluginManager.isPluginEnabled(hdGpuPlugin)){
                hdGpuPlugin = null;
                gpuEnabled = false;
            }
        }

        if(pluginChanged.getPlugin().equals(hdGpuPlugin)){
            gpuEnabled = pluginChanged.isLoaded() || (gpuPlugin != null && pluginManager.isPluginEnabled(gpuPlugin));
        }

    }


    @Subscribe
    public void onConfigChanged(ConfigChanged configChanged){    //onConfigChanged isn't on the client thread
        if(configChanged.getGroup().equals(config.GROUP)){
            updateTileInfo();
            if(configChanged.getKey().equals(config.AutoMark)){
                if(configChanged.getNewValue() == null){ //this happens on a brand-new profile creation
                    return;
                }
                if(configChanged.getNewValue().equals("true")){
                    //this avoids a race condition
                    clientThread.invokeLater(this::placeTileUnderPlayer); //overkill but now it marks the tile right away instead of after you move when you just enable it
                }
            }
            if(configChanged.getKey().equals(config.RenderDistance)){
                clientThread.invokeLater((Runnable) this::generateToRender);
            }
        }
    }


    private void placeTileUnderPlayer(){
        boolean allowedToMark = config.allowDeficit() || availableTiles > 0;
        if(allowedToMark) {
            Player localPlayer = client.getLocalPlayer();
            final WorldPoint playerPos = localPlayer.getWorldLocation();
            addToMarked(playerPos);   //overkill but now it marks the tile right away instead of after you move when you just enable it
        }
    }


    public void deleteAllTiles(){
        markedTiles = new HashMap<>();
        markedTileCount = 0;
        updateTileInfo();
        SwingUtilities.invokeLater(() -> limeyTileManPanel.tilesDeleteSuccess());
    }


    @Subscribe
    public void onGameTick(GameTick tick) {
        Player localPlayer = client.getLocalPlayer();
        final WorldPoint playerPos = localPlayer.getWorldLocation();

        boolean allowedToMark = config.allowDeficit() || availableTiles > 0;
        if(config.autoMark() & allowedToMark) {
            if (!playerPos.equals(lastWorldPoint)) {
                List<WorldPoint> path = bfsPathFinding(lastWorldPoint, playerPos, 3);
                if (path.isEmpty()) { //we teleported
                    addToMarked(playerPos);
                }
                for (WorldPoint point : path) {
                    addToMarked(point);
                    if(availableTiles == 0 && !config.allowDeficit()){break;}
                }
            }
        }

        updateTileInfo();

        generateToRender(playerPos);

        lastWorldPoint = playerPos;
    }


    public void generateToRender(){
        Player player = client.getLocalPlayer();
        if(player != null) {
            generateToRender(player.getWorldLocation());
        }
    }


    public void generateToRender(WorldPoint playerPos){
        WorldView wv = client.getTopLevelWorldView();
        LocalPoint lp = LocalPoint.fromWorld(wv, playerPos);
        if(lp == null){return;}
        WorldPoint playerPosFromLocal = WorldPoint.fromLocalInstance(client, lp, wv.getPlane());

        int regionLocalX = playerPosFromLocal.getX() & 7; //my regions are 8x8 and doing & 7 give us the remainder
        int regionLocalY = playerPosFromLocal.getY() & 7;

        int westRegionAmount = ((config.renderDistance() - regionLocalX) + 7) >> 3;  //Math.ceil((double) number / 8)
        int eastRegionAmount = (config.renderDistance() + regionLocalX) >> 3;

        int northRegionAmount = (config.renderDistance() + regionLocalY) >> 3;
        int southRegionAmount = ((config.renderDistance() - regionLocalY) + 7) >> 3;

        int maxLength = Math.max(westRegionAmount,
                        Math.max(eastRegionAmount,
                        Math.max(northRegionAmount, southRegionAmount)));


        List<WorldPoint> regionsToRender = new ArrayList<>();
        for (int i = maxLength; i >= 0; i--) {
            regionsToRender.addAll(regionSquareEdge(playerPosFromLocal, i)); //list of all regions to render from farthest to closest
        }

        List<WorldPoint> allTilesToRender = new ArrayList<>();
        for(WorldPoint region: regionsToRender){
            List<WorldPoint> regionTiles = markedTiles.get(toHash(region));
            if(regionTiles != null){
                allTilesToRender.addAll(regionTiles);
            }
        }

        int minX = playerPosFromLocal.getX() - config.renderDistance();
        int maxX = playerPosFromLocal.getX() + config.renderDistance();
        int minY = playerPosFromLocal.getY() - config.renderDistance();
        int maxY = playerPosFromLocal.getY() + config.renderDistance();

        allTilesToRender = allTilesToRender.stream().filter(worldPoint ->
                (worldPoint.getX() >= minX) && (worldPoint.getX() <= maxX) && (worldPoint.getY() >= minY) && (worldPoint.getY() <= maxY)
            ).flatMap(worldPoint -> {
                Collection<WorldPoint> localInstances = WorldPoint.toLocalInstance(wv, worldPoint);
                return localInstances.stream();
            }).collect(Collectors.toList());

        oneClickTiles = new ArrayList<>();
        toRender = new ArrayList<>();
        if(config.oneClickTiles()){
            WorldPoint[][] parentMap = getBfsPathFindingParentMap(playerPos);

            while(!allTilesToRender.isEmpty()){                       // I could probably make a 104x104 boolean "true if already checked" to speed it up instead of
                List<WorldPoint> currentPath = new ArrayList<>();     //doing a bunch of .contains / .indexOf operations;
                WorldPoint connectingTile = allTilesToRender.get(0);
                currentPath.add(allTilesToRender.remove(0));

                while(true) {
                    LocalPoint tileLocal = LocalPoint.fromWorld(wv, connectingTile);
                    if(tileLocal == null){
                        toRender.addAll(currentPath);
                        break;
                    }

                    connectingTile = parentMap[tileLocal.getSceneX()][tileLocal.getSceneY()];

                    if(connectingTile == null){
                        toRender.addAll(currentPath);
                        setParentPath(wv, currentPath, parentMap, null);
                        break;
                    }
                    if(connectingTile.equals(playerPos)){
                        oneClickTiles.addAll(currentPath);
                        setParentPath(wv, currentPath, parentMap, playerPos);
                        break;
                    }

                    int index = allTilesToRender.indexOf(connectingTile);
                    if(index != -1){
                        currentPath.add(allTilesToRender.remove(index));
                    }else if (oneClickTiles.contains(connectingTile)) {
                        oneClickTiles.addAll(currentPath);
                        setParentPath(wv, currentPath, parentMap, playerPos);
                        break;
                    }else{
                        toRender.addAll(currentPath);
                        setParentPath(wv, currentPath, parentMap, null);
                        break;
                    }
                }

            }
        }else{
            toRender = allTilesToRender;
        }
        generateTileColors();
    }



    private void generateTileColors(){
        tileColor = config.tileColor();
        if(config.warnToggle()){
            if(availableTiles <= config.warnThreshold()){
                tileColor = config.warnColor();
            }
            if(availableTiles <= 0){
                tileColor = config.warnColorZero();
            }
        }
        if(config.gradualFade() && config.warnToggle()){
            Color color1;
            Color color2;
            float ratio1;
            float ratio2;
            if(availableTiles > config.warnThreshold()){
                ratio1 = (availableTiles - config.warnThreshold()) / 10f; //start to fade the normal color to the warning when we are with in 10tiles
                ratio1 = Math.min(1f, ratio1);
                ratio2 = 1f - ratio1;
                color1 = config.tileColor();
                color2  = config.warnColor();

                //mix tile and warn color
            }else {
                ratio1 = availableTiles / (float)config.warnThreshold();
                ratio1 = Math.max(0f, ratio1);
                ratio2 = 1f - ratio1;
                color1 = config.warnColor();
                color2  = config.warnColorZero();
                //mix warn color and zero tile
            }

            int alpha = (int)(color1.getAlpha() * ratio1 + color2.getAlpha() * ratio2);
            assert alpha <= 255;

            float[] color1RGBColorComponents = color1.getRGBColorComponents(null);
            float[] color2RGBColorComponents = color2.getRGBColorComponents(null);

            float[] color1LinearColorComponents = linearRgbCS.fromRGB(color1RGBColorComponents);
            float[] color2LinearColorComponents = linearRgbCS.fromRGB(color2RGBColorComponents);

            float[] blendedLinearRgb = new float[3];
            blendedLinearRgb[0] = color1LinearColorComponents[0] * ratio1 + color2LinearColorComponents[0] * ratio2; // Red
            blendedLinearRgb[1] = color1LinearColorComponents[1] * ratio1 + color2LinearColorComponents[1] * ratio2; // Green
            blendedLinearRgb[2] = color1LinearColorComponents[2] * ratio1 + color2LinearColorComponents[2] * ratio2; // Blue

            float[] blendedRgb = linearRgbCS.toRGB(blendedLinearRgb);

            tileColor = new Color(blendedRgb[0], blendedRgb[1], blendedRgb[2], alpha / 255f);

        }
    }


    private void setParentPath(WorldView wv, List<WorldPoint> tiles, WorldPoint[][] parentMap, WorldPoint setTo){
        for(WorldPoint tile : tiles){
            LocalPoint tileLocal = LocalPoint.fromWorld(wv, tile);
            assert tileLocal != null;
            parentMap[tileLocal.getSceneX()][tileLocal.getSceneY()] = setTo;
        }
    }


    @Subscribe
    public void onClientTick(ClientTick tick){
        if(easyDeleteMode){
            WorldView wv = client.getTopLevelWorldView();
            Tile currentTile = wv.getSelectedSceneTile();
            if(currentTile != null) {
                WorldPoint mouseTile = currentTile.getWorldLocation();
                long oldMarkedCount = markedTileCount;
                if(client.isKeyPressed(KeyCode.KC_CONTROL)){
                    if (config.allowDeficit() || availableTiles > 0) {
                        addToMarked(mouseTile);
                    }
                }
                if(client.isKeyPressed(KeyCode.KC_ALT)){
                    removeFromMarked(mouseTile);
                }
                if(markedTileCount != oldMarkedCount){
                    generateToRender();
                    updateTileInfo();
                }
            }
        }
    }


    @Subscribe
    public void onMenuEntryAdded(MenuEntryAdded event){
        final boolean holdingShiftKey = client.isKeyPressed(KeyCode.KC_SHIFT);
        if (holdingShiftKey && event.getOption().equals("Walk here")) {
            WorldView wv = client.getTopLevelWorldView();
            final Tile selectedSceneTile = wv.getSelectedSceneTile();
            if (selectedSceneTile == null)
            {
                return;
            }

            WorldPoint point = selectedSceneTile.getWorldLocation();
            LocalPoint lp = LocalPoint.fromWorld(wv, point);
            if(lp == null){return;}
            WorldPoint realPoint = WorldPoint.fromLocalInstance(client, lp, wv.getPlane());
            WorldPoint regionID = toRegion(realPoint);
            List<WorldPoint> regionTiles = markedTiles.get(toHash(regionID));
            if(regionTiles == null){
                regionTiles = new ArrayList<>(0); //empty just so we can call contains
            }
            boolean hasMarkedTile = regionTiles.contains(realPoint);

            Menu menu = client.getMenu();
            menu.createMenuEntry(-1)
                .setOption(hasMarkedTile ? "Remove TileMan" : "Add TileMan")
                .setTarget("<col=09ff00>Tile")
                .setType(MenuAction.RUNELITE).onClick(menuEntry -> {
                    if(hasMarkedTile){
                        removeFromMarked(point);
                    }else{
                        if (config.allowDeficit() || availableTiles > 0) {
                            addToMarked(point);
                        }
                    }
                    generateToRender();
                    updateTileInfo();
                });
        }
        final boolean holdingDeleteKey = client.isKeyPressed(KeyCode.KC_DELETE);
        if (holdingDeleteKey && event.getOption().equals("Walk here")) {
            Menu menu = client.getMenu();
            menu.createMenuEntry(-1)
                .setOption(easyDeleteMode ? "Disable" : "Enable")
                .setTarget("<col=ff00e6>Easy Tile Deletion")
                .setType(MenuAction.RUNELITE).onClick(menuEntry -> easyDeleteMode = !easyDeleteMode);
        }

    }


    private void updateTileInfo(){
        availableTiles = 0;

        long totalPlayerXp = client.getOverallExperience();
        long totalTiles = (totalPlayerXp / config.xpPerTile());
        xpToNextTile = config.xpPerTile() - (totalPlayerXp % config.xpPerTile());

        if(config.addTilesOnXp()) {
            availableTiles += totalTiles;
        }
        if(config.addTileOnLevel()){
            availableTiles += (long) client.getTotalLevel() * config.tilesPerLevel();
        }
        availableTiles += config.addTiles();
        availableTiles -= config.subtractTiles();
        availableTiles -= markedTileCount;
    }

    /**
     *
     * @param point a normal {@link WorldPoint} to be added to markedTiles
     */
    private void addToMarked(WorldPoint point){
        WorldView wv = client.getTopLevelWorldView();
        LocalPoint lp = LocalPoint.fromWorld(wv, point);
        if(lp == null){return;}
        point = WorldPoint.fromLocalInstance(client, lp, wv.getPlane());

        WorldPoint regionID = toRegion(point);
        List<WorldPoint> regionTiles = markedTiles.get(toHash(regionID));
        if(regionTiles == null){
            regionTiles = new ArrayList<>(8 * 8);
        }
        if(!regionTiles.contains(point)){
            regionTiles.add(point);
            markedTileCount++;
            availableTiles--;
        }
        markedTiles.put(toHash(regionID), regionTiles);
    }


    private void removeFromMarked(WorldPoint point){
        WorldView wv = client.getTopLevelWorldView();
        LocalPoint lp = LocalPoint.fromWorld(wv, point);
        if(lp == null){return;}
        point = WorldPoint.fromLocalInstance(client, lp, wv.getPlane());

        WorldPoint regionID = toRegion(point);
        List<WorldPoint> regionTiles = markedTiles.get(toHash(regionID));
        if(regionTiles == null){
            return;
        }
        if(regionTiles.contains(point)){
            regionTiles.remove(point);
            markedTileCount--;
            availableTiles++;
        }
        markedTiles.put(toHash(regionID), regionTiles);
    }


    private List<WorldPoint> regionSquareEdge(WorldPoint center, int length){
        List<WorldPoint> pointsOnEdge = new ArrayList<>();
        int plane = center.getPlane();
        WorldPoint regionCenter = toRegion(center);
        int xRegion = regionCenter.getX();
        int yRegion = regionCenter.getY();

        if (length == 0) { // Special case for a 1x1 square
            pointsOnEdge.add(new WorldPoint(xRegion, yRegion, plane));
            return pointsOnEdge;
        }

        int minX = xRegion - length;
        int maxX = xRegion + length;
        int minY = yRegion - length;
        int maxY = yRegion + length;



        // Add top and bottom horizontal lines
        for (int x = minX; x <= maxX; x++) {
            pointsOnEdge.add(new WorldPoint(x, minY, plane));
            pointsOnEdge.add(new WorldPoint(x, maxY, plane));
        }

        // Add left and right vertical lines (excluding corners to avoid duplicates)
        for (int y = minY + 1; y < maxY; y++) { // Start y from minY + 1 and end at maxY - 1
            pointsOnEdge.add(new WorldPoint(minX, y, plane));
            pointsOnEdge.add(new WorldPoint(maxX, y, plane));
        }
        return pointsOnEdge;
    }

    /**
     *
     * @param wp takes a regioned WorldPoint, see {@link LimeyTileManPlugin#toRegion(WorldPoint)}
     * @return returns a unique int representing the regioned WorldPoint
     */
    public int toHash(WorldPoint wp){
        int x = wp.getX();
        int y = wp.getY();
        int plane = wp.getPlane();

        return (x << 16) | (y << 4) | plane;
    }


    private void savePoints(){
        String json = gson.toJson(markedTiles);
        try{
            Files.writeString(currentProfileFile, json);
        }catch (IOException e){
            log.error("error writing to file ", e);
        }

    }


    private void loadPoints(){
        if(!Files.exists(currentProfileFile)){
            savePoints();
        }
        String json = "";
        try {
            json = Files.readString(currentProfileFile);
        }catch (IOException e){
            log.error("error reading file ", e);
        }

        markedTiles = gson.fromJson(json, new TypeToken<HashMap<Integer, List<WorldPoint>>>(){}.getType());
        for( List<WorldPoint> region: markedTiles.values()){
            markedTileCount += region.size();

        }
    }


    public WorldPoint toRegion(WorldPoint wp){
        int x = wp.getX();
        int y = wp.getY();
        int plane = wp.getPlane();

        int xRegion = x >> 3;
        int yRegion = y >> 3;

        return new WorldPoint(xRegion, yRegion, plane);
    }


    public List<WorldPoint> bfsPathFinding(WorldPoint start, @Nonnull WorldPoint end, int stopDepth){
        if(start == null) { //plugin has just started null will always be passed in
            return List.of(end);
        }
        if(start.equals(end)){
            return List.of(start);
        }
        WorldArea startArea = start.toWorldArea();
        WorldView wv =  client.getTopLevelWorldView();
        int plane = wv.getPlane();

        Queue<WorldArea> queue = new ArrayDeque<>();
        WorldPoint[][] parentMap = new WorldPoint[104][104];

        queue.offer(startArea);
        LocalPoint lp = LocalPoint.fromWorld(wv,startArea.toWorldPoint());
        if(lp == null){
            return new ArrayList<>();
        }
        parentMap[lp.getSceneX()][lp.getSceneY()] = null;

        WorldArea currentNode = null;
        int currentDepth = 0;
        whileLoop:
        while (!queue.isEmpty()) {
            if(currentDepth == stopDepth){
                break;
            }
            int depthSize = queue.size();

            for (int i = 0; i < depthSize; i++) {

                currentNode = queue.poll();

                assert currentNode != null;
                if (currentNode.toWorldPoint().equals(end)) {
                    break whileLoop;
                }

                int xCord = currentNode.getX();
                int yCord = currentNode.getY();
                WorldPoint currentWP = currentNode.toWorldPoint();
                lp = LocalPoint.fromWorld(wv, currentWP);
                assert lp != null;
                int localX = lp.getSceneX();
                int localY = lp.getSceneY();

                if (parentMap[localX - 1][localY] == null) {
                    if (currentNode.canTravelInDirection(wv, -1, 0)) {   //west
                        queue.add(new WorldArea(xCord - 1, yCord, 1, 1, plane));
                        parentMap[localX - 1][localY] = currentWP;
                    }
                }
                if (parentMap[localX + 1][localY] == null) {
                    if (currentNode.canTravelInDirection(wv, 1, 0)) {   //east
                        queue.add(new WorldArea(xCord + 1, yCord, 1, 1, plane));
                        parentMap[localX + 1][localY] = currentWP;
                    }
                }
                if (parentMap[localX][localY - 1] == null) {
                    if (currentNode.canTravelInDirection(wv, 0, -1)) {   //south
                        queue.add(new WorldArea(xCord, yCord - 1, 1, 1, plane));
                        parentMap[localX][localY - 1] = currentWP;
                    }
                }
                if (parentMap[localX][localY + 1] == null) {
                    if (currentNode.canTravelInDirection(wv, 0, 1)) {   //north
                        queue.add(new WorldArea(xCord, yCord + 1, 1, 1, plane));
                        parentMap[localX][localY + 1] = currentWP;
                    }
                }
                if (parentMap[localX - 1][localY - 1] == null) {
                    if (currentNode.canTravelInDirection(wv, -1, -1)) {   //south-west
                        queue.add(new WorldArea(xCord - 1, yCord - 1, 1, 1, plane));
                        parentMap[localX - 1][localY - 1] = currentWP;
                    }
                }
                if (parentMap[localX + 1][localY - 1] == null) {
                    if (currentNode.canTravelInDirection(wv, 1, -1)) {   //south-east
                        queue.add(new WorldArea(xCord + 1, yCord - 1, 1, 1, plane));
                        parentMap[localX + 1][localY - 1] = currentWP;
                    }
                }
                if (parentMap[localX - 1][localY + 1] == null) {
                    if (currentNode.canTravelInDirection(wv, -1, 1)) {   //north-west
                        queue.add(new WorldArea(xCord - 1, yCord + 1, 1, 1, plane));
                        parentMap[localX - 1][localY + 1] = currentWP;
                    }
                }
                if (parentMap[localX + 1][localY + 1] == null) {
                    if (currentNode.canTravelInDirection(wv, 1, 1)) {   //north-east
                        queue.add(new WorldArea(xCord + 1, yCord + 1, 1, 1, plane));
                        parentMap[localX + 1][localY + 1] = currentWP;
                    }
                }
            }
            currentDepth++;
        }

        assert currentNode != null;
        if(currentNode.toWorldPoint().equals(end)){
            List<WorldPoint> path = new ArrayList<>();
            WorldPoint wp = end;
            path.add(wp);
            while (true){
                lp = LocalPoint.fromWorld(wv,wp);
                assert lp != null;
                wp = parentMap[lp.getSceneX()][lp.getSceneY()];
                path.add(wp);
                if(wp.equals(start)){
                    Collections.reverse(path);
                    return path;
                }
            }

        }
        return new ArrayList<>();
    }


    public WorldPoint[][] getBfsPathFindingParentMap(@Nonnull WorldPoint start){

        WorldArea startArea = start.toWorldArea();
        WorldView wv =  client.getTopLevelWorldView();
        int plane = wv.getPlane();

        Queue<WorldArea> queue = new ArrayDeque<>();
        WorldPoint[][] parentMap = new WorldPoint[104][104];

        queue.offer(startArea);
        LocalPoint lp = LocalPoint.fromWorld(wv,startArea.toWorldPoint());
        if(lp == null){
            return null;
        }
        parentMap[lp.getSceneX()][lp.getSceneY()] = start;

        WorldArea currentNode;

        while (!queue.isEmpty()) {
            int depthSize = queue.size();

            for (int i = 0; i < depthSize; i++) {

                currentNode = queue.poll();

                assert currentNode != null;

                int xCord = currentNode.getX();
                int yCord = currentNode.getY();
                WorldPoint currentWP = currentNode.toWorldPoint();
                lp = LocalPoint.fromWorld(wv, currentWP);
                assert lp != null;  //localPoint will always be valid as we cant leave the 104x104 collision map area
                int localX = lp.getSceneX();
                int localY = lp.getSceneY();


                if (parentMap[localX - 1][localY] == null) {
                    if (currentNode.canTravelInDirection(wv, -1, 0)) {   //west
                        queue.add(new WorldArea(xCord - 1, yCord, 1, 1, plane));
                        parentMap[localX - 1][localY] = currentWP;
                    }
                }
                if (parentMap[localX + 1][localY] == null) {
                    if (currentNode.canTravelInDirection(wv, 1, 0)) {   //east
                        queue.add(new WorldArea(xCord + 1, yCord, 1, 1, plane));
                        parentMap[localX + 1][localY] = currentWP;
                    }
                }
                if (parentMap[localX][localY - 1] == null) {
                    if (currentNode.canTravelInDirection(wv, 0, -1)) {   //south
                        queue.add(new WorldArea(xCord, yCord - 1, 1, 1, plane));
                        parentMap[localX][localY - 1] = currentWP;
                    }
                }
                if (parentMap[localX][localY + 1] == null) {
                    if (currentNode.canTravelInDirection(wv, 0, 1)) {   //north
                        queue.add(new WorldArea(xCord, yCord + 1, 1, 1, plane));
                        parentMap[localX][localY + 1] = currentWP;
                    }
                }
                if (parentMap[localX - 1][localY - 1] == null) {
                    if (currentNode.canTravelInDirection(wv, -1, -1)) {   //south-west
                        queue.add(new WorldArea(xCord - 1, yCord - 1, 1, 1, plane));
                        parentMap[localX - 1][localY - 1] = currentWP;
                    }
                }
                if (parentMap[localX + 1][localY - 1] == null) {
                    if (currentNode.canTravelInDirection(wv, 1, -1)) {   //south-east
                        queue.add(new WorldArea(xCord + 1, yCord - 1, 1, 1, plane));
                        parentMap[localX + 1][localY - 1] = currentWP;
                    }
                }
                if (parentMap[localX - 1][localY + 1] == null) {
                    if (currentNode.canTravelInDirection(wv, -1, 1)) {   //north-west
                        queue.add(new WorldArea(xCord - 1, yCord + 1, 1, 1, plane));
                        parentMap[localX - 1][localY + 1] = currentWP;
                    }
                }
                if (parentMap[localX + 1][localY + 1] == null) {
                    if (currentNode.canTravelInDirection(wv, 1, 1)) {   //north-east
                        queue.add(new WorldArea(xCord + 1, yCord + 1, 1, 1, plane));
                        parentMap[localX + 1][localY + 1] = currentWP;
                    }
                }
            }
        }
        return parentMap;
    }
}

/*
 * Copyright (c) 2025, ModestLime <ModestLime@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.modestlime.limeytileman;

import net.runelite.client.config.*;

import java.awt.*;


@ConfigGroup(LimeyTileManConfig.GROUP)
public interface LimeyTileManConfig extends Config{
    String GROUP = "limeytileman";
    String RenderDistance = "renderDistance";
    String AutoMark = "autoMark";


    @ConfigSection(
            name = "Colors",
            description = "Color options for all the different settings",
            closedByDefault = true,
            position = 100
    )
    String colorsSection = "colorsSection";

    @ConfigSection(
            name = "Customize game mode settings",
            description = "Customize everything :)",
            closedByDefault = true,
            position = 200
    )
    String gameModeSection = "gameModeSection";


    @Range(
            max = 70
    )
    @ConfigItem(
            keyName = RenderDistance,
            name = "Tile Render Distance",
            description = "Distance to render in tiles around the player",
            position = 0
    )
    default int renderDistance()
    {
        return 32;
    }

    @ConfigItem(
            keyName = AutoMark,
            name = "Auto Mark tiles",
            description = "Automatically marks tiles as you move",
            position = 1
    )
    default boolean autoMark(){return true;}

    @ConfigItem(
            keyName = "allowDeficit",
            name = "Allow Tile Deficit",
            description = "Lets you go into debt when placing tiles",
            position = 1
    )
    default boolean allowDeficit(){return true;}

    @ConfigItem(
            keyName = "warnToggle",
            name = "Warning when low",
            description = "Change color of tiles when you are low",
            position = 2
    )
    default boolean warnToggle(){return true;}

    @ConfigItem(
            keyName = "warnThreshold",
            name = "Warning Threshold",
            description = "How many tiles left before it changes colors",
            position = 3
    )
    default int warnThreshold(){return 20;}

    @ConfigItem(
            keyName = "oneClickTiles",
            name = "One Clickable Tiles",
            description = "Change tile colors of tiles that can be reached in 1 click",
            position = 4
    )
    default boolean oneClickTiles(){return true;}

    @ConfigItem(
            keyName = "drawMinimap",
            name = "Draw on Minimap",
            description = "Draw's your marked tiles on the minimap",
            position = 5
    )
    default boolean drawMinimap(){return false;}

    @ConfigItem(
            keyName = "drawWorldMap",
            name = "Draw on WorldMap",
            description = "Draw's your marked tiles on the world map",
            position = 6
    )
    default boolean drawWorldMap(){return false;}

    @ConfigItem(
            keyName = "bigMapTiles",
            name = "Big Tiles on World Map",
            description = "Draw's the tiles on the world map to be big when zoomed out",
            position = 7
    )
    default boolean bigMapTiles(){return false;}



    //colors
    @Alpha
    @ConfigItem(
            keyName = "tileColor",
            name = "Tile Color",
            description = "Color of the marked tiles",
            section = colorsSection,
            position = 101
    )
    default Color tileColor() {return new Color(255,255,255, 172);}

    @Alpha
    @ConfigItem(
            keyName = "TileFillColor",
            name = "Tile Fill Color",
            description = "Color of The Fill",
            section = colorsSection,
            position = 102
    )
    default Color tileFillColor(){return new Color(0, 0, 0, 50);}

    @Alpha
    @ConfigItem(
            keyName = "gradualFade",
            name = "Gradual Fade Warning",
            description = "Gradually fades the colors between the tile color->warning color->zero tile color",
            section = colorsSection,
            position = 103
    )
    default boolean gradualFade(){return true;}

    @Alpha
    @ConfigItem(
            keyName = "warnColor",
            name = "Warning Color",
            description = "Color of Tiles when you get low",
            section = colorsSection,
            position = 104
    )
    default Color warnColor() {return new Color(255, 106, 0, 189);}

    @Alpha
    @ConfigItem(
            keyName = "warnColorZero",
            name = "Warning Zero Tiles",
            description = "Color of Tiles when you no long have tiles left",
            section = colorsSection,
            position = 105
    )
    default Color warnColorZero() {return new Color(255, 0, 0, 171);}

    @Alpha
    @ConfigItem(
            keyName = "oneClickTilesColor",
            name = "One Clickable Tiles Color",
            description = "Color of one clickable tiles",
            section = colorsSection,
            position = 106
    )
    default Color oneClickTilesColor(){return new Color(0, 163, 255, 206);}

    @Alpha
    @ConfigItem(
            keyName = "oneClickTilesColorFill",
            name = "One Clickable Tiles Fill Color",
            description = "Color of The Fill",
            section = colorsSection,
            position = 107
    )
    default Color oneClickTilesColorFill(){return new Color(0, 0, 0, 50);}

    @Alpha
    @ConfigItem(
            keyName = "miniMapColor",
            name = "MiniMap Tile Color",
            description = "Color of the tiles on the mini map",
            section = colorsSection,
            position = 108
    )
    default Color miniMapColor(){return new Color(0, 247, 255, 116);}

    @Alpha
    @ConfigItem(
            keyName = "worldMapColor",
            name = "WorldMap Tile Color",
            description = "Color of the tiles on the world map",
            section = colorsSection,
            position = 109
    )
    default Color worldMapColor(){return new Color(255, 0, 251, 116);}


    //game mode settings
    @ConfigItem(
            keyName = "addTiles",
            name = "Add Tiles",
            description = "Add extra tiles!",
            section = gameModeSection,
            position = 201
    )
    default int addTiles()
    {
        return 0;
    }

    @ConfigItem(
            keyName = "subtractTiles",
            name = "Subtract Tiles",
            description = "subtract tiles!",
            section = gameModeSection,
            position = 202
    )
    default int subtractTiles()
    {
        return 0;
    }

    @ConfigItem(
            keyName = "addTilesOnXp",
            name = "Add Tiles With Xp",
            description = "Add Tiles when you gain xp",
            section = gameModeSection,
            position = 203
    )
    default boolean addTilesOnXp()
    {
        return true;
    }

    @Range(
            min = 1
    )
    @ConfigItem(
            keyName = "xpPerTile",
            name = "Xp Per Tile",
            description = "Amount of xp to gain a tile",
            section = gameModeSection,
            position = 204
    )
    default int xpPerTile()
    {
        return 500;
    }

    @ConfigItem(
            keyName = "addTileOnLevel",
            name = "Add Tiles with total level",
            description = "Adds tiles based on your total level",
            section = gameModeSection,
            position = 205
    )
    default boolean addTileOnLevel(){return false;}

    @ConfigItem(
            keyName = "tilesPerLevel",
            name = "Tiles added per level",
            description = "Amount of tiles to add per level up (Add total Levels must be enabled)",
            section = gameModeSection,
            position = 206
    )
    default int tilesPerLevel(){return 1;}




}
/*
 * Copyright (c) 2025, ModestLime <ModestLime@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.modestlime.limeytileman;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import java.awt.*;
import java.awt.geom.AffineTransform;

@Slf4j
public class LimeyTileManMiniMapOverlay extends Overlay {

    final private Client client;
    final private LimeyTileManConfig config;
    final private LimeyTileManPlugin plugin;


    @Inject
    private LimeyTileManMiniMapOverlay(Client client, LimeyTileManConfig config, LimeyTileManPlugin plugin) {
        this.client = client;
        this.config = config;
        this.plugin = plugin;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPriority(PRIORITY_LOW);
    }
    
    
    @Override
    public Dimension render(Graphics2D graphics) {

        if(!config.drawMinimap()){
            return null;
        }

        double angle = client.getCameraYawTarget() * Perspective.UNIT;
        double tileSize = client.getMinimapZoom();
        double unCenterOffset = tileSize / 2;
        int size = (int) Math.round(tileSize);
        graphics.setColor(config.miniMapColor());
        AffineTransform originalTransform = graphics.getTransform();

        WorldView wv = client.getTopLevelWorldView();
        for (WorldPoint point : plugin.toRender) {
            final LocalPoint tilePosLocal = LocalPoint.fromWorld(wv, point);
            if (tilePosLocal != null) {


                Point minimapTile = Perspective.localToMinimap(client, tilePosLocal);

                if (minimapTile == null) {
                    continue;
                }

                int x = (int) Math.round(minimapTile.getX() - unCenterOffset);
                int y = (int) Math.round(minimapTile.getY() - unCenterOffset);
                graphics.rotate(angle, minimapTile.getX(), minimapTile.getY());
                graphics.fillRect(x, y, size, size);
                graphics.setTransform(originalTransform);
            }
        }
        for (WorldPoint point : plugin.oneClickTiles) {
            final LocalPoint tilePosLocal = LocalPoint.fromWorld(wv, point);
            if (tilePosLocal != null) {


                Point minimapTile = Perspective.localToMinimap(client, tilePosLocal);

                if (minimapTile == null) {
                    continue;
                }

                int x = (int) Math.round(minimapTile.getX() - unCenterOffset);
                int y = (int) Math.round(minimapTile.getY() - unCenterOffset);
                graphics.rotate(angle, minimapTile.getX(), minimapTile.getY());
                graphics.fillRect(x, y, size, size);
                graphics.setTransform(originalTransform);
            }
        }
        return null;
    }
}



/*
 * Copyright (c) 2025, ModestLime <ModestLime@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.modestlime.limeytileman;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.*;

import javax.inject.Inject;
import java.awt.*;
import java.awt.geom.Path2D;


@Slf4j
public class LimeyTileManOverlay extends Overlay{

    final private Client client;
    final private LimeyTileManConfig config;
    final private LimeyTileManPlugin plugin;

    private final Path2D combinedToRender;
    private final Path2D combinedOneClickTiles;
    private final BasicStroke stroke =  new BasicStroke(2);

    @Inject
    private LimeyTileManOverlay(Client client, LimeyTileManConfig config, LimeyTileManPlugin plugin) {
        this.client = client;
        this.config = config;
        this.plugin = plugin;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
        setPriority(PRIORITY_LOW);

        combinedToRender = new Path2D.Float();
        combinedOneClickTiles = new Path2D.Float();


    }


    @Override
    public Dimension render(Graphics2D graphics){
        combinedToRender.reset();
        WorldView wv = client.getTopLevelWorldView();
        for (WorldPoint point : plugin.toRender) {
            final LocalPoint tilePosLocal = LocalPoint.fromWorld(wv, point);
            if (tilePosLocal != null) {
                final Polygon poly = Perspective.getCanvasTilePoly(client, tilePosLocal);
                if (poly != null) {
                    combinedToRender.append(poly, false);
                }
            }
        }

        combinedOneClickTiles.reset();
        for (WorldPoint point : plugin.oneClickTiles) {
            final LocalPoint tilePosLocal = LocalPoint.fromWorld(wv, point);
            if (tilePosLocal != null) {
                final Polygon poly = Perspective.getCanvasTilePoly(client, tilePosLocal);
                if (poly != null) {
                    combinedOneClickTiles.append(poly, false);
                }
            }
        }

        if(plugin.gpuEnabled) {
            //speeds up rendering and makes it look better by not mixing colors when drawing tiles
            //but when not rendering on the gpu our Graphics2D objects image buffer will contain our runescape scene instead of being blank,
            //so we don't want to overwrite pixels and always want to mix with the background
            graphics.setComposite(AlphaComposite.Src);
        }

        graphics.setColor(config.tileFillColor());
        graphics.fill(combinedToRender);
        graphics.setColor(config.oneClickTilesColorFill());
        graphics.fill(combinedOneClickTiles);

        graphics.setStroke(stroke);

        graphics.setColor(plugin.tileColor);
        graphics.draw(combinedToRender);

        graphics.setColor(config.oneClickTilesColor());
        graphics.draw(combinedOneClickTiles);




        return null;
    }
}

/*
 * Copyright (c) 2025, ModestLime <ModestLime@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.modestlime.limeytileman;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.overlay.*;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

import javax.inject.Inject;
import java.awt.*;
import java.text.NumberFormat;
import java.util.Locale;


@Slf4j
public class LimeyTileManTileInfoOverlay extends OverlayPanel {

    final private LimeyTileManConfig config;
    final private LimeyTileManPlugin plugin;

    private final static String availableTilesString = "Available Tiles:";
    private final static String  xpToNextString = "XP Until Next Tile:";
    private final static String  unlockedTilesString = "Tiles Unlocked:";
    private static final NumberFormat numberFormatter = NumberFormat.getInstance(Locale.ENGLISH);


    @Inject
    private LimeyTileManTileInfoOverlay(LimeyTileManConfig config, LimeyTileManPlugin plugin) {
        this.config = config;
        this.plugin = plugin;
        setPosition(OverlayPosition.TOP_LEFT);
        setLayer(OverlayLayer.ABOVE_SCENE);
        setPriority(Overlay.PRIORITY_MED);


    }


    @Override
    public Dimension render(Graphics2D graphics){
        panelComponent.getChildren().clear();

        String availableTilesNum = numberFormatter.format(plugin.availableTiles);
        String xpToNextNum = numberFormatter.format(plugin.xpToNextTile);
        String unlockedTilesNum = numberFormatter.format(plugin.markedTileCount);

        FontMetrics fm = graphics.getFontMetrics();
        int padding = 10 * 2;
        int maxWidth = fm.stringWidth(availableTilesString + " " + availableTilesNum);
        maxWidth = Math.max(maxWidth, fm.stringWidth(xpToNextString + " " + xpToNextNum));
        maxWidth = Math.max(maxWidth, fm.stringWidth(unlockedTilesString + " " + unlockedTilesNum));
        if(plugin.easyDeleteMode){maxWidth = Math.max(maxWidth, fm.stringWidth("Easy Tile Deletion Active!"));}

        maxWidth += padding;
        panelComponent.setPreferredSize(new Dimension(maxWidth, 0));


        Color availableTilesColor = Color.white;
        if(plugin.availableTiles <= 0){
            availableTilesColor = Color.red;
        }

        panelComponent.getChildren().add(LineComponent.builder()
                .left(availableTilesString)
                .right(availableTilesNum)
                .leftColor(availableTilesColor) // Color for the left part of the line
                .rightColor(availableTilesColor) // Color for the right part of the line
                .build());

        if(config.addTilesOnXp()) {
            panelComponent.getChildren().add(LineComponent.builder()
                    .left(xpToNextString)
                    .right(xpToNextNum)
                    .leftColor(Color.WHITE) // Color for the left part of the line
                    .rightColor(Color.WHITE) // Color for the right part of the line
                    .build());
        }

        panelComponent.getChildren().add(LineComponent.builder()
                .left(unlockedTilesString)
                .right(unlockedTilesNum)
                .leftColor(Color.WHITE) // Color for the left part of the line
                .rightColor(Color.WHITE) // Color for the right part of the line
                .build());

        if(plugin.easyDeleteMode){
            panelComponent.getChildren().add(TitleComponent.builder()
                    .text("Easy Tile Deletion Active!")
                    .color(Color.red)
                    .build());
        }

        return super.render(graphics);
    }
}

/*
 * Copyright (c) 2025, ModestLime <ModestLime@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.modestlime.limeytileman;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.worldmap.WorldMap;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;

@Slf4j
public class LimeyTileManWorldMapOverlay extends Overlay {

    final private Client client;
    final private LimeyTileManConfig config;
    final private LimeyTileManPlugin plugin;


    @Inject
    private LimeyTileManWorldMapOverlay(Client client, LimeyTileManConfig config, LimeyTileManPlugin plugin) {
        this.client = client;
        this.config = config;
        this.plugin = plugin;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPriority(PRIORITY_LOW);


    }


    @Override
    public Dimension render(Graphics2D graphics) {

        if(!config.drawWorldMap()){
            return null;
        }

        WorldMap worldMap = client.getWorldMap();
        Widget worldMapWidget = client.getWidget(InterfaceID.Worldmap.MAP_CONTAINER);

        if (worldMap == null || worldMapWidget == null)
        {
            return null;
        }

        float mapTileSize = worldMap.getWorldMapZoom();
        Rectangle worldMapRectangle = worldMapWidget.getBounds();
        graphics.setClip(worldMapRectangle);


        Point mapCenterWorldpoint = worldMap.getWorldMapPosition();
        int heightInTiles = (int)Math.ceil(worldMapRectangle.height / mapTileSize);
        int widthInTiles = (int)Math.ceil(worldMapRectangle.width / mapTileSize);

        //bottom left tile on the world map
        Point bottomLeftWorldPoint = new Point(mapCenterWorldpoint.getX() - (widthInTiles / 2), mapCenterWorldpoint.getY() - (heightInTiles / 2));

        graphics.setColor(config.worldMapColor());

        List<WorldPoint> tilesToRender = new ArrayList<>();
        int plane = client.getTopLevelWorldView().getPlane();
        for(int y = 0; y < heightInTiles; y++){
            for (int x = 0; x < widthInTiles; x++) {
                int hash = plugin.toHash(plugin.toRegion(new WorldPoint(bottomLeftWorldPoint.getX() + (x << 3), bottomLeftWorldPoint.getY() + (y << 3), plane)));
                List<WorldPoint> regionChunk = plugin.markedTiles.get(hash);
                if(regionChunk != null) {
                    tilesToRender.addAll(regionChunk);
                }
            }
        }

        float tileRenderSize = mapTileSize;
        if(config.bigMapTiles()){tileRenderSize = Math.max(tileRenderSize, 4.0f);}



        for(WorldPoint wp : tilesToRender) {

            int diffX = wp.getX() - bottomLeftWorldPoint.getX();
            int diffY = wp.getY() - bottomLeftWorldPoint.getY();

            int screenCordX = (int) ((diffX * mapTileSize) + worldMapRectangle.getX());
            int screenCordY = (int) (worldMapRectangle.getY() + worldMapRectangle.height - (diffY * mapTileSize) - mapTileSize);
            graphics.fillRect(screenCordX, screenCordY, (int) tileRenderSize, (int) tileRenderSize);
        }

        return null;
    }
}

/*
 * Copyright (c) 2025, ModestLime <ModestLime@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.modestlime.limeytileman.events;

public class LeckeyTilesImportFailed {
}

/*
 * Copyright (c) 2025, ModestLime <ModestLime@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.modestlime.limeytileman.events;

public class TilesCopied {



}

/*
 * Copyright (c) 2025, ModestLime <ModestLime@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.modestlime.limeytileman.events;

public class ClipboardImportFailed {
}

/*
 * Copyright (c) 2025, ModestLime <ModestLime@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.modestlime.limeytileman.events;

public class ClipboardImported {
}

/*
 * Copyright (c) 2025, ModestLime <ModestLime@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.modestlime.limeytileman.events;

public class LeckeyTilesImported {
}

package com.modestlime.limeytileman;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;


public class LimeyTileManPluginTest{

    public static void main(String[] args) throws Exception{

        ExternalPluginManager.loadBuiltin(LimeyTileManPlugin.class);
        RuneLite.main(args);
    }


}
