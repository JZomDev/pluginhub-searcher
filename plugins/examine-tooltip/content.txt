/*
 * Copyright (c) 2020, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.examinetooltip.util;

import java.awt.Color;

public class AlphaUtil
{
	/**
	 * Applies the given alpha modifier to the transparency of the given color.
	 * @param color The color to get the alpha modified version of.
	 * @param alphaModifier The alpha modifier.
	 * @return The alpha modified color or the passed Color object if alphaModifier == 1.0.
	 */
	public static Color getAlphaModdedColor(Color color, double alphaModifier)
	{
		if (alphaModifier == 1.0)
		{
			return color;
		}
		else
		{
			int newAlpha = (int) (color.getAlpha() * alphaModifier);
			// Clamp value to 0 - 255
			newAlpha = Math.max(0, Math.min(newAlpha, 255));

			return new Color(
				color.getRed(),
				color.getGreen(),
				color.getBlue(),
				newAlpha);
		}
	}
}

/*
 * Copyright (c) 2023, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.examinetooltip;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.client.ui.overlay.OverlayLayer;

@AllArgsConstructor
@Getter
public enum TooltipOverlayLayer
{
	ALWAYS_ON_TOP(OverlayLayer.ALWAYS_ON_TOP),
	ABOVE_WIDGETS(OverlayLayer.ABOVE_WIDGETS);

	private final OverlayLayer rlLayer;
}

package com.examinetooltip;

import com.examinetooltip.components.AlphaTooltipComponent;
import com.google.common.collect.ImmutableSet;
import com.google.inject.Inject;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Shape;
import java.time.Duration;
import java.time.Instant;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import net.runelite.api.Client;
import net.runelite.api.DecorativeObject;
import net.runelite.api.GameObject;
import net.runelite.api.GroundObject;
import net.runelite.api.ItemLayer;
import net.runelite.api.NPC;
import net.runelite.api.Node;
import net.runelite.api.ObjectComposition;
import net.runelite.api.Perspective;
import net.runelite.api.Tile;
import net.runelite.api.TileItem;
import net.runelite.api.TileObject;
import net.runelite.api.WallObject;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LayoutableRenderableEntity;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;
import org.apache.commons.text.WordUtils;

public class ExamineTooltipOverlay extends Overlay
{
	private final static int SCREEN_PADDING = 5;
	private final static int EXAMINE_PADDING = 10;

	private final static Set<ExamineType> TOOLTIP_ONLY_EXAMINE_TYPES =
		ImmutableSet.of(ExamineType.PRICE_CHECK, ExamineType.PLUGIN_HUB_PATCH_PAYMENT);

	@Inject
	private TooltipManager tooltipManager;

	@Inject
	private ExamineTooltipConfig config;

	@Inject
	private ExamineTooltipPlugin plugin;

	@Inject
	private RuneLiteConfig runeLiteConfig;

	@Inject
	private Client client;

	private final Map<ExamineTextTime, Dimension> dimMap = new HashMap<>();
	private final Map<ExamineTextTime, Rectangle> rectMap = new HashMap<>();

	public ExamineTooltipOverlay()
	{
		setPosition(OverlayPosition.TOOLTIP);
		setPriority(Overlay.PRIORITY_HIGHEST);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		Instant now = Instant.now();
		Duration defaultTimeout = Duration.ofSeconds(config.tooltipTimeout());
		Duration patchTimeout = Duration.ofSeconds(defaultTimeout.getSeconds() + config.patchInspectExtraTime());
		boolean shouldClearDimMap = !dimMap.isEmpty();
		boolean shouldClearRectMap = !rectMap.isEmpty();

		for (ExamineTextTime examine : plugin.getExamines())
		{
			Duration since = Duration.between(examine.getTime(), now);
			Duration timeout;

			if (examine.getType() == ExamineType.PATCH_INSPECT)
			{
				timeout = patchTimeout;
			}
			else
			{
				timeout = defaultTimeout;
			}

			if (since.compareTo(timeout) < 0)
			{
				long timeLeft = (timeout.minus(since)).toMillis();
				int fadeout = config.tooltipFadeout();
				double alpha;
				if (timeLeft < fadeout && fadeout > 0)
				{
					alpha = Math.min(1.0, timeLeft / (double) fadeout);
				}
				else
				{
					alpha = 1.0;
				}

				if (!config.rs3Style() || TOOLTIP_ONLY_EXAMINE_TYPES.contains(examine.getType()))
				{
					renderAsTooltip(examine, alpha);
				}
				else
				{
					renderAsRS3(examine, graphics, alpha);
					shouldClearDimMap = false;
					shouldClearRectMap = false;
				}
			}
		}

		if (shouldClearDimMap || dimMap.size() > 10)
		{
			dimMap.clear();
		}

		if (shouldClearRectMap || rectMap.size() > 10)
		{
			rectMap.clear();
		}

		return null;
	}

	private LayoutableRenderableEntity getRenderableEntity(ExamineTextTime examine, double alphaModifier)
	{
		final AlphaTooltipComponent tooltipComponent = new AlphaTooltipComponent();
		tooltipComponent.setText(getWrappedText(examine.getText()));
		tooltipComponent.setModIcons(client.getModIcons());
		tooltipComponent.setAlphaModifier(alphaModifier);

		if (config.customBackgroundColor() != null)
		{
			tooltipComponent.setBackgroundColor(config.customBackgroundColor());
		}
		else
		{
			tooltipComponent.setBackgroundColor(runeLiteConfig.overlayBackgroundColor());
		}

		return tooltipComponent;
	}

	private void renderAsTooltip(ExamineTextTime examine, double alphaModifier)
	{
		tooltipManager.add(new Tooltip(getRenderableEntity(examine, alphaModifier)));
	}

	private void renderAsRS3(ExamineTextTime examine, Graphics2D graphics, double alphaModifier)
	{
		ExamineType type = examine.getType();
		Rectangle bounds = null;
		WorldView wv = client.getTopLevelWorldView();
		switch (type)
		{
			case NPC:
				final NPC npc = wv.npcs().byIndex(examine.getId());
				if (npc != null)
				{
					Shape shape = npc.getConvexHull();
					if (shape != null)
					{
						bounds = shape.getBounds();
					}
				}
				break;

			case ITEM_INTERFACE:
				bounds = findWidgetBounds(examine.getWidgetId(), examine.getActionParam());
				break;

			case PATCH_INSPECT:
			case ITEM_GROUND:
			case OBJECT:
				// Yes, for these, ActionParam and WidgetID are scene coordinates
				LocalPoint point = LocalPoint.fromScene(examine.getActionParam(), examine.getWidgetId(), wv);
				int id = examine.getId();

				Tile tile = wv.getScene().getTiles()
					[wv.getPlane()][point.getSceneX()][point.getSceneY()];

				if (tile != null)
				{
					Shape shape = getObjectShapeFromTile(tile, type, id);
					if (shape == null)
					{
						Tile bridge = tile.getBridge();
						if (bridge != null)
						{
							shape = getObjectShapeFromTile(bridge, type, id);
						}
					}

					if (shape == null)
					{
						// Fallback to tile
						shape = Perspective.getCanvasTilePoly(client, point);
					}

					if (shape != null)
					{
						bounds = shape.getBounds();
					}
				}

				break;

			default:
				return;
		}

		// Try previously known location
		if (bounds == null && config.previousBoundsFallback())
		{
			bounds = rectMap.get(examine);
		}

		// Give up and render as tooltip if target not found
		if (bounds == null)
		{
			if (config.tooltipFallback())
			{
				renderAsTooltip(examine, alphaModifier);
			}
			return;
		}

		boolean isInterfaceExamine = type == ExamineType.ITEM_INTERFACE;

		int x = bounds.x;
		int y = bounds.height + bounds.y;

		if (!isInterfaceExamine)
		{
			x -= EXAMINE_PADDING;
			y += EXAMINE_PADDING;
		}

		final LayoutableRenderableEntity tooltipComponent = getRenderableEntity(examine, alphaModifier);

		if (isInterfaceExamine || config.clampRS3())
		{
			Dimension dim = dimMap.get(examine);
			if (dim != null)
			{
				int xMin, xMax, yMin, yMax;

				if (isInterfaceExamine)
				{
					xMin = 0;
					xMax = client.getCanvasWidth();
					yMin = 0;
					yMax = client.getCanvasHeight();
				}
				else
				{
					xMin = client.getViewportXOffset();
					xMax = client.getViewportWidth() + xMin;
					yMin = client.getViewportYOffset();
					yMax = client.getViewportHeight() + yMin;
				}

				xMin += SCREEN_PADDING;
				xMax -= SCREEN_PADDING;
				yMin += SCREEN_PADDING;
				yMax -= SCREEN_PADDING;

				if (x < xMin)
				{
					x = xMin;
				}
				else if (x + dim.width > xMax)
				{
					x = xMax - dim.width;
				}

				if (y < yMin)
				{
					y = yMin;
				}
				else if (y + dim.height > yMax)
				{
					y = yMax - dim.height;
				}
			}
		}

		tooltipComponent.setPreferredLocation(new Point(x, y));
		dimMap.put(examine, tooltipComponent.render(graphics));
		rectMap.put(examine, bounds);
	}

	private String getWrappedText(String text)
	{
		if (config.wrapTooltip())
		{
			return WordUtils.wrap(text, config.wrapTooltipColumns(), "</br>", false);
		}
		else
		{
			return text;
		}
	}

	private Rectangle findWidgetBounds(int widgetId, int actionParam)
	{
		Widget widget = client.getWidget(WidgetUtil.componentToInterface(widgetId), WidgetUtil.componentToId(widgetId));

		if (widget == null)
		{
			return null;
		}

		if (actionParam < 0)
		{
			return widget.getBounds();
		}

		try
		{
			Widget widgetItem = widget.getChild(actionParam);
			if (widgetItem != null)
			{
				return widgetItem.getBounds();
			}
		}
		catch (Exception e)
		{
			// Ignore
		}

		return null;
	}

	private Shape getObjectShapeFromTile(Tile tile, ExamineType type, int id)
	{
		if (type == ExamineType.ITEM_GROUND)
		{
			ItemLayer itemLayer = tile.getItemLayer();
			if (itemLayer != null)
			{
				Node current = itemLayer.getTop();
				while (current instanceof TileItem)
				{
					if (((TileItem) current).getId() == id)
					{
						return itemLayer.getCanvasTilePoly();
					}
					current = current.getNext();
				}
			}
		}
		else
		{
			for (GameObject object : tile.getGameObjects())
			{
				if (objectIdEquals(object, id))
				{
					Shape shape = object.getConvexHull();
					if (shape != null)
					{
						return shape;
					}
				}
			}

			GroundObject gObj = tile.getGroundObject();
			if (objectIdEquals(gObj, id))
			{
				Shape shape = gObj.getConvexHull();
				if (shape != null)
				{
					return shape;
				}
			}

			DecorativeObject dObj = tile.getDecorativeObject();
			if (objectIdEquals(dObj, id))
			{
				Shape shape = dObj.getConvexHull();
				if (shape != null)
				{
					return shape;
				}
			}

			WallObject wObj = tile.getWallObject();
			if (objectIdEquals(wObj, id))
			{
				return wObj.getConvexHull();
			}
		}

		return null;
	}

	// From ObjectIndicators plugin
	private boolean objectIdEquals(TileObject tileObject, int id)
	{
		if (tileObject == null)
		{
			return false;
		}

		if (tileObject.getId() == id)
		{
			return true;
		}

		// Menu action EXAMINE_OBJECT sends the transformed object id, not the base id, unlike
		// all of the GAME_OBJECT_OPTION actions, so check the id against the impostor ids
		final ObjectComposition comp = client.getObjectDefinition(tileObject.getId());

		if (comp.getImpostorIds() != null)
		{
			return Arrays.stream(comp.getImpostorIds()).anyMatch(imp -> imp == id);
		}

		return false;
	}
}

/*
 * Copyright (c) 2020, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.examinetooltip;

import java.time.Instant;
import lombok.Data;

@Data
public class ExamineTextTime
{
	private ExamineType type;
	private int id;
	private int widgetId;
	private int actionParam;

	private String text;
	private Instant time;
}

/*
 * Copyright (c) 2020, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.examinetooltip;

public enum ExamineType
{
	ITEM_GROUND,
	ITEM_INTERFACE,
	OBJECT,
	NPC,
	PRICE_CHECK,
	PATCH_INSPECT,
	PLUGIN_HUB_PATCH_PAYMENT
}

/*
 * Copyright (c) 2020, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.examinetooltip;

import com.google.common.collect.EvictingQueue;
import com.google.inject.Provides;
import java.time.Instant;
import java.util.ArrayDeque;
import java.util.Queue;
import java.util.regex.Pattern;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import lombok.Getter;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.Text;

@Slf4j
@PluginDescriptor(
	name = "Examine Tooltip",
	description = "Shows tooltips or RS3 style hover boxes on examine",
	tags = {"examine", "tooltip", "text", "hover", "rs3"}
)
public class ExamineTooltipPlugin extends Plugin
{
	private static final Pattern PATCH_INSPECT_PATTERN = Pattern.compile("^This is an? .+\\. The (?:soil|patch) has");

	private static final Pattern PLUGIN_HUB_PATCH_PAYMENT_1_PATTERN = Pattern.compile(
		"^A farmer will watch over an? .+ patch for"
	);

	private static final Pattern PLUGIN_HUB_PATCH_PAYMENT_2_PATTERN = Pattern.compile(
		"^An? .+ patch can NOT be protected by a farmer"
	);

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private ExamineTooltipOverlay examineTooltipOverlay;

	@Inject
	private ExamineTooltipConfig config;

	@Getter
	private final EvictingQueue<ExamineTextTime> examines = EvictingQueue.create(5);

	private final Queue<ExamineTextTime> pendingExamines = new ArrayDeque<>();

	private ExamineTextTime pendingPatchInspect;

	@Provides
	ExamineTooltipConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(ExamineTooltipConfig.class);
	}

	private void resetPlugin()
	{
		examines.clear();
		pendingExamines.clear();
		pendingPatchInspect = null;
	}

	@Override
	protected void startUp() throws Exception
	{
		examineTooltipOverlay.setLayer(config.overlayLayer().getRlLayer());
		overlayManager.add(examineTooltipOverlay);
		resetPlugin();
	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove(examineTooltipOverlay);
		resetPlugin();
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		resetPlugin();
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event)
	{
		String option = Text.removeTags(event.getMenuOption());

		ExamineType type;
		if (option.equals("Examine"))
		{
			switch (event.getMenuAction())
			{
				case EXAMINE_ITEM_GROUND:
					if (!config.showGroundItemExamines())
					{
						return;
					}
					type = ExamineType.ITEM_GROUND;
					break;
				case CC_OP:
				case CC_OP_LOW_PRIORITY:
					if (!config.showItemExamines())
					{
						return;
					}
					type = ExamineType.ITEM_INTERFACE;
					break;
				case EXAMINE_OBJECT:
					if (!config.showObjectExamines())
					{
						return;
					}
					type = ExamineType.OBJECT;
					break;
				case EXAMINE_NPC:
					if (!config.showNPCExamines())
					{
						return;
					}
					type = ExamineType.NPC;
					break;
				default:
					return;
			}
		}
		else if (option.equals("Inspect"))
		{
			switch (event.getMenuAction())
			{
				case GAME_OBJECT_FIRST_OPTION:
				case GAME_OBJECT_SECOND_OPTION:
				case GAME_OBJECT_THIRD_OPTION:
				case GAME_OBJECT_FOURTH_OPTION:
				case GAME_OBJECT_FIFTH_OPTION:
					type = ExamineType.PATCH_INSPECT;
					break;
				default:
					return;
			}
		}
		else
		{
			return;
		}

		int id = event.getId();
		int actionParam = event.getParam0(); // Action Param
		int wId = event.getParam1(); // Widget ID

		ExamineTextTime examine = new ExamineTextTime();
		examine.setType(type);
		examine.setId(id);
		examine.setWidgetId(wId);
		examine.setActionParam(actionParam);

		if (type == ExamineType.PATCH_INSPECT)
		{
			// Patch inspects require the player to move up to the patch.
			// They have to be treated separately and cannot be queued.
			pendingPatchInspect = examine;
		}
		else
		{
			pendingExamines.offer(examine);
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		String text = Text.removeTags(event.getMessage());
		ExamineType type;
		switch (event.getType())
		{
			case ITEM_EXAMINE:
				if (text.startsWith("Price of"))
				{
					type = ExamineType.PRICE_CHECK;
				}
				else if (checkPluginHubPatchPaymentException(text))
				{
					type = ExamineType.PLUGIN_HUB_PATCH_PAYMENT;
				}
				else
				{
					type = ExamineType.ITEM_INTERFACE;
				}
				break;
			case OBJECT_EXAMINE:
				type = ExamineType.OBJECT;
				break;
			case NPC_EXAMINE:
				type = ExamineType.NPC;
				break;
			case GAMEMESSAGE:
				if (PATCH_INSPECT_PATTERN.matcher(event.getMessage()).lookingAt())
				{
					type = ExamineType.PATCH_INSPECT;
				}
				else if (checkPluginHubPatchPaymentException(text))
				{
					type = ExamineType.PLUGIN_HUB_PATCH_PAYMENT;
				}
				else
				{
					// Interfaces examines are no longer GAMEMESSAGE, so stop processing here
					// https://github.com/runelite/runelite/blob/6c7ef87cb43d70daaa71fc1cba277eaafd86429f/runelite-client/src/main/java/net/runelite/client/plugins/examine/ExaminePlugin.java#L126
					// Previously: type = ExamineType.ITEM_INTERFACE;
					return;
				}
				break;
			default:
				return;
		}

		Instant now = Instant.now();

		if (type == ExamineType.PRICE_CHECK
			|| type == ExamineType.PLUGIN_HUB_PATCH_PAYMENT)
		{
			if ((type == ExamineType.PRICE_CHECK && config.showPriceCheck())
				|| (type == ExamineType.PLUGIN_HUB_PATCH_PAYMENT && config.showPluginHubPatchPayment()))
			{
				ExamineTextTime examine = new ExamineTextTime();
				examine.setType(type);
				examine.setText(text);
				examine.setTime(now);
				examines.add(examine);
			}
			return;
		}

		ExamineTextTime pending;

		if (type == ExamineType.PATCH_INSPECT)
		{
			if (pendingPatchInspect != null && config.showPatchInspects())
			{
				pending = pendingPatchInspect;
				pendingPatchInspect = null;
			}
			else
			{
				return;
			}
		}
		else if (!pendingExamines.isEmpty())
		{
			pending = pendingExamines.poll();
		}
		else
		{
			return;
		}

		// Since we can't tell on the receiving end if an ITEM_EXAMINE is for interface items or ground items, allow an exception here.
		if (pending.getType() == type || (type == ExamineType.ITEM_INTERFACE && pending.getType() == ExamineType.ITEM_GROUND))
		{
			pending.setTime(now);
			pending.setText(text);
			examines.removeIf(x -> x.getText().equals(text));
			examines.add(pending);
		}
		else
		{
			pendingExamines.clear();
		}
	}

	private boolean checkPluginHubPatchPaymentException(String text)
	{
		return PLUGIN_HUB_PATCH_PAYMENT_1_PATTERN.matcher(text).lookingAt()
			|| PLUGIN_HUB_PATCH_PAYMENT_2_PATTERN.matcher(text).lookingAt();
	}

	@Subscribe
	private void onConfigChanged(ConfigChanged event)
	{
		if (event.getGroup().equals(ExamineTooltipConfig.CONFIG_GROUP)
			&& event.getKey().equals(ExamineTooltipConfig.OVERLAY_LAYER_KEY_NAME))
		{
			examineTooltipOverlay.setLayer(config.overlayLayer().getRlLayer());
			overlayManager.resetOverlay(examineTooltipOverlay);
		}
	}
}

/*
 * Copyright (c) 2020, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.examinetooltip;

import java.awt.Color;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;
import net.runelite.client.config.Units;

@ConfigGroup(ExamineTooltipConfig.CONFIG_GROUP)
public interface ExamineTooltipConfig extends Config
{
	String CONFIG_GROUP = "examinetooltip";
	String ITEM_EXAMINES_KEY_NAME = "showItemExamines";
	String OVERLAY_LAYER_KEY_NAME = "overlayLayer";

	@ConfigSection(
		name = "RS3 examine settings",
		description = "Settings relating to using RS3 style examine boxes",
		position = 0
	)
	String rs3ExamineSettings = "rs3ExamineSettings";

	@ConfigSection(
		name = "Examine types settings",
		description = "Settings to select which examine types to process",
		position = 1
	)
	String examineTypesSettings = "examineTypesSettings";

	@ConfigSection(
		name = "Examine box display settings",
		description = "Settings relating to how the examine box is displayed visually",
		position = 2
	)
	String displaySettings = "boxDisplaySettings";

	@ConfigSection(
		name = "Plugin hub compatibility",
		description = "Settings to enable compatibility with other plugin hub plugins",
		position = 3,
		closedByDefault = true
	)
	String pluginHubCompatibility = "pluginHubCompatibility";

	@ConfigItem(
		keyName = "rs3Style",
		name = "RS3 style examine box",
		description = "Show examines as a hovering box under the examined items, else show as a cursor tooltip",
		position = 10,
		section = rs3ExamineSettings
	)
	default boolean rs3Style()
	{
		return true;
	}

	@ConfigItem(
		keyName = "clampRS3",
		name = "Clamp RS3 examine boxes",
		description = "Prevent the RS3 examine boxes from going offscreen",
		position = 11,
		section = rs3ExamineSettings
	)
	default boolean clampRS3()
	{
		return true;
	}

	@ConfigItem(
		keyName = "previousBoundsFallback",
		name = "Enable screen location fallback",
		description = "Show examines in the last known screen location when the examined object cannot be found",
		position = 12,
		section = rs3ExamineSettings
	)
	default boolean previousBoundsFallback()
	{
		return true;
	}

	@ConfigItem(
		keyName = "tooltipFallback",
		name = "Enable tooltip fallback",
		description = "Show examines as tooltips when the examined object cannot be found",
		position = 13,
		section = rs3ExamineSettings
	)
	default boolean tooltipFallback()
	{
		return true;
	}

	@ConfigItem(
		keyName = OVERLAY_LAYER_KEY_NAME,
		name = "Overlay Layer",
		description = "Select on what level the tooltips are shown. Choose 'Above Widgets' to have the tooltips appear below the right-click menu, but might have unintended interaction with other interfaces in the game.",
		position = 14,
		section = rs3ExamineSettings
	)
	default TooltipOverlayLayer overlayLayer()
	{
		return TooltipOverlayLayer.ALWAYS_ON_TOP;
	}

	@ConfigItem(
		keyName = "showPriceCheck",
		name = "Show price check",
		description = "Show the price check text from the Examine Plugin (\"Price of ...\"), always shown as cursor tooltip",
		position = 20,
		section = examineTypesSettings
	)
	default boolean showPriceCheck()
	{
		return false;
	}

	@ConfigItem(
		keyName = ITEM_EXAMINES_KEY_NAME,
		name = "Show interface item examines",
		description = "Show text from examining items in interfaces (e.g. inventory, bank, etc.)",
		position = 21,
		section = examineTypesSettings
	)
	default boolean showItemExamines()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showGroundItemExamines",
		name = "Show ground item examines",
		description = "Show text from examining items on the ground",
		position = 22,
		section = examineTypesSettings
	)
	default boolean showGroundItemExamines()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showObjectExamines",
		name = "Show object examines",
		description = "Show text from examining objects (e.g. scenery)",
		position = 23,
		section = examineTypesSettings
	)
	default boolean showObjectExamines()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showNPCExamines",
		name = "Show NPC examines",
		description = "Show text from examining NPCs",
		position = 24,
		section = examineTypesSettings
	)
	default boolean showNPCExamines()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showPatchInspects",
		name = "Show farming patch inspects",
		description = "Show text from inspecting farming patches",
		position = 25,
		section = examineTypesSettings
	)
	default boolean showPatchInspects()
	{
		return true;
	}

	@ConfigItem(
		keyName = "tooltipTimeout",
		name = "Tooltip timeout",
		description = "How long to show the examine tooltip",
		position = 30,
		section = displaySettings
	)
	@Units(Units.SECONDS)
	@Range(min = 1, max = 10)
	default int tooltipTimeout()
	{
		return 4;
	}

	@ConfigItem(
		keyName = "tooltipFadeout",
		name = "Tooltip fadeout",
		description = "Start fading out the tooltip X milliseconds before it disappears, 0 means no fadeout",
		position = 31,
		section = displaySettings
	)
	@Units(Units.MILLISECONDS)
	@Range(min = 0, max = 3000)
	default int tooltipFadeout()
	{
		return 1000;
	}

	@ConfigItem(
		keyName = "patchInspectExtraTime",
		name = "Patch extra time",
		description = "Add extra time to show the tooltip when inspecting farming patches (the text is typically quite long)",
		position = 32,
		section = displaySettings
	)
	@Units(Units.SECONDS)
	@Range(max = 10)
	default int patchInspectExtraTime()
	{
		return 2;
	}

	@ConfigItem(
		keyName = "wrapTooltip",
		name = "Wrap tooltip",
		description = "Wrap the text in the tooltip if it gets too long",
		position = 33,
		section = displaySettings
	)
	default boolean wrapTooltip()
	{
		return true;
	}

	@ConfigItem(
		keyName = "wrapTooltipColumns",
		name = "Wrap columns",
		description = "How many text columns (or characters) before wrapping the text",
		position = 34,
		section = displaySettings
	)
	@Range(
		min = 20
	)
	default int wrapTooltipColumns()
	{
		return 30;
	}

	@Alpha
	@ConfigItem(
		keyName = "customBackgroundColor",
		name = "Custom background color",
		description = "Use a custom background color instead of the globally configured overlay background default",
		position = 35,
		section = displaySettings
	)
	Color customBackgroundColor();

	@ConfigItem(
		keyName = "showPluginHubPatchPayment",
		name = "PolishToaster's Patch Payment",
		description = "Show text from PolishToaster's Patch Payment plugin, always shown as cursor tooltip",
		position = 50,
		section = pluginHubCompatibility
	)
	default boolean showPluginHubPatchPayment()
	{
		return true;
	}
}

/*
 * Copyright (c) 2016-2017, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.examinetooltip.components;

import com.examinetooltip.util.AlphaUtil;
import com.google.common.annotations.VisibleForTesting;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.util.regex.Pattern;
import lombok.Setter;
import net.runelite.api.IndexedSprite;
import net.runelite.client.ui.overlay.components.BackgroundComponent;
import net.runelite.client.ui.overlay.components.ComponentConstants;
import net.runelite.client.ui.overlay.components.LayoutableRenderableEntity;

@Setter
public class AlphaTooltipComponent implements LayoutableRenderableEntity
{
	private static final Pattern BR = Pattern.compile("</br>");
	private static final int OFFSET = 4;
	private static final int MOD_ICON_WIDTH = 13; // they are generally 13px wide
	private static final Color TRANSPARENT_COLOR = new Color(0, 0, 0, 0);

	private String text;
	private Color backgroundColor = ComponentConstants.STANDARD_BACKGROUND_COLOR;
	private Point position = new Point();
	private IndexedSprite[] modIcons;
	private double alphaModifier = 1.0;

	@Override
	public Dimension render(Graphics2D graphics)
	{
		// Tooltip size
		final FontMetrics metrics = graphics.getFontMetrics();
		final int textDescent = metrics.getDescent();
		final int textHeight = metrics.getHeight();
		int tooltipWidth = 0;
		int tooltipHeight = 0;
		String[] lines = BR.split(text);

		// Calculate tooltip size
		for (String line : lines)
		{
			int textWidth = calculateTextWidth(metrics, line);

			if (textWidth > tooltipWidth)
			{
				tooltipWidth = textWidth;
			}

			tooltipHeight += textHeight;
		}

		// Tooltip position
		int x = position.x;
		int y = position.y;

		// Render tooltip - background
		final Rectangle tooltipBackground = new Rectangle(x, y,
			tooltipWidth + OFFSET * 2, tooltipHeight + OFFSET * 2);
		final BackgroundComponent backgroundComponent = new BackgroundComponent();
		backgroundComponent.setBackgroundColor(AlphaUtil.getAlphaModdedColor(backgroundColor, alphaModifier));
		backgroundComponent.setRectangle(tooltipBackground);
		backgroundComponent.render(graphics);
		graphics.setColor(Color.WHITE);

		// Render tooltip - text - line by line
		int textX = x + OFFSET;
		int textY = y + OFFSET;
		int lineX;
		final Color defaultColor = AlphaUtil.getAlphaModdedColor(Color.WHITE, alphaModifier);
		Color nextColor = defaultColor;
		for (int i = 0; i < lines.length; i++)
		{
			lineX = textX;
			final String line = lines[i];
			char[] chars = line.toCharArray();

			int begin = 0;
			boolean inTag = false;
			for (int j = 0; j < chars.length; j++)
			{
				if (chars[j] == '<')
				{
					AlphaTextComponent textComponent = new AlphaTextComponent();
					textComponent.setColor(nextColor);
					textComponent.setAlphaModifier(alphaModifier);
					String text = line.substring(begin, j);
					textComponent.setText(text);
					textComponent.setPosition(new Point(lineX, textY + (i + 1) * textHeight - textDescent));
					textComponent.render(graphics);

					lineX += metrics.stringWidth(text);

					begin = j;
					inTag = true;
				}
				else if (chars[j] == '>' && inTag)
				{
					String subLine = line.substring(begin + 1, j);

					if (subLine.startsWith("col="))
					{
						String argument = subLine.substring(4);
						nextColor = AlphaUtil.getAlphaModdedColor(Color.decode("#" + argument), alphaModifier);
					}
					else if (subLine.equals("/col"))
					{
						nextColor = defaultColor;
					}
					else if (subLine.startsWith("img="))
					{
						if (modIcons != null)
						{
							String argument = subLine.substring(4);
							int iconId = Integer.parseInt(argument);
							IndexedSprite modIcon = modIcons[iconId];
							renderModIcon(graphics, lineX, textY + i * textHeight - textDescent, modIcon);
							lineX += modIcon.getWidth();
						}
					}
					else
					{
						AlphaTextComponent textComponent = new AlphaTextComponent();
						textComponent.setColor(nextColor);
						textComponent.setAlphaModifier(alphaModifier);
						String text = line.substring(begin, j + 1);
						textComponent.setText(text);
						textComponent.setPosition(new Point(lineX, textY + (i + 1) * textHeight - textDescent));
						textComponent.render(graphics);

						lineX += metrics.stringWidth(text);
					}

					begin = j + 1;
					inTag = false;
				}
			}

			// Draw trailing text (after last tag)
			final AlphaTextComponent textComponent = new AlphaTextComponent();
			textComponent.setColor(nextColor);
			textComponent.setAlphaModifier(alphaModifier);
			textComponent.setText(line.substring(begin));
			textComponent.setPosition(new Point(lineX, textY + (i + 1) * textHeight - textDescent));
			textComponent.render(graphics);
		}

		return new Dimension(tooltipWidth + OFFSET * 2, tooltipHeight + OFFSET * 2);
	}

	@VisibleForTesting
	static int calculateTextWidth(FontMetrics metrics, String line)
	{
		char[] chars = line.toCharArray();
		int textWidth = 0;

		int begin = 0;
		boolean inTag = false;
		for (int j = 0; j < chars.length; j++)
		{
			if (chars[j] == '<')
			{
				textWidth += metrics.stringWidth(line.substring(begin, j));

				begin = j;
				inTag = true;
			}
			else if (chars[j] == '>' && inTag)
			{
				String subLine = line.substring(begin + 1, j);

				if (subLine.startsWith("img="))
				{
					textWidth += MOD_ICON_WIDTH;
				}
				else if (!subLine.startsWith("col=") && !subLine.startsWith("/col"))
				{
					textWidth += metrics.stringWidth(line.substring(begin, j + 1));
				}

				begin = j + 1;
				inTag = false;
			}
		}

		// Include trailing text (after last tag)
		textWidth += metrics.stringWidth(line.substring(begin));

		return textWidth;
	}

	private void renderModIcon(Graphics2D graphics, int x, int y, IndexedSprite modIcon)
	{
		int sourceOffset = 0;

		for (int y2 = 0; y2 < modIcon.getHeight(); y2++)
		{
			for (int x2 = 0; x2 < modIcon.getWidth(); x2++)
			{
				int index = modIcon.getPixels()[sourceOffset++] & 0xff;

				if (index != 0)
				{
					graphics.setColor(new Color(modIcon.getPalette()[index]));
					graphics.drawLine(x + x2, y + y2, x + x2, y + y2);
				}
			}
		}
	}

	@Override
	public Rectangle getBounds()
	{
		return null;
	}

	@Override
	public void setPreferredLocation(Point position)
	{
		this.position = position;
	}

	@Override
	public void setPreferredSize(Dimension dimension)
	{
	}
}

/*
 * Copyright (c) 2017, Tomas Slusny <slusnucky@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.examinetooltip.components;

import com.examinetooltip.util.AlphaUtil;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.util.regex.Pattern;
import lombok.Setter;
import net.runelite.client.ui.overlay.RenderableEntity;
import net.runelite.client.util.Text;

@Setter
public class AlphaTextComponent implements RenderableEntity
{
	private static final String COL_TAG_REGEX = "(<col=([0-9a-fA-F]){2,6}>)";
	private static final Pattern COL_TAG_PATTERN_W_LOOKAHEAD = Pattern.compile("(?=" + COL_TAG_REGEX + ")");

	private String text;
	private Point position = new Point();
	private Color color = Color.WHITE;
	private boolean outline;
	private double alphaModifier = 1.0;

	@Override
	public Dimension render(Graphics2D graphics)
	{
		final FontMetrics fontMetrics = graphics.getFontMetrics();
		final Color shadowColor = AlphaUtil.getAlphaModdedColor(Color.BLACK, alphaModifier);

		if (COL_TAG_PATTERN_W_LOOKAHEAD.matcher(text).find())
		{
			final String[] parts = COL_TAG_PATTERN_W_LOOKAHEAD.split(text);
			int x = position.x;

			for (String textSplitOnCol : parts)
			{
				final String textWithoutCol = Text.removeTags(textSplitOnCol);
				final String colColor = textSplitOnCol.substring(textSplitOnCol.indexOf("=") + 1, textSplitOnCol.indexOf(">"));

				graphics.setColor(shadowColor);

				if (outline)
				{
					graphics.drawString(textWithoutCol, x, position.y + 1);
					graphics.drawString(textWithoutCol, x, position.y - 1);
					graphics.drawString(textWithoutCol, x + 1, position.y);
					graphics.drawString(textWithoutCol, x - 1, position.y);
				}
				else
				{
					// shadow
					graphics.drawString(textWithoutCol, x + 1, position.y + 1);
				}

				// actual text
				graphics.setColor(AlphaUtil.getAlphaModdedColor(Color.decode("#" + colColor), alphaModifier));
				graphics.drawString(textWithoutCol, x, position.y);

				x += fontMetrics.stringWidth(textWithoutCol);
			}
		}
		else
		{
			graphics.setColor(shadowColor);

			if (outline)
			{
				graphics.drawString(text, position.x, position.y + 1);
				graphics.drawString(text, position.x, position.y - 1);
				graphics.drawString(text, position.x + 1, position.y);
				graphics.drawString(text, position.x - 1, position.y);
			}
			else
			{
				// shadow
				graphics.drawString(text, position.x + 1, position.y + 1);
			}

			// actual text
			graphics.setColor(AlphaUtil.getAlphaModdedColor(color, alphaModifier));
			graphics.drawString(text, position.x, position.y);
		}

		return new Dimension(fontMetrics.stringWidth(text), fontMetrics.getHeight());
	}
}

/*
 * Copyright (c) 2020, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.examinetooltip;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamineTooltipPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(ExamineTooltipPlugin.class);
		RuneLite.main(args);
	}
}
