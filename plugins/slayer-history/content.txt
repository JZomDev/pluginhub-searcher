/*
 * Copyright (c) 2017, Tyler <https://github.com/tylerthardy>
 * Copyright (c) 2018, Shaun Dreclin <shaundreclin@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.slayerhistory;

import java.util.Map;
import net.runelite.api.gameval.ItemID;

class TaskIcon
{
	private static final Map<String, Integer> tasks = Map.<String, Integer>ofEntries(
		Map.entry("aberrant spectres", ItemID.SLAYERGUIDE_ABERRANTSPECTER),
		Map.entry("abyssal demons", ItemID.SLAYERGUIDE_ABYSSALDEMON),
		Map.entry("the abyssal sire", ItemID.ABYSSALSIRE_PET),
		Map.entry("the alchemical hydra", ItemID.HYDRAPET),
		Map.entry("ankou", ItemID.ANKOU_HEAD),
		Map.entry("araxxor", ItemID.ARAXXORPET),
		Map.entry("araxytes", ItemID.POG_SLAYER_DUMMY_ARAXYTES),
		Map.entry("aviansies", ItemID.ARCEUUS_CORPSE_AVIANSIE_INITIAL),
		Map.entry("bandits", ItemID.PICKPOCKET_GUIDE_DESERT_BANDIT),
		Map.entry("banshees", ItemID.SLAYERGUIDE_BANSHEE),
		Map.entry("barrows brothers", ItemID.BARROWS_KARIL_HEAD),
		Map.entry("basilisks", ItemID.SLAYERGUIDE_BASILISK),
		Map.entry("bats", ItemID.RAIDS_BAT2_COOKED),
		Map.entry("bears", ItemID.ARCEUUS_CORPSE_BEAR_INITIAL),
		Map.entry("birds", ItemID.FEATHER),
		Map.entry("black demons", ItemID.BLACK_DEMON_MASK),
		Map.entry("black dragons", ItemID.DRAGONMASK_BLACK),
		Map.entry("black knights", ItemID.BLACK_FULL_HELM),
		Map.entry("bloodveld", ItemID.SLAYERGUIDE_BLOODVELD),
		Map.entry("blue dragons", ItemID.DRAGONMASK_BLUE),
		Map.entry("brine rats", ItemID.OLAF2_BRINE_RAT_INV),
		Map.entry("callisto", ItemID.CALLISTO_PET),
		Map.entry("catablepon", ItemID.SOS_HALF_SKULL2),
		Map.entry("cave bugs", ItemID.SWAMP_CAVE_BUG),
		Map.entry("cave crawlers", ItemID.SLAYERGUIDE_CAVECRAWLER),
		Map.entry("cave horrors", ItemID.SLAYERGUIDE_HARMLESS_CAVE_HORROR),
		Map.entry("cave kraken", ItemID.CERT_EADGAR_FADE_TO_BLACK_INV),
		Map.entry("cave slimes", ItemID.SWAMP_CAVE_SLIME),
		Map.entry("cerberus", ItemID.HELL_PET),
		Map.entry("chaos druids", ItemID.ELDERCHAOS_HOOD),
		Map.entry("the chaos elemental", ItemID.CHAOSELEPET),
		Map.entry("the chaos fanatic", ItemID.STAFF_OF_ZAROS),
		Map.entry("cockatrice", ItemID.SLAYERGUIDE_COCKATRICE),
		Map.entry("cows", ItemID.COW_MASK),
		Map.entry("crabs", ItemID.HUNDRED_PIRATE_CRAB_SHELL_GAUNTLET),
		Map.entry("crawling hands", ItemID.SLAYERGUIDE_CRAWLINGHAND),
		Map.entry("crazy archaeologists", ItemID.FEDORA),
		Map.entry("crocodiles", ItemID.GREEN_SALAMANDER),
		Map.entry("custodian stalkers", ItemID.SLAYERGUIDE_CUSTODIAN_STALKER_MATURE),
		Map.entry("dagannoth", ItemID.POH_DAGGANOTH),
		Map.entry("dagannoth kings", ItemID.PRIMEPET),
		Map.entry("dark beasts", ItemID.SLAYERGUIDE_DARK_BEAST),
		Map.entry("dark warriors", ItemID.BLACK_MED_HELM),
		Map.entry("dogs", ItemID.POH_GUARD_DOG),
		Map.entry("drakes", ItemID.SLAYERGUIDE_DRAKE),
		Map.entry("duke sucellus", ItemID.DUKESUCELLUSPET),
		Map.entry("dust devils", ItemID.SLAYERGUIDE_DUSTDEVIL),
		Map.entry("dwarves", ItemID.EMPTY_OBJECT),  // we will load our own image
		Map.entry("earth warriors", ItemID.BRONZE_FULL_HELM_TRIM),
		Map.entry("elves", ItemID.PICKPOCKET_GUIDE_WOODELF),
		Map.entry("ents", ItemID.POH_TREE_2),
		Map.entry("fever spiders", ItemID.SLAYERGUIDE_FEVER_SPIDER),
		Map.entry("fire giants", ItemID.RTBRANDAPET),
		Map.entry("fleshcrawlers", ItemID.ARCEUUS_CORPSE_SCORPION_INITIAL),
		Map.entry("fossil island wyverns", ItemID.SLAYERGUIDE_FOSSILWYVERN),
		Map.entry("gargoyles", ItemID.SLAYERGUIDE_GARGOYLE),
		Map.entry("general graardor", ItemID.BANDOSPET),
		Map.entry("ghosts", ItemID.AMULET_OF_GHOSTSPEAK),
		Map.entry("ghouls", ItemID.TRICK_OR_TREAT_HEAD),
		Map.entry("the giant mole", ItemID.MOLEPET),
		Map.entry("goblins", ItemID.ARCEUUS_CORPSE_GOBLIN_INITIAL),
		Map.entry("greater demons", ItemID.GREATER_DEMON_MASK),
		Map.entry("green dragons", ItemID.DRAGONMASK_GREEN),
		Map.entry("the grotesque guardians", ItemID.DUSKPET),
		Map.entry("harpie bug swarms", ItemID.SLAYERGUIDE_SWARM),
		Map.entry("hellhounds", ItemID.POH_HELLHOUND),
		Map.entry("hill giants", ItemID.ARCEUUS_CORPSE_GIANT_INITIAL),
		Map.entry("hobgoblins", ItemID.POH_HOBGOBLIN),
		Map.entry("hydras", ItemID.SLAYERGUIDE_HYDRA),
		Map.entry("icefiends", ItemID.FD_ICEDIAMOND),
		Map.entry("ice giants", ItemID.RTELDRICPET),
		Map.entry("ice warriors", ItemID.MITHRIL_FULL_HELM_TRIM),
		Map.entry("infernal mages", ItemID.SLAYERGUIDE_INFERNALMAGE),
		Map.entry("tztok-jad", ItemID.JAD_PET),
		Map.entry("jellies", ItemID.SLAYERGUIDE_JELLY),
		Map.entry("jungle horrors", ItemID.ARCEUUS_CORPSE_HORROR_INITIAL),
		Map.entry("kalphites", ItemID.POH_KALPHITE_SOLDIER),
		Map.entry("the kalphite queen", ItemID.KQPET_WALKING),
		Map.entry("killerwatts", ItemID.SLAYERGUIDE_KILLERWATT),
		Map.entry("the king black dragon", ItemID.KBDPET),
		Map.entry("the cave kraken boss", ItemID.KRAKENPET),
		Map.entry("kree'arra", ItemID.ARMADYLPET),
		Map.entry("k'ril tsutsaroth", ItemID.ZAMORAKPET),
		Map.entry("kurask", ItemID.SLAYERGUIDE_KURASK),
		Map.entry("lava dragons", ItemID.LAVA_SCALE),
		Map.entry("lesser demons", ItemID.LESSER_DEMON_MASK),
		Map.entry("lesser nagua", ItemID.SLAYERGUIDE_LESSER_NAGUA),
		Map.entry("lizardmen", ItemID.LIZARDMAN_FANG),
		Map.entry("lizards", ItemID.SLAYERGUIDE_LIZARD),
		Map.entry("magic axes", ItemID.IRON_BATTLEAXE),
		Map.entry("mammoths", ItemID.BARBASSAULT_ATT_HORN_01),
		Map.entry("metal dragons", ItemID.POH_STEEL_DRAGON),
		Map.entry("minotaurs", ItemID.ARCEUUS_CORPSE_MINOTAUR_INITIAL),
		Map.entry("mogres", ItemID.SLAYERGUIDE_MOGRE),
		Map.entry("molanisks", ItemID.SLAYERGUIDE_MOLANISK),
		Map.entry("monkeys", ItemID.ARCEUUS_CORPSE_MONKEY_INITIAL),
		Map.entry("moss giants", ItemID.MOSSY_KEY),
		Map.entry("mutated zygomites", ItemID.SLAYER_ZYGOMITE_OBJECT),
		Map.entry("nechryael", ItemID.SLAYERGUIDE_NECHRYAEL),
		Map.entry("ogres", ItemID.ARCEUUS_CORPSE_OGRE_INITIAL),
		Map.entry("otherworldly beings", ItemID.SECRET_GHOST_HAT),
		Map.entry("the phantom muspah", ItemID.MUSPAHPET),
		Map.entry("pirates", ItemID.BREW_RED_PIRATE_HAT),
		Map.entry("pyrefiends", ItemID.SLAYERGUIDE_PYRFIEND),
		Map.entry("rats", ItemID.RATS_TAIL),
		Map.entry("red dragons", ItemID.POH_DRAGON),
		Map.entry("revenants", ItemID.WILD_CAVE_BRACELET_CHARGED),
		Map.entry("rockslugs", ItemID.SLAYERGUIDE_ROCKSLUG),
		Map.entry("rogues", ItemID.ROGUESDEN_HELM),
		Map.entry("sarachnis", ItemID.SARACHNISPET),
		Map.entry("scabarites", ItemID.NTK_SCARAB_GOLD),
		Map.entry("scorpia", ItemID.SCORPIA_PET),
		Map.entry("scorpions", ItemID.ARCEUUS_CORPSE_SCORPION_INITIAL),
		Map.entry("sea snakes", ItemID.CERT_FISHING_SPOT_ICON_DUMMY),
		Map.entry("shades", ItemID.BLACKROBETOP),
		Map.entry("shadow warriors", ItemID.BLACK_FULL_HELM),
		Map.entry("skeletal wyverns", ItemID.SLAYERGUIDE_SKELETALWYVERN),
		Map.entry("skeletons", ItemID.POH_SKELETON_GUARD),
		Map.entry("smoke devils", ItemID.CERT_GUIDE_ICON_DUMMY),
		Map.entry("sourhogs", ItemID.PORCINE_SOURHOG_TROPHY),
		Map.entry("spiders", ItemID.POH_SPIDER),
		Map.entry("spiritual creatures", ItemID.DRAGON_BOOTS),
		Map.entry("suqahs", ItemID.SUQKA_TOOTH),
		Map.entry("terror dogs", ItemID.SLAYERGUIDE_TERRORDOG),
		Map.entry("the leviathan", ItemID.LEVIATHANPET),
		Map.entry("the thermonuclear smoke devil", ItemID.SMOKEPET),
		Map.entry("the whisperer", ItemID.WHISPERERPET),
		Map.entry("trolls", ItemID.POH_TROLL),
		Map.entry("turoth", ItemID.SLAYERGUIDE_TUROTH),
		Map.entry("tzhaar", ItemID.ARCEUUS_CORPSE_TZHAAR_INITIAL),
		Map.entry("vampyres", ItemID.SLAYERGUIDE_VAMPYRE),
		Map.entry("vardorvis", ItemID.VARDORVISPET),
		Map.entry("venenatis", ItemID.VENENATIS_PET),
		Map.entry("vet'ion", ItemID.VETION_PET),
		Map.entry("vorkath", ItemID.VORKATHPET),
		Map.entry("wall beasts", ItemID.SWAMP_WALLBEAST),
		Map.entry("warped creatures", ItemID.POG_SLAYER_DUMMY_WARPED_TERRORBIRD),
		Map.entry("waterfiends", ItemID.WATER_ORB),
		Map.entry("werewolves", ItemID.DAGGER_WOLFBANE),
		Map.entry("wolves", ItemID.GREY_WOLF_FUR),
		Map.entry("wyrms", ItemID.SLAYERGUIDE_WYRM),
		Map.entry("commander zilyana", ItemID.SARADOMINPET),
		Map.entry("zombies", ItemID.TRICK_OR_TREAT_HEAD),
		Map.entry("tzkal-zuk", ItemID.INFERNOPET_ZUK),
		Map.entry("zulrah", ItemID.SNAKEPET),
		Map.entry("aquanites", ItemID.SLAYERGUIDE_AQUANITE),
		Map.entry("gryphons", ItemID.GRYPHON_FEATHER_5),
		Map.entry("the shellbane gryphon", ItemID.SLAYERGUIDE_GRYPHON),
		Map.entry("frost dragons", ItemID.FROST_DRAGON_BONES)
	);

	static int getItemSpriteId(String taskName)
	{
		return tasks.getOrDefault(taskName.toLowerCase(), ItemID.SLAYER_GEM);
	}
}
package com.slayerhistory;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup(SlayerHistoryConfig.CONFIG_GROUP)
public interface SlayerHistoryConfig extends Config
{
	String CONFIG_GROUP = "slayerhistory";

	@ConfigItem(
		keyName = "logTimeFormat",
		name = "Time Format",
		description = "Display completion times in 12 or 24 hour time format."
	)
	default TimeFormat timeFormatMode()
	{
		return TimeFormat.TIME_24H;
	}

	@ConfigItem(
		keyName = "showSkippedTasks",
		name = "Show skipped tasks",
		description = "Show/hide skipped tasks on the side panel."
	)
	default boolean showSkippedTasks()
	{
		return true;
	}
}

package com.slayerhistory;

import com.google.inject.Inject;
import com.slayerhistory.localstorage.SlayerHistoryRecord;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.image.BufferedImage;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import net.runelite.api.Constants;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

public class SlayerHistoryRecordBox extends JPanel
{
	private static final String DWARF_IMAGE_PATH = "null.png";
	private static final String DWARF_TASK_NAME = "dwarves";

	private final SlayerHistoryPanel panel;
	private final SlayerHistoryRecord record;
	private final ItemManager itemManager;
	private final ClientThread clientThread;

	private final JLabel taskNameLabel = new JLabel();
	private final JLabel taskMasterLabel = new JLabel();
	private final JLabel taskCompletionTimeLabel = new JLabel();
	private final JLabel taskIconLabel = new JLabel();
	private final JLabel taskStreakLabel = new JLabel();

	@Inject
	SlayerHistoryRecordBox(SlayerHistoryPanel panel, SlayerHistoryRecord record, ClientThread clientThread, ItemManager itemManager)
	{
		this.itemManager = itemManager;
		this.clientThread = clientThread;
		this.panel = panel;
		this.record = record;
		buildSlayerHistoryPanel();
	}

	private void buildSlayerHistoryPanel()
	{
		this.setBorder(new EmptyBorder(6, 0, 0, 0)); //spacing between cards
		this.setBackground(ColorScheme.DARK_GRAY_COLOR);
		this.setLayout(new BorderLayout());

		// image on the left of the card
		JPanel imageBox = new JPanel();
		imageBox.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		imageBox.setLayout(new BorderLayout());
		imageBox.setBorder(new EmptyBorder(0, 8, 0, 0));
		imageBox.add(taskIconLabel);

		// words on the right of the card
		JPanel taskInfo = new JPanel();
		taskInfo.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		taskInfo.setLayout(new BoxLayout(taskInfo, BoxLayout.Y_AXIS));
		taskInfo.setBorder(new EmptyBorder(5, 0, 5, 0));

		JPanel taskMasterDateStreakPanel = new JPanel();
		taskMasterDateStreakPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		taskMasterDateStreakPanel.setLayout(new BoxLayout(taskMasterDateStreakPanel, BoxLayout.Y_AXIS));

		JPanel dateStreakPanel = new JPanel();
		dateStreakPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		dateStreakPanel.setLayout(new BoxLayout(dateStreakPanel, BoxLayout.X_AXIS));
		dateStreakPanel.setBorder(new EmptyBorder(0, 0, 0, 7));
		taskCompletionTimeLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
		taskStreakLabel.setAlignmentX(Component.RIGHT_ALIGNMENT);
		dateStreakPanel.add(taskCompletionTimeLabel);
		dateStreakPanel.add(Box.createHorizontalGlue());
		dateStreakPanel.add(taskStreakLabel);

		taskMasterLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
		dateStreakPanel.setAlignmentX(Component.LEFT_ALIGNMENT);

		taskMasterDateStreakPanel.add(taskMasterLabel);
		taskMasterDateStreakPanel.add(dateStreakPanel);

		taskInfo.add(taskNameLabel);
		taskInfo.add(taskMasterDateStreakPanel);

		this.add(imageBox, BorderLayout.WEST);
		this.add(taskInfo);

		taskNameLabel.setFont(FontManager.getRunescapeBoldFont());
		taskMasterLabel.setFont(FontManager.getRunescapeSmallFont());
		taskCompletionTimeLabel.setFont(FontManager.getRunescapeSmallFont());
		taskStreakLabel.setFont(FontManager.getRunescapeSmallFont());

		taskMasterLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		taskCompletionTimeLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);

		taskIconLabel.setMinimumSize(new Dimension(Constants.ITEM_SPRITE_WIDTH, Constants.ITEM_SPRITE_HEIGHT));

		update();
	}

	void update()
	{
		if (record.skipped)
		{
			taskNameLabel.setForeground(new Color(183, 38, 21));
		}
		taskNameLabel.setText(record.taskName);
		taskMasterLabel.setText(record.taskMaster);
		taskCompletionTimeLabel.setText(panel.shortTimeFormat.format(record.taskCompletionTime));
		if (record.taskStreak > -1)
		{
			taskStreakLabel.setText(String.format("#%,d", record.taskStreak));
		}

		clientThread.invokeLater(() ->
		{
			BufferedImage taskImage = itemManager.getImage(TaskIcon.getItemSpriteId(record.taskName), record.taskQuantity, true);

			// custom image just for dwarves. combining with empty item image bc that handles the quantity superscript
			if (record.taskName.equalsIgnoreCase(DWARF_TASK_NAME))
			{
				BufferedImage dwarfImage = ImageUtil.loadImageResource(getClass(), DWARF_IMAGE_PATH);
				BufferedImage combined = new BufferedImage(taskImage.getWidth(), taskImage.getHeight(), BufferedImage.TYPE_INT_ARGB);

				int dwarfOffsetX = 2;
				int dwarfOffsetY = (taskImage.getHeight() - dwarfImage.getHeight()) / 2;

				Graphics g = combined.createGraphics();
				g.drawImage(dwarfImage, dwarfOffsetX, dwarfOffsetY, null);
				g.drawImage(taskImage, 0, 0, null);
				g.dispose();

				taskIconLabel.setIcon(new ImageIcon(combined));
			}
			else if (record.skipped)
			{
				BufferedImage nothingImage = itemManager.getImage(ItemID.BANK_FILLER, record.taskQuantity, true);
				taskIconLabel.setIcon(new ImageIcon(nothingImage));
			}
			else
			{
				taskIconLabel.setIcon(new ImageIcon(taskImage));
			}
		});
	}
}
package com.slayerhistory.localstorage;

import com.google.inject.Inject;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import static net.runelite.client.RuneLite.RUNELITE_DIR;
import net.runelite.http.api.RuneLiteAPI;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class SlayerHistoryLocalStorage
{
	private static final File SLAYER_HISTORY_FOLDER = new File(RUNELITE_DIR, "slayer-history");
	private static final String SLAYER_HISTORY_FILE = "tasks.log";
	private static final Logger log = LoggerFactory.getLogger(SlayerHistoryLocalStorage.class);
	private File logFile;
	private String accountFolderName;

	@Inject
	public SlayerHistoryLocalStorage()
	{
		SLAYER_HISTORY_FOLDER.mkdir();
	}

	public boolean setAccountFolderName(final String folderName)
	{
		if (folderName.equalsIgnoreCase(this.accountFolderName))
		{
			return false;
		}

		logFile = new File(SLAYER_HISTORY_FOLDER, folderName);
		logFile.mkdir();
		this.accountFolderName = folderName;
		return true;
	}

	private File getFile()
	{
		return new File(logFile, SLAYER_HISTORY_FILE);
	}

	public synchronized ArrayList<SlayerHistoryRecord> loadSlayerHistoryRecords()
	{
		final File file = getFile();
		final ArrayList<SlayerHistoryRecord> data = new ArrayList<>();

		try (final BufferedReader br = new BufferedReader(new FileReader(file)))
		{
			String line;
			while ((line = br.readLine()) != null)
			{
				if (line.length() > 0)
				{
					SlayerHistoryRecord r = RuneLiteAPI.GSON.fromJson(line, SlayerHistoryRecord.class);
					if (!line.contains("taskStreak"))
					{
						data.add(new SlayerHistoryRecord(
							r.getTaskCompletionTime(),
							r.getTaskMaster(),
							r.getTaskName(),
							r.getTaskQuantity(),
							r.isSkipped(),
							-1
						));
					}
					else
					{
						data.add(r);
					}
				}
			}
		}
		catch (FileNotFoundException e)
		{
			log.debug("File not found: {}", file.getName());
		}
		catch (IOException e)
		{
			log.warn("IOException for file {}: {}", file.getName(), e.getMessage());
		}

		return data;
	}

	public synchronized void addSlayerHistoryRecord(SlayerHistoryRecord record)
	{
		final File slayerHistoryFile = getFile();
		final String dataAsString = RuneLiteAPI.GSON.toJson(record);
		try
		{
			final BufferedWriter file = new BufferedWriter(new FileWriter(String.valueOf(slayerHistoryFile), true));
			file.append(dataAsString);
			file.newLine();
			file.close();
			log.debug("Added new task: {}", dataAsString);
		}
		catch (IOException e)
		{
			log.warn("Error writing slayer task data to file {}: {}", slayerHistoryFile.getName(), e.getMessage());
		}
	}
}
package com.slayerhistory.localstorage;

import lombok.Data;

@Data
public class SlayerHistoryRecord
{
	public final long taskCompletionTime;
	public final String taskMaster;
	public final String taskName;
	public final int taskQuantity;
	public final boolean skipped;
	public final int taskStreak;
}

package com.slayerhistory;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum TimeFormat
{
	TIME_12H("12-hour"),
	TIME_24H("24-hour");

	private final String name;

	@Override
	public String toString()
	{
		return this.name;
	}
}
/*
 * Copyright (c) 2017, Tyler <https://github.com/tylerthardy>
 * Copyright (c) 2018, Shaun Dreclin <shaundreclin@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.slayerhistory;

import com.google.inject.Inject;
import com.google.inject.Provides;
import com.slayerhistory.localstorage.SlayerHistoryLocalStorage;
import com.slayerhistory.localstorage.SlayerHistoryRecord;
import java.awt.image.BufferedImage;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Map;
import javax.swing.SwingUtilities;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.DBTableID;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneScapeProfileType;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;

@Slf4j
@PluginDescriptor(name = "Slayer History")
public class SlayerHistoryPlugin extends Plugin
{
	// https://oldschool.runescape.wiki/w/RuneScape:Varbit/4067
	private static final Map<Integer, String> SLAYER_MASTERS = Map.of(
		1, "Turael/Aya",
		2, "Mazchna/Achtryn",
		3, "Vannaka",
		4, "Chaeldar",
		5, "Duradel/Kuradal",
		6, "Nieve/Steve",
		7, "Krystilia",
		8, "Konar quo Maten",
		9, "Spria"
	);

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private ItemManager itemManager;

	@Inject
	private SlayerHistoryConfig config;

	@Inject
	private SlayerHistoryLocalStorage localStorage;

	private SlayerHistoryPanel panel;
	private NavigationButton navButton;

	private int oldStreak;
	private int oldWildyStreak;
	private boolean loggingIn;

	@Override
	protected void startUp() throws Exception
	{
		loggingIn = true;

		panel = new SlayerHistoryPanel(this, config, clientThread, itemManager);

		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "slayer_history_icon.png");

		navButton = NavigationButton.builder()
			.tooltip("Slayer History")
			.icon(icon)
			.panel(panel)
			.priority(7)
			.build();

		clientToolbar.addNavigation(navButton);

		if (client.getAccountHash() != -1)
		{
			loadPreviousTasks();
		}
	}

	@Override
	protected void shutDown() throws Exception
	{
		clientToolbar.removeNavigation(navButton);
	}

	@Provides
	SlayerHistoryConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(SlayerHistoryConfig.class);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged)
	{
		if (!configChanged.getGroup().equals(SlayerHistoryConfig.CONFIG_GROUP))
		{
			return;
		}

		panel.updateConfig();
		if (configChanged.getKey().equals("logTimeFormat"))
		{
			SwingUtilities.invokeLater(panel::updateAllRecordBoxes);
		}
		else if (configChanged.getKey().equals("showSkippedTasks"))
		{
			loadPreviousTasks();
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		switch (gameStateChanged.getGameState())
		{
			case HOPPING:
			case LOGGING_IN:
			case CONNECTION_LOST:
				loggingIn = true;
				break;
			case LOGGED_IN:
				updateFolderName();
		}
	}

	@Subscribe
	public void onGameTick(GameTick gameTick)
	{
		loggingIn = false;
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged varbitChanged)
	{
		int varpId = varbitChanged.getVarpId();
		if (!loggingIn && varpId == VarPlayerID.SLAYER_COUNT)
		{
			clientThread.invokeLater(() -> {
				int newStreak = client.getVarbitValue(VarbitID.SLAYER_TASKS_COMPLETED);
				int newWildyStreak = client.getVarbitValue(VarbitID.SLAYER_WILDERNESS_TASKS_COMPLETED);

				if (varbitChanged.getValue() == 0)
				{
					addTask(newStreak == oldStreak && newWildyStreak == oldWildyStreak);
				}

				oldStreak = newStreak;
				oldWildyStreak = newWildyStreak;
			});
		}
	}

	private void updateFolderName()
	{
		String folderName = String.valueOf(client.getAccountHash());
		RuneScapeProfileType profileType = RuneScapeProfileType.getCurrent(client);
		if (profileType != RuneScapeProfileType.STANDARD)
		{
			folderName += "-" + Text.titleCase(profileType);
		}

		if (localStorage.setAccountFolderName(folderName))
		{
			loadPreviousTasks();
		}
	}

	private synchronized void loadPreviousTasks()
	{
		panel.clearAllTasksView();
		ArrayList<SlayerHistoryRecord> taskHistory = localStorage.loadSlayerHistoryRecords();
		if (!taskHistory.isEmpty())
		{
			taskHistory.forEach(panel::addRecord);
		}
		else
		{
			panel.clearAllTasksView();
		}
	}

	private String getTaskName(int taskId)
	{
		int taskDBRow;
		if (taskId == 98 /* Bosses, from [proc,helper_slayer_current_assignment] */)
		{
			var bossRows = client.getDBRowsByValue(
				DBTableID.SlayerTaskSublist.ID,
				DBTableID.SlayerTaskSublist.COL_TASK_SUBTABLE_ID,
				0,
				client.getVarbitValue(VarbitID.SLAYER_TARGET_BOSSID));

			if (bossRows.isEmpty())
			{
				return null;
			}
			taskDBRow = (Integer) client.getDBTableField(bossRows.get(0), DBTableID.SlayerTaskSublist.COL_TASK, 0)[0];
		}
		else
		{
			var taskRows = client.getDBRowsByValue(DBTableID.SlayerTask.ID, DBTableID.SlayerTask.COL_ID, 0, taskId);
			if (taskRows.isEmpty())
			{
				return null;
			}
			taskDBRow = taskRows.get(0);
		}

		return (String) client.getDBTableField(taskDBRow, DBTableID.SlayerTask.COL_NAME_UPPERCASE, 0)[0];
	}

	private void addTask(boolean skipped)
	{
		int taskId = client.getVarpValue(VarPlayerID.SLAYER_TARGET);

		String taskName = getTaskName(taskId);
		String taskMaster = SLAYER_MASTERS.get(client.getVarbitValue(VarbitID.SLAYER_MASTER));
		int taskInitialQuantity = client.getVarpValue(VarPlayerID.SLAYER_COUNT_ORIGINAL);

		if (taskName == null)
		{
			log.warn("Unable to find task name");
			return;
		}
		log.debug("{}, {}, {}", taskName, taskMaster, taskInitialQuantity);

		int streak;
		if (taskMaster.equals("Krystilia"))
		{
			streak = client.getVarbitValue(VarbitID.SLAYER_WILDERNESS_TASKS_COMPLETED);
		}
		else
		{
			streak = client.getVarbitValue(VarbitID.SLAYER_TASKS_COMPLETED);
		}

		SlayerHistoryRecord record = new SlayerHistoryRecord(
			Instant.now().toEpochMilli(),
			taskMaster,
			taskName,
			taskInitialQuantity,
			skipped,
			streak
		);
		localStorage.addSlayerHistoryRecord(record);
		panel.addRecord(record);
	}
}
package com.slayerhistory;

import com.google.inject.Inject;
import com.slayerhistory.localstorage.SlayerHistoryRecord;
import java.awt.BorderLayout;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;

@Slf4j
public class SlayerHistoryPanel extends PluginPanel
{
	private final ArrayList<SlayerHistoryRecordBox> recordBoxes = new ArrayList<SlayerHistoryRecordBox>();
	private final JPanel recordBoxPanel = new JPanel();
	private final JLabel tasksLoggedLabel = new JLabel("Tasks logged: 0");
	private final SlayerHistoryConfig config;
	public SimpleDateFormat shortTimeFormat = new SimpleDateFormat("MMM dd, h:mm a");
	SlayerHistoryPlugin plugin;
	private final ClientThread clientThread;
	private final ItemManager itemManager;

	@Inject
	SlayerHistoryPanel(SlayerHistoryPlugin plugin, SlayerHistoryConfig config, ClientThread clientThread, ItemManager itemManager)
	{
		super();
		this.plugin = plugin;
		this.config = config;
		this.clientThread = clientThread;
		this.itemManager = itemManager;
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setBorder(new EmptyBorder(6, 6, 6, 6));
		setBackground(ColorScheme.DARK_GRAY_COLOR);

		JPanel titlePanel = new JPanel(new BorderLayout());
		titlePanel.setBorder(new EmptyBorder(5, 8, 5, 8));
		titlePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JLabel titleLabel = new JLabel("Slayer History");

		tasksLoggedLabel.setBorder(new EmptyBorder(2, 0, 0, 0));
		tasksLoggedLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		tasksLoggedLabel.setFont(FontManager.getRunescapeSmallFont());

		titlePanel.add(titleLabel, BorderLayout.WEST);
		titlePanel.add(tasksLoggedLabel, BorderLayout.EAST);

		recordBoxPanel.setLayout(new BoxLayout(recordBoxPanel, BoxLayout.Y_AXIS));

		add(titlePanel);
		add(recordBoxPanel);

		updateConfig();
	}

	public void clearAllTasksView()
	{
		recordBoxPanel.removeAll();
		recordBoxes.clear();
		recordBoxPanel.repaint();
		updateTasksLoggedLabel();
	}

	public void addRecord(SlayerHistoryRecord record)
	{
		if (config.showSkippedTasks() || !record.isSkipped())
		{
			SwingUtilities.invokeLater(() -> {
				SlayerHistoryRecordBox recordBox = new SlayerHistoryRecordBox(this, record, clientThread, itemManager);
				recordBoxPanel.add(recordBox, 0);
				recordBoxes.add(recordBox);
				updateTasksLoggedLabel();
			});
		}
	}

	public void updateConfig()
	{
		if (config.timeFormatMode() == TimeFormat.TIME_12H)
		{
			shortTimeFormat = new SimpleDateFormat("MMM dd, h:mm a");
		}
		else
		{
			shortTimeFormat = new SimpleDateFormat("MMM dd, HH:mm");
		}
	}

	public void updateAllRecordBoxes()
	{
		recordBoxes.forEach(SlayerHistoryRecordBox::update);
		updateTasksLoggedLabel();
	}

	public void updateTasksLoggedLabel()
	{
		tasksLoggedLabel.setText(String.format("Tasks logged: %,d", recordBoxes.size()));
	}
}
package com.slayerhistory;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class SlayerHistoryPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(SlayerHistoryPlugin.class);
		RuneLite.main(args);
	}
}
