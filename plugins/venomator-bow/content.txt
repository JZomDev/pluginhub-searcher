package com.raysfanatic02.venomatorbow;

import net.runelite.client.config.*;

import java.awt.Color;

@ConfigGroup("venomatorbow")
public interface VenomatorBowConfig extends Config
{
    @ConfigItem(
        keyName = "onlyOnTask",
        name = "Only on Slayer task",
        description = "Only show text on NPCs that match your current Slayer task."
    )
    default boolean onlyOnTask() { return true; }

    @ConfigSection(
        name = "Tagged",
        description = "Tagged state options",
        position = 0
    )
    String taggedSection = "taggedSection";

    @ConfigItem(
        keyName = "showTagged",
        name = "Show tagged",
        description = "Show tagged state text when the NPC is interacted with and receives a hitsplat.",
        section = taggedSection,
        position = 0
    )
    default boolean showTagged() { return true; }

    @ConfigItem(
        keyName = "taggedText",
        name = "Tagged text",
        description = "Text to show for tagged state (e.g. T or Tagged).",
        section = taggedSection,
        position = 1
    )
    default String taggedText() { return "T"; }

    @ConfigItem(
        keyName = "taggedColor",
        name = "Tagged color",
        description = "Color for tagged text.",
        section = taggedSection,
        position = 2
    )
    default Color taggedColor() { return new Color(120, 200, 255); } // light blue

    @ConfigSection(
        name = "Poisoned",
        description = "Poisoned state options",
        position = 1
    )
    String poisonedSection = "poisonedSection";

    @ConfigItem(
        keyName = "showPoisoned",
        name = "Show poisoned",
        description = "Show poisoned state text when poison hitsplat is observed.",
        section = poisonedSection,
        position = 0
    )
    default boolean showPoisoned() { return true; }

    @ConfigItem(
        keyName = "poisonedText",
        name = "Poisoned text",
        description = "Text to show for poisoned state (e.g. P).",
        section = poisonedSection,
        position = 1
    )
    default String poisonedText() { return "P"; }

    @ConfigItem(
        keyName = "poisonedColor",
        name = "Poisoned color",
        description = "Color for poisoned text.",
        section = poisonedSection,
        position = 2
    )
    default Color poisonedColor() { return new Color(0, 200, 0); }

    @ConfigSection(
        name = "Venomed",
        description = "Venomed state options",
        position = 2
    )
    String venomedSection = "venomedSection";

    @ConfigItem(
        keyName = "showVenomed",
        name = "Show venomed",
        description = "Show venomed state text when venom hitsplat is observed.",
        section = venomedSection,
        position = 0
    )
    default boolean showVenomed() { return true; }

    @ConfigItem(
        keyName = "venomedText",
        name = "Venomed text",
        description = "Text to show for venomed state (e.g. V).",
        section = venomedSection,
        position = 1
    )
    default String venomedText() { return "V"; }

    @ConfigItem(
        keyName = "venomedColor",
        name = "Venomed color",
        description = "Color for venomed text.",
        section = venomedSection,
        position = 2
    )
    default Color venomedColor() { return new Color(0, 255, 0); } // bright green

    @ConfigSection(
        name = "Overlay",
        description = "Overlay positioning options",
        position = 3
    )
    String overlaySection = "overlaySection";

    @Range(min = -60, max = 60)
    @ConfigItem(
        keyName = "yOffset",
        name = "Text Y offset",
        description = "Moves the text up/down relative to the NPC.",
        section = overlaySection,
        position = 0
    )
    default int yOffset() { return 0; }

    @ConfigItem(
        keyName = "shadow",
        name = "Text shadow",
        description = "Draw a simple black shadow behind text for visibility.",
        section = overlaySection,
        position = 1
    )
    default boolean shadow() { return true; }
}

package com.raysfanatic02.venomatorbow;

import com.google.inject.Inject;
import net.runelite.api.NPC;
import net.runelite.api.Point;
import net.runelite.client.ui.overlay.*;

import java.awt.*;
import java.util.Map;

public class VenomatorBowOverlay extends Overlay
{
    private final VenomatorBowPlugin plugin;
    private final VenomatorBowConfig config;

    @Inject
    public VenomatorBowOverlay(VenomatorBowPlugin plugin, VenomatorBowConfig config)
    {
        this.plugin = plugin;
        this.config = config;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        for (Map.Entry<Integer, VenomatorBowPlugin.State> e : plugin.getStates().entrySet())
        {
            NPC npc = plugin.getNpcByIndex(e.getKey());
            if (npc == null)
            {
                continue;
            }

            RenderSpec spec = getRenderSpec(e.getValue());
            if (spec == null || spec.text.isBlank())
            {
                continue;
            }

            Point p = npc.getCanvasTextLocation(graphics, spec.text, config.yOffset());
            if (p == null)
            {
                continue;
            }

            if (config.shadow())
            {
                // simple 1px shadow for contrast
                renderText(graphics, new Point(p.getX() + 1, p.getY() + 1), spec.text, Color.BLACK);
            }

            renderText(graphics, p, spec.text, spec.color);
        }

        return null;
    }

    private void renderText(Graphics2D g, Point p, String text, Color color)
    {
        g.setColor(color);
        g.drawString(text, p.getX(), p.getY());
    }

    private RenderSpec getRenderSpec(VenomatorBowPlugin.State s)
    {
        // Priority: VENOMED > POISONED > TAGGED
        switch (s)
        {
            case VENOMED:
                return config.showVenomed() ? new RenderSpec(config.venomedText(), config.venomedColor()) : null;
            case POISONED:
                return config.showPoisoned() ? new RenderSpec(config.poisonedText(), config.poisonedColor()) : null;
            case TAGGED:
                return config.showTagged() ? new RenderSpec(config.taggedText(), config.taggedColor()) : null;
            default:
                return null;
        }
    }

    private static class RenderSpec
    {
        final String text;
        final Color color;

        RenderSpec(String text, Color color)
        {
            this.text = text == null ? "" : text;
            this.color = color == null ? Color.WHITE : color;
        }
    }
}

package com.raysfanatic02.venomatorbow;

import com.google.inject.Provides;
import lombok.Getter;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.*;
import net.runelite.client.ui.overlay.OverlayManager;

import javax.inject.Inject;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

@PluginDescriptor(
    name = "Venomator Bow",
    description = "Shows configurable text over Slayer task NPCs to indicate tagged, poisoned, or venomed targets",
    tags = {"slayer", "venom", "poison", "overlay", "venator"}
)
public class VenomatorBowPlugin extends Plugin
{
    enum State { NONE, TAGGED, POISONED, VENOMED }

    @Inject private Client client;
    @Inject private OverlayManager overlayManager;
    @Inject private VenomatorBowOverlay overlay;
    @Inject private VenomatorBowConfig config;

    @Getter
    private final Map<Integer, State> states = new HashMap<>();

    // Slayer task detection via VarPlayer
    private String slayerTaskCreatureName = null;
    private int slayerTaskRemaining = 0;

    @Provides
    VenomatorBowConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(VenomatorBowConfig.class);
    }

    @Override
    protected void startUp()
    {
        overlayManager.add(overlay);
        states.clear();
        refreshTaskFromVars();
    }

    @Override
    protected void shutDown()
    {
        overlayManager.remove(overlay);
        states.clear();
        slayerTaskCreatureName = null;
        slayerTaskRemaining = 0;
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged e)
    {
        if (e.getGameState() == GameState.LOGGED_IN)
        {
            refreshTaskFromVars();
        }
        if (e.getGameState() == GameState.LOGIN_SCREEN || e.getGameState() == GameState.HOPPING)
        {
            states.clear();
        }
    }

    @Subscribe
    public void onVarbitChanged(VarbitChanged e)
    {
        // Fires often; refresh is cheap
        refreshTaskFromVars();
    }

    private void refreshTaskFromVars()
    {
        int creatureId = client.getVarpValue(VarPlayer.SLAYER_TASK_CREATURE);
        slayerTaskRemaining = client.getVarpValue(VarPlayer.SLAYER_TASK_SIZE);

        slayerTaskCreatureName = null;

        if (slayerTaskRemaining > 0 && creatureId > 0)
        {
            NPCComposition comp = client.getNpcDefinition(creatureId);
            if (comp != null && comp.getName() != null)
            {
                slayerTaskCreatureName = sanitize(comp.getName());
            }
        }
    }

    private String sanitize(String s)
    {
        return s.toLowerCase(Locale.ROOT).trim();
    }

    private boolean isOnTask(NPC npc)
    {
        if (!config.onlyOnTask())
        {
            return true;
        }

        if (slayerTaskCreatureName == null || slayerTaskCreatureName.isBlank())
        {
            return false;
        }

        String npcName = npc.getName();
        if (npcName == null)
        {
            return false;
        }

        // Loose match: handles pluralization/variants reasonably well
        String n = sanitize(npcName);
        return n.contains(slayerTaskCreatureName) || slayerTaskCreatureName.contains(n);
    }

    @Subscribe
    public void onNpcSpawned(NpcSpawned e)
    {
        NPC npc = e.getNpc();
        if (isOnTask(npc))
        {
            states.put(npc.getIndex(), State.NONE);
        }
    }

    @Subscribe
    public void onNpcDespawned(NpcDespawned e)
    {
        states.remove(e.getNpc().getIndex());
    }

    @Subscribe
    public void onHitsplatApplied(HitsplatApplied e)
    {
        if (!(e.getActor() instanceof NPC))
        {
            return;
        }

        NPC npc = (NPC) e.getActor();
        int idx = npc.getIndex();

        // Ensure we only consider task NPCs (and allow “late tracking” for already-spawned NPCs)
        if (!states.containsKey(idx))
        {
            if (!isOnTask(npc))
            {
                return;
            }
            states.put(idx, State.NONE);
        }

        final int hitsplatType = e.getHitsplat().getHitsplatType();

        // Confirmed state transitions
        if (hitsplatType == HitsplatID.VENOM)
        {
            states.put(idx, State.VENOMED);
            return;
        }

        if (hitsplatType == HitsplatID.POISON)
        {
            if (states.get(idx) != State.VENOMED)
            {
                states.put(idx, State.POISONED);
            }
            return;
        }

        // Tagged heuristic:
        // If you are interacting with the NPC and it receives any hitsplat,
        // mark it tagged unless it's already poison/venom.
        Player me = client.getLocalPlayer();
        if (me != null && me.getInteracting() == npc)
        {
            State cur = states.get(idx);
            if (cur == State.NONE)
            {
                states.put(idx, State.TAGGED);
            }
        }
    }

    NPC getNpcByIndex(int index)
    {
        for (NPC npc : client.getNpcs())
        {
            if (npc != null && npc.getIndex() == index)
            {
                return npc;
            }
        }
        return null;
    }
}

