package com.newgameplus;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.Range;

@ConfigGroup("newgameplus")
public interface NewGamePlusConfig extends Config {

    @ConfigItem(
            keyName = "inventoryOpacity",
            name = "Inventory dim opacity",
            description = "Opacity (0-255) used to dim locked items in the inventory"
    )
    @Range(min = 0, max = 255)
    default int inventoryOpacity() {
        return 165; // ~50%
    }

    @ConfigItem(
            keyName = "bankOpacity",
            name = "Bank dim opacity",
            description = "Opacity (0-255) used to dim locked items in the bank"
    )
    @Range(min = 0, max = 255)
    default int bankOpacity() {
        return 165; // ~50%
    }


    @ConfigItem(
            keyName = "showUnlockPopup",
            name = "Show unlock popup",
            description = "Show a popup with the item icon and name when an item is unlocked"
    )
    default boolean showUnlockPopup() {
        return true;
    }

    @ConfigItem(
            keyName = "playUnlockSound",
            name = "Play unlock sound",
            description = "Play a custom sound located at /.runelite/new-game-plus/new-game-plus-unlock.wav when an item is unlocked."
    )
    default boolean playUnlockSound() {
        return true;
    }

    @ConfigItem(
            keyName = "unlockSoundVolume",
            name = "Unlock sound volume",
            description = "Volume for the unlock sound (0-100)"
    )
    @Range(min = 0, max = 100)
    default int unlockSoundVolume() {
        return 100;
    }

    @ConfigItem(
            keyName = "screenshotOnUnlock",
            name = "Screenshot on unlock",
            description = "Take a screenshot when a new item is unlocked (saved to the RuneLite screenshots folder)."
    )
    default boolean screenshotOnUnlock() {
        return false;
    }
}

package com.newgameplus;

import net.runelite.client.ui.overlay.WidgetItemOverlay;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.ComponentID;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.Image;
import java.awt.image.BufferedImage;

import net.runelite.client.game.ItemManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;

@Singleton
class NewGamePlusOverlay extends WidgetItemOverlay {
    private final NewGamePlusPlugin plugin;
    private final ItemManager itemManager;
    private final NewGamePlusConfig config;

    @Inject
    private NewGamePlusOverlay(ItemManager itemManager, NewGamePlusPlugin plugin, NewGamePlusConfig config) {
        this.itemManager = itemManager;
        this.plugin = plugin;
        this.config = config;
        // Apply to inventory and bank
        showOnInventory();
        showOnBank();
    }

    @Override
    public void renderItemOverlay(Graphics2D graphics, int itemId, WidgetItem item) {
        if (!plugin.isLocked(itemId)) {
            return;
        }

        Rectangle bounds = item.getCanvasBounds();
        if (bounds == null) {
            return;
        }

        // Draw a tinted image that matches the item icon shape
        final int qty = item.getQuantity();
        final Image icon = itemManager.getImage(itemId, qty, false);
        if (icon == null) {
            return;
        }

        // Choose opacity based on context: bank items vs inventory (including side inventory)
        int groupId = 0;
        Widget w = item.getWidget();
        if (w != null) {
            // Extract interface group id from component id (top 16 bits)
            groupId = w.getId() >>> 16;
        }
        final boolean isBankItems = groupId == (ComponentID.BANK_ITEM_CONTAINER >>> 16); // bank main items container
        final int alpha = isBankItems ? config.bankOpacity() : config.inventoryOpacity();
        final Color dimColor = ColorUtil.colorWithAlpha(Color.BLACK, alpha);
        final BufferedImage iconBi = ImageUtil.bufferedImageFromImage(icon);
        final BufferedImage dimmed = ImageUtil.fillImage(iconBi, dimColor);
        graphics.drawImage(dimmed, (int) bounds.getX(), (int) bounds.getY(), null);
    }
}

package com.newgameplus;

import net.runelite.api.Client;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.PluginPanel;

import javax.swing.BorderFactory;
import javax.swing.DefaultListModel;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ListSelectionModel;
import javax.swing.SwingUtilities;
import javax.swing.ListCellRenderer;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;

class NewGamePlusPanel extends PluginPanel {
    private final NewGamePlusPlugin plugin;
    private final ItemManager itemManager;
    private final Client client;

    private final DefaultListModel<UnlockEntry> model = new DefaultListModel<>();
    private final JList<UnlockEntry> list = new JList<>(model);

    // No direct text input; we open a chatbox search in-game for adding items

    NewGamePlusPanel(NewGamePlusPlugin plugin, ItemManager itemManager, Client client) {
        super(false); // no scrolling container, we add our own
        this.plugin = plugin;
        this.itemManager = itemManager;
        this.client = client;

        setLayout(new BorderLayout());
        setPreferredSize(new Dimension(300, 0));

        // Header
        JLabel header = new JLabel("Unlocked Items");
        header.setBorder(BorderFactory.createEmptyBorder(8, 8, 8, 8));
        add(header, BorderLayout.NORTH);

        // Center list with custom renderer
        list.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
        list.setCellRenderer(new UnlockRenderer());
        JScrollPane scroll = new JScrollPane(list);
        add(scroll, BorderLayout.CENTER);

        // Footer controls
        JPanel controls = new JPanel(new GridBagLayout());
        controls.setBorder(BorderFactory.createEmptyBorder(8, 8, 8, 8));
        GridBagConstraints gc = new GridBagConstraints();
        gc.insets = new Insets(2, 2, 2, 2);

        JButton addBtn = new JButton("Add");
        gc.gridy = 0;
        gc.gridx = 0;
        gc.gridwidth = 1;
        gc.weightx = 1;
        gc.fill = GridBagConstraints.HORIZONTAL;
        controls.add(addBtn, gc);

        JButton removeBtn = new JButton("Remove Selected");
        gc.gridy = 1;
        gc.gridx = 0;
        gc.gridwidth = 1;
        gc.weightx = 1;
        gc.fill = GridBagConstraints.HORIZONTAL;
        controls.add(removeBtn, gc);

        JButton clearBtn = new JButton("Delete All Unlocks");
        gc.gridy = 2;
        gc.gridx = 0;
        gc.gridwidth = 1;
        gc.weightx = 1;
        gc.fill = GridBagConstraints.HORIZONTAL;
        controls.add(clearBtn, gc);

        add(controls, BorderLayout.SOUTH);

        // Actions
        addBtn.addActionListener(e -> onAdd());
        removeBtn.addActionListener(e -> onRemove());
        clearBtn.addActionListener(e -> onClearAll());

        refreshFromPlugin();
    }

    void refreshFromPlugin() {
        // Ask plugin to build entries on the client thread, then callback into setEntries()
        plugin.refreshPanelAsync(this);
    }

    // Called by plugin on the Swing thread to update entries
    void setEntries(Map<Integer, String> idToName) {
        if (!SwingUtilities.isEventDispatchThread()) {
            SwingUtilities.invokeLater(() -> setEntries(idToName));
            return;
        }
        model.clear();
        List<UnlockEntry> entries = new ArrayList<>();
        for (Map.Entry<Integer, String> e : idToName.entrySet()) {
            entries.add(new UnlockEntry(e.getKey(), e.getValue()));
        }
        entries.sort(Comparator.comparing(a -> a.name.toLowerCase()));
        for (UnlockEntry e : entries) {
            model.addElement(e);
        }
    }

    private void onAdd() {
        // Open in-game chatbox search input; selection will add and refresh
        plugin.openAddItemSearch();
    }

    private void onRemove() {
        List<UnlockEntry> selected = list.getSelectedValuesList();
        if (selected == null || selected.isEmpty()) {
            return;
        }
        for (UnlockEntry e : selected) {
            plugin.removeUnlock(e.id);
        }
        refreshFromPlugin();
    }

    private void onClearAll() {
        int res = JOptionPane.showConfirmDialog(this,
                "Are you sure you want to delete all unlocks?",
                "Confirm Delete All",
                JOptionPane.OK_CANCEL_OPTION,
                JOptionPane.WARNING_MESSAGE);
        if (res == JOptionPane.OK_OPTION) {
            plugin.clearAllUnlocks();
        }
    }

    private final class UnlockRenderer implements ListCellRenderer<UnlockEntry> {
        @Override
        public Component getListCellRendererComponent(JList<? extends UnlockEntry> jList, UnlockEntry value, int index, boolean isSelected, boolean cellHasFocus) {
            JPanel row = new JPanel(new FlowLayout(FlowLayout.LEFT, 8, 4));
            row.setOpaque(true);
            if (isSelected) {
                row.setBackground(jList.getSelectionBackground());
                row.setForeground(jList.getSelectionForeground());
            } else {
                row.setBackground(jList.getBackground());
                row.setForeground(jList.getForeground());
            }

            BufferedImage icon = itemManager.getImage(value.id, 1, false);
            JLabel iconLabel = new JLabel(icon != null ? new javax.swing.ImageIcon(icon) : null);
            JLabel textLabel = new JLabel(value.name);
            row.add(iconLabel);
            row.add(textLabel);
            return row;
        }
    }

    private static final class UnlockEntry {
        final int id;
        final String name;

        UnlockEntry(int id, String name) {
            this.id = id;
            this.name = name;
        }

        @Override
        public String toString() {
            return name;
        }
    }
}

package com.newgameplus;

import com.google.inject.Provides;

import javax.inject.Inject;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.MenuEntry;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.ClientUI;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.Text;
import net.runelite.client.events.ConfigChanged;
import net.runelite.api.events.ScriptCallbackEvent;

import java.awt.Color;
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;

import net.runelite.client.game.chatbox.ChatboxItemSearch;
import net.runelite.client.events.ServerNpcLoot;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.http.api.loottracker.LootRecordType;
import net.runelite.client.audio.AudioPlayer;
import net.runelite.client.ui.DrawManager;
import net.runelite.client.util.ImageCapture;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import net.runelite.client.RuneLite;

@Slf4j
@PluginDescriptor(
        name = "New Game Plus"
)
public class NewGamePlusPlugin extends Plugin {
    @Inject
    private Client client;

    @Inject
    private NewGamePlusConfig config;

    @Inject
    private ClientThread clientThread;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private NewGamePlusOverlay overlay;

    @Inject
    private NewGamePlusUnlockOverlay unlockOverlay;

    @Inject
    private ConfigManager configManager;

    @Inject
    private ClientToolbar clientToolbar;

    @Inject
    private ClientUI clientUI;

    @Inject
    private ItemManager itemManager;

    @Inject
    private ChatboxItemSearch chatboxItemSearch;

    @Inject
    private DrawManager drawManager;

    @Inject
    private ImageCapture imageCapture;

    private NavigationButton navButton;
    private NewGamePlusPanel panel;

    // Background executor for playing custom unlock sounds
    private ExecutorService audioExecutor;

    // Background executor for saving screenshots (scheduled to allow delayed capture)
    private ScheduledExecutorService screenshotExecutor;

    // In-memory set of unlocked item IDs. Initially empty -> everything is locked.
    private final Set<Integer> unlockedItemIds = new HashSet<>();

    // Snapshot of inventory counts used to detect newly added items (treated as picked up -> unlock)
    private final Map<Integer, Integer> inventoryCounts = new HashMap<>();

    // Guard to avoid treating the initial inventory load as "picked up"
    private boolean inventorySnapshotInitialized = false;

    // Compiled patterns representing unlocked name families (variants)
    private final List<Pattern> unlockedNamePatterns = new ArrayList<>();

    // Compiled patterns for default-locked name families loaded from resources
    private final List<Pattern> defaultLockedPatterns = new ArrayList<>();

    @Override
    protected void startUp() throws Exception {
        // Load persisted unlocks
        loadUnlockedFromConfig();
        rebuildUnlockedNames();
        loadDefaultLockedNames();
        inventorySnapshotInitialized = false;
        // Defer inventory snapshot to when we are LOGGED_IN, on the client thread
        clientThread.invoke(() -> {
            if (client.getGameState() == GameState.LOGGED_IN) {
                initializeInventorySnapshot();
            }
        });

        // Register overlay to dim inventory items
        overlayManager.add(overlay);
        // Register unlock popup overlay
        overlayManager.add(unlockOverlay);

        // Prepare audio executor and ensure custom sound directory exists
        audioExecutor = Executors.newSingleThreadExecutor(r -> {
            Thread t = new Thread(r, "ngp-audio");
            t.setDaemon(true);
            return t;
        });
        try {
            Path dir = RuneLite.RUNELITE_DIR.toPath().resolve("new-game-plus");
            Files.createDirectories(dir);
        } catch (IOException ignored) {
        }

        // Prepare screenshot executor (scheduled) for delayed capture
        screenshotExecutor = Executors.newSingleThreadScheduledExecutor(r -> {
            Thread t = new Thread(r, "ngp-screenshot");
            t.setDaemon(true);
            return t;
        });

        // Create and add sidebar panel
        panel = new NewGamePlusPanel(this, itemManager, client);
        BufferedImage icon = null;
        try {
            icon = ImageUtil.loadImageResource(NewGamePlusPlugin.class, "/newgameplus-icon.png");
            if (icon != null && (icon.getWidth() != 16 || icon.getHeight() != 16)) {
                icon = ImageUtil.resizeImage(icon, 16, 16);
            }
        } catch (Exception e) {
            // ignore and fallback below
        }
        if (icon == null) {
            icon = new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB);
        }
        navButton = NavigationButton.builder()
                .tooltip("New Game Plus")
                .icon(icon)
                .priority(7)
                .panel(panel)
                .build();
        clientToolbar.addNavigation(navButton);
        // Ensure the panel reflects any unlocks just loaded from config
        if (panel != null) {
            panel.refreshFromPlugin();
        }
    }

    @Override
    protected void shutDown() throws Exception {
        unlockedItemIds.clear();
        inventoryCounts.clear();
        inventorySnapshotInitialized = false;
        overlayManager.remove(overlay);
        if (unlockOverlay != null) {
            overlayManager.remove(unlockOverlay);
            unlockOverlay.clear();
        }
        if (audioExecutor != null) {
            audioExecutor.shutdownNow();
            audioExecutor = null;
        }
        if (screenshotExecutor != null) {
            screenshotExecutor.shutdownNow();
            screenshotExecutor = null;
        }
        if (navButton != null) {
            clientToolbar.removeNavigation(navButton);
            navButton = null;
            panel = null;
        }
    }

    @Subscribe
    public void onServerNpcLoot(final ServerNpcLoot event) {


        final java.util.Collection<net.runelite.client.game.ItemStack> items = event.getItems();
        if (items == null || items.isEmpty()) {
            return;
        }

        boolean changed = false;
        for (net.runelite.client.game.ItemStack is : items) {
            if (is == null) {
                continue;
            }
            int id = is.getId();
            if (id <= 0) {
                continue;
            }
            // Only auto-unlock if the item is currently locked
            if (isLocked(id) && unlockedItemIds.add(id)) {
                changed = true;
                // If the item was locked, unlock it and notify the user with selected configuration notifications
                try {
                    String name = itemManager.getItemComposition(id).getName();
                    postGameMessage(ColorUtil.prependColorTag("NG+: Unlocked " + name + "!", new Color(197, 27, 138)));
                    showUnlockPopup(id);
                    playUnlockSound();
                    takeUnlockScreenshot(name);
                } catch (Exception ignored) {
                }
            }
        }

        if (changed) {
            saveUnlockedToConfig();
            rebuildUnlockedNames();
            if (panel != null) {
                panel.refreshFromPlugin();
            }
        }
    }

    @Subscribe
    public void onLootReceived(final LootReceived event) {


        final LootRecordType type = event.getType();
        // Only handle chest-style/non-NPC rewards; NPC kills handled by onServerNpcLoot
        if (type != LootRecordType.EVENT) {
            return;
        }

        final java.util.Collection<net.runelite.client.game.ItemStack> items = event.getItems();
        if (items == null || items.isEmpty()) {
            return;
        }

        boolean changed = false;
        for (net.runelite.client.game.ItemStack is : items) {
            if (is == null) {
                continue;
            }
            final int id = is.getId();
            if (id <= 0) {
                continue;
            }
            if (isLocked(id) && unlockedItemIds.add(id)) {
                changed = true;
                try {
                    String name = itemManager.getItemComposition(id).getName();
                    postGameMessage(ColorUtil.prependColorTag("NG+: Unlocked " + name + "!", new Color(197, 27, 138)));
                    showUnlockPopup(id);
                    playUnlockSound();
                    takeUnlockScreenshot(name);
                } catch (Exception ignored) {
                }
            }
        }

        if (changed) {
            saveUnlockedToConfig();
            rebuildUnlockedNames();
            if (panel != null) {
                panel.refreshFromPlugin();
            }
        }
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        if (gameStateChanged.getGameState() == GameState.LOGGED_IN) {
            // Reset and initialize snapshot on the client thread after login
            inventorySnapshotInitialized = false;
            clientThread.invoke(this::initializeInventorySnapshot);
        }
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        if (!"newgameplus".equals(event.getGroup())) {
            return;
        }
        if ("unlockedItemIds".equals(event.getKey())) {
            loadUnlockedFromConfig();
            rebuildUnlockedNames();
            if (panel != null) {
                panel.refreshFromPlugin();
            }
        }
    }

    @Subscribe
    public void onClientTick(ClientTick tick) {
        // Keep blocked entries visible but faded (deprioritized); leave allowed entries (e.g., Take/Examine/Cancel) as-is
        MenuEntry[] entries = client.getMenuEntries();
        if (entries == null || entries.length == 0) {
            return;
        }

        boolean mutated = false;
        for (MenuEntry entry : entries) {
            if (!allowMenuEntry(entry)) {
                // Fade out disallowed entries on locked items
                entry.setDeprioritized(true);
                String option = entry.getOption();
                if (option != null && !isColored(option)) {
                    entry.setOption(ColorUtil.prependColorTag(option, Color.GRAY));
                }
                String target = entry.getTarget();
                if (target != null) {
                    entry.setTarget(ColorUtil.prependColorTag(Text.removeTags(target), Color.GRAY));
                }
                mutated = true;
            }
        }

        if (mutated) {
            client.setMenuEntries(entries);
        }
    }

    @Subscribe
    public void onMenuEntryAdded(MenuEntryAdded event) {
        final int itemId = event.getItemId();
        final String option = event.getOption();
        if (itemId <= 0 || option == null) {
            return;
        }

        if (allowOption(itemId, option)) {
            return;
        }

        MenuEntry[] entries = client.getMenuEntries();
        if (entries == null || entries.length == 0) {
            return;
        }
        MenuEntry last = entries[entries.length - 1];
        last.setDeprioritized(true);
        String lastOpt = last.getOption();
        if (lastOpt != null && !isColored(lastOpt)) {
            last.setOption(ColorUtil.prependColorTag(lastOpt, Color.GRAY));
        }
        String target = last.getTarget();
        if (target != null) {
            last.setTarget(ColorUtil.prependColorTag(Text.removeTags(target), Color.GRAY));
        }
        client.setMenuEntries(entries);
    }

    @Subscribe
    public void onScriptCallbackEvent(ScriptCallbackEvent event)
    {
        // Integrate with bank search filtering. When the user searches exactly "unlocked" (or "locked"),
        // filter bank items by our lock state.
        if (!"bankSearchFilter".equals(event.getEventName()))
        {
            return;
        }

        // Stack layout mirrors BankPlugin's usage: top of int stack has itemId,
        // and writing 1 to intStack[intStackSize - 2] signals a match.
        int[] intStack = client.getIntStack();
        Object[] objectStack = client.getObjectStack();
        int intStackSize = client.getIntStackSize();
        int objectStackSize = client.getObjectStackSize();

        if (intStackSize < 2 || objectStackSize < 1)
        {
            return;
        }

        final int itemId = intStack[intStackSize - 1];
        final Object searchObj = objectStack[objectStackSize - 1];
        if (!(searchObj instanceof String))
        {
            return;
        }
        final String searchRaw = (String) searchObj;
        final String search = Text.removeTags(searchRaw).toLowerCase().trim();

        if (search.equals("is:unlocked"))
        {
            // Only include items that were default-locked by the plugin and are now unlocked
            if (wasDefaultLocked(itemId) && !isLocked(itemId))
            {
                intStack[intStackSize - 2] = 1; // match
            }
        }
        else if (search.equals("is:locked"))
        {
            if (isLocked(itemId))
            {
                intStack[intStackSize - 2] = 1; // match
            }
        }
    }

    @Subscribe
    public void onMenuOptionClicked(MenuOptionClicked event) {
        MenuEntry entry = event.getMenuEntry();
        if (entry == null) {
            return;
        }

        final String option = entry.getOption();
        final int itemId = entry.getItemId();
        // Only consume item interactions that are not allowed for locked items.
        if (itemId > 0 && !allowOption(itemId, option)) {
            event.consume();
        }
    }

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event) {
        if (event.getContainerId() != InventoryID.INVENTORY.getId()) {
            return;
        }

        ItemContainer container = event.getItemContainer();
        if (container == null) {
            return;
        }

        // On the first inventory container load after login, build the baseline snapshot and do NOT unlock items
        if (!inventorySnapshotInitialized) {
            inventoryCounts.clear();
            for (Item item : container.getItems()) {
                if (item == null) {
                    continue;
                }
                int id = item.getId();
                if (id <= 0) {
                    continue;
                }
                inventoryCounts.merge(id, item.getQuantity(), Integer::sum);
            }
            inventorySnapshotInitialized = true;
            return;
        }

        // Detect newly added items and unlock those item IDs
        Map<Integer, Integer> newCounts = new HashMap<>();
        for (Item item : container.getItems()) {
            if (item == null) {
                continue;
            }
            int id = item.getId();
            if (id <= 0) {
                continue;
            }
            newCounts.merge(id, item.getQuantity(), Integer::sum);
        }

        for (Map.Entry<Integer, Integer> e : newCounts.entrySet()) {
            int id = e.getKey();
            int newQty = e.getValue();
            int oldQty = inventoryCounts.getOrDefault(id, 0);
            if (newQty > oldQty) {
                if (isLocked(id) && unlockedItemIds.add(id)) {
                    log.debug("Unlocked item id {} via inventory increase ({} -> {})", id, oldQty, newQty);
                    try {
                        String name = itemManager.getItemComposition(id).getName();
                        postGameMessage(ColorUtil.prependColorTag("NG+: Unlocked " + name + "!", new Color(197, 27, 138)));
                        showUnlockPopup(id);
                        playUnlockSound();
                        takeUnlockScreenshot(name);
                    } catch (Exception ignored) {
                    }
                    saveUnlockedToConfig();
                    rebuildUnlockedNames();
                    if (panel != null) {
                        panel.refreshFromPlugin();
                    }
                }
            }
        }

        // Update snapshot
        inventoryCounts.clear();
        inventoryCounts.putAll(newCounts);
    }

    private void initializeInventorySnapshot() {
        // Rebuild snapshot fresh each time
        inventoryCounts.clear();
        ItemContainer inv = client.getItemContainer(InventoryID.INVENTORY);
        if (inv == null) {
            return;
        }
        for (Item item : inv.getItems()) {
            if (item == null) {
                continue;
            }
            int id = item.getId();
            if (id <= 0) {
                continue;
            }
            inventoryCounts.merge(id, item.getQuantity(), Integer::sum);
        }
        inventorySnapshotInitialized = true;
    }

    private boolean allowMenuEntry(MenuEntry entry) {
        // Only consider entries tied to an item id
        int itemId = entry.getItemId();
        if (itemId <= 0) {
            return true; // not an item interaction
        }

        return allowOption(itemId, entry.getOption());
    }

    private boolean allowOption(int itemId, String option) {
        // If item is unlocked, allow normal behavior
        if (!isLocked(itemId)) {
            return true;
        }

        // Blacklist approach: disallow specific actions on locked items; allow everything else
        if (option == null) {
            return true; // not an actionable verb we recognize; allow
        }

        // Compare without any color tags, case-insensitive
        String opt = Text.removeTags(option).toLowerCase();

        // Disallowed verbs for locked items
        // - wear, wield, use, check, revert
        // - withdraw and all variants (withdraw-1, withdraw-5, withdraw-all, withdraw-all but one, etc.)
        if (opt.equals("wear")
                || opt.equals("wield")
                || opt.equals("use")
                || opt.equals("check")
                || opt.equals("revert")
                || opt.startsWith("withdraw")) {
            return false;
        }

        // Everything else is allowed (e.g. take, examine, cancel, view/select, deposit, etc.)
        return true;
    }

    // Determine if an item is locked considering user unlocks (by id and by name) and default-locked names
    public boolean isLocked(int itemId) {
        if (itemId <= 0) {
            return false;
        }
        // Explicit user unlocks by id
        if (unlockedItemIds.contains(itemId)) {
            return false;
        }
        // Resolve name for name-based checks
        String normName;
        try {
            String name = itemManager.getItemComposition(itemId).getName();
            normName = normalizeName(name);
        } catch (Exception e) {
            // If we cannot resolve the name, do not over-lock
            return false;
        }

        // User unlocks by name families (variant unlocking via wildcard patterns)
        for (Pattern p : unlockedNamePatterns) {
            if (p.matcher(normName).matches()) {
                return false;
            }
        }

        // Apply default locks (name families via wildcard patterns)
        for (Pattern p : defaultLockedPatterns) {
            if (p.matcher(normName).matches()) {
                return true;
            }
        }

        // Otherwise unlocked by default
        return false;
    }

    // Determine if an item would be considered default-locked based on name families
    private boolean wasDefaultLocked(int itemId)
    {
        if (itemId <= 0)
        {
            return false;
        }
        String normName;
        try
        {
            String name = itemManager.getItemComposition(itemId).getName();
            normName = normalizeName(name);
        }
        catch (Exception e)
        {
            return false;
        }
        for (Pattern p : defaultLockedPatterns)
        {
            if (p.matcher(normName).matches())
            {
                return true;
            }
        }
        return false;
    }

    private boolean isColored(String s) {
        if (s == null) {
            return false;
        }
        String lower = s.toLowerCase();
        return lower.contains("<col=") || lower.contains("</col>");
    }

    private String normalizeName(String name) {
        if (name == null) {
            return "";
        }
        return Text.removeTags(name).toLowerCase().trim();
    }

    private void rebuildUnlockedNames() {
        // Ensure we run on the client thread since ItemManager access requires it
        clientThread.invoke(this::rebuildUnlockedNamesUnsafe);
    }

    private void rebuildUnlockedNamesUnsafe() {
        unlockedNamePatterns.clear();
        for (int id : unlockedItemIds) {
            try {
                String nm = itemManager.getItemComposition(id).getName();
                String norm = normalizeName(nm);

                boolean mapped = false;
                // If this unlocked name falls under any default-locked family, unlock that family
                for (Pattern p : defaultLockedPatterns) {
                    if (p.matcher(norm).matches()) {
                        unlockedNamePatterns.add(p);
                        mapped = true;
                    }
                }
                // Otherwise, unlock its own family compiled from the name
                if (!mapped) {
                    unlockedNamePatterns.add(compileNameFamilyPattern(norm));
                }
            } catch (Exception ignored) {
            }
        }
    }

    private void postGameMessage(String message) {
        if (message == null) {
            return;
        }
        clientThread.invoke(() -> client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", message, null));
    }

    private void showUnlockPopup(int itemId) {
        if (!config.showUnlockPopup() || unlockOverlay == null) {
            return;
        }
        clientThread.invoke(() ->
        {
            String nm;
            try {
                nm = client.getItemDefinition(itemId).getName();
            } catch (Exception e) {
                nm = "Unknown item";
            }
            unlockOverlay.enqueueUnlock(itemId, nm);
        });
    }

    private void playUnlockSound() {
        if (audioExecutor == null || !config.playUnlockSound()) {
            return;
        }
        final Path soundPath = RuneLite.RUNELITE_DIR.toPath()
                .resolve("new-game-plus")
                .resolve("new-game-plus-unlock.wav");
        if (!Files.exists(soundPath)) {
            return;
        }

        audioExecutor.submit(() ->
        {
            try {
                int vol = Math.max(0, Math.min(100, config.unlockSoundVolume()));
                // Map 0..100 volume to a reasonable dB range (-80dB = silent, 0dB = no boost)
                float gainDb = -80.0f + (vol / 100.0f) * 80.0f;
                new AudioPlayer().play(soundPath.toFile(), gainDb);
            } catch (Throwable t) {
                log.debug("NG+: unlock sound failed: {}", t.getMessage());
            }
        });
    }

    private void takeUnlockScreenshot(String itemName) {
        if (!config.screenshotOnUnlock()) {
            return;
        }
        if (client.getGameState() == GameState.LOGIN_SCREEN) {
            return;
        }

        final String base = "Unlock (" + (itemName == null ? "item" : itemName) + ")";
        final String fileName = sanitizeFilename(base);

        // Delay to allow the notification/popup to render before capture
        if (screenshotExecutor != null) {
            screenshotExecutor.schedule(() -> {
                // Capture next frame and save asynchronously
                drawManager.requestNextFrameListener(image -> {
                    if (screenshotExecutor == null) {
                        return;
                    }
                    screenshotExecutor.submit(() -> {
                        try {
                            BufferedImage bi = ImageUtil.bufferedImageFromImage(image);
                            imageCapture.saveScreenshot(bi, fileName, "New Game Plus", false, false);
                        } catch (Exception e) {
                            log.debug("NG+: screenshot failed: {}", e.getMessage());
                        }
                    });
                });
            }, 1300, TimeUnit.MILLISECONDS);
        }
    }

    private String sanitizeFilename(String s) {
        if (s == null) {
            return "unlock";
        }
        s = Text.removeTags(s).trim();
        return s.replaceAll("[\\\\/:*?\"<>|]", "_");
    }

    // Load default-locked name families (always enabled)
    private void loadDefaultLockedNames() {
        defaultLockedPatterns.clear();
        readDefaultNamesResource("/default-locks/bosses.txt");
        readDefaultNamesResource("/default-locks/raids.txt");
        readDefaultNamesResource("/default-locks/slayer.txt");
        // Rebuild unlocked name patterns to map unlocks to the current default families
        rebuildUnlockedNames();
    }

    private void readDefaultNamesResource(String resourcePath) {
        try (InputStream is = NewGamePlusPlugin.class.getResourceAsStream(resourcePath)) {
            if (is == null) {
                log.debug("Default lock resource not found: {}", resourcePath);
                return;
            }
            try (BufferedReader br = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8))) {
                String line;
                while ((line = br.readLine()) != null) {
                    String trimmed = line.trim();
                    if (trimmed.isEmpty() || trimmed.startsWith("#")) {
                        continue;
                    }
                    String norm = normalizeName(trimmed);
                    defaultLockedPatterns.add(compileNameFamilyPattern(norm));
                }
            }
        } catch (Exception e) {
            log.warn("Failed reading default lock resource {}", resourcePath, e);
        }
    }

    // Build a regex that matches any name containing the tokens (in order), allowing extra words/prefixes/suffixes
    private Pattern compileNameFamilyPattern(String base) {
        if (base == null) {
            base = "";
        }
        String[] tokens = base.toLowerCase().split("[^a-z0-9]+");
        StringBuilder re = new StringBuilder();
        re.append(".*");
        for (String tk : tokens) {
            if (tk.isEmpty()) {
                continue;
            }
            re.append("\\b").append(java.util.regex.Pattern.quote(tk)).append("\\b").append(".*");
        }
        return java.util.regex.Pattern.compile(re.toString());
    }

    private void loadUnlockedFromConfig() {
        String csv = configManager.getConfiguration("newgameplus", "unlockedItemIds");
        unlockedItemIds.clear();
        if (csv == null || csv.isEmpty()) {
            return;
        }
        String[] parts = csv.split(",");
        for (String p : parts) {
            try {
                int id = Integer.parseInt(p.trim());
                if (id > 0) {
                    unlockedItemIds.add(id);
                }
            } catch (NumberFormatException ignored) {
            }
        }
    }

    private void saveUnlockedToConfig() {
        StringBuilder sb = new StringBuilder();
        for (Integer id : unlockedItemIds) {
            if (sb.length() > 0) {
                sb.append(',');
            }
            sb.append(id);
        }
        configManager.setConfiguration("newgameplus", "unlockedItemIds", sb.toString());
    }

    // Read unlocked IDs directly from persisted config
    public java.util.Set<Integer> getUnlockedItemIdsFromConfig() {
        java.util.Set<Integer> ids = new java.util.HashSet<>();
        String csv = configManager.getConfiguration("newgameplus", "unlockedItemIds");
        if (csv == null || csv.isEmpty()) {
            return ids;
        }
        String[] parts = csv.split(",");
        for (String p : parts) {
            try {
                int id = Integer.parseInt(p.trim());
                if (id > 0) {
                    ids.add(id);
                }
            } catch (NumberFormatException ignored) {
            }
        }
        return ids;
    }

    // Expose helpers for panel
    public java.util.Set<Integer> getUnlockedItemIds() {
        return new java.util.HashSet<>(unlockedItemIds);
    }

    public void addUnlock(int id) {
        if (id <= 0) {
            return;
        }
        if (unlockedItemIds.add(id)) {
            saveUnlockedToConfig();
            rebuildUnlockedNames();
            if (panel != null) {
                panel.refreshFromPlugin();
            }
        }
    }

    public void removeUnlock(int id) {
        if (unlockedItemIds.remove(id)) {
            saveUnlockedToConfig();
            rebuildUnlockedNames();
            if (panel != null) {
                panel.refreshFromPlugin();
            }
        }
    }

    public void clearAllUnlocks() {
        if (unlockedItemIds.isEmpty()) {
            return;
        }
        unlockedItemIds.clear();
        saveUnlockedToConfig();
        rebuildUnlockedNames();
        if (panel != null) {
            panel.refreshFromPlugin();
        }
        postGameMessage("NG+: Cleared all unlocks");
    }

    public String getItemName(int id) {
        try {
            return itemManager.getItemComposition(id).getName();
        } catch (Exception e) {
            return "Unknown item";
        }
    }

    // Build the panel entries on the client thread to satisfy item definition access
    public void refreshPanelAsync(NewGamePlusPanel targetPanel) {
        clientThread.invoke(() ->
        {
            Map<Integer, String> idToName = new HashMap<>();
            for (int id : getUnlockedItemIdsFromConfig()) {
                String name;
                try {
                    name = client.getItemDefinition(id).getName();
                } catch (Exception e) {
                    name = "Unknown item";
                }
                idToName.put(id, name);
            }
            if (targetPanel != null) {
                targetPanel.setEntries(idToName);
            }
        });
    }

    // Open an in-game chatbox search to add an unlocked item by name
    public void openAddItemSearch() {
        clientThread.invoke(() ->
        {
            // Ensure the RuneLite client (and chatbox input) has keyboard focus after clicking the sidebar button
            if (clientUI != null) {
                clientUI.requestFocus();
            }

            chatboxItemSearch
                    .tooltipText("Click a lockable item to add to unlocks")
                    .onItemSelected(id ->
                    {
                        if (id != null && id > 0) {
                            // Only accept items that belong to a default-locked family
                            boolean lockable = false;
                            try {
                                String nm = client.getItemDefinition(id).getName();
                                String norm = normalizeName(nm);
                                for (java.util.regex.Pattern p : defaultLockedPatterns) {
                                    if (p.matcher(norm).matches()) {
                                        lockable = true;
                                        break;
                                    }
                                }
                            } catch (Exception ignored) {
                            }
                            if (!lockable) {
                                postGameMessage("NG+: That item is not in the lockable lists. Pick another.");
                                // Reopen the restricted search to try again
                                openAddItemSearch();
                                return;
                            }

                            addUnlock(id);
                            String name;
                            try {
                                name = client.getItemDefinition(id).getName();
                            } catch (Exception e) {
                                name = "Unknown item";
                            }
                            postGameMessage("NG+: Added " + name + " to unlocks");
                        }
                    })
                    .prompt("Search lockable item to unlock")
                    .build();
        });
    }

    @Provides
    NewGamePlusConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(NewGamePlusConfig.class);
    }
}

package com.newgameplus;

import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

import javax.inject.Inject;
import java.awt.AlphaComposite;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.image.BufferedImage;
import java.time.Duration;
import java.util.ArrayDeque;
import java.util.Deque;

// Overlay that displays a center-top popup with the unlocked item's icon and name
public class NewGamePlusUnlockOverlay extends Overlay {
    private static final int PADDING = 8;
    private static final int SPACING = 8;
    private static final int ARC = 8;
    // Timing: fade-in, hold full opacity ~5s, fade-out
    private static final long FADE_IN_MS = 400;
    private static final long FULL_MS = Duration.ofSeconds(4).toMillis();
    private static final long FADE_OUT_MS = 400;
    private static final long TOTAL_MS = FADE_IN_MS + FULL_MS + FADE_OUT_MS;

    private final ItemManager itemManager;
    private final Deque<Notification> queue = new ArrayDeque<>();
    private Notification current;
    private long currentStart;

    @Inject
    public NewGamePlusUnlockOverlay(ItemManager itemManager) {
        this.itemManager = itemManager;
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPriority(OverlayPriority.HIGH);
        setPosition(OverlayPosition.TOP_CENTER);
    }

    public void enqueueUnlock(int itemId, String itemName) {
        if (itemId <= 0) {
            return;
        }
        queue.add(new Notification(itemId, itemName));
    }

    public void clear() {
        queue.clear();
        current = null;
        currentStart = 0L;
    }

    @Override
    public Dimension render(Graphics2D g) {
        long now = System.currentTimeMillis();
        if (current == null) {
            current = queue.pollFirst();
            currentStart = now;
        } else if (now - currentStart > TOTAL_MS) {
            current = queue.pollFirst();
            currentStart = now;
        }

        if (current == null) {
            return null;
        }

        // Resolve image lazily
        if (current.image == null) {
            try {
                current.image = itemManager.getImage(current.itemId);
            } catch (Exception ignored) {
            }
        }

        BufferedImage img = current.image;
        int imgW = img != null ? img.getWidth() : 0;
        int imgH = img != null ? img.getHeight() : 0;

        // Rendering setup
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
        g.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);
        g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);

        // Use RuneLite's standard fonts for crisp overlay text
        Font titleFont = FontManager.getRunescapeBoldFont();
        Font nameFont = FontManager.getRunescapeFont();

        // Strings
        String title = "NG+: New unlock";
        String name = current.itemName != null ? current.itemName : "Unknown item";

        // Measure
        g.setFont(titleFont);
        FontMetrics fmTitle = g.getFontMetrics();
        int titleW = fmTitle.stringWidth(title);
        int titleH = fmTitle.getAscent();

        g.setFont(nameFont);
        FontMetrics fmName = g.getFontMetrics();
        int nameW = fmName.stringWidth(name);
        int nameH = fmName.getAscent();

        int rightColW = Math.max(titleW, nameW);
        int contentW = imgW + (imgW > 0 ? SPACING : 0) + rightColW;
        int contentH = Math.max(imgH, titleH + 4 + nameH);

        int boxW = contentW + PADDING * 2;
        int boxH = contentH + PADDING * 2;

        // Compute alpha for fade-in/out
        long elapsed = now - currentStart;
        float alpha;
        if (elapsed < FADE_IN_MS) {
            alpha = Math.max(0f, Math.min(1f, (float) elapsed / (float) FADE_IN_MS));
        } else if (elapsed < FADE_IN_MS + FULL_MS) {
            alpha = 1f;
        } else {
            long t = elapsed - (FADE_IN_MS + FULL_MS);
            alpha = 1f - Math.max(0f, Math.min(1f, (float) t / (float) FADE_OUT_MS));
        }

        // Use RuneLite color scheme for a clean, native look
        Color bg = ColorScheme.DARKER_GRAY_COLOR;
        Color border = ColorScheme.DARK_GRAY_COLOR;
        Color titleColor = new Color(210, 180, 64); // gold-ish accent similar to OSRS

        g.setComposite(AlphaComposite.SrcOver.derive(alpha));

        // Subtle drop shadow
        g.setColor(new Color(0, 0, 0, 90));
        g.fillRoundRect(2, 3, boxW, boxH, ARC, ARC);

        // Panel background and border
        g.setColor(bg);
        g.fillRoundRect(0, 0, boxW, boxH, ARC, ARC);
        g.setColor(border);
        g.setStroke(new BasicStroke(1.5f));
        g.drawRoundRect(0, 0, boxW, boxH, ARC, ARC);

        int x = PADDING;
        int y = PADDING;

        // Draw item image
        if (img != null) {
            int imgY = y + (contentH - imgH) / 2;
            g.drawImage(img, x, imgY, null);
            x += imgW + (imgW > 0 ? SPACING : 0);
        }

        // Draw title and name stacked
        g.setFont(titleFont);
        g.setColor(titleColor);
        int titleY = y + fmTitle.getAscent();
        g.drawString(title, x, titleY);

        g.setFont(nameFont);
        g.setColor(Color.WHITE);
        int nameY = titleY + 4 + fmName.getAscent();
        g.drawString(name, x, nameY);

        return new Dimension(boxW, boxH);
    }

    private static class Notification {
        final int itemId;
        final String itemName;
        BufferedImage image;

        Notification(int itemId, String itemName) {
            this.itemId = itemId;
            this.itemName = itemName;
        }
    }
}

package com.newgameplus;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class NewGamePlusPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(NewGamePlusPlugin.class);
		RuneLite.main(args);
	}
}
