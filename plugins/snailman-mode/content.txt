package com.idyl.snailman.pathfinder;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import net.runelite.api.coords.WorldPoint;

public class CollisionMap extends SplitFlagMap {
    public CollisionMap(int regionSize, Map<Position, byte[]> compressedRegions) {
        super(regionSize, compressedRegions, 2);
    }

    public boolean n(int x, int y, int z) {
        return get(x, y, z, 0);
    }

    public boolean s(int x, int y, int z) {
        return n(x, y - 1, z);
    }

    public boolean e(int x, int y, int z) {
        return get(x, y, z, 1);
    }

    public boolean w(int x, int y, int z) {
        return e(x - 1, y, z);
    }

    private boolean ne(int x, int y, int z) {
        return n(x, y, z) && e(x, y + 1, z) && e(x, y, z) && n(x + 1, y, z);
    }

    private boolean nw(int x, int y, int z) {
        return n(x, y, z) && w(x, y + 1, z) && w(x, y, z) && n(x - 1, y, z);
    }

    private boolean se(int x, int y, int z) {
        return s(x, y, z) && e(x, y - 1, z) && e(x, y, z) && s(x + 1, y, z);
    }

    private boolean sw(int x, int y, int z) {
        return s(x, y, z) && w(x, y - 1, z) && w(x, y, z) && s(x - 1, y, z);
    }

    public boolean isBlocked(int x, int y, int z) {
        return !n(x, y, z) && !s(x, y, z) && !e(x, y, z) && !w(x, y, z);
    }

    public List<WorldPoint> getNeighbors(WorldPoint position) {
        int x = position.getX();
        int y = position.getY();
        int z = position.getPlane();

        List<WorldPoint> neighbors = new ArrayList<>();
        boolean[] traversable = new boolean[] {
                w(x, y, z), e(x, y, z), s(x, y, z), n(x, y, z), sw(x, y, z), se(x, y, z), nw(x, y, z), ne(x, y, z)
        };

        for (int i = 0; i < traversable.length; i++) {
            if (traversable[i]) {
                OrdinalDirection direction = OrdinalDirection.values()[i];
                neighbors.add(position.dx(direction.x).dy(direction.y));
            }
        }

        return neighbors;
    }
}
package com.idyl.snailman.pathfinder;

import java.nio.ByteBuffer;
import java.util.BitSet;

public class FlagMap {
    public static final int PLANE_COUNT = 4;
    protected final BitSet flags;
    public final int minX;
    public final int minY;
    public final int maxX;
    public final int maxY;
    private final int width;
    private final int height;
    private final int flagCount;

    public FlagMap(int minX, int minY, int maxX, int maxY, int flagCount) {
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
        this.flagCount = flagCount;
        width = (maxX - minX + 1);
        height = (maxY - minY + 1);
        flags = new BitSet(width * height * PLANE_COUNT * flagCount);
    }

    public FlagMap(byte[] bytes, int flagCount) {
        ByteBuffer buffer = ByteBuffer.wrap(bytes);
        minX = buffer.getInt();
        minY = buffer.getInt();
        maxX = buffer.getInt();
        maxY = buffer.getInt();
        this.flagCount = flagCount;
        width = (maxX - minX + 1);
        height = (maxY - minY + 1);
        flags = BitSet.valueOf(buffer);
    }

    public byte[] toBytes() {
        byte[] bytes = new byte[16 + flags.size()];
        ByteBuffer buffer = ByteBuffer.wrap(bytes);
        buffer.putInt(minX);
        buffer.putInt(minY);
        buffer.putInt(maxX);
        buffer.putInt(maxY);
        buffer.put(flags.toByteArray());
        return bytes;
    }

    public boolean get(int x, int y, int z, int flag) {
        if (x < minX || x > maxX || y < minY || y > maxY || z < 0 || z > PLANE_COUNT - 1) {
            return false;
        }

        return flags.get(index(x, y, z, flag));
    }

    public void set(int x, int y, int z, int flag, boolean value) {
        flags.set(index(x, y, z, flag), value);
    }

    private int index(int x, int y, int z, int flag) {
        if (x < minX || x > maxX || y < minY || y > maxY || z < 0 || z > PLANE_COUNT - 1 || flag < 0 || flag > flagCount - 1) {
            throw new IndexOutOfBoundsException(x + " " + y + " " + z);
        }

        return (z * width * height + (y - minY) * width + (x - minX)) * flagCount + flag;
    }
}
package com.idyl.snailman.pathfinder;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import net.runelite.api.coords.WorldPoint;

public class Node {
    public final WorldPoint position;
    public final Node previous;

    public Node(WorldPoint position, Node previous) {
        this.position = position;
        this.previous = previous;
    }

    public List<WorldPoint> getPath() {
        List<WorldPoint> path = new LinkedList<>();
        Node node = this;

        while (node != null) {
            path.add(0, node.position);
            node = node.previous;
        }

        return new ArrayList<>(path);
    }
}
package com.idyl.snailman.pathfinder;

public enum OrdinalDirection {
    WEST(-1, 0),
    EAST(1, 0),
    SOUTH(0, -1),
    NORTH(0, 1),
    SOUTH_WEST(-1, -1),
    SOUTH_EAST(1, -1),
    NORTH_WEST(-1, 1),
    NORTH_EAST(1, 1);

    final int x;
    final int y;

    OrdinalDirection(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
package com.idyl.snailman.pathfinder;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.time.Instant;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import lombok.Getter;
import net.runelite.api.coords.WorldPoint;
import com.idyl.snailman.Transport;

public class Pathfinder implements Runnable {
    @Getter
    private final WorldPoint start;
    @Getter
    private final WorldPoint target;
    private final PathfinderConfig config;

    private final List<Node> boundary = new LinkedList<>();
    private final Set<WorldPoint> visited = new HashSet<>();

    public boolean isComplete;

    @Getter
    private List<WorldPoint> path = new ArrayList<>();
    @Getter
    private boolean done = false;

    public Pathfinder(PathfinderConfig config, WorldPoint start, WorldPoint target, List<WorldPoint> existingPath) {
        this.config = config;
        this.start = start;
        this.target = target;

        isComplete = false;

        if(existingPath  != null) {
            Node prev = null;
            boolean foundStart = false;
            for(int i = 0; i < existingPath.size(); i++) {
                WorldPoint point = existingPath.get(i);

                if(!point.equals(start) && !foundStart) continue;
                foundStart = true;

                Node n = new Node(existingPath.get(i), prev);
                boundary.add(n);
                prev = n;
            }
        }

        new Thread(this).start();
    }

    public static void writeTransportToFile(String transport) {
        try {
            Files.write(Paths.get("src/main/resources/transports.txt"), transport.concat("\n").getBytes(), StandardOpenOption.APPEND);
        }catch (IOException e) {
            System.out.println(e);
        }
    }

    private void addNeighbor(Node node, WorldPoint neighbor) {
        if (!visited.add(neighbor)) {
            return;
        }
        boundary.add(new Node(neighbor, node));
    }

    private void addNeighbors(Node node) {
        for (WorldPoint neighbor : config.getMap().getNeighbors(node.position)) {
            addNeighbor(node, neighbor);
        }

        for (Transport transport : config.getTransports().getOrDefault(node.position, new ArrayList<>())) {
            addNeighbor(node, transport.getDestination());
        }
    }

    @Override
    public void run() {
        boundary.add(new Node(start, null));

        Node nearest = boundary.get(0);
        int bestDistance = Integer.MAX_VALUE;
        Instant cutoffTime = Instant.now().plus(PathfinderConfig.CALCULATION_CUTOFF);
        long startTime = Instant.now().toEpochMilli();

        while (!boundary.isEmpty()) {
            Node node = boundary.remove(0);

            if (node.position.equals(target)) {
                path = node.getPath();
                System.out.println("Found best path.");
                isComplete = true;
                break;
            }

            int distance = node.position.distanceTo(target);
            if (distance < bestDistance) {
                path = node.getPath();
                nearest = node;
                bestDistance = distance;
                cutoffTime = Instant.now().plus(PathfinderConfig.CALCULATION_CUTOFF);
            }

            if (Instant.now().isAfter(cutoffTime)) {
                path = nearest.getPath();
                long elapsed = Instant.now().toEpochMilli() - startTime;
                break;
            }

            addNeighbors(node);
        }
        long elapsed = Instant.now().toEpochMilli() - startTime;
        System.out.println("Finished calculation in "+elapsed+"ms");

        done = true;
        boundary.clear();
        visited.clear();
    }
}
package com.idyl.snailman.pathfinder;

import java.time.Duration;
import java.util.List;
import java.util.Map;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;
import com.idyl.snailman.Transport;

public class PathfinderConfig {
    public static final Duration CALCULATION_CUTOFF = Duration.ofSeconds(5);

    @Getter
    private final CollisionMap map;
    @Getter
    private final Map<WorldPoint, List<Transport>> transports;

    public PathfinderConfig(CollisionMap map, Map<WorldPoint, List<Transport>> transports, Client client) {
        this.map = map;
        this.transports = transports;
    }
}
package com.idyl.snailman.pathfinder;

import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import com.google.common.cache.Weigher;
import com.google.common.util.concurrent.UncheckedExecutionException;
import com.idyl.snailman.Util;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.UncheckedIOException;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.zip.GZIPInputStream;

public abstract class SplitFlagMap {
    private static final int MAXIMUM_SIZE = 20 * 1024 * 1024;
    private final int regionSize;
    private final LoadingCache<Position, FlagMap> regionMaps;
    private final int flagCount;

    public SplitFlagMap(int regionSize, Map<Position, byte[]> compressedRegions, int flagCount) {
        this.regionSize = regionSize;
        this.flagCount = flagCount;
        regionMaps = CacheBuilder
                .newBuilder()
                .weigher((Weigher<Position, FlagMap>) (k, v) -> v.flags.size() / 8)
                .maximumWeight(MAXIMUM_SIZE)
                .build(CacheLoader.from(position -> {
                    byte[] compressedRegion = compressedRegions.get(position);

                    if (compressedRegion == null) {
                        return new FlagMap(position.x * regionSize, position.y * regionSize, (position.x + 1) * regionSize - 1, (position.y + 1) * regionSize - 1, this.flagCount);
                    }

                    try (InputStream in = new GZIPInputStream(new ByteArrayInputStream(compressedRegion))) {
                        return new FlagMap(Util.readAllBytes(in), this.flagCount);
                    } catch (IOException e) {
                        throw new UncheckedIOException(e);
                    }
                }));
    }

    public boolean get(int x, int y, int z, int flag) {
        try {
            return regionMaps.get(new Position(x / regionSize, y / regionSize)).get(x, y, z, flag);
        } catch (ExecutionException e) {
            throw new UncheckedExecutionException(e);
        }
    }

    public static class Position {
        public final int x;
        public final int y;

        public Position(int x, int y) {
            this.x = x;
            this.y = y;
        }

        @Override
        public boolean equals(Object o) {
            return o instanceof Position &&
                    ((Position) o).x == x &&
                    ((Position) o).y == y;
        }

        @Override
        public int hashCode() {
            return x * 31 + y;
        }

        @Override
        public String toString() {
            return "(" + x + ", " + y + ")";
        }
    }
}
package com.idyl.snailman;

import net.runelite.client.config.*;

import java.awt.*;

@ConfigGroup("snailmanmode")
public interface SnailManModeConfig extends Config
{
	@ConfigItem(
			keyName = "snailColor",
			name = "Snail Color",
			description = "The color of the snail tile",
			position = 1
	)
	default Color color()
	{
		return Color.RED;
	}

	@ConfigItem(
			keyName = "speedBoost",
			name = "Speed Boost",
			description = "Snail moves 1 tile per tick when it gets close to you",
			position = 4
	)
	default boolean speedBoost() { return false; }

	@ConfigItem(
			keyName = "showOnMap",
			name = "Show Snail on World Map",
			description = "Show where the snail is on the world map (kind of defeats the purpose but its neat)",
			position = 2
	)
	default boolean showOnMap() { return false; }

	@ConfigItem(
			keyName = "pauseSnail",
			name = "Pause Snail",
			description = "Pause the snail so that it stops following you",
			position = 5
	)
	default boolean pauseSnail() { return false; }

	@ConfigItem(
			keyName = "moveSpeed",
			name = "Move Speed",
			description = "How many ticks it takes the snail to move 1 tile",
			position = 3
	)
	@Range(
			min=1,
			max=30
	)
	default int moveSpeed() { return 1; }

	@ConfigItem(
			keyName = "horrorMode",
			name = "Horror Mode",
			description = "Plays a sound when the snail is nearby (best experienced with minimum render distance & maximum fog in the GPU plugin)",
			position = 7
	)
	default boolean horrorMode()
	{
		return false;
	}

	@ConfigItem(
			keyName = "drawDistance",
			name = "Draw Distance",
			description = "Distance at which the snail is rendered",
			position = 6
	)
	@Range(
			min = 1,
			max = 32
	)
	default int drawDistance() { return 32; }
}

package com.idyl.snailman;

import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.api.Point;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.awt.geom.Area;
import java.util.List;

public class SnailManModeMapOverlay extends Overlay {
    private final Client client;
    private final SnailManModePlugin plugin;
    private final SnailManModeConfig config;

    private Area mapClipArea;

    private BufferedImage mapIcon;

    @Inject
    private SnailManModeMapOverlay(Client client, SnailManModePlugin plugin, SnailManModeConfig config) {
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(OverlayPriority.LOW);
        setLayer(OverlayLayer.MANUAL);
        drawAfterLayer(WidgetInfo.WORLD_MAP_VIEW);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if(!config.showOnMap()) return null;

        if (client.getWidget(WidgetInfo.WORLD_MAP_VIEW) == null) {
            return null;
        }

        mapClipArea = getWorldMapClipArea(client.getWidget(WidgetInfo.WORLD_MAP_VIEW).getBounds());
        graphics.setClip(mapClipArea);

        if(SnailManModePlugin.DEV_MODE && plugin.pathfinder != null) {
            List<WorldPoint> path = plugin.pathfinder.getPath();
            for (WorldPoint point : path) {
                Point graphicsPoint = plugin.mapWorldPointToGraphicsPoint(point);
                graphics.setColor(Color.GREEN);
                graphics.drawRect(graphicsPoint.getX(), graphicsPoint.getY(), 1, 1);
            }
        }

        BufferedImage marker = getMapIconImage();
        Point point = plugin.mapWorldPointToGraphicsPoint(plugin.getSnailWorldPoint());
        graphics.drawImage(marker, point.getX() - marker.getWidth() / 2, point.getY() - marker.getHeight() / 2, null);

        return null;
    }

    private BufferedImage getMapIconImage() {
        if(mapIcon == null) {
            mapIcon = ImageUtil.loadImageResource(getClass(), "/marker.png");
        }

        return mapIcon;
    }

    private Area getWorldMapClipArea(Rectangle baseRectangle) {
        final Widget overview = client.getWidget(WidgetInfo.WORLD_MAP_OVERVIEW_MAP);
        final Widget surfaceSelector = client.getWidget(WidgetInfo.WORLD_MAP_SURFACE_SELECTOR);

        Area clipArea = new Area(baseRectangle);

        if (overview != null && !overview.isHidden()) {
            clipArea.subtract(new Area(overview.getBounds()));
        }

        if (surfaceSelector != null && !surfaceSelector.isHidden()) {
            clipArea.subtract(new Area(surfaceSelector.getBounds()));
        }

        return clipArea;
    }
}

package com.idyl.snailman;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.*;
import net.runelite.api.Point;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.awt.*;
import java.util.List;
import java.awt.image.BufferedImage;

@Slf4j
public class SnailManModeOverlay extends Overlay {
    private static final int MAX_DRAW_DISTANCE = 32;

    private final Client client;
    private final SnailManModeConfig config;
    private final SnailManModePlugin plugin;

    BufferedImage snailShell = null;

    @Inject
    private SnailManModeOverlay(Client client, SnailManModeConfig config, SnailManModePlugin plugin) {
        this.client = client;
        this.config = config;
        this.plugin = plugin;

        setPosition(OverlayPosition.DYNAMIC);
        setPriority(OverlayPriority.LOW);
        setLayer(OverlayLayer.ABOVE_SCENE);
    }

//    private void renderTransports(Graphics2D graphics) {
//        for (WorldPoint a : plugin.pathfinderConfig.getTransports().keySet()) {
//            drawTransport(graphics, a);
//
//            java.awt.Point ca = tileCenter(a);
//
//            if (ca == null) {
//                continue;
//            }
//
//            for (Transport t : plugin.pathfinderConfig.getTransports().get(a)) {
//                WorldPoint b = t.getOrigin();
//                java.awt.Point cb = tileCenter(b);
//
//                if (cb != null) {
//                    graphics.drawLine(ca.x, ca.y, cb.x, cb.y);
//                }
//            }
//
//            StringBuilder s = new StringBuilder();
//            for (Transport t : plugin.pathfinderConfig.getTransports().get(a)) {
//                WorldPoint b = t.getDestination();
//                if (b.getPlane() > a.getPlane()) {
//                    s.append("+");
//                } else if (b.getPlane() < a.getPlane()) {
//                    s.append("-");
//                } else {
//                    s.append("=");
//                }
//            }
//            graphics.setColor(Color.WHITE);
//            graphics.drawString(s.toString(), ca.x, ca.y);
//        }
//    }

    private java.awt.Point tileCenter(WorldPoint b) {
        if (b.getPlane() != client.getPlane()) {
            return null;
        }

        LocalPoint lp = LocalPoint.fromWorld(client, b);
        if (lp == null) {
            return null;
        }

        Polygon poly = Perspective.getCanvasTilePoly(client, lp);
        if (poly == null) {
            return null;
        }

        int cx = poly.getBounds().x + poly.getBounds().width / 2;
        int cy = poly.getBounds().y + poly.getBounds().height / 2;
        return new java.awt.Point(cx, cy);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
//        if(SnailManModePlugin.DEV_MODE) renderTransports(graphics);

        WorldPoint snailPoint = plugin.getSnailWorldPoint();
        WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();

        if(SnailManModePlugin.DEV_MODE && plugin.pathfinder != null) {
            List<WorldPoint> path = plugin.pathfinder.getPath();
            for (WorldPoint point : path) {
                drawTile(graphics, point, Color.GREEN, new BasicStroke((float) 2));
            }
        }

        long drawDistance = config.drawDistance();

        if (snailPoint.distanceTo(playerLocation) >= drawDistance)
        {
            return null;
        }

        drawTile(graphics, snailPoint, config.color(), new BasicStroke((float) 2));
        drawImg(graphics, snailPoint);
        return null;
    }

    private void drawTile(Graphics2D graphics, WorldPoint point, Color color, Stroke borderStroke)
    {

        LocalPoint lp = LocalPoint.fromWorld(client, point);
        if (lp == null)
        {
            return;
        }

        Polygon poly = Perspective.getCanvasTilePoly(client, lp);
        if (poly != null)
        {
            OverlayUtil.renderPolygon(graphics, poly, color, new Color(0, 0, 0, 1), borderStroke);
        }
    }

    private void drawImg(Graphics2D graphics, WorldPoint point) {
        LocalPoint lp = LocalPoint.fromWorld(client, point);
        if (lp == null)
        {
            return;
        }

        BufferedImage snailShell = getSnailImage();
        Point canvasImageLocation = Perspective.getCanvasImageLocation(client, lp, snailShell, 75);

        if(canvasImageLocation == null) {
            return;
        }

        OverlayUtil.renderImageLocation(graphics, canvasImageLocation, snailShell);
    }

    private void drawTransport(Graphics2D graphics, WorldPoint point) {
        if (point.getPlane() != client.getPlane()) {
            return;
        }

        LocalPoint lp = LocalPoint.fromWorld(client, point);
        if (lp == null) {
            return;
        }

        Polygon poly = Perspective.getCanvasTilePoly(client, lp);
        if (poly == null) {
            return;
        }

        graphics.setColor(Color.GREEN);
        graphics.fill(poly);
    }

    private BufferedImage getSnailImage() {
        if (snailShell == null) {
            snailShell = ImageUtil.loadImageResource(getClass(), "/snail_shell.png");
        }
        return snailShell;
    }
}

package com.idyl.snailman;

import java.awt.*;
import java.util.HashMap;
import java.util.Map;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.JButton;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;

import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.timetracking.Tab;
import net.runelite.client.plugins.timetracking.TabContentPanel;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;

@Singleton
public class SnailManModePanel extends PluginPanel
{
    private final ItemManager itemManager;
    private final SnailManModePlugin plugin;

    /* This is the panel the tabs' respective panels will be displayed on. */
    private final JPanel display = new JPanel();
    private final Map<Tab, MaterialTab> uiTabs = new HashMap<>();
    private final MaterialTabGroup tabGroup = new MaterialTabGroup(display);

    private boolean active;

    @Nullable
    private TabContentPanel activeTabPanel = null;

    @Inject
    public SnailManModePanel(ItemManager itemManager, SnailManModePlugin plugin)
    {
        super(false);
        this.itemManager = itemManager;
        this.plugin = plugin;

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        display.setBorder(new EmptyBorder(10, 10, 8, 10));

        JButton resetButton = new JButton("Reset Snail Data");
        resetButton.addActionListener(l -> plugin.reset());

        display.add(resetButton);

        add(display, BorderLayout.NORTH);
    }
}
package com.idyl.snailman;

import com.google.inject.Provides;

import javax.inject.Inject;

import com.idyl.snailman.pathfinder.CollisionMap;
import com.idyl.snailman.pathfinder.Pathfinder;
import com.idyl.snailman.pathfinder.PathfinderConfig;
import com.idyl.snailman.pathfinder.SplitFlagMap;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.Point;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.WorldService;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.JagexColors;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;
import net.runelite.http.api.worlds.WorldResult;
import net.runelite.http.api.worlds.World;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.nio.charset.StandardCharsets;
import java.time.Duration;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

@Slf4j
@PluginDescriptor(
	name = "SnailMan Mode"
)
public class SnailManModePlugin extends Plugin
{
	@Inject
	private OverlayManager overlayManager;

	@Inject
	private SnailManModeOverlay snailManModeOverlay;

	@Inject
	private SnailManModeMapOverlay snailManModeMapOverlay;

	@Inject
	private Client client;

	@Inject
	private SnailManModeConfig config;

	@Inject
	private ConfigManager configManager;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private WorldService worldService;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private InfoBoxManager infoBoxManager;

	@Inject
	private ItemManager itemManager;

	private NavigationButton navButton;

	public Pathfinder pathfinder;
	public PathfinderConfig pathfinderConfig;

	private int currentPathIndex;

	private int snailmanIconOffset = -1;

	private boolean onSeasonalWorld;

	private WorldPoint snailWorldPoint;

	private boolean isLoggedIn;
	private boolean isAlive;
	private boolean isDying;
	private WorldPoint deathPoint;

	private WorldPoint transportStart;
	private MenuEntry lastClick;

	private long lastSaveTime;

	private int tickCount = 0;

	private WorldPoint lastPlayerPoint;

	private static boolean horrorCloseFlag = false;

	private static final int RECALCULATION_THRESHOLD = 20;
	private static final int SNAIL_HORROR_SOUND = 1899;
	private static final int SNAIL_HORROR_DISTANCE = 15;
	private static final String ADD_START = "Add start";
	private static final String ADD_END = "Add end";
	private static final String WALK_HERE = "Walk here";
	private static final String TRANSPORT = ColorUtil.wrapWithColorTag("Transport", JagexColors.MENU_TARGET);
	private static final String CONFIG_GROUP = "snailman";
	private static final String CONFIG_KEY_SNAIL_LOC = "snailWorldPoint";
	private static final String CONFIG_KEY_IS_ALIVE = "isAlive";
	private static final WorldPoint DEFAULT_SNAIL_START = new WorldPoint(1181, 3624, 0);

	public static final boolean DEV_MODE = false;

	@Provides
	SnailManModeConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(SnailManModeConfig.class);
	}

	@Override
	protected void startUp()
	{
		loadResources();
		isLoggedIn = false;
		onSeasonalWorld = false;
		isAlive = true;
		isDying = false;
		lastSaveTime = Instant.EPOCH.getEpochSecond();
		overlayManager.add(snailManModeOverlay);
		overlayManager.add(snailManModeMapOverlay);

		SnailManModePanel panel = injector.getInstance(SnailManModePanel.class);

		final BufferedImage icon = ImageUtil.loadImageResource(SnailManModePlugin.class, "/snail.png");

		navButton = NavigationButton.builder()
				.panel(panel)
				.tooltip("SnailMan Mode")
				.icon(icon)
				.priority(90)
				.build();

		clientToolbar.addNavigation(navButton);
	}

	@Override
	protected void shutDown()
	{
		overlayManager.remove(snailManModeOverlay);
		overlayManager.remove(snailManModeMapOverlay);
		clientToolbar.removeNavigation(navButton);
		infoBoxManager.removeIf(t -> t instanceof TeleportTimer);
	}

	private void addSnailmanIcon(ChatMessage chatMessage)
	{
		if(!isAlive) return;

		String name = chatMessage.getName();

		boolean isLocalPlayer = Text.standardize(name).equalsIgnoreCase(Text.standardize(client.getLocalPlayer().getName()));

		if(!isLocalPlayer) return;

		chatMessage.getMessageNode().setName(getImgTag(snailmanIconOffset)+Text.removeTags(name));
	}

	public WorldPoint getSnailWorldPoint() {
		return snailWorldPoint;
	}

	private WorldPoint getSavedSnailWorldPoint() {
		if(this.configManager.getRSProfileKey() == null) return null;

		final WorldPoint point = configManager.getRSProfileConfiguration(CONFIG_GROUP, CONFIG_KEY_SNAIL_LOC, WorldPoint.class);

		if(point == null) {
			return DEFAULT_SNAIL_START;
		}

		return point;
	}

	public void setSnailWorldPoint(WorldPoint point) {
		snailWorldPoint = point;
	}

	private void saveSnailWorldPoint() {
		if(this.configManager.getRSProfileKey() == null) return;

		this.configManager.setRSProfileConfiguration(CONFIG_GROUP, CONFIG_KEY_SNAIL_LOC, snailWorldPoint);
	}

	private void saveData() {
		if(this.configManager.getRSProfileKey() == null) return;

		saveSnailWorldPoint();
		configManager.setRSProfileConfiguration(CONFIG_GROUP, CONFIG_KEY_IS_ALIVE, isAlive);

		lastSaveTime = Instant.EPOCH.getEpochSecond();
	}

	public void reset() {
		setSnailWorldPoint(DEFAULT_SNAIL_START);
		pathfinder = null;
		isAlive = true;
		isDying = false;
		deathPoint = null;
		horrorCloseFlag = false;
		client.getLocalPlayer().setAnimation(AnimationID.IDLE);
		client.getLocalPlayer().setGraphic(-1);
		saveData();
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event) {
		if (client.isKeyPressed(KeyCode.KC_SHIFT) && event.getOption().equals(WALK_HERE) && DEV_MODE) {
			addMenuEntry(event, ADD_START);
			addMenuEntry(event, ADD_END);
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		if(gameStateChanged.getGameState() == GameState.LOGGED_IN && !isLoggedIn) {
			final WorldPoint point = getSavedSnailWorldPoint();
			String savedAlive = configManager.getRSProfileConfiguration(CONFIG_GROUP, CONFIG_KEY_IS_ALIVE);
			setSnailWorldPoint(point);
			currentPathIndex = 1;
			isAlive = savedAlive == null || Boolean.parseBoolean(savedAlive);
			isLoggedIn = true;
			onSeasonalWorld = isSeasonalWorld(client.getWorld());
		}
		else if(gameStateChanged.getGameState() == GameState.LOGIN_SCREEN && isLoggedIn){
			isLoggedIn = false;
			saveData();
			pathfinder = null;
		}
	}

	@Subscribe
	public void onGameTick(GameTick tick) {
		if(!isLoggedIn || config.pauseSnail() || isSeasonalWorld(client.getWorld())) return;

		tickCount++;

		WorldPoint playerPoint = client.getLocalPlayer().getWorldLocation();

		long distanceToSnail = playerPoint.distanceTo2D(snailWorldPoint);
		boolean snailShouldMove = tickCount % config.moveSpeed() == 0 || (distanceToSnail <= RECALCULATION_THRESHOLD && config.speedBoost());

		if(lastPlayerPoint == null) lastPlayerPoint = playerPoint;

		if(!snailShouldMove) return;

		if(pathfinder == null) {
			calculatePath(snailWorldPoint, playerPoint, false, false);
			return;
		}

		if(currentPathIndex < pathfinder.getPath().size() && pathfinder.isComplete) {
			int index = Math.max(pathfinder.getPath().size() - 1 - this.currentPathIndex, 0);
			WorldPoint target = pathfinder.getPath().get(index);
			setSnailWorldPoint(target);
			currentPathIndex++;
		}

		if(config.horrorMode()) {
			performHorrorModeChecks(distanceToSnail);
		}

		if(checkTouching()) {
			final ChatMessageBuilder message = new ChatMessageBuilder()
						.append(ChatColorType.HIGHLIGHT)
						.append("You have been touched by the snail. You are dead.");

			if(isAlive) {
				isDying = true;
				deathPoint = playerPoint;
				chatMessageManager.queue(QueuedMessage.builder()
						.type(ChatMessageType.GAMEMESSAGE)
						.runeLiteFormattedMessage(message.build())
						.build());

				client.playSoundEffect(SoundEffectID.ATTACK_HIT);

				client.getLocalPlayer().setAnimation(AnimationID.DEATH);
				client.getLocalPlayer().setAnimationFrame(0);
				client.getLocalPlayer().setGraphic(GraphicID.SNARE);

				isAlive = false;
				clientThread.invoke(() -> client.runScript(ScriptID.CHAT_PROMPT_INIT));
				saveData();
			}
		}
		recalculatePath();

		lastPlayerPoint = playerPoint;

		if(Instant.EPOCH.getEpochSecond() - lastSaveTime >= 60 && isLoggedIn) {
			saveData();
		}

		if(isDying) {
			if(!deathPoint.equals(playerPoint)) {
				isDying = false;
				client.getLocalPlayer().setAnimation(AnimationID.IDLE);
			}
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage chatMessage)
	{
		if (client.getGameState() != GameState.LOADING && client.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		if(client.getLocalPlayer().getName() == null) return;

		String name = Text.removeTags(chatMessage.getName());
		boolean isSelf = client.getLocalPlayer().getName().equalsIgnoreCase(name);

		switch (chatMessage.getType())
		{
			case PRIVATECHAT:
			case MODPRIVATECHAT:
			case FRIENDSCHAT:
			case CLAN_CHAT:
				if (!onSeasonalWorld && isSelf)
				{
					addSnailmanIcon(chatMessage);
				}
				break;
			case PUBLICCHAT:
			case MODCHAT:
				if (isSelf)
				{
					addSnailmanIcon(chatMessage);
				}
				break;
		}
	}

	@Subscribe
	public void onScriptCallbackEvent(ScriptCallbackEvent event)
	{
		if (!event.getEventName().equals("setChatboxInput"))
		{
			return;
		}

		updateChatbox();
	}

	@Subscribe
	public void onBeforeRender(BeforeRender event)
	{
		updateChatbox();
	}

	@Subscribe
	public void onHitsplatApplied(HitsplatApplied event) {
		if (event.getActor() instanceof Player) {
			final Player player = (Player) event.getActor();

			if (isDying) {
				isDying = false;
				client.getLocalPlayer().setAnimation(AnimationID.IDLE);
				client.getLocalPlayer().setGraphic(-1);
			}
		}
	}

	private void addMenuEntry(MenuEntryAdded event, String option) {
		client.createMenuEntry(1)
				.setOption(option)
				.setTarget(SnailManModePlugin.TRANSPORT)
				.setParam0(event.getActionParam0())
				.setParam1(event.getActionParam1())
				.setIdentifier(event.getIdentifier())
				.setType(MenuAction.RUNELITE)
				.onClick(this::onMenuOptionClicked);
	}

	private void onMenuOptionClicked(MenuEntry entry) {
		Player localPlayer = client.getLocalPlayer();

		WorldPoint currentLocation = localPlayer.getWorldLocation();
		if (entry.getOption().equals(ADD_START) && entry.getTarget().equals(TRANSPORT)) {
			transportStart = currentLocation;
		}

		if (entry.getOption().equals(ADD_END) && entry.getTarget().equals(TRANSPORT)) {
			WorldPoint transportEnd = client.getLocalPlayer().getWorldLocation();
			String transportText = transportStart.getX() + " " + transportStart.getY() + " " + transportStart.getPlane() + "\t" +
					currentLocation.getX() + " " + currentLocation.getY() + " " + currentLocation.getPlane() + "\t" +
					lastClick.getOption() + " " + Text.removeTags(lastClick.getTarget()) + " " + lastClick.getIdentifier();
			Pathfinder.writeTransportToFile(transportText);
			Transport transport = new Transport(transportStart, transportEnd);
			pathfinderConfig.getTransports().computeIfAbsent(transportStart, k -> new ArrayList<>()).add(transport);
		}

		if (entry.getType() != MenuAction.WALK) {
			lastClick = entry;
		}
	}

	private void performHorrorModeChecks(long distanceToSnail) {
		if(config.pauseSnail() || !isAlive) return;

		if(distanceToSnail < SNAIL_HORROR_DISTANCE && !horrorCloseFlag) {
			horrorCloseFlag = true;
			final ChatMessageBuilder message = new ChatMessageBuilder()
					.append(ChatColorType.HIGHLIGHT)
					.append("You see something moving in the fog...");

			chatMessageManager.queue(QueuedMessage.builder()
					.type(ChatMessageType.GAMEMESSAGE)
					.runeLiteFormattedMessage(message.build())
					.build());

			TeleportTimer timer = new TeleportTimer(Duration.of(10, ChronoUnit.SECONDS), itemManager.getImage(3327), this);
			infoBoxManager.addInfoBox(timer);

			client.playSoundEffect(SNAIL_HORROR_SOUND);
		}
		else if(distanceToSnail > 30 && horrorCloseFlag) {
			horrorCloseFlag = false;
		}
	}

	private void updateChatbox()
	{
		if(!isAlive) {
			return;
		}

		Widget chatboxTypedText = client.getWidget(WidgetInfo.CHATBOX_INPUT);

		if (snailmanIconOffset == -1)
		{
			return;
		}

		if (chatboxTypedText == null || chatboxTypedText.isHidden())
		{
			return;
		}

		String[] chatbox = chatboxTypedText.getText().split(":", 2);
		String rsn = Objects.requireNonNull(client.getLocalPlayer()).getName();

		chatboxTypedText.setText(getImgTag(snailmanIconOffset) + Text.removeTags(rsn) + ":" + chatbox[1]);
	}

	private static String getImgTag(int iconIndex)
	{
		return "<img=" + iconIndex + ">";
	}

	private boolean isSeasonalWorld(int worldNumber)
	{
		WorldResult worlds = worldService.getWorlds();
		if (worlds == null)
		{
			return false;
		}

		World world = worlds.findWorld(worldNumber);
		return world != null && world.getTypes().contains(WorldType.SEASONAL);
	}

	private void recalculatePath() {
		if(!isLoggedIn) return;

		if(client.isInInstancedRegion()) {
			pathfinder = null;
			return;
		}

		WorldPoint playerPoint = client.getLocalPlayer().getWorldLocation();
		final int distanceFromPlayer = snailWorldPoint.distanceTo2D(playerPoint);

		boolean forceRecalc = lastPlayerPoint.getPlane() != playerPoint.getPlane();

		if(distanceFromPlayer < RECALCULATION_THRESHOLD) {
			if(pathfinder.getStart().distanceTo2D(playerPoint) > 0) {
				calculatePath(snailWorldPoint, playerPoint, true, false);
				this.currentPathIndex = 1;
			}
		}
		else {
			// Limit number of recalculations done during player movement
			if(pathfinder.getStart().distanceTo2D(playerPoint) >= RECALCULATION_THRESHOLD || forceRecalc) {
				boolean useExistingPath = lastPlayerPoint.distanceTo(playerPoint) < 100;
				calculatePath(snailWorldPoint, playerPoint, forceRecalc, useExistingPath);
				this.currentPathIndex = 1;
			}
		}
	}

	private boolean checkTouching() {
		WorldPoint playerPoint = client.getLocalPlayer().getWorldLocation();
		final int distanceFromPlayer = snailWorldPoint.distanceTo2D(playerPoint);

		return distanceFromPlayer <= 0;
	}

	private void calculatePath(WorldPoint start, WorldPoint end, boolean force, boolean useExisting) {
		if(pathfinder != null && !pathfinder.isDone() && !force) return;

		if(client.isInInstancedRegion()) return;

		List<WorldPoint> existingPath = useExisting ? pathfinder.getPath() : null;

		pathfinder = new Pathfinder(pathfinderConfig, end, start, existingPath);

	}

	public Point mapWorldPointToGraphicsPoint(WorldPoint worldPoint)
	{
		RenderOverview ro = client.getRenderOverview();

		float pixelsPerTile = ro.getWorldMapZoom();

		Widget map = client.getWidget(WidgetInfo.WORLD_MAP_VIEW);
		if (map != null) {
			Rectangle worldMapRect = map.getBounds();

			int widthInTiles = (int) Math.ceil(worldMapRect.getWidth() / pixelsPerTile);
			int heightInTiles = (int) Math.ceil(worldMapRect.getHeight() / pixelsPerTile);

			Point worldMapPosition = ro.getWorldMapPosition();

			int yTileMax = worldMapPosition.getY() - heightInTiles / 2;
			int yTileOffset = (yTileMax - worldPoint.getY() - 1) * -1;
			int xTileOffset = worldPoint.getX() + widthInTiles / 2 - worldMapPosition.getX();

			int xGraphDiff = ((int) (xTileOffset * pixelsPerTile));
			int yGraphDiff = (int) (yTileOffset * pixelsPerTile);

			yGraphDiff -= pixelsPerTile - Math.ceil(pixelsPerTile / 2);
			xGraphDiff += pixelsPerTile - Math.ceil(pixelsPerTile / 2);

			yGraphDiff = worldMapRect.height - yGraphDiff;
			yGraphDiff += (int) worldMapRect.getY();
			xGraphDiff += (int) worldMapRect.getX();

			return new Point(xGraphDiff, yGraphDiff);
		}
		return null;
	}

	private void loadResources()
	{
		Map<SplitFlagMap.Position, byte[]> compressedRegions = new HashMap<>();
		HashMap<WorldPoint, List<Transport>> transports = new HashMap<>();

		try (ZipInputStream in = new ZipInputStream(SnailManModePlugin.class.getResourceAsStream("/collision-map.zip"))) {
			ZipEntry entry;
			while ((entry = in.getNextEntry()) != null) {
				String[] n = entry.getName().split("_");

				compressedRegions.put(
						new SplitFlagMap.Position(Integer.parseInt(n[0]), Integer.parseInt(n[1])),
						Util.readAllBytes(in)
				);
			}
		} catch (IOException e) {
			throw new UncheckedIOException(e);
		}

		try {
			String s = new String(Util.readAllBytes(SnailManModePlugin.class.getResourceAsStream("/transports.txt")), StandardCharsets.UTF_8);
			Scanner scanner = new Scanner(s);
			while (scanner.hasNextLine()) {
				String line = scanner.nextLine();

				if (line.startsWith("#") || line.isEmpty()) {
					continue;
				}

				Transport transport = new Transport(line);
				WorldPoint origin = transport.getOrigin();
				transports.computeIfAbsent(origin, k -> new ArrayList<>()).add(transport);
			}
		} catch (IOException e) {
			throw new RuntimeException(e);
		}

		pathfinderConfig = new PathfinderConfig(new CollisionMap(64, compressedRegions), transports, client);

		final IndexedSprite[] modIcons = client.getModIcons();

		if (snailmanIconOffset != -1 || modIcons == null)
		{
			return;
		}

		BufferedImage image = ImageUtil.loadImageResource(getClass(),"/helm.png");
		IndexedSprite indexedSprite = ImageUtil.getImageIndexedSprite(image, client);
		snailmanIconOffset = modIcons.length;

		final IndexedSprite[] newModIcons = Arrays.copyOf(modIcons, modIcons.length + 1);
		newModIcons[newModIcons.length - 1] = indexedSprite;

		client.setModIcons(newModIcons);
	}
}

package com.idyl.snailman;

import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxPriority;
import net.runelite.client.ui.overlay.infobox.Timer;

import javax.inject.Inject;
import java.awt.image.BufferedImage;
import java.time.Duration;
import java.time.temporal.ChronoUnit;

class TeleportTimer extends Timer
{
    TeleportTimer(Duration duration, BufferedImage image, SnailManModePlugin plugin)
    {
        super(duration.toMillis(), ChronoUnit.MILLIS, image, plugin);
        this.setTooltip("You are too afraid to cast a teleport spell.");
        setPriority(InfoBoxPriority.MED);
    }
}

package com.idyl.snailman;

import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

/**
 * This class represents a travel point between two WorldPoints.
 */
public class Transport {
    /** The starting point of this transport */
    @Getter
    private final WorldPoint origin;

    /** The ending point of this transport */
    @Getter
    private final WorldPoint destination;

    Transport(final String line) {
        final String DELIM = " ";

        String[] parts = line.split("\t");

        String[] parts_origin = parts[0].split(DELIM);
        String[] parts_destination = parts[1].split(DELIM);

        origin = new WorldPoint(
                Integer.parseInt(parts_origin[0]),
                Integer.parseInt(parts_origin[1]),
                Integer.parseInt(parts_origin[2]));
        destination = new WorldPoint(
                Integer.parseInt(parts_destination[0]),
                Integer.parseInt(parts_destination[1]),
                Integer.parseInt(parts_destination[2]));
    }

    Transport(final WorldPoint origin, final WorldPoint destination) {
        this.origin = origin;
        this.destination = destination;
    }
}
package com.idyl.snailman;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;

public class Util {
    public static byte[] readAllBytes(InputStream in) throws IOException {
        ByteArrayOutputStream result = new ByteArrayOutputStream();
        byte[] buffer = new byte[1024];

        while (true) {
            int read = in.read(buffer, 0, buffer.length);

            if (read == -1) {
                return result.toByteArray();
            }

            result.write(buffer, 0, read);
        }
    }

    public static void sleep(int time) {
        try {
            Thread.sleep(time);
        } catch (InterruptedException ignored) {
        }
    }
}
package com.idyl.snailman;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class SnailManModePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(SnailManModePlugin.class);
		RuneLite.main(args);
	}
}
