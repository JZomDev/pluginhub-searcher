package com.DoinkOink.UI;

import com.DoinkOink.LootListerConfig;
import com.DoinkOink.LootListerPlugin;
import com.DoinkOink.Misc.LootListManager;
import com.DoinkOink.Misc.LootListerItem;
import com.DoinkOink.Misc.LootListerSide;
import com.DoinkOink.Misc.LootListerStackSide;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.TextComponent;

import javax.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class LootListerOverlay extends OverlayPanel
{
	public static final int DEFAULT_OVERLAY_WIDTH = 100;

	private final LootListerConfig config;										// The mods config settings
	private final LootListerPlugin plugin;
	public LootListManager manager;

	private final List<LootListerItem> items = new ArrayList<>();				// The currently displayed items
	private final List<LootListerItem> itemQueue = new ArrayList<>();			// All the items that need to be displayed
	private final List<LootListerItem> itemsToRemove = new ArrayList<>();		// The current items being animated before being removed

	private final Map<String, Integer> npcFilters = new HashMap<>();			// All the per NPC value filters

	public FontMetrics fontMetrics;												// The current graphics font metrics which will be used to get an items text width
	private int currentOverlayWidth = DEFAULT_OVERLAY_WIDTH;					// How wide the current overlay is

	@Inject
	private LootListerOverlay(LootListerPlugin _plugin, LootListerConfig _config)
	{
		super(_plugin);

		plugin = _plugin;
		config = _config;

		setPosition(OverlayPosition.BOTTOM_LEFT);
		setPriority(PRIORITY_MED);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		fontMetrics = graphics.getFontMetrics();

		final int _fontHeight = fontMetrics.getHeight();

		// Draw all normal items first
		for (LootListerItem _item : manager.Items) {
			// Draw the item to the screen
			drawItem(graphics, _item, _fontHeight);
		}

		// Then draw all the items that are being removed
		for (LootListerItem _item : manager.ItemsToRemove) {
			drawItem(graphics, _item, _fontHeight);
		}

		// Always return the current max size of the overlay.
		return new Dimension(currentOverlayWidth, (config.iconSize() + config.spaceBetweenItems()) * (config.maxDisplayedItems() + 1));
	}

	private void drawItem(Graphics2D graphics, LootListerItem item, int fontHeight)
	{
		final TextComponent _textComponent = new TextComponent();

		graphics.drawImage(
			item.Image,
			item.CurrentPosition.x,
			item.CurrentPosition.y,
			config.iconSize(),
			config.iconSize(),
			null
		);

		_textComponent.setColor(config.textColor());
		_textComponent.setText(item.ItemText);
		_textComponent.setOutline(true);
		_textComponent.setPosition(new Point(
			item.CurrentPosition.x + config.iconSize() + config.spaceBetweenIconAndText(),
			item.CurrentPosition.y + (config.iconSize() / 2) + (fontHeight / 2)
		));

		_textComponent.render(graphics);
	}

	public int calcMaxOverlayWidth(List<LootListerItem> items)
	{
		return calcMaxOverlayWidth(items, 0);
	}

	public int calcMaxOverlayWidth(List<LootListerItem> items, int initialWidth)
	{
		// Check the given width with the default overlay width to see what is larger.
		//	This way the overlay's width will never be smaller than the default size.
		int maxX = Math.max(DEFAULT_OVERLAY_WIDTH, initialWidth);

		for(LootListerItem _item : items) {
			maxX = Math.max(maxX, config.iconSize() + (config.spaceBetweenIconAndText() * 2) + _item.TextWidth);
		}

		return currentOverlayWidth = maxX;
	}

	public int getMaxOverlayWidth() { return currentOverlayWidth; }
}

package com.DoinkOink;

import com.DoinkOink.Misc.LootListManager;
import com.DoinkOink.Misc.LootListerItem;
import com.DoinkOink.UI.LootListerOverlay;
import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ItemComposition;
import net.runelite.api.NPCComposition;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.PlayerLootReceived;
import net.runelite.client.events.ServerNpcLoot;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayMenuEntry;

import java.awt.image.BufferedImage;
import java.util.Collection;
import java.util.List;

import static net.runelite.api.MenuAction.RUNELITE_OVERLAY_CONFIG;
import static net.runelite.client.ui.overlay.OverlayManager.OPTION_CONFIGURE;

@Slf4j
@PluginDescriptor(
	name = "Loot Lister"
)
public class LootListerPlugin extends Plugin {

	@Inject
	private LootListerConfig config;

	@Inject
	private LootListerOverlay listerOverlay;

	private LootListManager lootListManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private ItemManager itemManager;

	@Override
	protected void startUp() throws Exception
	{
		OverlayMenuEntry _menuEntry = new OverlayMenuEntry(RUNELITE_OVERLAY_CONFIG, OPTION_CONFIGURE, "Loot Lister Overlay");
		listerOverlay.getMenuEntries().add(_menuEntry);
		overlayManager.add(listerOverlay);

		lootListManager = new LootListManager(config, listerOverlay);
		listerOverlay.manager = lootListManager;
	}

	@Override
	protected void shutDown() throws Exception
	{
		lootListManager.clearItemsFromOverlay();

		overlayManager.remove(listerOverlay);
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		lootListManager.clearItemsFromOverlay();
	}

	@Subscribe
	public void onConfigChanged(final ConfigChanged event)
	{
		final List<String> _configKeysToClear = List.of(
			"iconSize",
			"maxDisplayedItems",
			"maxDisplayTime",
			"spaceBetweenIconAndText",
			"spaceBetweenItems",
			"sideToAnimateFrom",
			"stackDirection"
		);

		if (_configKeysToClear.contains(event.getKey()))
			lootListManager.setAllItemsForRemoval();

		if (event.getKey().equals("npcFilters"))
			lootListManager.updateNpcFilters();
	}

	@Subscribe
	public void onGameTick(GameTick event) { lootListManager.onTick(); }

	@Subscribe
	public void onClientTick(ClientTick event) { lootListManager.updateItems(); }

	// Add loot to the queue when an NPC is killed/looted
	@Subscribe
	public void onServerNpcLoot(final ServerNpcLoot event)
	{
		final NPCComposition _npc = event.getComposition();

		addLoot(_npc, event.getItems());
	}

	// Add loot to the queue when a player is killed in PvP
	@Subscribe
	public void onPlayerLootReceived(final PlayerLootReceived playerLootReceived)
	{
		addLoot(null, playerLootReceived.getItems());
	}

	// Receives the npc and the loot it dropped and creates a LootListerItem per
	//	item that was dropped and add it to the item queue.
	private void addLoot(NPCComposition _npc, Collection<ItemStack> _items)
	{
		for (ItemStack _item : _items) {
			ItemComposition _ic = itemManager.getItemComposition(_item.getId());
			int _realId = _ic.getNote() == -1 ? _ic.getId() : _ic.getLinkedNoteId();
			int _price = Math.max(itemManager.getItemPrice(_realId), _ic.getHaPrice());
			BufferedImage _image = itemManager.getImage(_realId, _item.getQuantity(), false);

			lootListManager.addDropToQueue(new LootListerItem(_realId, _npc, _ic.getName(), _item.getQuantity(), _price, _image));
		}
	}

	@Provides
	LootListerConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(LootListerConfig.class);
	}
}

package com.DoinkOink;

import com.DoinkOink.Misc.DisplayTimeMethod;
import com.DoinkOink.Misc.LootListerSide;
import com.DoinkOink.Misc.LootListerStackSide;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

import java.awt.Color;

@ConfigGroup("Loot Lister")
public interface LootListerConfig extends Config
{
	@ConfigSection(
		name = "Display",
		description = "Display settings.",
		position = 0
	)
	String displaySection = "Display";

	@ConfigSection(
		name = "Animation",
		description = "Animation settings.",
		position = 1
	)
	String animationSection = "Animation";

	@ConfigItem(
		keyName = "maxDisplayedItems",
		name = "Max Displayed Items",
		description = "How many items can be shown at once.",
		section = displaySection
	)
	default int maxDisplayedItems()
	{
		return 5;
	}

	@ConfigItem(
		keyName = "minValueToDisplay",
		name = "Minimum Value",
		description = "The minimum value an item must be to be displayed.",
		section = displaySection
	)
	default int minValueToDisplay() { return 1000; }

	@ConfigItem(
		keyName = "iconSize",
		name = "Icon Size",
		description = "How big item icons will be.",
		section = displaySection
	)
	default int iconSize()
	{
		return 26;
	}

	@ConfigItem(
		keyName = "maxDisplayTime",
		name = "Max display time",
		description = "How many ticks the last item in the list will be displayed on screen. If set to 0 it will show until the max item displayed has been reached.",
		section = displaySection
	)
	default double maxDisplayTime() { return 10; }

	@ConfigItem(
		keyName = "spaceBetweenItems",
		name =  "Space Between Items",
		description = "How much vertical space is between each displayed item.",
		section = displaySection
	)
	default int spaceBetweenItems() { return 2; }

	@ConfigItem(
		keyName = "spaceBetweenIconAndText",
		name =  "Space Between Icons and Text",
		description = "How much space is between an items icon and text.",
		section = displaySection
	)
	default int spaceBetweenIconAndText() { return 2; }

	@ConfigItem(
		keyName = "textColor",
		name = "Text Color",
		description = "What color the text displays in.",
		section = displaySection
	)
	default Color textColor() { return Color.yellow; }

	@ConfigItem(
		keyName = "displayTimeMethod",
		name = "Time Remove Method",
		description = "What method should be used to remove items from the list. One At A Time: Remove items one at a time with each item taking the Max Display Time. By Drop Group: Remove all items from the same drop at the same time. Time Since Last Drop: Items will only disappear if an item isn't added within the Max Display Time.",
		section = displaySection
	)
	default DisplayTimeMethod displayTimeMethod() { return DisplayTimeMethod.ONE_AT_A_TIME; }

	@ConfigItem(
		keyName = "npcFilters",
		name = "NPC Specific Values",
		description = "Comma separated display values per NPC. To add an NPC put their {name or NPC ID}:{min value} Example: Cow:100,Goblin:20",
		section = displaySection,
		position = 100
	)
	default String npcFilters() { return ""; }

	@ConfigItem(
		keyName = "sideToAnimateFrom",
		name = "Direction to appear from",
		description = "Which side the items should appear and disappear from.",
		section = animationSection,
		position = 0
	)
	default LootListerSide sideToAnimateFrom() { return LootListerSide.RIGHT;}

	@ConfigItem(
		keyName = "stackDirection",
		name = "Item stack direction",
		description = "What direction items should stack in the list.",
		section = animationSection,
		position = 1
	)
	default LootListerStackSide stackDirection() { return LootListerStackSide.BOTTOM; }

	@ConfigItem(
		keyName = "horizontalTextSpeed",
		name =  "Horizontal Scroll Speed",
		description = "How fast the text will scroll left and right.",
		section = animationSection,
		position = 2
	)
	default int horizontalTextSpeed() { return 10; }

	@ConfigItem(
		keyName = "verticalTextSpeed",
		name =  "Vertical Scroll Speed",
		description = "How fast the text will scroll up and down.",
		section = animationSection,
		position = 3
	)
	default int verticalTextSpeed() { return 5; }
}

package com.DoinkOink.Misc;

public enum LootListerStackSide {
	TOP,
	BOTTOM
}

package com.DoinkOink.Misc;

public enum DisplayTimeMethod {
	ONE_AT_A_TIME,
	BY_DROP_GROUP,
	TIME_SINCE_LAST_DROP
}

package com.DoinkOink.Misc;

public enum LootListerSide {
	LEFT,
	RIGHT
}

package com.DoinkOink.Misc;

import com.DoinkOink.LootListerConfig;
import net.runelite.api.NPCComposition;

import java.awt.Point;
import java.awt.image.BufferedImage;

public class LootListerItem
{
	public final int ID;
	public final String SourceName;
	public final String SourceID;
	public final String ItemText;
	public final int Quantity;
	public final int Price;
	public final BufferedImage Image;

	public Point CurrentPosition = new Point(0,0);
	public Point NextPosition = new Point(0,0);
	public Point StartingPosition = new Point(0, 0);
	public int TextWidth = 0;
	public double TicksDisplayed = 0;
	public boolean JustAdded = true;
	public boolean IsTextMoving = false;
	public boolean MarkedForDelete = false;

	public LootListerItem(int _id, NPCComposition _npc, String _name, int _quantity, int _price, BufferedImage _image)
	{
		ID = _id;
		ItemText = (_quantity > 1 ? _quantity + " " : "") + _name;
		Quantity = _quantity;
		Price = _price * _quantity;
		Image = _image;

		if (_npc != null) {
			SourceName = _npc.getName().toLowerCase();
			SourceID = Integer.toString(_npc.getId());
		} else {
			SourceName = "";
			SourceID = "";
		}
	}

	public void UpdatePosition(LootListerConfig config, boolean isRemoving)
	{
		final int _verticalScrollMod = config.stackDirection() == LootListerStackSide.BOTTOM ? -1 : 1;
		int _horizontalScrollMod = config.sideToAnimateFrom() == LootListerSide.RIGHT ? -1 : 1;

		if (isRemoving)
			_horizontalScrollMod = _horizontalScrollMod == -1 ? 1 : -1;

		// Preemptively set the text to not moving as it will be set true later if it is moving.
		IsTextMoving = false;

		// Vertically animate the text if the CurrentPosition isn't the NextPosition
		if (GetRemainingVerticalDistance() < config.verticalTextSpeed()) {
			CurrentPosition.y = NextPosition.y;
		} else if (GetRemainingVerticalDistance() > 0) {
			CurrentPosition.y += config.verticalTextSpeed() * _verticalScrollMod;
			IsTextMoving = true;
		}

		// Horizontally animate the text if the CurrentPosition isn't the NextPosition
		if (GetRemainingHorizontalDistance() < config.horizontalTextSpeed()) {
			CurrentPosition.x = NextPosition.x;

			if (isRemoving)
				MarkedForDelete = true;
			else
				JustAdded = false;
		} else if (GetRemainingHorizontalDistance() > 0) {
			CurrentPosition.x += config.horizontalTextSpeed() * _horizontalScrollMod;
			IsTextMoving = true;
		}
	}

	public void SetNextPosition(Point _nextPos)
	{
		StartingPosition = new Point(CurrentPosition.x, CurrentPosition.y);
		NextPosition = _nextPos;
	}

	public void SetFirstPosition(Point _start, Point _end)
	{
		CurrentPosition = _start;
		SetNextPosition(_end);
	}

	public void SetHorizontalPosition(int _x)
	{
		CurrentPosition.x = StartingPosition.x = NextPosition.x = _x;
	}

	public double GetRemainingHorizontalDistance()
	{
		return StartingPosition.x < NextPosition.x
			? NextPosition.getX() - CurrentPosition.getX()
			: CurrentPosition.getX() - NextPosition.getX();
	}
	private double GetRemainingVerticalDistance()
	{
		return StartingPosition.y < NextPosition.y
			? NextPosition.getY() - CurrentPosition.getY()
			: CurrentPosition.getY() - NextPosition.getY();
	}

	private double GetTotalVerticalDistance()
	{
		return StartingPosition.y < NextPosition.y
			? NextPosition.getY() - StartingPosition.getY()
			: StartingPosition.getY() - NextPosition.getY();
	}

	public double GetVerticalDistancePercentage()
	{
		return GetRemainingVerticalDistance() / GetTotalVerticalDistance();
	}
}

package com.DoinkOink.Misc;

import com.DoinkOink.LootListerConfig;
import com.DoinkOink.UI.LootListerOverlay;

import javax.inject.Inject;
import java.awt.Point;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class LootListManager {

	private final LootListerConfig config;										// The mods config settings
	private final LootListerOverlay overlay;

	public final List<LootListerItem> Items = new ArrayList<>();				// The currently displayed items
	public final List<LootListerItem> ItemsToRemove = new ArrayList<>();		// The current items being animated before being removed
	private final List<LootListerItem> itemQueue = new ArrayList<>();			// All the items that need to be displayed
	private final Map<String, Integer> npcFilters = new HashMap<>();			// All the per NPC value filters

	private int timeSinceLastItemAdded = 0;

	@Inject
	public LootListManager(LootListerConfig _config, LootListerOverlay _overlay)
	{
		config = _config;
		overlay = _overlay;

		updateNpcFilters();
	}

	// Receive a LootListerItem and decide if it needs to go to the item queue or be immediately displayed
	public void addDropToQueue(LootListerItem item)
	{
		timeSinceLastItemAdded = 0;

		// Set the initial value to check to the configured global amount
		int _minValueToCheck = config.minValueToDisplay();

		// Check to see if the source NPC is in the configured NPC Filter dictionary and if it is change the value to check to the new value
		if (!item.SourceName.isEmpty() && npcFilters.containsKey(item.SourceName))
			_minValueToCheck = npcFilters.get(item.SourceName);
		else if (!item.SourceID.isEmpty() && npcFilters.containsKey(item.SourceID))
			_minValueToCheck = npcFilters.get(item.SourceID);

		// Now check to see if the item's price surpasses the min value
		if (item.Price < _minValueToCheck)
			return;

		itemQueue.add(0, item);

		// If there isn't currently anything in the queue go ahead and add it to the overlay
		if (Items.size() == 0)
			addNextDropToOverlay();
	}

	// Set up the last item in the queue to be displayed on the screen
	private void addNextDropToOverlay()
	{
		// Double check that if there isn't anything in the queue for whatever reason we break out so no errors occur
		if (itemQueue.size() == 0)
			return;

		// If the overlay is currently displaying more than configured we need to set up removal of the last item
		// 	from the overlay.
		if (Items.size() + 1 > config.maxDisplayedItems())
			setItemForRemoval(Items.remove(Items.size()-1));

		// Get the item that will be added to the overlay. This will always be the last item from the queue (FIFO)
		LootListerItem _itemToAdd = itemQueue.remove(itemQueue.size()-1);

		// Set the items text width to be used later
		_itemToAdd.TextWidth = overlay.fontMetrics.stringWidth(_itemToAdd.ItemText);

		// Check to see if add this item will change the current max width
		int _itemWidth = config.iconSize() + (config.spaceBetweenIconAndText() * 2) + _itemToAdd.TextWidth;
		int _overlayWidth = overlay.calcMaxOverlayWidth(Items, _itemWidth);

		// Set up the initial screen positions of the item based on some animation configurations
		_itemToAdd.SetFirstPosition(
			// Starting Point
			new Point(
				config.sideToAnimateFrom() == LootListerSide.RIGHT ? _overlayWidth : -(_itemToAdd.TextWidth + config.iconSize()),
				config.stackDirection() == LootListerStackSide.BOTTOM ? (config.iconSize() + config.spaceBetweenItems()) * (config.maxDisplayedItems()) : 0
			),
			// Ending Point
			new Point(
				config.sideToAnimateFrom() == LootListerSide.RIGHT ? _overlayWidth - (config.iconSize() + _itemToAdd.TextWidth + (config.spaceBetweenIconAndText() * 2)) : config.spaceBetweenIconAndText(),
				config.stackDirection() == LootListerStackSide.BOTTOM ? (config.iconSize() + config.spaceBetweenItems()) * (config.maxDisplayedItems()) : 0
			)
		);

		// Add the item to the currently displayed items list
		Items.add(0, _itemToAdd);

		// Finally update all currently displayed items X positions in case this item changes the maximum width
		updateItemHorizontalPositions();
	}

	public void updateItems()
	{
		boolean _isItemMoving = false;

		for(LootListerItem _item : Items)
		{
			_item.UpdatePosition(config, false);

			if (!_isItemMoving)
				_isItemMoving = _item.IsTextMoving;
		}

		for(LootListerItem _item : ItemsToRemove) { _item.UpdatePosition(config, true); }

		for(int i = ItemsToRemove.size()-1; i >= 0; i--)
		{
			LootListerItem _itemToRemove = ItemsToRemove.get(i);
			if (_itemToRemove.MarkedForDelete)
				ItemsToRemove.remove(i);
		}

		// Update all items vertical animations if no text is currently moving and there's an item waiting to be added
		//	to the overlay. This will eventually add the next item once the scrolling animation is halfway finished.
		if (!_isItemMoving && itemQueue.size() != 0)
			startScrollItems();

		// If text is currently moving and wasn't just added we need to be checking when we can add the next
		// 	item from the queue.
		if (_isItemMoving && !Items.get(0).JustAdded) {
			LootListerItem _itemToCheck = Items.get(0);

			// If the item to check, either the first or the second based on where we're at in the scrolling animation,
			//	has reached its halfway point we can add the next drop to the overlay.
			if (_itemToCheck.GetVerticalDistancePercentage() <= 0.5)
				addNextDropToOverlay();
		}

		// Check to see if we need to remove the last item in the list because it's been showing for too long
		if (Items.size() != 0) {
			LootListerItem _lastItem = Items.get(Items.size() - 1);

			if (config.maxDisplayTime() != 0 && _lastItem.TicksDisplayed >= config.maxDisplayTime())
				setItemForRemoval(Items.remove(Items.size() - 1));
		}

		// If there's an item  in the queue and there's no items currently being shown add it to the overlay.
		if (Items.size() == 0 && itemQueue.size() != 0)
			addNextDropToOverlay();
	}

	// Set up the next position for all items to start scrolling them up/down
	private void startScrollItems()
	{
		final int _verticalScrollMod = config.stackDirection() == LootListerStackSide.BOTTOM ? -1 : 1;
		for (LootListerItem _item : Items)
		{
			_item.SetNextPosition(new Point(
				_item.CurrentPosition.x,
				_item.CurrentPosition.y + ((config.iconSize() + config.spaceBetweenItems()) * _verticalScrollMod)
			));
		}
	}

	// Update all currently displayed items X positions based on the current max overlay width
	public void updateItemHorizontalPositions()
	{
		// As this will only ever be called when an item is added to the overlay we have to skip the first item
		//	so the horizontal animation doesn't break.
		for (int i = 1; i < Items.size(); i++) {
			LootListerItem _item = Items.get(i);
			// Set the horizontal position based on which direction the text is animating from
			_item.SetHorizontalPosition(
				config.sideToAnimateFrom() == LootListerSide.RIGHT
					? overlay.getMaxOverlayWidth() - (config.iconSize() + _item.TextWidth + (config.spaceBetweenIconAndText() * 2))
					: config.spaceBetweenIconAndText()
			);
		}
	}

	// Removes the given item from the overlay list and adds it to the removal list, so it can still be animated
	//	before being fully removed.
	private void setItemForRemoval(LootListerItem _item)
	{
		ItemsToRemove.add(_item);

		_item.SetNextPosition(new Point(
			config.sideToAnimateFrom() == LootListerSide.RIGHT ? overlay.getMaxOverlayWidth() : -(_item.TextWidth + config.iconSize()),
			_item.CurrentPosition.y
		));
	}

	public void setAllItemsForRemoval()
	{
		for(int i = Items.size()-1; i >= 0; i--)
		{
			setItemForRemoval(Items.remove(i));
		}
	}

	// Remove all items from the screen. This will be called when the player changes config settings as it breaks the
	//	layout if we don't clear them.
	public void clearItemsFromOverlay() { Items.clear(); }

	public void onTick()
	{
		var _displayTimeMethod = config.displayTimeMethod();

		if (_displayTimeMethod == DisplayTimeMethod.ONE_AT_A_TIME)
		{
			Items.get(Items.size()-1).TicksDisplayed += 1;
		}
		else if (_displayTimeMethod == DisplayTimeMethod.BY_DROP_GROUP)
		{
			for(LootListerItem _item : Items) { _item.TicksDisplayed += 1; }
		}
		else if (_displayTimeMethod == DisplayTimeMethod.TIME_SINCE_LAST_DROP)
		{
			timeSinceLastItemAdded += 1;

			if (timeSinceLastItemAdded >= config.maxDisplayTime())
				setAllItemsForRemoval();
		}
	}

	// Update the NPC filtering list to later be used when checking to see if an item should be added to the overlay
	public void updateNpcFilters()
	{
		npcFilters.clear();

		final String[] _filters = config.npcFilters().split(",");
		for (String _filter : _filters) {
			try {
				final String[] _splitFilter = _filter.split(":");

				if (npcFilters.containsKey(_splitFilter[0].trim().toLowerCase()))
					continue;

				npcFilters.put(_splitFilter[0].trim().toLowerCase(), Integer.parseInt(_splitFilter[1].trim()));
			} catch (Exception ignored) { }
		}
	}
}

package com.example;

import com.DoinkOink.LootListerPlugin;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class LootListerTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(LootListerPlugin.class);
		RuneLite.main(args);
	}
}
