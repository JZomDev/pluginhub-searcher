package com.DoinkOink.UI;

import com.DoinkOink.LootListerConfig;
import com.DoinkOink.LootListerPlugin;
import com.DoinkOink.Misc.LootListerItem;
import com.DoinkOink.Misc.LootListerSide;
import com.DoinkOink.Misc.LootListerStackSide;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.TextComponent;

import javax.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class LootListerOverlay extends OverlayPanel
{
	private static final int DEFAULT_OVERLAY_WIDTH = 100;

	private final LootListerConfig config;										// The mods config settings

	private final List<LootListerItem> items = new ArrayList<>();				// The currently displayed items
	private final List<LootListerItem> itemQueue = new ArrayList<>();			// All the items that need to be displayed
	private final List<LootListerItem> itemsToRemove = new ArrayList<>();		// The current items being animated before being removed

	private final Map<String, Integer> npcFilters = new HashMap<>();			// All the per NPC value filters

	private FontMetrics fontMetrics;											// The current graphics font metrics which will be used to get an items text width
	private int currentOverlayWidth = DEFAULT_OVERLAY_WIDTH;					// How wide the current overlay is

	@Inject
	private LootListerOverlay(LootListerConfig _config, LootListerPlugin _plugin)
	{
		super(_plugin);

		config = _config;

		setPosition(OverlayPosition.BOTTOM_LEFT);
		setPriority(PRIORITY_MED);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		fontMetrics = graphics.getFontMetrics();

		final int _fontHeight = fontMetrics.getHeight();
		final int _verticalScrollMod = config.stackDirection() == LootListerStackSide.BOTTOM ? -1 : 1;
		final int _horizontalScrollMod = config.sideToAnimateFrom() == LootListerSide.LEFT ? -1 : 1;

		boolean _isTextMoving = false;

		for (LootListerItem _item : items) {
			// Draw the item to the screen
			drawItem(graphics, _item, _fontHeight);

			// Set the current max width based on this items text width alongside the configured icon size.
			currentOverlayWidth = Math.max(currentOverlayWidth, config.iconSize() + (config.spaceBetweenIconAndText() * 2) + _item.TextWidth);

			// Vertically animate the text if the CurrentPosition isn't the NextPosition
			if (_item.GetRemainingVerticalDistance() < config.verticalTextSpeed()) {
				_item.CurrentPosition.y = _item.NextPosition.y;
			} else if (_item.GetRemainingVerticalDistance() > 0) {
				_item.CurrentPosition.y += config.verticalTextSpeed() * _verticalScrollMod;
				_isTextMoving = true;
			}

			// Horizontally animate the text if the CurrentPosition isn't the NextPosition
			if (_item.GetRemainingHorizontalDistance() < config.horizontalTextSpeed()) {
				_item.CurrentPosition.x = _item.NextPosition.x;
				_item.JustAdded = false;
			} else if (_item.GetRemainingHorizontalDistance() > 0) {
				_item.CurrentPosition.x += config.horizontalTextSpeed() * _horizontalScrollMod;
				_isTextMoving = true;
			}
		}

		// Animate all the items that need to be removed from the screen
		for(int i = itemsToRemove.size()-1; i >= 0; i--) {
			LootListerItem _itemToRemove = itemsToRemove.get(i);

			if (_itemToRemove.GetRemainingHorizontalDistance() <= 0) {
				itemsToRemove.remove(i);
			} else {
				drawItem(graphics, _itemToRemove, _fontHeight);
				_itemToRemove.CurrentPosition.x -= config.horizontalTextSpeed() * _horizontalScrollMod;
			}
		}

		// Update all items vertical animations if no text is currently moving and there's an item waiting to be added
		//	to the overlay. This will eventually add the next item once the scrolling animation is halfway finished.
		if (!_isTextMoving && itemQueue.size() != 0)
			startScrollItems();

		// If text is currently moving and wasn't just added we need to be checking when we can add the next
		// 	item from the queue.
		if (_isTextMoving && !items.get(0).JustAdded) {
			LootListerItem _itemToCheck = items.get(0);

			// If the item to check, either the first or the second based on where we're at in the scrolling animation,
			//	has reached its halfway point we can add the next drop to the overlay.
			if (_itemToCheck.GetVerticalDistancePercentage() <= 0.5)
				addNextDropToOverlay();
		}

		// Check to see if we need to remove the last item in the list because it's been showing for too long
		if (items.size() != 0) {
			LootListerItem _lastItem = items.get(items.size() - 1);

			if (config.maxDisplayTime() != 0 && _lastItem.TimeDisplayed >= config.maxDisplayTime())
				setItemForRemoval(items.remove(items.size() - 1));
		}

		// If there's an item  in the queue and there's no items currently being shown add it to the overlay.
		if (items.size() == 0 && itemQueue.size() != 0)
			addNextDropToOverlay();

		// Always return the current max size of the overlay.
		return new Dimension(currentOverlayWidth, (config.iconSize() + config.spaceBetweenItems()) * (config.maxDisplayedItems() + 1));
	}

	private void drawItem(Graphics2D _graphics, LootListerItem _item, int _fontHeight)
	{
		final TextComponent _textComponent = new TextComponent();

		_graphics.drawImage(
			_item.Image,
			_item.CurrentPosition.x,
			_item.CurrentPosition.y,
			config.iconSize(),
			config.iconSize(),
			null
		);

		_textComponent.setColor(Color.yellow);
		_textComponent.setText(_item.ItemText);
		_textComponent.setOutline(true);
		_textComponent.setPosition(new Point(
			_item.CurrentPosition.x + config.iconSize() + config.spaceBetweenIconAndText(),
			_item.CurrentPosition.y + (config.iconSize() / 2) + (_fontHeight / 2)
		));

		_textComponent.render(_graphics);
	}

	public void addDropToQueue(LootListerItem _item)
	{
		// Set the initial value to check to the configured global ammount
		int _minValueToCheck = config.minValueToDisplay();
		
		// Check to see if the source NPC is in the configured NPC Filter dictionary and if it is change the value to check to the new value
		if (!_item.SourceName.isEmpty() && npcFilters.containsKey(_item.SourceName))
			_minValueToCheck = npcFilters.get(_item.SourceName);
		else if (!_item.SourceID.isEmpty() && npcFilters.containsKey(_item.SourceID))
			_minValueToCheck = npcFilters.get(_item.SourceID);
		
		// Now check to see if the item's price surpasses the min value
		if (_item.Price < _minValueToCheck)
			return;

		itemQueue.add(0, _item);

		// If there isn't currently anything in the queue go ahead and add it to the overlay
		if (items.size() == 0)
			addNextDropToOverlay();
	}

	// Set up the last item in the queue to be displayed on the screen
	public void addNextDropToOverlay()
	{
		// Double check that if there isn't anything in the queue for whatever reason we break out so no errors occur
		if (itemQueue.size() == 0)
			return;

		// If the overlay is currently displaying more than configured we need to set up removal of the last item
		// 	from the overlay.
		if (items.size() + 1 > config.maxDisplayedItems())
			setItemForRemoval(items.remove(items.size()-1));

		// Get the item that will be added to the overlay. This will always be the last item from the queue (FIFO)
		LootListerItem _itemToAdd = itemQueue.remove(itemQueue.size()-1);

		// Set the items text width to be used later
		_itemToAdd.TextWidth = fontMetrics.stringWidth(_itemToAdd.ItemText);

		// Check to see if add this item will change the current max width
		currentOverlayWidth = getMaxX(config.iconSize() + (config.spaceBetweenIconAndText() * 2) + _itemToAdd.TextWidth);

		// Set up the initial screen positions of the item based on some animation configurations
		_itemToAdd.SetFirstPosition(
			// Starting Point
			new Point(
				config.sideToAnimateFrom() == LootListerSide.LEFT ? currentOverlayWidth : -(_itemToAdd.TextWidth + config.iconSize()),
				config.stackDirection() == LootListerStackSide.BOTTOM ? (config.iconSize() + config.spaceBetweenItems()) * (config.maxDisplayedItems()) : 0
			),
			// Ending Point
			new Point(
				config.sideToAnimateFrom() == LootListerSide.LEFT ? currentOverlayWidth - (config.iconSize() + _itemToAdd.TextWidth + (config.spaceBetweenIconAndText() * 2)) : config.spaceBetweenIconAndText(),
				config.stackDirection() == LootListerStackSide.BOTTOM ? (config.iconSize() + config.spaceBetweenItems()) * (config.maxDisplayedItems()) : 0
			)
		);

		// Add the item to the currently displayed items list
		items.add(0, _itemToAdd);

		// Finally update all currently displayed items X positions in case this item changes the maximum width
		updateItemHorizontalPositions();
	}

	// Update all currently displayed items X positions based on the current max overlay width
	public void updateItemHorizontalPositions()
	{
		// As this will only ever be called when an item is added to the overlay we have to skip the first item
		//	so the horizontal animation doesn't break.
		for (int i = 1; i < items.size(); i++) {
			LootListerItem _item = items.get(i);
			// Set the horizontal position based on which direction the text is animating from
			_item.SetHorizontalPosition(
				config.sideToAnimateFrom() == LootListerSide.LEFT
					? currentOverlayWidth - (config.iconSize() + _item.TextWidth + (config.spaceBetweenIconAndText() * 2))
					: config.spaceBetweenIconAndText()
			);
		}
	}

	// Remove all items from the screen. This will be called when the player changes config settings as it breaks the
	//	layout if we don't clear them.
	public void clearItemsFromOverlay()
	{
		items.clear();
	}

	// Update the NPC filtering list to later be used when checking to see if an item should be added to the overlay
	public void updateNpcFilters()
	{
 		npcFilters.clear();

		final String[] _filters = config.npcFilters().split(",");
		for (String _filter : _filters) {
			try {
				final String[] _splitFilter = _filter.split(":");

				if (npcFilters.containsKey(_splitFilter[0].trim().toLowerCase()))
					continue;

				npcFilters.put(_splitFilter[0].trim().toLowerCase(), Integer.parseInt(_splitFilter[1].trim()));
			} catch (Exception ignored) { }
		}
	}

	// Add 0.6s to the last items timer every tick, so it can be removed from the screen if configured to do so.
	public void updateOldestItemTimer()
	{
		if (items.size() > 0)
			items.get(items.size()-1).TimeDisplayed += 0.6;
	}

	// Set up the next position for all items to start scrolling them up/down
	private void startScrollItems()
	{
		final int _verticalScrollMod = config.stackDirection() == LootListerStackSide.BOTTOM ? -1 : 1;
		for (LootListerItem _item : items)
		{
			_item.SetNextPosition(new Point(
				_item.CurrentPosition.x,
				_item.CurrentPosition.y + ((config.iconSize() + config.spaceBetweenItems()) * _verticalScrollMod)
			));
		}
	}

	// Removes the given item from the overlay list and adds it to the removal list, so it can still be animated
	//	before being fully removed.
	private void setItemForRemoval(LootListerItem _item)
	{
		itemsToRemove.add(_item);

		_item.SetNextPosition(new Point(
			config.sideToAnimateFrom() == LootListerSide.LEFT ? currentOverlayWidth : -(_item.TextWidth + config.iconSize()),
			_item.CurrentPosition.y
		));
	}

	// Go through all currently displayed items and get the maximum width the overlay needs to be.
	private int getMaxX(int _maxX)
	{
		// Check the given width with the default overlay width to see what is larger.
		//	This way the overlay's width will never be smaller than the default size.
		_maxX = Math.max(DEFAULT_OVERLAY_WIDTH, _maxX);

		for(LootListerItem _item : items) {
			_maxX = Math.max(_maxX, config.iconSize() + (config.spaceBetweenIconAndText() * 2) + _item.TextWidth);
		}

		return _maxX;
	}

}

package com.DoinkOink;

import com.DoinkOink.Misc.LootListerItem;
import com.DoinkOink.UI.LootListerOverlay;
import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.api.NPCComposition;
import net.runelite.api.Player;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.PlayerLootReceived;
import net.runelite.client.events.ServerNpcLoot;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.client.plugins.loottracker.PluginLootReceived;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.util.Text;
import net.runelite.http.api.loottracker.LootRecordType;

import java.awt.image.BufferedImage;
import java.util.Collection;
import java.util.List;

import static net.runelite.api.MenuAction.RUNELITE_OVERLAY_CONFIG;
import static net.runelite.client.ui.overlay.OverlayManager.OPTION_CONFIGURE;

@Slf4j
@PluginDescriptor(
	name = "Loot Lister"
)
public class LootListerPlugin extends Plugin {
	@Inject
	private LootListerOverlay listerOverlay;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private ItemManager itemManager;

	@Override
	protected void startUp() throws Exception
	{
		OverlayMenuEntry _menuEntry = new OverlayMenuEntry(RUNELITE_OVERLAY_CONFIG, OPTION_CONFIGURE, "Loot Lister Overlay");

		listerOverlay.getMenuEntries().add(_menuEntry);

		overlayManager.add(listerOverlay);
	}

	@Override
	protected void shutDown() throws Exception
	{
		listerOverlay.clearItemsFromOverlay();

		overlayManager.remove(listerOverlay);
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		listerOverlay.clearItemsFromOverlay();
	}

	@Subscribe
	public void onConfigChanged(final ConfigChanged event)
	{
		final List<String> _configKeysToClear = List.of(
			"iconSize",
			"maxDisplayedItems",
			"maxDisplayTime",
			"spaceBetweenIconAndText",
			"spaceBetweenItems",
			"sideToAnimateFrom",
			"stackDirection"
		);

		if (_configKeysToClear.contains(event.getKey()))
			listerOverlay.clearItemsFromOverlay();

		if (event.getKey().equals("npcFilters"))
			listerOverlay.updateNpcFilters();
	}

	@Subscribe
	public void onServerNpcLoot(final ServerNpcLoot event)
	{
		final NPCComposition _npc = event.getComposition();

		addLoot(_npc, event.getItems());
	}

	@Subscribe
	public void onPlayerLootReceived(final PlayerLootReceived playerLootReceived)
	{
		addLoot(null, playerLootReceived.getItems());
	}

	private void addLoot(NPCComposition _npc, Collection<ItemStack> _items)
	{
		for (ItemStack _item : _items) {
			ItemComposition _ic = itemManager.getItemComposition(_item.getId());
			int _realId = _ic.getNote() == -1 ? _ic.getId() : _ic.getLinkedNoteId();
			int _price = Math.max(itemManager.getItemPrice(_realId), _ic.getHaPrice());
			BufferedImage _image = itemManager.getImage(_realId, _item.getQuantity(), false);

			listerOverlay.addDropToQueue(new LootListerItem(_realId, _npc, _ic.getName(), _item.getQuantity(), _price, _image));
		}
	}

	@Subscribe
	public void onGameTick(GameTick event)
	{
		listerOverlay.updateOldestItemTimer();
	}

	@Provides
	LootListerConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(LootListerConfig.class);
	}
}

package com.DoinkOink;

import com.DoinkOink.Misc.LootListerSide;
import com.DoinkOink.Misc.LootListerStackSide;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("Loot Lister")
public interface LootListerConfig extends Config
{
	@ConfigSection(
		name = "Display",
		description = "Display settings.",
		position = 0
	)
	String displaySection = "Display";

	@ConfigSection(
		name = "Animation",
		description = "Animation settings.",
		position = 1
	)
	String animationSection = "Animation";

	@ConfigItem(
		keyName = "maxDisplayedItems",
		name = "Max Displayed Items",
		description = "How many items can be shown at once.",
		section = displaySection
	)
	default int maxDisplayedItems()
	{
		return 5;
	}

	@ConfigItem(
		keyName = "minValueToDisplay",
		name = "Minimum Value",
		description = "The minimum value an item must be to be displayed.",
		section = displaySection
	)
	default int minValueToDisplay() { return 1000; }

	@ConfigItem(
		keyName = "iconSize",
		name = "Icon Size",
		description = "How big item icons will be.",
		section = displaySection
	)
	default int iconSize()
	{
		return 26;
	}

	@ConfigItem(
		keyName = "maxDisplayTime",
		name = "Max display time",
		description = "How long the last item in the list will be displayed on screen. If set to 0 it will show until the max item displayed has been reached.",
		section = displaySection
	)
	default double maxDisplayTime() { return 10; }

	@ConfigItem(
		keyName = "spaceBetweenItems",
		name =  "Space Between Items",
		description = "How much vertical space is between each displayed item.",
		section = displaySection
	)
	default int spaceBetweenItems() { return 2; }

	@ConfigItem(
		keyName = "spaceBetweenIconAndText",
		name =  "Space Between Icons and Text",
		description = "How much space is between an items icon and text.",
		section = displaySection
	)
	default int spaceBetweenIconAndText() { return 2; }

	@ConfigItem(
		keyName = "npcFilters",
		name = "NPC Specific Values",
		description = "Comma separated display values per NPC. To add an NPC put their {name or NPC ID}:{min value}/nExample: Cow:100,Goblin:20",
		section = displaySection,
		position = 100
	)
	default String npcFilters() { return ""; }

	@ConfigItem(
		keyName = "sideToAnimateFrom",
		name = "Direction to appear from",
		description = "Which side the items should appear and disappear from.",
		section = animationSection,
		position = 0
	)
	default LootListerSide sideToAnimateFrom() { return LootListerSide.RIGHT;}

	@ConfigItem(
		keyName = "stackDirection",
		name = "Item stack direction",
		description = "What direction items should stack in the list.",
		section = animationSection,
		position = 1
	)
	default LootListerStackSide stackDirection() { return LootListerStackSide.BOTTOM; }

	@ConfigItem(
		keyName = "horizontalTextSpeed",
		name =  "Horizontal Scroll Speed",
		description = "How fast the text will scroll left and right.",
		section = animationSection,
		position = 2
	)
	default int horizontalTextSpeed() { return 10; }

	@ConfigItem(
		keyName = "verticalTextSpeed",
		name =  "Vertical Scroll Speed",
		description = "How fast the text will scroll up and down.",
		section = animationSection,
		position = 3
	)
	default int verticalTextSpeed() { return 5; }
}

package com.DoinkOink.Misc;

public enum LootListerStackSide {
	TOP,
	BOTTOM
}

package com.DoinkOink.Misc;

public enum LootListerSide {
	LEFT,
	RIGHT
}

package com.DoinkOink.Misc;

import net.runelite.api.NPCComposition;

import java.awt.Point;
import java.awt.image.BufferedImage;

public class LootListerItem
{
	public final int ID;
	public final String SourceName;
	public final String SourceID;
	public final String ItemText;
	public final int Quantity;
	public final int Price;
	public final BufferedImage Image;

	public Point CurrentPosition = new Point(0,0);
	public Point NextPosition = new Point(0,0);
	public Point StartingPosition = new Point(0, 0);
	public int TextWidth = 0;
	public double TimeDisplayed = 0;
	public boolean JustAdded = true;

	public LootListerItem(int _id, NPCComposition _npc, String _name, int _quantity, int _price, BufferedImage _image)
	{
		ID = _id;
		ItemText = (_quantity > 1 ? _quantity + " " : "") + _name;
		Quantity = _quantity;
		Price = _price * _quantity;
		Image = _image;

		if (_npc != null) {
			SourceName = _npc.getName().toLowerCase();
			SourceID = Integer.toString(_npc.getId());
		} else {
			SourceName = "";
			SourceID = "";
		}
	}

	public void SetNextPosition(Point _nextPos)
	{
		StartingPosition = new Point(CurrentPosition.x, CurrentPosition.y);
		NextPosition = _nextPos;
	}

	public void SetFirstPosition(Point _start, Point _end)
	{
		CurrentPosition = _start;
		SetNextPosition(_end);
	}

	public void SetHorizontalPosition(int _x)
	{
		CurrentPosition.x = StartingPosition.x = NextPosition.x = _x;
	}

	public double GetRemainingHorizontalDistance()
	{
		return StartingPosition.x < NextPosition.x
			? NextPosition.getX() - CurrentPosition.getX()
			: CurrentPosition.getX() - NextPosition.getX();
	}
	public double GetRemainingVerticalDistance()
	{
		return StartingPosition.y < NextPosition.y
			? NextPosition.getY() - CurrentPosition.getY()
			: CurrentPosition.getY() - NextPosition.getY();
	}

	public double GetTotalVerticalDistance()
	{
		return StartingPosition.y < NextPosition.y
			? NextPosition.getY() - StartingPosition.getY()
			: StartingPosition.getY() - NextPosition.getY();
	}

	public double GetVerticalDistancePercentage()
	{
		return GetRemainingVerticalDistance() / GetTotalVerticalDistance();
	}
}

package com.example;

import com.DoinkOink.LootListerPlugin;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class LootListerTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(LootListerPlugin.class);
		RuneLite.main(args);
	}
}
