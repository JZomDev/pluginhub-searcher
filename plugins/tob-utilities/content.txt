package com.tobutilities;

import com.tobutilities.common.enums.FontType;
import com.tobutilities.maiden.ScuffWarningDisplay;
import net.runelite.client.config.*;

import java.awt.*;

@ConfigGroup("tobutilities")
public interface TobUtilitiesConfig extends Config
{
	@ConfigSection(
		name = "Metronome",
		description = "Config for visual Metronome",
		position = 6
	)
	String Metronome = "Metronome";

	@ConfigItem(
		position = 1,
		keyName = "enableBloatMetronome",
		name = "Enable Bloat Metronome",
		description = "Enable visual metronome in Bloat room",
		section = Metronome
	)
	default boolean enableBloatMetronome()
	{
		return false;
	}
	@ConfigItem(
		position = 2,
		keyName = "enableNylocasMetronome",
		name = "Enable Nylocas Metronome",
		description = "Enable visual metronome in Nylo room",
		section = Metronome
	)
	default boolean enableNyloMetronome()
	{
		return false;
	}

	@ConfigItem(
		position = 3,
		keyName = "enableSotetsegMetronome",
		name = "Enable Sotetseg Metronome",
		description = "Enable visual metronome in Sotetseg room",
		section = Metronome
	)
	default boolean enableSoteMetronome()
	{
		return false;
	}

	@ConfigItem(
		position = 4,
		keyName = "enableXarpusMetronome",
		name = "Enable Xarpus Metronome",
		description = "Enable visual metronome in Xarpus room",
		section = Metronome
	)
	default boolean enableXarpusMetronome()
	{
		return false;
	}

	@ConfigItem(
		position = 5,
		keyName = "enableVerzikMetronome",
		name = "Enable Verzik Metronome",
		description = "Enable visual metronome in Verzik room",
		section = Metronome
	)
	default boolean enableVerzikMetronome()
	{
		return false;
	}

	@ConfigItem(
		position = 6,
		keyName = "countColor",
		name = "Tick Number Color",
		description = "Configures the color of tick number",
		section = Metronome
	)
	default Color NumberColor()
	{
		return Color.CYAN;
	}


	@ConfigItem(
		position = 7,
		keyName = "fontType",
		name = "Font Type",
		description = "Change the font of the Tick Number",
		section = Metronome
	)
	default FontType fontType()
	{
		return FontType.REGULAR;
	}

	@Alpha
	@ConfigItem(
		position = 8,
		keyName = "tick1Color",
		name = "1st Tick Color",
		description = "Configures the color of 1st tick",
		section = Metronome
	)
	default Color getTick1Color()
	{
		return Color.WHITE;
	}

	@Alpha
	@ConfigItem(
		position = 9,
		keyName = "tick2Color",
		name = "2nd Tick Color",
		description = "Configures the color of 2nd tick",
		section = Metronome
	)
	default Color getTick2Color()
	{
		return Color.GRAY;
	}

	@Alpha
	@ConfigItem(
		position = 10,
		keyName = "tick3Color",
		name = "3rd Tick Color",
		description = "Configures the color of 3rd tick if enabled",
		section = Metronome
	)
	default Color getTick3Color()
	{
		return Color.DARK_GRAY;
	}

	@Alpha
	@ConfigItem(
		position = 11,
		keyName = "tick4Color",
		name = "4th Tick Color",
		description = "Configures the color of the 4rd tick if enabled",
		section = Metronome
	)
	default Color getTick4Color()
	{
		return Color.BLACK;
	}

	@Alpha
	@ConfigItem(
		position = 12,
		keyName = "tick5Color",
		name = "5th Tick Color",
		description = "Configures the color of the 5th tick if enabled",
		section = Metronome
	)
	default Color getTick5Color()
	{
		return new Color(112, 131, 255);
	}

	@Alpha
	@ConfigItem(
		position = 13,
		keyName = "tick6Color",
		name = "6th Tick Color",
		description = "Configures the color of the 6th tick if enabled",
		section = Metronome
	)
	default Color getTick6Color()
	{
		return new Color(0, 23, 171);
	}

	@Alpha
	@ConfigItem(
		position = 14,
		keyName = "tick7Color",
		name = "7th Tick Color",
		description = "Configures the color of the 7th tick if enabled",
		section = Metronome
	)
	default Color getTick7Color()
	{
		return new Color(107, 255, 124);
	}

	@ConfigItem(
		position = 15,
		keyName = "metronomeResetHotkey ",
		name = "Metronome Reset Hotkey",
		description = "Hotkey to reset metronome",
		section = Metronome
	)
	default Keybind metronomeResetHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigSection(
		name = "Maiden",
		description = "Change Maiden settings",
		position = 1
	)
	String Maiden = "Maiden Settings";

	@ConfigItem(
		position = 0,
		keyName = "maidenScuffWarning",
		name = "Maiden Scuff Warning",
		description = "Provides Maidens index, lets you know if you should expect scuffed nylos",
		section = Maiden
	)
	default ScuffWarningDisplay scuffWarningDisplayType()
	{
		return ScuffWarningDisplay.CHAT_MESSAGE;
	}

	@ConfigItem(
		position = 1,
		keyName = "scuffedSpawnHighlight",
		name = "Highlight scuffed spawns",
		description = "Highlights scuffed nylocas matomenos ",
		section = Maiden
	)
	default boolean enabledScuffedSpawnHighlight()
	{
		return false;
	}

	@ConfigItem(
		position = 2,
		keyName = "highlightColor",
		name = "Highlight Color",
		description = "The color to highlight Nylocas Matomenos",
		section = Maiden
	)
	default Color getHighlightColor()
	{
		return new Color(0, 0, 0, 255);
	}

	@ConfigItem(
		position = 3,
		keyName = "borderWidth",
		name = "Border Width",
		description = "Width of the highlighted border",
		section = Maiden
	)
	default int getBorderWidth()
	{
		return 2;
	}

	@ConfigItem(
		position = 4,
		keyName = "borderFeather",
		name = "Border Feather",
		description = "Feather of the highlighted border",
		section = Maiden
	)
	default int getBorderFeather()
	{
		return 2;
	}


	@ConfigSection(
		name = "Bloat",
		description = "Change Bloat settings",
		position = 2
	)
	String Bloat = "Bloat Settings";

	@ConfigItem(
		keyName = "hideSelfDuringBloat",
		name = "Hide self",
		description = "Enable hiding of local player while bloat is alive",
		position = 1,
		section = Bloat
	)
	default boolean hideLocalPlayerDuringBloat()
	{
		return false;
	}

	@ConfigItem(
		keyName = "hideOthersDuringBloat",
		name = "Hide others",
		description = "Enable hiding of other players while bloat is alive",
		position = 2,
		section = Bloat
	)
	default boolean hideOtherPlayersDuringBloat()
	{
		return false;
	}

	@ConfigItem(
		keyName = "outlinePlayers",
		name = "Outline players",
		description = "Enable outlining players ",
		position = 3,
		section = Bloat
	)
	default boolean enableOutlinePlayers()
	{
		return false;
	}

    @ConfigItem(
            keyName = "hideBloatFloor",
            name = "Hide floor",
            description = "Enable hiding ground objects in the bloat room",
            position = 4,
            section = Bloat
    )
    default boolean hideBloatFloor()
    {
        return false;
    }

    @ConfigItem(
            keyName = "bloatSkyboxOverride",
            name = "Skybox override",
            description = "Override the skybox color in the bloat room",
            position = 5,
            section = Bloat
    )

    default boolean enableBloatSkyboxOverride()
    {
        return false;
    }

    @ConfigItem(
            keyName = "bloatSkyboxColor",
            name = "Skybox color",
            description = "The color for the skybox in the bloat room",
            position = 6,
            section = Bloat
    )

    default Color bloatSkyboxColor()
    {
		return new Color(178,150,203);
    }

	@ConfigSection(
		name = "Nylocas",
		description = "Change Nylocas settings",
		position = 3
	)
	String Nylocas = "Nylocas Settings";

	@ConfigItem(
		keyName = "enableHighlightAggressiveNylos",
		name = "Highlight aggressive nylos",
		description = "Enables highlighting aggressive nylos",
		position = 1,
		section = Nylocas
	)
	default boolean enableHighlightAggressiveNylos()
	{
		return false;
	}


	@ConfigSection(
		name = "Verzik",
		description = "Change Verzik settings",
		position = 5
	)
	String Verzik = "Verzik Settings";

	@ConfigItem(
		keyName = "enableHideVerzikHotkey",
		name = "Enable hide Verzik ",
		description = "Enable ability to hide P3 Verzik using a hotkey ",
		position = 1,
		section = Verzik
	)
	default boolean enableHideVerzik()
	{
		return false;
	}

	@ConfigItem(
		keyName = "hideVerzikHotkey",
		name = "Hide Verzik Hotkey",
		description = "Key to hide Verzik ",
		position = 2,
		section = Verzik
	)
	default Keybind hideVerzikHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
		keyName = "enableDawnbringerOverlay",
		name = "Enable dawnbringer overlay ",
		description = "Enable overlay over player orb to show who is currently holding dawnbringer",
		position = 3,
		section = Verzik
	)
	default boolean enableDawnbringerOverlay()
	{
		return true;
	}
	@ConfigItem(
		keyName = "enableDawnbringerParty",
		name = "Enable dawnbringer party integration ",
		description = "Checks if dawnbringer is  in a teammates inventory - Requires party plugin ",
		position = 3,
		section = Verzik
	)
	default boolean enableDawnbringerParty()
	{
		return true;
	}

	@ConfigItem(
		keyName = "dawnbringerEquippedOverlayColor",
		name = "Dawnbringer equipped overlay color",
		description = "Color for dawnbringer holders orb",
		position = 5,
		section = Verzik
	)
	default Color dawnbringerEquippedOverlayColor()
	{
		return new Color(0, 82, 87);
	}
	@ConfigItem(
		keyName = "dawnbringerInventoryOverlayColor",
		name = "Dawnbringer inventory overlay color",
		description = "Color for orb of player with dawnbringer in inventory (Party required)",
		position = 6,
		section = Verzik
	)
	default Color dawnbringerInventoryOverlayColor()
	{
		return new Color(0, 82, 87);
	}

	@ConfigItem(
		keyName = "enableLightbearerOverlay",
		name = "Enable lightbearer overlay ",
		description = "Reminds player to equip their lightbearer for P1",
		position = 7,
		section = Verzik
	)
	default boolean enableLightbearerOverlay()
	{
		return true;
	}

	@ConfigItem(
		keyName = "lightbearerOverlayColor",
		name = "Lightbearer overlay color",
		description = "Color for lightbearer reminder overlay",
		position = 8,
		section = Verzik
	)
	default Color lightbearerOverlayColor()
	{
		return new Color(89, 0, 0);
	}


}


package com.tobutilities.verzik;

import com.tobutilities.TobUtilitiesConfig;
import com.tobutilities.TobUtilitiesPlugin;
import com.tobutilities.common.enums.Region;

import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;

@Slf4j
public class LightbearerWarningOverlay extends OverlayPanel
{
	private final Client client;
	private final VerzikHandler verzikHandler;
	private final TobUtilitiesConfig config;
	private final TobUtilitiesPlugin plugin;

	@Inject
	private LightbearerWarningOverlay(Client client, VerzikHandler verzikHandler, TobUtilitiesConfig config, TobUtilitiesPlugin plugin)
	{
		this.client = client;
		this.verzikHandler = verzikHandler;
		this.config = config;
		this.plugin = plugin;

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (verzikHandler.isLightbearerOverlayDisplayed() && Region.VERZIK.equals(plugin.region))
		{
			buildPanelComponent(graphics);
			setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
			return panelComponent.render(graphics);
		}
		return null;
	}

	private void buildPanelComponent(Graphics2D graphics)
	{

		String message = "You need to equip your lightbearer";
		panelComponent.getChildren().clear();


		panelComponent.getChildren().add(LineComponent.builder()
			.left(message)
			.build());


		panelComponent.setPreferredSize(new Dimension(graphics.getFontMetrics().stringWidth(message) + 10, 0));
		panelComponent.setBackgroundColor(config.lightbearerOverlayColor());
	}
}
package com.tobutilities.verzik;

import lombok.EqualsAndHashCode;
import lombok.Value;
import net.runelite.client.party.messages.PartyMessage;

/**
 * Message sent between party members to share Dawnbringer status
 */
@Value
@EqualsAndHashCode(callSuper = true)
public class DawnbringerStatusMessage extends PartyMessage
{
	String playerName;
	DawnbringerStatus dawnbringerStatus;


}
package com.tobutilities.verzik;

import java.util.List;
import net.runelite.api.gameval.NpcID;

public class VerzikConstants
{
	public static final String VERZIK_NAME = "Verzik Vitur";
	public static final List<Integer> VERZIK_P1_IDS = List.of(
		NpcID.VERZIK_INITIAL_STORY,
		NpcID.VERZIK_PHASE1_STORY,
		NpcID.VERZIK_INITIAL,
		NpcID.VERZIK_INITIAL_BASE,
		NpcID.VERZIK_INITIAL_QUICKSTART,
		NpcID.VERZIK_PHASE1,
		NpcID.VERZIK_INITIAL_HARD,
		NpcID.VERZIK_INITIAL_HARD_BASE,
		NpcID.VERZIK_INITIAL_HARD_QUICKSTART,
		NpcID.VERZIK_PHASE1_HARD);
}


package com.tobutilities.verzik;

public enum DawnbringerStatus
{
	EQUIPPED,
	IN_INVENTORY,
	UNKNOWN
}

package com.tobutilities.verzik;

import com.tobutilities.common.RoomHandler;


import com.tobutilities.common.player.TobPlayerOrb;
import com.tobutilities.TobUtilitiesPlugin;
import com.tobutilities.TobUtilitiesConfig;

import static com.tobutilities.verzik.VerzikConstants.VERZIK_NAME;
import static com.tobutilities.verzik.VerzikConstants.VERZIK_P1_IDS;
import java.awt.event.KeyEvent;
import java.util.HashMap;
import java.util.Map;
import javax.annotation.Nullable;
import javax.inject.Inject;

import javax.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.ItemContainer;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.Renderable;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ItemContainerChanged;
import static net.runelite.api.kit.KitType.WEAPON;

import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.party.PartyService;
import org.apache.commons.lang3.StringUtils;


@Slf4j
@Singleton
public class VerzikHandler extends RoomHandler

{
	@Getter
	private TobPlayerOrb tobPlayerOrb = TobPlayerOrb.UNKNOWN;
	@Getter
	private DawnbringerStatus dawnbringerStatus = DawnbringerStatus.UNKNOWN;
	private boolean isVerzikHidden = false;
	@Getter
	private boolean isLightbearerOverlayDisplayed = false;

	@Inject
	private PartyService partyService;
	@Inject
	private ClientThread clientThread;


	// Tracks Dawnbringer status of all party members
	private final Map<String, DawnbringerStatus> memberDawnbringerStatus = new HashMap<>();


	@Inject
	protected VerzikHandler(TobUtilitiesPlugin plugin, TobUtilitiesConfig config, Client client)
	{
		super(plugin, config, client);
	}


	@Subscribe
	public void onGameTick(GameTick tick)
	{
		isLightbearerOverlayDisplayed = shouldDisplayLightbearerReminder();
		if (!config.enableDawnbringerOverlay())
		{
			return;
		}

		if (config.enableDawnbringerParty() && partyService.isInParty())
		{
			handlePartyDawnbringerOverlay();
		}
		else
		{
			handleNonPartyDawnbringerOverlay();
		}
	}

	private void handleNonPartyDawnbringerOverlay()
	{
		String dawnbringerHolderName = removeNonAlphanumeric(getDawnbringerHolderName());
		if (dawnbringerHolderName != null)
		{
			for (TobPlayerOrb tobPlayer : TobPlayerOrb.values())
			{
				String playerName = removeNonAlphanumeric(client.getVarcStrValue(tobPlayer.getNameVarc()));
				if (dawnbringerHolderName.equals(playerName))
				{
					tobPlayerOrb = tobPlayer;
					dawnbringerStatus = DawnbringerStatus.EQUIPPED;
					return;
				}
			}
		}
		tobPlayerOrb = TobPlayerOrb.UNKNOWN;
	}

	private void handlePartyDawnbringerOverlay()
	{
		Map.Entry<String, DawnbringerStatus> playerStatusEntry = getPlayerWithDawnbringerInParty();
		if (playerStatusEntry == null)
		{
			tobPlayerOrb = TobPlayerOrb.UNKNOWN;
			dawnbringerStatus = DawnbringerStatus.UNKNOWN;
			return;
		}
		String dawnbringerHolderName = removeNonAlphanumeric(playerStatusEntry.getKey());
		if (dawnbringerHolderName != null)
		{
			for (TobPlayerOrb tobPlayer : TobPlayerOrb.values())
			{
				String playerName = removeNonAlphanumeric(client.getVarcStrValue(tobPlayer.getNameVarc()));
				if (dawnbringerHolderName.equals(playerName))
				{
					tobPlayerOrb = tobPlayer;
					dawnbringerStatus = playerStatusEntry.getValue();
					return;
				}
			}
		}

		handleNonPartyDawnbringerOverlay();
	}


	private String getDawnbringerHolderName()
	{

		for (Player player : client.getWorldView(-1).players())
		{
			if (player == null || player.getName() == null)
			{
				continue; // Skip null or invalid players
			}
			int weaponId = player.getPlayerComposition().getEquipmentId(WEAPON);
			if (weaponId == ItemID.VERZIK_SPECIAL_WEAPON)
			{
				return player.getName(); // Stop once we find a match
			}
		}
		return null;
	}

	private static String removeNonAlphanumeric(String str)
	{
		if (str == null)
		{
			return null;
		}
		str = str.replaceAll(
			"[^a-zA-Z0-9]", "");
		return str;
	}

	public void keyPressed(KeyEvent e)
	{
		if (config.hideVerzikHotkey().matches(e) && config.enableHideVerzik())
		{
			isVerzikHidden = !isVerzikHidden;
			e.consume();
		}

	}

	public boolean shouldDraw(Renderable renderable, boolean drawingUI)
	{
		if (renderable instanceof NPC)
		{
			NPC npc = (NPC) renderable;
			return !VERZIK_NAME.equals(npc.getName()) || !isVerzikHidden || !config.enableHideVerzik();
		}
		return true;
	}

	/**
	 * Gets the name of the player holding the Dawnbringer
	 *
	 * @return The name of the player with Dawnbringer, or null if no one has it
	 */
	@Nullable
	public Map.Entry<String, DawnbringerStatus> getPlayerWithDawnbringerInParty()
	{
		return memberDawnbringerStatus.entrySet().stream()
			.filter(entry -> entry.getValue() != DawnbringerStatus.UNKNOWN)
			.findFirst()
			.orElse(null);
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event)
	{
		// Only check inventory changes
		if (event.getContainerId() == InventoryID.INV || event.getContainerId() == InventoryID.WORN)
		{
			clientThread.invoke(this::checkLocalPlayerForDawnbringer);
		}
	}

	private void checkLocalPlayerForDawnbringer()
	{
		// Make sure we're in a party
		if (!partyService.isInParty())
		{
			return;
		}

		// Check if we have Dawnbringer in inventory
		DawnbringerStatus status = DawnbringerStatus.UNKNOWN;
		String localPlayerName = client.getLocalPlayer().getName();
		ItemContainer inventory = client.getItemContainer(InventoryID.INV);
		ItemContainer equippedItems = client.getItemContainer(InventoryID.WORN);
		if (inventory != null && inventory.contains(ItemID.VERZIK_SPECIAL_WEAPON))
		{
			status = DawnbringerStatus.IN_INVENTORY;
		}
		else if (equippedItems != null && equippedItems.contains(ItemID.VERZIK_SPECIAL_WEAPON))
		{
			status = DawnbringerStatus.EQUIPPED;
		}
		// Store our status
		memberDawnbringerStatus.put(localPlayerName, status);

		// Send status to party
		partyService.send(new DawnbringerStatusMessage(localPlayerName, status));

	}

	/**
	 * Handles incoming Dawnbringer status messages from party members
	 */
	@Subscribe
	public void onDawnbringerStatusMessage(DawnbringerStatusMessage message)
	{
		log.debug("Message received: {}", message);
		if (client.getLocalPlayer() != null && StringUtils.isNotBlank(client.getLocalPlayer().getName()) && client.getLocalPlayer().getName().equals(message.getPlayerName()))
		{
			//ignore messages sent by local player
			return;
		}
		// Update status map
		memberDawnbringerStatus.put(message.getPlayerName(), message.getDawnbringerStatus());
	}

	private boolean shouldDisplayLightbearerReminder()
	{
		return config.enableLightbearerOverlay() && isP1VerzikAlive() && isLightbearerInInventory();
	}

	private boolean isP1VerzikAlive()
	{
		return client.getWorldView(-1).npcs()
			.stream()
			.anyMatch(npc -> VERZIK_P1_IDS.contains(npc.getId()) && !npc.isDead());
	}

	private boolean isLightbearerInInventory()
	{
		ItemContainer inventory = client.getItemContainer(InventoryID.INV);
		return inventory != null && inventory.contains(ItemID.LIGHTBEARER);
	}

	public void startUp()
	{
		memberDawnbringerStatus.clear();
	}


	public void shutDown()
	{
		memberDawnbringerStatus.clear();
	}

}

package com.tobutilities.maiden;

public enum ScuffWarningDisplay
{
	CHAT_MESSAGE,
	INFO_BOX,
	OVERLAY_PANEL,
	DISABLED
}

package com.tobutilities.maiden;

import java.util.List;
import net.runelite.api.Point;

public class MaidenConstants
{
	public static List<Point> SCUFFED_SPAWNS = List.of(
		new Point(22, 41),
		new Point(26, 41),
		new Point(30, 41),
		new Point(34, 41),
		new Point(34, 39),
		new Point(22, 19),
		new Point(26, 19),
		new Point(30, 19),
		new Point(34, 19),
		new Point(34, 21));

	public static final String THE_MAIDEN_OF_SUGADINTI = "The Maiden of Sugadinti";
	public static final String NYLOCAS_MATOMENOS = "Nylocas Matomenos";
	public static final int MAIDEN_BOSS_IMAGE = 25748;
	public static final int OVERLAY_DISPLAY_TICKS = 10;
}

package com.tobutilities.maiden;

import com.tobutilities.TobUtilitiesConfig;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.NPCComposition;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;

public class ScuffedNylocasOverlay extends Overlay
{
	private final Client client;
	private final MaidenHandler maidenHandler;
	private final TobUtilitiesConfig config;
	private final ModelOutlineRenderer modelOutlineRenderer;

	@Inject
	private ScuffedNylocasOverlay(Client client, MaidenHandler maidenHandler, TobUtilitiesConfig config, ModelOutlineRenderer modelOutlineRenderer)
	{
		this.client = client;
		this.maidenHandler = maidenHandler;
		this.config = config;
		this.modelOutlineRenderer = modelOutlineRenderer;

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		// First, set up the outlines for rendering
		for (NPC npc : maidenHandler.getNylocasMatomenosSpawns())
		{
			if (npc == null || npc.isDead())
			{
				continue;
			}

			NPCComposition npcComposition = npc.getTransformedComposition();
			if (npcComposition == null)
			{
				continue;
			}

			Color highlight = config.getHighlightColor();
			modelOutlineRenderer.drawOutline(npc, config.getBorderWidth(), highlight, config.getBorderFeather());

		}

		return null;
	}
}
package com.tobutilities.maiden;

import com.tobutilities.TobUtilitiesConfig;
import com.tobutilities.TobUtilitiesPlugin;
import com.tobutilities.common.RoomHandler;
import static com.tobutilities.maiden.MaidenConstants.OVERLAY_DISPLAY_TICKS;
import static com.tobutilities.maiden.MaidenConstants.MAIDEN_BOSS_IMAGE;
import static com.tobutilities.maiden.MaidenConstants.NYLOCAS_MATOMENOS;
import static com.tobutilities.maiden.MaidenConstants.THE_MAIDEN_OF_SUGADINTI;
import java.awt.Color;
import java.util.ArrayList;
import java.util.List;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Point;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import org.apache.commons.lang3.StringUtils;

@Slf4j
@Singleton
public class MaidenHandler extends RoomHandler
{
	@Getter
	private final List<NPC> nylocasMatomenosSpawns = new ArrayList<>();
	private ScuffWarningInfoBox scuffWarningInfoBox;
	@Inject
	ItemManager itemManager;
	@Getter
	private int maidenIndex;
	@Getter
	private boolean overlayDisplayed = false;
	private int displayTicksRemaining = 0;

	@Inject
	protected MaidenHandler(TobUtilitiesPlugin plugin, TobUtilitiesConfig config, Client client)
	{
		super(plugin, config, client);
	}

	@Inject
	private ChatMessageManager chatMessageManager;

	@Subscribe
	public void onNpcSpawned(NpcSpawned event)
	{
		NPC npc = event.getNpc();
		if (npc == null || StringUtils.isBlank(npc.getName()))
		{
			return;
		}

		if (THE_MAIDEN_OF_SUGADINTI.equals(npc.getName()))
		{
			handleMaidenSpawn(npc);
			return;
		}

		if (shouldHighlightScuffedNylocas(npc))
		{
			nylocasMatomenosSpawns.add(npc);
		}
	}

	private void handleMaidenSpawn(NPC maiden)
	{
		maidenIndex = maiden.getIndex();
		nylocasMatomenosSpawns.clear();

		ScuffWarningDisplay displayType = config.scuffWarningDisplayType();
		switch (displayType)
		{
			case CHAT_MESSAGE:
				handleScuffedSpawnChatMessage();
				break;
			case INFO_BOX:
				handleScuffedSpawnInfoBox();
				break;
			case OVERLAY_PANEL:
				handleScuffedSpawnOverlayPanel();
				break;
			default:
				break;
		}
	}

	private boolean shouldHighlightScuffedNylocas(NPC npc)
	{
		if (!config.enabledScuffedSpawnHighlight() || !NYLOCAS_MATOMENOS.equals(npc.getName()))
		{
			return false;
		}

		int x = npc.getWorldLocation().getRegionX();
		int y = npc.getWorldLocation().getRegionY();
		Point position = new Point(x, y);

		return MaidenConstants.SCUFFED_SPAWNS.contains(position) && !nylocasMatomenosSpawns.contains(npc);
	}

	private void handleScuffedSpawnChatMessage()
	{
		ChatMessageBuilder messageBuilder = new ChatMessageBuilder()
			.append(ChatColorType.HIGHLIGHT);

		if (maidenIndex < 58000)
		{
			messageBuilder.append(Color.GREEN, String.format("There is no reasonable risk of a scuff. Maiden index: %d", maidenIndex));
		}
		else if (maidenIndex < 60000)
		{
			messageBuilder.append(Color.GREEN, String.format("A scuff is very unlikely (possible in small scales). Maiden index: %d", maidenIndex));
		}
		else if (maidenIndex < 62000)
		{
			messageBuilder.append(Color.GREEN, String.format("A scuff is unlikely (possible in small scales). Maiden index: %d", maidenIndex));
		}
		else if (maidenIndex < 63500)
		{
			messageBuilder.append(Color.ORANGE, String.format("A scuff is likely, especially in small scales. Maiden index: %d", maidenIndex));
		}
		else
		{
			messageBuilder.append(Color.RED, String.format("A scuff is very likely. Maiden index: %d", maidenIndex));
		}

		chatMessageManager.queue(QueuedMessage.builder()
			.type(ChatMessageType.CONSOLE)
			.name("ToB Utilities")
			.sender("ToB Utilities")
			.runeLiteFormattedMessage(messageBuilder.build())
			.build());
	}

	private void handleScuffedSpawnInfoBox()
	{
		this.scuffWarningInfoBox = new ScuffWarningInfoBox(itemManager.getImage(MAIDEN_BOSS_IMAGE), plugin, this);
		plugin.infoBoxManager.addInfoBox(scuffWarningInfoBox);
		displayTicksRemaining = OVERLAY_DISPLAY_TICKS;
	}

	private void handleScuffedSpawnOverlayPanel()
	{
		overlayDisplayed = true;
		displayTicksRemaining = OVERLAY_DISPLAY_TICKS;
	}

	public void onGameTick(GameTick tick)
	{
		if (!overlayDisplayed && !plugin.infoBoxManager.getInfoBoxes().contains(scuffWarningInfoBox))
		{
			return;
		}

		if (--displayTicksRemaining > 0)
		{
			return;
		}

		if (overlayDisplayed)
		{
			overlayDisplayed = false;
		}
		else
		{
			plugin.infoBoxManager.removeInfoBox(scuffWarningInfoBox);
		}
	}


	@Subscribe
	public void onNpcDespawned(NpcDespawned event)
	{
		nylocasMatomenosSpawns.remove(event.getNpc());
	}

	public void shutDown()
	{
		nylocasMatomenosSpawns.clear();
	}

}

package com.tobutilities.maiden;

import com.tobutilities.TobUtilitiesConfig;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.api.Client;

import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;

public class ScuffWarningOverlay extends OverlayPanel
{
	private final Client client;
	private final MaidenHandler maidenHandler;
	private final TobUtilitiesConfig config;

	@Inject
	private ScuffWarningOverlay(Client client, MaidenHandler maidenHandler, TobUtilitiesConfig config, ModelOutlineRenderer modelOutlineRenderer)
	{
		this.client = client;
		this.maidenHandler = maidenHandler;
		this.config = config;

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (maidenHandler.isOverlayDisplayed())
		{
			buildPanelComponent(graphics);
			setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
			return panelComponent.render(graphics);
		}
		return null;
	}

	private void buildPanelComponent(Graphics2D graphics)
	{
		int maidenIndex = maidenHandler.getMaidenIndex();
		String message;
		String indexInfo = "Maiden index: " + maidenIndex;
		Color color = Color.GREEN;
		panelComponent.getChildren().clear();

		if (maidenIndex < 58000)
		{
			message = "There is no reasonable risk of a scuff";
		}
		else if (maidenIndex < 60000)
		{
			message = "A scuff is very unlikely";
		}
		else if (maidenIndex < 61000)
		{
			message = "A scuff is unlikely (possible in small scales)";
		}
		else if (maidenIndex < 63500)
		{
			message = "A scuff is likely, especially in small scales";
			color = Color.ORANGE;
		}
		else
		{
			message = "A scuff is very likely";
			color = Color.RED;
		}

		panelComponent.getChildren().add(LineComponent.builder()
			.left(message)
			.leftColor(color)
			.build());

		panelComponent.getChildren().add(LineComponent.builder()
			.left(indexInfo)
			.leftColor(color)
			.build());

		panelComponent.setPreferredSize(new Dimension(graphics.getFontMetrics().stringWidth(message) + 10, 0));
		panelComponent.setBackgroundColor(new Color(100, 85, 85, 100));
	}
}
package com.tobutilities.maiden;


import java.awt.Color;
import java.awt.image.BufferedImage;
import javax.inject.Inject;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.ui.overlay.infobox.InfoBox;

@Slf4j
public class ScuffWarningInfoBox extends InfoBox
{
	@Inject
	private MaidenHandler maidenHandler;


	public ScuffWarningInfoBox(BufferedImage image, Plugin plugin, MaidenHandler maidenHandler)
	{
		super(image, plugin);
		this.maidenHandler = maidenHandler;
	}

	@Override
	public String getText()
	{
		return Integer.toString(maidenHandler.getMaidenIndex());
	}

	@Override
	public Color getTextColor()
	{
		if (maidenHandler.getMaidenIndex() < 61000)
		{
			return Color.GREEN;
		}
		else if (maidenHandler.getMaidenIndex() < 63500)
		{
			return Color.ORANGE;
		}
		else
		{
			return Color.RED;
		}
	}

	@Override
	public String getTooltip()
	{
		if (maidenHandler.getMaidenIndex() < 58000)
		{
			return "There is no reasonable risk of a scuff.";
		}
		else if (maidenHandler.getMaidenIndex() < 60000)
		{
			return "A scuff is very unlikely (possible in small scales)";
		}
		else if (maidenHandler.getMaidenIndex() < 61000)
		{
			return "A scuff is unlikely.";
		}
		else if (maidenHandler.getMaidenIndex() < 63500)
		{
			return "A scuff is likely.";
		}
		else
		{
			return "A scuff is very likely.";
		}
	}

}
package com.tobutilities.nylocas;

import com.tobutilities.TobUtilitiesConfig;

import java.awt.*;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.NPCComposition;
import net.runelite.api.Perspective;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

public class NylocasOverlay extends Overlay
{
	private final Client client;
	private final NylocasHandler nylocasHandler;
	private final TobUtilitiesConfig config;
	private Polygon tilePolygon;

	@Inject
	private NylocasOverlay(Client client, NylocasHandler nylocasHandler, TobUtilitiesConfig config)
	{
		this.client = client;
		this.nylocasHandler = nylocasHandler;
		this.config = config;

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ALWAYS_ON_TOP);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (config.enableHighlightAggressiveNylos())
		{
			for (NPC npc : nylocasHandler.getAggressiveNylocas())
			{
				if (npc == null || npc.isDead())
				{
					continue;
				}

				NPCComposition npcComposition = npc.getTransformedComposition();
				if (npcComposition == null)
				{
					continue;
				}

				LocalPoint localPoint = npc.getLocalLocation();
				if (localPoint != null)
				{
					tilePolygon = Perspective.getCanvasTileAreaPoly(client, localPoint, npcComposition.getSize());
					if (tilePolygon != null)
					{
						renderPoly(graphics, tilePolygon, config.getBorderWidth());
					}
				}
			}
		}
		return null;
	}

	private void renderPoly(Graphics2D graphics, Shape polygon, double width)
	{
		if (polygon != null)
		{
			graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
			graphics.setColor(Color.RED);
			graphics.setStroke(new BasicStroke((float) width));
			graphics.draw(polygon);
		}
	}
}

package com.tobutilities.nylocas;

import java.util.List;

public class NylocasConstants
{
	public static final List<Integer> AGGRESSIVE_NYLOCAS_IDS = List.of(8348, 8349, 8350, 8351, 8352, 8353, 10797, 10798, 10799, 10800, 10801, 10802);

}

package com.tobutilities.nylocas;

import com.tobutilities.TobUtilitiesConfig;
import com.tobutilities.TobUtilitiesPlugin;
import com.tobutilities.common.RoomHandler;

import java.util.ArrayList;
import java.util.List;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.NpcChanged;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.client.eventbus.Subscribe;

import static com.tobutilities.nylocas.NylocasConstants.AGGRESSIVE_NYLOCAS_IDS;

@Singleton
public class NylocasHandler extends RoomHandler
{
	private final List<NPC> aggressiveNylocas = new ArrayList<>();

	public List<NPC> getAggressiveNylocas()
	{
		return aggressiveNylocas;
	}

	@Inject
	protected NylocasHandler(TobUtilitiesPlugin plugin, TobUtilitiesConfig config, Client client)
	{
		super(plugin, config, client);
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned event)
	{
		NPC npc = event.getNpc();
		if (AGGRESSIVE_NYLOCAS_IDS.contains(npc.getId()) && !aggressiveNylocas.contains(npc))
		{
			aggressiveNylocas.add(npc);
		}
	}

	@Subscribe
	public void onNpcChanged(NpcChanged event)
	{
		NPC npc = event.getNpc();
		if (AGGRESSIVE_NYLOCAS_IDS.contains(npc.getId()) && !aggressiveNylocas.contains(npc) && !npc.isDead())
		{
			aggressiveNylocas.add(npc);
		}
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned event)
	{
		aggressiveNylocas.remove(event.getNpc());
	}

	@Subscribe
	public void onActorDeath(ActorDeath event)
	{
		if (event.getActor() instanceof NPC)
		{
			aggressiveNylocas.remove((NPC) event.getActor());
		}
	}

	public void shutDown()
	{
		aggressiveNylocas.clear();
	}
}

package com.tobutilities.common.util;

import com.tobutilities.common.enums.Region;

public class CommonUtils
{

	public static Region getRegionByRegionId(int regionId)
	{
		switch (regionId)
		{
			case 12613:
				return Region.MAIDEN;
			case 13125:
				return Region.BLOAT;
			case 13122:
				return Region.NYLOCAS;
			case 13123:
			case 13379:
				return Region.SOTETSEG;
			case 12612:
				return Region.XARPUS;
			case 12611:
				return Region.VERZIK;
			default:
				return Region.UNKNOWN;
		}
	}
}

package com.tobutilities.common.enums;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Getter
public enum FontType
{
	REGULAR("RS Regular"),
	ARIAL("Arial"),
	CAMBRIA("Cambria"),
	ROCKWELL("Rockwell"),
	SEGOE_UI("Segoe Ui"),
	TIMES_NEW_ROMAN("Times New Roman"),
	VERDANA("Verdana");

	private final String name;

	@Override
	public String toString()
	{
		return name;
	}
}

package com.tobutilities.common.enums;

public enum Region
{
	MAIDEN(0, 1, 12613),
	BLOAT(5, 2, 13125),
	NYLOCAS(4, 3, 13122),
	SOTETSEG(4, 4, 13123),
	XARPUS(4, 5, 12612),
	VERZIK(7, 6, 12611),
	UNKNOWN(0, 0, -1);
	private final int tickCount;
	private final int waveNumber;
	private final int regionId;

	Region(int tickCount, int waveNumber, int regionId)
	{
		this.tickCount = tickCount;
		this.waveNumber = waveNumber;
		this.regionId = regionId;
	}

	public int getTickCount()
	{
		return this.tickCount;
	}

	public int getWaveNumber()
	{
		return this.waveNumber;
	}

	public int getRegionId()
	{
		return this.regionId;
	}
}

package com.tobutilities.common.metronome;

import com.tobutilities.TobUtilitiesConfig;
import com.tobutilities.common.enums.FontType;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Point;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.inject.Inject;
import java.awt.*;

@Slf4j
public class MetronomeOverlay extends Overlay
{
	private final MetronomeService metronomeService;
	private final TobUtilitiesConfig config;


	private static int TITLE_PADDING = 10;
	private static final int MINIMUM_SIZE = 16;
	private Dimension DEFAULT_SIZE = new Dimension(25, 25);

	@Inject
	protected MetronomeOverlay(MetronomeService metronomeService, TobUtilitiesConfig config)
	{
		this.metronomeService = metronomeService;
		this.config = config;
		setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
		setMinimumSize(MINIMUM_SIZE);
		setResizable(true);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		Dimension preferredSize = getPreferredSize();
		if (preferredSize == null)
		{
			preferredSize = DEFAULT_SIZE;
			setPreferredSize(preferredSize);
		}

		if (metronomeService.isMetronomeDisplayed() && metronomeService.isCurrentRegionMetronomeEnabled())
		{
			// Background
			graphics.setColor(metronomeService.getCurrentColor());
			graphics.fillRect(0, 0, preferredSize.width, preferredSize.height);


			TITLE_PADDING = (Math.min(preferredSize.width, preferredSize.height) / 2 - 4);
			if (config.fontType() == FontType.REGULAR)
			{
				graphics.setFont(new Font(FontManager.getRunescapeFont().getName(), Font.BOLD,
					Math.min(preferredSize.width, preferredSize.height)));
			}
			else
			{
				graphics.setFont(new Font(config.fontType().toString(), Font.BOLD,
					Math.min(preferredSize.width, preferredSize.height)));
			}

			String tickText = String.valueOf(metronomeService.getCurrentColorIndex());
			FontMetrics fm = graphics.getFontMetrics();
			int textWidth = fm.stringWidth(tickText);

			final Point tickCounterPoint = new Point(
				preferredSize.width / 2 - textWidth / 2,
				preferredSize.height / 2 + fm.getAscent() / 2
			);

			OverlayUtil.renderTextLocation(graphics, tickCounterPoint, tickText, config.NumberColor());
		}
		return preferredSize;
	}
}
package com.tobutilities.common.metronome;

import com.tobutilities.TobUtilitiesConfig;
import com.tobutilities.TobUtilitiesPlugin;
import com.tobutilities.common.enums.Region;
import static com.tobutilities.common.util.CommonUtils.getRegionByRegionId;
import java.awt.Color;
import java.awt.event.KeyEvent;
import java.util.Random;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameTick;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
@Singleton
public class MetronomeService

{
	@Inject
	private Client client;

	@Inject
	private TobUtilitiesPlugin plugin;

	@Inject
	private TobUtilitiesConfig config;

	@Getter
	@Setter
	private boolean metronomeDisplayed = true;
	@Getter
	@Setter
	private Color currentColor = Color.WHITE;
	@Getter
	@Setter
	private int currentColorIndex = 0;
	private final Random random = new Random();


	@Inject
	public MetronomeService(Client client, TobUtilitiesPlugin plugin, TobUtilitiesConfig config)
	{
		this.client = client;
		this.plugin = plugin;
		this.config = config;
	}

	@Subscribe
	public void onGameTick(GameTick tick)
	{
		int regionTickCount;
		Player player = client.getLocalPlayer();
		final LocalPoint playerLocation = player.getLocalLocation();
		WorldPoint playerLocationPoint = WorldPoint.fromLocalInstance(client, playerLocation);
		final int regionId = playerLocationPoint.getRegionID();
		Region newTickRegion = getRegionByRegionId(regionId);

		if (newTickRegion != plugin.region)
		{
			if (newTickRegion.getWaveNumber() > plugin.region.getWaveNumber())
			{
				// raid has advanced to next room
				plugin.region = newTickRegion;
				if (isCurrentRegionMetronomeEnabled())
				{
					//randomize color index to avoid potential instance timer sync for player who starts the instance
					currentColorIndex = random.nextInt(plugin.region.getTickCount() + 1);
					//enable metronome if applicable
					setMetronomeDisplayed(true);
				}
			}
			else
			{
				//In event of either wipe or after treasure room
				plugin.region = newTickRegion;
			}
		}

		if (plugin.region.getTickCount() == 0)
		{
			//Player is in a region where metronome isn't used
			setMetronomeDisplayed(false);
			return;
		}

		regionTickCount = plugin.region.getTickCount();

		if (getCurrentColorIndex() >= regionTickCount)
		{
			setCurrentColorIndex(0);
		}

		int colorIndex = getCurrentColorIndex() + 1;
		setCurrentColorIndex(colorIndex);

		switch (colorIndex)
		{
			case 1:
				setCurrentColor(config.getTick1Color());
				break;
			case 2:
				setCurrentColor(config.getTick2Color());
				break;
			case 3:
				setCurrentColor(config.getTick3Color());
				break;
			case 4:
				setCurrentColor(config.getTick4Color());
				break;
			case 5:
				setCurrentColor(config.getTick5Color());
				break;
			case 6:
				setCurrentColor(config.getTick6Color());
				break;
			case 7:
				setCurrentColor(config.getTick7Color());
				break;
		}
	}


	public boolean isCurrentRegionMetronomeEnabled()
	{
		Region region = plugin.region;
		switch (region)
		{
			case BLOAT:
				return config.enableBloatMetronome();
			case NYLOCAS:
				return config.enableNyloMetronome();
			case SOTETSEG:
				return config.enableSoteMetronome();
			case XARPUS:
				return config.enableXarpusMetronome();
			case VERZIK:
				return config.enableVerzikMetronome();
			default:
				return false;
		}
	}

	public void keyPressed(KeyEvent e)
	{
		if (config.metronomeResetHotkey().matches(e))
		{
			currentColorIndex = 0;
			e.consume();
		}
	}
}

package com.tobutilities.common.player;

import com.tobutilities.TobUtilitiesConfig;
import com.tobutilities.verzik.VerzikHandler;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

public class PlayerOneOrbOverlay extends Overlay implements PlayerOrb
{
	private final Client client;
	private final VerzikHandler verzikHandler;
	private final TobUtilitiesConfig config;

	@Inject
	protected PlayerOneOrbOverlay(Client client, VerzikHandler verzikHandler, TobUtilitiesConfig config)
	{
		this.client = client;
		this.verzikHandler = verzikHandler;
		this.config = config;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.MANUAL);
		drawAfterLayer(TobPlayerOrb.PLAYER_1.getOrbBackgroundId());
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		Color overlayColor = getOverlayColor(verzikHandler, config);
		if (!TobPlayerOrb.PLAYER_1.equals(verzikHandler.getTobPlayerOrb()))
		{
			return null;
		}
		return getDimension(graphics, overlayColor, client, verzikHandler);
	}
}

package com.tobutilities.common.player;

import com.tobutilities.TobUtilitiesConfig;
import com.tobutilities.verzik.VerzikHandler;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

public class PlayerTwoOrbOverlay extends Overlay implements PlayerOrb
{
	private final Client client;
	private final VerzikHandler verzikHandler;
	private final TobUtilitiesConfig config;

	@Inject
	protected PlayerTwoOrbOverlay(Client client, VerzikHandler verzikHandler, TobUtilitiesConfig config)
	{
		this.client = client;
		this.verzikHandler = verzikHandler;
		this.config = config;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.MANUAL);
		drawAfterLayer(TobPlayerOrb.PLAYER_2.getOrbBackgroundId());
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		Color overlayColor = getOverlayColor(verzikHandler, config);
		if (!TobPlayerOrb.PLAYER_2.equals(verzikHandler.getTobPlayerOrb()))
		{
			return null;
		}
		return getDimension(graphics, overlayColor, client, verzikHandler);
	}
}

package com.tobutilities.common.player;

import com.tobutilities.TobUtilitiesConfig;
import com.tobutilities.verzik.VerzikHandler;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

public class PlayerFourOrbOverlay extends Overlay implements PlayerOrb
{
	private final Client client;
	private final VerzikHandler verzikHandler;
	private final TobUtilitiesConfig config;

	@Inject
	protected PlayerFourOrbOverlay(Client client, VerzikHandler verzikHandler, TobUtilitiesConfig config)
	{
		this.client = client;
		this.verzikHandler = verzikHandler;
		this.config = config;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.MANUAL);
		drawAfterLayer(TobPlayerOrb.PLAYER_4.getOrbBackgroundId());
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		Color overlayColor = getOverlayColor(verzikHandler, config);
		if (!TobPlayerOrb.PLAYER_4.equals(verzikHandler.getTobPlayerOrb()))
		{
			return null;
		}
		return getDimension(graphics, overlayColor, client, verzikHandler);
	}
}

package com.tobutilities.common.player;

import com.tobutilities.TobUtilitiesConfig;
import com.tobutilities.verzik.VerzikHandler;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

public class PlayerThreeOrbOverlay extends Overlay implements PlayerOrb
{
	private final Client client;
	private final VerzikHandler verzikHandler;
	private final TobUtilitiesConfig config;

	@Inject
	protected PlayerThreeOrbOverlay(Client client, VerzikHandler verzikHandler, TobUtilitiesConfig config)
	{
		this.client = client;
		this.verzikHandler = verzikHandler;
		this.config = config;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.MANUAL);
		drawAfterLayer(TobPlayerOrb.PLAYER_3.getOrbBackgroundId());
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		Color overlayColor = getOverlayColor(verzikHandler, config);
		if (!TobPlayerOrb.PLAYER_3.equals(verzikHandler.getTobPlayerOrb()))
		{
			return null;
		}
		return getDimension(graphics, overlayColor, client, verzikHandler);
	}
}

package com.tobutilities.common.player;

import lombok.Getter;

@Getter
public enum TobPlayerOrb
{

	PLAYER_1(1, 330, 1835026, 1835027),
	PLAYER_2(2, 331, 1835030, 1835031),
	PLAYER_3(3, 332, 1835034, 1835035),
	PLAYER_4(4, 333, 1835038, 1835039),
	PLAYER_5(5, 334, 1835042, 1835043),
	UNKNOWN(0, 0, 0, 0);

	private final int orbPosition;

	/**
	 * the Varc ID which contains the name of the player the orb belongs to
	 */
	private final int nameVarc;

	private final int orbId;

	private final int orbBackgroundId;


	TobPlayerOrb(int orbPosition, int nameVarc, int orbId, int orbBackgroundId)
	{
		this.orbPosition = orbPosition;
		this.nameVarc = nameVarc;
		this.orbId = orbId;
		this.orbBackgroundId = orbBackgroundId;
	}

	@Override
	public String toString()
	{
		return "TobPlayerOrb{" +
			"orbPosition=" + orbPosition +
			", nameVarc=" + nameVarc +
			", orbId=" + orbId +
			", orbBackgroundId=" + orbBackgroundId +
			'}';
	}
}

package com.tobutilities.common.player;

import com.tobutilities.TobUtilitiesConfig;
import com.tobutilities.verzik.DawnbringerStatus;
import com.tobutilities.verzik.VerzikHandler;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;

public interface PlayerOrb
{

	default Dimension getDimension(Graphics2D graphics, Color overlayColor, Client client, VerzikHandler verzikHandler)
	{
		Widget playerOrbWidget = client.getWidget(verzikHandler.getTobPlayerOrb().getOrbId());
		if (playerOrbWidget != null)
		{
			Rectangle bounds = playerOrbWidget.getBounds();
			graphics.setColor(overlayColor);
			graphics.fillOval(bounds.x, bounds.y, bounds.width, bounds.height);
		}
		return null;
	}

	default Color getOverlayColor(VerzikHandler verzikHandler, TobUtilitiesConfig config){
		if (DawnbringerStatus.IN_INVENTORY.equals(verzikHandler.getDawnbringerStatus())){
			return config.dawnbringerInventoryOverlayColor();
		} else {
			return config.dawnbringerEquippedOverlayColor();
		}
	}
}

package com.tobutilities.common.player;

import com.tobutilities.TobUtilitiesConfig;
import com.tobutilities.verzik.DawnbringerStatus;
import com.tobutilities.verzik.VerzikHandler;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

public class PlayerFiveOrbOverlay extends Overlay implements PlayerOrb
{
	private final Client client;
	private final VerzikHandler verzikHandler;
	private final TobUtilitiesConfig config;

	@Inject
	protected PlayerFiveOrbOverlay(Client client, VerzikHandler verzikHandler, TobUtilitiesConfig config)
	{
		this.client = client;
		this.verzikHandler = verzikHandler;
		this.config = config;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.MANUAL);
		drawAfterLayer(TobPlayerOrb.PLAYER_5.getOrbBackgroundId());
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		Color overlayColor = getOverlayColor(verzikHandler, config);
		if (!TobPlayerOrb.PLAYER_5.equals(verzikHandler.getTobPlayerOrb()))
		{
			return null;
		}
		return getDimension(graphics, overlayColor, client, verzikHandler);
	}
}

package com.tobutilities.common;

import com.google.inject.Provides;
import com.tobutilities.TobUtilitiesConfig;
import com.tobutilities.TobUtilitiesPlugin;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.ui.overlay.OverlayManager;

public class RoomHandler
{
	@Inject
	protected Client client;
	@Inject
	private OverlayManager overlayManager;
	@Inject
	private ConfigManager configManager;

	protected TobUtilitiesConfig config;

	protected TobUtilitiesPlugin plugin;

	@Provides
	TobUtilitiesConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(TobUtilitiesConfig.class);
	}

	@Inject
	protected RoomHandler(TobUtilitiesPlugin plugin, TobUtilitiesConfig config, Client client)
	{
		this.plugin = plugin;
		this.config = config;
		this.client = client;
	}

}

package com.tobutilities.bloat;

import static com.tobutilities.bloat.BloatConstants.BLOAT_FLOOR_IDS;
import static com.tobutilities.bloat.BloatConstants.PESTILENT_BLOAT;
import com.tobutilities.common.RoomHandler;
import com.tobutilities.TobUtilitiesPlugin;
import com.tobutilities.TobUtilitiesConfig;
import javax.inject.Inject;

import com.tobutilities.common.enums.Region;
import lombok.extern.slf4j.Slf4j;

import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.events.BeforeRender;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;

import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;

import java.util.HashMap;
import java.util.Map;

@Slf4j
public class BloatHandler extends RoomHandler
{
	private boolean isBloatAlive = false;
    private final Map<LocalPoint, GroundObject> hiddenObjects = new HashMap<>();
    private int bloatSkyboxColor;
    private boolean bloatSkyboxOverride;
    private boolean hideBloatFloor;
    private String originalHdSkyColorConfig;
    private String originalHdSkyConfig;
    private boolean hdConfigApplied;

    @Inject
    private ConfigManager configManager;

	@Inject
	protected BloatHandler(TobUtilitiesPlugin plugin, TobUtilitiesConfig config, Client client)
	{
		super(plugin, config, client);
	}

	public boolean shouldDraw(Renderable renderable, boolean drawingUi)
	{
		if (renderable instanceof Player && isBloatAlive)
		{
			if (drawingUi){
				return true;
			}
			Player player = (Player) renderable;
			if (player.equals(client.getLocalPlayer()))
			{
				return !config.hideLocalPlayerDuringBloat();
			}
			else
			{
				return !config.hideOtherPlayersDuringBloat();
			}
		}
		return true;
	}

	@Subscribe
	public void onGameTick(GameTick tick)
	{
		for (NPC npc : client.getWorldView(-1).npcs())
		{
			if (PESTILENT_BLOAT.equals(npc.getName()))
			{
				isBloatAlive = !npc.isDead();
                break;
			}
		}
        updateHdConfig();
        updateGroundObjects();
	}

    @Subscribe
    public void onGameStateChanged(GameStateChanged event)
    {
        switch (event.getGameState())
        {
            case LOADING:
                hiddenObjects.clear();
                break;

            case LOGGED_IN:
                if (plugin.region == Region.BLOAT)
                {
                    updateGroundObjects();
                    updateHdConfig();
                }
                break;

            case LOGIN_SCREEN:
                hiddenObjects.clear();
                restoreHdConfig();
                break;
        }
    }

    @Subscribe(priority = -1.0f)
    public void onBeforeRender(BeforeRender r)
    {
        if (bloatSkyboxOverride && client.getGameState() == GameState.LOGGED_IN)
        {
            client.setSkyboxColor(bloatSkyboxColor);
        }
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event)
    {
        if (event.getGroup().equals("tobutilities"))
        {
            switch (event.getKey())
            {
                case "hideBloatFloor":
                    hideBloatFloor = config.hideBloatFloor();
                    updateGroundObjects();
                    break;

                case "bloatSkyboxOverride":
                    bloatSkyboxOverride = config.enableBloatSkyboxOverride();
                    updateHdConfig();
                    break;

                case "bloatSkyboxColor":
                    bloatSkyboxColor = config.bloatSkyboxColor().getRGB();
                    break;
            }
        }
    }

    private void updateGroundObjects()
    {
        if (hideBloatFloor)
        {
            hideGroundObjects();
        }
        else
        {
            unhideGroundObjects();
        }
    }

    private void hideGroundObjects()
    {
        Scene scene = client.getTopLevelWorldView().getScene();

        if (scene == null)
        {
            return;
        }

        Tile[][][] tiles = scene.getTiles();

        for (int z = 0; z < Constants.MAX_Z; z++)
        {
            if (tiles[z] == null) continue;

            for (int x = 0; x < Constants.SCENE_SIZE; x++)
            {
                if (tiles[z][x] == null) continue;

                for (int y = 0; y < Constants.SCENE_SIZE; y++)
                {
                    Tile tile = tiles[z][x][y];
                    if (tile == null)
                    {
                        continue;
                    }

                    GroundObject groundObject = tile.getGroundObject();
                    if (groundObject != null && BLOAT_FLOOR_IDS.contains(groundObject.getId()))
                    {
                        LocalPoint lp = tile.getLocalLocation();

                        // Skip if already hidden
                        if (hiddenObjects.containsKey(lp)) continue;

                        // Cache original object
                        hiddenObjects.put(lp, groundObject);

                        // Remove it from the scene
                        tile.setGroundObject(null);
                    }
                }
            }
        }
    }

    private void unhideGroundObjects()
    {
        Scene scene = client.getTopLevelWorldView().getScene();
        if (scene == null)
        {
            hiddenObjects.clear();
            return;
        }

        for (Map.Entry<LocalPoint, GroundObject> entry : hiddenObjects.entrySet())
        {
            LocalPoint lp = entry.getKey();
            Tile tile = getTileAtLocalPoint(lp);
            if (tile == null)
                continue;

            // Restore ground object if not already present
            if (tile.getGroundObject() == null)
            {
                tile.setGroundObject(entry.getValue());
            }
        }
        hiddenObjects.clear();
    }

    private Tile getTileAtLocalPoint(LocalPoint point)
    {
        WorldView wv = client.getTopLevelWorldView();
        Scene scene = wv.getScene();
        Tile[][] tiles = scene.getTiles()[wv.getPlane()];
        int sceneX = point.getSceneX();
        int sceneY = point.getSceneY();

        if (sceneX < 0 || sceneY < 0 || sceneX >= Constants.SCENE_SIZE || sceneY >= Constants.SCENE_SIZE)
        {
            return null;
        }

        return tiles[sceneX][sceneY];
    }

    private void updateHdConfig() {
        if (bloatSkyboxOverride && !hdConfigApplied)
        {
            overrideHdConfig();
        }
        else if (!bloatSkyboxOverride && hdConfigApplied)
        {
            restoreHdConfig();
        }
    }

    private void overrideHdConfig() {
        final String group = "hd";
        // Save original hd config
        if (originalHdSkyColorConfig == null)
        {
            originalHdSkyColorConfig = configManager.getConfiguration(group, "defaultSkyColor");
        }
        if (originalHdSkyConfig == null)
        {
            originalHdSkyConfig = configManager.getConfiguration(group, "overrideSky");
        }

        // Apply temporary overrides
        configManager.setConfiguration(group, "defaultSkyColor", "RUNELITE");
        configManager.setConfiguration(group, "overrideSky", "true");

        hdConfigApplied = true;
        log.debug("Applied 117 HD config overrides for Bloat");
    }

    private void restoreHdConfig() {
        final String group = "hd";
        // Restore original hd config
        if (originalHdSkyColorConfig != null)
        {
            configManager.setConfiguration(group, "defaultSkyColor", originalHdSkyColorConfig);
        }
        if (originalHdSkyConfig != null)
        {
            configManager.setConfiguration(group, "overrideSky", originalHdSkyConfig);
        }

        hdConfigApplied = false;
        originalHdSkyColorConfig = null;
        originalHdSkyConfig = null;
        log.debug("Restored original 117 HD config");
    }

    public void onRoomExit()
    {
        restoreHdConfig();
        unhideGroundObjects();
    }

    public void startUp()
    {
        hideBloatFloor = config.hideBloatFloor();
        bloatSkyboxColor = config.bloatSkyboxColor().getRGB();
        bloatSkyboxOverride = config.enableBloatSkyboxOverride();
        if (client.getGameState() == GameState.LOGGED_IN)
        {
            updateGroundObjects();
            updateHdConfig();
        }
    }

    public void shutDown()
    {
        onRoomExit();
    }
}

package com.tobutilities.bloat;

import java.util.List;

public class BloatConstants

{
	public static final String PESTILENT_BLOAT = "Pestilent Bloat";
    public static final List<Integer> BLOAT_FLOOR_IDS = List.of(
            32941,
            32942,
            32943,
            32944,
            32945,
            32946,
            32947,
            32948
    );
}

package com.tobutilities.bloat;

import com.tobutilities.TobUtilitiesConfig;
import com.tobutilities.TobUtilitiesPlugin;
import com.tobutilities.common.enums.Region;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;

public class BloatPlayerOverlay extends Overlay
{
	private final Client client;
	private final TobUtilitiesConfig config;
	private final ModelOutlineRenderer modelOutlineRenderer;
	private final TobUtilitiesPlugin plugin;

	@Inject
	private BloatPlayerOverlay(Client client, TobUtilitiesConfig config, ModelOutlineRenderer modelOutlineRenderer, TobUtilitiesPlugin plugin)
	{
		this.client = client;
		this.config = config;
		this.modelOutlineRenderer = modelOutlineRenderer;
		this.plugin = plugin;

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (Region.BLOAT.equals(plugin.region) && config.enableOutlinePlayers())
		{
			for (Player player : client.getWorldView(-1).players())
			{
				if (player == null || player.isDead())
				{
					continue;
				}

				Color highlight = config.getHighlightColor();
				modelOutlineRenderer.drawOutline(player, config.getBorderWidth(), highlight, 1);

			}
		}
		return null;
	}
}
package com.tobutilities;

import com.google.common.annotations.VisibleForTesting;
import com.google.inject.Provides;
import com.tobutilities.bloat.BloatHandler;
import com.tobutilities.bloat.BloatPlayerOverlay;
import com.tobutilities.common.metronome.MetronomeService;
import com.tobutilities.common.metronome.MetronomeOverlay;
import com.tobutilities.common.enums.Region;
import com.tobutilities.maiden.MaidenHandler;
import com.tobutilities.maiden.ScuffWarningOverlay;
import com.tobutilities.maiden.ScuffedNylocasOverlay;
import com.tobutilities.common.player.PlayerOneOrbOverlay;
import com.tobutilities.common.player.PlayerTwoOrbOverlay;
import com.tobutilities.common.player.PlayerThreeOrbOverlay;
import com.tobutilities.common.player.PlayerFourOrbOverlay;
import com.tobutilities.common.player.PlayerFiveOrbOverlay;
import com.tobutilities.nylocas.NylocasHandler;
import com.tobutilities.nylocas.NylocasOverlay;
import com.tobutilities.verzik.DawnbringerStatusMessage;
import com.tobutilities.verzik.LightbearerWarningOverlay;
import com.tobutilities.verzik.VerzikHandler;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;

import net.runelite.client.callback.Hooks;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.input.KeyManager;
import net.runelite.client.party.WSClient;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.HotkeyListener;

import javax.inject.Inject;
import java.awt.event.KeyEvent;

@PluginDescriptor(
	name = "ToB Utilities",
	description = "Various tools for the theatre of blood",
	tags = {"timers", "overlays", "tick", "theatre", "metronome", "tob", "maiden", "bloat", "nylo", "xarpus", "verzik"}
)
@Slf4j
public class TobUtilitiesPlugin extends Plugin
{
	@Inject
	private OverlayManager overlayManager;
	@Inject
	public InfoBoxManager infoBoxManager;
	@Inject
	public ConfigManager configManager;
	@Inject
	private Client client;
	@Inject
	private MetronomeOverlay metronomeOverlay;
	@Inject
	private PlayerOneOrbOverlay playerOneOrbOverlay;
	@Inject
	private PlayerTwoOrbOverlay playerTwoOrbOverlay;
	@Inject
	private PlayerThreeOrbOverlay playerThreeOrbOverlay;
	@Inject
	private PlayerFourOrbOverlay playerFourOrbOverlay;
	@Inject
	private PlayerFiveOrbOverlay playerFiveOrbOverlay;
	@Inject
	private ScuffedNylocasOverlay scuffedNylocasOverlay;
	@Inject
	private ScuffWarningOverlay scuffWarningOverlay;
	@Inject
	private BloatPlayerOverlay bloatPlayerOverlay;
	@Inject
	private LightbearerWarningOverlay lightbearerWarningOverlay;
	@Inject
	private NylocasOverlay nylocasOverlay;
	@Inject
	private TobUtilitiesConfig config;
	@Inject
	private KeyManager keyManager;
	@Inject
	private Hooks hooks;
	@Inject
	private MaidenHandler maidenHandler;
	@Inject
	private BloatHandler bloatHandler;
	@Inject
	private NylocasHandler nylocasHandler;

	@Inject
	private VerzikHandler verzikHandler;
	@Inject
	private MetronomeService metronomeService;
	@Inject
	private WSClient wsClient;


	public Region region = Region.UNKNOWN;
	private final Hooks.RenderableDrawListener drawListener = this::shouldDraw;

	@Provides
	TobUtilitiesConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(TobUtilitiesConfig.class);
	}

	@Subscribe
	public void onGameTick(GameTick tick)
	{
		Region oldRegion = region;
        // metronomeService updates region
		metronomeService.onGameTick(tick);
		if (oldRegion.equals(Region.BLOAT) && !region.equals(Region.BLOAT))
		{
			bloatHandler.onRoomExit();
		}
		if (region.equals(Region.MAIDEN))
		{
			maidenHandler.onGameTick(tick);
		}
		else if (region.equals(Region.VERZIK))
		{
			verzikHandler.onGameTick(tick);
		}
		else if (region.equals(Region.BLOAT))
		{
			bloatHandler.onGameTick(tick);
		}
	}


	private final HotkeyListener hideVerzikHotkeyListener = new HotkeyListener(() -> config.hideVerzikHotkey())
	{
		@Override
		public void keyPressed(KeyEvent e)
		{
			if (Region.VERZIK.equals(region))
			{
				verzikHandler.keyPressed(e);
			}
		}

		@Override
		public void keyReleased(KeyEvent e)
		{
			hotkeyReleased();
		}
	};

	private final HotkeyListener metronomeResetHotkeyListener = new HotkeyListener(() -> config.metronomeResetHotkey())
	{
		@Override
		public void keyPressed(KeyEvent e)
		{
			metronomeService.keyPressed(e);
		}

		@Override
		public void keyReleased(KeyEvent e)
		{
			hotkeyReleased();
		}
	};


	@Subscribe
	public void onNpcSpawned(NpcSpawned event)
	{
		if (Region.MAIDEN.equals(region))
		{
			maidenHandler.onNpcSpawned(event);
		}
		else if (Region.NYLOCAS.equals(region))
		{
			nylocasHandler.onNpcSpawned(event);
		}
	}


	@VisibleForTesting
	boolean shouldDraw(Renderable renderable, boolean drawingUI)
	{
		if (Region.BLOAT.equals(region))
		{
			return bloatHandler.shouldDraw(renderable, drawingUI);
		}

		if (Region.VERZIK.equals(region))
		{
			return verzikHandler.shouldDraw(renderable, drawingUI);
		}
		return true;
	}


	@Subscribe
	void onActorDeath(ActorDeath event)
	{
		if (Region.NYLOCAS.equals(region))
		{
			nylocasHandler.onActorDeath(event);
		}
	}

	@Subscribe
	public void onNpcChanged(NpcChanged event)
	{
		if (Region.NYLOCAS.equals(region))
		{
			nylocasHandler.onNpcChanged(event);
		}
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned event)
	{
		if (Region.MAIDEN.equals(region))
		{
			maidenHandler.onNpcDespawned(event);
		}
		else if (Region.NYLOCAS.equals(region))
		{
			nylocasHandler.onNpcDespawned(event);
		}
	}

	@Subscribe
	public void onDawnbringerStatusMessage(DawnbringerStatusMessage message)
	{
		verzikHandler.onDawnbringerStatusMessage(message);
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event)
	{
		if (Region.VERZIK.equals(region)){
			verzikHandler.onItemContainerChanged(event);
		}
	}

    @Subscribe (priority = -1.0f)
    public void onBeforeRender(BeforeRender r)
    {
        if (region.equals(Region.BLOAT)) {
            bloatHandler.onBeforeRender(r);
        }
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event)
    {
        bloatHandler.onConfigChanged(event);
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event)
    {
        bloatHandler.onGameStateChanged(event);
    }

	@Override
	protected void startUp() throws Exception
	{
		overlayManager.add(metronomeOverlay);
		overlayManager.add(playerOneOrbOverlay);
		overlayManager.add(playerTwoOrbOverlay);
		overlayManager.add(playerThreeOrbOverlay);
		overlayManager.add(playerFourOrbOverlay);
		overlayManager.add(playerFiveOrbOverlay);
		overlayManager.add(scuffedNylocasOverlay);
		overlayManager.add(scuffWarningOverlay);
		overlayManager.add(bloatPlayerOverlay);
		overlayManager.add(lightbearerWarningOverlay);
		overlayManager.add(nylocasOverlay);
        bloatHandler.startUp();
		verzikHandler.startUp();
		wsClient.registerMessage(DawnbringerStatusMessage.class);
		keyManager.registerKeyListener(hideVerzikHotkeyListener);
		keyManager.registerKeyListener(metronomeResetHotkeyListener);
		hooks.registerRenderableDrawListener(drawListener);
	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove(metronomeOverlay);
		overlayManager.remove(playerOneOrbOverlay);
		overlayManager.remove(playerTwoOrbOverlay);
		overlayManager.remove(playerThreeOrbOverlay);
		overlayManager.remove(playerFourOrbOverlay);
		overlayManager.remove(playerFiveOrbOverlay);
		overlayManager.remove(scuffedNylocasOverlay);
		overlayManager.remove(scuffWarningOverlay);
		overlayManager.remove(bloatPlayerOverlay);
		overlayManager.remove(lightbearerWarningOverlay);
		overlayManager.remove(nylocasOverlay);
		nylocasHandler.shutDown();
		maidenHandler.shutDown();
        bloatHandler.shutDown();
		verzikHandler.shutDown();
		wsClient.unregisterMessage(DawnbringerStatusMessage.class);
		keyManager.unregisterKeyListener(hideVerzikHotkeyListener);
		keyManager.unregisterKeyListener(metronomeResetHotkeyListener);
		hooks.unregisterRenderableDrawListener(drawListener);
	}
}

package com.tobutilities;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class TobUtilitiesTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(TobUtilitiesPlugin.class);
		RuneLite.main(args);
	}
}
