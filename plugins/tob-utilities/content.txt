package com.tobutilities;

import com.tobutilities.common.enums.FontType;
import net.runelite.client.config.*;

import java.awt.*;

@ConfigGroup("tobutilities")
public interface TobUtilitiesConfig extends Config
{
	@ConfigSection(
		name = "Metronome",
		description = "Config for visual Metronome",
		position = 6
	)
	String Metronome = "Metronome";

	@ConfigItem(
		position = 1,
		keyName = "enableNylocas Metronome",
		name = "Enable Nylocas Metronome",
		description = "Enable visual metronome in Nylo room",
		section = Metronome
	)
	default boolean enableNyloMetronome()
	{
		return false;
	}

	@ConfigItem(
		position = 2,
		keyName = "enableSotetsegMetronome",
		name = "Enable Sotetseg Metronome",
		description = "Enable visual metronome in Sotetseg room",
		section = Metronome
	)
	default boolean enableSoteMetronome()
	{
		return false;
	}

	@ConfigItem(
		position = 3,
		keyName = "enableXarpusMetronome",
		name = "Enable Xarpus Metronome",
		description = "Enable visual metronome in Xarpus room",
		section = Metronome
	)
	default boolean enableXarpusMetronome()
	{
		return false;
	}

	@ConfigItem(
		position = 4,
		keyName = "enableVerzikMetronome",
		name = "Enable Verik Metronome",
		description = "Enable visual metronome in Verzik room",
		section = Metronome
	)
	default boolean enableVerzikMetronome()
	{
		return false;
	}

	@ConfigItem(
		position = 5,
		keyName = "countColor",
		name = "Tick Number Color",
		description = "Configures the color of tick number",
		section = Metronome
	)
	default Color NumberColor()
	{
		return Color.CYAN;
	}

	@ConfigItem(
		position = 6,
		keyName = "metronomeBorderWidth",
		name = "MetronomeBorderWidth",
		description = "Configures the width of the colored metronome border",
		section = Metronome
	)
	default int metronomeBorderWidth()
	{
		return 2;
	}


	@ConfigItem(
		position = 7,
		keyName = "fontType",
		name = "Font Type",
		description = "Change the font of the Tick Number",
		section = Metronome
	)
	default FontType fontType()
	{
		return FontType.REGULAR;
	}

	@Alpha
	@ConfigItem(
		position = 8,
		keyName = "tick1Color",
		name = "1st Tick Color",
		description = "Configures the color of 1st tick",
		section = Metronome
	)
	default Color getTick1Color()
	{
		return Color.WHITE;
	}

	@Alpha
	@ConfigItem(
		position = 9,
		keyName = "tick2Color",
		name = "2nd Tick Color",
		description = "Configures the color of 2nd tick",
		section = Metronome
	)
	default Color getTick2Color()
	{
		return Color.GRAY;
	}

	@Alpha
	@ConfigItem(
		position = 10,
		keyName = "tick3Color",
		name = "3rd Tick Color",
		description = "Configures the color of 3rd tick if enabled",
		section = Metronome
	)
	default Color getTick3Color()
	{
		return Color.DARK_GRAY;
	}

	@Alpha
	@ConfigItem(
		position = 11,
		keyName = "tick4Color",
		name = "4th Tick Color",
		description = "Configures the color of the 4rd tick if enabled",
		section = Metronome
	)
	default Color getTick4Color()
	{
		return Color.BLACK;
	}

	@Alpha
	@ConfigItem(
		position = 12,
		keyName = "tick5Color",
		name = "5th Tick Color",
		description = "Configures the color of the 5th tick if enabled",
		section = Metronome
	)
	default Color getTick5Color()
	{
		return new Color(112, 131, 255);
	}

	@Alpha
	@ConfigItem(
		position = 13,
		keyName = "tick6Color",
		name = "6th Tick Color",
		description = "Configures the color of the 6th tick if enabled",
		section = Metronome
	)
	default Color getTick6Color()
	{
		return new Color(0, 23, 171);
	}

	@Alpha
	@ConfigItem(
		position = 14,
		keyName = "tick7Color",
		name = "7th Tick Color",
		description = "Configures the color of the 7th tick if enabled",
		section = Metronome
	)
	default Color getTick7Color()
	{
		return new Color(107, 255, 124);
	}

	@ConfigSection(
		name = "Maiden",
		description = "Change Maiden settings",
		position = 1
	)
	String Maiden = "Maiden Settings";

	@ConfigItem(
		position = 0,
		keyName = "maidenScuffWarning",
		name = "Maiden Scuff Warning",
		description = "Sends a message with Maidens index, lets you know if you should expect scuffed nylos",
		section = Maiden
	)
	default boolean enableMaidenIndexMessage()
	{
		return true;
	}

	@ConfigItem(
		position = 1,
		keyName = "scuffedSpawnHighlight",
		name = "Highlight scuffed spawns",
		description = "Highlights scuffed nylocas matomenos ",
		section = Maiden
	)
	default boolean enabledScuffedSpawnHighlight()
	{
		return false;
	}

	@ConfigItem(
		position = 2,
		keyName = "highlightColor",
		name = "Highlight Color",
		description = "The color to highlight Nylocas Matomenos",
		section = Maiden
	)
	default Color getHighlightColor()
	{
		return new Color(0, 0, 0, 255);
	}

	@ConfigItem(
		position = 3,
		keyName = "borderWidth",
		name = "Border Width",
		description = "Width of the highlighted border",
		section = Maiden
	)
	default int getBorderWidth()
	{
		return 2;
	}

	@ConfigItem(
		position = 4,
		keyName = "borderFeather",
		name = "Border Feather",
		description = "Feather of the highlighted border",
		section = Maiden
	)
	default int getBorderFeather()
	{
		return 2;
	}


	@ConfigSection(
		name = "Bloat",
		description = "Change Bloat settings",
		position = 2
	)
	String Bloat = "Bloat Settings";

	@ConfigItem(
		keyName = "hideSelfDuringBloat",
		name = "Hide self",
		description = "Enable hiding of local player while bloat is alive",
		position = 1,
		section = Bloat
	)
	default boolean hideLocalPlayerDuringBloat()
	{
		return false;
	}

	@ConfigItem(
		keyName = "hideOthersDuringBloat",
		name = "Hide others",
		description = "Enable hiding of other players while bloat is alive",
		position = 2,
		section = Bloat
	)
	default boolean hideOtherPlayersDuringBloat()
	{
		return false;
	}

	@ConfigSection(
		name = "Nylocas",
		description = "Change Nylocas settings",
		position = 3
	)
	String Nylocas = "Nylocas Settings";

	@ConfigItem(
		keyName = "enableHighlightAggressiveNylos",
		name = "Highlight aggressive nylos",
		description = "Enables highlighting aggressive nylos",
		position = 1,
		section = Nylocas
	)
	default boolean enableHighlightAggressiveNylos()
	{
		return false;
	}


	@ConfigSection(
		name = "Verzik",
		description = "Change Verzik settings",
		position = 5
	)
	String Verzik = "Verzik Settings";

	@ConfigItem(
		keyName = "enableHideVerzikHotkey",
		name = "Enable hide Verzik ",
		description = "Enable ability to hide P3 Verzik using a hotkey ",
		position = 1,
		section = Verzik
	)
	default boolean enableHideVerzik()
	{
		return false;
	}

	@ConfigItem(
		keyName = "hideVerzikHotkey",
		name = "Hide Verzik Hotkey",
		description = "Key to hide verzik ",
		position = 2,
		section = Verzik
	)
	default Keybind hideVerzikHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
		keyName = "enableDawnbringerOverlay",
		name = "Enable dawnbringer overlay ",
		description = "Enable overlay over player orb to show who is currently holding dawnbringer",
		position = 3,
		section = Verzik
	)
	default boolean enableDawnbringerOverlay()
	{
		return true;
	}

	@ConfigItem(
		keyName = "dawnbringerOverlayColor",
		name = "Dawnbringer overlay color",
		description = "Color for dawnbringer holders orb",
		position = 4,
		section = Verzik
	)
	default Color dawnbringerOverlayColor()
	{
		return new Color(0, 82, 87);
	}

}


package com.tobutilities.verzik;

public class VerzikConstants
{
	public static final String VERZIK_NAME = "Verzik Vitur";
}

package com.tobutilities.verzik;

import com.tobutilities.common.RoomHandler;


import com.tobutilities.common.player.TobPlayerOrb;
import com.tobutilities.TobUtilitiesPlugin;
import com.tobutilities.TobUtilitiesConfig;

import static com.tobutilities.verzik.VerzikConstants.VERZIK_NAME;
import java.awt.event.KeyEvent;
import javax.inject.Inject;

import javax.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.Renderable;
import net.runelite.api.events.GameTick;
import static net.runelite.api.kit.KitType.WEAPON;

import net.runelite.client.eventbus.Subscribe;


@Slf4j
@Singleton
public class VerzikHandler extends RoomHandler

{
	@Getter
	private TobPlayerOrb tobPlayerOrb = TobPlayerOrb.UNKNOWN;
	private boolean isVerzikHidden = false;

	@Inject
	protected VerzikHandler(TobUtilitiesPlugin plugin, TobUtilitiesConfig config, Client client)
	{
		super(plugin, config, client);
	}


	@Subscribe
	public void onGameTick(GameTick tick)
	{
		if (config.enableDawnbringerOverlay())
		{
			String dawnbringerHolderName = removeNonAlphanumeric(getDawnbringerHolderName());
			if (dawnbringerHolderName != null)
			{
				for (TobPlayerOrb tobPlayer : TobPlayerOrb.values())
				{
					String playerName = removeNonAlphanumeric(client.getVarcStrValue(tobPlayer.getNameVarc()));
					if (playerName.equals(dawnbringerHolderName))
					{
						tobPlayerOrb = tobPlayer;
						return;
					}
				}
			}
			tobPlayerOrb = TobPlayerOrb.UNKNOWN;
		}
	}


	private String getDawnbringerHolderName()
	{

		for (Player player : client.getWorldView(-1).players())
		{
			if (player == null || player.getName() == null)
			{
				log.info("Invalid/Null player");
				continue; // Skip null or invalid players
			}
			int weaponId = player.getPlayerComposition().getEquipmentId(WEAPON);
			if (weaponId == ItemID.DAWNBRINGER)
			{
				return player.getName(); // Stop once we find a match
			}
		}
		return null;
	}

	private static String removeNonAlphanumeric(String str)
	{
		if (str == null)
		{
			return null;
		}
		str = str.replaceAll(
			"[^a-zA-Z0-9]", "");
		return str;
	}

	public void keyPressed(KeyEvent e)
	{
		if (config.hideVerzikHotkey().matches(e))
		{
			if (config.enableHideVerzik())
			{
				isVerzikHidden = !isVerzikHidden;
				e.consume();
			}
		}
	}

	public boolean shouldDraw(Renderable renderable, boolean drawingUI)
	{
		if (renderable instanceof NPC)
		{
			NPC npc = (NPC) renderable;
			return !VERZIK_NAME.equals(npc.getName()) || !isVerzikHidden || !config.enableHideVerzik();
		}
		return true;
	}

}

package com.tobutilities.maiden;

import com.tobutilities.TobUtilitiesConfig;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.NPCComposition;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;

public class MaidenOverlay extends Overlay
{
	private final Client client;
	private final MaidenHandler maidenHandler;
	private final TobUtilitiesConfig config;
	private final ModelOutlineRenderer modelOutlineRenderer;

	@Inject
	private MaidenOverlay(Client client, MaidenHandler maidenHandler, TobUtilitiesConfig config, ModelOutlineRenderer modelOutlineRenderer)
	{
		this.client = client;
		this.maidenHandler = maidenHandler;
		this.config = config;
		this.modelOutlineRenderer = modelOutlineRenderer;

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		// First, set up the outlines for rendering
		for (NPC npc : maidenHandler.getNylocasMatomenosSpawns())
		{
			if (npc == null || npc.isDead())
			{
				continue;
			}

			NPCComposition npcComposition = npc.getTransformedComposition();
			if (npcComposition == null)
			{
				continue;
			}

			Color highlight = config.getHighlightColor();
			modelOutlineRenderer.drawOutline(npc, config.getBorderWidth(), highlight, config.getBorderFeather());

		}

		return null;
	}
}
package com.tobutilities.maiden;

import java.util.List;
import net.runelite.api.Point;

public class MaidenConstants
{
	public static List<Point> SCUFFED_SPAWNS = List.of(
		new Point(22, 41),
		new Point(26, 41),
		new Point(30, 41),
		new Point(34, 41),
		new Point(34, 39),
		new Point(22, 19),
		new Point(26, 19),
		new Point(30, 19),
		new Point(34, 19),
		new Point(34, 21));

	public static final String THE_MAIDEN_OF_SUGADINTI = "The Maiden of Sugadinti";
	public static final String NYLOCAS_MATOMENOS = "Nylocas Matomenos";
}

package com.tobutilities.maiden;

import com.tobutilities.TobUtilitiesConfig;
import com.tobutilities.TobUtilitiesPlugin;
import com.tobutilities.common.RoomHandler;
import static com.tobutilities.maiden.MaidenConstants.NYLOCAS_MATOMENOS;
import static com.tobutilities.maiden.MaidenConstants.THE_MAIDEN_OF_SUGADINTI;
import java.awt.Color;
import java.util.ArrayList;
import java.util.List;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Point;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.eventbus.Subscribe;
import org.apache.commons.lang3.StringUtils;

@Slf4j
@Singleton
public class MaidenHandler extends RoomHandler
{
	private final List<NPC> nylocasMatomenosSpawns = new ArrayList<>();

	public List<NPC> getNylocasMatomenosSpawns()
	{
		return nylocasMatomenosSpawns;
	}

	@Inject
	protected MaidenHandler(TobUtilitiesPlugin plugin, TobUtilitiesConfig config, Client client)
	{
		super(plugin, config, client);
	}

	@Inject
	private ChatMessageManager chatMessageManager;

	@Subscribe
	public void onNpcSpawned(NpcSpawned event)
	{
		NPC npc = event.getNpc();
		if (npc != null)
		{

			if (StringUtils.isNotBlank(npc.getName()) && THE_MAIDEN_OF_SUGADINTI.equals(npc.getName()))
			{
				nylocasMatomenosSpawns.clear();
				if (config.enableMaidenIndexMessage())
				{
					handleScuffedSpawnChatMessage(npc);
				}
			}
			if (config.enabledScuffedSpawnHighlight())
			{
				int x = npc.getWorldLocation().getRegionX();
				int y = npc.getWorldLocation().getRegionY();
				Point p = new Point(x, y);
				if (MaidenConstants.SCUFFED_SPAWNS.contains(p) && NYLOCAS_MATOMENOS.equals(npc.getName()) && !nylocasMatomenosSpawns.contains(npc))
				{
					nylocasMatomenosSpawns.add(npc);
				}
			}
		}
	}

	private void handleScuffedSpawnChatMessage(NPC npc)
	{
		int maidenIndex = npc.getIndex();

		String chatMessage;
		if (maidenIndex < 58000)
		{
			chatMessage = new ChatMessageBuilder()
				.append(ChatColorType.HIGHLIGHT)
				.append(Color.GREEN, String.format("There is no reasonable risk of a scuff. Maiden index: %d", maidenIndex))
				.build();
		}
		else if (maidenIndex < 60000)
		{
			chatMessage = new ChatMessageBuilder()
				.append(ChatColorType.HIGHLIGHT)
				.append(Color.GREEN, String.format("A scuff is very unlikely (possible in small scales). Maiden index: %d", maidenIndex))
				.build();
		}
		else if (maidenIndex < 62000)
		{
			chatMessage = new ChatMessageBuilder()
				.append(ChatColorType.HIGHLIGHT)
				.append(Color.GREEN, String.format("A scuff is unlikely. Maiden index: %d", maidenIndex))
				.build();
		}
		else if (maidenIndex < 64000)
		{
			chatMessage = new ChatMessageBuilder()
				.append(ChatColorType.HIGHLIGHT)
				.append(Color.ORANGE, String.format("A scuff is likely, especially in small scales. Maiden index: %d", maidenIndex))
				.build();
		}
		else
		{
			chatMessage = new ChatMessageBuilder()
				.append(ChatColorType.HIGHLIGHT)
				.append(Color.RED, String.format("A scuff is very likely. Maiden index: %d", maidenIndex))
				.build();
		}

		chatMessageManager.queue(QueuedMessage.builder()
			.type(ChatMessageType.CONSOLE)
			.name("ToB Utilities")
			.sender("ToB Utilities")
			.runeLiteFormattedMessage(chatMessage)
			.build());
	}


	@Subscribe
	public void onNpcDespawned(NpcDespawned event)
	{
		nylocasMatomenosSpawns.remove(event.getNpc());
	}

	public void shutDown()
	{
		nylocasMatomenosSpawns.clear();
	}

}

package com.tobutilities.nylocas;

import com.tobutilities.TobUtilitiesConfig;

import java.awt.*;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.NPCComposition;
import net.runelite.api.Perspective;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

public class NylocasOverlay extends Overlay
{
	private final Client client;
	private final NylocasHandler nylocasHandler;
	private final TobUtilitiesConfig config;
	private Polygon tilePolygon;

	@Inject
	private NylocasOverlay(Client client, NylocasHandler nylocasHandler, TobUtilitiesConfig config)
	{
		this.client = client;
		this.nylocasHandler = nylocasHandler;
		this.config = config;

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ALWAYS_ON_TOP);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (config.enableHighlightAggressiveNylos())
		{
			for (NPC npc : nylocasHandler.getAggressiveNylocas())
			{
				if (npc == null || npc.isDead())
				{
					continue;
				}

				NPCComposition npcComposition = npc.getTransformedComposition();
				if (npcComposition == null)
				{
					continue;
				}

				LocalPoint localPoint = npc.getLocalLocation();
				if (localPoint != null)
				{
					tilePolygon = Perspective.getCanvasTileAreaPoly(client, localPoint, npcComposition.getSize());
					if (tilePolygon != null)
					{
						renderPoly(graphics, tilePolygon, config.getBorderWidth());
					}
				}
			}
		}
		return null;
	}

	private void renderPoly(Graphics2D graphics, Shape polygon, double width)
	{
		if (polygon != null)
		{
			graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
			graphics.setColor(Color.RED);
			graphics.setStroke(new BasicStroke((float) width));
			graphics.draw(polygon);
		}
	}
}

package com.tobutilities.nylocas;

import java.util.List;

public class NylocasConstants
{
	public static final List<Integer> AGGRESSIVE_NYLOCAS_IDS = List.of(8348, 8349, 8350, 8351, 8352, 8353, 10797, 10798, 10799, 10800, 10801, 10802);

}

package com.tobutilities.nylocas;

import com.tobutilities.TobUtilitiesConfig;
import com.tobutilities.TobUtilitiesPlugin;
import com.tobutilities.common.RoomHandler;

import java.util.ArrayList;
import java.util.List;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.NpcChanged;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.client.eventbus.Subscribe;

import static com.tobutilities.nylocas.NylocasConstants.AGGRESSIVE_NYLOCAS_IDS;

@Singleton
public class NylocasHandler extends RoomHandler
{
	private final List<NPC> aggressiveNylocas = new ArrayList<>();

	public List<NPC> getAggressiveNylocas()
	{
		return aggressiveNylocas;
	}

	@Inject
	protected NylocasHandler(TobUtilitiesPlugin plugin, TobUtilitiesConfig config, Client client)
	{
		super(plugin, config, client);
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned event)
	{
		NPC npc = event.getNpc();
		if (AGGRESSIVE_NYLOCAS_IDS.contains(npc.getId()) && !aggressiveNylocas.contains(npc))
		{
			aggressiveNylocas.add(npc);
		}
	}

	@Subscribe
	public void onNpcChanged(NpcChanged event)
	{
		NPC npc = event.getNpc();
		if (AGGRESSIVE_NYLOCAS_IDS.contains(npc.getId()) && !aggressiveNylocas.contains(npc) && !npc.isDead())
		{
			aggressiveNylocas.add(npc);
		}
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned event)
	{
		aggressiveNylocas.remove(event.getNpc());
	}

	@Subscribe
	public void onActorDeath(ActorDeath event)
	{
		if (event.getActor() instanceof NPC)
		{
			aggressiveNylocas.remove((NPC) event.getActor());
		}
	}

	public void shutDown()
	{
		aggressiveNylocas.clear();
	}
}

package com.tobutilities.common.util;

import com.tobutilities.common.enums.Region;

public class CommonUtils
{

	public static Region getRegionByRegionId(int regionId)
	{
		switch (regionId)
		{
			case 12613:
				return Region.MAIDEN;
			case 13125:
				return Region.BLOAT;
			case 13122:
				return Region.NYLOCAS;
			case 13123:
			case 13379:
				return Region.SOTETSEG;
			case 12612:
				return Region.XARPUS;
			case 12611:
				return Region.VERZIK;
			default:
				return Region.UNKNOWN;
		}
	}
}

package com.tobutilities.common.enums;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Getter
public enum FontType
{
	REGULAR("RS Regular"),
	ARIAL("Arial"),
	CAMBRIA("Cambria"),
	ROCKWELL("Rockwell"),
	SEGOE_UI("Segoe Ui"),
	TIMES_NEW_ROMAN("Times New Roman"),
	VERDANA("Verdana");

	private final String name;

	@Override
	public String toString()
	{
		return name;
	}
}

package com.tobutilities.common.enums;

public enum Region
{
	MAIDEN(0, 1, 12613),
	BLOAT(0, 2, 13125),
	NYLOCAS(4, 3, 13122),
	SOTETSEG(4, 4, 13123),
	XARPUS(4, 5, 12612),
	VERZIK(7, 6, 12611),
	UNKNOWN(0, 0, -1);
	private final int tickCount;
	private final int waveNumber;
	private final int regionId;

	Region(int tickCount, int waveNumber, int regionId)
	{
		this.tickCount = tickCount;
		this.waveNumber = waveNumber;
		this.regionId = regionId;
	}

	public int getTickCount()
	{
		return this.tickCount;
	}

	public int getWaveNumber()
	{
		return this.waveNumber;
	}

	public int getRegionId()
	{
		return this.regionId;
	}
}

package com.tobutilities.common.metronome;

import com.tobutilities.TobUtilitiesConfig;
import com.tobutilities.common.enums.FontType;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Point;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.inject.Inject;
import java.awt.*;

@Slf4j
public class MetronomeOverlay extends Overlay
{
	private final MetronomeService metronomeService;
	private final TobUtilitiesConfig config;


	private static int TITLE_PADDING = 10;
	private static final int MINIMUM_SIZE = 16;
	private Dimension DEFAULT_SIZE = new Dimension(25, 25);

	@Inject
	protected MetronomeOverlay(MetronomeService metronomeService, TobUtilitiesConfig config)
	{
		this.metronomeService = metronomeService;
		this.config = config;
		setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
		setMinimumSize(MINIMUM_SIZE);
		setResizable(true);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		Dimension preferredSize = getPreferredSize();
		if (preferredSize == null)
		{
			preferredSize = DEFAULT_SIZE;
			setPreferredSize(preferredSize);
		}

		if (metronomeService.isMetronomeDisplayed() && metronomeService.isCurrentRegionMetronomeEnabled())
		{
			// Background
			graphics.setColor(new Color(0, 0, 0, 155)); // Semi-transparent black
			graphics.fillRect(0, 0, preferredSize.width, preferredSize.height);

			// Draw border
			graphics.setColor(metronomeService.getCurrentColor());
			graphics.setStroke(new BasicStroke(config.metronomeBorderWidth()));
			graphics.drawRect(0, 0, preferredSize.width - 1, preferredSize.height - 1);


			TITLE_PADDING = (Math.min(preferredSize.width, preferredSize.height) / 2 - 4);

			if (config.fontType() == FontType.REGULAR)
			{
				graphics.setFont(new Font(FontManager.getRunescapeFont().getName(), Font.BOLD,
					Math.min(preferredSize.width, preferredSize.height) / 2));
			}
			else
			{
				graphics.setFont(new Font(config.fontType().toString(), Font.BOLD,
					Math.min(preferredSize.width, preferredSize.height) / 2));
			}

			String tickText = String.valueOf(metronomeService.getCurrentColorIndex());
			FontMetrics fm = graphics.getFontMetrics();
			int textWidth = fm.stringWidth(tickText);

			final Point tickCounterPoint = new Point(
				preferredSize.width / 2 - textWidth / 2,
				preferredSize.height / 2 + fm.getAscent() / 2
			);

			// Draw text with a subtle shadow for better visibility
			OverlayUtil.renderTextLocation(graphics,
				new Point(tickCounterPoint.getX() + 1, tickCounterPoint.getY() + 1),
				tickText, Color.BLACK);
			OverlayUtil.renderTextLocation(graphics, tickCounterPoint, tickText, config.NumberColor());
		}
		return preferredSize;
	}
}
package com.tobutilities.common.metronome;

import com.tobutilities.TobUtilitiesConfig;
import com.tobutilities.TobUtilitiesPlugin;
import com.tobutilities.common.enums.Region;
import static com.tobutilities.common.util.CommonUtils.getRegionByRegionId;
import java.awt.Color;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameTick;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
@Singleton
public class MetronomeService

{
	@Inject
	private Client client;

	@Inject
	private TobUtilitiesPlugin plugin;

	@Inject
	private TobUtilitiesConfig config;

	private int tickCounter = 0;

	@Getter
	@Setter
	private boolean metronomeDisplayed = true;
	@Getter
	@Setter
	private Color currentColor = Color.WHITE;
	@Getter
	@Setter
	private int currentColorIndex = 0;


	@Inject
	public MetronomeService(Client client, TobUtilitiesPlugin plugin, TobUtilitiesConfig config)
	{
		this.client = client;
		this.plugin = plugin;
		this.config = config;
	}

	@Subscribe
	public void onGameTick(GameTick tick)
	{
		int regionTickCount;
		Player player = client.getLocalPlayer();
		final LocalPoint playerLocation = player.getLocalLocation();
		WorldPoint playerLocationPoint = WorldPoint.fromLocalInstance(client, playerLocation);
		final int regionId = playerLocationPoint.getRegionID();
		Region newTickRegion = getRegionByRegionId(regionId);

		if (newTickRegion != plugin.region)
		{
			if (newTickRegion.getWaveNumber() > plugin.region.getWaveNumber())
			{
				// raid has advanced to next room
				plugin.region = newTickRegion;
				if (isCurrentRegionMetronomeEnabled())
				{
					//enable metronome if applicable
					setMetronomeDisplayed(true);
				}
			}
			else
			{
				//In event of either wipe or after treasure room
				plugin.region = newTickRegion;
			}
		}

		if (plugin.region.getTickCount() == 0)
		{
			//Player is in a region where metronome isn't used
			setMetronomeDisplayed(false);
			return;
		}

		regionTickCount = plugin.region.getTickCount();

		if (getCurrentColorIndex() >= regionTickCount)
		{
			tickCounter = 0;
			setCurrentColorIndex(0);
		}

		int colorIndex = getCurrentColorIndex() + 1;
		setCurrentColorIndex(colorIndex);

		switch (colorIndex)
		{
			case 1:
				setCurrentColor(config.getTick1Color());
				break;
			case 2:
				setCurrentColor(config.getTick2Color());
				break;
			case 3:
				setCurrentColor(config.getTick3Color());
				break;
			case 4:
				setCurrentColor(config.getTick4Color());
				break;
			case 5:
				setCurrentColor(config.getTick5Color());
				break;
			case 6:
				setCurrentColor(config.getTick6Color());
				break;
			case 7:
				setCurrentColor(config.getTick7Color());
				break;
		}
		tickCounter++;
	}


	public boolean isCurrentRegionMetronomeEnabled()
	{
		Region region = plugin.region;
		if (Region.NYLOCAS.equals(region) && config.enableNyloMetronome())
		{
			return true;
		}
		else if (Region.SOTETSEG.equals(region) && config.enableSoteMetronome())
		{
			return true;
		}
		else if (Region.XARPUS.equals(region) && config.enableXarpusMetronome())
		{
			return true;
		}
		else if (Region.VERZIK.equals(region) && config.enableVerzikMetronome())
		{
			return true;
		}
		return false;
	}

}

package com.tobutilities.common.player;

import com.tobutilities.TobUtilitiesConfig;
import com.tobutilities.verzik.VerzikHandler;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

public class PlayerOneOrbOverlay extends Overlay implements PlayerOrb
{
	private final Client client;
	private final VerzikHandler verzikHandler;
	private final TobUtilitiesConfig config;

	@Inject
	protected PlayerOneOrbOverlay(Client client, VerzikHandler verzikHandler, TobUtilitiesConfig config)
	{
		this.client = client;
		this.verzikHandler = verzikHandler;
		this.config = config;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.MANUAL);
		drawAfterLayer(TobPlayerOrb.PLAYER_1.getOrbBackgroundId());
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		Color overlayColor = config.dawnbringerOverlayColor();
		if (!TobPlayerOrb.PLAYER_1.equals(verzikHandler.getTobPlayerOrb()))
		{
			return null;
		}
		return getDimension(graphics, overlayColor, client, verzikHandler);
	}
}

package com.tobutilities.common.player;

import com.tobutilities.TobUtilitiesConfig;
import com.tobutilities.verzik.VerzikHandler;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

public class PlayerTwoOrbOverlay extends Overlay implements PlayerOrb
{
	private final Client client;
	private final VerzikHandler verzikHandler;
	private final TobUtilitiesConfig config;

	@Inject
	protected PlayerTwoOrbOverlay(Client client, VerzikHandler verzikHandler, TobUtilitiesConfig config)
	{
		this.client = client;
		this.verzikHandler = verzikHandler;
		this.config = config;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.MANUAL);
		drawAfterLayer(TobPlayerOrb.PLAYER_2.getOrbBackgroundId());
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		Color overlayColor = config.dawnbringerOverlayColor();
		if (!TobPlayerOrb.PLAYER_2.equals(verzikHandler.getTobPlayerOrb()))
		{
			return null;
		}
		return getDimension(graphics, overlayColor, client, verzikHandler);
	}
}

package com.tobutilities.common.player;

import com.tobutilities.TobUtilitiesConfig;
import com.tobutilities.verzik.VerzikHandler;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

public class PlayerFourOrbOverlay extends Overlay implements PlayerOrb
{
	private final Client client;
	private final VerzikHandler verzikHandler;
	private final TobUtilitiesConfig config;

	@Inject
	protected PlayerFourOrbOverlay(Client client, VerzikHandler verzikHandler, TobUtilitiesConfig config)
	{
		this.client = client;
		this.verzikHandler = verzikHandler;
		this.config = config;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.MANUAL);
		drawAfterLayer(TobPlayerOrb.PLAYER_4.getOrbBackgroundId());
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		Color overlayColor = config.dawnbringerOverlayColor();
		if (!TobPlayerOrb.PLAYER_4.equals(verzikHandler.getTobPlayerOrb()))
		{
			return null;
		}
		return getDimension(graphics, overlayColor, client, verzikHandler);
	}
}

package com.tobutilities.common.player;

import com.tobutilities.TobUtilitiesConfig;
import com.tobutilities.verzik.VerzikHandler;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

public class PlayerThreeOrbOverlay extends Overlay implements PlayerOrb
{
	private final Client client;
	private final VerzikHandler verzikHandler;
	private final TobUtilitiesConfig config;

	@Inject
	protected PlayerThreeOrbOverlay(Client client, VerzikHandler verzikHandler, TobUtilitiesConfig config)
	{
		this.client = client;
		this.verzikHandler = verzikHandler;
		this.config = config;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.MANUAL);
		drawAfterLayer(TobPlayerOrb.PLAYER_3.getOrbBackgroundId());
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		Color overlayColor = config.dawnbringerOverlayColor();
		if (!TobPlayerOrb.PLAYER_3.equals(verzikHandler.getTobPlayerOrb()))
		{
			return null;
		}
		return getDimension(graphics, overlayColor, client, verzikHandler);
	}
}

package com.tobutilities.common.player;

import lombok.Getter;

@Getter
public enum TobPlayerOrb
{

	PLAYER_1(1, 330, 1835026, 1835027),
	PLAYER_2(2, 331, 1835030, 1835031),
	PLAYER_3(3, 332, 1835034, 1835035),
	PLAYER_4(4, 333, 1835038, 1835039),
	PLAYER_5(5, 334, 1835042, 1835043),
	UNKNOWN(0, 0, 0, 0);

	private final int orbPosition;

	/**
	 * the Varc ID which contains the name of the player the orb belongs to
	 */
	private final int nameVarc;

	private final int orbId;

	private final int orbBackgroundId;


	TobPlayerOrb(int orbPosition, int nameVarc, int orbId, int orbBackgroundId)
	{
		this.orbPosition = orbPosition;
		this.nameVarc = nameVarc;
		this.orbId = orbId;
		this.orbBackgroundId = orbBackgroundId;
	}

	@Override
	public String toString()
	{
		return "TobPlayerOrb{" +
			"orbPosition=" + orbPosition +
			", nameVarc=" + nameVarc +
			", orbId=" + orbId +
			", orbBackgroundId=" + orbBackgroundId +
			'}';
	}
}

package com.tobutilities.common.player;

import com.tobutilities.verzik.VerzikHandler;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;

public interface PlayerOrb
{

	default Dimension getDimension(Graphics2D graphics, Color overlayColor, Client client, VerzikHandler verzikHandler)
	{
		Widget playerOrbWidget = client.getWidget(verzikHandler.getTobPlayerOrb().getOrbId());
		if (playerOrbWidget != null)
		{
			Rectangle bounds = playerOrbWidget.getBounds();
			graphics.setColor(overlayColor);
			graphics.fillOval(bounds.x, bounds.y, bounds.width, bounds.height);
		}
		return null;
	}
}

package com.tobutilities.common.player;

import com.tobutilities.TobUtilitiesConfig;
import com.tobutilities.verzik.VerzikHandler;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

public class PlayerFiveOrbOverlay extends Overlay implements PlayerOrb
{
	private final Client client;
	private final VerzikHandler verzikHandler;
	private final TobUtilitiesConfig config;

	@Inject
	protected PlayerFiveOrbOverlay(Client client, VerzikHandler verzikHandler, TobUtilitiesConfig config)
	{
		this.client = client;
		this.verzikHandler = verzikHandler;
		this.config = config;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.MANUAL);
		drawAfterLayer(TobPlayerOrb.PLAYER_5.getOrbBackgroundId());
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		Color overlayColor = config.dawnbringerOverlayColor();
		if (!TobPlayerOrb.PLAYER_5.equals(verzikHandler.getTobPlayerOrb()))
		{
			return null;
		}
		return getDimension(graphics, overlayColor, client, verzikHandler);
	}
}

package com.tobutilities.common;

import com.google.inject.Provides;
import com.tobutilities.TobUtilitiesConfig;
import com.tobutilities.TobUtilitiesPlugin;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.ui.overlay.OverlayManager;

public class RoomHandler
{
	@Inject
	protected Client client;
	@Inject
	private OverlayManager overlayManager;
	@Inject
	private ConfigManager configManager;

	protected TobUtilitiesConfig config;

	protected TobUtilitiesPlugin plugin;

	@Provides
	TobUtilitiesConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(TobUtilitiesConfig.class);
	}

	@Inject
	protected RoomHandler(TobUtilitiesPlugin plugin, TobUtilitiesConfig config, Client client)
	{
		this.plugin = plugin;
		this.config = config;
		this.client = client;
	}

}

package com.tobutilities.bloat;

import static com.tobutilities.bloat.BloatConstants.PESTILENT_BLOAT;
import com.tobutilities.common.RoomHandler;
import com.tobutilities.TobUtilitiesPlugin;
import com.tobutilities.TobUtilitiesConfig;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.Renderable;

import net.runelite.api.events.GameTick;

import net.runelite.client.eventbus.Subscribe;

@Slf4j
public class BloatHandler extends RoomHandler
{
	boolean isBloatAlive;

	@Inject
	protected BloatHandler(TobUtilitiesPlugin plugin, TobUtilitiesConfig config, Client client)
	{
		super(plugin, config, client);
	}

	public boolean shouldDraw(Renderable renderable)
	{
		if (renderable instanceof Player && isBloatAlive)
		{
			Player player = (Player) renderable;
			if (player.equals(client.getLocalPlayer()))
			{
				return !config.hideLocalPlayerDuringBloat();
			}
			else
			{
				return !config.hideOtherPlayersDuringBloat();
			}
		}
		return true;
	}

	@Subscribe
	public void onGameTick(GameTick tick)
	{
		for (NPC npc : client.getWorldView(-1).npcs())
		{
			if (PESTILENT_BLOAT.equals(npc.getName()))
			{
				isBloatAlive = !npc.isDead();
			}
		}
	}
}


package com.tobutilities.bloat;

public class BloatConstants

{
	public static final String PESTILENT_BLOAT = "Pestilent Bloat";
}

package com.tobutilities;

import com.google.common.annotations.VisibleForTesting;
import com.google.inject.Provides;
import com.tobutilities.bloat.BloatHandler;
import com.tobutilities.common.metronome.MetronomeService;
import com.tobutilities.common.metronome.MetronomeOverlay;
import com.tobutilities.common.enums.Region;
import com.tobutilities.maiden.MaidenHandler;
import com.tobutilities.maiden.MaidenOverlay;
import com.tobutilities.common.player.PlayerOneOrbOverlay;
import com.tobutilities.common.player.PlayerTwoOrbOverlay;
import com.tobutilities.common.player.PlayerThreeOrbOverlay;
import com.tobutilities.common.player.PlayerFourOrbOverlay;
import com.tobutilities.common.player.PlayerFiveOrbOverlay;
import com.tobutilities.nylocas.NylocasHandler;
import com.tobutilities.nylocas.NylocasOverlay;
import com.tobutilities.verzik.VerzikHandler;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;

import net.runelite.client.callback.Hooks;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.HotkeyListener;

import javax.inject.Inject;
import java.awt.event.KeyEvent;

@PluginDescriptor(
	name = "ToB Utilities",
	description = "Various tools for the theatre of blood",
	tags = {"timers", "overlays", "tick", "theatre", "metronome", "tob", "maiden", "bloat", "nylo", "xarpus", "verzik"}
)
@Slf4j
public class TobUtilitiesPlugin extends Plugin
{
	@Inject
	private OverlayManager overlayManager;
	@Inject
	public ConfigManager configManager;
	@Inject
	private Client client;
	@Inject
	private MetronomeOverlay metronomeOverlay;
	@Inject
	private PlayerOneOrbOverlay playerOneOrbOverlay;
	@Inject
	private PlayerTwoOrbOverlay playerTwoOrbOverlay;
	@Inject
	private PlayerThreeOrbOverlay playerThreeOrbOverlay;
	@Inject
	private PlayerFourOrbOverlay playerFourOrbOverlay;
	@Inject
	private PlayerFiveOrbOverlay playerFiveOrbOverlay;
	@Inject
	private MaidenOverlay maidenOverlay;
	@Inject
	private NylocasOverlay nylocasOverlay;
	@Inject
	private TobUtilitiesConfig config;
	@Inject
	private KeyManager keyManager;
	@Inject
	private Hooks hooks;
	@Inject
	private MaidenHandler maidenHandler;
	@Inject
	private BloatHandler bloatHandler;
	@Inject
	private NylocasHandler nylocasHandler;

	@Inject
	private VerzikHandler verzikHandler;
	@Inject
	private MetronomeService metronomeService;

	public Region region = Region.UNKNOWN;
	private final Hooks.RenderableDrawListener drawListener = this::shouldDraw;

	@Provides
	TobUtilitiesConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(TobUtilitiesConfig.class);
	}

	@Subscribe
	public void onGameTick(GameTick tick)
	{
		if (region.equals(Region.VERZIK))
		{
			verzikHandler.onGameTick(tick);
		}
		else if (region.equals(Region.BLOAT))
		{
			bloatHandler.onGameTick(tick);
		}
		metronomeService.onGameTick(tick);
	}


	private final HotkeyListener hideVerzikHotkeyListener = new HotkeyListener(() -> config.hideVerzikHotkey())
	{
		@Override
		public void keyPressed(KeyEvent e)
		{
			if (Region.VERZIK.equals(region))
			{
				verzikHandler.keyPressed(e);
			}
		}

		@Override
		public void keyReleased(KeyEvent e)
		{
			hotkeyReleased();
		}
	};


	@Subscribe
	public void onNpcSpawned(NpcSpawned event)
	{
		if (Region.MAIDEN.equals(region))
		{
			maidenHandler.onNpcSpawned(event);
		}
		else if (Region.NYLOCAS.equals(region))
		{
			nylocasHandler.onNpcSpawned(event);
		}
	}


	@VisibleForTesting
	boolean shouldDraw(Renderable renderable, boolean drawingUI)
	{
		if (Region.BLOAT.equals(region))
		{
			return bloatHandler.shouldDraw(renderable);
		}

		if (Region.VERZIK.equals(region))
		{
			return verzikHandler.shouldDraw(renderable, drawingUI);
		}
		return true;
	}


	@Subscribe
	void onActorDeath(ActorDeath event)
	{
		if (Region.NYLOCAS.equals(region))
		{
			nylocasHandler.onActorDeath(event);
		}
	}

	@Subscribe
	public void onNpcChanged(NpcChanged event)
	{
		if (Region.NYLOCAS.equals(region))
		{
			nylocasHandler.onNpcChanged(event);
		}
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned event)
	{
		if (Region.MAIDEN.equals(region))
		{
			maidenHandler.onNpcDespawned(event);
		}
		else if (Region.NYLOCAS.equals(region))
		{
			nylocasHandler.onNpcDespawned(event);
		}
	}

	@Override
	protected void startUp() throws Exception
	{
		overlayManager.add(metronomeOverlay);
		overlayManager.add(playerOneOrbOverlay);
		overlayManager.add(playerTwoOrbOverlay);
		overlayManager.add(playerThreeOrbOverlay);
		overlayManager.add(playerFourOrbOverlay);
		overlayManager.add(playerFiveOrbOverlay);
		overlayManager.add(maidenOverlay);
		overlayManager.add(nylocasOverlay);
		keyManager.registerKeyListener(hideVerzikHotkeyListener);
		hooks.registerRenderableDrawListener(drawListener);
	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove(metronomeOverlay);
		overlayManager.remove(playerOneOrbOverlay);
		overlayManager.remove(playerTwoOrbOverlay);
		overlayManager.remove(playerThreeOrbOverlay);
		overlayManager.remove(playerFourOrbOverlay);
		overlayManager.remove(playerFiveOrbOverlay);
		overlayManager.remove(maidenOverlay);
		overlayManager.remove(nylocasOverlay);
		nylocasHandler.shutDown();
		maidenHandler.shutDown();
		keyManager.unregisterKeyListener(hideVerzikHotkeyListener);
		hooks.unregisterRenderableDrawListener(drawListener);
	}
}

package com.tobutilities;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class TobUtilitiesTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(TobUtilitiesPlugin.class);
		RuneLite.main(args);
	}
}
