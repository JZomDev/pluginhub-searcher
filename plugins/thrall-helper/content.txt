package com.portaguy;

import com.google.inject.Provides;
import com.portaguy.trackers.*;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.Notifier;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.util.HotkeyListener;
import net.runelite.client.events.ConfigChanged;

import javax.inject.Inject;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;

@Slf4j
@PluginDescriptor(
  name = "Spell Reminder",
  description = "Shows a box that reminds you to recast a spell",
  tags = {
      "spellbook",
      "thrall",
      "death charge",
      "mark of darkness",
      "ward of arceuus",
      "shadow veil",
      "corruption",
      "charge",
      "vile vigour",
      "vengeance"
  },
  configName = "ThrallHelperPlugin"
)
public class SpellReminderPlugin extends Plugin {
  private final List<SpellTracker> spellTrackers = new ArrayList<>();
  private final List<HotkeyListener> hotkeyListeners = new ArrayList<>();

  @Inject
  protected ThrallTracker thrallTracker;

  @Inject
  protected DeathChargeTracker deathChargeTracker;

  @Inject
  protected MarkOfDarknessTracker markOfDarknessTracker;

  @Inject
  protected WardOfArceuusTracker wardOfArceuusTracker;

  @Inject
  protected ShadowVeilTracker shadowVeilTracker;

  @Inject
  protected CorruptionTracker corruptionTracker;

  @Inject
  protected ChargeTracker chargeTracker;

  @Inject
  protected VengeanceTracker vengeanceTracker;

  @Inject
  protected VileVigourTracker vileVigourTracker;

  @Inject
  protected Client client;

  @Inject
  protected EventBus eventBus;

  @Inject
  protected Notifier notifier;

  @Inject
  protected KeyManager keyManager;

  @Inject
  protected ConfigManager configManager;

  @Inject
  protected ChatMessageManager chatMessageManager;

  @Inject
  protected SpellReminderConfig config;

  @Inject
  protected SpellReminderOverlayFactory overlayFactory;

  @Inject
  protected SpellReminderInfoboxFactory infoboxFactory;

  @Provides
  SpellReminderConfig provideConfig(ConfigManager configManager) {
    return configManager.getConfig(SpellReminderConfig.class);
  }

  @Override
  protected void startUp() {
    spellTrackers.add(thrallTracker);
    spellTrackers.add(deathChargeTracker);
    spellTrackers.add(markOfDarknessTracker);
    spellTrackers.add(wardOfArceuusTracker);
    spellTrackers.add(shadowVeilTracker);
    spellTrackers.add(corruptionTracker);
    spellTrackers.add(chargeTracker);
    spellTrackers.add(vengeanceTracker);
    spellTrackers.add(vileVigourTracker);

    for (SpellTracker tracker : spellTrackers) {
      tracker.initializePatterns();
      eventBus.register(tracker);

      HotkeyListener listener = new HotkeyListener(tracker::getHideReminderHotkey) {
        @Override
        public void hotkeyPressed() {
          overlayFactory.removeOverlay(tracker);
          infoboxFactory.removeInfobox(tracker);
        }
      };
      keyManager.registerKeyListener(listener);

      hotkeyListeners.add(listener);
    }
  }

  @Override
  protected void shutDown() {
    for (SpellTracker tracker : spellTrackers) {
      eventBus.unregister(tracker);
    }
    spellTrackers.clear();

    for (HotkeyListener listener : hotkeyListeners) {
      keyManager.unregisterKeyListener(listener);
    }
    hotkeyListeners.clear();

    overlayFactory.removeAllOverlays();
    infoboxFactory.removeAllInfoboxes();
  }

  @Subscribe
  protected void onGameTick(GameTick ignored) {
    for (SpellTracker tracker : spellTrackers) {
      if (!tracker.isSpellTracked()) {
        continue;
      }

      if (tracker.isExpired()) {
        final int spellbookVarbit = client.getVarbitValue(VarbitID.SPELLBOOK);

        Spellbook spellbook = Spellbook.fromVarbit(spellbookVarbit);
        if (tracker.onlyOnSpellbook() && tracker.getSpellbook() != spellbook) {
          return;
        }

        if (tracker.getReminderStyle() == SpellReminderStyle.INFOBOX) {
          infoboxFactory.createInfobox(tracker);
        } else {
          overlayFactory.createOverlay(tracker);
        }

        if (tracker.getNotification().isEnabled()) {
          notifier.notify(tracker.getNotification(), "Spell Reminder: " + tracker.getCustomMessage());
        }
      }

      if (tracker.isActive()) {
        overlayFactory.removeOverlay(tracker);
        infoboxFactory.removeInfobox(tracker);
      }
    }
  }

  @Subscribe
  protected void onChatMessage(ChatMessage event) {
    final String message = event.getMessage();
    final ChatMessageType type = event.getType();

    // Moons of Peril sends an empty chat message.
    // Empty chat messages should not match on empty regex configs.
    if (message.isEmpty()) {
      return;
    }

    for (SpellTracker tracker : spellTrackers) {
      if (!tracker.isSpellTracked()) {
        continue;
      }

      if (tracker.onGameMessageOnly() && type != ChatMessageType.GAMEMESSAGE) {
        continue;
      }

      Matcher notifyMatcher = tracker.notifyMessage.matcher(message);
      if (notifyMatcher.matches()) {
        if (tracker.getReminderStyle() == SpellReminderStyle.INFOBOX) {
          infoboxFactory.createInfobox(tracker);
        } else {
          overlayFactory.createOverlay(tracker);
        }

        if (tracker.getNotification().isEnabled()) {
          notifier.notify(tracker.getNotification(), "Spell Reminder: " + tracker.getCustomMessage());
        }
      }

      Matcher removeMatcher = tracker.removeMessage.matcher(message);
      if (removeMatcher.matches()) {
        overlayFactory.removeOverlay(tracker);
        infoboxFactory.removeInfobox(tracker);
      }
    }
  }

  @Subscribe
  protected void onGameStateChanged(GameStateChanged gameStateChanged) {
    if (gameStateChanged.getGameState() != GameState.LOGGED_IN) {
      return;
    }

    if (!config.thrallHelperToSpellReminderUpdate()) {
      chatMessageManager.queue(QueuedMessage.builder()
          .type(ChatMessageType.GAMEMESSAGE)
          .runeLiteFormattedMessage(SpellReminderConfig.thrallHelperToSpellReminderUpdateText).build());
      configManager.setConfiguration(SpellReminderConfig.GROUP, "thrallHelperToSpellReminderUpdate", true);
    }
  }

  @Subscribe
  protected void onConfigChanged(ConfigChanged event) {
    if (!event.getGroup().equals(SpellReminderConfig.GROUP)) {
      return;
    }

    for (SpellTracker tracker : spellTrackers) {
      if (!event.getKey().equals(tracker.getReminderStyleConfigKey())) {
        continue;
      }

      boolean overlayWasActive = overlayFactory.isOverlayActive(tracker);
      boolean infoboxWasActive = infoboxFactory.isInfoboxActive(tracker);
      boolean wasActive = overlayWasActive || infoboxWasActive;

      overlayFactory.removeOverlay(tracker);
      infoboxFactory.removeInfobox(tracker);

      // Don't recreate an overlay or infobox if it wasn't active
      if (!wasActive) {
        continue;
      }

      if (tracker.getReminderStyle() == SpellReminderStyle.INFOBOX) {
          infoboxFactory.createInfobox(tracker);
      } else {
          overlayFactory.createOverlay(tracker);
      }
    }
  }
}

package com.portaguy;

import lombok.NonNull;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;

import javax.annotation.Nullable;
import java.awt.*;

public abstract class SpellReminderOverlay extends OverlayPanel {
  protected final SpellReminderConfig config;
  protected final Client client;
  protected final SpellTracker tracker;
  @Setter
  private Long startTime;

  protected SpellReminderOverlay(SpellReminderConfig config, Client client, SpellTracker tracker) {
    this.config = config;
    this.client = client;
    this.tracker = tracker;
    this.startTime = null;
    setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
  }

  @Override
  public Dimension render(Graphics2D graphics) {
    if (isExpired()) {
      return null;
    }

    final int padding = getTextPadding();
    final String displayText = getDisplayText();
    if (displayText == null) {
      return null;
    }

    panelComponent.getChildren().clear();
    panelComponent.getChildren().add(LineComponent.builder()
        .left(displayText)
        .build());

    panelComponent.setPreferredSize(getTextWidth(graphics, displayText, padding));
    if (shouldFlash() && client.getGameCycle() % 40 >= 20) {
      panelComponent.setBackgroundColor(getFlashColor());
    } else {
      panelComponent.setBackgroundColor(getColor());
    }

    if (getReminderStyle() == SpellReminderStyle.CUSTOM_TEXT) {
      return super.render(graphics);
    } else {
      return panelComponent.render(graphics);
    }
  }

  @Nullable
  private String getDisplayText() {
    switch (getReminderStyle()) {
      case LONG_TEXT:
        return getLongText();
      case SHORT_TEXT:
        return getShortText();
      case CUSTOM_TEXT:
        return getCustomText();
      default:
        return null;
    }
  }

  private int getTextPadding() {
    switch (getReminderStyle()) {
      case LONG_TEXT:
      case CUSTOM_TEXT:
        return -20;
      case SHORT_TEXT:
        return 10;
      default:
        return 0;
    }
  }

  @NonNull
  private Dimension getTextWidth(Graphics2D graphics, String string, int offset) {
    FontMetrics fontMetrics = graphics.getFontMetrics();
    int stringWidth = fontMetrics.stringWidth(string);
    return new Dimension(stringWidth + offset, 0);
  }

  protected boolean isExpired() {
    if (startTime == null) {
      return true;
    }

    final long timeoutMillis = getTimeoutSeconds() * 1000L;
    final long elapsedMillis = System.currentTimeMillis() - startTime;

    return elapsedMillis > timeoutMillis;
  }

  protected abstract String getLongText();

  protected abstract String getShortText();

  protected abstract String getCustomText();

  protected abstract SpellReminderStyle getReminderStyle();

  protected abstract boolean shouldFlash();

  protected abstract Color getColor();

  protected abstract Color getFlashColor();

  protected abstract int getTimeoutSeconds();
}
package com.portaguy.trackers;

import com.portaguy.*;
import com.portaguy.infoboxes.DeathChargeInfobox;
import com.portaguy.overlays.DeathChargeOverlay;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.config.Keybind;
import net.runelite.client.config.Notification;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;

public class DeathChargeTracker extends SpellTracker {
  @Inject
  protected DeathChargeOverlay overlay;

  @Inject
  protected DeathChargeInfobox infobox;

  @Inject
  public DeathChargeTracker() {
    super(Spellbook.ARCEUUS, false);
  }

  @Subscribe
  @Override
  protected void onVarbitChanged(VarbitChanged event) {
    if (event.getVarbitId() == VarbitID.ARCEUUS_DEATH_CHARGE_COOLDOWN) {
      if (event.getValue() == 1 && !active) {
        start();
      } else if (event.getValue() == 0 && active) {
        stop();
      }
    }
  }

  @Override
  protected boolean onlyOnSpellbook() {
    return config.deathChargeOnlyArceuus();
  }

  @Override
  protected boolean isSpellTracked() {
    return config.deathChargeEnabled();
  }

  @Override
  protected Notification getNotification() {
    return config.deathChargeShouldNotify();
  }

  @Override
  protected String getNotifyPattern() {
    return config.deathChargeNotifyRegex();
  }

  @Override
  protected String getRemovePattern() {
    return config.deathChargeRemoveRegex();
  }

  @Override
  protected boolean onGameMessageOnly() {
    return config.deathChargeMatchGameMessagesOnly();
  }

  @Override
  protected String getCustomMessage() {
    return config.deathChargeCustomText();
  }

  @Override
  protected SpellReminderOverlay getOverlay() {
    return overlay;
  }

  @Override
  protected SpellReminderInfobox getInfobox() {
    return infobox;
  }

  @Override
  protected Keybind getHideReminderHotkey() {
    return config.deathChargeHideReminderHotkey();
  }

  @Override
  protected SpellReminderStyle getReminderStyle() {
    return config.deathChargeReminderStyle();
  }

  @Override
  public String getReminderStyleConfigKey() {
    return "deathChargeReminderStyle";
  }
}

package com.portaguy.trackers;

import com.portaguy.*;
import com.portaguy.infoboxes.VileVigourInfobox;
import com.portaguy.overlays.VileVigourOverlay;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.config.Keybind;
import net.runelite.client.config.Notification;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import java.time.Instant;

/***
 * Vile Vigour is a special case for spell tracking as you might not want to cast
 * it immediately after the cooldown ends, since it depends on your run energy being low.
 * <br/>
 * The cases that we want to handle are:
 * <ul>
 *   <li>If it comes off cooldown and you're below the run energy threshold, you get a notification</li>
 *   <li>If it comes off cooldown and you're not below the run energy threshold, you do not get a notification</li>
 *   <li>If you've casted it X seconds ago and you hit the run energy threshold, you get a notification</li>
 * </ul>
 */
public class VileVigourTracker extends SpellTracker {
  private Instant cooldownEndTime = null;

  @Inject
  protected VileVigourOverlay overlay;

  @Inject
  protected VileVigourInfobox infobox;

  @Inject
  public VileVigourTracker() {
    super(Spellbook.ARCEUUS, false);
  }

  @Override
  @Subscribe
  protected void onVarbitChanged(VarbitChanged event) {
    if (event.getVarbitId() != VarbitID.ARCEUUS_VILE_VIGOUR_COOLDOWN) {
      return;
    }

    if (event.getValue() == 1 && !active) {
      start();
    } else if (event.getValue() == 0 && active) {
      cooldownEndTime = Instant.now();
      checkAndNotify();
    }
  }

  @Override
  @Subscribe(priority = 1)
  protected void onGameTick(GameTick ignored) {
    if (active && client.getTickCount() == finalTick) {
      stop();
    } else if (isExpired() || client.getTickCount() > finalTick) {
      reset();
    }

    if (cooldownEndTime != null) {
      Instant thresholdTime = cooldownEndTime.plusSeconds(config.vileVigourThresholdTimeout());
      if (Instant.now().isAfter(thresholdTime)) {
        cooldownEndTime = null;
      } else if (isBelowThreshold()) {
        stop();
        cooldownEndTime = null;
      }
    }
  }

  private void checkAndNotify() {
    if (isBelowThreshold()) {
      stop();
    } else {
      reset();
    }
  }

  private boolean isBelowThreshold() {
    final int runEnergy = client.getEnergy() / 100;
    return runEnergy < config.vileVigourRunThreshold();
  }

  @Override
  protected boolean onlyOnSpellbook() {
    return config.vileVigourOnlyArceuus();
  }

  @Override
  protected boolean isSpellTracked() {
    return config.vileVigourEnabled();
  }

  @Override
  protected Notification getNotification() {
    return config.vileVigourShouldNotify();
  }

  @Override
  protected String getNotifyPattern() {
    return config.vileVigourNotifyRegex();
  }

  @Override
  protected String getRemovePattern() {
    return config.vileVigourRemoveRegex();
  }

  @Override
  protected boolean onGameMessageOnly() {
    return config.vileVigourMatchGameMessagesOnly();
  }

  @Override
  protected String getCustomMessage() {
    return config.vileVigourCustomText();
  }

  @Override
  protected SpellReminderOverlay getOverlay() {
    return overlay;
  }

  @Override
  protected SpellReminderInfobox getInfobox() {
    return infobox;
  }

  @Override
  protected Keybind getHideReminderHotkey() {
    return config.vileVigourHideReminderHotkey();
  }

  @Override
  protected SpellReminderStyle getReminderStyle() {
    return config.vileVigourReminderStyle();
  }

  @Override
  public String getReminderStyleConfigKey() {
    return "vileVigourReminderStyle";
  }
}

package com.portaguy.trackers;

import com.portaguy.*;
import com.portaguy.infoboxes.VengeanceInfobox;
import com.portaguy.overlays.VengeanceOverlay;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.config.Keybind;
import net.runelite.client.config.Notification;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;

public class VengeanceTracker extends SpellTracker {
  @Inject
  protected VengeanceOverlay overlay;

  @Inject
  protected VengeanceInfobox infobox;

  @Inject
  public VengeanceTracker() {
    super(Spellbook.LUNAR, false);
  }

  @Subscribe
  @Override
  protected void onVarbitChanged(VarbitChanged event) {
    // 0 when there is no active vengeance to rebound
    int rebound = client.getVarbitValue(VarbitID.VENGEANCE_REBOUND);
    // 1 when vengeance is on cooldown
    int cooldown = client.getVarbitValue(VarbitID.VENGEANCE_TIMELIMIT);
    if (event.getVarbitId() == VarbitID.VENGEANCE_TIMELIMIT) {
      if (event.getValue() == 1 && !active) {
        start();
      } else if (event.getValue() == 0 && rebound == 0 && active) {
        stop();
      }
    } else if (event.getVarbitId() == VarbitID.VENGEANCE_REBOUND) {
      if (event.getValue() == 0 && cooldown == 0 && active) {
        stop();
      }
    }
  }

  @Override
  protected boolean onlyOnSpellbook() {
    return config.vengeanceOnlyLunar();
  }

  @Override
  protected boolean isSpellTracked() {
    return config.vengeanceEnabled();
  }

  @Override
  protected Notification getNotification() {
    return config.vengeanceShouldNotify();
  }

  @Override
  protected String getNotifyPattern() {
    return config.vengeanceNotifyRegex();
  }

  @Override
  protected String getRemovePattern() {
    return config.vengeanceRemoveRegex();
  }

  @Override
  protected boolean onGameMessageOnly() {
    return config.vengeanceMatchGameMessagesOnly();
  }

  @Override
  protected String getCustomMessage() {
    return config.vengeanceCustomText();
  }

  @Override
  protected SpellReminderOverlay getOverlay() {
    return overlay;
  }

  @Override
  protected SpellReminderInfobox getInfobox() {
    return infobox;
  }

  @Override
  protected Keybind getHideReminderHotkey() {
    return config.vengeanceHideReminderHotkey();
  }

  @Override
  protected SpellReminderStyle getReminderStyle() {
    return config.vengeanceReminderStyle();
  }

  @Override
  public String getReminderStyleConfigKey() {
    return "vengeanceReminderStyle";
  }
}
package com.portaguy.trackers;

import com.portaguy.*;
import com.portaguy.infoboxes.WardOfArceuusInfobox;
import com.portaguy.overlays.WardOfArceuusOverlay;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.config.Keybind;
import net.runelite.client.config.Notification;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.Text;

import javax.inject.Inject;

public class WardOfArceuusTracker extends SpellTracker {
  private static final String WARD_EXPIRED_MESSAGE = "your ward of arceuus has expired.";

  @Inject
  protected WardOfArceuusOverlay overlay;

  @Inject
  protected WardOfArceuusInfobox infobox;

  @Inject
  public WardOfArceuusTracker() {
    super(Spellbook.ARCEUUS, true);
  }

  @Subscribe
  @Override
  protected void onVarbitChanged(VarbitChanged event) {
    if (event.getVarbitId() == VarbitID.ARCEUUS_WARD_COOLDOWN) {
      if (event.getValue() == 1 && !active) {
        start();
      }
    }
  }

  @Subscribe
  @Override
  protected void onChatMessage(ChatMessage event) {
    String message = Text.standardize(event.getMessage());
    if (event.getType() != ChatMessageType.GAMEMESSAGE) {
      return;
    }

    if (message.equals(WARD_EXPIRED_MESSAGE)) {
      stop();
    }
  }

  @Override
  protected boolean onlyOnSpellbook() {
    return config.wardOfArceuusOnlyArceuus();
  }

  @Override
  protected boolean isSpellTracked() {
    return config.wardOfArceuusEnabled();
  }

  @Override
  protected Notification getNotification() {
    return config.wardOfArceuusShouldNotify();
  }

  @Override
  protected String getNotifyPattern() {
    return config.wardOfArceuusNotifyRegex();
  }

  @Override
  protected String getRemovePattern() {
    return config.wardOfArceuusRemoveRegex();
  }

  @Override
  protected boolean onGameMessageOnly() {
    return config.wardOfArceuusMatchGameMessagesOnly();
  }

  @Override
  protected String getCustomMessage() {
    return config.wardOfArceuusCustomText();
  }

  @Override
  protected SpellReminderOverlay getOverlay() {
    return overlay;
  }

  @Override
  protected SpellReminderInfobox getInfobox() {
    return infobox;
  }

  @Override
  protected Keybind getHideReminderHotkey() {
    return config.wardOfArceuusHideReminderHotkey();
  }

  @Override
  protected SpellReminderStyle getReminderStyle() {
    return config.wardOfArceuusReminderStyle();
  }

  @Override
  public String getReminderStyleConfigKey() {
    return "wardOfArceuusReminderStyle";
  }
}
package com.portaguy.trackers;

import com.portaguy.*;
import com.portaguy.infoboxes.CorruptionInfobox;
import com.portaguy.overlays.CorruptionOverlay;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.config.Keybind;
import net.runelite.client.config.Notification;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;

public class CorruptionTracker extends SpellTracker {
  @Inject
  protected CorruptionOverlay overlay;

  @Inject
  protected CorruptionInfobox infobox;

  @Inject
  public CorruptionTracker() {
    super(Spellbook.ARCEUUS, false);
  }

  @Subscribe
  @Override
  protected void onVarbitChanged(VarbitChanged event) {
    if (event.getVarbitId() == VarbitID.ARCEUUS_CORRUPTION_COOLDOWN) {
      if (event.getValue() == 1 && !active) {
        start();
      } else if (event.getValue() == 0 && active) {
        stop();
      }
    }
  }

  @Override
  protected boolean onlyOnSpellbook() {
    return config.corruptionOnlyArceuus();
  }

  @Override
  protected boolean isSpellTracked() {
    return config.corruptionEnabled();
  }

  @Override
  protected Notification getNotification() {
    return config.corruptionShouldNotify();
  }

  @Override
  protected String getNotifyPattern() {
    return config.corruptionNotifyRegex();
  }

  @Override
  protected String getRemovePattern() {
    return config.corruptionRemoveRegex();
  }

  @Override
  protected boolean onGameMessageOnly() {
    return config.corruptionMatchGameMessagesOnly();
  }

  @Override
  protected String getCustomMessage() {
    return config.corruptionCustomText();
  }

  @Override
  protected SpellReminderOverlay getOverlay() {
    return overlay;
  }

  @Override
  protected SpellReminderInfobox getInfobox() {
    return infobox;
  }

  @Override
  protected Keybind getHideReminderHotkey() {
    return config.corruptionHideReminderHotkey();
  }

  @Override
  protected SpellReminderStyle getReminderStyle() {
    return config.corruptionReminderStyle();
  }

  @Override
  public String getReminderStyleConfigKey() {
    return "corruptionReminderStyle";
  }
}
package com.portaguy.trackers;

import com.portaguy.*;
import com.portaguy.infoboxes.ChargeInfobox;
import com.portaguy.overlays.ChargeOverlay;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.client.config.Keybind;
import net.runelite.client.config.Notification;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;

public class ChargeTracker extends SpellTracker {
  @Inject
  protected ChargeOverlay overlay;

  @Inject
  protected ChargeInfobox infobox;

  @Inject
  public ChargeTracker() {
    super(Spellbook.STANDARD, false);
  }

  @Subscribe
  @Override
  protected void onVarbitChanged(VarbitChanged event) {
    if (event.getVarpId() == VarPlayerID.MAGEARENA_CHARGE) {
      if (event.getValue() > 0 && !active) {
        start();
      } else if (event.getValue() == 0 && active) {
        stop();
      }
    }
  }

  @Override
  protected boolean onlyOnSpellbook() {
    return config.chargeOnlyStandard();
  }

  @Override
  protected boolean isSpellTracked() {
    return config.chargeEnabled();
  }

  @Override
  protected Notification getNotification() {
    return config.chargeShouldNotify();
  }

  @Override
  protected String getNotifyPattern() {
    return config.chargeNotifyRegex();
  }

  @Override
  protected String getRemovePattern() {
    return config.chargeRemoveRegex();
  }

  @Override
  protected boolean onGameMessageOnly() {
    return config.chargeMatchGameMessagesOnly();
  }

  @Override
  protected String getCustomMessage() {
    return config.chargeCustomText();
  }

  @Override
  protected SpellReminderOverlay getOverlay() {
    return overlay;
  }

  @Override
  protected SpellReminderInfobox getInfobox() {
    return infobox;
  }

  @Override
  protected Keybind getHideReminderHotkey() {
    return config.chargeHideReminderHotkey();
  }

  @Override
  protected SpellReminderStyle getReminderStyle() {
    return config.chargeReminderStyle();
  }

  @Override
  public String getReminderStyleConfigKey() {
    return "chargeReminderStyle";
  }
}
package com.portaguy.trackers;

import com.portaguy.*;
import com.portaguy.infoboxes.MarkOfDarknessInfobox;
import com.portaguy.overlays.MarkOfDarknessOverlay;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.Skill;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.config.Keybind;
import net.runelite.client.config.Notification;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.Text;

import javax.inject.Inject;

public class MarkOfDarknessTracker extends SpellTracker {
  private static final String MARK_PLACED_MESSAGE = "you have placed a mark of darkness upon yourself.";
  private static final String MARK_FADED_MESSAGE = "your mark of darkness has faded away.";

  @Inject
  protected MarkOfDarknessOverlay overlay;

  @Inject
  protected MarkOfDarknessInfobox infobox;

  @Inject
  public MarkOfDarknessTracker() {
    super(Spellbook.ARCEUUS, true);
  }

  @Subscribe
  @Override
  protected void onChatMessage(ChatMessage event) {
    String message = Text.standardize(event.getMessage());
    if (message.equals(MARK_PLACED_MESSAGE)) {
      int ticks = client.getRealSkillLevel(Skill.MAGIC) * 3;
      if (isPurgingStaffEquipped()) {
        ticks *= 5;
      }
      start(ticks);
    } else if (message.equals(MARK_FADED_MESSAGE)) {
      stop();
    }
  }

  private boolean isPurgingStaffEquipped() {
    final ItemContainer container = client.getItemContainer(InventoryID.WORN);
    if (container == null) {
      return false;
    }

    final Item weapon = container.getItem(EquipmentInventorySlot.WEAPON.getSlotIdx());
    if (weapon == null) {
      return false;
    }

    return weapon.getId() == ItemID.PURGING_STAFF;
  }

  @Override
  protected boolean onlyOnSpellbook() {
    return config.markOfDarknessOnlyArceuus();
  }

  @Override
  protected boolean isSpellTracked() {
    return config.markOfDarknessEnabled();
  }

  @Override
  protected Notification getNotification() {
    return config.markOfDarknessShouldNotify();
  }

  @Override
  protected String getNotifyPattern() {
    return config.markOfDarknessNotifyRegex();
  }

  @Override
  protected String getRemovePattern() {
    return config.markOfDarknessRemoveRegex();
  }

  @Override
  protected boolean onGameMessageOnly() {
    return config.markOfDarknessMatchGameMessagesOnly();
  }

  @Override
  protected String getCustomMessage() {
    return config.markOfDarknessCustomText();
  }

  @Override
  protected SpellReminderOverlay getOverlay() {
    return overlay;
  }

  @Override
  protected SpellReminderInfobox getInfobox() {
    return infobox;
  }

  @Override
  protected Keybind getHideReminderHotkey() {
    return config.markOfDarknessHideReminderHotkey();
  }

  @Override
  protected SpellReminderStyle getReminderStyle() {
    return config.markOfDarknessReminderStyle();
  }

  @Override
  public String getReminderStyleConfigKey() {
    return "markOfDarknessReminderStyle";
  }
}
package com.portaguy.trackers;

import com.portaguy.*;
import com.portaguy.infoboxes.ThrallInfobox;
import com.portaguy.overlays.ThrallOverlay;
import net.runelite.api.Skill;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.config.Keybind;
import net.runelite.client.config.Notification;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;

public class ThrallTracker extends SpellTracker {
  @Inject
  protected ThrallOverlay overlay;

  @Inject
  protected ThrallInfobox infobox;

  @Inject
  public ThrallTracker() {
    super(Spellbook.ARCEUUS, false);
  }

  @Subscribe
  @Override
  protected void onVarbitChanged(VarbitChanged event) {
    // We use ARCEUUS_RESURRECTION_COOLDOWN instead of ARCEUUS_RESURRECTION_ACTIVE
    // so that the reminder is cleared immediately upon casting a new thrall.
    if (event.getVarbitId() != VarbitID.ARCEUUS_RESURRECTION_COOLDOWN) {
      return;
    }

    if (event.getValue() == 1) {
      // Thralls last as long as your magic level in game ticks.
      // This timer can be doubled with completion of the Master tier of Combat Achievements.
      int ticks = client.getBoostedSkillLevel(Skill.MAGIC);
      if (client.getVarbitValue(VarbitID.CA_TIER_STATUS_MASTER) == 2) {
        ticks += ticks;
      }

      // Thralls take 4 ticks from summon to become active
      start(ticks + 4);
    }
  }

  @Override
  protected boolean onlyOnSpellbook() {
    return config.onlyArceuus();
  }

  @Override
  protected boolean isSpellTracked() {
    return config.thrallEnabled();
  }

  @Override
  protected Notification getNotification() {
    return config.shouldNotify();
  }

  @Override
  protected String getNotifyPattern() {
    return config.notifyRegex();
  }

  @Override
  protected String getRemovePattern() {
    return config.removeRegex();
  }

  @Override
  protected boolean onGameMessageOnly() {
    return config.matchGameMessagesOnly();
  }

  @Override
  protected String getCustomMessage() {
    return config.customText();
  }

  @Override
  protected SpellReminderOverlay getOverlay() {
    return overlay;
  }

  @Override
  protected SpellReminderInfobox getInfobox() {
    return infobox;
  }

  @Override
  protected Keybind getHideReminderHotkey() {
    return config.hideReminderHotkey();
  }

  @Override
  protected SpellReminderStyle getReminderStyle() {
    return config.reminderStyle();
  }

  @Override
  public String getReminderStyleConfigKey() {
    return "reminderStyle";
  }
}
package com.portaguy.trackers;

import com.portaguy.*;
import com.portaguy.infoboxes.ShadowVeilInfobox;
import com.portaguy.overlays.ShadowVeilOverlay;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.config.Keybind;
import net.runelite.client.config.Notification;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;

public class ShadowVeilTracker extends SpellTracker {
  @Inject
  protected ShadowVeilOverlay overlay;

  @Inject
  protected ShadowVeilInfobox infobox;

  @Inject
  public ShadowVeilTracker() {
    super(Spellbook.ARCEUUS, false);
  }

  @Subscribe
  @Override
  protected void onVarbitChanged(VarbitChanged event) {
    if (event.getVarbitId() == VarbitID.ARCEUUS_SHADOW_VEIL_ACTIVE) {
      if (event.getValue() == 1 && !active) {
        start();
      } else if (event.getValue() == 0 && active) {
        stop();
      }
    }
  }

  @Override
  protected boolean onlyOnSpellbook() {
    return config.shadowVeilOnlyArceuus();
  }

  @Override
  protected boolean isSpellTracked() {
    return config.shadowVeilEnabled();
  }

  @Override
  protected Notification getNotification() {
    return config.shadowVeilShouldNotify();
  }

  @Override
  protected String getNotifyPattern() {
    return config.shadowVeilNotifyRegex();
  }

  @Override
  protected String getRemovePattern() {
    return config.shadowVeilRemoveRegex();
  }

  @Override
  protected boolean onGameMessageOnly() {
    return config.shadowVeilMatchGameMessagesOnly();
  }

  @Override
  protected String getCustomMessage() {
    return config.shadowVeilCustomText();
  }

  @Override
  protected SpellReminderOverlay getOverlay() {
    return overlay;
  }

  @Override
  protected SpellReminderInfobox getInfobox() {
    return infobox;
  }

  @Override
  protected Keybind getHideReminderHotkey() {
    return config.shadowVeilHideReminderHotkey();
  }

  @Override
  protected SpellReminderStyle getReminderStyle() {
    return config.shadowVeilReminderStyle();
  }

  @Override
  public String getReminderStyleConfigKey() {
    return "shadowVeilReminderStyle";
  }
}
package com.portaguy;

import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.overlay.infobox.InfoBox;

import java.awt.*;

@Slf4j
public abstract class SpellReminderInfobox extends InfoBox {
  protected final SpellReminderConfig config;
  protected final SpellTracker tracker;
  @Setter
  private Long startTime;

  public SpellReminderInfobox(SpellReminderPlugin plugin, SpellReminderConfig config, SpellTracker tracker) {
    super(null, plugin);
    this.config = config;
    this.tracker = tracker;
    this.startTime = null;
  }

  @Override
  public String getText() {
    return null;
  }

  @Override
  public Color getTextColor() {
    return null;
  }

  @Override
  public String getTooltip() {
    return tracker.getCustomMessage();
  }

  @Override
  public boolean render() {
    return !isExpired();
  }

  protected boolean isExpired() {
    if (startTime == null) {
      return true;
    }

    final long timeoutMillis = getTimeoutSeconds() * 1000L;
    final long elapsedMillis = System.currentTimeMillis() - startTime;

    return elapsedMillis > timeoutMillis;
  }

  protected abstract int getSpriteId();

  protected abstract int getTimeoutSeconds();
}
package com.portaguy.overlays;

import com.portaguy.SpellReminderConfig;
import com.portaguy.SpellReminderOverlay;
import com.portaguy.SpellReminderStyle;
import com.portaguy.trackers.ThrallTracker;
import net.runelite.api.Client;

import javax.inject.Inject;
import java.awt.*;

public class ThrallOverlay extends SpellReminderOverlay {
  @Inject
  public ThrallOverlay(SpellReminderConfig config, Client client, ThrallTracker tracker) {
    super(config, client, tracker);
  }

  @Override
  protected String getLongText() {
    return "You need to summon a thrall!";
  }

  @Override
  protected String getShortText() {
    return "Thrall";
  }

  @Override
  protected String getCustomText() {
    return config.customText();
  }

  @Override
  protected SpellReminderStyle getReminderStyle() {
    return config.reminderStyle();
  }

  @Override
  protected boolean shouldFlash() {
    return config.shouldFlash();
  }

  @Override
  protected Color getColor() {
    return config.color();
  }

  @Override
  protected Color getFlashColor() {
    return config.flashColor();
  }

  @Override
  protected int getTimeoutSeconds() {
    return config.thrallTimeoutSeconds();
  }
}
package com.portaguy.overlays;

import com.portaguy.SpellReminderConfig;
import com.portaguy.SpellReminderOverlay;
import com.portaguy.SpellReminderStyle;
import com.portaguy.trackers.VileVigourTracker;
import net.runelite.api.Client;

import javax.inject.Inject;
import java.awt.*;

public class VileVigourOverlay extends SpellReminderOverlay {
  @Inject
  public VileVigourOverlay(SpellReminderConfig config, Client client, VileVigourTracker tracker) {
    super(config, client, tracker);
  }

  @Override
  protected String getLongText() {
    return "You need to cast Vile Vigour!";
  }

  @Override
  protected String getShortText() {
    return "Vile";
  }

  @Override
  protected String getCustomText() {
    return config.vileVigourCustomText();
  }

  @Override
  protected SpellReminderStyle getReminderStyle() {
    return config.vileVigourReminderStyle();
  }

  @Override
  protected boolean shouldFlash() {
    return config.vileVigourShouldFlash();
  }

  @Override
  protected Color getColor() {
    return config.vileVigourColor();
  }

  @Override
  protected Color getFlashColor() {
    return config.vileVigourFlashColor();
  }

  @Override
  protected int getTimeoutSeconds() {
    return config.vileVigourTimeoutSeconds();
  }
}

package com.portaguy.overlays;

import com.portaguy.SpellReminderConfig;
import com.portaguy.SpellReminderOverlay;
import com.portaguy.SpellReminderStyle;
import com.portaguy.trackers.CorruptionTracker;
import net.runelite.api.Client;

import javax.inject.Inject;
import java.awt.*;

public class CorruptionOverlay extends SpellReminderOverlay {
  @Inject
  public CorruptionOverlay(SpellReminderConfig config, Client client, CorruptionTracker tracker) {
    super(config, client, tracker);
  }

  @Override
  protected String getLongText() {
    return "You need to cast Corruption!";
  }

  @Override
  protected String getShortText() {
    return "Corruption";
  }

  @Override
  protected String getCustomText() {
    return config.corruptionCustomText();
  }

  @Override
  protected SpellReminderStyle getReminderStyle() {
    return config.corruptionReminderStyle();
  }

  @Override
  protected boolean shouldFlash() {
    return config.corruptionShouldFlash();
  }

  @Override
  protected Color getColor() {
    return config.corruptionColor();
  }

  @Override
  protected Color getFlashColor() {
    return config.corruptionFlashColor();
  }

  @Override
  protected int getTimeoutSeconds() {
    return config.corruptionTimeoutSeconds();
  }
}
package com.portaguy.overlays;

import com.portaguy.SpellReminderConfig;
import com.portaguy.SpellReminderOverlay;
import com.portaguy.SpellReminderStyle;
import com.portaguy.trackers.ChargeTracker;
import net.runelite.api.Client;

import javax.inject.Inject;
import java.awt.*;

public class ChargeOverlay extends SpellReminderOverlay {
  @Inject
  public ChargeOverlay(SpellReminderConfig config, Client client, ChargeTracker tracker) {
    super(config, client, tracker);
  }

  @Override
  protected String getLongText() {
    return "You need to cast Charge!";
  }

  @Override
  protected String getShortText() {
    return "Charge";
  }

  @Override
  protected String getCustomText() {
    return config.chargeCustomText();
  }

  @Override
  protected SpellReminderStyle getReminderStyle() {
    return config.chargeReminderStyle();
  }

  @Override
  protected boolean shouldFlash() {
    return config.chargeShouldFlash();
  }

  @Override
  protected Color getColor() {
    return config.chargeColor();
  }

  @Override
  protected Color getFlashColor() {
    return config.chargeFlashColor();
  }

  @Override
  protected int getTimeoutSeconds() {
    return config.chargeTimeoutSeconds();
  }
}
package com.portaguy.overlays;

import com.portaguy.SpellReminderConfig;
import com.portaguy.SpellReminderOverlay;
import com.portaguy.SpellReminderStyle;
import com.portaguy.trackers.VengeanceTracker;
import net.runelite.api.Client;

import javax.inject.Inject;
import java.awt.*;

public class VengeanceOverlay extends SpellReminderOverlay {
  @Inject
  public VengeanceOverlay(SpellReminderConfig config, Client client, VengeanceTracker tracker) {
    super(config, client, tracker);
  }

  @Override
  protected String getLongText() {
    return "You need to cast Vengeance!";
  }

  @Override
  protected String getShortText() {
    return "Veng";
  }

  @Override
  protected String getCustomText() {
    return config.vengeanceCustomText();
  }

  @Override
  protected SpellReminderStyle getReminderStyle() {
    return config.vengeanceReminderStyle();
  }

  @Override
  protected boolean shouldFlash() {
    return config.vengeanceShouldFlash();
  }

  @Override
  protected Color getColor() {
    return config.vengeanceColor();
  }

  @Override
  protected Color getFlashColor() {
    return config.vengeanceFlashColor();
  }

  @Override
  protected int getTimeoutSeconds() {
    return config.vengeanceTimeoutSeconds();
  }
}
package com.portaguy.overlays;

import com.portaguy.SpellReminderConfig;
import com.portaguy.SpellReminderOverlay;
import com.portaguy.SpellReminderStyle;
import com.portaguy.trackers.MarkOfDarknessTracker;
import net.runelite.api.Client;

import javax.inject.Inject;
import java.awt.*;

public class MarkOfDarknessOverlay extends SpellReminderOverlay {
  @Inject
  public MarkOfDarknessOverlay(SpellReminderConfig config, Client client, MarkOfDarknessTracker tracker) {
    super(config, client, tracker);
  }

  @Override
  protected String getLongText() {
    return "You need to cast Mark of Darkness!";
  }

  @Override
  protected String getShortText() {
    return "Mark";
  }

  @Override
  protected String getCustomText() {
    return config.markOfDarknessCustomText();
  }

  @Override
  protected SpellReminderStyle getReminderStyle() {
    return config.markOfDarknessReminderStyle();
  }

  @Override
  protected boolean shouldFlash() {
    return config.markOfDarknessShouldFlash();
  }

  @Override
  protected Color getColor() {
    return config.markOfDarknessColor();
  }

  @Override
  protected Color getFlashColor() {
    return config.markOfDarknessFlashColor();
  }

  @Override
  protected int getTimeoutSeconds() {
    return config.markOfDarknessTimeoutSeconds();
  }
}
package com.portaguy.overlays;

import com.portaguy.SpellReminderConfig;
import com.portaguy.SpellReminderOverlay;
import com.portaguy.SpellReminderStyle;
import com.portaguy.trackers.WardOfArceuusTracker;
import net.runelite.api.Client;

import javax.inject.Inject;
import java.awt.*;

public class WardOfArceuusOverlay extends SpellReminderOverlay {
  @Inject
  public WardOfArceuusOverlay(SpellReminderConfig config, Client client, WardOfArceuusTracker tracker) {
    super(config, client, tracker);
  }

  @Override
  protected String getLongText() {
    return "You need to cast Ward of Arceuus!";
  }

  @Override
  protected String getShortText() {
    return "Ward";
  }

  @Override
  protected String getCustomText() {
    return config.wardOfArceuusCustomText();
  }

  @Override
  protected SpellReminderStyle getReminderStyle() {
    return config.wardOfArceuusReminderStyle();
  }

  @Override
  protected boolean shouldFlash() {
    return config.wardOfArceuusShouldFlash();
  }

  @Override
  protected Color getColor() {
    return config.wardOfArceuusColor();
  }

  @Override
  protected Color getFlashColor() {
    return config.wardOfArceuusFlashColor();
  }

  @Override
  protected int getTimeoutSeconds() {
    return config.wardOfArceuusTimeoutSeconds();
  }
}
package com.portaguy.overlays;

import com.portaguy.SpellReminderConfig;
import com.portaguy.SpellReminderOverlay;
import com.portaguy.SpellReminderStyle;
import com.portaguy.trackers.DeathChargeTracker;
import net.runelite.api.Client;

import javax.inject.Inject;
import java.awt.*;

public class DeathChargeOverlay extends SpellReminderOverlay {
  @Inject
  public DeathChargeOverlay(SpellReminderConfig config, Client client, DeathChargeTracker tracker) {
    super(config, client, tracker);
  }

  @Override
  protected String getLongText() {
    return "You need to cast Death Charge!";
  }

  @Override
  protected String getShortText() {
    return "Death Charge";
  }

  @Override
  protected String getCustomText() {
    return config.deathChargeCustomText();
  }

  @Override
  protected SpellReminderStyle getReminderStyle() {
    return config.deathChargeReminderStyle();
  }

  @Override
  protected boolean shouldFlash() {
    return config.deathChargeShouldFlash();
  }

  @Override
  protected Color getColor() {
    return config.deathChargeColor();
  }

  @Override
  protected Color getFlashColor() {
    return config.deathChargeFlashColor();
  }

  @Override
  protected int getTimeoutSeconds() {
    return config.deathChargeTimeoutSeconds();
  }
}

package com.portaguy.overlays;

import com.portaguy.SpellReminderConfig;
import com.portaguy.SpellReminderOverlay;
import com.portaguy.SpellReminderStyle;
import com.portaguy.trackers.ShadowVeilTracker;
import net.runelite.api.Client;

import javax.inject.Inject;
import java.awt.*;

public class ShadowVeilOverlay extends SpellReminderOverlay {
  @Inject
  public ShadowVeilOverlay(SpellReminderConfig config, Client client, ShadowVeilTracker tracker) {
    super(config, client, tracker);
  }

  @Override
  protected String getLongText() {
    return "You need to cast Shadow Veil!";
  }

  @Override
  protected String getShortText() {
    return "Veil";
  }

  @Override
  protected String getCustomText() {
    return config.shadowVeilCustomText();
  }

  @Override
  protected SpellReminderStyle getReminderStyle() {
    return config.shadowVeilReminderStyle();
  }

  @Override
  protected boolean shouldFlash() {
    return config.shadowVeilShouldFlash();
  }

  @Override
  protected Color getColor() {
    return config.shadowVeilColor();
  }

  @Override
  protected Color getFlashColor() {
    return config.shadowVeilFlashColor();
  }

  @Override
  protected int getTimeoutSeconds() {
    return config.shadowVeilTimeoutSeconds();
  }
}
package com.portaguy;

import lombok.AllArgsConstructor;
import lombok.Getter;

import javax.annotation.Nullable;

/**
 * Represents the player's current spellbook.
 * <br/>
 * This enum maps the values of VarbitID.SPELLBOOK (4070).
 */
@Getter
@AllArgsConstructor
public enum Spellbook {
  STANDARD(0),
  ANCIENT(1),
  LUNAR(2),
  ARCEUUS(3);

  private final int varbit;

  @Nullable
  public static Spellbook fromVarbit(int varbitValue) {
    switch (varbitValue) {
      case 0: return STANDARD;
      case 1: return ANCIENT;
      case 2: return LUNAR;
      case 3: return ARCEUUS;
      default: return null;
    }
  }
}
package com.portaguy;

import com.google.inject.Inject;
import net.runelite.client.ui.overlay.OverlayManager;

import java.util.HashMap;
import java.util.Map;

public class SpellReminderOverlayFactory {
  private final Map<SpellTracker, SpellReminderOverlay> activeOverlays;

  @Inject
  private final OverlayManager overlayManager;

  @Inject
  public SpellReminderOverlayFactory(OverlayManager overlayManager) {
    this.overlayManager = overlayManager;
    this.activeOverlays = new HashMap<>();
  }

  public void createOverlay(SpellTracker tracker) {
    if (tracker == null || !tracker.isSpellTracked()) {
      return;
    }

    SpellReminderOverlay overlay = tracker.getOverlay();
    if (overlay == null) {
      return;
    }

    overlay.setStartTime(System.currentTimeMillis());
    activeOverlays.put(tracker, overlay);
    overlayManager.add(overlay);
  }

  public void removeOverlay(SpellTracker tracker) {
    if (tracker == null) {
      return;
    }

    SpellReminderOverlay overlay = activeOverlays.remove(tracker);
    if (overlay != null) {
      overlayManager.remove(overlay);
    }
  }

  public void removeAllOverlays() {
    activeOverlays.values().forEach(overlayManager::remove);
    activeOverlays.clear();
  }

  public boolean isOverlayActive(SpellTracker tracker) {
    return activeOverlays.containsKey(tracker);
  }
}
package com.portaguy;

public enum SpellReminderStyle {
  LONG_TEXT,
  SHORT_TEXT,
  CUSTOM_TEXT,
  INFOBOX
}

package com.portaguy;

import com.google.inject.Inject;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;

import java.util.HashMap;
import java.util.Map;

public class SpellReminderInfoboxFactory {
  private final Map<SpellTracker, SpellReminderInfobox> activeInfoboxes;

  @Inject
  private final InfoBoxManager infoBoxManager;

  @Inject
  private final SpriteManager spriteManager;

  @Inject
  public SpellReminderInfoboxFactory(InfoBoxManager infoBoxManager, SpriteManager spriteManager) {
    this.infoBoxManager = infoBoxManager;
    this.spriteManager = spriteManager;
    this.activeInfoboxes = new HashMap<>();
  }

  public void createInfobox(SpellTracker tracker) {
    if (tracker == null || !tracker.isSpellTracked() || tracker.getReminderStyle() != SpellReminderStyle.INFOBOX) {
      return;
    }

    SpellReminderInfobox infobox = tracker.getInfobox();
    if (infobox == null) {
      return;
    }

    if (activeInfoboxes.containsKey(tracker)) {
      return;
    }

    infobox.setStartTime(System.currentTimeMillis());
    spriteManager.getSpriteAsync(infobox.getSpriteId(), 0, infobox::setImage);
    activeInfoboxes.put(tracker, infobox);
    infoBoxManager.addInfoBox(infobox);
  }

  public void removeInfobox(SpellTracker tracker) {
    if (tracker == null) {
      return;
    }

    SpellReminderInfobox infobox = activeInfoboxes.remove(tracker);
    if (infobox != null) {
      infoBoxManager.removeInfoBox(infobox);
    }
  }

  public void removeAllInfoboxes() {
    activeInfoboxes.values().forEach(infoBoxManager::removeInfoBox);
    activeInfoboxes.clear();
  }

  public boolean isInfoboxActive(SpellTracker tracker) {
    return activeInfoboxes.containsKey(tracker);
  }
}
package com.portaguy;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.config.Notification;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.config.Keybind;

import javax.inject.Inject;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

@Slf4j
@Getter
public abstract class SpellTracker {
  protected Spellbook spellbook;
  protected boolean removedOnDeath;
  protected Pattern notifyMessage;
  protected Pattern removeMessage;

  protected boolean active;
  protected boolean expired;
  protected int startTick;
  protected int finalTick;

  @Inject
  protected Client client;

  @Inject
  protected SpellReminderPlugin plugin;

  @Inject
  protected SpellReminderConfig config;

  public SpellTracker(Spellbook spellbook, boolean removedOnDeath) {
    this.spellbook = spellbook;
    this.removedOnDeath = removedOnDeath;
    this.notifyMessage = Pattern.compile("");
    this.removeMessage = Pattern.compile("");

    reset();
  }

  public void start() {
    active = true;
    expired = false;
    startTick = client.getTickCount();
    finalTick = Integer.MAX_VALUE;
  }

  public void start(int maxDuration) {
    active = true;
    expired = false;
    startTick = client.getTickCount();
    finalTick = startTick + maxDuration;
  }

  public void stop() {
    active = false;
    expired = true;
  }

  protected void reset() {
    active = false;
    expired = false;
    startTick = -1;
    finalTick = Integer.MAX_VALUE;
  }

  public void initializePatterns() {
    final String notify = getNotifyPattern();
    try {
      notifyMessage = Pattern.compile(notify);
    } catch (PatternSyntaxException exception) {
      notifyMessage = Pattern.compile("");
    }

    final String remove = getRemovePattern();
    try {
      removeMessage = Pattern.compile(remove);
    } catch (PatternSyntaxException exception) {
      removeMessage = Pattern.compile("");
    }
  }

  @Subscribe
  protected void onConfigChanged(ConfigChanged event) {
    if (!event.getGroup().equals(SpellReminderConfig.GROUP)) {
      return;
    }

    initializePatterns();
  }

  @Subscribe
  protected void onActorDeath(ActorDeath event) {
    Player player = client.getLocalPlayer();
    if (player == null) {
      return;
    }

    if (event.getActor() instanceof Player) {
      Player actor = (Player) event.getActor();
      if (!actor.equals(player)) {
        return;
      }

      if (removedOnDeath && active) {
        stop();
      }
    }
  }

  @Subscribe
  protected void onVarbitChanged(VarbitChanged event) {
  }

  @Subscribe
  protected void onChatMessage(ChatMessage event) {
  }

  // Run this after the plugin's main game tick to reset a tracker
  @Subscribe(priority = -1)
  protected void onGameTick(GameTick ignored) {
    if (active && client.getTickCount() == finalTick) {
      stop();
    } else if (isExpired() || client.getTickCount() > finalTick) {
      reset();
    }
  }

  /**
   * Checks if this spell should show notifications only when its spellbook is
   * active
   *
   * @return true if the spell should be tracked only on its spellbook, false
   *         otherwise
   */
  protected abstract boolean onlyOnSpellbook();

  /**
   * Checks if this spell should be tracked based on config settings
   *
   * @return true if the spell should be tracked, false otherwise
   */
  protected abstract boolean isSpellTracked();

  /**
   * Gets the custom regex pattern to notify about the tracker
   *
   * @return The custom remove notify expression
   */
  protected abstract String getNotifyPattern();

  /**
   * Gets the custom regex pattern to remove the tracker's overlays
   *
   * @return The custom remove regular expression
   */
  protected abstract String getRemovePattern();

  /**
   * Checks if the patterns should only be applied to game messages
   *
   * @return true if patterns should only be applied on game messages, false
   *         otherwise
   */
  protected abstract boolean onGameMessageOnly();

  /**
   * Checks if this spell should show notifications based on config settings
   *
   * @return The custom notification for this spell
   */
  protected abstract Notification getNotification();

  /**
   * Gets the custom message to display when the spell expires
   *
   * @return The custom message for this spell
   */
  protected abstract String getCustomMessage();

  /**
   * Gets the overlay to display when the spell expires
   *
   * @return The custom overlay for this spell
   */
  protected abstract SpellReminderOverlay getOverlay();

  /**
   * Gets the infobox to display when the spell expires
   *
   * @return The custom infobox for this spell
   */
  protected abstract SpellReminderInfobox getInfobox();

  /**
   * Gets the hotkey to hide this spell's reminder overlay
   *
   * @return The hotkey binding for this spell
   */
  protected abstract Keybind getHideReminderHotkey();

  /**
   * Gets the type of notification style for a tracker
   *
   * @return The style to notify the user with
   */
  protected abstract SpellReminderStyle getReminderStyle();

  /**
   * Returns the config key for the reminder style for this tracker.
   */
  public abstract String getReminderStyleConfigKey();
}
package com.portaguy;

import net.runelite.client.config.*;

import java.awt.*;

@ConfigGroup(SpellReminderConfig.GROUP)
public interface SpellReminderConfig extends Config {
  String GROUP = "thrallhelper";

  // Sections

  @ConfigSection(
      name = "Thralls",
      description = "Thrall Reminder Settings",
      position = 0,
      closedByDefault = true
  )
  String THRALL_SECTION = "thrallSection";

  @ConfigSection(
      name = "Death Charge",
      description = "Death Charge Reminder Settings",
      position = 1,
      closedByDefault = true
  )
  String DEATH_CHARGE_SECTION = "deathChargeSection";

  @ConfigSection(
      name = "Mark of Darkness",
      description = "Mark of Darkness Reminder Settings",
      position = 2,
      closedByDefault = true
  )
  String MARK_OF_DARKNESS_SECTION = "markOfDarknessSection";

  @ConfigSection(
      name = "Ward of Arceuus",
      description = "Ward of Arceuus Reminder Settings",
      position = 3,
      closedByDefault = true
  )
  String WARD_OF_ARCEUUS_SECTION = "wardOfArceuusSection";

  @ConfigSection(
      name = "Shadow Veil",
      description = "Shadow Veil Reminder Settings",
      position = 4,
      closedByDefault = true
  )
  String SHADOW_VEIL_SECTION = "shadowVeilSection";

  @ConfigSection(
      name = "Corruption",
      description = "Corruption Reminder Settings",
      position = 5,
      closedByDefault = true
  )
  String CORRUPTION_SECTION = "corruptionSection";

  @ConfigSection(
      name = "Charge",
      description = "Charge Reminder Settings",
      position = 7,
      closedByDefault = true
  )
  String CHARGE_SECTION = "chargeSection";

  @ConfigSection(
      name = "Vengeance",
      description = "Vengeance Reminder Settings",
      position = 8,
      closedByDefault = true
  )
  String VENGEANCE_SECTION = "vengeanceSection";

  @ConfigSection(
      name = "Vile Vigour",
      description = "Vile Vigour Reminder Settings",
      position = 9,
      closedByDefault = true
  )
  String VILE_VIGOUR_SECTION = "vileVigourSection";

  /*
   * Thralls
   * Note: These do not have a "thrall" keyName as they were created when the
   * plugin
   * was simply "Thrall Helper" and have been preserved to keep user settings.
   */

  @ConfigItem(
      keyName = "thrallEnabled",
      name = "Thrall Enabled",
      description = "Enables reminders for Thralls.",
      position = 0,
      section = THRALL_SECTION
  )
  default boolean thrallEnabled() {
    return true;
  }

  @ConfigItem(
      keyName = "shouldNotify",
      name = "Notification on Reminder",
      description = "Sends a notification once the thrall needs to be summoned.",
      position = 1,
      section = THRALL_SECTION
  )
  default Notification shouldNotify() {
    return Notification.ON;
  }

  @ConfigItem(
      keyName = "thrallTimeoutSeconds",
      name = "Reminder Box Timeout",
      description = "The duration in seconds before the reminder box disappears.",
      position = 2,
      section = THRALL_SECTION
  )
  @Units(Units.SECONDS)
  default int thrallTimeoutSeconds() {
    return 60;
  }

  @ConfigItem(
      keyName = "onlyArceuus",
      name = "Only on Arceuus Spellbook",
      description = "Only display the reminder box when on the Arceuus spellbook.",
      position = 3,
      section = THRALL_SECTION
  )
  default boolean onlyArceuus() {
    return false;
  }

  @ConfigItem(
      keyName = "hideReminderHotkey",
      name = "Hide Reminder Hotkey",
      description = "Sets a hotkey to instantly hide the reminder box.",
      position = 4,
      section = THRALL_SECTION
  )
  default Keybind hideReminderHotkey() {
    return Keybind.NOT_SET;
  }

  @ConfigItem(
      keyName = "reminderStyle",
      name = "Reminder style",
      description = "Changes the style of the reminder box",
      position = 5,
      section = THRALL_SECTION
  )
  default SpellReminderStyle reminderStyle() {
    return SpellReminderStyle.LONG_TEXT;
  }

  @ConfigItem(
      keyName = "customText",
      name = "Custom Text",
      description = "Changes the text in the reminder box if the style is set to custom text",
      position = 6,
      section = THRALL_SECTION
  )
  default String customText() {
    return "You need to summon a thrall!";
  }

  @ConfigItem(
      keyName = "shouldFlash",
      name = "Flash the Reminder Box",
      description = "Makes the reminder box flash between the defined colors.",
      position = 7,
      section = THRALL_SECTION
  )
  default boolean shouldFlash() {
    return false;
  }

  @Alpha
  @ConfigItem(
      keyName = "flashColor2",
      name = "Color",
      description = "The second color to flash between.",
      position = 8,
      section = THRALL_SECTION
  )
  default Color color() {
    return new Color(255, 0, 0, 150);
  }

  @Alpha
  @ConfigItem(
      keyName = "flashColor1",
      name = "Flash Color",
      description = "The first color to flash between, also controls the non-flashing color.",
      position = 9,
      section = THRALL_SECTION
  )
  default Color flashColor() {
    return new Color(70,  70, 70, 150);
  }

  @ConfigItem(
      keyName = "reminderRegex",
      name = "Remind on Regex",
      description = "Displays the reminder box upon a chat message matching the regex.",
      position = 10,
      section = THRALL_SECTION
  )
  default String notifyRegex() {
    return "";
  }

  @ConfigItem(
      keyName = "hiderRegex",
      name = "Hide on Regex",
      description = "Hides the reminder (if active) upon a chat message matching the regex.",
      position = 11,
      section = THRALL_SECTION
  )
  default String removeRegex() {
    return "";
  }

  @ConfigItem(
      keyName = "matchGameMessagesOnly",
      name = "Only Match Game Messages",
      description = "Only attempt to match game messages with the regex.",
      position = 12,
      section = THRALL_SECTION
  )
  default boolean matchGameMessagesOnly() {
    return false;
  }

  // Death Charge

  @ConfigItem(
      keyName = "deathChargeEnabled",
      name = "Death Charge Enabled",
      description = "Enables reminders for Death Charge.",
      position = 0,
      section = DEATH_CHARGE_SECTION
  )
  default boolean deathChargeEnabled() {
    return false;
  }

  @ConfigItem(
      keyName = "deathChargeShouldNotify",
      name = "Notification on Reminder",
      description = "Sends a notification when Death Charge can be recast.",
      position = 1,
      section = DEATH_CHARGE_SECTION
  )
  default Notification deathChargeShouldNotify() {
    return Notification.ON;
  }

  @ConfigItem(
      keyName = "deathChargeTimeoutSeconds",
      name = "Reminder Box Timeout",
      description = "The duration in seconds before the reminder box disappears.",
      position = 2,
      section = DEATH_CHARGE_SECTION
  )
  @Units(Units.SECONDS)
  default int deathChargeTimeoutSeconds() {
    return 60;
  }

  @ConfigItem(
      keyName = "deathChargeOnlyArceuus",
      name = "Only on Arceuus Spellbook",
      description = "Only display the reminder box when on the Arceuus spellbook.",
      position = 3,
      section = DEATH_CHARGE_SECTION
  )
  default boolean deathChargeOnlyArceuus() {
    return false;
  }

  @ConfigItem(
      keyName = "deathChargeHideReminderHotkey",
      name = "Hide Reminder Hotkey",
      description = "Sets a hotkey to instantly hide the reminder box.",
      position = 4,
      section = DEATH_CHARGE_SECTION
  )
  default Keybind deathChargeHideReminderHotkey() {
    return Keybind.NOT_SET;
  }

  @ConfigItem(
      keyName = "deathChargeReminderStyle",
      name = "Reminder style",
      description = "Changes the style of the reminder box",
      position = 5,
      section = DEATH_CHARGE_SECTION
  )
  default SpellReminderStyle deathChargeReminderStyle() {
    return SpellReminderStyle.LONG_TEXT;
  }

  @ConfigItem(
      keyName = "deathChargeCustomText",
      name = "Custom Text",
      description = "Changes the text in the reminder box if the style is set to custom text",
      position = 6,
      section = DEATH_CHARGE_SECTION
  )
  default String deathChargeCustomText() {
    return "You need to cast Death Charge!";
  }

  @ConfigItem(
      keyName = "deathChargeShouldFlash",
      name = "Flash the Reminder Box",
      description = "Makes the reminder box flash between the defined colors.",
      position = 7,
      section = DEATH_CHARGE_SECTION
  )
  default boolean deathChargeShouldFlash() {
    return false;
  }

  @Alpha
  @ConfigItem(
      keyName = "deathChargeColor",
      name = "Color",
      description = "The second color to flash between.",
      position = 8,
      section = DEATH_CHARGE_SECTION
  )
  default Color deathChargeColor() {
    return new Color(48, 200, 215, 150);
  }

  @Alpha
  @ConfigItem(
      keyName = "deathChargeFlashColor",
      name = "Flash Color",
      description = "The first color to flash between, also controls the non-flashing color.",
      position = 9,
      section = DEATH_CHARGE_SECTION
  )
  default Color deathChargeFlashColor() {
    return new Color(70,  70, 70, 150);
  }

  @ConfigItem(
      keyName = "deathChargeNotifyRegex",
      name = "Remind on Regex",
      description = "Displays the reminder box upon a chat message matching the regex.",
      position = 10,
      section = DEATH_CHARGE_SECTION
  )
  default String deathChargeNotifyRegex() {
    return "";
  }

  @ConfigItem(
      keyName = "deathChargeRemoveRegex",
      name = "Hide on Regex",
      description = "Hides the reminder (if active) upon a chat message matching the regex.",
      position = 11,
      section = DEATH_CHARGE_SECTION
  )
  default String deathChargeRemoveRegex() {
    return "";
  }

  @ConfigItem(
      keyName = "deathChargeMatchGameMessagesOnly",
      name = "Only Match Game Messages",
      description = "Only attempt to match game messages with the regex.",
      position = 12,
      section = DEATH_CHARGE_SECTION
  )
  default boolean deathChargeMatchGameMessagesOnly() {
    return false;
  }

  // Mark of Darkness

  @ConfigItem(
      keyName = "markOfDarknessEnabled",
      name = "Mark of Darkness Enabled",
      description = "Enables reminders for Mark of Darkness.",
      position = 0,
      section = MARK_OF_DARKNESS_SECTION
  )
  default boolean markOfDarknessEnabled() {
    return false;
  }

  @ConfigItem(
      keyName = "markOfDarknessShouldNotify",
      name = "Notification on Reminder",
      description = "Sends a notification when Mark of Darkness wears off.",
      position = 1,
      section = MARK_OF_DARKNESS_SECTION
  )
  default Notification markOfDarknessShouldNotify() {
    return Notification.ON;
  }

  @ConfigItem(
      keyName = "markOfDarknessTimeoutSeconds",
      name = "Reminder Box Timeout",
      description = "The duration in seconds before the reminder box disappears.",
      position = 2,
      section = MARK_OF_DARKNESS_SECTION
  )
  @Units(Units.SECONDS)
  default int markOfDarknessTimeoutSeconds() {
    return 60;
  }

  @ConfigItem(
      keyName = "markOfDarknessOnlyArceuus",
      name = "Only on Arceuus Spellbook",
      description = "Only display the reminder box when on the Arceuus spellbook.",
      position = 3,
      section = MARK_OF_DARKNESS_SECTION
  )
  default boolean markOfDarknessOnlyArceuus() {
    return false;
  }

  @ConfigItem(
      keyName = "markOfDarknessHideReminderHotkey",
      name = "Hide Reminder Hotkey",
      description = "Sets a hotkey to instantly hide the reminder box.",
      position = 4,
      section = MARK_OF_DARKNESS_SECTION
  )
  default Keybind markOfDarknessHideReminderHotkey() {
    return Keybind.NOT_SET;
  }

  @ConfigItem(
      keyName = "markOfDarknessReminderStyle",
      name = "Reminder style",
      description = "Changes the style of the reminder box",
      position = 5,
      section = MARK_OF_DARKNESS_SECTION
  )
  default SpellReminderStyle markOfDarknessReminderStyle() {
    return SpellReminderStyle.LONG_TEXT;
  }

  @ConfigItem(
      keyName = "markOfDarknessCustomText",
      name = "Custom Text",
      description = "Changes the text in the reminder box if the style is set to custom text",
      position = 6,
      section = MARK_OF_DARKNESS_SECTION
  )
  default String markOfDarknessCustomText() {
    return "You need to cast Mark of Darkness!";
  }

  @ConfigItem(
      keyName = "markOfDarknessShouldFlash",
      name = "Flash the Reminder Box",
      description = "Makes the reminder box flash between the defined colors.",
      position = 7,
      section = MARK_OF_DARKNESS_SECTION
  )
  default boolean markOfDarknessShouldFlash() {
    return false;
  }

  @Alpha
  @ConfigItem(
      keyName = "markOfDarknessColor",
      name = "Color",
      description = "The second color to flash between.",
      position = 8,
      section = MARK_OF_DARKNESS_SECTION
  )
  default Color markOfDarknessColor() {
    return new Color(85, 0, 205, 150);
  }

  @Alpha
  @ConfigItem(
      keyName = "markOfDarknessFlashColor",
      name = "Flash Color",
      description = "The first color to flash between, also controls the non-flashing color.",
      position = 9,
      section = MARK_OF_DARKNESS_SECTION
  )
  default Color markOfDarknessFlashColor() {
    return new Color(70,  70, 70, 150);
  }

  @ConfigItem(
      keyName = "markOfDarknessNotifyRegex",
      name = "Remind on Regex",
      description = "Displays the reminder box upon a chat message matching the regex.",
      position = 10,
      section = MARK_OF_DARKNESS_SECTION
  )
  default String markOfDarknessNotifyRegex() {
    return "";
  }

  @ConfigItem(
      keyName = "markOfDarknessRemoveRegex",
      name = "Hide on Regex",
      description = "Hides the reminder (if active) upon a chat message matching the regex.",
      position = 11,
      section = MARK_OF_DARKNESS_SECTION
  )
  default String markOfDarknessRemoveRegex() {
    return "";
  }

  @ConfigItem(
      keyName = "markOfDarknessMatchGameMessagesOnly",
      name = "Only Match Game Messages",
      description = "Only attempt to match game messages with the regex.",
      position = 12,
      section = MARK_OF_DARKNESS_SECTION
  )
  default boolean markOfDarknessMatchGameMessagesOnly() {
    return false;
  }

  // Ward of Arceuus

  @ConfigItem(
      keyName = "wardOfArceuusEnabled",
      name = "Ward of Arceuus Enabled",
      description = "Enables reminders for Ward of ARceuus.",
      position = 0,
      section = WARD_OF_ARCEUUS_SECTION
  )
  default boolean wardOfArceuusEnabled() {
    return false;
  }

  @ConfigItem(
      keyName = "wardOfArceuusShouldNotify",
      name = "Notification on Reminder",
      description = "Sends a notification once Ward of Arceuus wears off.",
      position = 1,
      section = WARD_OF_ARCEUUS_SECTION
  )
  default Notification wardOfArceuusShouldNotify() {
    return Notification.ON;
  }

  @ConfigItem(
      keyName = "wardOfArceuusTimeoutSeconds",
      name = "Reminder Box Timeout",
      description = "The duration in seconds before the reminder box disappears.",
      position = 2,
      section = WARD_OF_ARCEUUS_SECTION
  )
  @Units(Units.SECONDS)
  default int wardOfArceuusTimeoutSeconds() {
    return 60;
  }

  @ConfigItem(
      keyName = "wardOfArceuusOnlyArceuus",
      name = "Only on Arceuus Spellbook",
      description = "Only display the reminder box when on the Arceuus spellbook.",
      position = 3,
      section = WARD_OF_ARCEUUS_SECTION
  )
  default boolean wardOfArceuusOnlyArceuus() {
    return false;
  }

  @ConfigItem(
      keyName = "wardOfArceuusHideReminderHotkey",
      name = "Hide Reminder Hotkey",
      description = "Sets a hotkey to instantly hide the reminder box.",
      position = 4,
      section = WARD_OF_ARCEUUS_SECTION
  )
  default Keybind wardOfArceuusHideReminderHotkey() {
    return Keybind.NOT_SET;
  }

  @ConfigItem(
      keyName = "wardOfArceuusReminderStyle",
      name = "Reminder style",
      description = "Changes the style of the reminder box",
      position = 5,
      section = WARD_OF_ARCEUUS_SECTION
  )
  default SpellReminderStyle wardOfArceuusReminderStyle() {
    return SpellReminderStyle.LONG_TEXT;
  }

  @ConfigItem(
      keyName = "wardOfArceuusCustomText",
      name = "Custom Text",
      description = "Changes the text in the reminder box if the style is set to custom text",
      position = 6,
      section = WARD_OF_ARCEUUS_SECTION
  )
  default String wardOfArceuusCustomText() {
    return "You need to cast Ward of Arceuus!";
  }

  @ConfigItem(
      keyName = "wardOfArceuusShouldFlash",
      name = "Flash the Reminder Box",
      description = "Makes the reminder box flash between the defined colors.",
      position = 7,
      section = WARD_OF_ARCEUUS_SECTION
  )
  default boolean wardOfArceuusShouldFlash() {
    return false;
  }

  @Alpha
  @ConfigItem(
      keyName = "wardOfArceuusColor",
      name = "Color",
      description = "The second color to flash between.",
      position = 8,
      section = WARD_OF_ARCEUUS_SECTION
  )
  default Color wardOfArceuusColor() {
    return new Color(0, 170, 128, 150);
  }

  @Alpha
  @ConfigItem(
      keyName = "wardOfArceuusFlashColor",
      name = "Flash Color",
      description = "The first color to flash between, also controls the non-flashing color.",
      position = 9,
      section = WARD_OF_ARCEUUS_SECTION
  )
  default Color wardOfArceuusFlashColor() {
    return new Color(70,  70, 70, 150);
  }

  @ConfigItem(
      keyName = "wardOfArceuusNotifyRegex",
      name = "Remind on Regex",
      description = "Displays the reminder box upon a chat message matching the regex.",
      position = 10,
      section = WARD_OF_ARCEUUS_SECTION
  )
  default String wardOfArceuusNotifyRegex() {
    return "";
  }

  @ConfigItem(
      keyName = "wardOfArceuusRemoveRegex",
      name = "Hide on Regex",
      description = "Hides the reminder (if active) upon a chat message matching the regex.",
      position = 11,
      section = WARD_OF_ARCEUUS_SECTION
  )
  default String wardOfArceuusRemoveRegex() {
    return "";
  }

  @ConfigItem(
      keyName = "wardOfArceuusMatchGameMessagesOnly",
      name = "Only Match Game Messages",
      description = "Only attempt to match game messages with the regex.",
      position = 12,
      section = WARD_OF_ARCEUUS_SECTION
  )
  default boolean wardOfArceuusMatchGameMessagesOnly() {
    return false;
  }

  // Shadow Veil

  @ConfigItem(
      keyName = "shadowVeilEnabled",
      name = "Shadow Veil Enabled",
      description = "Enables reminders for Shadow Veil.",
      position = 0,
      section = SHADOW_VEIL_SECTION
  )
  default boolean shadowVeilEnabled() {
    return false;
  }

  @ConfigItem(
      keyName = "shadowVeilShouldNotify",
      name = "Notification on Reminder",
      description = "Sends a notification once Shadow Veil wears off.",
      position = 1,
      section = SHADOW_VEIL_SECTION
  )
  default Notification shadowVeilShouldNotify() {
    return Notification.ON;
  }

  @ConfigItem(
      keyName = "shadowVeilTimeoutSeconds",
      name = "Reminder Box Timeout",
      description = "The duration in seconds before the reminder box disappears.",
      position = 2,
      section = SHADOW_VEIL_SECTION
  )
  @Units(Units.SECONDS)
  default int shadowVeilTimeoutSeconds() {
    return 60;
  }

  @ConfigItem(
      keyName = "shadowVeilOnlyArceuus",
      name = "Only on Arceuus Spellbook",
      description = "Only display the reminder box when on the Arceuus spellbook.",
      position = 3,
      section = SHADOW_VEIL_SECTION
  )
  default boolean shadowVeilOnlyArceuus() {
    return false;
  }

  @ConfigItem(
      keyName = "shadowVeilHideReminderHotkey",
      name = "Hide Reminder Hotkey",
      description = "Sets a hotkey to instantly hide the reminder box.",
      position = 4,
      section = SHADOW_VEIL_SECTION
  )
  default Keybind shadowVeilHideReminderHotkey() {
    return Keybind.NOT_SET;
  }

  @ConfigItem(
      keyName = "shadowVeilReminderStyle",
      name = "Reminder style",
      description = "Changes the style of the reminder box",
      position = 5,
      section = SHADOW_VEIL_SECTION
  )
  default SpellReminderStyle shadowVeilReminderStyle() {
    return SpellReminderStyle.LONG_TEXT;
  }

  @ConfigItem(
      keyName = "shadowVeilCustomText",
      name = "Custom Text",
      description = "Changes the text in the reminder box if the style is set to custom text",
      position = 6,
      section = SHADOW_VEIL_SECTION
  )
  default String shadowVeilCustomText() {
    return "You need to cast Shadow Veil!";
  }

  @ConfigItem(
      keyName = "shadowVeilShouldFlash",
      name = "Flash the Reminder Box",
      description = "Makes the reminder box flash between the defined colors.",
      position = 7,
      section = SHADOW_VEIL_SECTION
  )
  default boolean shadowVeilShouldFlash() {
    return false;
  }

  @Alpha
  @ConfigItem(
      keyName = "shadowVeilColor",
      name = "Color",
      description = "The second color to flash between.",
      position = 8,
      section = SHADOW_VEIL_SECTION
  )
  default Color shadowVeilColor() {
    return new Color(30, 30, 50, 150);
  }

  @Alpha
  @ConfigItem(
      keyName = "shadowVeilFlashColor",
      name = "Flash Color",
      description = "The first color to flash between, also controls the non-flashing color.",
      position = 9,
      section = SHADOW_VEIL_SECTION
  )
  default Color shadowVeilFlashColor() {
    return new Color(70,  70, 70, 150);
  }

  @ConfigItem(
      keyName = "shadowVeilNotifyRegex",
      name = "Remind on Regex",
      description = "Displays the reminder box upon a chat message matching the regex.",
      position = 10,
      section = SHADOW_VEIL_SECTION
  )
  default String shadowVeilNotifyRegex() {
    return "";
  }

  @ConfigItem(
      keyName = "shadowVeilRemoveRegex",
      name = "Hide on Regex",
      description = "Hides the reminder (if active) upon a chat message matching the regex.",
      position = 11,
      section = SHADOW_VEIL_SECTION
  )
  default String shadowVeilRemoveRegex() {
    return "";
  }

  @ConfigItem(
      keyName = "shadowVeilMatchGameMessagesOnly",
      name = "Only Match Game Messages",
      description = "Only attempt to match game messages with the regex.",
      position = 12,
      section = SHADOW_VEIL_SECTION
  )
  default boolean shadowVeilMatchGameMessagesOnly() {
    return false;
  }

  // Corruption

  @ConfigItem(
      keyName = "corruptionEnabled",
      name = "Corruption Enabled",
      description = "Enables reminders for Corruption.",
      position = 0,
      section = CORRUPTION_SECTION
  )
  default boolean corruptionEnabled() {
    return false;
  }

  @ConfigItem(
      keyName = "corruptionShouldNotify",
      name = "Notification on Reminder",
      description = "Sends a notification once Corruption should be recast.",
      position = 1,
      section = CORRUPTION_SECTION
  )
  default Notification corruptionShouldNotify() {
    return Notification.ON;
  }

  @ConfigItem(
      keyName = "corruptionTimeoutSeconds",
      name = "Reminder Box Timeout",
      description = "The duration in seconds before the reminder box disappears.",
      position = 2,
      section = CORRUPTION_SECTION
  )
  @Units(Units.SECONDS)
  default int corruptionTimeoutSeconds() {
    return 60;
  }

  @ConfigItem(
      keyName = "corruptionOnlyArceuus",
      name = "Only on Arceuus Spellbook",
      description = "Only display the reminder box when on the Arceuus spellbook.",
      position = 3,
      section = CORRUPTION_SECTION
  )
  default boolean corruptionOnlyArceuus() {
    return false;
  }

  @ConfigItem(
      keyName = "corruptionHideReminderHotkey",
      name = "Hide Reminder Hotkey",
      description = "Sets a hotkey to instantly hide the reminder box.",
      position = 4,
      section = CORRUPTION_SECTION
  )
  default Keybind corruptionHideReminderHotkey() {
    return Keybind.NOT_SET;
  }

  @ConfigItem(
      keyName = "corruptionReminderStyle",
      name = "Reminder style",
      description = "Changes the style of the reminder box",
      position = 5,
      section = CORRUPTION_SECTION
  )
  default SpellReminderStyle corruptionReminderStyle() {
    return SpellReminderStyle.LONG_TEXT;
  }

  @ConfigItem(
      keyName = "corruptionCustomText",
      name = "Custom Text",
      description = "Changes the text in the reminder box if the style is set to custom text",
      position = 6,
      section = CORRUPTION_SECTION
  )
  default String corruptionCustomText() {
    return "You need to cast a Corruption spell!";
  }

  @ConfigItem(
      keyName = "corruptionShouldFlash",
      name = "Flash the Reminder Box",
      description = "Makes the reminder box flash between the defined colors.",
      position = 7,
      section = CORRUPTION_SECTION
  )
  default boolean corruptionShouldFlash() {
    return false;
  }

  @Alpha
  @ConfigItem(
      keyName = "corruptionColor",
      name = "Color",
      description = "The second color to flash between.",
      position = 8,
      section = CORRUPTION_SECTION
  )
  default Color corruptionColor() {
    return new Color(70, 3, 0, 150);
  }

  @Alpha
  @ConfigItem(
      keyName = "corruptionFlashColor",
      name = "Flash Color",
      description = "The first color to flash between, also controls the non-flashing color.",
      position = 9,
      section = CORRUPTION_SECTION
  )
  default Color corruptionFlashColor() {
    return new Color(70,  70, 70, 150);
  }

  @ConfigItem(
      keyName = "corruptionNotifyRegex",
      name = "Remind on Regex",
      description = "Displays the reminder box upon a chat message matching the regex.",
      position = 10,
      section = CORRUPTION_SECTION
  )
  default String corruptionNotifyRegex() {
    return "";
  }

  @ConfigItem(
      keyName = "corruptionRemoveRegex",
      name = "Hide on Regex",
      description = "Hides the reminder (if active) upon a chat message matching the regex.",
      position = 11,
      section = CORRUPTION_SECTION
  )
  default String corruptionRemoveRegex() {
    return "";
  }

  @ConfigItem(
      keyName = "corruptionMatchGameMessagesOnly",
      name = "Only Match Game Messages",
      description = "Only attempt to match game messages with the regex.",
      position = 12,
      section = CORRUPTION_SECTION
  )
  default boolean corruptionMatchGameMessagesOnly() {
    return false;
  }

  // Charge

  @ConfigItem(
      keyName = "chargeEnabled",
      name = "Charge Enabled",
      description = "Enables reminders for Charge.",
      position = 0,
      section = CHARGE_SECTION
  )
  default boolean chargeEnabled() {
    return false;
  }

  @ConfigItem(
      keyName = "chargeShouldNotify",
      name = "Notification on Reminder",
      description = "Sends a notification once Charge wears off.",
      position = 1,
      section = CHARGE_SECTION
  )
  default Notification chargeShouldNotify() {
    return Notification.ON;
  }

  @ConfigItem(
      keyName = "chargeTimeoutSeconds",
      name = "Reminder Box Timeout",
      description = "The duration in seconds before the reminder box disappears.",
      position = 2,
      section = CHARGE_SECTION
  )
  @Units(Units.SECONDS)
  default int chargeTimeoutSeconds() {
    return 60;
  }

  @ConfigItem(
      keyName = "chargeOnlyStandard",
      name = "Only on Standard Spellbook",
      description = "Only display the reminder box when on the Standard spellbook.",
      position = 3,
      section = CHARGE_SECTION
  )
  default boolean chargeOnlyStandard() {
    return false;
  }

  @ConfigItem(
      keyName = "chargeHideReminderHotkey",
      name = "Hide Reminder Hotkey",
      description = "Sets a hotkey to instantly hide the reminder box.",
      position = 4,
      section = CHARGE_SECTION
  )
  default Keybind chargeHideReminderHotkey() {
    return Keybind.NOT_SET;
  }

  @ConfigItem(
      keyName = "chargeReminderStyle",
      name = "Reminder style",
      description = "Changes the style of the reminder box",
      position = 5,
      section = CHARGE_SECTION
  )
  default SpellReminderStyle chargeReminderStyle() {
    return SpellReminderStyle.LONG_TEXT;
  }

  @ConfigItem(
      keyName = "chargeCustomText",
      name = "Custom Text",
      description = "Changes the text in the reminder box if the style is set to custom text",
      position = 6,
      section = CHARGE_SECTION
  )
  default String chargeCustomText() {
    return "You need to cast Charge!";
  }

  @ConfigItem(
      keyName = "chargeShouldFlash",
      name = "Flash the Reminder Box",
      description = "Makes the reminder box flash between the defined colors.",
      position = 7,
      section = CHARGE_SECTION
  )
  default boolean chargeShouldFlash() {
    return false;
  }

  @Alpha
  @ConfigItem(
      keyName = "chargeColor",
      name = "Color",
      description = "The second color to flash between.",
      position = 8,
      section = CHARGE_SECTION
  )
  default Color chargeColor() {
    return new Color(192, 188, 0, 150);
  }

  @Alpha
  @ConfigItem(
      keyName = "chargeFlashColor",
      name = "Flash Color",
      description = "The first color to flash between, also controls the non-flashing color.",
      position = 9,
      section = CHARGE_SECTION
  )
  default Color chargeFlashColor() {
    return new Color(70,  70, 70, 150);
  }

  @ConfigItem(
      keyName = "chargeNotifyRegex",
      name = "Remind on Regex",
      description = "Displays the reminder box upon a chat message matching the regex.",
      position = 10,
      section = CHARGE_SECTION
  )
  default String chargeNotifyRegex() {
    return "";
  }

  @ConfigItem(
      keyName = "chargeRemoveRegex",
      name = "Hide on Regex",
      description = "Hides the reminder (if active) upon a chat message matching the regex.",
      position = 11,
      section = CHARGE_SECTION
  )
  default String chargeRemoveRegex() {
    return "";
  }

  @ConfigItem(
      keyName = "chargeMatchGameMessagesOnly",
      name = "Only Match Game Messages",
      description = "Only attempt to match game messages with the regex.",
      position = 12,
      section = CHARGE_SECTION
  )
  default boolean chargeMatchGameMessagesOnly() {
    return false;
  }

  // Vengeance

  @ConfigItem(
      keyName = "vengeanceEnabled",
      name = "Vengeance Enabled",
      description = "Enables reminders for Vengeance.",
      position = 0,
      section = VENGEANCE_SECTION
  )
  default boolean vengeanceEnabled() {
    return false;
  }

  @ConfigItem(
      keyName = "vengeanceShouldNotify",
      name = "Notification on Reminder",
      description = "Sends a notification once Vengeance can be recast.",
      position = 1,
      section = VENGEANCE_SECTION
  )
  default Notification vengeanceShouldNotify() {
    return Notification.ON;
  }

  @ConfigItem(
      keyName = "vengeanceTimeoutSeconds",
      name = "Reminder Box Timeout",
      description = "The duration in seconds before the reminder box disappears.",
      position = 2,
      section = VENGEANCE_SECTION
  )
  @Units(Units.SECONDS)
  default int vengeanceTimeoutSeconds() {
    return 60;
  }

  @ConfigItem(
      keyName = "vengeanceOnlyLunar",
      name = "Only on Lunar Spellbook",
      description = "Only display the reminder box when on the Lunar spellbook.",
      position = 3,
      section = VENGEANCE_SECTION
  )
  default boolean vengeanceOnlyLunar() {
    return false;
  }

  @ConfigItem(
      keyName = "vengeanceHideReminderHotkey",
      name = "Hide Reminder Hotkey",
      description = "Sets a hotkey to instantly hide the reminder box.",
      position = 4,
      section = VENGEANCE_SECTION
  )
  default Keybind vengeanceHideReminderHotkey() {
    return Keybind.NOT_SET;
  }

  @ConfigItem(
      keyName = "vengeanceReminderStyle",
      name = "Reminder style",
      description = "Changes the style of the reminder box",
      position = 5,
      section = VENGEANCE_SECTION
  )
  default SpellReminderStyle vengeanceReminderStyle() {
    return SpellReminderStyle.LONG_TEXT;
  }

  @ConfigItem(
      keyName = "vengeanceCustomText",
      name = "Custom Text",
      description = "Changes the text in the reminder box if the style is set to custom text",
      position = 6,
      section = VENGEANCE_SECTION
  )
  default String vengeanceCustomText() {
    return "You need to cast Vengeance!";
  }

  @ConfigItem(
      keyName = "vengeanceShouldFlash",
      name = "Flash the Reminder Box",
      description = "Makes the reminder box flash between the defined colors.",
      position = 7,
      section = VENGEANCE_SECTION
  )
  default boolean vengeanceShouldFlash() {
    return false;
  }

  @Alpha
  @ConfigItem(
      keyName = "vengeanceColor",
      name = "Color",
      description = "The second color to flash between.",
      position = 8,
      section = VENGEANCE_SECTION
  )
  default Color vengeanceColor() {
    return new Color(175, 175, 200, 150);
  }

  @Alpha
  @ConfigItem(
      keyName = "vengeanceFlashColor",
      name = "Flash Color",
      description = "The first color to flash between, also controls the non-flashing color.",
      position = 9,
      section = VENGEANCE_SECTION
  )
  default Color vengeanceFlashColor() {
    return new Color(70,  70, 70, 150);
  }

  @ConfigItem(
      keyName = "vengeanceNotifyRegex",
      name = "Remind on Regex",
      description = "Displays the reminder box upon a chat message matching the regex.",
      position = 10,
      section = VENGEANCE_SECTION
  )
  default String vengeanceNotifyRegex() {
    return "";
  }

  @ConfigItem(
      keyName = "vengeanceRemoveRegex",
      name = "Hide on Regex",
      description = "Hides the reminder (if active) upon a chat message matching the regex.",
      position = 11,
      section = VENGEANCE_SECTION
  )
  default String vengeanceRemoveRegex() {
    return "";
  }

  @ConfigItem(
      keyName = "vengeanceMatchGameMessagesOnly",
      name = "Only Match Game Messages",
      description = "Only attempt to match game messages with the regex.",
      position = 12,
      section = VENGEANCE_SECTION
  )
  default boolean vengeanceMatchGameMessagesOnly() {
    return false;
  }

  // Vile Vigour

  @ConfigItem(
      keyName = "vileVigourEnabled",
      name = "Vile Vigour Enabled",
      description = "Enables reminders for Vile Vigour.",
      position = 0,
      section = VILE_VIGOUR_SECTION
  )
  default boolean vileVigourEnabled() {
    return false;
  }

  @ConfigItem(
      keyName = "vileVigourRunThreshold",
      name = "Run Energy Threshold",
      description = "The run energy threshold for the reminder box to appear.",
      position = 1,
      section = VILE_VIGOUR_SECTION
  )
  default int vileVigourRunThreshold() {
    return 25;
  }

  @ConfigItem(
      keyName = "vileVigourThresholdTimeout",
      name = "Threshold Timeout",
      description = "The duration in seconds after cooldown to check the run threshold",
      position = 2,
      section = VILE_VIGOUR_SECTION
  )
  default int vileVigourThresholdTimeout() {
    return 60;
  }

  @ConfigItem(
      keyName = "vileVigourShouldNotify",
      name = "Notification on Reminder",
      description = "Sends a notification once the run energy threshold has been met.",
      position = 3,
      section = VILE_VIGOUR_SECTION
  )
  default Notification vileVigourShouldNotify() {
    return Notification.ON;
  }

  @ConfigItem(
      keyName = "vileVigourTimeoutSeconds",
      name = "Reminder Box Timeout",
      description = "The duration in seconds before the reminder box disappears.",
      position = 4,
      section = VILE_VIGOUR_SECTION
  )
  @Units(Units.SECONDS)
  default int vileVigourTimeoutSeconds() {
    return 60;
  }

  @ConfigItem(
      keyName = "vileVigourOnlyArceuus",
      name = "Only on Arceuus Spellbook",
      description = "Only display the reminder box when on the Arceuus spellbook.",
      position = 5,
      section = VILE_VIGOUR_SECTION
  )
  default boolean vileVigourOnlyArceuus() {
    return false;
  }

  @ConfigItem(
      keyName = "vileVigourHideReminderHotkey",
      name = "Hide Reminder Hotkey",
      description = "Sets a hotkey to instantly hide the reminder box.",
      position = 6,
      section = VILE_VIGOUR_SECTION
  )
  default Keybind vileVigourHideReminderHotkey() {
    return Keybind.NOT_SET;
  }

  @ConfigItem(
      keyName = "vileVigourReminderStyle",
      name = "Reminder style",
      description = "Changes the style of the reminder box",
      position = 7,
      section = VILE_VIGOUR_SECTION
  )
  default SpellReminderStyle vileVigourReminderStyle() {
    return SpellReminderStyle.LONG_TEXT;
  }

  @ConfigItem(
      keyName = "vileVigourCustomText",
      name = "Custom Text",
      description = "Changes the text in the reminder box if the style is set to custom text",
      position = 8,
      section = VILE_VIGOUR_SECTION
  )
  default String vileVigourCustomText() {
    return "You need to cast Vile Vigour!";
  }

  @ConfigItem(
      keyName = "vileVigourShouldFlash",
      name = "Flash the Reminder Box",
      description = "Makes the reminder box flash between the defined colors.",
      position = 9,
      section = VILE_VIGOUR_SECTION
  )
  default boolean vileVigourShouldFlash() {
    return false;
  }

  @Alpha
  @ConfigItem(
      keyName = "vileVigourColor",
      name = "Color",
      description = "The second color to flash between.",
      position = 10,
      section = VILE_VIGOUR_SECTION
  )
  default Color vileVigourColor() {
    return new Color(107, 219, 0, 150);
  }

  @Alpha
  @ConfigItem(
      keyName = "vileVigourFlashColor",
      name = "Flash Color",
      description = "The first color to flash between, also controls the non-flashing color.",
      position = 11,
      section = VILE_VIGOUR_SECTION
  )
  default Color vileVigourFlashColor() {
    return new Color(70,  70, 70, 150);
  }

  @ConfigItem(
      keyName = "vileVigourNotifyRegex",
      name = "Remind on Regex",
      description = "Displays the reminder box upon a chat message matching the regex.",
      position = 12,
      section = VILE_VIGOUR_SECTION
  )
  default String vileVigourNotifyRegex() {
    return "";
  }

  @ConfigItem(
      keyName = "vileVigourRemoveRegex",
      name = "Hide on Regex",
      description = "Hides the reminder (if active) upon a chat message matching the regex.",
      position = 13,
      section = VILE_VIGOUR_SECTION
  )
  default String vileVigourRemoveRegex() {
    return "";
  }

  @ConfigItem(
      keyName = "vileVigourMatchGameMessagesOnly",
      name = "Only Match Game Messages",
      description = "Only attempt to match game messages with the regex.",
      position = 14,
      section = VILE_VIGOUR_SECTION
  )
  default boolean vileVigourMatchGameMessagesOnly() {
    return false;
  }

  // Update Text
  @ConfigItem(
    keyName = "thrallHelperToSpellReminderUpdate",
    name = "Thrall Helper to Spell Reminder Update",
    description = "Tracks if the update notice for turning Thrall Helper into Spell Reminder has been shown",
    hidden = true
  )
  default boolean thrallHelperToSpellReminderUpdate() { return false; }
  String thrallHelperToSpellReminderUpdateText = "The Thrall Helper plugin has been transformed into the Spell Reminder plugin. " +
        "This adds reminder support for many other spells. " +
        "Please double-check your configuration options to make use of the new settings.";

}

package com.portaguy.infoboxes;

import com.portaguy.SpellReminderConfig;
import com.portaguy.SpellReminderInfobox;
import com.portaguy.SpellReminderPlugin;
import com.portaguy.trackers.DeathChargeTracker;
import net.runelite.api.SpriteID;

import javax.inject.Inject;

public class DeathChargeInfobox extends SpellReminderInfobox {
  @Inject
  public DeathChargeInfobox(SpellReminderPlugin plugin,
                            SpellReminderConfig config,
                            DeathChargeTracker tracker) {
    super(plugin, config, tracker);
  }

  @Override
  protected int getSpriteId() {
    return SpriteID.SPELL_DEATH_CHARGE;
  }

  @Override
  protected int getTimeoutSeconds() {
    return config.deathChargeTimeoutSeconds();
  }
}
package com.portaguy.infoboxes;

import com.portaguy.SpellReminderConfig;
import com.portaguy.SpellReminderInfobox;
import com.portaguy.SpellReminderPlugin;
import com.portaguy.trackers.ThrallTracker;

import javax.inject.Inject;

public class ThrallInfobox extends SpellReminderInfobox {
  private static final int SPRITE_SPELL_RESURRECT_GREATER_GHOST = 2979;

  @Inject
  public ThrallInfobox(SpellReminderPlugin plugin,
                       SpellReminderConfig config,
                       ThrallTracker tracker) {
    super(plugin, config, tracker);
  }

  @Override
  protected int getSpriteId() {
    return SPRITE_SPELL_RESURRECT_GREATER_GHOST;
  }

  @Override
  protected int getTimeoutSeconds() {
    return config.thrallTimeoutSeconds();
  }
}
package com.portaguy.infoboxes;

import com.portaguy.SpellReminderConfig;
import com.portaguy.SpellReminderInfobox;
import com.portaguy.SpellReminderPlugin;
import com.portaguy.trackers.MarkOfDarknessTracker;
import net.runelite.api.SpriteID;

import javax.inject.Inject;

public class MarkOfDarknessInfobox extends SpellReminderInfobox {
  @Inject
  public MarkOfDarknessInfobox(SpellReminderPlugin plugin,
                               SpellReminderConfig config,
                               MarkOfDarknessTracker tracker) {
    super(plugin, config, tracker);
  }

  @Override
  protected int getSpriteId() {
    return SpriteID.SPELL_MARK_OF_DARKNESS;
  }

  @Override
  protected int getTimeoutSeconds() {
    return config.markOfDarknessTimeoutSeconds();
  }
}
package com.portaguy.infoboxes;

import com.portaguy.SpellReminderConfig;
import com.portaguy.SpellReminderInfobox;
import com.portaguy.SpellReminderPlugin;
import com.portaguy.trackers.ShadowVeilTracker;
import net.runelite.api.SpriteID;

import javax.inject.Inject;

public class ShadowVeilInfobox extends SpellReminderInfobox {
  @Inject
  public ShadowVeilInfobox(SpellReminderPlugin plugin,
                           SpellReminderConfig config,
                           ShadowVeilTracker tracker) {
    super(plugin, config, tracker);
  }

  @Override
  protected int getSpriteId() {
    return SpriteID.SPELL_SHADOW_VEIL;
  }

  @Override
  protected int getTimeoutSeconds() {
    return config.shadowVeilTimeoutSeconds();
  }
}
package com.portaguy.infoboxes;

import com.portaguy.SpellReminderConfig;
import com.portaguy.SpellReminderInfobox;
import com.portaguy.SpellReminderPlugin;
import com.portaguy.trackers.VileVigourTracker;
import net.runelite.api.SpriteID;

import javax.inject.Inject;

public class VileVigourInfobox extends SpellReminderInfobox {
  @Inject
  public VileVigourInfobox(SpellReminderPlugin plugin,
                           SpellReminderConfig config,
                           VileVigourTracker tracker) {
    super(plugin, config, tracker);
  }

  @Override
  protected int getSpriteId() {
    return SpriteID.SPELL_VILE_VIGOUR;
  }

  @Override
  protected int getTimeoutSeconds() {
    return config.vileVigourTimeoutSeconds();
  }
}
package com.portaguy.infoboxes;

import com.portaguy.SpellReminderConfig;
import com.portaguy.SpellReminderInfobox;
import com.portaguy.SpellReminderPlugin;
import com.portaguy.trackers.CorruptionTracker;
import net.runelite.api.SpriteID;

import javax.inject.Inject;

public class CorruptionInfobox extends SpellReminderInfobox {
  @Inject
  public CorruptionInfobox(SpellReminderPlugin plugin,
                           SpellReminderConfig config,
                           CorruptionTracker tracker) {
    super(plugin, config, tracker);
  }

  @Override
  protected int getSpriteId() {
    return SpriteID.SPELL_GREATER_CORRUPTION;
  }

  @Override
  protected int getTimeoutSeconds() {
    return config.corruptionTimeoutSeconds();
  }
}
package com.portaguy.infoboxes;

import com.portaguy.SpellReminderConfig;
import com.portaguy.SpellReminderInfobox;
import com.portaguy.SpellReminderPlugin;
import com.portaguy.trackers.VengeanceTracker;
import net.runelite.api.SpriteID;

import javax.inject.Inject;

public class VengeanceInfobox extends SpellReminderInfobox {
  @Inject
  public VengeanceInfobox(SpellReminderPlugin plugin,
                          SpellReminderConfig config,
                          VengeanceTracker tracker) {
    super(plugin, config, tracker);
  }

  @Override
  protected int getSpriteId() {
    return SpriteID.SPELL_VENGEANCE;
  }

  @Override
  protected int getTimeoutSeconds() {
    return config.vengeanceTimeoutSeconds();
  }
}
package com.portaguy.infoboxes;

import com.portaguy.SpellReminderConfig;
import com.portaguy.SpellReminderInfobox;
import com.portaguy.SpellReminderPlugin;
import com.portaguy.trackers.ChargeTracker;
import net.runelite.api.SpriteID;

import javax.inject.Inject;

public class ChargeInfobox extends SpellReminderInfobox {
  @Inject
  public ChargeInfobox(SpellReminderPlugin plugin,
                       SpellReminderConfig config,
                       ChargeTracker tracker) {
    super(plugin, config, tracker);
  }

  @Override
  protected int getSpriteId() {
    return SpriteID.SPELL_CHARGE;
  }

  @Override
  protected int getTimeoutSeconds() {
    return config.chargeTimeoutSeconds();
  }
}
package com.portaguy.infoboxes;

import com.portaguy.SpellReminderConfig;
import com.portaguy.SpellReminderInfobox;
import com.portaguy.SpellReminderPlugin;
import com.portaguy.trackers.WardOfArceuusTracker;
import net.runelite.api.SpriteID;

import javax.inject.Inject;

public class WardOfArceuusInfobox extends SpellReminderInfobox {
  @Inject
  public WardOfArceuusInfobox(SpellReminderPlugin plugin,
                              SpellReminderConfig config,
                              WardOfArceuusTracker tracker) {
    super(plugin, config, tracker);
  }

  @Override
  protected int getSpriteId() {
    return SpriteID.SPELL_WARD_OF_ARCEUUS;
  }

  @Override
  protected int getTimeoutSeconds() {
    return config.wardOfArceuusTimeoutSeconds();
  }
}
package com.portaguy;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class SpellReminderPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(SpellReminderPlugin.class);
		RuneLite.main(args);
	}
}
