package com.revalclan.quests;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Quest;
import net.runelite.api.QuestState;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.Map;

/**
 * Manages quest completion data
 */
@Slf4j
@Singleton
public class QuestManager {
	@Inject private Client client;

	/**
	 * Sync and get quest completion data
	 */
	public Map<String, Object> sync() {
		Map<String, Object> questData = new HashMap<>();
		Map<String, String> questStates = new HashMap<>();
		
		for (Quest quest : Quest.values()) {
			QuestState state = quest.getState(client);
			questStates.put(quest.getName(), state.name());
		}
		
		questData.put("questPoints", client.getVarpValue(101));
		questData.put("questStates", questStates);
		
		return questData;
	}
}


package com.revalclan.util;

import com.google.gson.Gson;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.Map;
import java.util.zip.GZIPOutputStream;

@Slf4j
@Singleton
public class WebhookService {
	private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");
	private static final String WEBHOOK_URL = "https://api.revalosrs.ee/reval-webhook";
	
	@Inject
	private OkHttpClient httpClient;
	
	@Inject
	private Gson gson;

	/**
	 * Sends player data to webhook asynchronously
	 */
	public void sendDataAsync(Map<String, Object> data) {
		sendDataAsync(WEBHOOK_URL, data);
	}

	/**
	 * Sends player data to a specific webhook URL asynchronously
	 * 
	 * @param webhookUrl The webhook endpoint URL
	 * @param data The player data to send
	 */
	private void sendDataAsync(String webhookUrl, Map<String, Object> data) {
		if (webhookUrl == null || webhookUrl.trim().isEmpty()) {
			return;
		}

		try {
			String json = gson.toJson(data);
			byte[] jsonBytes = json.getBytes("UTF-8");
			
			ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
			try (GZIPOutputStream gzipStream = new GZIPOutputStream(byteStream)) {
				gzipStream.write(jsonBytes);
			}
			byte[] compressedData = byteStream.toByteArray();
			
			RequestBody body = RequestBody.create(JSON, compressedData);
			
			Request request = new Request.Builder()
				.url(webhookUrl)
				.post(body)
				.addHeader("Content-Type", "application/json")
				.addHeader("Content-Encoding", "gzip")
				.addHeader("User-Agent", "RuneLite-RevalClan-Plugin")
				.build();

			httpClient.newCall(request).enqueue(new Callback() {
				@Override
				public void onFailure(Call call, IOException e) {
					log.error("Failed to send data to webhook: {}", e.getMessage());
				}

				@Override
				public void onResponse(Call call, Response response) {
					try {
						if (!response.isSuccessful()) {
							log.warn("Webhook returned non-successful status: {}", response.code());
						}
					} finally {
						response.close();
					}
				}
			});
		} catch (IOException e) {
			log.error("Failed to prepare webhook data: {}", e.getMessage());
		} catch (Exception e) {
			log.error("Unexpected error preparing webhook", e);
		}
	}
}


package com.revalclan.util;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.util.*;

/**
 * Manages dynamic event filters fetched from the backend API
 */
@Slf4j
@Singleton
public class EventFilterManager{
	private static final String FILTERS_URL = "https://api.revalosrs.ee/event-filters";
	
	@Inject private OkHttpClient httpClient;
	
	@Inject private Gson gson;
	
	@Getter private EventFilters filters;
	
	/**
	 * Holds all filter configurations
	 */
	@Getter
	public static class EventFilters {
		// Loot filter settings
		@Getter private long lootMinValue = 1_000_000; // 1M default
		@Getter private Set<Integer> lootWhitelist = new HashSet<>();
		@Getter private Set<Integer> lootBlacklist = new HashSet<>(Arrays.asList(526, 995)); // Bones, Coins
		
		// Area entry filter settings
		@Getter private Set<Integer> areaEntryRegions = new HashSet<>(); // Empty by default = no regions trigger
		
		// Detailed kill filter settings
		@Getter private Set<Integer> detailedKillNpcIdWhitelist = new HashSet<>();
		@Getter private Set<Integer> detailedKillNpcIdBlacklist = new HashSet<>();
		
		// Event toggles
		@Getter private boolean lootEnabled = true;
		@Getter private boolean petEnabled = true;
		@Getter private boolean questEnabled = true;
		@Getter private boolean levelEnabled = true;
		@Getter private boolean killCountEnabled = true;
		@Getter private boolean clueEnabled = true;
		@Getter private boolean diaryEnabled = true;
		@Getter private boolean combatAchievementEnabled = true;
		@Getter private boolean collectionEnabled = true;
		@Getter private boolean deathEnabled = true;
		@Getter private boolean detailedKillEnabled = true;
		@Getter private boolean areaEntryEnabled = true;
		@Getter private boolean emoteEnabled = true;
	}
	
	public EventFilterManager() {
		// Initialize with defaults
		filters = new EventFilters();
	}
	
	/**
	 * Fetch filters from the API
	 * @return true if successful, false otherwise
	 */
	public boolean fetchFilters() {
		try {
			Request request = new Request.Builder()
				.url(FILTERS_URL)
				.get()
				.addHeader("User-Agent", "RuneLite-RevalClan-Plugin")
				.build();
			
			try (Response response = httpClient.newCall(request).execute()) {
				if (!response.isSuccessful()) {
					log.warn("Failed to fetch event filters: HTTP {}", response.code());
					return false;
				}
				
				String responseBody = response.body().string();
				JsonObject json = gson.fromJson(responseBody, JsonObject.class);
				
				parseFilters(json);
				
				log.info("✓ Successfully fetched event filters from API");
				return true;
			}
		} catch (IOException e) {
			log.error("Failed to fetch event filters: {}", e.getMessage());
			return false;
		} catch (Exception e) {
			log.error("Unexpected error fetching event filters", e);
			return false;
		}
	}
	
	/**
	 * Fetch filters asynchronously
	 */
	public void fetchFiltersAsync() {
		Request request = new Request.Builder()
			.url(FILTERS_URL)
			.get()
			.addHeader("User-Agent", "RuneLite-RevalClan-Plugin")
			.build();
		
		httpClient.newCall(request).enqueue(new Callback() {
			@Override
			public void onFailure(Call call, IOException e) {
				log.error("Failed to fetch event filters: {}", e.getMessage());
			}

			@Override
			public void onResponse(Call call, Response response) {
				try {
					if (!response.isSuccessful()) {
						log.warn("Failed to fetch event filters: HTTP {}", response.code());
						return;
					}
					
					String responseBody = response.body().string();
					JsonObject json = gson.fromJson(responseBody, JsonObject.class);
					
					parseFilters(json);
					
					log.info("✓ Successfully fetched event filters from API");
				} catch (IOException e) {
					log.error("Failed to parse event filters response: {}", e.getMessage());
				} catch (Exception e) {
					log.error("Unexpected error parsing event filters", e);
				} finally {
					response.close();
				}
			}
		});
	}
	
	/**
	 * Parse the filters JSON response
	 */
	private void parseFilters(JsonObject json) {
		EventFilters newFilters = new EventFilters();
		
		try {
			// Parse loot filters
			if (json.has("loot")) {
				JsonObject loot = json.getAsJsonObject("loot");
				
				if (loot.has("minValue")) {
					newFilters.lootMinValue = loot.get("minValue").getAsLong();
				}
				
				// Clear defaults and only use API values
				newFilters.lootWhitelist.clear();
				if (loot.has("whitelist") && loot.get("whitelist").isJsonArray()) {
					loot.getAsJsonArray("whitelist").forEach(item -> 
						newFilters.lootWhitelist.add(item.getAsInt())
					);
				}
				
				newFilters.lootBlacklist.clear();
				if (loot.has("blacklist") && loot.get("blacklist").isJsonArray()) {
					loot.getAsJsonArray("blacklist").forEach(item -> 
						newFilters.lootBlacklist.add(item.getAsInt())
					);
				}
			}
			
			// Parse area entry filters
			if (json.has("areaEntry")) {
				JsonObject areaEntry = json.getAsJsonObject("areaEntry");
				
				// Clear defaults and only use API values
				newFilters.areaEntryRegions.clear();
				if (areaEntry.has("regions") && areaEntry.get("regions").isJsonArray()) {
					areaEntry.getAsJsonArray("regions").forEach(region -> 
						newFilters.areaEntryRegions.add(region.getAsInt())
					);
				}
			}
			
			// Parse detailed kill filters
			if (json.has("detailedKill")) {
				JsonObject detailedKill = json.getAsJsonObject("detailedKill");
				
				// Clear defaults and only use API values
				newFilters.detailedKillNpcIdWhitelist.clear();
				if (detailedKill.has("npcIdWhitelist") && detailedKill.get("npcIdWhitelist").isJsonArray()) {
					detailedKill.getAsJsonArray("npcIdWhitelist").forEach(id -> 
						newFilters.detailedKillNpcIdWhitelist.add(id.getAsInt())
					);
				}
				
				newFilters.detailedKillNpcIdBlacklist.clear();
				if (detailedKill.has("npcIdBlacklist") && detailedKill.get("npcIdBlacklist").isJsonArray()) {
					detailedKill.getAsJsonArray("npcIdBlacklist").forEach(id -> 
						newFilters.detailedKillNpcIdBlacklist.add(id.getAsInt())
					);
				}
			}
			
			// Parse event toggles
			if (json.has("enabled")) {
				JsonObject enabled = json.getAsJsonObject("enabled");
				
				if (enabled.has("loot")) newFilters.lootEnabled = enabled.get("loot").getAsBoolean();
				if (enabled.has("pet")) newFilters.petEnabled = enabled.get("pet").getAsBoolean();
				if (enabled.has("quest")) newFilters.questEnabled = enabled.get("quest").getAsBoolean();
				if (enabled.has("level")) newFilters.levelEnabled = enabled.get("level").getAsBoolean();
				if (enabled.has("killCount")) newFilters.killCountEnabled = enabled.get("killCount").getAsBoolean();
				if (enabled.has("clue")) newFilters.clueEnabled = enabled.get("clue").getAsBoolean();
				if (enabled.has("diary")) newFilters.diaryEnabled = enabled.get("diary").getAsBoolean();
				if (enabled.has("combatAchievement")) newFilters.combatAchievementEnabled = enabled.get("combatAchievement").getAsBoolean();
				if (enabled.has("collection")) newFilters.collectionEnabled = enabled.get("collection").getAsBoolean();
				if (enabled.has("death")) newFilters.deathEnabled = enabled.get("death").getAsBoolean();
				if (enabled.has("detailedKill")) newFilters.detailedKillEnabled = enabled.get("detailedKill").getAsBoolean();
				if (enabled.has("areaEntry")) newFilters.areaEntryEnabled = enabled.get("areaEntry").getAsBoolean();
				if (enabled.has("emote")) newFilters.emoteEnabled = enabled.get("emote").getAsBoolean();
			}
			
			// Atomically replace filters
			this.filters = newFilters;
		} catch (Exception e) {
			log.error("Error parsing filters JSON", e);
		}
	}
}


package com.revalclan.util;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.clan.ClanChannel;
import net.runelite.api.clan.ClanChannelMember;
import net.runelite.api.clan.ClanRank;

/**
 * Utility class for validating clan membership and rank
 * Used to restrict webhook notifications to specific clan members
 */
@Slf4j
public class ClanValidator {
	/** Required clan name (null or empty to disable clan check) */
	private static final String REQUIRED_CLAN_NAME = "Reval";
	
	/** 
	 * Minimum clan rank required (-1 to 127, where higher = more permissions)
	 */
	private static final ClanRank MINIMUM_CLAN_RANK = new ClanRank(10); // 10 = new member
	
	// ===============================================

	/**
	 * Validate that the player is in the required clan with sufficient rank
	 * @param client The RuneLite client instance
	 * @return true if player passes clan validation (or validation is disabled)
	 */
	public static boolean validateClan(Client client) {
		if (REQUIRED_CLAN_NAME == null || REQUIRED_CLAN_NAME.trim().isEmpty()) {
			return true;
		}

		ClanChannel clanChannel = client.getClanChannel();
		if (clanChannel == null) return false;

		boolean isInTheWrongClan = !REQUIRED_CLAN_NAME.equalsIgnoreCase(clanChannel.getName());
		if (isInTheWrongClan) return false;

		if (MINIMUM_CLAN_RANK == null) return true;

		String playerName = client.getLocalPlayer() != null ? client.getLocalPlayer().getName() : "Unknown";
		ClanChannelMember member = clanChannel.findMember(playerName);		
		if (member == null) return false;

		ClanRank playerRank = member.getRank();
		boolean isBelowMinimumRank = playerRank.getRank() < MINIMUM_CLAN_RANK.getRank();
		if (isBelowMinimumRank) return false;

		return true;
	}
}


package com.revalclan;

import com.revalclan.collectionlog.CollectionLogManager;
import com.revalclan.combatachievements.CombatAchievementManager;
import com.revalclan.diaries.AchievementDiaryManager;
import com.revalclan.player.PlayerManager;
import com.revalclan.quests.QuestManager;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.Map;

/**
 * Collects ALL player data by coordinating various managers
 */
@Slf4j
@Singleton
public class PlayerDataCollector {
	@Inject
	private PlayerManager playerManager;
	
	@Inject
	private QuestManager questManager;
	
	@Inject
	private AchievementDiaryManager achievementDiaryManager;
	
	@Inject
	private CombatAchievementManager combatAchievementManager;

	@Inject
	private CollectionLogManager collectionLogManager;

	/**
	 * Collects all player data and returns it as a map
	 */
	public Map<String, Object> collectAllData() {
		Map<String, Object> data = new HashMap<>();
		
		data.put("player", playerManager.sync());
		data.put("quests", questManager.sync());
		data.put("achievementDiaries", achievementDiaryManager.sync());
		data.put("combatAchievements", combatAchievementManager.sync());
		data.put("collectionLog", collectionLogManager.sync());
		
		return data;
	}
}

package com.revalclan.combatachievements;

import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Represents a Combat Achievement task with all its details
 */
@Data
@NoArgsConstructor
public class CombatAchievementTask {
	private int id;
	private String name;
	private String description;
	private String tier;
	private String type;
	private String boss;
	private int points;
	private boolean completed;
}


package com.revalclan.combatachievements;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.EnumComposition;
import net.runelite.api.StructComposition;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;

/**
 * Manages Combat Achievement task data by reading from game cache (enums/structs)
 */
@Slf4j
@Singleton
public class CombatAchievementManager {
	@Inject private Client client;

	private static final Map<Integer, String> TIER_ENUMS = new LinkedHashMap<>();
	static {
		TIER_ENUMS.put(3981, "Easy");
		TIER_ENUMS.put(3982, "Medium");
		TIER_ENUMS.put(3983, "Hard");
		TIER_ENUMS.put(3984, "Elite");
		TIER_ENUMS.put(3985, "Master");
		TIER_ENUMS.put(3986, "Grandmaster");
	}

	private static final Map<Integer, String> TYPE_MAP = new LinkedHashMap<>();
	static {
		TYPE_MAP.put(1, "Stamina");
		TYPE_MAP.put(2, "Perfection");
		TYPE_MAP.put(3, "Kill Count");
		TYPE_MAP.put(4, "Mechanical");
		TYPE_MAP.put(5, "Restriction");
		TYPE_MAP.put(6, "Speed");
	}

	private static final int BOSS_ENUM_ID = 3971;

	private static final int FIELD_NAME = 1308;
	private static final int FIELD_DESCRIPTION = 1309;
	private static final int FIELD_TASK_ID = 1306;
	private static final int FIELD_TYPE_ID = 1311;
	private static final int FIELD_BOSS_ID = 1312;

	private static final int[] COMPLETION_VARPS = {
		3116,  // CA_TASK_COMPLETED_0
		3117,  // CA_TASK_COMPLETED_1
		3118,  // CA_TASK_COMPLETED_2
		3119,  // CA_TASK_COMPLETED_3
		3120,  // CA_TASK_COMPLETED_4
		3121,  // CA_TASK_COMPLETED_5
		3122,  // CA_TASK_COMPLETED_6
		3123,  // CA_TASK_COMPLETED_7
		3124,  // CA_TASK_COMPLETED_8
		3125,  // CA_TASK_COMPLETED_9
		3126,  // CA_TASK_COMPLETED_10
		3127,  // CA_TASK_COMPLETED_11
		3128,  // CA_TASK_COMPLETED_12
		3387,  // CA_TASK_COMPLETED_13
		3718,  // CA_TASK_COMPLETED_14
		3773,  // CA_TASK_COMPLETED_15
		3774,  // CA_TASK_COMPLETED_16
		4204,  // CA_TASK_COMPLETED_17
		4496,  // CA_TASK_COMPLETED_18
		4721   // CA_TASK_COMPLETED_19
	};

	private final List<CombatAchievementTask> allTasks = new ArrayList<>();

	/**
	 * Sync and get combat achievement data
	 */
	public Map<String, Object> sync() {
		allTasks.clear();
		
		for (Map.Entry<Integer, String> tierEntry : TIER_ENUMS.entrySet()) {
			try {
				EnumComposition tierEnum = client.getEnum(tierEntry.getKey());
				if (tierEnum == null) continue;
				
				for (int structId : tierEnum.getIntVals()) {
					try {
						CombatAchievementTask task = loadTaskFromStruct(structId, tierEntry.getValue());
						if (task != null) allTasks.add(task);
					} catch (Exception ignored) {}
				}
			} catch (Exception ignored) {}
		}
		
		int totalPoints = calculateTotalPoints();
		
		Map<String, Object> data = new HashMap<>();
		data.put("currentTier", calculateCurrentTier(totalPoints));
		data.put("totalPoints", totalPoints);
		data.put("tierProgress", getTierProgress());
		data.put("allTasks", getAllTasksDetailed());
		data.put("totalTasksLoaded", allTasks.size());
		
		return data;
	}

	/**
	 * Loads a single task from a struct
	 */
	private CombatAchievementTask loadTaskFromStruct(int structId, String tierName) {
		StructComposition struct = client.getStructComposition(structId);
		if (struct == null) return null;
		
		String name = struct.getStringValue(FIELD_NAME);
		String description = struct.getStringValue(FIELD_DESCRIPTION);
		int taskId = struct.getIntValue(FIELD_TASK_ID);
		int typeId = struct.getIntValue(FIELD_TYPE_ID);
		String type = TYPE_MAP.getOrDefault(typeId, "Unknown");
		int bossId = struct.getIntValue(FIELD_BOSS_ID);
		String bossName = getBossName(bossId);
		
		boolean completed = isTaskCompleted(taskId);
		
		CombatAchievementTask task = new CombatAchievementTask();
		task.setId(taskId);
		task.setName(name);
		task.setDescription(description);
		task.setTier(tierName);
		task.setType(type);
		task.setBoss(bossName);
		task.setCompleted(completed);
		task.setPoints(getPointsForTier(tierName));
		
		return task;
	}

	/**
	 * Gets boss name from boss enum
	 */
	private String getBossName(int bossId) {
		try {
			EnumComposition bossEnum = client.getEnum(BOSS_ENUM_ID);
			if (bossEnum != null) {
				String name = bossEnum.getStringValue(bossId);
				if (name != null && !name.isEmpty()) return name;
			}
		} catch (Exception ignored) {}
		return "Unknown";
	}

	/**
	 * Checks if a task is completed using VarPlayer
	 */
	private boolean isTaskCompleted(int taskId) {
		if (taskId < 0 || taskId >= COMPLETION_VARPS.length * 32) return false;

		int varpIndex = taskId / 32;
		int bitIndex = taskId % 32;

		if (varpIndex >= COMPLETION_VARPS.length) return false;
		
		try {
			int varpValue = client.getVarpValue(COMPLETION_VARPS[varpIndex]);
			return (varpValue & (1 << bitIndex)) != 0;
		} catch (Exception e) {
			return false;
		}
	}

	/**
	 * Gets points for a tier
	 */
	private int getPointsForTier(String tier) {
		switch (tier.toLowerCase()) {
			case "easy": return 1;
			case "medium": return 2;
			case "hard": return 3;
			case "elite": return 4;
			case "master": return 5;
			case "grandmaster": return 6;
			default: return 1;
		}
	}

	/**
	 * Calculate total points from completed tasks
	 */
	private int calculateTotalPoints() {
		return allTasks.stream()
			.filter(CombatAchievementTask::isCompleted)
			.mapToInt(CombatAchievementTask::getPoints)
			.sum();
	}

	/**
	 * Calculate current tier based on total points
	 */
	private String calculateCurrentTier(int totalPoints) {
		if (totalPoints >= 1550) return "Grandmaster";
		if (totalPoints >= 1265) return "Master";
		if (totalPoints >= 977) return "Elite";
		if (totalPoints >= 683) return "Hard";
		if (totalPoints >= 391) return "Medium";
		if (totalPoints >= 110) return "Easy";
		return "None";
	}

	/**
	 * Get tier progress breakdown
	 */
	private Map<String, Map<String, Integer>> getTierProgress() {
		Map<String, Map<String, Integer>> tierProgress = new LinkedHashMap<>();
		
		for (String tier : TIER_ENUMS.values()) {
			int completed = (int) allTasks.stream()
				.filter(t -> t.getTier().equals(tier) && t.isCompleted())
				.count();
			
			int total = (int) allTasks.stream()
				.filter(t -> t.getTier().equals(tier))
				.count();
			
			Map<String, Integer> tierData = new HashMap<>();
			tierData.put("completed", completed);
			tierData.put("total", total);
			tierProgress.put(tier.toLowerCase(), tierData);
		}
		
		return tierProgress;
	}

	/**
	 * Get all tasks with full details
	 */
	private List<Map<String, Object>> getAllTasksDetailed() {
		List<Map<String, Object>> tasksList = new ArrayList<>();
		
		for (CombatAchievementTask task : allTasks) {
			tasksList.add(Map.of(
				"id", task.getId(),
				"name", task.getName(),
				"description", task.getDescription(),
				"tier", task.getTier(),
				"type", task.getType(),
				"boss", task.getBoss(),
				"points", task.getPoints(),
				"completed", task.isCompleted()
			));
		}
		
		return tasksList;
	}
}
package com.revalclan.notifiers;

import com.revalclan.RevalClanConfig;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Player;
import net.runelite.api.events.MenuOptionClicked;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@Singleton
public class EmoteNotifier extends BaseNotifier {
	@Inject
	private RevalClanConfig config;

	@Override
	public boolean isEnabled() {
		return config.notifyEmote() && filterManager.getFilters().isEmoteEnabled();
	}

	@Override
	protected String getEventType() {
		return "EMOTE";
	}

	public void onMenuOptionClicked(MenuOptionClicked event) {
		if (!isEnabled()) return;

		String menuOption = event.getMenuOption();
		String menuTarget = event.getMenuTarget();

		if (menuOption != null && menuOption.toLowerCase().contains("perform")) {
			Player localPlayer = client.getLocalPlayer();
			if (localPlayer == null) return;

			int regionId = localPlayer.getWorldLocation().getRegionID();
			int x = localPlayer.getWorldLocation().getX();
			int y = localPlayer.getWorldLocation().getY();

			Map<String, Object> emoteData = new HashMap<>();
			emoteData.put("emote", menuTarget);
			emoteData.put("regionId", regionId);
			emoteData.put("x", x);
			emoteData.put("y", y);

			sendNotification(emoteData);
		}
	}
}


/*
 * Portions of this file are derived from or inspired by the Dink plugin
 * Copyright (c) 2022, Jake Barter
 * Copyright (c) 2022, pajlads
 * Licensed under the BSD 2-Clause License
 * See LICENSES/dink-LICENSE.txt for full license text
 */
package com.revalclan.notifiers;

import com.revalclan.RevalClanConfig;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.callback.ClientThread;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j
@Singleton
public class DiaryNotifier extends BaseNotifier {
	/**
	 * CS2 Script IDs for diary completion tracking
	 * @see <a href="https://github.com/Joshua-F/cs2-scripts">CS2 Reference</a>
	 */
	private static final int COMPLETED_TASKS_SCRIPT_ID = 3971;
	private static final int TOTAL_TASKS_SCRIPT_ID = 3980;

	/**
	 * Map of diary varbit IDs to their completion status
	 * Key: varbit ID, Value: completion value (0 = not started, 1 = completed, 2 = completed for Karamja special case)
	 */
	private static final Map<Integer, String> DIARY_VARBITS = createDiaryMap();

	@Inject private RevalClanConfig config;

	@Inject private ClientThread clientThread;

	private final Map<Integer, Integer> diaryCompletionById = new ConcurrentHashMap<>();
	private int initDelayTicks = 0;

	@Override
	public boolean isEnabled() {
		return config.notifyDiary() && filterManager.getFilters().isDiaryEnabled();
	}

	@Override
	protected String getEventType() {
		return "DIARY";
	}

	public void onGameStateChanged(GameStateChanged event) {
		if (event.getGameState() != GameState.LOGGED_IN) {
			reset();
		}
	}

	public void onGameTick() {
		if (client.getGameState() != GameState.LOGGED_IN) return;

		if (initDelayTicks > 0) {
			initDelayTicks--;
			if (initDelayTicks == 0)
			{
				initializeDiaries();
			}
		} else if (diaryCompletionById.isEmpty() && isEnabled()) {
			initDelayTicks = 4;
		}
	}

	public void onVarbitChanged(VarbitChanged event) {
		int id = event.getVarbitId();
		if (id < 0) return;
		
		String diaryInfo = DIARY_VARBITS.get(id);
		if (diaryInfo == null) return;
		if (!isEnabled()) return;

		if (diaryCompletionById.isEmpty()) {
			if (client.getGameState() == GameState.LOGGED_IN && isComplete(id, event.getValue())) return;
			else return;
		}

		int value = event.getValue();
		Integer previous = diaryCompletionById.get(id);

		if (previous == null) {
			reset();
			return;
		}

		if (value < previous) {
			reset();
			return;
		}

		if (value > previous) {
			diaryCompletionById.put(id, value);

			if (isComplete(id, value)) {
				clientThread.invokeLater(() -> {
					handleDiaryCompletion(diaryInfo, id);
					return true;
				});
			}
		}
	}

	private void handleDiaryCompletion(String diaryInfo, int varbitId) {
		client.runScript(COMPLETED_TASKS_SCRIPT_ID);
		int completedTasks = client.getIntStack()[0];

		client.runScript(TOTAL_TASKS_SCRIPT_ID);
		int totalTasks = client.getIntStack()[0];

		int totalDiariesCompleted = getTotalCompleted();

		String[] parts = diaryInfo.split("_");
		String area = parts.length > 0 ? parts[0] : "Unknown";
		String difficulty = parts.length > 1 ? parts[1] : "Unknown";

		Map<String, Object> diaryData = new HashMap<>();
		diaryData.put("area", area);
		diaryData.put("difficulty", difficulty);
		diaryData.put("varbitId", varbitId);
		diaryData.put("completedTasks", completedTasks);
		diaryData.put("totalTasks", totalTasks);
		diaryData.put("totalDiariesCompleted", totalDiariesCompleted);

		sendNotification(diaryData);
	}

	private void initializeDiaries() {
		if (!isEnabled()) return;

		diaryCompletionById.clear();

		for (Integer varbitId : DIARY_VARBITS.keySet()) {
			int value = client.getVarbitValue(varbitId);
			if (value >= 0) {
				diaryCompletionById.put(varbitId, value);
			}
		}
	}

	private int getTotalCompleted() {
		int count = 0;
		for (Map.Entry<Integer, Integer> entry : diaryCompletionById.entrySet()) {
			if (isComplete(entry.getKey(), entry.getValue())) count++;
		}
		return count;
	}

	private static boolean isComplete(int varbitId, int value) {
		if (varbitId == 3578 || varbitId == 3599 || varbitId == 3611) {
			return value > 1;
		}
		return value > 0;
	}

	public void reset() {
		diaryCompletionById.clear();
		initDelayTicks = 0;
	}

	private static Map<Integer, String> createDiaryMap() {
		Map<Integer, String> map = new HashMap<>();
		
		map.put(3577, "Ardougne_Easy");
		map.put(3598, "Ardougne_Medium");
		map.put(3608, "Ardougne_Hard");
		map.put(3630, "Ardougne_Elite");
		
		map.put(3579, "Desert_Easy");
		map.put(3597, "Desert_Medium");
		map.put(3610, "Desert_Hard");
		map.put(3628, "Desert_Elite");
		
		map.put(3580, "Falador_Easy");
		map.put(3596, "Falador_Medium");
		map.put(3612, "Falador_Hard");
		map.put(3632, "Falador_Elite");
		
		map.put(3582, "Fremennik_Easy");
		map.put(3594, "Fremennik_Medium");
		map.put(3615, "Fremennik_Hard");
		map.put(3636, "Fremennik_Elite");
		
		map.put(3583, "Kandarin_Easy");
		map.put(3593, "Kandarin_Medium");
		map.put(3617, "Kandarin_Hard");
		map.put(3638, "Kandarin_Elite");
		
		map.put(3578, "Karamja_Easy");
		map.put(3599, "Karamja_Medium");
		map.put(3611, "Karamja_Hard");
		map.put(3631, "Karamja_Elite");
		
		map.put(3581, "Lumbridge_Easy");
		map.put(3595, "Lumbridge_Medium");
		map.put(3614, "Lumbridge_Hard");
		map.put(3635, "Lumbridge_Elite");
		
		map.put(3584, "Morytania_Easy");
		map.put(3592, "Morytania_Medium");
		map.put(3618, "Morytania_Hard");
		map.put(3639, "Morytania_Elite");
		
		map.put(3576, "Varrock_Easy");
		map.put(3601, "Varrock_Medium");
		map.put(3606, "Varrock_Hard");
		map.put(3627, "Varrock_Elite");
		
		map.put(3585, "Western_Easy");
		map.put(3591, "Western_Medium");
		map.put(3620, "Western_Hard");
		map.put(3641, "Western_Elite");
		
		map.put(3586, "Wilderness_Easy");
		map.put(3600, "Wilderness_Medium");
		map.put(3621, "Wilderness_Hard");
		map.put(3642, "Wilderness_Elite");
		
		map.put(7925, "Kourend_Easy");
		map.put(7926, "Kourend_Medium");
		map.put(7927, "Kourend_Hard");
		map.put(7928, "Kourend_Elite");
		
		return map;
	}
}

/*
 * Portions of this file are derived from or inspired by the Dink plugin
 * Copyright (c) 2022, Jake Barter
 * Copyright (c) 2022, pajlads
 * Licensed under the BSD 2-Clause License
 * See LICENSES/dink-LICENSE.txt for full license text
 */
package com.revalclan.notifiers;

import com.revalclan.RevalClanConfig;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.NPC;
import net.runelite.api.NPCComposition;
import net.runelite.api.Player;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.InteractingChanged;
import net.runelite.client.ui.DrawManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.image.BufferedImage;
import java.lang.ref.WeakReference;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@Singleton
public class DeathNotifier extends BaseNotifier {
	private static final String ATTACK_OPTION = "Attack";
	
	@Inject private RevalClanConfig config;
	
	@Inject private DrawManager drawManager;

	private Actor lastAttacker = null;
	private long lastAttackTime = 0;
	private static final long ATTACK_TIMEOUT_MS = 10000;
	
	/**
	 * Tracks the last Actor our local player interacted with (attacked)
	 * Wrapped in WeakReference to allow garbage collection if actor despawns
	 */
	private WeakReference<Actor> lastTarget = new WeakReference<>(null);

	@Override
	public boolean isEnabled() {
		return config.notifyDeath() && filterManager.getFilters().isDeathEnabled();
	}

	@Override
	protected String getEventType() {
		return "DEATH";
	}

	/**
	 * Track who is attacking the player (inbound interaction)
	 */
	public void onInteractingChanged(InteractingChanged event) {
		if (!isEnabled()) return;

		Actor source = event.getSource();
		Actor target = event.getTarget();

		// Track who is attacking us
		if (target != null && target == client.getLocalPlayer()) {
			lastAttacker = source;
			lastAttackTime = System.currentTimeMillis();
		}
		
		// Track who we are attacking (outbound interaction)
		if (source == client.getLocalPlayer() && target != null && target.getCombatLevel() > 0) {
			lastTarget = new WeakReference<>(target);
		}
	}

	public void onActorDeath(ActorDeath event) {
		if (!isEnabled()) return;

		Actor actor = event.getActor();
		if (actor == client.getLocalPlayer()) {
			handleDeath();
		}
		
		// Clear target reference if our target or we died
		if (actor == client.getLocalPlayer() || actor == lastTarget.get()) {
			lastTarget = new WeakReference<>(null);
		}
	}

	private void handleDeath() {
		Map<String, Object> deathData = new HashMap<>();
		
		// Add equipment worn at death
		deathData.put("equipment", getEquippedItems());
		
		// Identify killer using sophisticated algorithm
		Actor killer = identifyKiller();
		
		if (killer != null) {
			if (killer instanceof NPC) {
				NPC npc = (NPC) killer;
				deathData.put("killedBy", npc.getName());
				deathData.put("killerType", "NPC");
				deathData.put("killerId", npc.getId());
			} else if (killer instanceof Player) {
				Player player = (Player) killer;
				deathData.put("killedBy", player.getName());
				deathData.put("killerType", "PLAYER");
				deathData.put("killerCombatLevel", player.getCombatLevel());
			}
		} else {
			deathData.put("killedBy", "Unknown");
			deathData.put("killerType", "UNKNOWN");
		}
		
		// Capture screenshot of death moment
		captureDeathScreenshot(deathData);
		
		lastAttacker = null;
		lastTarget = new WeakReference<>(null);
	}
	
	/**
	 * Identify who killed the player using multiple strategies:
	 * 1. Check last target (who we attacked)
	 * 2. Check who was attacking us (lastAttacker)
	 * 3. Search through all NPCs interacting with us
	 */
	private Actor identifyKiller() {
		Player localPlayer = client.getLocalPlayer();
		if (localPlayer == null) return null;
		
		// Strategy 1: Check our last target (who we attacked)
		Actor lastTarget = this.lastTarget.get();
		if (isValidKiller(lastTarget, localPlayer)) {
			return lastTarget;
		}
		
		// Strategy 2: Check last attacker (simple fallback)
		if (lastAttacker != null && (System.currentTimeMillis() - lastAttackTime) < ATTACK_TIMEOUT_MS) {
			if (isValidKiller(lastAttacker, localPlayer)) {
				return lastAttacker;
			}
		}
		
		// Strategy 3: Search through all NPCs currently interacting with us
		return client.getTopLevelWorldView().npcs().stream()
			.filter(npc -> npc != null && !npc.isDead())
			.filter(npc -> npc.getInteracting() == localPlayer)
			.filter(npc -> {
				NPCComposition comp = npc.getTransformedComposition();
				return comp != null && comp.isInteractible() && !comp.isFollower() && comp.getCombatLevel() > 0;
			})
			.findFirst()
			.orElse(null);
	}
	
	/**
	 * Check if an actor is a valid killer
	 */
	private boolean isValidKiller(Actor actor, Player localPlayer) {
		if (actor == null || actor.isDead()) return false;
		if (actor.getInteracting() != localPlayer) return false;
		
		if (actor instanceof NPC) {
			NPC npc = (NPC) actor;
			NPCComposition comp = npc.getTransformedComposition();
			if (comp == null || !comp.isInteractible() || comp.isFollower()) return false;
			if (comp.getCombatLevel() <= 0) return false;
			
			// Check if NPC has attack option (is attackable)
			String[] actions = comp.getActions();
			if (actions != null) {
				for (String action : actions) {
					if (ATTACK_OPTION.equals(action)) {
						return true;
					}
				}
			}
			return false;
		}
		
		if (actor instanceof Player) {
			// For now, we'll accept any player
			// In the future, could add wilderness/PvP world checks
			return true;
		}
		
		return false;
	}
	
	/**
	 * Capture a screenshot of the death moment and include it in the notification
	 */
	private void captureDeathScreenshot(Map<String, Object> deathData) {
		try {
			drawManager.requestNextFrameListener(image -> {
				if (image != null) {
					// Convert java.awt.Image to BufferedImage
					BufferedImage bufferedImage;
					if (image instanceof BufferedImage) {
						bufferedImage = (BufferedImage) image;
					} else {
						bufferedImage = new BufferedImage(
							image.getWidth(null),
							image.getHeight(null),
							BufferedImage.TYPE_INT_ARGB
						);
						java.awt.Graphics2D g = bufferedImage.createGraphics();
						g.drawImage(image, 0, 0, null);
						g.dispose();
					}
					
					String base64Image = convertImageToBase64(bufferedImage);
					if (base64Image != null) {
						deathData.put("screenshot", base64Image);
					}
					sendNotification(deathData);
				} else {
					// If screenshot fails, still send notification without it
					sendNotification(deathData);
				}
			});
		} catch (Exception e) {
			log.warn("Failed to capture death screenshot", e);
			// Send notification without screenshot
			sendNotification(deathData);
		}
	}
	
	/**
	 * Convert BufferedImage to base64 string for transmission
	 */
	private String convertImageToBase64(BufferedImage image) {
		try {
			java.io.ByteArrayOutputStream baos = new java.io.ByteArrayOutputStream();
			javax.imageio.ImageIO.write(image, "png", baos);
			byte[] imageBytes = baos.toByteArray();
			return java.util.Base64.getEncoder().encodeToString(imageBytes);
		} catch (Exception e) {
			log.error("Failed to convert image to base64", e);
			return null;
		}
	}

	public void reset() {
		lastAttacker = null;
		lastAttackTime = 0;
		lastTarget = new WeakReference<>(null);
	}
}


package com.revalclan.notifiers;

import com.revalclan.RevalClanConfig;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.NPC;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.events.PlayerLootReceived;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;

@Slf4j
@Singleton
public class LootNotifier extends BaseNotifier
{
	@Inject
	private RevalClanConfig config;

	@Inject
	private ItemManager itemManager;

	@Override
	public boolean isEnabled() {
		return config.notifyLoot() && filterManager.getFilters().isLootEnabled();
	}

	@Override
	protected String getEventType() {
		return "LOOT";
	}

	@Subscribe
	public void onNpcLootReceived(NpcLootReceived event){
		if (!isEnabled()) return;

		NPC npc = event.getNpc();
		Collection<ItemStack> items = event.getItems();

		handleLootDrop(items, npc.getName(), "NPC", npc.getId());
	}

	@Subscribe
	public void onPlayerLootReceived(PlayerLootReceived event) {
		if (!isEnabled()) return;

		String playerName = event.getPlayer().getName();
		Collection<ItemStack> items = event.getItems();

		handleLootDrop(items, playerName, "PLAYER", null);
	}

	private void handleLootDrop(Collection<ItemStack> items, String source, String sourceType, Integer sourceId) {
		// Get dynamic filters
		long minLootValue = filterManager.getFilters().getLootMinValue();
		Set<Integer> whitelistItemIds = filterManager.getFilters().getLootWhitelist();
		Set<Integer> blacklistItemIds = filterManager.getFilters().getLootBlacklist();
		
		List<Map<String, Object>> itemsList = new ArrayList<>();
		long totalGEValue = 0;
		long totalHAValue = 0;
		boolean hasWhitelistedItem = false;
		boolean hasUntradeable = false;

		for (ItemStack item : items) {
			int itemId = item.getId();
			
			// Skip blacklisted items
			if (blacklistItemIds.contains(itemId)) continue;

			int gePrice = itemManager.getItemPrice(itemId);
			int haValue = itemManager.getItemComposition(itemId).getPrice();
			boolean isTradeable = itemManager.getItemComposition(itemId).isTradeable();
			String itemName = itemManager.getItemComposition(itemId).getName();

			Map<String, Object> itemData = new HashMap<>();
			itemData.put("id", itemId);
			itemData.put("name", itemName);
			itemData.put("quantity", item.getQuantity());
			itemData.put("gePrice", gePrice);
			itemData.put("haValue", haValue);
			itemData.put("tradeable", isTradeable);
			itemsList.add(itemData);

			totalGEValue += (long) gePrice * item.getQuantity();
			totalHAValue += (long) haValue * item.getQuantity();

			// Check for special items
			if (whitelistItemIds.contains(itemId)) hasWhitelistedItem = true;
			if (!isTradeable) hasUntradeable = true;
		}
		// 1. Total value >= minLootValue (from API)
		// 2. Contains a whitelisted item (from API)
		// 3. Contains an untradeable item
		boolean shouldNotify = totalGEValue >= minLootValue || hasWhitelistedItem || hasUntradeable;

		if (!shouldNotify) return;

		Map<String, Object> lootData = new HashMap<>();
		lootData.put("source", source);
		lootData.put("sourceType", sourceType);
		if (sourceId != null) {
			lootData.put("sourceId", sourceId);
		}
		lootData.put("totalGEValue", totalGEValue);
		lootData.put("totalHAValue", totalHAValue);
		lootData.put("items", itemsList);

		sendNotification(lootData);
	}
}


package com.revalclan.notifiers;

import com.revalclan.RevalClanConfig;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.Widget;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@Singleton
public class QuestNotifier extends BaseNotifier {
	@Inject private RevalClanConfig config;

	@Override
	public boolean isEnabled() {
		return config.notifyQuest() && filterManager.getFilters().isQuestEnabled();
	}

	@Override
	protected String getEventType() {
		return "QUEST";
	}

	public void onWidgetLoaded(WidgetLoaded event) {
		if (!isEnabled()) return;

		if (event.getGroupId() == InterfaceID.QUESTSCROLL) {
			Widget questTitle = client.getWidget(InterfaceID.Questscroll.QUEST_TITLE);
			if (questTitle != null) {
				String questText = questTitle.getText();
				handleQuestCompletion(questText);
			}
		}
	}

	private void handleQuestCompletion(String questText) {
		// Parse quest name from the widget text
		String questName = parseQuestName(questText);
		if (questName == null) return;

		int questPoints = client.getVarpValue(VarPlayerID.QP);
		int completedQuests = client.getVarbitValue(VarbitID.QUESTS_COMPLETED_COUNT);
		int totalQuests = client.getVarbitValue(VarbitID.QUESTS_TOTAL_COUNT);

		Map<String, Object> questData = new HashMap<>();
		questData.put("questName", questName);
		questData.put("questPoints", questPoints);
		questData.put("completedQuests", completedQuests);
		questData.put("totalQuests", totalQuests);

		sendNotification(questData);
	}

	private String parseQuestName(String questText) {
		if (questText == null) return null;

		String[] lines = questText.split("\n");
		if (lines.length >= 3) {
			String name = lines[2].replace("!", "").trim();
			return name.isEmpty() ? null : name;
		}
		return null;
	}
}


package com.revalclan.notifiers;

import com.revalclan.RevalClanConfig;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
@Singleton
public class PetNotifier extends BaseNotifier {
	private static final Pattern PET_PATTERN = Pattern.compile(
		"You (?:have a funny feeling like you're being followed|feel something weird sneaking into your backpack|have a funny feeling like you would have been followed)\\.?",
		Pattern.CASE_INSENSITIVE
	);

	@Inject private RevalClanConfig config;

	@Override
	public boolean isEnabled() {
		return config.notifyPet() && filterManager.getFilters().isPetEnabled();
	}

	@Override
	protected String getEventType() {
		return "PET";
	}

	public void onChatMessage(String message) {
		if (!isEnabled()) return;

		Matcher matcher = PET_PATTERN.matcher(message);
		if (matcher.find()) {
			handlePetDrop(message);
		}
	}

	private void handlePetDrop(String originalMessage) {
		Map<String, Object> petData = new HashMap<>();
		petData.put("message", originalMessage);
		petData.put("obtained", !originalMessage.contains("would have been"));

		sendNotification(petData);
	}
}


package com.revalclan.notifiers;

import com.revalclan.RevalClanConfig;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Skill;
import net.runelite.api.events.StatChanged;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.Map;

/**
 * Notifies on level ups
 */
@Slf4j
@Singleton
public class LevelNotifier extends BaseNotifier {
	@Inject private RevalClanConfig config;

	private final Map<Skill, Integer> previousLevels = new EnumMap<>(Skill.class);
	private final Map<Skill, Integer> previousXp = new EnumMap<>(Skill.class);

	@Override
	public boolean isEnabled() {
		return config.notifyLevel() && filterManager.getFilters().isLevelEnabled();
	}

	@Override
	protected String getEventType() {
		return "LEVEL";
	}

	public void onStatChanged(StatChanged event) {
		if (!isEnabled()) return;

		Skill skill = event.getSkill();
		int newLevel = event.getLevel();
		int newXp = event.getXp();

		// Initialize if first time seeing this skill
		if (!previousLevels.containsKey(skill)) {
			previousLevels.put(skill, newLevel);
			previousXp.put(skill, newXp);
			return;
		}

		int oldLevel = previousLevels.get(skill);
		int oldXp = previousXp.get(skill);

		// Update tracking
		previousLevels.put(skill, newLevel);
		previousXp.put(skill, newXp);

		// Check for level up
		if (newLevel > oldLevel && newXp > oldXp) {
			handleLevelUp(skill, newLevel, newXp);
		}
	}

	private void handleLevelUp(Skill skill, int level, int xp) {
		int totalLevel = client.getTotalLevel();
		long totalXp = client.getOverallExperience();
		int combatLevel = client.getLocalPlayer() != null ? client.getLocalPlayer().getCombatLevel() : 0;

		Map<String, Object> levelData = new HashMap<>();
		levelData.put("skill", skill.getName());
		levelData.put("level", level);
		levelData.put("experience", xp);
		levelData.put("totalLevel", totalLevel);
		levelData.put("totalExperience", totalXp);
		levelData.put("combatLevel", combatLevel);

		log.info("{} leveled {} to {}", getPlayerName(), skill.getName(), level);

		sendNotification(levelData);
	}

	public void reset() {
		previousLevels.clear();
		previousXp.clear();
	}
}


package com.revalclan.notifiers;

import com.revalclan.RevalClanConfig;
import com.revalclan.util.ClanValidator;
import com.revalclan.util.EventFilterManager;
import com.revalclan.util.WebhookService;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.client.game.ItemManager;

import javax.inject.Inject;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Base class for all notification types (loot, death, pets, etc.)
 */
@Slf4j
public abstract class BaseNotifier {
	@Inject protected Client client;

	@Inject protected WebhookService webhookService;

	@Inject protected RevalClanConfig config;

	@Inject protected EventFilterManager filterManager;
	
	@Inject protected ItemManager itemManager;

	/**
	 * Check if this notifier should be active
	 * @return true if the notifier is enabled and conditions are met
	 */
	public abstract boolean isEnabled();

	/**
	 * Get the event type identifier for this notifier
	 * @return Event type string (e.g., "LOOT", "DEATH", "PET")
	 */
	protected abstract String getEventType();

	/**
	 * Send a notification with the given data
	 * 
	 * @param data The notification data
	 */
	protected void sendNotification(Map<String, Object> data) {
		// Validate clan membership before sending
		if (!ClanValidator.validateClan(client)) return;

		// Add event metadata
		data.put("eventType", getEventType());
		data.put("eventTimestamp", System.currentTimeMillis());
		data.put("accountHash", client.getAccountHash());
		data.put("username", getPlayerName());
		
		// Send webhook
		webhookService.sendDataAsync(data);
	}

	/**
	 * Get the player's name
	 */
	protected String getPlayerName() {
		if (client.getLocalPlayer() != null) return client.getLocalPlayer().getName();
		return "Unknown";
	}
	
	/**
	 * Get player's equipped items
	 */
	protected List<Map<String, Object>> getEquippedItems() {
		List<Map<String, Object>> equipment = new ArrayList<>();
		
		if (client.getLocalPlayer() == null || client.getLocalPlayer().getPlayerComposition() == null) {
			return equipment;
		}
		
		int[] equipped = client.getLocalPlayer().getPlayerComposition().getEquipmentIds();
		if (equipped == null) return equipment;
		
		for (int i = 0; i < equipped.length; i++) {
			int itemId = equipped[i];
			
			// Skip empty slots (ID 0 or -1 means empty)
			if (itemId <= 0) continue;
			
			// ItemComposition IDs are offset by 512 for worn items
			int actualItemId = itemId - 512;
			if (actualItemId <= 0) continue;
			
			Map<String, Object> itemData = new HashMap<>();
			itemData.put("id", actualItemId);
			itemData.put("slot", i);
			
			try {
				ItemComposition itemComp = itemManager.getItemComposition(actualItemId);
				itemData.put("name", itemComp.getName());
			} catch (Exception e) {
				itemData.put("name", "Unknown");
			}
			
			equipment.add(itemData);
		}
		
		return equipment;
	}
}


/*
 * Portions of this file are derived from or inspired by the Dink plugin
 * Copyright (c) 2022, Jake Barter
 * Copyright (c) 2022, pajlads
 * Licensed under the BSD 2-Clause License
 * See LICENSES/dink-LICENSE.txt for full license text
 */
package com.revalclan.notifiers;

import com.revalclan.RevalClanConfig;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
@Singleton
public class CollectionNotifier extends BaseNotifier {
	private static final Pattern COLLECTION_PATTERN = Pattern.compile(
		"New item added to your collection log: (?<item>.+)",
		Pattern.CASE_INSENSITIVE
	);

	@Inject private RevalClanConfig config;

	@Override
	public boolean isEnabled() {
		return config.notifyCollection() && filterManager.getFilters().isCollectionEnabled();
	}

	@Override
	protected String getEventType() {
		return "COLLECTION";
	}

	public void onChatMessage(String message) {
		if (!isEnabled()) return;

		Matcher matcher = COLLECTION_PATTERN.matcher(message);
		if (matcher.find()) {
			String itemName = matcher.group("item");
			handleCollectionItem(itemName);
		}
	}

	private void handleCollectionItem(String itemName) {
		Map<String, Object> collectionData = new HashMap<>();
		collectionData.put("item", itemName);

		sendNotification(collectionData);
	}
}

package com.revalclan.notifiers;

import com.revalclan.RevalClanConfig;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.time.Duration;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Notifies on boss kill counts
 * Portions inspired by Dink plugin (BSD 2-Clause License)
 */
@Slf4j
@Singleton
public class KillCountNotifier extends BaseNotifier {
	// Primary pattern: "Your <boss> kill/chest/completion count is: <count>"
	private static final Pattern PRIMARY_REGEX = Pattern.compile(
		"Your (?<key>.+?)\\s+(?<type>kill|chest|completion|harvest|success|opened)\\s?count is:?\\s*(?<value>[\\d,]+)\\b",
		Pattern.CASE_INSENSITIVE
	);
	
	// Secondary pattern: "Your completed <raid> count is: <count>"
	private static final Pattern SECONDARY_REGEX = Pattern.compile(
		"Your (?:completed|subdued) (?<key>.+) count is: (?<value>[\\d,]+)\\b",
		Pattern.CASE_INSENSITIVE
	);
	
	// Time pattern: "Duration: <time>" or "Time: <time> (Personal best: <pb>)"
	private static final Pattern TIME_REGEX = Pattern.compile(
		"(?:Duration|time|Subdued in):?\\s*(?<time>[\\d:]+(?:\\.\\d+)?)\\.?(?:\\s*\\(new personal best\\))?(?:\\s*Personal best:\\s*(?<pbtime>[\\d:]+(?:\\.\\d+)?))?",
		Pattern.CASE_INSENSITIVE
	);

	@Inject private RevalClanConfig config;
	
	private String pendingBoss = null;
	private Integer pendingCount = null;
	private Duration pendingTime = null;
	private boolean pendingIsPb = false;
	private int badTicks = 0;
	private static final int MAX_BAD_TICKS = 10;

	@Override
	public boolean isEnabled() {
		return config.notifyKillCount() && filterManager.getFilters().isKillCountEnabled();
	}

	@Override
	protected String getEventType() {
		return "KILL_COUNT";
	}

	public void onChatMessage(String message) {
		if (!isEnabled()) return;
		
		// Skip preparation messages
		if (message.startsWith("Preparation")) return;

		// Try to parse boss kill count
		parseBossKillCount(message);
		
		// Try to parse time/duration
		parseTime(message);
	}
	
	/**
	 * Called on game tick to check if we have complete data to send
	 */
	public void onTick() {
		if (pendingBoss != null && pendingCount != null) {
			// We have boss name and count - send notification
			sendKillCountNotification();
			reset();
		} else if (pendingTime != null || pendingBoss != null || pendingCount != null) {
			// We have partial data - wait a bit for the rest
			badTicks++;
			if (badTicks > MAX_BAD_TICKS) {
				// Timeout - reset and give up
				reset();
			}
		}
	}

	private void parseBossKillCount(String message) {
		// Try primary pattern first
		Matcher primary = PRIMARY_REGEX.matcher(message);
		if (primary.find()) {
			String rawBoss = primary.group("key");
			String type = primary.group("type");
			String countStr = primary.group("value").replace(",", "");
			
			String boss = normalizeBossName(rawBoss, type);
			if (boss != null) {
				try {
					int count = Integer.parseInt(countStr);
					pendingBoss = boss;
					pendingCount = count;
					badTicks = 0; // Reset bad tick counter
				} catch (NumberFormatException e) {
					log.debug("Failed to parse kill count: {}", countStr);
				}
			}
			return;
		}
		
		// Try secondary pattern (raids)
		Matcher secondary = SECONDARY_REGEX.matcher(message);
		if (secondary.find()) {
			String rawBoss = secondary.group("key");
			String countStr = secondary.group("value").replace(",", "");
			
			String boss = normalizeRaidName(rawBoss);
			if (boss != null) {
				try {
					int count = Integer.parseInt(countStr);
					pendingBoss = boss;
					pendingCount = count;
					badTicks = 0;
				} catch (NumberFormatException e) {
					log.debug("Failed to parse kill count: {}", countStr);
				}
			}
		}
	}
	
	private void parseTime(String message) {
		// TOB special case: skip wave duration, get challenge time
		String msg = message;
		if (message.startsWith("Wave")) {
			int tobIndex = message.indexOf("Theatre of Blood");
			if (tobIndex > 0) {
				msg = message.substring(tobIndex);
				if (pendingBoss == null) {
					pendingBoss = "Theatre of Blood";
				}
				log.debug("TOB wave message detected - extracted: {}", msg);
			}
		}
		
		Matcher matcher = TIME_REGEX.matcher(msg);
		if (matcher.find()) {
			String timeStr = matcher.group("time");
			String pbTimeStr = matcher.group("pbtime");
			
			log.debug("Time pattern matched - Time: {}, PB Time: {}", timeStr, pbTimeStr);
			
			Duration duration = parseTimeString(timeStr);
			
			if (duration != null) {
				pendingTime = duration;
				pendingIsPb = msg.toLowerCase().contains("(new personal best)") || 
				              msg.toLowerCase().contains("new personal best");
				badTicks = 0;
				log.debug("Time parsed - Duration: {}, isPB: {}", duration, pendingIsPb);
			} else {
				log.debug("Failed to parse time string: {}", timeStr);
			}
		}
	}
	
	/**
	 * Normalize boss names based on message type
	 */
	private String normalizeBossName(String boss, String type) {
		if (boss == null) return null;
		
		switch (type.toLowerCase()) {
			case "chest":
				if ("Barrows".equalsIgnoreCase(boss)) return "Barrows";
				if ("Lunar".equals(boss)) return "Lunar Chest";
				return null;
				
			case "completion":
				if ("Gauntlet".equalsIgnoreCase(boss)) return "Crystalline Hunllef";
				if ("Corrupted Gauntlet".equalsIgnoreCase(boss)) return "Corrupted Hunllef";
				return null;
				
			case "harvest":
				if ("Herbiboar".equalsIgnoreCase(boss)) return "Herbiboar";
				return null;
				
			case "kill":
			case "success":
			case "opened":
				return boss;
				
			default:
				return null;
		}
	}
	
	/**
	 * Normalize raid names
	 */
	private String normalizeRaidName(String raid) {
		if (raid == null) return null;
		
		if ("Wintertodt".equalsIgnoreCase(raid)) return "Wintertodt";
		
		// Handle raid modes (e.g., "Theatre of Blood: Entry Mode")
		int modeSeparator = raid.lastIndexOf(':');
		String raidName = modeSeparator > 0 ? raid.substring(0, modeSeparator).trim() : raid;
		
		if (raidName.equalsIgnoreCase("Theatre of Blood") ||
		    raidName.equalsIgnoreCase("Tombs of Amascut") ||
		    raidName.equalsIgnoreCase("Chambers of Xeric") ||
		    raid.equalsIgnoreCase("Chambers of Xeric Challenge Mode")) {
			return raid; // Return full name with mode
		}
		
		return null;
	}
	
	/**
	 * Parse time string like "1:23" or "1:23.45" into Duration
	 */
	private Duration parseTimeString(String timeStr) {
		if (timeStr == null) return null;
		
		try {
			String[] parts = timeStr.split(":");
			if (parts.length == 2) {
				int minutes = Integer.parseInt(parts[0]);
				double seconds = Double.parseDouble(parts[1]);
				long totalMillis = (minutes * 60 * 1000L) + (long)(seconds * 1000);
				return Duration.ofMillis(totalMillis);
			} else if (parts.length == 3) {
				int hours = Integer.parseInt(parts[0]);
				int minutes = Integer.parseInt(parts[1]);
				double seconds = Double.parseDouble(parts[2]);
				long totalMillis = (hours * 3600 * 1000L) + (minutes * 60 * 1000L) + (long)(seconds * 1000);
				return Duration.ofMillis(totalMillis);
			}
		} catch (NumberFormatException e) {
			log.debug("Failed to parse time: {}", timeStr);
		}
		
		return null;
	}
	
	private void sendKillCountNotification() {
		log.info("Sending KC notification - Boss: {}, Count: {}, Time: {}, isPB: {}", 
			pendingBoss, pendingCount, pendingTime, pendingIsPb);
		
		Map<String, Object> kcData = new HashMap<>();
		kcData.put("boss", pendingBoss);
		kcData.put("killCount", pendingCount);
		
		if (pendingTime != null) {
			kcData.put("time", formatDuration(pendingTime));
			kcData.put("timeSeconds", pendingTime.getSeconds() + (pendingTime.getNano() / 1_000_000_000.0));
			log.debug("Including time data - formatted: {}, seconds: {}", 
				formatDuration(pendingTime), pendingTime.getSeconds() + (pendingTime.getNano() / 1_000_000_000.0));
		}
		
		if (pendingIsPb) {
			kcData.put("personalBest", true);
			log.debug("Marking as personal best");
		}

		sendNotification(kcData);
	}
	
	/**
	 * Format duration as MM:SS or HH:MM:SS
	 */
	private String formatDuration(Duration duration) {
		long totalSeconds = duration.getSeconds();
		long hours = totalSeconds / 3600;
		long minutes = (totalSeconds % 3600) / 60;
		long seconds = totalSeconds % 60;
		long millis = duration.getNano() / 1_000_000;
		
		if (hours > 0) {
			return String.format("%d:%02d:%02d.%d", hours, minutes, seconds, millis / 100);
		} else {
			return String.format("%d:%02d.%d", minutes, seconds, millis / 100);
		}
	}

	public void reset() {
		pendingBoss = null;
		pendingCount = null;
		pendingTime = null;
		pendingIsPb = false;
		badTicks = 0;
	}
}


package com.revalclan.notifiers;

import com.revalclan.RevalClanConfig;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemContainer;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameTick;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;

@Slf4j
@Singleton
public class AreaEntryNotifier extends BaseNotifier
{
	@Inject
	private RevalClanConfig config;

	private int lastRegionId = -1;

	@Override
	public boolean isEnabled() {
		return config.notifyAreaEntry() && filterManager.getFilters().isAreaEntryEnabled();
	}

	@Override
	protected String getEventType() {
		return "AREA_ENTRY";
	}

	public void onGameTick(GameTick event)
	{
		if (!isEnabled()) return;
		if (client.getLocalPlayer() == null) return;

		WorldPoint location = client.getLocalPlayer().getWorldLocation();
		int regionId = location.getRegionID();

		if (regionId != lastRegionId && lastRegionId != -1) {
			// Only trigger if this region is in the filter list (empty = no regions trigger)
			if (filterManager.getFilters().getAreaEntryRegions().contains(regionId)) {
				handleAreaEntry(regionId, location);
			}
		}

		lastRegionId = regionId;
	}

	private void handleAreaEntry(int regionId, WorldPoint location) {
		Map<String, Object> areaData = new HashMap<>();
		areaData.put("regionId", regionId);
		areaData.put("x", location.getX());
		areaData.put("y", location.getY());
		areaData.put("plane", location.getPlane());
		
		areaData.put("equipment", getEquippedItems());
		
		areaData.put("inventory", getInventoryData());

		sendNotification(areaData);
	}

	/**
	 * Get player's inventory data
	 */
	private List<Map<String, Object>> getInventoryData() {
		List<Map<String, Object>> inventory = new ArrayList<>();
		
		ItemContainer container = client.getItemContainer(93); // 93 or 149
		if (container == null) return inventory;
		
		Item[] items = container.getItems();
		if (items == null) return inventory;
		
		for (int i = 0; i < items.length; i++) {
			Item item = items[i];
			
			// Skip empty slots
			if (item.getId() <= 0 || item.getQuantity() <= 0) continue;
			
			Map<String, Object> itemData = new HashMap<>();
			itemData.put("id", item.getId());
			itemData.put("quantity", item.getQuantity());
			itemData.put("slot", i);
			
			try {
				ItemComposition itemComp = itemManager.getItemComposition(item.getId());
				if (itemComp != null) {
					itemData.put("name", itemComp.getName());
				} else {
					itemData.put("name", "Unknown");
				}
			} catch (Exception e) {
				itemData.put("name", "Unknown");
			}
			
			inventory.add(itemData);
		}
		
		return inventory;
	}

	public void reset() {
		lastRegionId = -1;
	}
}


package com.revalclan.notifiers;

import com.revalclan.RevalClanConfig;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
@Singleton
public class CombatAchievementNotifier extends BaseNotifier {
	private static final Pattern CA_PATTERN = Pattern.compile(
		"Congratulations, you've completed an? (?<tier>\\w+) combat task: (?<task>.+)\\.",
		Pattern.CASE_INSENSITIVE
	);

	@Inject private RevalClanConfig config;

	@Override 
	public boolean isEnabled() {
		return config.notifyCombatAchievement() && filterManager.getFilters().isCombatAchievementEnabled();
	}

	@Override
	protected String getEventType() {
		return "COMBAT_ACHIEVEMENT";
	}

	public void onChatMessage(String message) {
		if (!isEnabled()) return;

		Matcher matcher = CA_PATTERN.matcher(message);
		if (matcher.find()) {
			String tier = matcher.group("tier");
			String task = matcher.group("task");

			handleCombatAchievement(tier, task);
		}
	}

	private void handleCombatAchievement(String tier, String task) {
		task = task.replaceAll("\\s+\\(\\d+ points?\\)$", "");

		Map<String, Object> caData = new HashMap<>();
		caData.put("tier", tier);
		caData.put("task", task);

		sendNotification(caData);
	}
}


package com.revalclan.notifiers;

import com.revalclan.RevalClanConfig;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.Hitsplat;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.client.game.ItemManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j
@Singleton
public class DetailedKillNotifier extends BaseNotifier {
	@Inject private RevalClanConfig config;

	@Inject private ItemManager itemManager;

	private final Map<NPC, KillData> activeKills = new ConcurrentHashMap<>();
	
	private int previousSpecEnergy = 100;
	private int specTicksRemaining = 0;
	private String specWeaponName = null;

	@Override
	public boolean isEnabled() {
		return config.notifyDetailedKill() && filterManager.getFilters().isDetailedKillEnabled();
	}

	@Override
	protected String getEventType() {
		return "DETAILED_KILL";
	}

	public void onGameTick(GameTick event) {
		if (!isEnabled()) return;

		int currentSpecEnergy = client.getVarpValue(300);
		
		if (currentSpecEnergy < previousSpecEnergy) {
			Player localPlayer = client.getLocalPlayer();
			if (localPlayer != null) {
				int weaponId = localPlayer.getPlayerComposition().getEquipmentId(net.runelite.api.kit.KitType.WEAPON);
				specWeaponName = weaponId > 0 ? itemManager.getItemComposition(weaponId).getName() : "Unarmed";
				specTicksRemaining = 3;
			}
		} else if (specTicksRemaining > 0) {
			specTicksRemaining--;
			if (specTicksRemaining == 0) {
				specWeaponName = null;
			}
		}
		
		previousSpecEnergy = currentSpecEnergy;
	}

	public void onHitsplatApplied(HitsplatApplied event) {
		if (!isEnabled()) return;

		Actor actor = event.getActor();
		if (!(actor instanceof NPC)) return;

		Hitsplat hitsplat = event.getHitsplat();
		if (!hitsplat.isMine()) return;

		NPC npc = (NPC) actor;
		int damage = hitsplat.getAmount();

		Player localPlayer = client.getLocalPlayer();
		if (localPlayer == null) return;

		int weaponId = localPlayer.getPlayerComposition().getEquipmentId(net.runelite.api.kit.KitType.WEAPON);
		String weaponName = weaponId > 0 ? itemManager.getItemComposition(weaponId).getName() : "Unarmed";

		boolean isSpec = specTicksRemaining > 0 && weaponName.equals(specWeaponName);
		KillData data = activeKills.computeIfAbsent(npc, k -> new KillData(npc.getName(), npc.getId()));
		data.addHit(damage, weaponName, isSpec);
	}

	public void onActorDeath(ActorDeath event) {
		if (!isEnabled()) return;

		Actor actor = event.getActor();
		if (!(actor instanceof NPC)) return;

		NPC npc = (NPC) actor;
		KillData data = activeKills.remove(npc);

		if (data != null && data.totalDamage > 0) {
			handleDetailedKill(data);
		}
	}

	private void handleDetailedKill(KillData data) {
		// Apply filters
		if (!shouldNotifyKill(data.npcId)) {
			return;
		}
		
		Map<String, Object> killData = new HashMap<>();
		killData.put("npcName", data.npcName);
		killData.put("npcId", data.npcId);
		killData.put("totalDamage", data.totalDamage);
		killData.put("hitCount", data.hitCount);
		killData.put("specialAttacks", data.specialAttackCount);
		killData.put("lastHitWeapon", data.lastHitWeapon);
		killData.put("lastHitDamage", data.lastHitDamage);
		killData.put("lastHitWasSpec", data.lastHitWasSpec);
		killData.put("weaponsUsed", new ArrayList<>(data.weaponsUsed.keySet()));
		killData.put("damageByWeapon", data.weaponsUsed);

		sendNotification(killData);
	}
	
	/**
	 * Check if we should notify for this NPC based on filters
	 * Filter priority:
	 * 1. If whitelist has entries and NPC is in whitelist -> ALLOW
	 * 2. If NPC is in blacklist -> DENY
	 * 3. If whitelist is empty -> ALLOW (default behavior)
	 * 4. Otherwise -> DENY
	 */
	private boolean shouldNotifyKill(int npcId) {
		var filters = filterManager.getFilters();
		
		// Check ID whitelist first (highest priority)
		boolean hasIdWhitelist = !filters.getDetailedKillNpcIdWhitelist().isEmpty();
		if (hasIdWhitelist && filters.getDetailedKillNpcIdWhitelist().contains(npcId)) {
			return true; // Explicitly whitelisted by ID
		}
		
		// Check ID blacklist
		if (filters.getDetailedKillNpcIdBlacklist().contains(npcId)) {
			return false; // Explicitly blacklisted by ID
		}
		
		// If whitelist exists and NPC wasn't in it, deny
		if (hasIdWhitelist) {
			return false;
		}
		
		// No filters configured, allow all
		return true;
	}

	public void reset() {
		activeKills.clear();
		previousSpecEnergy = 100;
		specTicksRemaining = 0;
		specWeaponName = null;
	}

	private static class KillData {
		final String npcName;
		final int npcId;
		int totalDamage = 0;
		int hitCount = 0;
		int specialAttackCount = 0;
		String lastHitWeapon = "Unknown";
		int lastHitDamage = 0;
		boolean lastHitWasSpec = false;
		final Map<String, Integer> weaponsUsed = new HashMap<>();

		KillData(String npcName, int npcId) {
			this.npcName = npcName;
			this.npcId = npcId;
		}

		void addHit(int damage, String weapon, boolean isSpec) {
			totalDamage += damage;
			hitCount++;
			lastHitWeapon = weapon;
			lastHitDamage = damage;
			lastHitWasSpec = isSpec;

			if (isSpec) {
				specialAttackCount++;
			}

			weaponsUsed.merge(weapon, damage, Integer::sum);
		}
	}
}


/*
 * Portions of this file are derived from or inspired by the Dink plugin
 * Copyright (c) 2022, Jake Barter
 * Copyright (c) 2022, pajlads
 * Licensed under the BSD 2-Clause License
 * See LICENSES/dink-LICENSE.txt for full license text
 */
package com.revalclan.notifiers;

import com.revalclan.RevalClanConfig;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.game.ItemManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
@Singleton
public class ClueNotifier extends BaseNotifier {
	private static final Pattern CLUE_PATTERN = Pattern.compile(
		"You have completed (?<count>\\d+) (?<tier>\\w+) Treasure Trails?\\.",
		Pattern.CASE_INSENSITIVE
	);

	@Inject private RevalClanConfig config;

	@Inject private ItemManager itemManager;

	private int clueCount = -1;
	private String clueTier = "";

	@Override
	public boolean isEnabled() {
		return config.notifyClue() && filterManager.getFilters().isClueEnabled();
	}

	@Override
	protected String getEventType() {
		return "CLUE";
	}

	public void onChatMessage(String message) {
		if (!isEnabled()) return;

		Matcher matcher = CLUE_PATTERN.matcher(message);
		if (matcher.find()) {
			clueCount = Integer.parseInt(matcher.group("count"));
			clueTier = matcher.group("tier");
		}
	}

	public void onWidgetLoaded(WidgetLoaded event) {
		if (!isEnabled()) return;

		if (event.getGroupId() == InterfaceID.TRAIL_REWARDSCREEN && !clueTier.isEmpty()) {
			Widget clueWidget = client.getWidget(InterfaceID.TrailRewardscreen.ITEMS);
			if (clueWidget != null) {
				Widget[] children = clueWidget.getChildren();
				if (children == null) return;

				List<Map<String, Object>> items = new ArrayList<>();
				long totalValue = 0;

				for (Widget child : children) {
					if (child == null) continue;

					int quantity = child.getItemQuantity();
					int itemId = child.getItemId();
					if (itemId > -1 && quantity > 0) {
						int price = itemManager.getItemPrice(itemId);
						String name = itemManager.getItemComposition(itemId).getName();

						Map<String, Object> item = new HashMap<>();
						item.put("id", itemId);
						item.put("name", name);
						item.put("quantity", quantity);
						item.put("price", price);
						items.add(item);

						totalValue += (long) price * quantity;
					}
				}

				handleClueCompletion(items, totalValue);
			}
		}
	}

	private void handleClueCompletion(List<Map<String, Object>> items, long totalValue) {
		Map<String, Object> clueData = new HashMap<>();
		clueData.put("tier", clueTier);
		clueData.put("count", clueCount);
		clueData.put("totalValue", totalValue);
		clueData.put("items", items);

		sendNotification(clueData);

		clueCount = -1;
		clueTier = "";
	}

	public void reset() {
		clueCount = -1;
		clueTier = "";
	}
}


package com.revalclan.diaries;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.Map;

/**
 * Manages achievement diary progress
 */
@Slf4j
@Singleton
public class AchievementDiaryManager {
	@Inject
	private Client client;

	private final Map<String, Map<String, Integer>> diaryVarbits = new HashMap<>();

	public AchievementDiaryManager() {
		initializeDiaryVarbits();
	}

	/**
	 * Initialize all diary varbit mappings
	 */
	private void initializeDiaryVarbits() {
		Map<String, Integer> ardougne = new HashMap<>();
		ardougne.put("easy", 4458);
		ardougne.put("medium", 4459);
		ardougne.put("hard", 4460);
		ardougne.put("elite", 4461);
		diaryVarbits.put("Ardougne", ardougne);
		
		Map<String, Integer> desert = new HashMap<>();
		desert.put("easy", 4483);
		desert.put("medium", 4484);
		desert.put("hard", 4485);
		desert.put("elite", 4486);
		diaryVarbits.put("Desert", desert);

		Map<String, Integer> falador = new HashMap<>();
		falador.put("easy", 4462);
		falador.put("medium", 4463);
		falador.put("hard", 4464);
		falador.put("elite", 4465);
		diaryVarbits.put("Falador", falador);

		Map<String, Integer> fremennik = new HashMap<>();
		fremennik.put("easy", 4491);
		fremennik.put("medium", 4492);
		fremennik.put("hard", 4493);
		fremennik.put("elite", 4494);
		diaryVarbits.put("Fremennik", fremennik);

		Map<String, Integer> kandarin = new HashMap<>();
		kandarin.put("easy", 4475);
		kandarin.put("medium", 4476);
		kandarin.put("hard", 4477);
		kandarin.put("elite", 4478);
		diaryVarbits.put("Kandarin", kandarin);

		Map<String, Integer> karamja = new HashMap<>();
		karamja.put("easy", 3578);
		karamja.put("medium", 3599);
		karamja.put("hard", 3611);
		karamja.put("elite", 4566);
		diaryVarbits.put("Karamja", karamja);
		
		Map<String, Integer> kourend = new HashMap<>();
		kourend.put("easy", 7925);
		kourend.put("medium", 7926);
		kourend.put("hard", 7927);
		kourend.put("elite", 7928);
		diaryVarbits.put("Kourend", kourend);
		
		Map<String, Integer> lumbridge = new HashMap<>();
		lumbridge.put("easy", 4495);
		lumbridge.put("medium", 4496);
		lumbridge.put("hard", 4497);
		lumbridge.put("elite", 4498);
		diaryVarbits.put("Lumbridge", lumbridge);

		Map<String, Integer> morytania = new HashMap<>();
		morytania.put("easy", 4487);
		morytania.put("medium", 4488);
		morytania.put("hard", 4489);
		morytania.put("elite", 4490);
		diaryVarbits.put("Morytania", morytania);

		Map<String, Integer> varrock = new HashMap<>();
		varrock.put("easy", 4479);
		varrock.put("medium", 4480);
		varrock.put("hard", 4481);
		varrock.put("elite", 4482);
		diaryVarbits.put("Varrock", varrock);
		
		Map<String, Integer> western = new HashMap<>();
		western.put("easy", 4471);
		western.put("medium", 4472);
		western.put("hard", 4473);
		western.put("elite", 4474);
		diaryVarbits.put("Western", western);
		
		Map<String, Integer> wilderness = new HashMap<>();
		wilderness.put("easy", 4466);
		wilderness.put("medium", 4467);
		wilderness.put("hard", 4468);
		wilderness.put("elite", 4469);
		diaryVarbits.put("Wilderness", wilderness);
	}

	/**
	 * Sync and get achievement diary progress data
	 */
	public Map<String, Object> sync() {
		Map<String, Object> diaryData = new HashMap<>();
		Map<String, Map<String, Boolean>> diaryProgress = new HashMap<>();
		
		int totalCompleted = 0;
		
		for (Map.Entry<String, Map<String, Integer>> regionEntry : diaryVarbits.entrySet()) {
			String region = regionEntry.getKey();
			Map<String, Boolean> tierProgress = new HashMap<>();
			
			for (Map.Entry<String, Integer> tierEntry : regionEntry.getValue().entrySet()) {
				String tier = tierEntry.getKey();
				int varbitId = tierEntry.getValue();
				int value = client.getVarbitValue(varbitId);
				
				// Karamja Easy (3578), Medium (3599), Hard (3611) special case
				// 0 = not started, 1 = started, 2 = completed
				boolean isComplete;
				if (varbitId == 3578 || varbitId == 3599 || varbitId == 3611) {
					isComplete = value > 1;
				} else {
					isComplete = value > 0;
				}
				
				tierProgress.put(tier, isComplete);
				
				if (isComplete) {
					totalCompleted++;
				}
			}
			
			diaryProgress.put(region, tierProgress);
		}
		
		diaryData.put("progress", diaryProgress);
		diaryData.put("totalCompleted", totalCompleted);
		diaryData.put("totalDiaries", 48); // 12 regions * 4 tiers
		
		return diaryData;
	}
}


package com.revalclan.player;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.Map;

/**
 * Manages player metadata and statistics
 */
@Slf4j
@Singleton
public class PlayerManager {
	@Inject private Client client;

	/**
	 * Sync and get player metadata
	 */
	public Map<String, Object> sync() {
		Map<String, Object> metadata = new HashMap<>();
		
		if (client.getLocalPlayer() != null) {
			metadata.put("username", client.getLocalPlayer().getName());
			metadata.put("combatLevel", client.getLocalPlayer().getCombatLevel());
		} else {
			metadata.put("username", "Unknown");
			metadata.put("combatLevel", 0);
		}
		
		metadata.put("accountHash", client.getAccountHash());
		metadata.put("totalLevel", client.getTotalLevel());
		metadata.put("totalExperience", client.getOverallExperience());
		
		return metadata;
	}
}



package com.revalclan.collectionlog;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Represents a collection log item that the player has obtained
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ObtainedCollectionItem {
	private int id;
	private String name;
	private int count;

	public ObtainedCollectionItem(int id, int count) {
		this.id = id;
		this.count = count;
	}
}


/*
 * Portions of this file are derived from or inspired by the TempleOSRS plugin
 * Copyright (c) 2022, SMaloney2017
 * Licensed under the BSD 2-Clause License
 * See LICENSES/templeOSRS-LICENSE.txt for full license text
 */
package com.revalclan.collectionlog;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

/**
 * All available category groups (i.e. tabs) mapped to their in-game struct IDs
 */
@RequiredArgsConstructor
public enum CollectionLogCategoryGroup {
	BOSSES(471),
	RAIDS(472),
	CLUES(473),
	MINIGAMES(474),
	OTHER(475);

	@Getter private final int structId;
	
	/**
	 * Get the category name (capitalized) from struct ID
	 * @param structId The struct ID to lookup
	 * @return The category name with first letter capitalized, or "Unknown" if not found
	 */
	public static String getNameFromStructId(int structId) {
		for (CollectionLogCategoryGroup group : values()) {
			if (group.structId == structId) {
				String name = group.name().toLowerCase();
				return name.substring(0, 1).toUpperCase() + name.substring(1);
			}
		}

		return "Unknown";
	}
}

/*
 * Portions of this file are derived from or inspired by the TempleOSRS plugin
 * Copyright (c) 2022, SMaloney2017
 * Licensed under the BSD 2-Clause License
 * See LICENSES/templeOSRS-LICENSE.txt for full license text
 */
package com.revalclan.collectionlog;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.FontID;
import net.runelite.api.MenuAction;
import net.runelite.api.SpriteID;
import net.runelite.api.annotations.Component;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetPositionMode;
import net.runelite.api.widgets.WidgetTextAlignment;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;

/**
 * Adds a "Reval" sync button to the collection log interface
 * Based on Temple OSRS implementation
 */
@Slf4j
@Singleton
public class CollectionLogSyncButton {
	private static final int COLLECTION_LOG_SETUP = 7797;
	
	// Sprite IDs for button background (inactive state)
	private static final int[] SPRITE_IDS_INACTIVE = {
		SpriteID.DIALOG_BACKGROUND,
		SpriteID.WORLD_MAP_BUTTON_METAL_CORNER_TOP_LEFT,
		SpriteID.WORLD_MAP_BUTTON_METAL_CORNER_TOP_RIGHT,
		SpriteID.WORLD_MAP_BUTTON_METAL_CORNER_BOTTOM_LEFT,
		SpriteID.WORLD_MAP_BUTTON_METAL_CORNER_BOTTOM_RIGHT,
		SpriteID.WORLD_MAP_BUTTON_EDGE_LEFT,
		SpriteID.WORLD_MAP_BUTTON_EDGE_TOP,
		SpriteID.WORLD_MAP_BUTTON_EDGE_RIGHT,
		SpriteID.WORLD_MAP_BUTTON_EDGE_BOTTOM,
	};

	// Sprite IDs for button background (hovered/active state)
	private static final int[] SPRITE_IDS_ACTIVE = {
		SpriteID.RESIZEABLE_MODE_SIDE_PANEL_BACKGROUND,
		SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_TOP_LEFT_HOVERED,
		SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_TOP_RIGHT_HOVERED,
		SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_BOTTOM_LEFT_HOVERED,
		SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_BOTTOM_RIGHT_HOVERED,
		SpriteID.EQUIPMENT_BUTTON_EDGE_LEFT_HOVERED,
		SpriteID.EQUIPMENT_BUTTON_EDGE_TOP_HOVERED,
		SpriteID.EQUIPMENT_BUTTON_EDGE_RIGHT_HOVERED,
		SpriteID.EQUIPMENT_BUTTON_EDGE_BOTTOM_HOVERED,
	};

	private static final int FONT_COLOUR_INACTIVE = 0xd6d6d6;
	private static final int FONT_COLOUR_ACTIVE = 0xffffff;
	private static final int CLOSE_BUTTON_OFFSET = 28;
	private static final int BUTTON_WIDTH = 60;
	private static final int BUTTON_OFFSET = CLOSE_BUTTON_OFFSET + 5;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private EventBus eventBus;

	@Inject
	private CollectionLogManager collectionLogManager;

	public void startUp() {
		eventBus.register(this);
		clientThread.invokeLater(() -> tryAddButton(this::onButtonClick));
	}

	public void shutDown() {
		eventBus.unregister(this);
		clientThread.invokeLater(this::removeButton);
	}

	void tryAddButton(Runnable onClick) {
		for (Screen screen : Screen.values()) {
			addButton(screen, onClick);
		}
	}

	@Subscribe
	public void onScriptPostFired(ScriptPostFired scriptPostFired) {
		if (scriptPostFired.getScriptId() == COLLECTION_LOG_SETUP) {
			removeButton();
			addButton(Screen.COLLECTION_LOG, this::onButtonClick);
		}
	}

	void onButtonClick() {
		collectionLogManager.clearObtainedItems();

		client.menuAction(-1, 40697932, MenuAction.CC_OP, 1, -1, "Search", null);
		client.runScript(2240);
		
		client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Reval: Capturing collection log data...", "");
	}

	void addButton(Screen screen, Runnable onClick) {
		Widget parent = client.getWidget(screen.getParentId());
		Widget searchButton = client.getWidget(screen.getSearchButtonId());
		Widget collectionLogContainer = client.getWidget(screen.getCollectionLogContainer());
		Widget[] containerChildren;
		Widget draggableTopbar;
		
		if (parent == null || searchButton == null || collectionLogContainer == null ||
			(containerChildren = collectionLogContainer.getChildren()) == null ||
			(draggableTopbar = containerChildren[0]) == null) {
			return;
		}

		final int w = BUTTON_WIDTH;
		final int h = searchButton.getOriginalHeight();
		final int x = BUTTON_OFFSET;
		final int y = searchButton.getOriginalY();
		final int cornerDim = 9;

		final Widget[] spriteWidgets = new Widget[10];

		spriteWidgets[0] = parent.createChild(-1, WidgetType.GRAPHIC)
			.setSpriteId(SPRITE_IDS_INACTIVE[0])
			.setPos(x, y)
			.setSize(w, h)
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setYPositionMode(searchButton.getYPositionMode());

		spriteWidgets[1] = parent.createChild(-1, WidgetType.GRAPHIC)
			.setSpriteId(SPRITE_IDS_INACTIVE[1])
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setSize(cornerDim, cornerDim)
			.setPos(x + (w - cornerDim), y);
		spriteWidgets[2] = parent.createChild(-1, WidgetType.GRAPHIC)
			.setSpriteId(SPRITE_IDS_INACTIVE[2])
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setSize(cornerDim, cornerDim)
			.setPos(x, y);
		spriteWidgets[3] = parent.createChild(-1, WidgetType.GRAPHIC)
			.setSpriteId(SPRITE_IDS_INACTIVE[3])
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setSize(cornerDim, cornerDim)
			.setPos(x + (w - cornerDim), y + h - cornerDim);
		spriteWidgets[4] = parent.createChild(-1, WidgetType.GRAPHIC)
			.setSpriteId(SPRITE_IDS_INACTIVE[4])
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setSize(cornerDim, cornerDim)
			.setPos(x, y + h - cornerDim);

		int sideWidth = 9;
		int sideHeight = 4;
		spriteWidgets[5] = parent.createChild(-1, WidgetType.GRAPHIC)
			.setSpriteId(SPRITE_IDS_INACTIVE[5])
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setSize(sideWidth, sideHeight)
			.setPos(x + (w - sideWidth), y + cornerDim);
		spriteWidgets[7] = parent.createChild(-1, WidgetType.GRAPHIC)
			.setSpriteId(SPRITE_IDS_INACTIVE[7])
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setSize(sideWidth, sideHeight)
			.setPos(x, y + cornerDim);

		int topWidth = 42;
		int topHeight = 9;
		spriteWidgets[6] = parent.createChild(-1, WidgetType.GRAPHIC)
			.setSpriteId(SPRITE_IDS_INACTIVE[6])
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setSize(topWidth, topHeight)
			.setPos(x + cornerDim, y);
		spriteWidgets[8] = parent.createChild(-1, WidgetType.GRAPHIC)
			.setSpriteId(SPRITE_IDS_INACTIVE[8])
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setSize(topWidth, topHeight)
			.setPos(x + cornerDim, y + h - topHeight);

		spriteWidgets[9] = parent.createChild(-1, WidgetType.GRAPHIC)
			.setSpriteId(SpriteID.UNKNOWN_WHITE_REFRESH_ARROWS)
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setSize(13, 13)
			.setPos(x + 6, y + 4);

		for (int i = 0; i < 10; i++) {
			spriteWidgets[i].revalidate();
		}

		final Widget text = parent.createChild(-1, WidgetType.TEXT)
			.setText("Reval")
			.setTextColor(FONT_COLOUR_INACTIVE)
			.setFontId(FontID.PLAIN_11)
			.setTextShadowed(true)
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setXTextAlignment(WidgetTextAlignment.LEFT)
			.setYTextAlignment(WidgetTextAlignment.CENTER)
			.setPos(x - 8, y)
			.setSize(w, h)
			.setYPositionMode(searchButton.getYPositionMode());
		text.revalidate();

		text.setHasListener(true);
		text.setOnMouseOverListener((JavaScriptCallback) ev -> {
			for (int i = 0; i <= 8; i++) {
				spriteWidgets[i].setSpriteId(SPRITE_IDS_ACTIVE[i]);
			}
			text.setTextColor(FONT_COLOUR_ACTIVE);
		});
		text.setOnMouseLeaveListener((JavaScriptCallback) ev -> {
			for (int i = 0; i <= 8; i++) {
				spriteWidgets[i].setSpriteId(SPRITE_IDS_INACTIVE[i]);
			}
			text.setTextColor(FONT_COLOUR_INACTIVE);
		});

		text.setAction(0, "Capture collection log data");
		text.setOnOpListener((JavaScriptCallback) ev -> onClick.run());

		draggableTopbar.setOriginalWidth(draggableTopbar.getOriginalWidth() - (w + (x - CLOSE_BUTTON_OFFSET)));
		draggableTopbar.revalidate();

		parent.revalidate();
	}

	void removeButton() {
		for (Screen screen : Screen.values()) {
			Widget parent = client.getWidget(screen.getParentId());
			if (parent != null) {
				parent.deleteAllChildren();
				parent.revalidate();
			}
		}
	}

	@Getter
	@RequiredArgsConstructor
	enum Screen {
		COLLECTION_LOG(40697944, 40697932, ComponentID.COLLECTION_LOG_CONTAINER); // parentId, searchButtonId, collectionLogContainer

		@Getter(onMethod_ = @Component)
		private final int parentId;

		@Getter(onMethod_ = @Component)
		private final int searchButtonId;

		@Getter(onMethod_ = @Component)
		private final int collectionLogContainer;
	}
}


/*
 * Portions of this file are derived from or inspired by the TempleOSRS plugin
 * Copyright (c) 2022, SMaloney2017
 * Licensed under the BSD 2-Clause License
 * See LICENSES/templeOSRS-LICENSE.txt for full license text
 */
package com.revalclan.collectionlog;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.EnumComposition;
import net.runelite.api.StructComposition;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;
import java.util.regex.Pattern;

/**
 * Manages collection log data by reading directly from the game cache
 * Based on Temple OSRS implementation
 */
@Slf4j
@Singleton
public class CollectionLogManager {
	@Inject private Client client;

	/**
	 * Maps in-game category struct IDs to the list of items they contain
	 */
	@Getter private final Map<Integer, Set<Integer>> categoryItemMap = new HashMap<>();

	/**
	 * Maps slugified category names to their in-game struct ID
	 */
	@Getter private final Map<String, Integer> categoryStructIdMap = new HashMap<>();

	/**
	 * Maps top level tabs to their containing categories
	 */
	@Getter private final Map<Integer, Set<String>> categoryTabSlugs = new LinkedHashMap<>();

	/**
	 * List of all items in the collection log
	 */
	@Getter private final Set<Integer> allCollectionLogItems = new HashSet<>();

	/**
	 * Set of items the player has obtained (populated when collection log is opened)
	 */
	@Getter private final Set<ObtainedCollectionItem> obtainedItems = new HashSet<>();

	/**
	 * Maps category slugs to their KC varbit/varp IDs
	 */
	private final Map<String, KCSource> categoryKCMap = new HashMap<>();
	
	/**
	 * Maps category slugs to additional KC sources (for multi-KC tracking)
	 */
	private final Map<String, Map<String, KCSource>> additionalKCMap = new HashMap<>();
	
	/**
	 * Maps subcategories to their KC calculation rules (for derived KCs like original boss = combined - awakened)
	 * Format: subcategorySlug -> (resultKCName -> [combinedKCName, subtractKCName])
	 */
	private final Map<String, Map<String, String[]>> derivedKCMap = new HashMap<>();
	
	/**
	 * Maps subcategories to their summed KC rules (for derived KCs that are sums of multiple sources)
	 * Format: subcategorySlug -> (resultKCName -> [source1Name, source2Name, ...])
	 */
	private final Map<String, Map<String, String[]>> summedKCMap = new HashMap<>();

	/**
	 * Helper class to store KC source information
	 */
	private static class KCSource {
		final boolean isVarbit;
		final int id;

		KCSource(boolean isVarbit, int id) {
			this.isVarbit = isVarbit;
			this.id = id;
		}
	}
	
	/**
	 * Fluent builder for configuring KC tracking for a subcategory
	 */
	private class KCBuilder {
		private final String subcategory;
		
		KCBuilder(String subcategory) {
			this.subcategory = subcategory;
		}
		
		KCBuilder primaryKC(boolean isVarbit, int id) {
			categoryKCMap.put(subcategory, new KCSource(isVarbit, id));
			return this;
		}
		
		KCBuilder primaryKC(int varPlayerId) {
			return primaryKC(false, varPlayerId);
		}
		
		KCBuilder additionalKC(String kcName, boolean isVarbit, int id) {
			additionalKCMap.computeIfAbsent(subcategory, k -> new HashMap<>())
				.put(kcName, new KCSource(isVarbit, id));
			return this;
		}

		KCBuilder additionalKC(String kcName, int varPlayerId) {
			return additionalKC(kcName, false, varPlayerId);
		}
		

		KCBuilder derivedKC(String resultKCName, String combinedKCName, String subtractKCName) {
			derivedKCMap.computeIfAbsent(subcategory, k -> new HashMap<>())
				.put(resultKCName, new String[]{combinedKCName, subtractKCName});
			return this;
		}
		
		KCBuilder summedKC(String resultKCName, String... sourceKCNames) {
			summedKCMap.computeIfAbsent(subcategory, k -> new HashMap<>())
				.put(resultKCName, sourceKCNames);
			return this;
		}
		
		/**
		 * Convenience method for boss pairs (original + awakened)
		 * Sets up: primary KC, combined KC, awakened KC, and derived original KC
		 */
		KCBuilder bossPair(int combinedVarPlayerId, String originalName, int awakenedVarPlayerId, String awakenedName) {
			return primaryKC(combinedVarPlayerId)
				.additionalKC(originalName + "_combined_kc", combinedVarPlayerId)
				.additionalKC(awakenedName + "_kc", awakenedVarPlayerId)
				.derivedKC(originalName + "_kc", originalName + "_combined_kc", awakenedName + "_kc");
		}
	}
	
	/**
	 * Start building KC configuration for a subcategory
	 */
	private KCBuilder kc(String subcategory) {
		return new KCBuilder(subcategory);
	}

	/**
	 * Initialize the KC mapping for collection log categories
	 */
	private void initializeKCMap() {
		// ===== BOSSES =====
		kc("abyssal_sire").primaryKC(1526);
		kc("alchemical_hydra").primaryKC(2074);
		kc("amoxliatl").primaryKC(4403);
		kc("araxxor").primaryKC(4260);
		kc("barrows_chests").primaryKC(1502);
		kc("bryophyta").primaryKC(1733);
		
		kc("callisto_and_artio").bossPair(1510, "callisto", 3761, "artio");
		
		kc("venenatis_and_spindel")
			.primaryKC(1511)
			.additionalKC("venenatis_kc", 1511)
			.additionalKC("spindel_kc", 3762);
		
		kc("vetion_and_calvarion").bossPair(1512, "vetion", 3763, "calvarion");
		
		kc("cerberus").primaryKC(1525);
		kc("chaos_elemental").primaryKC(1513);
		kc("chaos_fanatic").primaryKC(1519);
		kc("commander_zilyana").primaryKC(1505);
		kc("corporeal_beast").primaryKC(1517);
		kc("crazy_archaeologist").primaryKC(1521);
		
		kc("dagannoth_kings")
			.primaryKC(1507)
			.additionalKC("dagannoth_prime_kc", 1507)
			.additionalKC("dagannoth_rex_kc", 1508)
			.additionalKC("dagannoth_supreme_kc", 1509);
		
		kc("deranged_archaeologist").primaryKC(1661);
		
		kc("doom_of_mokhaiotl")
			.primaryKC(4182)
			.additionalKC("level_1_completions", 4808)
			.additionalKC("level_2_completions", 4809)
			.additionalKC("level_3_completions", 4810)
			.additionalKC("level_4_completions", 4811)
			.additionalKC("level_5_completions", 4812)
			.additionalKC("level_6_completions", 4813)
			.additionalKC("level_7_completions", 4814)
			.additionalKC("level_8_completions", 4815)
			.additionalKC("level_8_plus_completions", 4816)
			.summedKC("total_completions", 
				"level_1_completions", "level_2_completions", "level_3_completions", "level_4_completions",
				"level_5_completions", "level_6_completions", "level_7_completions", "level_8_completions", "level_8_plus_completions")
			.additionalKC("deepest_delves", 4806);
		
		kc("duke_sucellus").primaryKC(3967);
		kc("the_fight_caves").primaryKC(1522);
		
		kc("fortis_colosseum")
			.primaryKC(4131)
			.additionalKC("colosseum_glory", 4132);
		
		kc("the_gauntlet")
			.primaryKC(2353)
			.additionalKC("corrupted_gauntlet_kc", 2354);
		
		kc("general_graardor").primaryKC(1504);
		kc("giant_mole").primaryKC(1515);
		kc("grotesque_guardians").primaryKC(1669);
		kc("hespori").primaryKC(2075);
		kc("the_hueycoatl").primaryKC(4404);
		kc("the_inferno").primaryKC(1585);
		kc("kalphite_queen").primaryKC(1516);
		kc("king_black_dragon").primaryKC(1514);
		kc("kraken").primaryKC(1523);
		kc("kreearra").primaryKC(1503);
		kc("kril_tsutsaroth").primaryKC(1506);
		kc("the_leviathan").primaryKC(3968);
		
		kc("moons_of_peril")
			.primaryKC(4186)
			.additionalKC("eclipse_moon_kc", 4148)
			.additionalKC("blue_moon_kc", 4149)
			.additionalKC("blood_moon_kc", 4150);
		
		kc("mimic").primaryKC(2221);
		kc("nex").primaryKC(3269);
		kc("the_nightmare").primaryKC(2664);
		kc("phosanis_nightmare").primaryKC(2671);
		kc("obor").primaryKC(1529);
		kc("phantom_muspah").primaryKC(3752);
		kc("royal_titans").primaryKC(4648);
		kc("sarachnis").primaryKC(2233);
		kc("scorpia").primaryKC(1520);
		kc("scurrius").primaryKC(4079);
		kc("skotizo").primaryKC(1527);
		
		kc("tempoross")
			.primaryKC(2934)
			.additionalKC("tempoross_rewards", true, 11936);
		
		kc("thermonuclear_smoke_devil").primaryKC(1524);
		kc("vardorvis").primaryKC(3970);
		kc("vorkath").primaryKC(1691);
		kc("the_whisperer").primaryKC(3969);
		
		kc("wintertodt")
			.primaryKC(1528)
			.additionalKC("wintertodt_rewards", 1941);
		
		kc("yama").primaryKC(4701);
		kc("zalcano").primaryKC(2352);
		kc("zulrah").primaryKC(1518);

		kc("chambers_of_xeric")
			.primaryKC(1532)
			.additionalKC("challenge_mode", 1735);
		
		kc("theatre_of_blood")
			.primaryKC(1748)
			.additionalKC("hard_mode", 3057);
		
		kc("tombs_of_amascut")
			.primaryKC(3646)
			.additionalKC("entry_mode", 3645)
			.additionalKC("expert_mode", 3647);

		// ===== CLUES =====
		kc("beginner_treasure_trails").primaryKC(true, 11996);
		kc("easy_treasure_trails").primaryKC(true, 11997);
		kc("medium_treasure_trails").primaryKC(true, 11998);
		kc("hard_treasure_trails").primaryKC(true, 11999);
		kc("elite_treasure_trails").primaryKC(true, 12000);
		kc("master_treasure_trails").primaryKC(true, 12001);
		kc("hard_treasure_trails_rare").primaryKC(true, 11999);
		kc("elite_treasure_trails_rare").primaryKC(true, 12000);
		kc("master_treasure_trails_rare").primaryKC(true, 12001);

		// ===== MINIGAMES =====
		kc("barbarian_assault").primaryKC(1605);

		kc("guardians_of_the_rift")
			.primaryKC(3397)
			.additionalKC("rifts_closed", 3397);
		
		kc("hallowed_sepulchre").primaryKC(2936);
		
		kc("last_man_standing")
			.primaryKC(2396)
			.additionalKC("lms_wins", 2397)
			.additionalKC("lms_kills", 2398);
		
		kc("mastering_mixology").primaryKC(4480);
		
		kc("soul_wars")
			.primaryKC(2871)
			.additionalKC("total_kills", 2872)
			.additionalKC("total_deaths", 2873)
			.additionalKC("total_games", 2874)
			.additionalKC("total_wins", 2875)
			.additionalKC("zeal_tokens", 2876);


		// ===== OTHER =====
		kc("gloughs_experiments")
			.primaryKC(1685)
			.additionalKC("demonic_gorillas_kc", 1685)
			.additionalKC("tortured_gorillas_kc", 4321);

		kc("tormented_demons").primaryKC(4240);
	}

	/**
	 * Parse the game cache to extract all collection log structure
	 */
	public void parseCacheForCollectionLog() {
		if (client.getIndexConfig() == null) {
			return;
		}

		initializeKCMap();
		categoryItemMap.clear();
		categoryStructIdMap.clear();
		categoryTabSlugs.clear();
		allCollectionLogItems.clear();

		try {
			Pattern specialCharPattern = Pattern.compile("['()]");
			EnumComposition replacements = client.getEnum(3721);
			int[] topLevelTabStructIds = client.getEnum(2102).getIntVals();

			for (int topLevelTabStructIndex : topLevelTabStructIds) {
				StructComposition topLevelTabStruct = client.getStructComposition(topLevelTabStructIndex);
				int[] subtabStructIndices = client.getEnum(topLevelTabStruct.getIntValue(683)).getIntVals();
				Set<String> categorySlugSet = new LinkedHashSet<>();

				for (int subtabStructIndex : subtabStructIndices) {
					StructComposition subtabStruct = client.getStructComposition(subtabStructIndex);
					int[] clogItems = client.getEnum(subtabStruct.getIntValue(690)).getIntVals();
					String categoryName = subtabStruct.getStringValue(689);

					String slug = specialCharPattern.matcher(categoryName.toLowerCase().replaceAll(" ", "_")).replaceAll("");
					Set<Integer> itemSet = new LinkedHashSet<>();

					for (int itemId : clogItems) {
						int replacementId = replacements.getIntValue(itemId);
						itemSet.add(replacementId == -1 ? itemId : replacementId);
					}

					allCollectionLogItems.addAll(itemSet);
					categoryItemMap.put(subtabStructIndex, itemSet);
					categoryStructIdMap.put(slug, subtabStructIndex);
					categorySlugSet.add(slug);
				}

				categoryTabSlugs.put(topLevelTabStructIndex, categorySlugSet);
			}
		} catch (Exception e) {
			log.error("Error parsing collection log cache", e);
		}
	}

	/**
	 * Called when collection log opens - tracks which items the player has obtained
	 */
	public void onCollectionLogItemObtained(int itemId, int itemCount, String itemName) {
		obtainedItems.add(new ObtainedCollectionItem(itemId, itemName, itemCount));
	}

	/**
	 * Sync and get collection log data grouped by category (Category > Subcategory > Items)
	 */
	public Map<String, Object> sync() {
		Map<String, Object> data = new HashMap<>();
		data.put("totalItems", allCollectionLogItems.size());
		
		// Get obtained items count
		if (!obtainedItems.isEmpty()) {
			data.put("obtainedItems", obtainedItems.size());
			data.put("dataSource", "collection_log_opened");
		} else {
			try {
				data.put("obtainedItems", client.getVarpValue(2943));
				data.put("dataSource", "varbit_2943");
			} catch (Exception e) {
				data.put("obtainedItems", 0);
				data.put("dataSource", "unavailable");
			}
		}

		// Map obtained items for quick lookup
		Map<Integer, ObtainedCollectionItem> obtainedItemsMap = new HashMap<>();
		for (ObtainedCollectionItem item : obtainedItems) {
			obtainedItemsMap.put(item.getId(), item);
		}

		// Build hierarchical structure: Category > Subcategory > Items
		Map<String, Map<String, Map<String, Object>>> categoriesData = new LinkedHashMap<>();

		for (Map.Entry<Integer, Set<String>> tabEntry : categoryTabSlugs.entrySet()) {
			String categoryName = CollectionLogCategoryGroup.getNameFromStructId(tabEntry.getKey());
			Map<String, Map<String, Object>> subcategoriesData = new LinkedHashMap<>();

			for (String subcategorySlug : tabEntry.getValue()) {
				Set<Integer> categoryItems = categoryItemMap.get(categoryStructIdMap.get(subcategorySlug));
				if (categoryItems == null) continue;

				Map<String, Object> subcategoryData = buildSubcategoryData(subcategorySlug, categoryItems, obtainedItemsMap);
				subcategoriesData.put(subcategorySlug, subcategoryData);
			}

			categoriesData.put(categoryName, subcategoriesData);
		}

		data.put("categories", categoriesData);
		return data;
	}

	/**
	 * Build subcategory data including items and KC tracking
	 */
	private Map<String, Object> buildSubcategoryData(String subcategorySlug, Set<Integer> categoryItems, 
			Map<Integer, ObtainedCollectionItem> obtainedItemsMap) {
		Map<String, Object> subcategoryData = new HashMap<>();
		List<Map<String, Object>> itemsList = new ArrayList<>();
		int obtainedCount = 0;

		// Build items list
		for (Integer itemId : categoryItems) {
			Map<String, Object> itemData = new HashMap<>();
			itemData.put("id", itemId);
			
			ObtainedCollectionItem obtainedItem = obtainedItemsMap.get(itemId);
			if (obtainedItem != null) {
				itemData.put("name", obtainedItem.getName());
				itemData.put("quantity", obtainedItem.getCount());
				itemData.put("obtained", true);
				obtainedCount++;
			} else {
				try {
					itemData.put("name", client.getItemDefinition(itemId).getName());
				} catch (Exception e) {
					itemData.put("name", "Unknown");
				}
				itemData.put("quantity", 0);
				itemData.put("obtained", false);
			}
			
			itemsList.add(itemData);
		}

		subcategoryData.put("total", categoryItems.size());
		subcategoryData.put("obtained", obtainedCount);
		subcategoryData.put("items", itemsList);

		// Add primary KC
		addPrimaryKC(subcategorySlug, subcategoryData);
		
		// Add additional KCs (including derived and summed)
		addAdditionalKCs(subcategorySlug, subcategoryData);

		return subcategoryData;
	}

	/**
	 * Add primary KC to subcategory data
	 */
	private void addPrimaryKC(String subcategorySlug, Map<String, Object> subcategoryData) {
		KCSource kcSource = categoryKCMap.get(subcategorySlug);
		if (kcSource != null) {
			try {
				int kc = kcSource.isVarbit ? client.getVarbitValue(kcSource.id) : client.getVarpValue(kcSource.id);
				subcategoryData.put("kc", kc);
			} catch (Exception e) {
				subcategoryData.put("kc", 0);
			}
		} else {
			subcategoryData.put("kc", 0);
		}
	}

	/**
	 * Add additional KCs including derived and summed calculations
	 */
	private void addAdditionalKCs(String subcategorySlug, Map<String, Object> subcategoryData) {
		Map<String, KCSource> additionalKCs = additionalKCMap.get(subcategorySlug);
		if (additionalKCs == null || additionalKCs.isEmpty()) return;

		Map<String, Integer> kcValues = new HashMap<>();
		
		// Fetch all KC values
		for (Map.Entry<String, KCSource> entry : additionalKCs.entrySet()) {
			try {
				KCSource source = entry.getValue();
				int value = source.isVarbit ? client.getVarbitValue(source.id) : client.getVarpValue(source.id);
				kcValues.put(entry.getKey(), value);
			} catch (Exception e) {
				kcValues.put(entry.getKey(), 0);
			}
		}
		
		// Process derived KCs (subtraction: original = combined - awakened)
		Map<String, String[]> derivedKCs = derivedKCMap.get(subcategorySlug);
		if (derivedKCs != null) {
			for (Map.Entry<String, String[]> entry : derivedKCs.entrySet()) {
				String[] calc = entry.getValue();
				int result = kcValues.getOrDefault(calc[0], 0) - kcValues.getOrDefault(calc[1], 0);
				kcValues.put(entry.getKey(), result);
			}
		}
		
		// Process summed KCs (addition: total = sum of all sources)
		Map<String, String[]> summedKCs = summedKCMap.get(subcategorySlug);
		if (summedKCs != null) {
			for (Map.Entry<String, String[]> entry : summedKCs.entrySet()) {
				int sum = 0;
				for (String sourceKCName : entry.getValue()) {
					sum += kcValues.getOrDefault(sourceKCName, 0);
				}
				kcValues.put(entry.getKey(), sum);
			}
		}
		
		// Add all KC values to subcategory data (exclude intermediate _combined_kc values)
		for (Map.Entry<String, Integer> entry : kcValues.entrySet()) {
			if (!entry.getKey().endsWith("_combined_kc")) {
				subcategoryData.put(entry.getKey(), entry.getValue());
			}
		}
	}

	/**
	 * Clear obtained items (for re-syncing)
	 */
	public void clearObtainedItems()
	{
		obtainedItems.clear();
	}
}


package com.revalclan;

import com.revalclan.collectionlog.CollectionLogManager;
import com.revalclan.collectionlog.CollectionLogSyncButton;
import com.revalclan.notifiers.*;
import com.revalclan.util.ClanValidator;
import com.revalclan.util.EventFilterManager;
import com.revalclan.util.WebhookService;
import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.InteractingChanged;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.StatChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;

import java.lang.reflect.Array;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Slf4j
@PluginDescriptor(
	name = "Reval Clan"
)
public class RevalClanPlugin extends Plugin {
	@Inject private Client client;

	@Inject	private PlayerDataCollector dataCollector;

	@Inject	private CollectionLogManager collectionLogManager;

	@Inject	private CollectionLogSyncButton syncButton;

	@Inject	private WebhookService webhookService;

	@Inject	private LootNotifier lootNotifier;

	@Inject	private PetNotifier petNotifier;

	@Inject	private QuestNotifier questNotifier;

	@Inject	private LevelNotifier levelNotifier;

	@Inject	private KillCountNotifier killCountNotifier;

	@Inject	private ClueNotifier clueNotifier;

	@Inject	private DiaryNotifier diaryNotifier;

	@Inject	private CombatAchievementNotifier combatAchievementNotifier;

	@Inject	private CollectionNotifier collectionNotifier;

	@Inject	private DeathNotifier deathNotifier;

	@Inject	private DetailedKillNotifier detailedKillNotifier;

	@Inject	private AreaEntryNotifier areaEntryNotifier;

	@Inject	private EmoteNotifier emoteNotifier;

	@Inject	private EventBus eventBus;

	@Inject	private ClientThread clientThread;

	@Inject	private ItemManager itemManager;

	@Inject	private EventFilterManager eventFilterManager;

	private boolean wasLoggedIn = false;

	@Override
	protected void startUp() throws Exception {
		log.info("Reval Clan plugin started!");
		wasLoggedIn = false;

		clientThread.invoke(() -> {
			if (client.getIndexConfig() == null || client.getGameState().ordinal() < GameState.LOGIN_SCREEN.ordinal()) {
				return false;
			}

			collectionLogManager.parseCacheForCollectionLog();
			return true;
		});

		syncButton.startUp();
		
		eventBus.register(lootNotifier);
	}

	@Override
	protected void shutDown() throws Exception {
		log.info("Reval Clan plugin stopped!");
		collectionLogManager.clearObtainedItems();
		syncButton.shutDown();
		
		eventBus.unregister(lootNotifier);
		
		levelNotifier.reset();
		clueNotifier.reset();
		killCountNotifier.reset();
		detailedKillNotifier.reset();
		areaEntryNotifier.reset();
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged) {
		diaryNotifier.onGameStateChanged(gameStateChanged);

		if (gameStateChanged.getGameState() == GameState.LOGGED_IN) {
			wasLoggedIn = true;

			collectionLogManager.clearObtainedItems();
			
			// Fetch dynamic event filters from API on login
			eventFilterManager.fetchFiltersAsync();
		} else if (gameStateChanged.getGameState() == GameState.LOGIN_SCREEN) {
			if (wasLoggedIn) {
				log.info("Player logged out, collecting data...");
				
				Map<String, Object> data = dataCollector.collectAllData();
				
				data.put("eventType", "SYNC");
				data.put("eventTimestamp", System.currentTimeMillis());
				
			if (ClanValidator.validateClan(client)) {
				log.info("Sending data to webhook...");
				// Log only top-level keys and value types
				Map<String, String> dataSummary = new HashMap<>();
				data.forEach((key, value) -> {
					if (value == null) {
						dataSummary.put(key, "null");
					} else if (value instanceof Map) {
						dataSummary.put(key, "Map[" + ((Map<?, ?>) value).size() + " entries]");
					} else if (value instanceof List) {
						dataSummary.put(key, "List[" + ((List<?>) value).size() + " items]");
					} else if (value.getClass().isArray()) {
						dataSummary.put(key, "Array[" + Array.getLength(value) + " items]");
					} else {
						dataSummary.put(key, String.valueOf(value));
					}
				});
				log.info("Data summary: {}", dataSummary);
				webhookService.sendDataAsync(data);
			}
				
			wasLoggedIn = false;
			}
		}
	}

	@Subscribe
	public void onGameTick(GameTick gameTick) {
		areaEntryNotifier.onGameTick(gameTick);
		
		detailedKillNotifier.onGameTick(gameTick);
		
		killCountNotifier.onTick();
		
		diaryNotifier.onGameTick();
	}

	/**
	 * Handles collection log script events to track obtained items
	 * Script 4100 fires when collection log opens and for each item
	 */
	@Subscribe
	public void onScriptPreFired(ScriptPreFired preFired) {
		if (preFired.getScriptId() == 4100) {
			try {
				Object[] args = preFired.getScriptEvent().getArguments();
				
				if (args == null || args.length < 3) {
					log.warn("Script 4100 fired with insufficient arguments: {}", args != null ? args.length : "null");
					return;
				}
				
				int itemId = (int) args[1];
				int itemCount = (int) args[2];
				String itemName = itemManager.getItemComposition(itemId).getName();

				collectionLogManager.onCollectionLogItemObtained(itemId, itemCount, itemName);
			} catch (Exception e) {
				log.error("Error capturing collection log item", e);
			}
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage event) {
		String message = event.getMessage();
		
		if (message.toLowerCase().startsWith("::testreval")) {
			handleTestCommand();
			return;
		}
		
		// Only process game messages, not player chat
		// This prevents fake notifications from players typing game messages
		net.runelite.api.ChatMessageType type = event.getType();
		if (type == net.runelite.api.ChatMessageType.GAMEMESSAGE || 
		    type == net.runelite.api.ChatMessageType.SPAM ||
		    type == net.runelite.api.ChatMessageType.ENGINE) {
			
			// Strip HTML color tags from the message before processing
			String cleanMessage = message.replaceAll("<col=[0-9a-fA-F]+>", "").replaceAll("</col>", "");
			
			petNotifier.onChatMessage(cleanMessage);
			killCountNotifier.onChatMessage(cleanMessage);
			clueNotifier.onChatMessage(cleanMessage);
			combatAchievementNotifier.onChatMessage(cleanMessage);
			collectionNotifier.onChatMessage(cleanMessage);
		}
	}

	/**
	 * Handles the ::testreval command to test webhook functionality
	 */
	private void handleTestCommand() {
		if (!ClanValidator.validateClan(client)) return;

		Map<String, Object> testData = new java.util.HashMap<>();
		testData.put("eventType", "TEST");
		testData.put("eventTimestamp", System.currentTimeMillis());
		testData.put("player", client.getLocalPlayer() != null ? client.getLocalPlayer().getName() : "Unknown");
		testData.put("message", "Test webhook from Reval Clan plugin");
		testData.put("command", "::testreval");

		webhookService.sendDataAsync(testData);
	}

	@Subscribe
	public void onStatChanged(StatChanged event) {
		levelNotifier.onStatChanged(event);
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event) {
		questNotifier.onWidgetLoaded(event);
		clueNotifier.onWidgetLoaded(event);
	}

	@Subscribe
	public void onActorDeath(ActorDeath event) {
		deathNotifier.onActorDeath(event);
		detailedKillNotifier.onActorDeath(event);
	}

	@Subscribe
	public void onHitsplatApplied(HitsplatApplied event) {
		detailedKillNotifier.onHitsplatApplied(event);
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event) {
		emoteNotifier.onMenuOptionClicked(event);
	}

	@Subscribe
	public void onInteractingChanged(InteractingChanged event) {
		deathNotifier.onInteractingChanged(event);
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event) {
		diaryNotifier.onVarbitChanged(event);
	}

	@Provides
	RevalClanConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(RevalClanConfig.class);
	}
}



package com.revalclan;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("revalclan")
public interface RevalClanConfig extends Config {
	@ConfigSection(
		name = "Event Notifications",
		description = "Toggle individual event types",
		position = 1
	)
	String eventsSection = "eventsSection";

	// Event type toggles
	@ConfigItem(
		keyName = "notifyLoot",
		name = "Loot Drops",
		description = "Send notifications for valuable loot drops",
		section = eventsSection,
		position = 1
	)
	default boolean notifyLoot() {
		return true;
	}

	@ConfigItem(
		keyName = "notifyPet",
		name = "Pet Drops",
		description = "Send notifications when you receive a pet",
		section = eventsSection,
		position = 2
	)
	default boolean notifyPet() {
		return true;
	}

	@ConfigItem(
		keyName = "notifyQuest",
		name = "Quest Completions",
		description = "Send notifications when you complete a quest",
		section = eventsSection,
		position = 3
	)
	default boolean notifyQuest() {
		return true;
	}

	@ConfigItem(
		keyName = "notifyLevel",
		name = "Level Ups",
		description = "Send notifications when you level up",
		section = eventsSection,
		position = 4
	)
	default boolean notifyLevel() {
		return true;
	}

	@ConfigItem(
		keyName = "notifyKillCount",
		name = "Kill Counts",
		description = "Send notifications for boss kill counts",
		section = eventsSection,
		position = 5
	)
	default boolean notifyKillCount() {
		return true;
	}

	@ConfigItem(
		keyName = "notifyClue",
		name = "Clue Scrolls",
		description = "Send notifications when you complete a clue scroll",
		section = eventsSection,
		position = 6
	)
	default boolean notifyClue() {
		return true;
	}

	@ConfigItem(
		keyName = "notifyDiary",
		name = "Achievement Diaries",
		description = "Send notifications when you complete an achievement diary",
		section = eventsSection,
		position = 7
	)
	default boolean notifyDiary() {
		return true;
	}

	@ConfigItem(
		keyName = "notifyCombatAchievement",
		name = "Combat Achievements",
		description = "Send notifications when you complete a combat achievement",
		section = eventsSection,
		position = 8
	)
	default boolean notifyCombatAchievement() {
		return true;
	}

	@ConfigItem(
		keyName = "notifyCollection",
		name = "Collection Log",
		description = "Send notifications when you add items to collection log",
		section = eventsSection,
		position = 9
	)
	default boolean notifyCollection() {
		return true;
	}

	@ConfigItem(
		keyName = "notifyDeath",
		name = "Player Deaths",
		description = "Send notifications when you die",
		section = eventsSection,
		position = 10
	)
	default boolean notifyDeath() {
		return true;
	}

	@ConfigItem(
		keyName = "deathIncludeScreenshot",
		name = "Death Screenshots",
		description = "Include a screenshot with death notifications",
		section = eventsSection,
		position = 11
	)
	default boolean deathIncludeScreenshot() {
		return true;
	}

	@ConfigItem(
		keyName = "notifyDetailedKill",
		name = "Detailed Kills",
		description = "Send detailed kill tracking (damage, weapons, specs)",
		section = eventsSection,
		position = 12
	)
	default boolean notifyDetailedKill() {
		return true;
	}

	@ConfigItem(
		keyName = "notifyAreaEntry",
		name = "Area Entry",
		description = "Send notifications when entering specific regions",
		section = eventsSection,
		position = 13
	)
	default boolean notifyAreaEntry() {
		return true;
	}

	@ConfigItem(
		keyName = "notifyEmote",
		name = "Emotes",
		description = "Send notifications when performing emotes",
		section = eventsSection,
		position = 14
	)
	default boolean notifyEmote() {
		return true;
	}
}

package com.revalclan;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class RevalClanPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(RevalClanPlugin.class);
		RuneLite.main(args);
	}
}



