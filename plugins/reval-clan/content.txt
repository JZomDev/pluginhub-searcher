package com.revalclan.quests;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Quest;
import net.runelite.api.QuestState;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.Map;

/**
 * Manages quest completion data
 */
@Slf4j
@Singleton
public class QuestManager {
	@Inject private Client client;

	/**
	 * Sync and get quest completion data
	 */
	public Map<String, Object> sync() {
		Map<String, Object> questData = new HashMap<>();
		Map<String, String> questStates = new HashMap<>();
		
		for (Quest quest : Quest.values()) {
			QuestState state = quest.getState(client);
			questStates.put(quest.getName(), state.name());
		}
		
		questData.put("questPoints", client.getVarpValue(101));
		questData.put("questStates", questStates);
		
		return questData;
	}
}


package com.revalclan.util;

import com.google.gson.Gson;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.Map;
import java.util.zip.GZIPOutputStream;

@Slf4j
@Singleton
public class WebhookService {
	private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");
	private static final String WEBHOOK_URL = "https://api.revalosrs.ee/reval-webhook";
	
	@Inject
	private OkHttpClient httpClient;
	
	@Inject
	private Gson gson;

	/**
	 * Sends player data to webhook asynchronously
	 */
	public void sendDataAsync(Map<String, Object> data) {
		sendDataAsync(WEBHOOK_URL, data);
	}

	/**
	 * Sends player data to a specific webhook URL asynchronously
	 * 
	 * @param webhookUrl The webhook endpoint URL
	 * @param data The player data to send
	 */
	private void sendDataAsync(String webhookUrl, Map<String, Object> data) {
		if (webhookUrl == null || webhookUrl.trim().isEmpty()) {
			return;
		}

		try {
			String json = gson.toJson(data);
			byte[] jsonBytes = json.getBytes("UTF-8");
			
			ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
			try (GZIPOutputStream gzipStream = new GZIPOutputStream(byteStream)) {
				gzipStream.write(jsonBytes);
			}
			byte[] compressedData = byteStream.toByteArray();
			
			RequestBody body = RequestBody.create(JSON, compressedData);
			
			Request request = new Request.Builder()
				.url(webhookUrl)
				.post(body)
				.addHeader("Content-Type", "application/json")
				.addHeader("Content-Encoding", "gzip")
				.addHeader("User-Agent", "RuneLite-RevalClan-Plugin")
				.build();

			httpClient.newCall(request).enqueue(new Callback() {
				@Override
				public void onFailure(Call call, IOException e) {
					log.error("Failed to send data to webhook: {}", e.getMessage());
				}

				@Override
				public void onResponse(Call call, Response response) {
					try {
						if (!response.isSuccessful()) {
							log.warn("Webhook returned non-successful status: {}", response.code());
						}
					} finally {
						response.close();
					}
				}
			});
		} catch (IOException e) {
			log.error("Failed to prepare webhook data: {}", e.getMessage());
		} catch (Exception e) {
			log.error("Unexpected error preparing webhook", e);
		}
	}
}


package com.revalclan.util;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.util.*;
import java.util.List;

/**
 * Manages dynamic event filters fetched from the backend API
 */
@Slf4j
@Singleton
public class EventFilterManager{
	private static final String FILTERS_URL = "https://api.revalosrs.ee/event-filters";
	
	@Inject private OkHttpClient httpClient;
	
	@Inject private Gson gson;
	
	@Getter private EventFilters filters;
	
	/**
	 * Holds all filter configurations
	 */
	@Getter
	public static class EventFilters {
		// Loot filter settings
		@Getter private long lootMinValue = 1_000_000; // 1M default
		@Getter private Set<Integer> lootWhitelist = new HashSet<>();
		@Getter private Set<Integer> lootBlacklist = new HashSet<>(Arrays.asList(526, 995)); // Bones, Coins
		
		// Detailed kill filter settings
		@Getter private Set<Integer> detailedKillNpcIdWhitelist = new HashSet<>();
		@Getter private Set<Integer> detailedKillNpcIdBlacklist = new HashSet<>();
		
		// Chat filter settings
		@Getter private List<String> chatPatterns = new ArrayList<>(); // Empty by default = no patterns, all messages pass
		
		// Event toggles
		@Getter private boolean lootEnabled = true;
		@Getter private boolean petEnabled = true;
		@Getter private boolean questEnabled = true;
		@Getter private boolean levelEnabled = true;
		@Getter private boolean killCountEnabled = true;
		@Getter private boolean clueEnabled = true;
		@Getter private boolean diaryEnabled = true;
		@Getter private boolean combatAchievementEnabled = true;
		@Getter private boolean collectionEnabled = true;
		@Getter private boolean deathEnabled = true;
		@Getter private boolean detailedKillEnabled = true;
		@Getter private boolean emoteEnabled = true;
		@Getter private boolean chatEnabled = true;
		@Getter private boolean musicEnabled = true;
	}
	
	public EventFilterManager() {
		// Initialize with defaults
		filters = new EventFilters();
	}
	
	/**
	 * Fetch filters from the API
	 * @return true if successful, false otherwise
	 */
	public boolean fetchFilters() {
		try {
			Request request = new Request.Builder()
				.url(FILTERS_URL)
				.get()
				.addHeader("User-Agent", "RuneLite-RevalClan-Plugin")
				.build();
			
			try (Response response = httpClient.newCall(request).execute()) {
				if (!response.isSuccessful()) {
					log.warn("Failed to fetch event filters: HTTP {}", response.code());
					return false;
				}
				
				String responseBody = response.body().string();
				JsonObject json = gson.fromJson(responseBody, JsonObject.class);
				
				parseFilters(json);
				
				log.info("✓ Successfully fetched event filters from API");
				return true;
			}
		} catch (IOException e) {
			log.error("Failed to fetch event filters: {}", e.getMessage());
			return false;
		} catch (Exception e) {
			log.error("Unexpected error fetching event filters", e);
			return false;
		}
	}
	
	/**
	 * Fetch filters asynchronously
	 */
	public void fetchFiltersAsync() {
		Request request = new Request.Builder()
			.url(FILTERS_URL)
			.get()
			.addHeader("User-Agent", "RuneLite-RevalClan-Plugin")
			.build();
		
		httpClient.newCall(request).enqueue(new Callback() {
			@Override
			public void onFailure(Call call, IOException e) {
				log.error("Failed to fetch event filters: {}", e.getMessage());
			}

			@Override
			public void onResponse(Call call, Response response) {
				try {
					if (!response.isSuccessful()) {
						log.warn("Failed to fetch event filters: HTTP {}", response.code());
						return;
					}
					
					String responseBody = response.body().string();
					JsonObject json = gson.fromJson(responseBody, JsonObject.class);
					
					parseFilters(json);
					
					log.info("✓ Successfully fetched event filters from API");
				} catch (IOException e) {
					log.error("Failed to parse event filters response: {}", e.getMessage());
				} catch (Exception e) {
					log.error("Unexpected error parsing event filters", e);
				} finally {
					response.close();
				}
			}
		});
	}
	
	/**
	 * Parse the filters JSON response
	 */
	private void parseFilters(JsonObject json) {
		EventFilters newFilters = new EventFilters();
		
		try {
			// Parse loot filters
			if (json.has("loot")) {
				JsonObject loot = json.getAsJsonObject("loot");
				
				if (loot.has("minValue")) {
					newFilters.lootMinValue = loot.get("minValue").getAsLong();
				}
				
				// Clear defaults and only use API values
				newFilters.lootWhitelist.clear();
				if (loot.has("whitelist") && loot.get("whitelist").isJsonArray()) {
					loot.getAsJsonArray("whitelist").forEach(item -> 
						newFilters.lootWhitelist.add(item.getAsInt())
					);
				}
				
				newFilters.lootBlacklist.clear();
				if (loot.has("blacklist") && loot.get("blacklist").isJsonArray()) {
					loot.getAsJsonArray("blacklist").forEach(item -> 
						newFilters.lootBlacklist.add(item.getAsInt())
					);
				}
			}
			
			// Parse detailed kill filters
			if (json.has("detailedKill")) {
				JsonObject detailedKill = json.getAsJsonObject("detailedKill");
				
				// Clear defaults and only use API values
				newFilters.detailedKillNpcIdWhitelist.clear();
				if (detailedKill.has("npcIdWhitelist") && detailedKill.get("npcIdWhitelist").isJsonArray()) {
					detailedKill.getAsJsonArray("npcIdWhitelist").forEach(id -> 
						newFilters.detailedKillNpcIdWhitelist.add(id.getAsInt())
					);
				}
				
				newFilters.detailedKillNpcIdBlacklist.clear();
				if (detailedKill.has("npcIdBlacklist") && detailedKill.get("npcIdBlacklist").isJsonArray()) {
					detailedKill.getAsJsonArray("npcIdBlacklist").forEach(id -> 
						newFilters.detailedKillNpcIdBlacklist.add(id.getAsInt())
					);
				}
			}
			
			// Parse chat filters
			if (json.has("chat")) {
				JsonObject chat = json.getAsJsonObject("chat");
				
				newFilters.chatPatterns.clear();
				if (chat.has("patterns") && chat.get("patterns").isJsonArray()) {
					chat.getAsJsonArray("patterns").forEach(pattern -> 
						newFilters.chatPatterns.add(pattern.getAsString())
					);
				}
			}
			
			// Parse event toggles
			if (json.has("enabled")) {
				JsonObject enabled = json.getAsJsonObject("enabled");
				
				if (enabled.has("loot")) newFilters.lootEnabled = enabled.get("loot").getAsBoolean();
				if (enabled.has("pet")) newFilters.petEnabled = enabled.get("pet").getAsBoolean();
				if (enabled.has("quest")) newFilters.questEnabled = enabled.get("quest").getAsBoolean();
				if (enabled.has("level")) newFilters.levelEnabled = enabled.get("level").getAsBoolean();
				if (enabled.has("killCount")) newFilters.killCountEnabled = enabled.get("killCount").getAsBoolean();
				if (enabled.has("clue")) newFilters.clueEnabled = enabled.get("clue").getAsBoolean();
				if (enabled.has("diary")) newFilters.diaryEnabled = enabled.get("diary").getAsBoolean();
				if (enabled.has("combatAchievement")) newFilters.combatAchievementEnabled = enabled.get("combatAchievement").getAsBoolean();
				if (enabled.has("collection")) newFilters.collectionEnabled = enabled.get("collection").getAsBoolean();
				if (enabled.has("death")) newFilters.deathEnabled = enabled.get("death").getAsBoolean();
				if (enabled.has("detailedKill")) newFilters.detailedKillEnabled = enabled.get("detailedKill").getAsBoolean();
				if (enabled.has("emote")) newFilters.emoteEnabled = enabled.get("emote").getAsBoolean();
				if (enabled.has("chat")) newFilters.chatEnabled = enabled.get("chat").getAsBoolean();
				if (enabled.has("music")) newFilters.musicEnabled = enabled.get("music").getAsBoolean();
			}
			
			// Atomically replace filters
			this.filters = newFilters;
		} catch (Exception e) {
			log.error("Error parsing filters JSON", e);
		}
	}
}


package com.revalclan.util;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.clan.ClanChannel;
import net.runelite.api.clan.ClanChannelMember;
import net.runelite.api.clan.ClanRank;

/**
 * Utility class for validating clan membership and rank
 * Used to restrict webhook notifications to specific clan members
 */
@Slf4j
public class ClanValidator {
	/** Required clan name (null or empty to disable clan check) */
	private static final String REQUIRED_CLAN_NAME = "Reval";
	
	/** 
	 * Minimum clan rank required (-1 to 127, where higher = more permissions)
	 */
	private static final ClanRank MINIMUM_CLAN_RANK = new ClanRank(0); // 10 = new member
	
	// ===============================================

	/**
	 * Validate that the player is in the required clan with sufficient rank
	 * @param client The RuneLite client instance
	 * @return true if player passes clan validation (or validation is disabled)
	 */
	public static boolean validateClan(Client client) {
		if (REQUIRED_CLAN_NAME == null || REQUIRED_CLAN_NAME.trim().isEmpty()) {
			return true;
		}

		ClanChannel clanChannel = client.getClanChannel();
		if (clanChannel == null) return false;

		boolean isInTheWrongClan = !REQUIRED_CLAN_NAME.equalsIgnoreCase(clanChannel.getName());
		if (isInTheWrongClan) return false;

		if (MINIMUM_CLAN_RANK == null) return true;

		String playerName = client.getLocalPlayer() != null ? client.getLocalPlayer().getName() : "Unknown";
		ClanChannelMember member = clanChannel.findMember(playerName);		
		if (member == null) return false;

		ClanRank playerRank = member.getRank();
		boolean isBelowMinimumRank = playerRank.getRank() < MINIMUM_CLAN_RANK.getRank();
		if (isBelowMinimumRank) return false;

		return true;
	}
}


package com.revalclan;

import com.revalclan.collectionlog.CollectionLogManager;
import com.revalclan.combatachievements.CombatAchievementManager;
import com.revalclan.diaries.AchievementDiaryManager;
import com.revalclan.player.PlayerManager;
import com.revalclan.quests.QuestManager;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.Map;

/**
 * Collects ALL player data by coordinating various managers
 */
@Slf4j
@Singleton
public class PlayerDataCollector {
	@Inject
	private PlayerManager playerManager;
	
	@Inject
	private QuestManager questManager;
	
	@Inject
	private AchievementDiaryManager achievementDiaryManager;
	
	@Inject
	private CombatAchievementManager combatAchievementManager;

	@Inject
	private CollectionLogManager collectionLogManager;

	/**
	 * Collects all player data and returns it as a map
	 */
	public Map<String, Object> collectAllData() {
		Map<String, Object> data = new HashMap<>();
		
		data.put("player", playerManager.sync());
		data.put("quests", questManager.sync());
		data.put("achievementDiaries", achievementDiaryManager.sync());
		data.put("combatAchievements", combatAchievementManager.sync());
		data.put("collectionLog", collectionLogManager.sync());
		
		return data;
	}
}

package com.revalclan.combatachievements;

import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Represents a Combat Achievement task with all its details
 */
@Data
@NoArgsConstructor
public class CombatAchievementTask {
	private int id;
	private String name;
	private String description;
	private String tier;
	private String type;
	private String boss;
	private int points;
	private boolean completed;
}


package com.revalclan.combatachievements;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.EnumComposition;
import net.runelite.api.StructComposition;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;

/**
 * Manages Combat Achievement task data by reading from game cache (enums/structs)
 */
@Slf4j
@Singleton
public class CombatAchievementManager {
	@Inject private Client client;

	private static final Map<Integer, String> TIER_ENUMS = new LinkedHashMap<>();
	static {
		TIER_ENUMS.put(3981, "Easy");
		TIER_ENUMS.put(3982, "Medium");
		TIER_ENUMS.put(3983, "Hard");
		TIER_ENUMS.put(3984, "Elite");
		TIER_ENUMS.put(3985, "Master");
		TIER_ENUMS.put(3986, "Grandmaster");
	}

	private static final Map<Integer, String> TYPE_MAP = new LinkedHashMap<>();
	static {
		TYPE_MAP.put(1, "Stamina");
		TYPE_MAP.put(2, "Perfection");
		TYPE_MAP.put(3, "Kill Count");
		TYPE_MAP.put(4, "Mechanical");
		TYPE_MAP.put(5, "Restriction");
		TYPE_MAP.put(6, "Speed");
	}

	private static final int BOSS_ENUM_ID = 3971;

	private static final int FIELD_NAME = 1308;
	private static final int FIELD_DESCRIPTION = 1309;
	private static final int FIELD_TASK_ID = 1306;
	private static final int FIELD_TYPE_ID = 1311;
	private static final int FIELD_BOSS_ID = 1312;

	private static final int[] COMPLETION_VARPS = {
		3116,  // CA_TASK_COMPLETED_0
		3117,  // CA_TASK_COMPLETED_1
		3118,  // CA_TASK_COMPLETED_2
		3119,  // CA_TASK_COMPLETED_3
		3120,  // CA_TASK_COMPLETED_4
		3121,  // CA_TASK_COMPLETED_5
		3122,  // CA_TASK_COMPLETED_6
		3123,  // CA_TASK_COMPLETED_7
		3124,  // CA_TASK_COMPLETED_8
		3125,  // CA_TASK_COMPLETED_9
		3126,  // CA_TASK_COMPLETED_10
		3127,  // CA_TASK_COMPLETED_11
		3128,  // CA_TASK_COMPLETED_12
		3387,  // CA_TASK_COMPLETED_13
		3718,  // CA_TASK_COMPLETED_14
		3773,  // CA_TASK_COMPLETED_15
		3774,  // CA_TASK_COMPLETED_16
		4204,  // CA_TASK_COMPLETED_17
		4496,  // CA_TASK_COMPLETED_18
		4721   // CA_TASK_COMPLETED_19
	};

	private final List<CombatAchievementTask> allTasks = new ArrayList<>();

	/**
	 * Sync and get combat achievement data
	 */
	public Map<String, Object> sync() {
		allTasks.clear();
		
		for (Map.Entry<Integer, String> tierEntry : TIER_ENUMS.entrySet()) {
			try {
				EnumComposition tierEnum = client.getEnum(tierEntry.getKey());
				if (tierEnum == null) continue;
				
				for (int structId : tierEnum.getIntVals()) {
					try {
						CombatAchievementTask task = loadTaskFromStruct(structId, tierEntry.getValue());
						if (task != null) allTasks.add(task);
					} catch (Exception ignored) {}
				}
			} catch (Exception ignored) {}
		}
		
		int totalPoints = calculateTotalPoints();
		
		Map<String, Object> data = new HashMap<>();
		data.put("currentTier", calculateCurrentTier(totalPoints));
		data.put("totalPoints", totalPoints);
		data.put("tierProgress", getTierProgress());
		data.put("allTasks", getAllTasksDetailed());
		data.put("totalTasksLoaded", allTasks.size());
		
		return data;
	}

	/**
	 * Loads a single task from a struct
	 */
	private CombatAchievementTask loadTaskFromStruct(int structId, String tierName) {
		StructComposition struct = client.getStructComposition(structId);
		if (struct == null) return null;
		
		String name = struct.getStringValue(FIELD_NAME);
		String description = struct.getStringValue(FIELD_DESCRIPTION);
		int taskId = struct.getIntValue(FIELD_TASK_ID);
		int typeId = struct.getIntValue(FIELD_TYPE_ID);
		String type = TYPE_MAP.getOrDefault(typeId, "Unknown");
		int bossId = struct.getIntValue(FIELD_BOSS_ID);
		String bossName = getBossName(bossId);
		
		boolean completed = isTaskCompleted(taskId);
		
		CombatAchievementTask task = new CombatAchievementTask();
		task.setId(taskId);
		task.setName(name);
		task.setDescription(description);
		task.setTier(tierName);
		task.setType(type);
		task.setBoss(bossName);
		task.setCompleted(completed);
		task.setPoints(getPointsForTier(tierName));
		
		return task;
	}

	/**
	 * Gets boss name from boss enum
	 */
	private String getBossName(int bossId) {
		try {
			EnumComposition bossEnum = client.getEnum(BOSS_ENUM_ID);
			if (bossEnum != null) {
				String name = bossEnum.getStringValue(bossId);
				if (name != null && !name.isEmpty()) return name;
			}
		} catch (Exception ignored) {}
		return "Unknown";
	}

	/**
	 * Checks if a task is completed using VarPlayer
	 */
	private boolean isTaskCompleted(int taskId) {
		if (taskId < 0 || taskId >= COMPLETION_VARPS.length * 32) return false;

		int varpIndex = taskId / 32;
		int bitIndex = taskId % 32;

		if (varpIndex >= COMPLETION_VARPS.length) return false;
		
		try {
			int varpValue = client.getVarpValue(COMPLETION_VARPS[varpIndex]);
			return (varpValue & (1 << bitIndex)) != 0;
		} catch (Exception e) {
			return false;
		}
	}

	/**
	 * Gets points for a tier
	 */
	private int getPointsForTier(String tier) {
		switch (tier.toLowerCase()) {
			case "easy": return 1;
			case "medium": return 2;
			case "hard": return 3;
			case "elite": return 4;
			case "master": return 5;
			case "grandmaster": return 6;
			default: return 1;
		}
	}

	/**
	 * Calculate total points from completed tasks
	 */
	private int calculateTotalPoints() {
		return allTasks.stream()
			.filter(CombatAchievementTask::isCompleted)
			.mapToInt(CombatAchievementTask::getPoints)
			.sum();
	}

	/**
	 * Calculate current tier based on total points
	 */
	private String calculateCurrentTier(int totalPoints) {
		if (totalPoints >= 1550) return "Grandmaster";
		if (totalPoints >= 1265) return "Master";
		if (totalPoints >= 977) return "Elite";
		if (totalPoints >= 683) return "Hard";
		if (totalPoints >= 391) return "Medium";
		if (totalPoints >= 110) return "Easy";
		return "None";
	}

	/**
	 * Get tier progress breakdown
	 */
	private Map<String, Map<String, Integer>> getTierProgress() {
		Map<String, Map<String, Integer>> tierProgress = new LinkedHashMap<>();
		
		for (String tier : TIER_ENUMS.values()) {
			int completed = (int) allTasks.stream()
				.filter(t -> t.getTier().equals(tier) && t.isCompleted())
				.count();
			
			int total = (int) allTasks.stream()
				.filter(t -> t.getTier().equals(tier))
				.count();
			
			Map<String, Integer> tierData = new HashMap<>();
			tierData.put("completed", completed);
			tierData.put("total", total);
			tierProgress.put(tier.toLowerCase(), tierData);
		}
		
		return tierProgress;
	}

	/**
	 * Get all tasks with full details
	 */
	private List<Map<String, Object>> getAllTasksDetailed() {
		List<Map<String, Object>> tasksList = new ArrayList<>();
		
		for (CombatAchievementTask task : allTasks) {
			tasksList.add(Map.of(
				"id", task.getId(),
				"name", task.getName(),
				"description", task.getDescription(),
				"tier", task.getTier(),
				"type", task.getType(),
				"boss", task.getBoss(),
				"points", task.getPoints(),
				"completed", task.isCompleted()
			));
		}
		
		return tasksList;
	}
}
package com.revalclan.notifiers;

import com.revalclan.RevalClanConfig;
import net.runelite.api.events.MenuOptionClicked;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.Map;

@Singleton
public class EmoteNotifier extends BaseNotifier {
	@Inject
	private RevalClanConfig config;

	@Override
	public boolean isEnabled() {
		return config.notifyEmote() && filterManager.getFilters().isEmoteEnabled();
	}

	@Override
	protected String getEventType() {
		return "EMOTE";
	}

	public void onMenuOptionClicked(MenuOptionClicked event) {
		if (!isEnabled()) return;

		String menuOption = event.getMenuOption();
		String menuTarget = event.getMenuTarget();

		if (menuOption != null && menuOption.toLowerCase().contains("perform")) {
			Map<String, Object> emoteData = new HashMap<>();
			emoteData.put("emote", menuTarget);

			sendNotification(emoteData);
		}
	}
}


package com.revalclan.notifiers;

import javax.inject.Singleton;

import com.google.inject.Inject;
import com.revalclan.PlayerDataCollector;

import java.util.Map;

/**
 * Notifies when a player logs in.
 * Sends a lightweight LOGIN event with basic player info.
 */
@Singleton
public class LoginNotifier extends BaseNotifier {
	@Inject
	private PlayerDataCollector dataCollector;
	
	@Override
	public boolean isEnabled() {
		return true;
	}

	@Override
	protected String getEventType() {
		return "LOGIN";
	}

	/**
	 * Called when the player logs in.
	 */
	public void onLogin() {
		Map<String, Object> data = dataCollector.collectAllData();
		data.put("world", client.getWorld());

		sendNotification(data);
	}
}


/*
 * Portions of this file are derived from or inspired by the Dink plugin
 * Copyright (c) 2022, Jake Barter
 * Copyright (c) 2022, pajlads
 * Licensed under the BSD 2-Clause License
 * See LICENSES/dink-LICENSE.txt for full license text
 */
package com.revalclan.notifiers;

import com.revalclan.RevalClanConfig;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.callback.ClientThread;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Singleton
public class DiaryNotifier extends BaseNotifier {
	/**
	 * CS2 Script IDs for diary completion tracking
	 * @see <a href="https://github.com/Joshua-F/cs2-scripts">CS2 Reference</a>
	 */
	private static final int COMPLETED_TASKS_SCRIPT_ID = 3971;
	private static final int TOTAL_TASKS_SCRIPT_ID = 3980;

	/**
	 * Map of diary varbit IDs to their completion status
	 * Key: varbit ID, Value: completion value (0 = not started, 1 = completed, 2 = completed for Karamja special case)
	 */
	private static final Map<Integer, String> DIARY_VARBITS = createDiaryMap();

	@Inject private RevalClanConfig config;

	@Inject private ClientThread clientThread;

	private final Map<Integer, Integer> diaryCompletionById = new ConcurrentHashMap<>();
	private int initDelayTicks = 0;

	@Override
	public boolean isEnabled() {
		return config.notifyDiary() && filterManager.getFilters().isDiaryEnabled();
	}

	@Override
	protected String getEventType() {
		return "DIARY";
	}

	public void onGameStateChanged(GameStateChanged event) {
		if (event.getGameState() != GameState.LOGGED_IN) {
			reset();
		}
	}

	public void onGameTick() {
		if (client.getGameState() != GameState.LOGGED_IN) return;

		if (initDelayTicks > 0) {
			initDelayTicks--;
			if (initDelayTicks == 0)
			{
				initializeDiaries();
			}
		} else if (diaryCompletionById.isEmpty() && isEnabled()) {
			initDelayTicks = 4;
		}
	}

	public void onVarbitChanged(VarbitChanged event) {
		int id = event.getVarbitId();
		if (id < 0) return;
		
		String diaryInfo = DIARY_VARBITS.get(id);
		if (diaryInfo == null) return;
		if (!isEnabled()) return;

		if (diaryCompletionById.isEmpty()) {
			if (client.getGameState() == GameState.LOGGED_IN && isComplete(id, event.getValue())) return;
			else return;
		}

		int value = event.getValue();
		Integer previous = diaryCompletionById.get(id);

		if (previous == null) {
			reset();
			return;
		}

		if (value < previous) {
			reset();
			return;
		}

		if (value > previous) {
			diaryCompletionById.put(id, value);

			if (isComplete(id, value)) {
				clientThread.invokeLater(() -> {
					handleDiaryCompletion(diaryInfo, id);
					return true;
				});
			}
		}
	}

	private void handleDiaryCompletion(String diaryInfo, int varbitId) {
		client.runScript(COMPLETED_TASKS_SCRIPT_ID);
		int completedTasks = client.getIntStack()[0];

		client.runScript(TOTAL_TASKS_SCRIPT_ID);
		int totalTasks = client.getIntStack()[0];

		int totalDiariesCompleted = getTotalCompleted();

		String[] parts = diaryInfo.split("_");
		String area = parts.length > 0 ? parts[0] : "Unknown";
		String difficulty = parts.length > 1 ? parts[1] : "Unknown";

		Map<String, Object> diaryData = new HashMap<>();
		diaryData.put("area", area);
		diaryData.put("difficulty", difficulty);
		diaryData.put("varbitId", varbitId);
		diaryData.put("completedTasks", completedTasks);
		diaryData.put("totalTasks", totalTasks);
		diaryData.put("totalDiariesCompleted", totalDiariesCompleted);

		sendNotification(diaryData);
	}

	private void initializeDiaries() {
		if (!isEnabled()) return;

		diaryCompletionById.clear();

		for (Integer varbitId : DIARY_VARBITS.keySet()) {
			int value = client.getVarbitValue(varbitId);
			if (value >= 0) {
				diaryCompletionById.put(varbitId, value);
			}
		}
	}

	private int getTotalCompleted() {
		int count = 0;
		for (Map.Entry<Integer, Integer> entry : diaryCompletionById.entrySet()) {
			if (isComplete(entry.getKey(), entry.getValue())) count++;
		}
		return count;
	}

	private static boolean isComplete(int varbitId, int value) {
		if (varbitId == 3578 || varbitId == 3599 || varbitId == 3611) {
			return value > 1;
		}
		return value > 0;
	}

	public void reset() {
		diaryCompletionById.clear();
		initDelayTicks = 0;
	}

	private static Map<Integer, String> createDiaryMap() {
		Map<Integer, String> map = new HashMap<>();
		
		map.put(3577, "Ardougne_Easy");
		map.put(3598, "Ardougne_Medium");
		map.put(3608, "Ardougne_Hard");
		map.put(3630, "Ardougne_Elite");
		
		map.put(3579, "Desert_Easy");
		map.put(3597, "Desert_Medium");
		map.put(3610, "Desert_Hard");
		map.put(3628, "Desert_Elite");
		
		map.put(3580, "Falador_Easy");
		map.put(3596, "Falador_Medium");
		map.put(3612, "Falador_Hard");
		map.put(3632, "Falador_Elite");
		
		map.put(3582, "Fremennik_Easy");
		map.put(3594, "Fremennik_Medium");
		map.put(3615, "Fremennik_Hard");
		map.put(3636, "Fremennik_Elite");
		
		map.put(3583, "Kandarin_Easy");
		map.put(3593, "Kandarin_Medium");
		map.put(3617, "Kandarin_Hard");
		map.put(3638, "Kandarin_Elite");
		
		map.put(3578, "Karamja_Easy");
		map.put(3599, "Karamja_Medium");
		map.put(3611, "Karamja_Hard");
		map.put(3631, "Karamja_Elite");
		
		map.put(3581, "Lumbridge_Easy");
		map.put(3595, "Lumbridge_Medium");
		map.put(3614, "Lumbridge_Hard");
		map.put(3635, "Lumbridge_Elite");
		
		map.put(3584, "Morytania_Easy");
		map.put(3592, "Morytania_Medium");
		map.put(3618, "Morytania_Hard");
		map.put(3639, "Morytania_Elite");
		
		map.put(3576, "Varrock_Easy");
		map.put(3601, "Varrock_Medium");
		map.put(3606, "Varrock_Hard");
		map.put(3627, "Varrock_Elite");
		
		map.put(3585, "Western_Easy");
		map.put(3591, "Western_Medium");
		map.put(3620, "Western_Hard");
		map.put(3641, "Western_Elite");
		
		map.put(3586, "Wilderness_Easy");
		map.put(3600, "Wilderness_Medium");
		map.put(3621, "Wilderness_Hard");
		map.put(3642, "Wilderness_Elite");
		
		map.put(7925, "Kourend_Easy");
		map.put(7926, "Kourend_Medium");
		map.put(7927, "Kourend_Hard");
		map.put(7928, "Kourend_Elite");
		
		return map;
	}
}

/*
 * Portions of this file are derived from or inspired by the Dink plugin
 * Copyright (c) 2022, Jake Barter
 * Copyright (c) 2022, pajlads
 * Licensed under the BSD 2-Clause License
 * See LICENSES/dink-LICENSE.txt for full license text
 */
package com.revalclan.notifiers;

import com.revalclan.RevalClanConfig;
import net.runelite.api.Actor;
import net.runelite.api.NPC;
import net.runelite.api.NPCComposition;
import net.runelite.api.Player;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.InteractingChanged;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.lang.ref.WeakReference;
import java.util.HashMap;
import java.util.Map;

@Singleton
public class DeathNotifier extends BaseNotifier {
	private static final String ATTACK_OPTION = "Attack";
	
	@Inject private RevalClanConfig config;

	private Actor lastAttacker = null;
	private long lastAttackTime = 0;
	private static final long ATTACK_TIMEOUT_MS = 10000;
	
	/**
	 * Tracks the last Actor our local player interacted with (attacked)
	 * Wrapped in WeakReference to allow garbage collection if actor despawns
	 */
	private WeakReference<Actor> lastTarget = new WeakReference<>(null);

	@Override
	public boolean isEnabled() {
		return config.notifyDeath() && filterManager.getFilters().isDeathEnabled();
	}

	@Override
	protected String getEventType() {
		return "DEATH";
	}

	/**
	 * Track who is attacking the player (inbound interaction)
	 */
	public void onInteractingChanged(InteractingChanged event) {
		if (!isEnabled()) return;

		Actor source = event.getSource();
		Actor target = event.getTarget();

		// Track who is attacking us
		if (target != null && target == client.getLocalPlayer()) {
			lastAttacker = source;
			lastAttackTime = System.currentTimeMillis();
		}
		
		// Track who we are attacking (outbound interaction)
		if (source == client.getLocalPlayer() && target != null && target.getCombatLevel() > 0) {
			lastTarget = new WeakReference<>(target);
		}
	}

	public void onActorDeath(ActorDeath event) {
		if (!isEnabled()) return;

		Actor actor = event.getActor();
		if (actor == client.getLocalPlayer()) {
			handleDeath();
		}
		
		// Clear target reference if our target or we died
		if (actor == client.getLocalPlayer() || actor == lastTarget.get()) {
			lastTarget = new WeakReference<>(null);
		}
	}

	private void handleDeath() {
		Map<String, Object> deathData = new HashMap<>();
		
		// Identify killer using sophisticated algorithm
		Actor killer = identifyKiller();
		
		if (killer != null) {
			if (killer instanceof NPC) {
				NPC npc = (NPC) killer;
				deathData.put("killedBy", npc.getName());
				deathData.put("killerType", "NPC");
				deathData.put("killerId", npc.getId());
			} else if (killer instanceof Player) {
				Player player = (Player) killer;
				deathData.put("killedBy", player.getName());
				deathData.put("killerType", "PLAYER");
				deathData.put("killerCombatLevel", player.getCombatLevel());
			}
		} else {
			deathData.put("killedBy", "Unknown");
			deathData.put("killerType", "UNKNOWN");
		}
		
		sendNotification(deathData);
		
		reset();
	}
	
	/**
	 * Identify who killed the player using multiple strategies:
	 * 1. Check last target (who we attacked)
	 * 2. Check who was attacking us (lastAttacker)
	 * 3. Search through all NPCs interacting with us
	 */
	private Actor identifyKiller() {
		Player localPlayer = client.getLocalPlayer();
		if (localPlayer == null) return null;
		
		// Strategy 1: Check our last target (who we attacked)
		Actor lastTarget = this.lastTarget.get();
		if (isValidKiller(lastTarget, localPlayer)) {
			return lastTarget;
		}
		
		// Strategy 2: Check last attacker (simple fallback)
		if (lastAttacker != null && (System.currentTimeMillis() - lastAttackTime) < ATTACK_TIMEOUT_MS) {
			if (isValidKiller(lastAttacker, localPlayer)) {
				return lastAttacker;
			}
		}
		
		// Strategy 3: Search through all NPCs currently interacting with us
		return client.getTopLevelWorldView().npcs().stream()
			.filter(npc -> npc != null && !npc.isDead())
			.filter(npc -> npc.getInteracting() == localPlayer)
			.filter(npc -> {
				NPCComposition comp = npc.getTransformedComposition();
				return comp != null && comp.isInteractible() && !comp.isFollower() && comp.getCombatLevel() > 0;
			})
			.findFirst()
			.orElse(null);
	}
	
	/**
	 * Check if an actor is a valid killer
	 */
	private boolean isValidKiller(Actor actor, Player localPlayer) {
		if (actor == null || actor.isDead()) return false;
		if (actor.getInteracting() != localPlayer) return false;
		
		if (actor instanceof NPC) {
			NPC npc = (NPC) actor;
			NPCComposition comp = npc.getTransformedComposition();
			if (comp == null || !comp.isInteractible() || comp.isFollower()) return false;
			if (comp.getCombatLevel() <= 0) return false;
			
			// Check if NPC has attack option (is attackable)
			String[] actions = comp.getActions();
			if (actions != null) {
				for (String action : actions) {
					if (ATTACK_OPTION.equals(action)) {
						return true;
					}
				}
			}
			return false;
		}
		
		if (actor instanceof Player) {
			// For now, we'll accept any player
			// In the future, could add wilderness/PvP world checks
			return true;
		}
		
		return false;
	}

	public void reset() {
		lastAttacker = null;
		lastAttackTime = 0;
		lastTarget = new WeakReference<>(null);
	}
}


package com.revalclan.notifiers;

import com.revalclan.RevalClanConfig;
import net.runelite.api.NPC;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.NpcID;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.events.PlayerLootReceived;
import net.runelite.client.events.ServerNpcLoot;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.http.api.loottracker.LootRecordType;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;

@Singleton
public class LootNotifier extends BaseNotifier {
	@Inject
	private RevalClanConfig config;

	@Inject
	private ItemManager itemManager;

	/**
	 * NPC IDs that fire LootReceived instead of NpcLootReceived
	 * These should be handled in onLootReceived, not onNpcLootReceived
	 */
	private static final Set<Integer> SPECIAL_LOOT_NPC_IDS = Set.of(
		NpcID.WHISPERER, NpcID.WHISPERER_MELEE, NpcID.WHISPERER_QUEST, NpcID.WHISPERER_MELEE_QUEST,
		NpcID.ARAXXOR, NpcID.ARAXXOR_DEAD, NpcID.RT_FIRE_QUEEN_INACTIVE, NpcID.RT_ICE_KING_INACTIVE,
		NpcID.YAMA,
		NpcID.HESPORI
	);

	/**
	 * NPC names that fire LootReceived instead of NpcLootReceived
	 */
	private static final Set<String> SPECIAL_LOOT_NPC_NAMES = Set.of(
		"The Whisperer", "Araxxor",
		"Branda the Fire Queen", "Eldric the Ice King",
		"Crystalline Hunllef", "Corrupted Hunllef",
		"The Gauntlet", "Corrupted Gauntlet",
		"Shellbane Gryphon"
	);

	@Override
	public boolean isEnabled() {
		return config.notifyLoot() && filterManager.getFilters().isLootEnabled();
	}

	@Override
	protected String getEventType() {
		return "LOOT";
	}

	@Subscribe
	public void onServerNpcLoot(ServerNpcLoot event) {
		if (!isEnabled()) return;

		// Most NPCs are handled by NpcLootReceived or LootReceived to avoid duplicates
		int npcId = event.getComposition().getId();
		var name = event.getComposition().getName();
		
		// Only handle Yama, Hespori, and Hallowed Sepulchre
		if (npcId != NpcID.YAMA && npcId != NpcID.HESPORI && !name.startsWith("Hallowed Sepulchre")) {
			return;
		}

		var comp = event.getComposition();
		handleLootDrop(event.getItems(), comp.getName(), "NPC", comp.getId());
	}

	@Subscribe
	public void onNpcLootReceived(NpcLootReceived event){
		if (!isEnabled()) return;

		NPC npc = event.getNpc();
		int npcId = npc.getId();

		// Skip NPCs that fire LootReceived instead (to avoid duplicates)
		if (SPECIAL_LOOT_NPC_IDS.contains(npcId)) return;

		Collection<ItemStack> items = event.getItems();
		handleLootDrop(items, npc.getName(), "NPC", npcId);
	}

	@Subscribe
	public void onPlayerLootReceived(PlayerLootReceived event) {
		if (!isEnabled()) return;

		String playerName = event.getPlayer().getName();
		Collection<ItemStack> items = event.getItems();

		handleLootDrop(items, playerName, "PLAYER", null);
	}

	@Subscribe
	public void onLootReceived(LootReceived event) {
		if (!isEnabled()) return;

		// Handle EVENT and PICKPOCKET types
		// EVENT type includes: raids (Chambers of Xeric, Theatre of Blood, Tombs of Amascut),
		// moons (Moons of Peril), barrows chests, gauntlet chests, and other special content
		if (event.getType() == LootRecordType.EVENT || event.getType() == LootRecordType.PICKPOCKET) {
			String source = event.getName();
			handleLootDrop(event.getItems(), source, "EVENT", null);
		} 
		// Handle special NPCs that fire LootReceived instead of NpcLootReceived
		else if (event.getType() == LootRecordType.NPC && SPECIAL_LOOT_NPC_NAMES.contains(event.getName())) {
			String source = event.getName();
			if ("The Gauntlet".equals(source) || "Corrupted Gauntlet".equals(source)) {
				handleLootDrop(event.getItems(), source, "EVENT", null);
			} else {
				handleLootDrop(event.getItems(), source, "NPC", null);
			}
		}
	}

	/**
	 * Handle game messages for special loot cases that don't fire normal loot events
	 */
	public void onGameMessage(String message) {
		if (!isEnabled()) return;

		// Pyramid Plunder: Pharaoh's sceptre doesn't fire a normal loot event
		if ("You have found a Pharaoh's sceptre! It fell on the floor.".equals(message)) {
			handleLootDrop(List.of(new ItemStack(ItemID.PHARAOHS_SCEPTRE, 1)), "Pyramid Plunder", "EVENT", null);
		}
	}

	private void handleLootDrop(Collection<ItemStack> items, String source, String sourceType, Integer sourceId) {
		// Get dynamic filters
		long minLootValue = filterManager.getFilters().getLootMinValue();
		Set<Integer> whitelistItemIds = filterManager.getFilters().getLootWhitelist();
		Set<Integer> blacklistItemIds = filterManager.getFilters().getLootBlacklist();
		
		List<Map<String, Object>> itemsList = new ArrayList<>();
		long totalGEValue = 0;
		long totalHAValue = 0;
		boolean hasWhitelistedItem = false;
		boolean hasUntradeable = false;

		for (ItemStack item : items) {
			int itemId = item.getId();
			
			// Skip blacklisted items
			if (blacklistItemIds.contains(itemId)) continue;

			int gePrice = itemManager.getItemPrice(itemId);
			int haValue = itemManager.getItemComposition(itemId).getPrice();
			boolean isTradeable = itemManager.getItemComposition(itemId).isTradeable();
			String itemName = itemManager.getItemComposition(itemId).getName();

			Map<String, Object> itemData = new HashMap<>();
			itemData.put("id", itemId);
			itemData.put("name", itemName);
			itemData.put("quantity", item.getQuantity());
			itemData.put("gePrice", gePrice);
			itemData.put("haValue", haValue);
			itemData.put("tradeable", isTradeable);
			itemsList.add(itemData);

			totalGEValue += (long) gePrice * item.getQuantity();
			totalHAValue += (long) haValue * item.getQuantity();

			// Check for special items
			if (whitelistItemIds.contains(itemId)) hasWhitelistedItem = true;
			if (!isTradeable) hasUntradeable = true;
		}
		// 1. Total value >= minLootValue (from API)
		// 2. Contains a whitelisted item (from API)
		// 3. Contains an untradeable item
		boolean shouldNotify = totalGEValue >= minLootValue || hasWhitelistedItem || hasUntradeable;

		if (!shouldNotify) return;

		Map<String, Object> lootData = new HashMap<>();
		lootData.put("source", source);
		lootData.put("sourceType", sourceType);
		if (sourceId != null) {
			lootData.put("sourceId", sourceId);
		}
		lootData.put("totalGEValue", totalGEValue);
		lootData.put("totalHAValue", totalHAValue);
		lootData.put("items", itemsList);

		sendNotification(lootData);
	}
}

package com.revalclan.notifiers;

import com.revalclan.RevalClanConfig;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.Widget;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@Singleton
public class QuestNotifier extends BaseNotifier {
	@Inject private RevalClanConfig config;

	@Override
	public boolean isEnabled() {
		return config.notifyQuest() && filterManager.getFilters().isQuestEnabled();
	}

	@Override
	protected String getEventType() {
		return "QUEST";
	}

	public void onWidgetLoaded(WidgetLoaded event) {
		if (!isEnabled()) return;

		if (event.getGroupId() == InterfaceID.QUESTSCROLL) {
			Widget questTitle = client.getWidget(InterfaceID.Questscroll.QUEST_TITLE);
			if (questTitle != null) {
				String questText = questTitle.getText();
				handleQuestCompletion(questText);
			}
		}
	}

	private void handleQuestCompletion(String questText) {
		// Parse quest name from the widget text
		String questName = parseQuestName(questText);
		if (questName == null) return;

		int questPoints = client.getVarpValue(VarPlayerID.QP);
		int completedQuests = client.getVarbitValue(VarbitID.QUESTS_COMPLETED_COUNT);
		int totalQuests = client.getVarbitValue(VarbitID.QUESTS_TOTAL_COUNT);

		Map<String, Object> questData = new HashMap<>();
		questData.put("questName", questName);
		questData.put("questPoints", questPoints);
		questData.put("completedQuests", completedQuests);
		questData.put("totalQuests", totalQuests);

		sendNotification(questData);
	}

	private String parseQuestName(String questText) {
		if (questText == null) return null;

		String[] lines = questText.split("\n");
		if (lines.length >= 3) {
			String name = lines[2].replace("!", "").trim();
			return name.isEmpty() ? null : name;
		}
		return null;
	}
}


package com.revalclan.notifiers;

import com.revalclan.RevalClanConfig;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.gameval.InterfaceID;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.Map;

@Singleton
public class MusicNotifier extends BaseNotifier {
	private static final int MUSIC_INTERFACE = InterfaceID.MUSIC;

	@Inject
	private RevalClanConfig config;

	@Override
	public boolean isEnabled() {
		return config.notifyMusic() && filterManager.getFilters().isMusicEnabled();
	}

	@Override
	protected String getEventType() {
		return "MUSIC_PLAYED";
	}

	public void onMenuOptionClicked(MenuOptionClicked event) {
		if (!isEnabled()) return;
		
		String menuOption = event.getMenuOption();
		String menuTarget = event.getMenuTarget();
		int widgetId = event.getParam1();
		int widgetGroup = widgetId >> 16;
		
		if ("Play".equals(menuOption) && widgetGroup == MUSIC_INTERFACE) {
			String trackName = menuTarget.replaceAll("<[^>]+>", "").trim();
			
			if (!trackName.isEmpty()) {
				Map<String, Object> musicData = new HashMap<>();
				musicData.put("trackName", trackName);
				
				sendNotification(musicData);
			}
		}
	}
}


package com.revalclan.notifiers;

import com.revalclan.PlayerDataCollector;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.Map;

/**
 * Handles full account sync events.
 * This is triggered on logout or manually via the collection log button.
 */
@Singleton
public class SyncNotifier extends BaseNotifier {
	@Inject
	private PlayerDataCollector dataCollector;

	@Override
	public boolean isEnabled() {
		return true;
	}

	@Override
	protected String getEventType() {
		return "SYNC";
	}

	/**
	 * Trigger a full account sync.
	 * Collects all player data (collection log, quests, diaries, combat achievements, etc.)
	 * and sends it to the webhook.
	 */
	public void triggerSync() {
		Map<String, Object> data = dataCollector.collectAllData();
		sendNotification(data);
	}
}


package com.revalclan.notifiers;

import com.revalclan.RevalClanConfig;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
@Singleton
public class PetNotifier extends BaseNotifier {
	/**
	 * Pattern matching the initial pet drop message
	 */
	private static final Pattern PET_PATTERN = Pattern.compile(
		"You (?:have a funny feeling like you(?:'re being followed| would have been followed)|feel something weird sneaking into your backpack)\\.?",
		Pattern.CASE_INSENSITIVE
	);

	/**
	 * Pattern matching untradeable drop messages (e.g., "Untradeable drop: Pet zilyana")
	 */
	private static final Pattern UNTRADEABLE_PATTERN = Pattern.compile(
		"Untradeable drop: (.+)",
		Pattern.CASE_INSENSITIVE
	);

	/**
	 * Pattern matching collection log messages (e.g., "New item added to your collection log: Pet zilyana")
	 */
	private static final Pattern COLLECTION_LOG_PATTERN = Pattern.compile(
		"New item added to your collection log: (.+)",
		Pattern.CASE_INSENSITIVE
	);

	/**
	 * Pattern matching clan pet notifications
	 * Matches formats like:
	 * - "Username has a funny feeling like she would have been followed: Pet name at 114 completions."
	 * - "Username has a funny feeling like she's being followed: Pet name at 50 kills."
	 * - "Username feels something weird sneaking into her backpack: Pet name at 100 kills."
	 */
	private static final Pattern CLAN_REGEX = Pattern.compile(
		"(?<user>.+?) (?:has a funny feeling like .+? (?:would have been followed|being followed)|feels something weird sneaking into .+? backpack|feels like .+? acquired something special): (?<pet>.+?)(?: at (?<milestone>.+))?\\.$",
		Pattern.CASE_INSENSITIVE
	);

	/**
	 * Maximum number of ticks to wait for pet name before sending notification without it
	 */
	private static final int MAX_TICKS_WAIT = 5;

	@Inject private RevalClanConfig config;

	/**
	 * Whether we've seen the personal "You have a funny feeling" game message
	 */
	private volatile boolean seenGameMessage = false;

	/**
	 * The personal game message content
	 */
	private volatile String gameMessage = null;

	/**
	 * Pet name extracted from follow-up messages
	 */
	private volatile String petName = null;

	/**
	 * Kill count information (e.g., "50 kills")
	 */
	private volatile String killCount = null;

	/**
	 * Number of ticks waited for pet name
	 */
	private final AtomicInteger ticksWaited = new AtomicInteger(0);

	@Override
	public boolean isEnabled() {
		return config.notifyPet() && filterManager.getFilters().isPetEnabled();
	}

	@Override
	protected String getEventType() {
		return "PET";
	}

	/**
	 * Handle chat messages - looks for initial pet message and follow-up messages with pet name
	 */
	public void onChatMessage(String message) {
		if (!isEnabled()) return;

		// Check for the personal pet drop message
		Matcher petMatcher = PET_PATTERN.matcher(message);
		if (petMatcher.find()) {
			this.seenGameMessage = true;
			this.gameMessage = message;
			this.ticksWaited.set(0);
			return;
		}

		// If we've seen a pet message, look for follow-up messages with pet name
		if (this.seenGameMessage && this.petName == null) {
			// Check for untradeable drop message (new pets only, not duplicates)
			Matcher untradeableMatcher = UNTRADEABLE_PATTERN.matcher(message);
			if (untradeableMatcher.find()) {
				String itemName = untradeableMatcher.group(1).trim();
				if (isPetItem(itemName)) {
					this.petName = itemName;
					return;
				}
			}

			// Check for collection log message (new pets only, not duplicates)
			Matcher collectionMatcher = COLLECTION_LOG_PATTERN.matcher(message);
			if (collectionMatcher.find()) {
				String itemName = collectionMatcher.group(1).trim();
				if (isPetItem(itemName)) {
					this.petName = itemName;
					return;
				}
			}
		}
	}

	/**
	 * Handle clan notifications - extracts pet name and kill count for the current player
	 * This is especially important for duplicate pets where there's no "Untradeable drop:" message
	 */
	public void onClanNotification(String message) {
		if (!isEnabled()) return;

		Matcher clanMatcher = CLAN_REGEX.matcher(message);
		if (clanMatcher.find()) {
			String user = clanMatcher.group("user").trim();
			String playerName = getPlayerName();
			
			if (user.equalsIgnoreCase(playerName)) {
				String pet = null;
				String milestone = null;
				
				try {
					pet = clanMatcher.group("pet");
					milestone = clanMatcher.group("milestone");
				} catch (IllegalArgumentException e) {
					return;
				}

				if (pet != null && !pet.trim().isEmpty()) {
					this.petName = pet.trim();
				}
				if (milestone != null && !milestone.trim().isEmpty()) {
					this.killCount = milestone.trim();
				}

				// If we haven't seen the game message yet, mark that we've seen clan info
				// The game message should arrive soon (or may have already arrived)
				if (!seenGameMessage) {
					this.ticksWaited.set(0);
				}
			}
		}
	}

	/**
	 * Called on each game tick - checks if we should send notification
	 */
	public void onGameTick() {
		if (!this.seenGameMessage && this.petName == null) {
			return;
		}

		// We need the personal game message to confirm it's actually a pet drop
		// But we may have gotten clan info first, so wait for game message
		if (!this.seenGameMessage) {
			int ticks = this.ticksWaited.incrementAndGet();
			if (ticks > MAX_TICKS_WAIT) {
				// Clan info arrived but no game message - this wasn't our pet
				reset();
			}
			return;
		}

		// We have the game message - check if we have complete info or should wait
		if (this.petName != null) {
			handleNotify();
			reset();
			return;
		}

		// Still waiting for pet name
		int ticks = this.ticksWaited.incrementAndGet();
		if (ticks > MAX_TICKS_WAIT) {
			// Timeout - send notification without pet name
			handleNotify();
			reset();
		}
	}

	/**
	 * Send the pet notification
	 */
	private void handleNotify() {
		if (!isEnabled()) return;

		// Determine if pet was obtained or duplicate based on game message
		boolean obtained = this.gameMessage != null && !this.gameMessage.contains("would have been");

		Map<String, Object> petData = new HashMap<>();
		petData.put("message", this.gameMessage);
		petData.put("obtained", obtained);

		// Add pet name if we have it
		if (this.petName != null && !this.petName.isEmpty()) {
			petData.put("petName", this.petName);
		}

		// Add kill count if available
		if (this.killCount != null && !this.killCount.isEmpty()) {
			petData.put("killCount", this.killCount);
		}

		sendNotification(petData);
	}

	/**
	 * Reset the notifier state
	 */
	public void reset() {
		this.seenGameMessage = false;
		this.gameMessage = null;
		this.petName = null;
		this.killCount = null;
		this.ticksWaited.set(0);
	}

	/**
	 * Set of all known pet names (case-insensitive matching)
	 */
	private static final Set<String> PET_NAMES = new HashSet<>();

	static {
		// Boss pets
		PET_NAMES.add("abyssal orphan");
		PET_NAMES.add("baby mole");
		PET_NAMES.add("baron");
		PET_NAMES.add("bran");
		PET_NAMES.add("butch");
		PET_NAMES.add("callisto cub");
		PET_NAMES.add("dom");
		PET_NAMES.add("gull");
		PET_NAMES.add("hellpuppy");
		PET_NAMES.add("huberte");
		PET_NAMES.add("ikkle hydra");
		PET_NAMES.add("jal-nib-rek");
		PET_NAMES.add("kalphite princess");
		PET_NAMES.add("lil' zik");
		PET_NAMES.add("lil'viathan");
		PET_NAMES.add("little nightmare");
		PET_NAMES.add("moxi");
		PET_NAMES.add("muphin");
		PET_NAMES.add("nexling");
		PET_NAMES.add("nid");
		PET_NAMES.add("noon");
		PET_NAMES.add("olmlet");
		PET_NAMES.add("pet chaos elemental");
		PET_NAMES.add("pet dagannoth prime");
		PET_NAMES.add("pet dagannoth rex");
		PET_NAMES.add("pet dagannoth supreme");
		PET_NAMES.add("pet dark core");
		PET_NAMES.add("pet general graardor");
		PET_NAMES.add("pet k'ril tsutsaroth");
		PET_NAMES.add("pet kraken");
		PET_NAMES.add("pet kree'arra");
		PET_NAMES.add("pet smoke devil");
		PET_NAMES.add("pet snakeling");
		PET_NAMES.add("pet zilyana");
		PET_NAMES.add("phoenix");
		PET_NAMES.add("prince black dragon");
		PET_NAMES.add("scorpia's offspring");
		PET_NAMES.add("scurry");
		PET_NAMES.add("skotos");
		PET_NAMES.add("smolcano");
		PET_NAMES.add("smol heredit");
		PET_NAMES.add("sraracha");
		PET_NAMES.add("tiny tempor");
		PET_NAMES.add("tumeken's guardian");
		PET_NAMES.add("tzrek-jad");
		PET_NAMES.add("venenatis spiderling");
		PET_NAMES.add("vet'ion jr.");
		PET_NAMES.add("vorki");
		PET_NAMES.add("wisp");
		PET_NAMES.add("yami");
		PET_NAMES.add("youngllef");

		// Skill pets
		PET_NAMES.add("baby chinchompa");
		PET_NAMES.add("beaver");
		PET_NAMES.add("giant squirrel");
		PET_NAMES.add("heron");
		PET_NAMES.add("rift guardian");
		PET_NAMES.add("rock golem");
		PET_NAMES.add("rocky");
		PET_NAMES.add("soup");
		PET_NAMES.add("tangleroot");

		// Other pets
		PET_NAMES.add("abyssal protector");
		PET_NAMES.add("bloodhound");
		PET_NAMES.add("chompy chick");
		PET_NAMES.add("herbi");
		PET_NAMES.add("lil' creator");
		PET_NAMES.add("pet penance queen");
		PET_NAMES.add("quetzin");
	}

	/**
	 * Check if an item name is a known pet
	 */
	private boolean isPetItem(String itemName) {
		if (itemName == null || itemName.isEmpty()) return false;

		// Normalize the item name (lowercase, trim)
		String normalized = itemName.toLowerCase().trim();

		// Direct match
		if (PET_NAMES.contains(normalized)) {
			return true;
		}

		// Check if it starts with "pet " and the rest matches
		if (normalized.startsWith("pet ")) {
			String withoutPrefix = normalized.substring(4).trim();
			return PET_NAMES.contains(withoutPrefix) || PET_NAMES.contains(normalized);
		}

		return false;
	}
}

package com.revalclan.notifiers;

import com.revalclan.RevalClanConfig;
import net.runelite.api.Skill;
import net.runelite.api.events.StatChanged;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.Map;

/**
 * Notifies on level ups
 */
@Singleton
public class LevelNotifier extends BaseNotifier {
	@Inject private RevalClanConfig config;

	private final Map<Skill, Integer> previousLevels = new EnumMap<>(Skill.class);
	private final Map<Skill, Integer> previousXp = new EnumMap<>(Skill.class);

	@Override
	public boolean isEnabled() {
		return config.notifyLevel() && filterManager.getFilters().isLevelEnabled();
	}

	@Override
	protected String getEventType() {
		return "LEVEL";
	}

	public void onStatChanged(StatChanged event) {
		if (!isEnabled()) return;

		Skill skill = event.getSkill();
		int newLevel = event.getLevel();
		int newXp = event.getXp();

		// Initialize if first time seeing this skill
		if (!previousLevels.containsKey(skill)) {
			previousLevels.put(skill, newLevel);
			previousXp.put(skill, newXp);
			return;
		}

		int oldLevel = previousLevels.get(skill);
		int oldXp = previousXp.get(skill);

		// Update tracking
		previousLevels.put(skill, newLevel);
		previousXp.put(skill, newXp);

		// Check for level up
		if (newLevel > oldLevel && newXp > oldXp) {
			handleLevelUp(skill, newLevel, newXp);
		}
	}

	private void handleLevelUp(Skill skill, int level, int xp) {
		int totalLevel = client.getTotalLevel();
		long totalXp = client.getOverallExperience();
		int combatLevel = client.getLocalPlayer() != null ? client.getLocalPlayer().getCombatLevel() : 0;

		Map<String, Object> levelData = new HashMap<>();
		levelData.put("skill", skill.getName());
		levelData.put("level", level);
		levelData.put("experience", xp);
		levelData.put("totalLevel", totalLevel);
		levelData.put("totalExperience", totalXp);
		levelData.put("combatLevel", combatLevel);

		sendNotification(levelData);
	}

	public void reset() {
		previousLevels.clear();
		previousXp.clear();
	}
}


package com.revalclan.notifiers;

import com.revalclan.RevalClanConfig;
import com.revalclan.util.ClanValidator;
import com.revalclan.util.EventFilterManager;
import com.revalclan.util.WebhookService;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemContainer;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.game.ItemManager;

import javax.inject.Inject;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Base class for all notification types (loot, death, pets, etc.)
 */
@Slf4j
public abstract class BaseNotifier {
	@Inject protected Client client;

	@Inject protected WebhookService webhookService;

	@Inject protected RevalClanConfig config;

	@Inject protected EventFilterManager filterManager;
	
	@Inject protected ItemManager itemManager;

	/**
	 * Check if this notifier should be active
	 * @return true if the notifier is enabled and conditions are met
	 */
	public abstract boolean isEnabled();

	/**
	 * Get the event type identifier for this notifier
	 * @return Event type string (e.g., "LOOT", "DEATH", "PET")
	 */
	protected abstract String getEventType();

	/**
	 * Send a notification with the given data
	 * 
	 * @param data The notification data
	 */
	protected void sendNotification(Map<String, Object> data) {
		if (!ClanValidator.validateClan(client)) return;

		// Add event metadata
		data.put("eventType", getEventType());
		data.put("eventTimestamp", System.currentTimeMillis());
		data.put("accountHash", client.getAccountHash());
		data.put("username", getPlayerName());
		
		if (client.getLocalPlayer() != null) {
			WorldPoint wp = client.getLocalPlayer().getWorldLocation();
			data.put("worldX", wp.getX());
			data.put("worldY", wp.getY());
			data.put("plane", wp.getPlane());
			data.put("regionId", wp.getRegionID());
		}
		
		data.put("inventory", getInventoryData());
		data.put("equipment", getEquippedItems());
		
		// Send webhook
		webhookService.sendDataAsync(data);
	}

	/**
	 * Get the player's name
	 */
	protected String getPlayerName() {
		if (client.getLocalPlayer() != null) return client.getLocalPlayer().getName();
		return "Unknown";
	}
	
	/**
	 * Get player's equipped items using the equipment ItemContainer
	 */
	protected List<Map<String, Object>> getEquippedItems() {
		return getItemContainerData(94); // Equipment container
	}
	
	/**
	 * Get player's inventory data
	 */
	protected List<Map<String, Object>> getInventoryData() {
		return getItemContainerData(93); // Inventory container
	}
	
	/**
	 * Get items from a specific ItemContainer
	 * @param containerId The container ID (93=inventory, 94=equipment)
	 */
	private List<Map<String, Object>> getItemContainerData(int containerId) {
		List<Map<String, Object>> items = new ArrayList<>();
		
		ItemContainer container = client.getItemContainer(containerId);
		if (container == null) return items;
		
		Item[] containerItems = container.getItems();
		if (containerItems == null) return items;
		
		for (int i = 0; i < containerItems.length; i++) {
			Item item = containerItems[i];
			
			// Skip empty slots
			if (item.getId() <= 0 || item.getQuantity() <= 0) continue;
			
			Map<String, Object> itemData = new HashMap<>();
			itemData.put("id", item.getId());
			itemData.put("quantity", item.getQuantity());
			itemData.put("gePrice", itemManager.getItemPrice(item.getId()));
			itemData.put("slot", i);
			
			try {
				ItemComposition itemComp = itemManager.getItemComposition(item.getId());
				if (itemComp != null) {
					itemData.put("name", itemComp.getName());
				} else {
					itemData.put("name", "Unknown");
				}
			} catch (Exception e) {
				itemData.put("name", "Unknown");
			}
			
			items.add(itemData);
		}
		
		return items;
	}
}


/*
 * Portions of this file are derived from or inspired by the Dink plugin
 * Copyright (c) 2022, Jake Barter
 * Copyright (c) 2022, pajlads
 * Licensed under the BSD 2-Clause License
 * See LICENSES/dink-LICENSE.txt for full license text
 */
package com.revalclan.notifiers;

import com.revalclan.RevalClanConfig;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Singleton
public class CollectionNotifier extends BaseNotifier {
	private static final Pattern COLLECTION_PATTERN = Pattern.compile(
		"New item added to your collection log: (?<item>.+)",
		Pattern.CASE_INSENSITIVE
	);

	@Inject private RevalClanConfig config;

	@Override
	public boolean isEnabled() {
		return config.notifyCollection() && filterManager.getFilters().isCollectionEnabled();
	}

	@Override
	protected String getEventType() {
		return "COLLECTION";
	}

	public void onChatMessage(String message) {
		if (!isEnabled()) return;

		Matcher matcher = COLLECTION_PATTERN.matcher(message);
		if (matcher.find()) {
			String itemName = matcher.group("item");
			handleCollectionItem(itemName);
		}
	}

	private void handleCollectionItem(String itemName) {
		Map<String, Object> collectionData = new HashMap<>();
		collectionData.put("item", itemName);

		sendNotification(collectionData);
	}
}

package com.revalclan.notifiers;

import com.revalclan.RevalClanConfig;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.time.Duration;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Notifies on boss kill counts
 * Portions inspired by Dink plugin (BSD 2-Clause License)
 */
@Slf4j
@Singleton
public class KillCountNotifier extends BaseNotifier {
	// Primary pattern: "Your <boss> kill/chest/completion count is: <count>"
	private static final Pattern PRIMARY_REGEX = Pattern.compile(
		"Your (?<key>.+?)\\s+(?<type>kill|chest|completion|harvest|success|opened)\\s?count is:?\\s*(?<value>[\\d,]+)\\b",
		Pattern.CASE_INSENSITIVE
	);
	
	// Secondary pattern: "Your completed <raid> count is: <count>"
	private static final Pattern SECONDARY_REGEX = Pattern.compile(
		"Your (?:completed|subdued) (?<key>.+) count is: (?<value>[\\d,]+)\\b",
		Pattern.CASE_INSENSITIVE
	);
	
	// Time pattern: "Duration: <time>" or "Time: <time> (Personal best: <pb>)"
	private static final Pattern TIME_REGEX = Pattern.compile(
		"(?:Duration|time|Subdued in):?\\s*(?<time>[\\d:]+(?:\\.\\d+)?)\\.?(?:\\s*\\(new personal best\\))?(?:\\s*Personal best:\\s*(?<pbtime>[\\d:]+(?:\\.\\d+)?))?",
		Pattern.CASE_INSENSITIVE
	);

	@Inject private RevalClanConfig config;
	
	private String pendingBoss = null;
	private Integer pendingCount = null;
	private Duration pendingTime = null;
	private boolean pendingIsPb = false;
	private int badTicks = 0;
	private static final int MAX_BAD_TICKS = 10;

	@Override
	public boolean isEnabled() {
		return config.notifyKillCount() && filterManager.getFilters().isKillCountEnabled();
	}

	@Override
	protected String getEventType() {
		return "KILL_COUNT";
	}

	public void onChatMessage(String message) {
		if (!isEnabled()) return;
		
		// Skip preparation messages
		if (message.startsWith("Preparation")) return;

		// Try to parse boss kill count
		parseBossKillCount(message);
		
		// Try to parse time/duration
		parseTime(message);
	}
	
	/**
	 * Called on game tick to check if we have complete data to send
	 */
	public void onTick() {
		if (pendingBoss != null && pendingCount != null) {
			// We have boss name and count - send notification
			sendKillCountNotification();
			reset();
		} else if (pendingTime != null || pendingBoss != null || pendingCount != null) {
			// We have partial data - wait a bit for the rest
			badTicks++;
			if (badTicks > MAX_BAD_TICKS) {
				// Timeout - reset and give up
				reset();
			}
		}
	}

	private void parseBossKillCount(String message) {
		// Try primary pattern first
		Matcher primary = PRIMARY_REGEX.matcher(message);
		if (primary.find()) {
			String rawBoss = primary.group("key");
			String type = primary.group("type");
			String countStr = primary.group("value").replace(",", "");
			
			String boss = normalizeBossName(rawBoss, type);
			if (boss != null) {
				try {
					int count = Integer.parseInt(countStr);
					pendingBoss = boss;
					pendingCount = count;
					badTicks = 0; // Reset bad tick counter
				} catch (NumberFormatException e) {
					log.debug("Failed to parse kill count: {}", countStr);
				}
			}
			return;
		}
		
		// Try secondary pattern (raids)
		Matcher secondary = SECONDARY_REGEX.matcher(message);
		if (secondary.find()) {
			String rawBoss = secondary.group("key");
			String countStr = secondary.group("value").replace(",", "");
			
			String boss = normalizeRaidName(rawBoss);
			if (boss != null) {
				try {
					int count = Integer.parseInt(countStr);
					pendingBoss = boss;
					pendingCount = count;
					badTicks = 0;
				} catch (NumberFormatException e) {
					log.debug("Failed to parse kill count: {}", countStr);
				}
			}
		}
	}
	
	private void parseTime(String message) {
		// TOB special case: skip wave duration, get challenge time
		String msg = message;
		if (message.startsWith("Wave")) {
			int tobIndex = message.indexOf("Theatre of Blood");
			if (tobIndex > 0) {
				msg = message.substring(tobIndex);
				if (pendingBoss == null) {
					pendingBoss = "Theatre of Blood";
				}
				log.debug("TOB wave message detected - extracted: {}", msg);
			}
		}
		
		Matcher matcher = TIME_REGEX.matcher(msg);
		if (matcher.find()) {
			String timeStr = matcher.group("time");
			
			Duration duration = parseTimeString(timeStr);
			
			if (duration != null) {
				pendingTime = duration;
				pendingIsPb = msg.toLowerCase().contains("(new personal best)") || 
				              msg.toLowerCase().contains("new personal best");
				badTicks = 0;
			} else {
				log.debug("Failed to parse time string: {}", timeStr);
			}
		}
	}
	
	/**
	 * Normalize boss names based on message type
	 */
	private String normalizeBossName(String boss, String type) {
		if (boss == null) return null;
		
		switch (type.toLowerCase()) {
			case "chest":
				if ("Barrows".equalsIgnoreCase(boss)) return "Barrows";
				if ("Lunar".equals(boss)) return "Lunar Chest";
				return null;
				
			case "completion":
				if ("Gauntlet".equalsIgnoreCase(boss)) return "Crystalline Hunllef";
				if ("Corrupted Gauntlet".equalsIgnoreCase(boss)) return "Corrupted Hunllef";
				return null;
				
			case "harvest":
				if ("Herbiboar".equalsIgnoreCase(boss)) return "Herbiboar";
				return null;
				
			case "kill":
			case "success":
			case "opened":
				return boss;
				
			default:
				return null;
		}
	}
	
	/**
	 * Normalize raid names
	 */
	private String normalizeRaidName(String raid) {
		if (raid == null) return null;
		
		if ("Wintertodt".equalsIgnoreCase(raid)) return "Wintertodt";
		
		// Handle raid modes (e.g., "Theatre of Blood: Entry Mode")
		int modeSeparator = raid.lastIndexOf(':');
		String raidName = modeSeparator > 0 ? raid.substring(0, modeSeparator).trim() : raid;
		
		if (raidName.equalsIgnoreCase("Theatre of Blood") ||
		    raidName.equalsIgnoreCase("Tombs of Amascut") ||
		    raidName.equalsIgnoreCase("Chambers of Xeric") ||
		    raid.equalsIgnoreCase("Chambers of Xeric Challenge Mode")) {
			return raid; // Return full name with mode
		}
		
		return null;
	}
	
	/**
	 * Parse time string like "1:23" or "1:23.45" into Duration
	 */
	private Duration parseTimeString(String timeStr) {
		if (timeStr == null) return null;
		
		try {
			String[] parts = timeStr.split(":");
			if (parts.length == 2) {
				int minutes = Integer.parseInt(parts[0]);
				double seconds = Double.parseDouble(parts[1]);
				long totalMillis = (minutes * 60 * 1000L) + (long)(seconds * 1000);
				return Duration.ofMillis(totalMillis);
			} else if (parts.length == 3) {
				int hours = Integer.parseInt(parts[0]);
				int minutes = Integer.parseInt(parts[1]);
				double seconds = Double.parseDouble(parts[2]);
				long totalMillis = (hours * 3600 * 1000L) + (minutes * 60 * 1000L) + (long)(seconds * 1000);
				return Duration.ofMillis(totalMillis);
			}
		} catch (NumberFormatException e) {
			log.debug("Failed to parse time: {}", timeStr);
		}
		
		return null;
	}
	
	private void sendKillCountNotification() {
		Map<String, Object> kcData = new HashMap<>();
		kcData.put("boss", pendingBoss);
		kcData.put("killCount", pendingCount);
		
		if (pendingTime != null) {
			kcData.put("time", formatDuration(pendingTime));
			kcData.put("timeSeconds", pendingTime.getSeconds() + (pendingTime.getNano() / 1_000_000_000.0));
		}
		
		if (pendingIsPb) {
			kcData.put("personalBest", true);
		}

		sendNotification(kcData);
	}
	
	/**
	 * Format duration as MM:SS or HH:MM:SS
	 */
	private String formatDuration(Duration duration) {
		long totalSeconds = duration.getSeconds();
		long hours = totalSeconds / 3600;
		long minutes = (totalSeconds % 3600) / 60;
		long seconds = totalSeconds % 60;
		long millis = duration.getNano() / 1_000_000;
		
		if (hours > 0) {
			return String.format("%d:%02d:%02d.%d", hours, minutes, seconds, millis / 100);
		} else {
			return String.format("%d:%02d.%d", minutes, seconds, millis / 100);
		}
	}

	public void reset() {
		pendingBoss = null;
		pendingCount = null;
		pendingTime = null;
		pendingIsPb = false;
		badTicks = 0;
	}
}


package com.revalclan.notifiers;

import com.revalclan.RevalClanConfig;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;

/**
 * Notifier for system chat messages - excludes player chats, private messages, clan chats, etc.
 * Useful for tracking game events, broadcasts, and system notifications for bingo/challenges.
 */
@Slf4j
@Singleton
public class ChatNotifier extends BaseNotifier {
	@Inject private RevalClanConfig config;
	
	/**
	 * Chat message types that are considered "system" messages.
	 * These are game-generated messages, not player-typed chats.
	 */
	private static final Set<ChatMessageType> SYSTEM_MESSAGE_TYPES = EnumSet.of(
		ChatMessageType.GAMEMESSAGE,      // General game messages (most common)
		ChatMessageType.SPAM,             // Spam filter messages (loot, drops, etc.)
		ChatMessageType.ENGINE,           // Engine messages
		ChatMessageType.CONSOLE,          // Console messages
		ChatMessageType.MESBOX,           // Message boxes (NPC dialog, etc.)
		ChatMessageType.DIALOG,           // Dialog messages
    ChatMessageType.OBJECT_EXAMINE,   // Object examine messages
    ChatMessageType.NPC_SAY,          // NPC say messages
    ChatMessageType.NPC_EXAMINE       // NPC examine messages
	);
	
	@Override
	public boolean isEnabled() {
		return config.notifyChat() && filterManager.getFilters().isChatEnabled();
	}
	
	@Override
	protected String getEventType() {
		return "CHAT";
	}
	
	/**
	 * Handle a chat message event
	 * @param messageType The type of chat message
	 * @param source The source/sender of the message (can be null for system messages)
	 * @param message The message content
	 */
	public void onChatMessage(ChatMessageType messageType, String source, String message) {
		if (!isEnabled()) return;

		if (!SYSTEM_MESSAGE_TYPES.contains(messageType)) return;

		String cleanMessage = cleanMessage(message);

		List<String> patterns = filterManager.getFilters().getChatPatterns();

		if (!patterns.isEmpty() && !hasMatch(cleanMessage, patterns)) {
			return;
		}
		
		handleNotify(messageType, source, cleanMessage);
	}
	
	/**
	 * Clean HTML tags and formatting from a message
	 */
	private String cleanMessage(String message) {
		if (message == null) return "";
		return message
			.replaceAll("<col=[0-9a-fA-F]+>", "")
			.replaceAll("</col>", "")
			.replaceAll("<br>", " ")
			.replaceAll("<[^>]+>", "")
			.trim();
	}
	
	/**
	 * Check if the message matches any configured patterns
	 * @param message The message to check
	 * @param patterns List of regex pattern strings from the API
	 */
	private boolean hasMatch(String message, List<String> patterns) {
		for (String patternStr : patterns) {
			try {
				Pattern pattern = Pattern.compile(patternStr, Pattern.CASE_INSENSITIVE);
				if (pattern.matcher(message).find()) {
					return true;
				}
			} catch (Exception e) {
				log.warn("Invalid chat pattern from API: {}", patternStr);
			}
		}
		return false;
	}
	
	/**
	 * Send a chat notification
	 */
	private void handleNotify(ChatMessageType messageType, String source, String message) {
		Map<String, Object> chatData = new HashMap<>();
		chatData.put("messageType", messageType.name());
		chatData.put("message", message);
		
		if (source != null && !source.isEmpty()) {
			chatData.put("source", source);
		}
		
		chatData.put("category", categorizeMessage(messageType, message));
		
		sendNotification(chatData);
	}
	
	/**
	 * Categorize the message type for easier processing
	 */
	private String categorizeMessage(ChatMessageType type, String message) {
		switch (type) {
			case GAMEMESSAGE:
			case ENGINE:
				return "GAME";
			case SPAM:
				return "SPAM";
			case CONSOLE:
				return "CONSOLE";
			case MESBOX:
			case DIALOG:
				return "DIALOG";
			case OBJECT_EXAMINE:
			case NPC_EXAMINE:
				return "EXAMINE";
			case NPC_SAY:
				return "NPC";
			default:
				return "OTHER";
		}
	}
}

package com.revalclan.notifiers;

import com.revalclan.RevalClanConfig;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Singleton
public class CombatAchievementNotifier extends BaseNotifier {
	private static final Pattern CA_PATTERN = Pattern.compile(
		"Congratulations, you've completed an? (?<tier>\\w+) combat task: (?<task>.+)\\.",
		Pattern.CASE_INSENSITIVE
	);

	@Inject private RevalClanConfig config;

	@Override 
	public boolean isEnabled() {
		return config.notifyCombatAchievement() && filterManager.getFilters().isCombatAchievementEnabled();
	}

	@Override
	protected String getEventType() {
		return "COMBAT_ACHIEVEMENT";
	}

	public void onChatMessage(String message) {
		if (!isEnabled()) return;

		Matcher matcher = CA_PATTERN.matcher(message);
		if (matcher.find()) {
			String tier = matcher.group("tier");
			String task = matcher.group("task");

			handleCombatAchievement(tier, task);
		}
	}

	private void handleCombatAchievement(String tier, String task) {
		task = task.replaceAll("\\s+\\(\\d+ points?\\)$", "");

		Map<String, Object> caData = new HashMap<>();
		caData.put("tier", tier);
		caData.put("task", task);

		sendNotification(caData);
	}
}


package com.revalclan.notifiers;

import java.util.Map;

import javax.inject.Inject;
import javax.inject.Singleton;

import com.revalclan.PlayerDataCollector;

/**
 * Handles logout events.
 * Triggers a full account sync when the player logs out.
 */
@Singleton
public class LogoutNotifier extends BaseNotifier {
	@Inject
	private PlayerDataCollector dataCollector;

	@Override
	public boolean isEnabled() {
		return true;
	}

	@Override
	protected String getEventType() {
		return "LOGOUT";
	}

	/**
	 * Called when the player logs out.
	 * Triggers a full account sync.
	 */
	public void onLogout() {
		Map<String, Object> data = dataCollector.collectAllData();
		sendNotification(data);
	}
}


package com.revalclan.notifiers;

import com.revalclan.RevalClanConfig;
import net.runelite.api.Actor;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.Hitsplat;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.client.game.ItemManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

@Singleton
public class DetailedKillNotifier extends BaseNotifier {
	@Inject private RevalClanConfig config;

	@Inject private ItemManager itemManager;

	private final Map<NPC, KillData> activeKills = new ConcurrentHashMap<>();
	
	private int previousSpecEnergy = 100;
	private int specTicksRemaining = 0;
	private String specWeaponName = null;

	@Override
	public boolean isEnabled() {
		return config.notifyDetailedKill() && filterManager.getFilters().isDetailedKillEnabled();
	}

	@Override
	protected String getEventType() {
		return "DETAILED_KILL";
	}

	public void onGameTick(GameTick event) {
		if (!isEnabled()) return;

		int currentSpecEnergy = client.getVarpValue(300);
		
		if (currentSpecEnergy < previousSpecEnergy) {
			Player localPlayer = client.getLocalPlayer();
			if (localPlayer != null) {
				int weaponId = localPlayer.getPlayerComposition().getEquipmentId(net.runelite.api.kit.KitType.WEAPON);
				specWeaponName = weaponId > 0 ? itemManager.getItemComposition(weaponId).getName() : "Unarmed";
				specTicksRemaining = 3;
			}
		} else if (specTicksRemaining > 0) {
			specTicksRemaining--;
			if (specTicksRemaining == 0) {
				specWeaponName = null;
			}
		}
		
		previousSpecEnergy = currentSpecEnergy;
	}

	public void onHitsplatApplied(HitsplatApplied event) {
		if (!isEnabled()) return;

		Actor actor = event.getActor();
		if (!(actor instanceof NPC)) return;

		Hitsplat hitsplat = event.getHitsplat();
		if (!hitsplat.isMine()) return;

		NPC npc = (NPC) actor;
		int damage = hitsplat.getAmount();

		Player localPlayer = client.getLocalPlayer();
		if (localPlayer == null) return;

		int weaponId = localPlayer.getPlayerComposition().getEquipmentId(net.runelite.api.kit.KitType.WEAPON);
		String weaponName = weaponId > 0 ? itemManager.getItemComposition(weaponId).getName() : "Unarmed";

		boolean isSpec = specTicksRemaining > 0 && weaponName.equals(specWeaponName);
		KillData data = activeKills.computeIfAbsent(npc, k -> new KillData(npc.getName(), npc.getId()));
		data.addHit(damage, weaponName, isSpec);
	}

	public void onActorDeath(ActorDeath event) {
		if (!isEnabled()) return;

		Actor actor = event.getActor();
		if (!(actor instanceof NPC)) return;

		NPC npc = (NPC) actor;
		KillData data = activeKills.remove(npc);

		if (data != null && data.totalDamage > 0) {
			handleDetailedKill(data);
		}
	}

	private void handleDetailedKill(KillData data) {
		// Apply filters
		if (!shouldNotifyKill(data.npcId)) {
			return;
		}
		
		Map<String, Object> killData = new HashMap<>();
		killData.put("npcName", data.npcName);
		killData.put("npcId", data.npcId);
		killData.put("totalDamage", data.totalDamage);
		killData.put("hitCount", data.hitCount);
		killData.put("specialAttacks", data.specialAttackCount);
		killData.put("lastHitWeapon", data.lastHitWeapon);
		killData.put("lastHitDamage", data.lastHitDamage);
		killData.put("lastHitWasSpec", data.lastHitWasSpec);
		killData.put("weaponsUsed", new ArrayList<>(data.weaponsUsed.keySet()));
		killData.put("damageByWeapon", data.weaponsUsed);

		sendNotification(killData);
	}
	
	/**
	 * Check if we should notify for this NPC based on filters
	 * Filter priority:
	 * 1. If whitelist has entries and NPC is in whitelist -> ALLOW
	 * 2. If NPC is in blacklist -> DENY
	 * 3. If whitelist is empty -> ALLOW (default behavior)
	 * 4. Otherwise -> DENY
	 */
	private boolean shouldNotifyKill(int npcId) {
		var filters = filterManager.getFilters();
		
		// Check ID whitelist first (highest priority)
		boolean hasIdWhitelist = !filters.getDetailedKillNpcIdWhitelist().isEmpty();
		if (hasIdWhitelist && filters.getDetailedKillNpcIdWhitelist().contains(npcId)) {
			return true; // Explicitly whitelisted by ID
		}
		
		// Check ID blacklist
		if (filters.getDetailedKillNpcIdBlacklist().contains(npcId)) {
			return false; // Explicitly blacklisted by ID
		}
		
		// If whitelist exists and NPC wasn't in it, deny
		if (hasIdWhitelist) {
			return false;
		}
		
		// No filters configured, allow all
		return true;
	}

	public void reset() {
		activeKills.clear();
		previousSpecEnergy = 100;
		specTicksRemaining = 0;
		specWeaponName = null;
	}

	private static class KillData {
		final String npcName;
		final int npcId;
		int totalDamage = 0;
		int hitCount = 0;
		int specialAttackCount = 0;
		String lastHitWeapon = "Unknown";
		int lastHitDamage = 0;
		boolean lastHitWasSpec = false;
		final Map<String, Integer> weaponsUsed = new HashMap<>();

		KillData(String npcName, int npcId) {
			this.npcName = npcName;
			this.npcId = npcId;
		}

		void addHit(int damage, String weapon, boolean isSpec) {
			totalDamage += damage;
			hitCount++;
			lastHitWeapon = weapon;
			lastHitDamage = damage;
			lastHitWasSpec = isSpec;

			if (isSpec) {
				specialAttackCount++;
			}

			weaponsUsed.merge(weapon, damage, Integer::sum);
		}
	}
}


/*
 * Portions of this file are derived from or inspired by the Dink plugin
 * Copyright (c) 2022, Jake Barter
 * Copyright (c) 2022, pajlads
 * Licensed under the BSD 2-Clause License
 * See LICENSES/dink-LICENSE.txt for full license text
 */
package com.revalclan.notifiers;

import com.revalclan.RevalClanConfig;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.game.ItemManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Singleton
public class ClueNotifier extends BaseNotifier {
	private static final Pattern CLUE_PATTERN = Pattern.compile(
		"You have completed (?<count>\\d+) (?<tier>\\w+) Treasure Trails?\\.",
		Pattern.CASE_INSENSITIVE
	);

	@Inject private RevalClanConfig config;

	@Inject private ItemManager itemManager;

	private int clueCount = -1;
	private String clueTier = "";

	@Override
	public boolean isEnabled() {
		return config.notifyClue() && filterManager.getFilters().isClueEnabled();
	}

	@Override
	protected String getEventType() {
		return "CLUE";
	}

	public void onChatMessage(String message) {
		if (!isEnabled()) return;

		Matcher matcher = CLUE_PATTERN.matcher(message);
		if (matcher.find()) {
			clueCount = Integer.parseInt(matcher.group("count"));
			clueTier = matcher.group("tier");
		}
	}

	public void onWidgetLoaded(WidgetLoaded event) {
		if (!isEnabled()) return;

		if (event.getGroupId() == InterfaceID.TRAIL_REWARDSCREEN && !clueTier.isEmpty()) {
			Widget clueWidget = client.getWidget(InterfaceID.TrailRewardscreen.ITEMS);
			if (clueWidget != null) {
				Widget[] children = clueWidget.getChildren();
				if (children == null) return;

				List<Map<String, Object>> items = new ArrayList<>();
				long totalValue = 0;

				for (Widget child : children) {
					if (child == null) continue;

					int quantity = child.getItemQuantity();
					int itemId = child.getItemId();
					if (itemId > -1 && quantity > 0) {
						int price = itemManager.getItemPrice(itemId);
						String name = itemManager.getItemComposition(itemId).getName();

						Map<String, Object> item = new HashMap<>();
						item.put("id", itemId);
						item.put("name", name);
						item.put("quantity", quantity);
						item.put("price", price);
						items.add(item);

						totalValue += (long) price * quantity;
					}
				}

				handleClueCompletion(items, totalValue);
			}
		}
	}

	private void handleClueCompletion(List<Map<String, Object>> items, long totalValue) {
		Map<String, Object> clueData = new HashMap<>();
		clueData.put("tier", clueTier);
		clueData.put("count", clueCount);
		clueData.put("totalValue", totalValue);
		clueData.put("items", items);

		sendNotification(clueData);

		clueCount = -1;
		clueTier = "";
	}

	public void reset() {
		clueCount = -1;
		clueTier = "";
	}
}


package com.revalclan.diaries;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.Map;

/**
 * Manages achievement diary progress
 */
@Slf4j
@Singleton
public class AchievementDiaryManager {
	@Inject
	private Client client;

	private final Map<String, Map<String, Integer>> diaryVarbits = new HashMap<>();

	public AchievementDiaryManager() {
		initializeDiaryVarbits();
	}

	/**
	 * Initialize all diary varbit mappings
	 */
	private void initializeDiaryVarbits() {
		Map<String, Integer> ardougne = new HashMap<>();
		ardougne.put("easy", 4458);
		ardougne.put("medium", 4459);
		ardougne.put("hard", 4460);
		ardougne.put("elite", 4461);
		diaryVarbits.put("Ardougne", ardougne);
		
		Map<String, Integer> desert = new HashMap<>();
		desert.put("easy", 4483);
		desert.put("medium", 4484);
		desert.put("hard", 4485);
		desert.put("elite", 4486);
		diaryVarbits.put("Desert", desert);

		Map<String, Integer> falador = new HashMap<>();
		falador.put("easy", 4462);
		falador.put("medium", 4463);
		falador.put("hard", 4464);
		falador.put("elite", 4465);
		diaryVarbits.put("Falador", falador);

		Map<String, Integer> fremennik = new HashMap<>();
		fremennik.put("easy", 4491);
		fremennik.put("medium", 4492);
		fremennik.put("hard", 4493);
		fremennik.put("elite", 4494);
		diaryVarbits.put("Fremennik", fremennik);

		Map<String, Integer> kandarin = new HashMap<>();
		kandarin.put("easy", 4475);
		kandarin.put("medium", 4476);
		kandarin.put("hard", 4477);
		kandarin.put("elite", 4478);
		diaryVarbits.put("Kandarin", kandarin);

		Map<String, Integer> karamja = new HashMap<>();
		karamja.put("easy", 3578);
		karamja.put("medium", 3599);
		karamja.put("hard", 3611);
		karamja.put("elite", 4566);
		diaryVarbits.put("Karamja", karamja);
		
		Map<String, Integer> kourend = new HashMap<>();
		kourend.put("easy", 7925);
		kourend.put("medium", 7926);
		kourend.put("hard", 7927);
		kourend.put("elite", 7928);
		diaryVarbits.put("Kourend", kourend);
		
		Map<String, Integer> lumbridge = new HashMap<>();
		lumbridge.put("easy", 4495);
		lumbridge.put("medium", 4496);
		lumbridge.put("hard", 4497);
		lumbridge.put("elite", 4498);
		diaryVarbits.put("Lumbridge", lumbridge);

		Map<String, Integer> morytania = new HashMap<>();
		morytania.put("easy", 4487);
		morytania.put("medium", 4488);
		morytania.put("hard", 4489);
		morytania.put("elite", 4490);
		diaryVarbits.put("Morytania", morytania);

		Map<String, Integer> varrock = new HashMap<>();
		varrock.put("easy", 4479);
		varrock.put("medium", 4480);
		varrock.put("hard", 4481);
		varrock.put("elite", 4482);
		diaryVarbits.put("Varrock", varrock);
		
		Map<String, Integer> western = new HashMap<>();
		western.put("easy", 4471);
		western.put("medium", 4472);
		western.put("hard", 4473);
		western.put("elite", 4474);
		diaryVarbits.put("Western", western);
		
		Map<String, Integer> wilderness = new HashMap<>();
		wilderness.put("easy", 4466);
		wilderness.put("medium", 4467);
		wilderness.put("hard", 4468);
		wilderness.put("elite", 4469);
		diaryVarbits.put("Wilderness", wilderness);
	}

	/**
	 * Sync and get achievement diary progress data
	 */
	public Map<String, Object> sync() {
		Map<String, Object> diaryData = new HashMap<>();
		Map<String, Map<String, Boolean>> diaryProgress = new HashMap<>();
		
		int totalCompleted = 0;
		
		for (Map.Entry<String, Map<String, Integer>> regionEntry : diaryVarbits.entrySet()) {
			String region = regionEntry.getKey();
			Map<String, Boolean> tierProgress = new HashMap<>();
			
			for (Map.Entry<String, Integer> tierEntry : regionEntry.getValue().entrySet()) {
				String tier = tierEntry.getKey();
				int varbitId = tierEntry.getValue();
				int value = client.getVarbitValue(varbitId);
				
				// Karamja Easy (3578), Medium (3599), Hard (3611) special case
				// 0 = not started, 1 = started, 2 = completed
				boolean isComplete;
				if (varbitId == 3578 || varbitId == 3599 || varbitId == 3611) {
					isComplete = value > 1;
				} else {
					isComplete = value > 0;
				}
				
				tierProgress.put(tier, isComplete);
				
				if (isComplete) {
					totalCompleted++;
				}
			}
			
			diaryProgress.put(region, tierProgress);
		}
		
		diaryData.put("progress", diaryProgress);
		diaryData.put("totalCompleted", totalCompleted);
		diaryData.put("totalDiaries", 48); // 12 regions * 4 tiers
		
		return diaryData;
	}
}


package com.revalclan.player;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Skill;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.Map;

/**
 * Manages player metadata and statistics
 */
@Slf4j
@Singleton
public class PlayerManager {
	@Inject private Client client;

	/**
	 * Sync and get player metadata
	 */
	public Map<String, Object> sync() {
		Map<String, Object> metadata = new HashMap<>();
		
		if (client.getLocalPlayer() != null) {
			metadata.put("username", client.getLocalPlayer().getName());
			metadata.put("combatLevel", client.getLocalPlayer().getCombatLevel());
		} else {
			metadata.put("username", "Unknown");
			metadata.put("combatLevel", 0);
		}
		
		metadata.put("accountHash", client.getAccountHash());
		metadata.put("totalLevel", client.getTotalLevel());
		metadata.put("totalExperience", client.getOverallExperience());
		
		Map<String, Map<String, Integer>> skills = new HashMap<>();
		for (Skill skill : Skill.values()) {
			Map<String, Integer> skillData = new HashMap<>();
			skillData.put("level", client.getRealSkillLevel(skill));
			skillData.put("experience", client.getSkillExperience(skill));
			skills.put(skill.getName().toLowerCase(), skillData);
		}
		metadata.put("skills", skills);
		
		return metadata;
	}
}

package com.revalclan.collectionlog;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Represents a collection log item that the player has obtained
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ObtainedCollectionItem {
	private int id;
	private String name;
	private int count;

	public ObtainedCollectionItem(int id, int count) {
		this.id = id;
		this.count = count;
	}
}


/*
 * Portions of this file are derived from or inspired by the TempleOSRS plugin
 * Copyright (c) 2022, SMaloney2017
 * Licensed under the BSD 2-Clause License
 * See LICENSES/templeOSRS-LICENSE.txt for full license text
 */
package com.revalclan.collectionlog;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

/**
 * All available category groups (i.e. tabs) mapped to their in-game struct IDs
 */
@RequiredArgsConstructor
public enum CollectionLogCategoryGroup {
	BOSSES(471),
	RAIDS(472),
	CLUES(473),
	MINIGAMES(474),
	OTHER(475);

	@Getter private final int structId;
	
	/**
	 * Get the category name (capitalized) from struct ID
	 * @param structId The struct ID to lookup
	 * @return The category name with first letter capitalized, or "Unknown" if not found
	 */
	public static String getNameFromStructId(int structId) {
		for (CollectionLogCategoryGroup group : values()) {
			if (group.structId == structId) {
				String name = group.name().toLowerCase();
				return name.substring(0, 1).toUpperCase() + name.substring(1);
			}
		}

		return "Unknown";
	}
}

/*
 * Portions of this file are derived from or inspired by the RuneProfile plugin
 * Copyright (c) RuneProfile
 * Licensed under the BSD 2-Clause License
 */
package com.revalclan.collectionlog;

import com.revalclan.notifiers.SyncNotifier;
import com.revalclan.util.ClanValidator;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;

/**
 * Adds a "Sync Reval" button to the collection log dropdown menu
 * Similar to RuneProfile's implementation, in order to avoid overlapping buttons
 */
@Slf4j
@Singleton
public class CollectionLogSyncButton {
	private static final int DRAW_BURGER_MENU = 7812;
	private static final int FONT_COLOR = 0xFF981F;
	private static final int FONT_COLOR_ACTIVE = 0xFFFFFF;
	private static final String BUTTON_TEXT = "Sync Reval";
	private static final int SYNC_DELAY_TICKS = 3; // Wait 3 ticks for search to complete

	@Inject
	private Client client;

	@Inject
	private EventBus eventBus;

	@Inject
	private CollectionLogManager collectionLogManager;

	@Inject
	private SyncNotifier syncNotifier;

	private int baseMenuHeight = -1;
	private int lastAttemptedSync = -1;
	private int pendingSyncTick = -1;

	public void startUp() {
		eventBus.register(this);
	}

	public void shutDown() {
		eventBus.unregister(this);
	}

	@Subscribe
	public void onScriptPreFired(ScriptPreFired event) {
		if (event.getScriptId() != DRAW_BURGER_MENU) {
			return;
		}

		Object[] args = event.getScriptEvent().getArguments();
		int menuId = (int) args[3];

		try {
			addButton(menuId, this::onButtonClick);
		} catch (Exception e) {
			log.debug("Failed to add Reval button to menu: {}", e.getMessage());
		}
	}

	private void onButtonClick() {
		// Rate limit: 30 seconds between syncs
		if (lastAttemptedSync != -1 && lastAttemptedSync + 50 > client.getTickCount()) {
			int secondsRemaining = (int) Math.round((lastAttemptedSync + 50 - client.getTickCount()) * 0.6);
			client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", 
				"Reval: Please wait " + secondsRemaining + " seconds before syncing again.", "");
			return;
		}
		lastAttemptedSync = client.getTickCount();

		// Validate clan membership
		if (!ClanValidator.validateClan(client)) {
			client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Reval: You must be in the Reval clan to sync.", "");
			return;
		}

		// Clear existing data and trigger collection log scan
		collectionLogManager.clearObtainedItems();

		// Trigger the search to scan all items
		client.menuAction(-1, 40697932, MenuAction.CC_OP, 1, -1, "Search", null);
		client.runScript(2240);

		client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Reval: Scanning collection log...", "");

		// Schedule the sync after a short delay to allow the search to populate items
		scheduleSync();
	}

	private void scheduleSync() {
		pendingSyncTick = client.getTickCount() + SYNC_DELAY_TICKS;
	}

	@Subscribe
	public void onGameTick(GameTick event) {
		if (pendingSyncTick != -1 && client.getTickCount() >= pendingSyncTick) {
			pendingSyncTick = -1;
			performSync();
		}
	}

	private void performSync() {
		try {
			syncNotifier.triggerSync();
			client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", 
				"Reval: Synced account data successfully!", "");
		} catch (Exception e) {
			client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Reval: Failed to sync. Please try again.", "");
		}
	}

	private void addButton(int menuId, Runnable onClick) throws NullPointerException, NoSuchElementException {
		// Don't add button if viewing from POH adventure log (viewing someone else's log)
		boolean isOpenedFromAdventureLog = client.getVarbitValue(VarbitID.COLLECTION_POH_HOST_BOOK_OPEN) == 1;
		if (isOpenedFromAdventureLog) return;

		Widget menu = Objects.requireNonNull(client.getWidget(menuId));
		Widget[] menuChildren = Objects.requireNonNull(menu.getChildren());

		if (baseMenuHeight == -1) {
			baseMenuHeight = menu.getOriginalHeight();
		}

		// Find the last rectangle and text widgets to use as templates
		List<Widget> reversedMenuChildren = new ArrayList<>(Arrays.asList(menuChildren));
		Collections.reverse(reversedMenuChildren);
		
		Widget lastRectangle = reversedMenuChildren.stream()
			.filter(w -> w.getType() == WidgetType.RECTANGLE)
			.findFirst()
			.orElseThrow(() -> new NoSuchElementException("No RECTANGLE widget found in menu"));
		
		Widget lastText = reversedMenuChildren.stream()
			.filter(w -> w.getType() == WidgetType.TEXT)
			.findFirst()
			.orElseThrow(() -> new NoSuchElementException("No TEXT widget found in menu"));

		final int buttonHeight = lastRectangle.getHeight();
		final int buttonY = lastRectangle.getOriginalY() + buttonHeight;

		// Check if button already exists
		final boolean existingButton = Arrays.stream(menuChildren)
			.anyMatch(w -> w.getText() != null && w.getText().equals(BUTTON_TEXT));

		if (!existingButton) {
			// Create background rectangle
			final Widget background = menu.createChild(WidgetType.RECTANGLE)
				.setOriginalWidth(lastRectangle.getOriginalWidth())
				.setOriginalHeight(lastRectangle.getOriginalHeight())
				.setOriginalX(lastRectangle.getOriginalX())
				.setOriginalY(buttonY)
				.setOpacity(lastRectangle.getOpacity())
				.setFilled(lastRectangle.isFilled());
			background.revalidate();

			// Create text button
			final Widget text = menu.createChild(WidgetType.TEXT)
				.setText(BUTTON_TEXT)
				.setTextColor(FONT_COLOR)
				.setFontId(lastText.getFontId())
				.setTextShadowed(lastText.getTextShadowed())
				.setOriginalWidth(lastText.getOriginalWidth())
				.setOriginalHeight(lastText.getOriginalHeight())
				.setOriginalX(lastText.getOriginalX())
				.setOriginalY(buttonY)
				.setXTextAlignment(lastText.getXTextAlignment())
				.setYTextAlignment(lastText.getYTextAlignment());
			
			text.setHasListener(true);
			text.setOnMouseOverListener((JavaScriptCallback) ev -> text.setTextColor(FONT_COLOR_ACTIVE));
			text.setOnMouseLeaveListener((JavaScriptCallback) ev -> text.setTextColor(FONT_COLOR));
			text.setAction(0, "Sync collection log to Reval");
			text.setOnOpListener((JavaScriptCallback) ev -> onClick.run());
			text.revalidate();
		}

		// Extend menu height to fit new button
		if (menu.getOriginalHeight() <= baseMenuHeight) {
			menu.setOriginalHeight(menu.getOriginalHeight() + buttonHeight);
		}

		menu.revalidate();
		for (Widget child : menuChildren) {
			child.revalidate();
		}
	}
}

/*
 * Portions of this file are derived from or inspired by the TempleOSRS plugin
 * Copyright (c) 2022, SMaloney2017
 * Licensed under the BSD 2-Clause License
 * See LICENSES/templeOSRS-LICENSE.txt for full license text
 */
package com.revalclan.collectionlog;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.EnumComposition;
import net.runelite.api.StructComposition;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;
import java.util.regex.Pattern;

/**
 * Manages collection log data by reading directly from the game cache
 * Based on Temple OSRS implementation
 */
@Slf4j
@Singleton
public class CollectionLogManager {
	@Inject private Client client;

	/**
	 * Maps in-game category struct IDs to the list of items they contain
	 */
	@Getter private final Map<Integer, Set<Integer>> categoryItemMap = new HashMap<>();

	/**
	 * Maps slugified category names to their in-game struct ID
	 */
	@Getter private final Map<String, Integer> categoryStructIdMap = new HashMap<>();

	/**
	 * Maps top level tabs to their containing categories
	 */
	@Getter private final Map<Integer, Set<String>> categoryTabSlugs = new LinkedHashMap<>();

	/**
	 * List of all items in the collection log
	 */
	@Getter private final Set<Integer> allCollectionLogItems = new HashSet<>();

	/**
	 * Set of items the player has obtained (populated when collection log is opened)
	 */
	@Getter private final Set<ObtainedCollectionItem> obtainedItems = new HashSet<>();

	/**
	 * Maps category slugs to their KC varbit/varp IDs
	 */
	private final Map<String, KCSource> categoryKCMap = new HashMap<>();
	
	/**
	 * Maps category slugs to additional KC sources (for multi-KC tracking)
	 */
	private final Map<String, Map<String, KCSource>> additionalKCMap = new HashMap<>();
	
	/**
	 * Maps subcategories to their KC calculation rules (for derived KCs like original boss = combined - awakened)
	 * Format: subcategorySlug -> (resultKCName -> [combinedKCName, subtractKCName])
	 */
	private final Map<String, Map<String, String[]>> derivedKCMap = new HashMap<>();
	
	/**
	 * Maps subcategories to their summed KC rules (for derived KCs that are sums of multiple sources)
	 * Format: subcategorySlug -> (resultKCName -> [source1Name, source2Name, ...])
	 */
	private final Map<String, Map<String, String[]>> summedKCMap = new HashMap<>();

	/**
	 * Helper class to store KC source information
	 */
	private static class KCSource {
		final boolean isVarbit;
		final int id;

		KCSource(boolean isVarbit, int id) {
			this.isVarbit = isVarbit;
			this.id = id;
		}
	}
	
	/**
	 * Fluent builder for configuring KC tracking for a subcategory
	 */
	private class KCBuilder {
		private final String subcategory;
		
		KCBuilder(String subcategory) {
			this.subcategory = subcategory;
		}
		
		KCBuilder primaryKC(boolean isVarbit, int id) {
			categoryKCMap.put(subcategory, new KCSource(isVarbit, id));
			return this;
		}
		
		KCBuilder primaryKC(int varPlayerId) {
			return primaryKC(false, varPlayerId);
		}
		
		KCBuilder additionalKC(String kcName, boolean isVarbit, int id) {
			additionalKCMap.computeIfAbsent(subcategory, k -> new HashMap<>())
				.put(kcName, new KCSource(isVarbit, id));
			return this;
		}

		KCBuilder additionalKC(String kcName, int varPlayerId) {
			return additionalKC(kcName, false, varPlayerId);
		}
		

		KCBuilder derivedKC(String resultKCName, String combinedKCName, String subtractKCName) {
			derivedKCMap.computeIfAbsent(subcategory, k -> new HashMap<>())
				.put(resultKCName, new String[]{combinedKCName, subtractKCName});
			return this;
		}
		
		KCBuilder summedKC(String resultKCName, String... sourceKCNames) {
			summedKCMap.computeIfAbsent(subcategory, k -> new HashMap<>())
				.put(resultKCName, sourceKCNames);
			return this;
		}
		
		/**
		 * Convenience method for boss pairs (original + awakened)
		 * Sets up: primary KC, combined KC, awakened KC, and derived original KC
		 */
		KCBuilder bossPair(int combinedVarPlayerId, String originalName, int awakenedVarPlayerId, String awakenedName) {
			return primaryKC(combinedVarPlayerId)
				.additionalKC(originalName + "_combined_kc", combinedVarPlayerId)
				.additionalKC(awakenedName + "_kc", awakenedVarPlayerId)
				.derivedKC(originalName + "_kc", originalName + "_combined_kc", awakenedName + "_kc");
		}
	}
	
	/**
	 * Start building KC configuration for a subcategory
	 */
	private KCBuilder kc(String subcategory) {
		return new KCBuilder(subcategory);
	}

	/**
	 * Initialize the KC mapping for collection log categories
	 */
	private void initializeKCMap() {
		// ===== BOSSES =====
		kc("abyssal_sire").primaryKC(1526);
		kc("alchemical_hydra").primaryKC(2074);
		kc("amoxliatl").primaryKC(4403);
		kc("araxxor").primaryKC(4260);
		kc("barrows_chests").primaryKC(1502);
		kc("bryophyta").primaryKC(1733);
		
		kc("callisto_and_artio").bossPair(1510, "callisto", 3761, "artio");
		
		kc("venenatis_and_spindel")
			.primaryKC(1511)
			.additionalKC("venenatis_kc", 1511)
			.additionalKC("spindel_kc", 3762);
		
		kc("vetion_and_calvarion").bossPair(1512, "vetion", 3763, "calvarion");
		
		kc("cerberus").primaryKC(1525);
		kc("chaos_elemental").primaryKC(1513);
		kc("chaos_fanatic").primaryKC(1519);
		kc("commander_zilyana").primaryKC(1505);
		kc("corporeal_beast").primaryKC(1517);
		kc("crazy_archaeologist").primaryKC(1521);
		
		kc("dagannoth_kings")
			.primaryKC(1507)
			.additionalKC("dagannoth_prime_kc", 1507)
			.additionalKC("dagannoth_rex_kc", 1508)
			.additionalKC("dagannoth_supreme_kc", 1509);
		
		kc("deranged_archaeologist").primaryKC(1661);
		
		kc("doom_of_mokhaiotl")
			.primaryKC(4182)
			.additionalKC("level_1_completions", 4808)
			.additionalKC("level_2_completions", 4809)
			.additionalKC("level_3_completions", 4810)
			.additionalKC("level_4_completions", 4811)
			.additionalKC("level_5_completions", 4812)
			.additionalKC("level_6_completions", 4813)
			.additionalKC("level_7_completions", 4814)
			.additionalKC("level_8_completions", 4815)
			.additionalKC("level_8_plus_completions", 4816)
			.summedKC("total_completions", 
				"level_1_completions", "level_2_completions", "level_3_completions", "level_4_completions",
				"level_5_completions", "level_6_completions", "level_7_completions", "level_8_completions", "level_8_plus_completions")
			.additionalKC("deepest_delves", 4806);
		
		kc("duke_sucellus").primaryKC(3967);
		kc("the_fight_caves").primaryKC(1522);
		
		kc("fortis_colosseum")
			.primaryKC(4131)
			.additionalKC("colosseum_glory", 4132);
		
		kc("the_gauntlet")
			.primaryKC(2353)
			.additionalKC("corrupted_gauntlet_kc", 2354);
		
		kc("general_graardor").primaryKC(1504);
		kc("giant_mole").primaryKC(1515);
		kc("grotesque_guardians").primaryKC(1669);
		kc("hespori").primaryKC(2075);
		kc("the_hueycoatl").primaryKC(4404);
		kc("the_inferno").primaryKC(1585);
		kc("kalphite_queen").primaryKC(1516);
		kc("king_black_dragon").primaryKC(1514);
		kc("kraken").primaryKC(1523);
		kc("kreearra").primaryKC(1503);
		kc("kril_tsutsaroth").primaryKC(1506);
		kc("the_leviathan").primaryKC(3968);
		
		kc("moons_of_peril")
			.primaryKC(4186)
			.additionalKC("eclipse_moon_kc", 4148)
			.additionalKC("blue_moon_kc", 4149)
			.additionalKC("blood_moon_kc", 4150);
		
		kc("mimic").primaryKC(2221);
		kc("nex").primaryKC(3269);
		kc("the_nightmare").primaryKC(2664);
		kc("phosanis_nightmare").primaryKC(2671);
		kc("obor").primaryKC(1529);
		kc("phantom_muspah").primaryKC(3752);
		kc("royal_titans").primaryKC(4648);
		kc("sarachnis").primaryKC(2233);
		kc("scorpia").primaryKC(1520);
		kc("scurrius").primaryKC(4079);
		kc("skotizo").primaryKC(1527);
		
		kc("tempoross")
			.primaryKC(2934)
			.additionalKC("tempoross_rewards", true, 11936);
		
		kc("thermonuclear_smoke_devil").primaryKC(1524);
		kc("vardorvis").primaryKC(3970);
		kc("vorkath").primaryKC(1691);
		kc("the_whisperer").primaryKC(3969);
		
		kc("wintertodt")
			.primaryKC(1528)
			.additionalKC("wintertodt_rewards", 1941);
		
		kc("yama").primaryKC(4701);
		kc("zalcano").primaryKC(2352);
		kc("zulrah").primaryKC(1518);

		kc("chambers_of_xeric")
			.primaryKC(1532)
			.additionalKC("challenge_mode", 1735);
		
		kc("theatre_of_blood")
			.primaryKC(1748)
			.additionalKC("hard_mode", 3057);
		
		kc("tombs_of_amascut")
			.primaryKC(3646)
			.additionalKC("entry_mode", 3645)
			.additionalKC("expert_mode", 3647);

		// ===== CLUES =====
		kc("beginner_treasure_trails").primaryKC(true, 11996);
		kc("easy_treasure_trails").primaryKC(true, 11997);
		kc("medium_treasure_trails").primaryKC(true, 11998);
		kc("hard_treasure_trails").primaryKC(true, 11999);
		kc("elite_treasure_trails").primaryKC(true, 12000);
		kc("master_treasure_trails").primaryKC(true, 12001);
		kc("hard_treasure_trails_rare").primaryKC(true, 11999);
		kc("elite_treasure_trails_rare").primaryKC(true, 12000);
		kc("master_treasure_trails_rare").primaryKC(true, 12001);

		// ===== MINIGAMES =====
		kc("barbarian_assault").primaryKC(1605);

		kc("guardians_of_the_rift")
			.primaryKC(3397)
			.additionalKC("rifts_closed", 3397);
		
		kc("hallowed_sepulchre").primaryKC(2936);
		
		kc("last_man_standing")
			.primaryKC(2396)
			.additionalKC("lms_wins", 2397)
			.additionalKC("lms_kills", 2398);
		
		kc("mastering_mixology").primaryKC(4480);
		
		kc("soul_wars")
			.primaryKC(2871)
			.additionalKC("total_kills", 2872)
			.additionalKC("total_deaths", 2873)
			.additionalKC("total_games", 2874)
			.additionalKC("total_wins", 2875)
			.additionalKC("zeal_tokens", 2876);


		// ===== OTHER =====
		kc("gloughs_experiments")
			.primaryKC(1685)
			.additionalKC("demonic_gorillas_kc", 1685)
			.additionalKC("tortured_gorillas_kc", 4321);

		kc("tormented_demons").primaryKC(4240);
	}

	/**
	 * Parse the game cache to extract all collection log structure
	 */
	public void parseCacheForCollectionLog() {
		if (client.getIndexConfig() == null) {
			return;
		}

		initializeKCMap();
		categoryItemMap.clear();
		categoryStructIdMap.clear();
		categoryTabSlugs.clear();
		allCollectionLogItems.clear();

		try {
			Pattern specialCharPattern = Pattern.compile("['()]");
			EnumComposition replacements = client.getEnum(3721);
			int[] topLevelTabStructIds = client.getEnum(2102).getIntVals();

			for (int topLevelTabStructIndex : topLevelTabStructIds) {
				StructComposition topLevelTabStruct = client.getStructComposition(topLevelTabStructIndex);
				int[] subtabStructIndices = client.getEnum(topLevelTabStruct.getIntValue(683)).getIntVals();
				Set<String> categorySlugSet = new LinkedHashSet<>();

				for (int subtabStructIndex : subtabStructIndices) {
					StructComposition subtabStruct = client.getStructComposition(subtabStructIndex);
					int[] clogItems = client.getEnum(subtabStruct.getIntValue(690)).getIntVals();
					String categoryName = subtabStruct.getStringValue(689);

					String slug = specialCharPattern.matcher(categoryName.toLowerCase().replaceAll(" ", "_")).replaceAll("");
					Set<Integer> itemSet = new LinkedHashSet<>();

					for (int itemId : clogItems) {
						int replacementId = replacements.getIntValue(itemId);
						itemSet.add(replacementId == -1 ? itemId : replacementId);
					}

					allCollectionLogItems.addAll(itemSet);
					categoryItemMap.put(subtabStructIndex, itemSet);
					categoryStructIdMap.put(slug, subtabStructIndex);
					categorySlugSet.add(slug);
				}

				categoryTabSlugs.put(topLevelTabStructIndex, categorySlugSet);
			}
		} catch (Exception e) {
			log.error("Error parsing collection log cache", e);
		}
	}

	/**
	 * Called when collection log opens - tracks which items the player has obtained
	 */
	public void onCollectionLogItemObtained(int itemId, int itemCount, String itemName) {
		obtainedItems.add(new ObtainedCollectionItem(itemId, itemName, itemCount));
	}

	/**
	 * Sync and get collection log data grouped by category (Category > Subcategory > Items)
	 */
	public Map<String, Object> sync() {
		Map<String, Object> data = new HashMap<>();
		data.put("totalItems", allCollectionLogItems.size());
		
		// Get obtained items count
		if (!obtainedItems.isEmpty()) {
			data.put("obtainedItems", obtainedItems.size());
			data.put("dataSource", "collection_log_opened");
		} else {
			try {
				data.put("obtainedItems", client.getVarpValue(2943));
				data.put("dataSource", "varbit_2943");
			} catch (Exception e) {
				data.put("obtainedItems", 0);
				data.put("dataSource", "unavailable");
			}
		}

		// Map obtained items for quick lookup
		Map<Integer, ObtainedCollectionItem> obtainedItemsMap = new HashMap<>();
		for (ObtainedCollectionItem item : obtainedItems) {
			obtainedItemsMap.put(item.getId(), item);
		}

		// Build hierarchical structure: Category > Subcategory > Items
		Map<String, Map<String, Map<String, Object>>> categoriesData = new LinkedHashMap<>();

		for (Map.Entry<Integer, Set<String>> tabEntry : categoryTabSlugs.entrySet()) {
			String categoryName = CollectionLogCategoryGroup.getNameFromStructId(tabEntry.getKey());
			Map<String, Map<String, Object>> subcategoriesData = new LinkedHashMap<>();

			for (String subcategorySlug : tabEntry.getValue()) {
				Set<Integer> categoryItems = categoryItemMap.get(categoryStructIdMap.get(subcategorySlug));
				if (categoryItems == null) continue;

				Map<String, Object> subcategoryData = buildSubcategoryData(subcategorySlug, categoryItems, obtainedItemsMap);
				subcategoriesData.put(subcategorySlug, subcategoryData);
			}

			categoriesData.put(categoryName, subcategoriesData);
		}

		data.put("categories", categoriesData);
		return data;
	}

	/**
	 * Build subcategory data including items and KC tracking
	 */
	private Map<String, Object> buildSubcategoryData(String subcategorySlug, Set<Integer> categoryItems, 
			Map<Integer, ObtainedCollectionItem> obtainedItemsMap) {
		Map<String, Object> subcategoryData = new HashMap<>();
		List<Map<String, Object>> itemsList = new ArrayList<>();
		int obtainedCount = 0;

		// Build items list
		for (Integer itemId : categoryItems) {
			Map<String, Object> itemData = new HashMap<>();
			itemData.put("id", itemId);
			
			ObtainedCollectionItem obtainedItem = obtainedItemsMap.get(itemId);
			if (obtainedItem != null) {
				itemData.put("name", obtainedItem.getName());
				itemData.put("quantity", obtainedItem.getCount());
				itemData.put("obtained", true);
				obtainedCount++;
			} else {
				try {
					itemData.put("name", client.getItemDefinition(itemId).getName());
				} catch (Exception e) {
					itemData.put("name", "Unknown");
				}
				itemData.put("quantity", 0);
				itemData.put("obtained", false);
			}
			
			itemsList.add(itemData);
		}

		subcategoryData.put("total", categoryItems.size());
		subcategoryData.put("obtained", obtainedCount);
		subcategoryData.put("items", itemsList);

		// Add primary KC
		addPrimaryKC(subcategorySlug, subcategoryData);
		
		// Add additional KCs (including derived and summed)
		addAdditionalKCs(subcategorySlug, subcategoryData);

		return subcategoryData;
	}

	/**
	 * Add primary KC to subcategory data
	 */
	private void addPrimaryKC(String subcategorySlug, Map<String, Object> subcategoryData) {
		KCSource kcSource = categoryKCMap.get(subcategorySlug);
		if (kcSource != null) {
			try {
				int kc = kcSource.isVarbit ? client.getVarbitValue(kcSource.id) : client.getVarpValue(kcSource.id);
				subcategoryData.put("kc", kc);
			} catch (Exception e) {
				subcategoryData.put("kc", 0);
			}
		} else {
			subcategoryData.put("kc", 0);
		}
	}

	/**
	 * Add additional KCs including derived and summed calculations
	 */
	private void addAdditionalKCs(String subcategorySlug, Map<String, Object> subcategoryData) {
		Map<String, KCSource> additionalKCs = additionalKCMap.get(subcategorySlug);
		if (additionalKCs == null || additionalKCs.isEmpty()) return;

		Map<String, Integer> kcValues = new HashMap<>();
		
		// Fetch all KC values
		for (Map.Entry<String, KCSource> entry : additionalKCs.entrySet()) {
			try {
				KCSource source = entry.getValue();
				int value = source.isVarbit ? client.getVarbitValue(source.id) : client.getVarpValue(source.id);
				kcValues.put(entry.getKey(), value);
			} catch (Exception e) {
				kcValues.put(entry.getKey(), 0);
			}
		}
		
		// Process derived KCs (subtraction: original = combined - awakened)
		Map<String, String[]> derivedKCs = derivedKCMap.get(subcategorySlug);
		if (derivedKCs != null) {
			for (Map.Entry<String, String[]> entry : derivedKCs.entrySet()) {
				String[] calc = entry.getValue();
				int result = kcValues.getOrDefault(calc[0], 0) - kcValues.getOrDefault(calc[1], 0);
				kcValues.put(entry.getKey(), result);
			}
		}
		
		// Process summed KCs (addition: total = sum of all sources)
		Map<String, String[]> summedKCs = summedKCMap.get(subcategorySlug);
		if (summedKCs != null) {
			for (Map.Entry<String, String[]> entry : summedKCs.entrySet()) {
				int sum = 0;
				for (String sourceKCName : entry.getValue()) {
					sum += kcValues.getOrDefault(sourceKCName, 0);
				}
				kcValues.put(entry.getKey(), sum);
			}
		}
		
		// Add all KC values to subcategory data (exclude intermediate _combined_kc values)
		for (Map.Entry<String, Integer> entry : kcValues.entrySet()) {
			if (!entry.getKey().endsWith("_combined_kc")) {
				subcategoryData.put(entry.getKey(), entry.getValue());
			}
		}
	}

	/**
	 * Clear obtained items (for re-syncing)
	 */
	public void clearObtainedItems() {
		obtainedItems.clear();
	}
}


package com.revalclan;

import com.revalclan.collectionlog.CollectionLogManager;
import com.revalclan.collectionlog.CollectionLogSyncButton;
import com.revalclan.notifiers.*;
import com.revalclan.util.EventFilterManager;
import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.InteractingChanged;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.StatChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;

@Slf4j
@PluginDescriptor(
	name = "Reval Clan"
)
public class RevalClanPlugin extends Plugin {
	@Inject private Client client;

	@Inject	private CollectionLogManager collectionLogManager;

	@Inject	private CollectionLogSyncButton syncButton;

	@Inject	private LootNotifier lootNotifier;

	@Inject	private PetNotifier petNotifier;

	@Inject	private QuestNotifier questNotifier;

	@Inject	private LevelNotifier levelNotifier;

	@Inject	private KillCountNotifier killCountNotifier;

	@Inject	private ClueNotifier clueNotifier;

	@Inject	private DiaryNotifier diaryNotifier;

	@Inject	private CombatAchievementNotifier combatAchievementNotifier;

	@Inject	private CollectionNotifier collectionNotifier;

	@Inject	private DeathNotifier deathNotifier;

	@Inject	private DetailedKillNotifier detailedKillNotifier;

	@Inject	private EmoteNotifier emoteNotifier;

	@Inject	private ChatNotifier chatNotifier;

	@Inject	private MusicNotifier musicNotifier;

	@Inject	private LoginNotifier loginNotifier;

	@Inject	private LogoutNotifier logoutNotifier;

	@Inject	private EventBus eventBus;

	@Inject	private ClientThread clientThread;

	@Inject	private ItemManager itemManager;

	@Inject	private EventFilterManager eventFilterManager;

	private boolean wasLoggedIn = false;

	@Override
	protected void startUp() throws Exception {
		log.info("Reval Clan plugin started!");
		wasLoggedIn = false;

		clientThread.invoke(() -> {
			if (client.getIndexConfig() == null || client.getGameState().ordinal() < GameState.LOGIN_SCREEN.ordinal()) {
				return false;
			}

			collectionLogManager.parseCacheForCollectionLog();
			return true;
		});

		syncButton.startUp();
		
		eventBus.register(lootNotifier);
	}

	@Override
	protected void shutDown() throws Exception {
		log.info("Reval Clan plugin stopped!");
		collectionLogManager.clearObtainedItems();
		syncButton.shutDown();
		
		eventBus.unregister(lootNotifier);

		levelNotifier.reset();
		clueNotifier.reset();
		killCountNotifier.reset();
		detailedKillNotifier.reset();
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged) {
		diaryNotifier.onGameStateChanged(gameStateChanged);

		if (gameStateChanged.getGameState() == GameState.LOGGED_IN) {
			wasLoggedIn = true;

			collectionLogManager.clearObtainedItems();
			
			// Fetch dynamic event filters from API on login
			eventFilterManager.fetchFiltersAsync();

			// Send login notification
			loginNotifier.onLogin();
		} else if (gameStateChanged.getGameState() == GameState.LOGIN_SCREEN) {
			if (wasLoggedIn) {
				logoutNotifier.onLogout();
				wasLoggedIn = false;
			}
		}
	}

	@Subscribe
	public void onGameTick(GameTick gameTick) {
		detailedKillNotifier.onGameTick(gameTick);
		
		killCountNotifier.onTick();
		
		diaryNotifier.onGameTick();
		
		petNotifier.onGameTick();
	}

	/**
	 * Handles collection log script events to track obtained items
	 * Script 4100 fires when collection log opens and for each item
	 */
	@Subscribe
	public void onScriptPreFired(ScriptPreFired preFired) {
		if (preFired.getScriptId() == 4100) {
			try {
				Object[] args = preFired.getScriptEvent().getArguments();
				
				if (args == null || args.length < 3) {
					log.warn("Script 4100 fired with insufficient arguments: {}", args != null ? args.length : "null");
					return;
				}
				
				int itemId = (int) args[1];
				int itemCount = (int) args[2];
				String itemName = itemManager.getItemComposition(itemId).getName();

				collectionLogManager.onCollectionLogItemObtained(itemId, itemCount, itemName);
			} catch (Exception e) {
				log.error("Error capturing collection log item", e);
			}
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage event) {
		String message = event.getMessage();
		
		// Strip HTML color tags from the message before processing
		String cleanMessage = message.replaceAll("<col=[0-9a-fA-F]+>", "").replaceAll("</col>", "");
		
		ChatMessageType type = event.getType();
		
		chatNotifier.onChatMessage(type, event.getName(), cleanMessage);
		
		if (type == ChatMessageType.GAMEMESSAGE || 
		    type == ChatMessageType.SPAM ||
		    type == ChatMessageType.ENGINE) {
			petNotifier.onChatMessage(cleanMessage);
			lootNotifier.onGameMessage(cleanMessage);
			killCountNotifier.onChatMessage(cleanMessage);
			clueNotifier.onChatMessage(cleanMessage);
			combatAchievementNotifier.onChatMessage(cleanMessage);
			collectionNotifier.onChatMessage(cleanMessage);
		} else if (type == ChatMessageType.CLAN_MESSAGE ||
		           type == ChatMessageType.CLAN_CHAT ||
		           type == ChatMessageType.CLAN_GUEST_CHAT) {
			petNotifier.onClanNotification(cleanMessage);
		}
	}

	@Subscribe
	public void onStatChanged(StatChanged event) {
		levelNotifier.onStatChanged(event);
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event) {
		questNotifier.onWidgetLoaded(event);
		clueNotifier.onWidgetLoaded(event);
	}

	@Subscribe
	public void onActorDeath(ActorDeath event) {
		deathNotifier.onActorDeath(event);
		detailedKillNotifier.onActorDeath(event);
	}

	@Subscribe
	public void onHitsplatApplied(HitsplatApplied event) {
		detailedKillNotifier.onHitsplatApplied(event);
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event) {
		emoteNotifier.onMenuOptionClicked(event);
		musicNotifier.onMenuOptionClicked(event);
	}

	@Subscribe
	public void onInteractingChanged(InteractingChanged event) {
		deathNotifier.onInteractingChanged(event);
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event) {
		diaryNotifier.onVarbitChanged(event);
	}

	@Provides
	RevalClanConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(RevalClanConfig.class);
	}
}



package com.revalclan;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("revalclan")
public interface RevalClanConfig extends Config {
	@ConfigSection(
		name = "Event Notifications",
		description = "Toggle individual event types",
		position = 1
	)
	String eventsSection = "eventsSection";

	// Event type toggles
	@ConfigItem(
		keyName = "notifyLoot",
		name = "Loot Drops",
		description = "Send notifications for valuable loot drops",
		section = eventsSection,
		position = 1
	)
	default boolean notifyLoot() {
		return true;
	}

	@ConfigItem(
		keyName = "notifyPet",
		name = "Pet Drops",
		description = "Send notifications when you receive a pet",
		section = eventsSection,
		position = 2
	)
	default boolean notifyPet() {
		return true;
	}

	@ConfigItem(
		keyName = "notifyQuest",
		name = "Quest Completions",
		description = "Send notifications when you complete a quest",
		section = eventsSection,
		position = 3
	)
	default boolean notifyQuest() {
		return true;
	}

	@ConfigItem(
		keyName = "notifyLevel",
		name = "Level Ups",
		description = "Send notifications when you level up",
		section = eventsSection,
		position = 4
	)
	default boolean notifyLevel() {
		return true;
	}

	@ConfigItem(
		keyName = "notifyKillCount",
		name = "Kill Counts",
		description = "Send notifications for boss kill counts",
		section = eventsSection,
		position = 5
	)
	default boolean notifyKillCount() {
		return true;
	}

	@ConfigItem(
		keyName = "notifyClue",
		name = "Clue Scrolls",
		description = "Send notifications when you complete a clue scroll",
		section = eventsSection,
		position = 6
	)
	default boolean notifyClue() {
		return true;
	}

	@ConfigItem(
		keyName = "notifyDiary",
		name = "Achievement Diaries",
		description = "Send notifications when you complete an achievement diary",
		section = eventsSection,
		position = 7
	)
	default boolean notifyDiary() {
		return true;
	}

	@ConfigItem(
		keyName = "notifyCombatAchievement",
		name = "Combat Achievements",
		description = "Send notifications when you complete a combat achievement",
		section = eventsSection,
		position = 8
	)
	default boolean notifyCombatAchievement() {
		return true;
	}

	@ConfigItem(
		keyName = "notifyCollection",
		name = "Collection Log",
		description = "Send notifications when you add items to collection log",
		section = eventsSection,
		position = 9
	)
	default boolean notifyCollection() {
		return true;
	}

	@ConfigItem(
		keyName = "notifyDeath",
		name = "Player Deaths",
		description = "Send notifications when you die",
		section = eventsSection,
		position = 10
	)
	default boolean notifyDeath() {
		return true;
	}

	@ConfigItem(
		keyName = "notifyDetailedKill",
		name = "Detailed Kills",
		description = "Send detailed kill tracking (damage, weapons, specs)",
		section = eventsSection,
		position = 12
	)
	default boolean notifyDetailedKill() {
		return true;
	}

	@ConfigItem(
		keyName = "notifyEmote",
		name = "Emotes",
		description = "Send notifications when performing emotes",
		section = eventsSection,
		position = 14
	)
	default boolean notifyEmote() {
		return true;
	}

	@ConfigItem(
		keyName = "notifyChat",
		name = "System Chat Messages",
		description = "Send notifications for system chat messages (game events, broadcasts, etc.)",
		section = eventsSection,
		position = 15
	)
	default boolean notifyChat() {
		return true;
	}

	@ConfigItem(
		keyName = "notifyMusic",
		name = "Music Played",
		description = "Send notifications when you play a music track",
		section = eventsSection,
		position = 17
	)
	default boolean notifyMusic() {
		return true;
	}
}

package com.revalclan;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class RevalClanPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(RevalClanPlugin.class);
		RuneLite.main(args);
	}
}



