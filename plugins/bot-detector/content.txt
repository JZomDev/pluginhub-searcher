/*
 * Copyright (c) 2021, Ferrariic, Seltzer Bro, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.botdetector;

import com.botdetector.model.PlayerStatsType;
import com.botdetector.model.StatsCommandDetailLevel;
import com.botdetector.ui.PanelFontType;
import java.awt.Color;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;
import net.runelite.client.config.Units;

@ConfigGroup(BotDetectorConfig.CONFIG_GROUP)
public interface BotDetectorConfig extends Config
{
	String CONFIG_GROUP = "botdetector";
	String ONLY_SEND_AT_LOGOUT_KEY = "sendAtLogout";
	String AUTO_SEND_MINUTES_KEY = "autoSendMinutes";
	String ADD_PREDICT_PLAYER_OPTION_KEY = "addDetectOption"; // I know it says detect, don't change it.
	String ADD_PREDICT_MENU_OPTION_KEY = "addPlayerMenuOption";
	String ANONYMOUS_UPLOADING_KEY = "enableAnonymousReporting";
	String PANEL_FONT_TYPE_KEY = "panelFontType";
	String AUTH_FULL_TOKEN_KEY = "authToken";
	String SHOW_FEEDBACK_TEXTBOX = "showFeedbackTextbox";
	String SHOW_DISCORD_VERIFICATION_ERRORS = "showDiscordVerificationErrors";
	String ANONYMOUS_UUID_KEY = "anonymousUUID";
	String ACKNOWLEDGED_HARASSMENT_WARNING_KEY = "acknowledgedHarassmentWarning";

	int AUTO_SEND_MINIMUM_MINUTES = 5;
	int AUTO_SEND_MAXIMUM_MINUTES = 360;

	@ConfigSection(
		position = 1,
		name = "Upload Settings",
		description = "Settings for how the plugin uploads player data."
	)
	String uploadSection = "uploadSection";

	@ConfigSection(
		position = 2,
		name = "Panel Settings",
		description = "Settings for the plugin's panel."
	)
	String panelSection = "panelSection";

	@ConfigSection(
		position = 3,
		name = "'Predict' Settings",
		description = "Settings for the 'Predict' right-click option."
	)
	String predictSection = "predictSection";

	@ConfigSection(
		position = 4,
		name = "Other Settings",
		description = "Other miscellaneous settings."
	)
	String miscSection = "miscSection";

	@ConfigItem(
		position = 1,
		keyName = ACKNOWLEDGED_HARASSMENT_WARNING_KEY,
		name = "Acknowledge Harassment Warning",
		description = "Set this config to acknowledge you understand not to harass other players while using this plugin.",
		warning = "<html>We have received reports of legitimate players being harassed by users of this plugin." +
			"<br>" +
			"<br>Bot predictions from this plugin are not to be taken at face value, as players with lower" +
			"<br>total XP or account builds that generally deviate from the expected average may throw" +
			"<br>off our Machine Learning models, resulting in reductions in 'Real Player' confidence." +
			"<br>" +
			"<br>We ask that you <b>do not harass other players based on our predictions</b>." +
			"<br>Harassment never helps, as bots do not care and legitimate players suffer unnecessarily." +
			"<br>" +
			"<br>For more context, please read the plugin's FAQ, available on both the plugin's GitHub" +
			"<br>page and our Discord server before you continue using the plugin." +
			"<br>" +
			"<br>Thank you," +
			"<br>- The Bot Detector Team.</html>"
	)
	default boolean acknowledgedHarassmentWarning()
	{
		return false;
	}

	@ConfigItem(
		position = 1,
		keyName = ANONYMOUS_UPLOADING_KEY,
		name = "Anonymous Uploading",
		description = "Your name will not be included with your name uploads.<br>Disable if you'd like to track your contributions.",
		section = uploadSection
	)
	default boolean enableAnonymousUploading()
	{
		return true;
	}

	@ConfigItem(
		position = 2,
		keyName = ONLY_SEND_AT_LOGOUT_KEY,
		name = "Send Names Only After Logout",
		description = "Waits to upload names until you've logged out. Use this if you have a poor connection."
			+ "<br><span style='color:red'>WARNING:</span> Names <b>will not</b> be sent if RuneLite is closed completely"
			+ "<br>before logging out, unless 'Attempt Send on Close' is turned on.",
		section = uploadSection
	)
	default boolean onlySendAtLogout()
	{
		return false;
	}

	@ConfigItem(
		position = 3,
		keyName = "uploadOnShutdown",
		name = "Attempt Send on Close",
		description = "Attempts to upload names when closing RuneLite while being logged in."
			+ "<br><span style='color:red'>WARNING:</span> This may cause the client to take significantly longer to close"
			+ "<br>in the event that the Bot Detector server is being slow or unresponsive.",
		section = uploadSection
	)
	default boolean uploadOnShutdown()
	{
		return false;
	}

	@ConfigItem(
		position = 4,
		keyName = AUTO_SEND_MINUTES_KEY,
		name = "Send Names Every",
		description = "Sets the amount of time between automatic name uploads.",
		section = uploadSection
	)
	@Range(min = AUTO_SEND_MINIMUM_MINUTES, max = AUTO_SEND_MAXIMUM_MINUTES)
	@Units(Units.MINUTES)
	default int autoSendMinutes()
	{
		return 5;
	}

	@ConfigItem(
		position = 1,
		keyName = "autocomplete",
		name = "Prediction Autocomplete",
		description = "Autocomplete names when typing a name to predict in the prediction panel.",
		section = panelSection
	)
	default boolean panelAutocomplete()
	{
		return true;
	}

	@ConfigItem(
		position = 2,
		keyName = "showBreakdownOnNullConfidence",
		name = "Show Breakdown in Special Cases",
		description = "Show the Prediction Breakdown when predicting certain types of accounts, such as 'Stats Too Low'.",
		section = panelSection
	)
	default boolean showBreakdownOnNullConfidence()
	{
		return false;
	}

	@ConfigItem(
		position = 3,
		keyName = SHOW_FEEDBACK_TEXTBOX,
		name = "Show Feedback Textbox",
		description = "Show a textbox on the prediction feedback panel where you can explain your feedback to us.",
		section = panelSection
	)
	default boolean showFeedbackTextbox()
	{
		return true;
	}

	@ConfigItem(
		position = 4,
		keyName = "panelDefaultStatsType",
		name = "Panel Default Stats Tab",
		description = "Sets the initial player statistics tab in the prediction panel for when the plugin is launched.",
		section = panelSection
	)
	default PlayerStatsType panelDefaultStatsType()
	{
		return PlayerStatsType.TOTAL;
	}

	@ConfigItem(
		position = 5,
		keyName = PANEL_FONT_TYPE_KEY,
		name = "Panel Font Size",
		description = "Sets the size of the label fields in the prediction panel.",
		section = panelSection
	)
	default PanelFontType panelFontType()
	{
		return PanelFontType.NORMAL;
	}

	@ConfigItem(
		position = 1,
		keyName = ADD_PREDICT_PLAYER_OPTION_KEY,
		name = "Right-click 'Predict' Players",
		description = "Adds an entry to game world player menus to quickly check them in the prediction panel.",
		section = predictSection
	)
	default boolean addPredictPlayerOption()
	{
		return false;
	}

	@ConfigItem(
		position = 2,
		keyName = ADD_PREDICT_MENU_OPTION_KEY,
		name = "Right-click 'Predict' Menus",
		description = "Adds an entry to interface player menus to quickly check them in the prediction panel.",
		section = predictSection
	)
	default boolean addPredictMenuOption()
	{
		return false;
	}

	@ConfigItem(
		position = 3,
		keyName = "predictOnReport",
		name = "'Predict' on Right-click 'Report'",
		description = "Makes the in-game right-click 'Report' option also open the prediction panel.",
		section = predictSection
	)
	default boolean predictOnReport()
	{
		return false;
	}

	@ConfigItem(
		position = 4,
		keyName = "predictOptionCopyName",
		name = "'Predict' Copy Name to Clipboard",
		description = "Copies the player's name to the clipboard when right-click predicting a player.",
		section = predictSection
	)
	default boolean predictOptionCopyName()
	{
		return false;
	}

	@ConfigItem(
		position = 5,
		keyName = "predictOptionDefaultColor",
		name = "'Predict' Default Color",
		description = "When right-clicking on a player, the predict option will be this color by default.",
		section = predictSection
	)
	Color predictOptionDefaultColor();

	@ConfigItem(
		position = 6,
		keyName = "predictOptionFlaggedColor",
		name = "'Predict' Voted/Flagged Color",
		description = "When right-clicking on a player that has been flagged or given feedback, the predict option will be this color instead.",
		section = predictSection
	)
	Color predictOptionFlaggedColor();

	@ConfigItem(
		position = 7,
		keyName = "applyPredictColorsOnReportOption",
		name = "Apply Colors to 'Report'",
		description = "Applies the above 'Predict' color options to the in-game 'Report' option as well.",
		section = predictSection,
		warning = "Enabling this setting may cause issues with other plugins that rely on the 'Report' option being unchanged."
	)
	default boolean applyPredictColorsOnReportOption()
	{
		return false;
	}

	@ConfigItem(
		position = 1,
		keyName = "enableChatNotifications",
		name = "Enable Chat Status Messages",
		description = "Show various plugin status messages in the game chat.",
		section = miscSection
	)
	default boolean enableChatStatusMessages()
	{
		return false;
	}

	@ConfigItem(
		position = 2,
		keyName = "statsChatCommandDetailLevel",
		name = "'!bdstats' Chat Command Detail Level",
		description = "Enable processing the '!bdstats' command when it appears in the chatbox,"
			+ "<br>which will fetch the message author's plugin stats and display them.",
		section = miscSection
	)
	default StatsCommandDetailLevel statsChatCommandDetailLevel()
	{
		return StatsCommandDetailLevel.CONFIRMED_ONLY;
	}

	@ConfigItem(
		keyName = AUTH_FULL_TOKEN_KEY,
		name = "",
		description = "",
		hidden = true
	)
	default String authFullToken()
	{
		return null;
	}

	@ConfigItem(
		keyName = AUTH_FULL_TOKEN_KEY,
		name = "",
		description = "",
		hidden = true
	)
	void setAuthFullToken(String fullToken);

	@ConfigItem(
		keyName = SHOW_DISCORD_VERIFICATION_ERRORS,
		name = "",
		description = "",
		hidden = true
	)
	default boolean showDiscordVerificationErrors()
	{
		return true;
	}

	@ConfigItem(
		keyName = SHOW_DISCORD_VERIFICATION_ERRORS,
		name = "",
		description = "",
		hidden = true
	)
	void setShowDiscordVerificationErrors(boolean show);
}

/*
 * Copyright (c) 2021, Ferrariic, Seltzer Bro, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.botdetector;

import com.botdetector.http.BotDetectorClient;
import com.botdetector.http.UnauthorizedTokenException;
import com.botdetector.http.ValidationException;
import com.botdetector.model.AuthToken;
import com.botdetector.model.AuthTokenPermission;
import com.botdetector.model.AuthTokenType;
import com.botdetector.model.CaseInsensitiveString;
import com.botdetector.model.PlayerSighting;
import com.botdetector.model.PlayerStats;
import com.botdetector.model.PlayerStatsType;
import com.botdetector.model.FeedbackPredictionLabel;
import com.botdetector.model.StatsCommandDetailLevel;
import com.botdetector.ui.BotDetectorPanel;
import com.botdetector.events.BotDetectorPanelActivated;
import com.google.common.collect.EvictingQueue;
import com.google.common.collect.HashBasedTable;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Table;
import com.google.common.collect.Tables;
import com.google.common.primitives.Ints;
import java.awt.Toolkit;
import java.awt.Color;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.text.DecimalFormat;
import java.time.Duration;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Collection;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Consumer;
import java.util.regex.Pattern;
import javax.swing.JEditorPane;
import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;
import javax.swing.event.HyperlinkEvent;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.MessageNode;
import net.runelite.api.Player;
import net.runelite.api.WorldEntity;
import net.runelite.api.WorldType;
import net.runelite.api.WorldView;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.CommandExecuted;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.MenuOpened;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.PlayerSpawned;
import net.runelite.api.events.WorldChanged;
import net.runelite.api.kit.KitType;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatCommandManager;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneScapeProfileType;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ClientShutdown;
import net.runelite.client.game.ItemManager;
import net.runelite.client.menus.MenuManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.events.ConfigChanged;
import javax.inject.Inject;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.task.Schedule;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.Text;
import com.google.inject.Provides;
import org.apache.commons.lang3.StringUtils;
import static com.botdetector.model.CaseInsensitiveString.wrap;

@Slf4j
@PluginDescriptor(
	name = "Bot Detector",
	description = "This plugin sends encountered Player Names to a server in order to detect Botting Behavior.",
	tags = {"Bot", "Detector", "Player"}
)
public class BotDetectorPlugin extends Plugin
{
	/** {@link PlayerSighting}s should only be created if the player is logged into a world set up for one of these {@link RuneScapeProfileType}s. **/
	private static final ImmutableSet<RuneScapeProfileType> ALLOWED_PROFILE_TYPES =
		ImmutableSet.of(
			RuneScapeProfileType.STANDARD
		);

	/** {@link PlayerSighting}s should only be created if the returned region id is <= this amount. **/
	private static final int MAX_ALLOWED_REGION_ID = 16000;

	private static final Pattern UUID_PATTERN = Pattern.compile("^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$");

	private static final String PREDICT_OPTION = "Predict";
	private static final String REPORT_OPTION = "Report";

	private static final ImmutableSet<MenuAction> PLAYER_MENU_ACTIONS = ImmutableSet.of(
		MenuAction.PLAYER_FIRST_OPTION, MenuAction.PLAYER_SECOND_OPTION, MenuAction.PLAYER_THIRD_OPTION, MenuAction.PLAYER_FOURTH_OPTION,
		MenuAction.PLAYER_FIFTH_OPTION, MenuAction.PLAYER_SIXTH_OPTION, MenuAction.PLAYER_SEVENTH_OPTION, MenuAction.PLAYER_EIGHTH_OPTION
	);


	private static final String VERIFY_DISCORD_COMMAND = "!code";
	private static final int VERIFY_DISCORD_CODE_SIZE = 4;
	private static final Pattern VERIFY_DISCORD_CODE_PATTERN = Pattern.compile("\\d{1," + VERIFY_DISCORD_CODE_SIZE + "}");

	private static final String STATS_CHAT_COMMAND = "!bdstats";

	private static final String COMMAND_PREFIX = "bd";
	private static final String MANUAL_FLUSH_COMMAND = COMMAND_PREFIX + "Flush";
	private static final String MANUAL_SIGHT_COMMAND = COMMAND_PREFIX + "Snap";
	private static final String MANUAL_REFRESH_COMMAND = COMMAND_PREFIX + "Refresh";
	private static final String SHOW_HIDE_ID_COMMAND = COMMAND_PREFIX + "ShowId";
	private static final String GET_AUTH_TOKEN_COMMAND = COMMAND_PREFIX + "GetToken";
	private static final String SET_AUTH_TOKEN_COMMAND = COMMAND_PREFIX + "SetToken";
	private static final String CLEAR_AUTH_TOKEN_COMMAND = COMMAND_PREFIX + "ClearToken";
	private static final String TOGGLE_SHOW_DISCORD_VERIFICATION_ERRORS_COMMAND = COMMAND_PREFIX + "ToggleShowDiscordVerificationErrors";
	private static final String TOGGLE_SHOW_DISCORD_VERIFICATION_ERRORS_COMMAND_ALIAS = COMMAND_PREFIX + "ToggleDVE";

	/** Command to method map to be used in {@link #onCommandExecuted(CommandExecuted)}. **/
	private final ImmutableMap<CaseInsensitiveString, Consumer<String[]>> commandConsumerMap =
		ImmutableMap.<CaseInsensitiveString, Consumer<String[]>>builder()
			.put(wrap(MANUAL_FLUSH_COMMAND), s -> manualFlushCommand())
			.put(wrap(MANUAL_SIGHT_COMMAND), s -> manualSightCommand())
			.put(wrap(MANUAL_REFRESH_COMMAND), s -> manualRefreshStatsCommand())
			.put(wrap(SHOW_HIDE_ID_COMMAND), this::showHideIdCommand)
			.put(wrap(GET_AUTH_TOKEN_COMMAND), s -> putAuthTokenIntoClipboardCommand())
			.put(wrap(SET_AUTH_TOKEN_COMMAND), s -> setAuthTokenFromClipboardCommand())
			.put(wrap(CLEAR_AUTH_TOKEN_COMMAND), s -> clearAuthTokenCommand())
			.put(wrap(TOGGLE_SHOW_DISCORD_VERIFICATION_ERRORS_COMMAND), s -> toggleShowDiscordVerificationErrors())
			.put(wrap(TOGGLE_SHOW_DISCORD_VERIFICATION_ERRORS_COMMAND_ALIAS), s -> toggleShowDiscordVerificationErrors())
			.build();

	private static final int MANUAL_FLUSH_COOLDOWN_SECONDS = 60;
	private static final int AUTO_REFRESH_STATS_COOLDOWN_SECONDS = 150;
	private static final int AUTO_REFRESH_LAST_FLUSH_GRACE_PERIOD_SECONDS = 30;
	private static final int API_HIT_SCHEDULE_SECONDS = 5;

	private static final String CHAT_MESSAGE_HEADER = "[Bot Detector] ";
	public static final String ANONYMOUS_USER_NAME = "AnonymousUser";
	public static final String ANONYMOUS_USER_NAME_UUID_FORMAT = ANONYMOUS_USER_NAME + "_%s";

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ConfigManager configManager;

	@Inject
	private MenuManager menuManager;

	@Inject
	private ItemManager itemManager;

	@Inject
	private BotDetectorConfig config;

	@Inject
	private PluginManager pluginManager;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private ChatCommandManager chatCommandManager;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private BotDetectorClient detectorClient;

	private BotDetectorPanel panel;
	private NavigationButton navButton;

	@Provides
	BotDetectorConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(BotDetectorConfig.class);
	}

	/** The currently logged in player name, or {@code null} if the user is logged out. **/
	@Getter
	private String loggedPlayerName;
	/** The next time an automatic call to {@link #flushPlayersToClient(boolean)} should be allowed to run. **/
	private Instant timeToAutoSend;
	/** The total number of names uploaded in the current login session. **/
	private int namesUploaded;
	/** The last time a {@link #flushPlayersToClient(boolean)} was successfully attempted. **/
	private Instant lastFlush = Instant.MIN;
	/** The last time a {@link #refreshPlayerStats(boolean)}} was successfully attempted. **/
	private Instant lastStatsRefresh = Instant.MIN;
	/** See {@link #processCurrentWorld()}. **/
	private int currentWorldNumber;
	/** See {@link #processCurrentWorld()}. **/
	private boolean isCurrentWorldMembers;
	/** See {@link #processCurrentWorld()}. **/
	private boolean isCurrentWorldPVP;
	/** A blocked world should not log {@link PlayerSighting}s (see {@link #processCurrentWorld()} and {@link #ALLOWED_PROFILE_TYPES}). **/
	private boolean isCurrentWorldBlocked;
	/** A queue containing the last two {@link GameState}s from {@link #onGameStateChanged(GameStateChanged)}. **/
	private final EvictingQueue<GameState> previousTwoGameStates = EvictingQueue.create(2);

	/** The currently loaded token or {@link AuthToken#EMPTY_TOKEN} if no valid token is loaded. **/
	@Getter
	private AuthToken authToken = AuthToken.EMPTY_TOKEN;

	/** The currently loaded anonymous UUID. **/
	private String anonymousUUID;

	/**
	 * Contains the last {@link PlayerSighting} for the given {@code player} and {@code regionId}
	 * since the last successful call to {@link #flushPlayersToClient(boolean, boolean)}.
	 * Always use {@link #normalizeAndWrapPlayerName(String)} when keying into this table.
	 */
	@Getter
	private final Table<CaseInsensitiveString, Integer, PlayerSighting> sightingTable = Tables.synchronizedTable(HashBasedTable.create());

	/**
	 * Contains the last {@link PlayerSighting} for the given {@code player} for the current login session.
	 * Always use {@link #normalizeAndWrapPlayerName(String)} when keying into this map.
	 */
	@Getter
	private final Map<CaseInsensitiveString, PlayerSighting> persistentSightings = new ConcurrentHashMap<>();

	/**
	 * Contains the feedbacks (See {@link FeedbackPredictionLabel}) sent per {@code player} for the current login session.
	 * Always use {@link #normalizeAndWrapPlayerName(String)} when keying into this map.
	 */
	@Getter
	private final Map<CaseInsensitiveString, FeedbackPredictionLabel> feedbackedPlayers = new ConcurrentHashMap<>();

	/**
	 * Contains the feedback texts sent per {@code player} for the current login session.
	 * Always use {@link #normalizeAndWrapPlayerName(String)} when keying into this map.
	 */
	@Getter
	private final Map<CaseInsensitiveString, String> feedbackedPlayersText = new ConcurrentHashMap<>();

	/**
	 * Contains the flagging (yes/no) sent per {@code player} for the current login session.
	 * Always use {@link #normalizeAndWrapPlayerName(String)} when keying into this map.
	 */
	@Getter
	private final Map<CaseInsensitiveString, Boolean> flaggedPlayers = new ConcurrentHashMap<>();

	@Override
	protected void startUp()
	{
		// Get current version of the plugin using properties file generated by build.gradle
		// Thanks to https://github.com/dillydill123/inventory-setups/
		try
		{
			final Properties props = new Properties();
			props.load(getClass().getResourceAsStream("version.txt"));
			detectorClient.setPluginVersion(props.getProperty("version"));
		}
		catch (Exception e)
		{
			log.error("Could not parse plugin version from properties file!", e);

			// Turn plugin back off and display an error message
			pluginManager.setPluginEnabled(this, false);
			displayPluginVersionError();

			return;
		}

		// Load up the anonymous UUID
		anonymousUUID = configManager.getConfiguration(BotDetectorConfig.CONFIG_GROUP, BotDetectorConfig.ANONYMOUS_UUID_KEY);
		if (StringUtils.isBlank(anonymousUUID) || !UUID_PATTERN.matcher(anonymousUUID).matches())
		{
			anonymousUUID = UUID.randomUUID().toString();
			configManager.setConfiguration(BotDetectorConfig.CONFIG_GROUP, BotDetectorConfig.ANONYMOUS_UUID_KEY, anonymousUUID);
		}

		panel = injector.getInstance(BotDetectorPanel.class);
		SwingUtilities.invokeLater(() ->
		{
			panel.setWarningVisible(BotDetectorPanel.WarningLabel.ANONYMOUS, config.enableAnonymousUploading());
			panel.setWarningVisible(BotDetectorPanel.WarningLabel.HARASSMENT_WARNING, !config.acknowledgedHarassmentWarning());
			panel.setPluginVersion(detectorClient.getPluginVersion());
			panel.setNamesUploaded(0, false);
			panel.setNamesUploaded(0, true);
			panel.setFeedbackTextboxVisible(config.showFeedbackTextbox());
		});

		processCurrentWorld();

		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "bot-icon.png");

		navButton = NavigationButton.builder()
			.panel(panel)
			.tooltip("Bot Detector")
			.icon(icon)
			.priority(90)
			.build();

		clientToolbar.addNavigation(navButton);

		if (config.addPredictPlayerOption() && client != null)
		{
			menuManager.addPlayerMenuItem(PREDICT_OPTION);
		}

		updateTimeToAutoSend();

		authToken = AuthToken.fromFullToken(config.authFullToken());

		previousTwoGameStates.offer(client.getGameState());

		chatCommandManager.registerCommand(VERIFY_DISCORD_COMMAND, this::verifyDiscord);
		chatCommandManager.registerCommand(STATS_CHAT_COMMAND, this::statsChatCommand);
	}

	@Override
	protected void shutDown()
	{
		panel.shutdown();

		flushPlayersToClient(false);
		persistentSightings.clear();
		feedbackedPlayers.clear();
		feedbackedPlayersText.clear();
		flaggedPlayers.clear();

		if (client != null)
		{
			menuManager.removePlayerMenuItem(PREDICT_OPTION);
		}

		clientToolbar.removeNavigation(navButton);

		namesUploaded = 0;
		loggedPlayerName = null;
		lastFlush = Instant.MIN;
		lastStatsRefresh = Instant.MIN;
		authToken = AuthToken.EMPTY_TOKEN;

		previousTwoGameStates.clear();

		chatCommandManager.unregisterCommand(VERIFY_DISCORD_COMMAND);
		chatCommandManager.unregisterCommand(STATS_CHAT_COMMAND);
	}

	/**
	 * Updates {@link #timeToAutoSend} according to {@link BotDetectorConfig#autoSendMinutes()}.
	 */
	private void updateTimeToAutoSend()
	{
		timeToAutoSend = Instant.now().plusSeconds(60L *
			Ints.constrainToRange(config.autoSendMinutes(),
				BotDetectorConfig.AUTO_SEND_MINIMUM_MINUTES,
				BotDetectorConfig.AUTO_SEND_MAXIMUM_MINUTES));
	}

	/**
	 * Do not call this method in code. Continuously calls the automatic variants of API calling methods.
	 */
	@Schedule(period = API_HIT_SCHEDULE_SECONDS, unit = ChronoUnit.SECONDS, asynchronous = true)
	public void hitApi()
	{
		if (loggedPlayerName == null)
		{
			return;
		}

		if (!config.onlySendAtLogout() && Instant.now().isAfter(timeToAutoSend))
		{
			flushPlayersToClient(true);
		}

		refreshPlayerStats(false);
	}

	/**
	 * Attempts to send the contents of {@link #sightingTable} to {@link BotDetectorClient#sendSightings(Collection, String, boolean)}.
	 * @param restoreOnFailure The table is cleared before sending. If {@code true}, re-insert the cleared sightings into the table on failure.
	 * @return A completable future if there were any names to attempt to send, {@code null} otherwise.
	 */
	public synchronized CompletableFuture<Boolean> flushPlayersToClient(boolean restoreOnFailure)
	{
		return flushPlayersToClient(restoreOnFailure, false);
	}

	/**
	 * Attempts to send the contents of {@link #sightingTable} to {@link BotDetectorClient#sendSightings(Collection, String, boolean)}.
	 * @param restoreOnFailure The table is cleared before sending. If {@code true}, re-insert the cleared sightings into the table on failure.
	 * @param forceChatNotification Force displays the chat notifications.
	 * @return A completable future if there were any names to attempt to send, {@code null} otherwise.
	 */
	public synchronized CompletableFuture<Boolean> flushPlayersToClient(boolean restoreOnFailure, boolean forceChatNotification)
	{
		String uploader = getUploaderName();
		if (uploader == null)
		{
			return null;
		}

		updateTimeToAutoSend();

		int uniqueNames;
		Collection<PlayerSighting> sightings;
		int numUploads;
		synchronized (sightingTable)
		{
			uniqueNames = sightingTable.rowKeySet().size();
			if (uniqueNames <= 0)
			{
				return null;
			}

			sightings = new ArrayList<>(sightingTable.values());
			sightingTable.clear();
			numUploads = sightings.size();
		}

		lastFlush = Instant.now();

		return detectorClient.sendSightings(sightings, getUploaderName(), false)
			.whenComplete((b, ex) ->
			{
				if (ex == null && b)
				{
					namesUploaded += uniqueNames;
					SwingUtilities.invokeLater(() -> panel.setNamesUploaded(namesUploaded, false));
					sendChatStatusMessage("Successfully uploaded " + numUploads +
						" locations for " + uniqueNames + " unique players.",
						forceChatNotification);
				}
				else
				{
					sendChatStatusMessage("Error sending player sightings!", forceChatNotification);
					// Put the sightings back, but not if it's because of a validation error
					if (restoreOnFailure && !(ex instanceof ValidationException))
					{
						synchronized (sightingTable)
						{
							sightings.forEach(s ->
							{
								CaseInsensitiveString name = wrap(s.getPlayerName());
								int region = s.getRegionID();
								// Don't replace if new sightings were added to the table during the request
								if (!sightingTable.contains(name, region))
								{
									sightingTable.put(name, region, s);
								}
							});
						}
					}
				}
			});
	}

	/**
	 * Attempts to refresh the current player uploading statistics on the plugin panel according to various checks.
	 * @param forceRefresh If {@code true}, ignore checks in place meant for the automatic calling of this method.
	 */
	public synchronized void refreshPlayerStats(boolean forceRefresh)
	{
		if (!forceRefresh)
		{
			Instant now = Instant.now();
			// Only perform non-manual refreshes when a player is not anon, logged in and the panel is open
			if (config.enableAnonymousUploading() || loggedPlayerName == null || !panel.isActive()
				|| now.isBefore(lastStatsRefresh.plusSeconds(AUTO_REFRESH_STATS_COOLDOWN_SECONDS))
				|| now.isBefore(lastFlush.plusSeconds(AUTO_REFRESH_LAST_FLUSH_GRACE_PERIOD_SECONDS)))
			{
				return;
			}
		}

		lastStatsRefresh = Instant.now();

		if (config.enableAnonymousUploading() || loggedPlayerName == null)
		{
			SwingUtilities.invokeLater(() ->
			{
				panel.setPlayerStatsMap(null);
				panel.setPlayerStatsLoading(false);
				panel.setWarningVisible(BotDetectorPanel.WarningLabel.ANONYMOUS, config.enableAnonymousUploading());
				panel.setWarningVisible(BotDetectorPanel.WarningLabel.PLAYER_STATS_ERROR, false);
				if (loggedPlayerName == null)
				{
					panel.forceHideFeedbackPanel();
				}
				panel.forceHideFlaggingPanel();
			});
			return;
		}

		SwingUtilities.invokeLater(() ->
		{
			panel.setPlayerStatsLoading(true);
			panel.setWarningVisible(BotDetectorPanel.WarningLabel.ANONYMOUS, false);
		});

		String nameAtRequest = loggedPlayerName;
		detectorClient.requestPlayerStats(nameAtRequest)
			.whenComplete((psm, ex) ->
			{
				// Player could have logged out in the mean time, don't update panel
				// Player could also have switched to anon mode, don't update either.
				if (config.enableAnonymousUploading() || !nameAtRequest.equals(loggedPlayerName))
				{
					return;
				}

				SwingUtilities.invokeLater(() -> panel.setPlayerStatsLoading(false));

				if (ex == null && psm != null)
				{
					SwingUtilities.invokeLater(() ->
					{
						panel.setPlayerStatsMap(psm);
						panel.setWarningVisible(BotDetectorPanel.WarningLabel.PLAYER_STATS_ERROR, false);
					});
				}
				else
				{
					SwingUtilities.invokeLater(() ->
						panel.setWarningVisible(BotDetectorPanel.WarningLabel.PLAYER_STATS_ERROR, true));
				}
			});
	}

	@Subscribe
	private void onBotDetectorPanelActivated(BotDetectorPanelActivated event)
	{
		if (!config.enableAnonymousUploading())
		{
			refreshPlayerStats(false);
		}
	}

	@Subscribe
	private void onConfigChanged(ConfigChanged event)
	{
		if (!event.getGroup().equals(BotDetectorConfig.CONFIG_GROUP) || event.getKey() == null)
		{
			return;
		}

		switch (event.getKey())
		{
			case BotDetectorConfig.ADD_PREDICT_PLAYER_OPTION_KEY:
				if (client != null)
				{
					menuManager.removePlayerMenuItem(PREDICT_OPTION);

					if (config.addPredictPlayerOption())
					{
						menuManager.addPlayerMenuItem(PREDICT_OPTION);
					}
				}
				break;
			case BotDetectorConfig.ANONYMOUS_UPLOADING_KEY:
				refreshPlayerStats(true);
				SwingUtilities.invokeLater(() ->
				{
					panel.forceHideFeedbackPanel();
					panel.forceHideFlaggingPanel();
				});
				break;
			case BotDetectorConfig.ACKNOWLEDGED_HARASSMENT_WARNING_KEY:
				SwingUtilities.invokeLater(() ->
					panel.setWarningVisible(
						BotDetectorPanel.WarningLabel.HARASSMENT_WARNING,
						!config.acknowledgedHarassmentWarning()));
				break;
			case BotDetectorConfig.PANEL_FONT_TYPE_KEY:
				SwingUtilities.invokeLater(() -> panel.setFontType(config.panelFontType()));
				break;
			case BotDetectorConfig.SHOW_FEEDBACK_TEXTBOX:
				SwingUtilities.invokeLater(() -> panel.setFeedbackTextboxVisible(config.showFeedbackTextbox()));
				break;
			case BotDetectorConfig.AUTO_SEND_MINUTES_KEY:
			case BotDetectorConfig.ONLY_SEND_AT_LOGOUT_KEY:
				updateTimeToAutoSend();
				break;
		}
	}

	@Subscribe
	private void onGameStateChanged(GameStateChanged event)
	{
		switch (event.getGameState())
		{
			case LOGIN_SCREEN:
				if (loggedPlayerName != null)
				{
					flushPlayersToClient(false);
					persistentSightings.clear();
					feedbackedPlayers.clear();
					feedbackedPlayersText.clear();
					flaggedPlayers.clear();
					loggedPlayerName = null;

					refreshPlayerStats(true);
					SwingUtilities.invokeLater(() -> panel.setWarningVisible(BotDetectorPanel.WarningLabel.NAME_ERROR, false));
					lastStatsRefresh = Instant.MIN;
				}
				break;
			case LOGGED_IN:
				// Reload Sighting cache when passing from LOGGED_IN -> LOADING -> LOGGED_IN
				if (!isCurrentWorldBlocked && loggedPlayerName != null
					&& previousTwoGameStates.contains(GameState.LOGGED_IN)
					&& previousTwoGameStates.contains(GameState.LOADING))
				{
					Set<Player> allPlayers = getAllPlayers();
					if (allPlayers != null)
					{
						allPlayers.forEach(this::processPlayer);
					}
				}
				break;
		}
		previousTwoGameStates.offer(event.getGameState());
	}

	@Subscribe
	private void onPlayerSpawned(PlayerSpawned event)
	{
		processPlayer(event.getPlayer());
	}

	/**
	 * Processes the given {@code player}, creating and saving a {@link PlayerSighting}.
	 * @param player The player to process.
	 */
	private void processPlayer(Player player)
	{
		if (player == null)
		{
			return;
		}

		String rawName = player.getName();

		boolean invalidName = rawName == null || rawName.length() == 0 || rawName.charAt(0) == '#' || rawName.charAt(0) == '[';

		if (player == client.getLocalPlayer())
		{
			if (loggedPlayerName == null || !loggedPlayerName.equals(rawName))
			{
				if (invalidName)
				{
					loggedPlayerName = null;
					SwingUtilities.invokeLater(() -> panel.setWarningVisible(BotDetectorPanel.WarningLabel.NAME_ERROR, true));
				}
				else
				{
					loggedPlayerName = rawName;
					updateTimeToAutoSend();
					refreshPlayerStats(true);
					SwingUtilities.invokeLater(() -> panel.setWarningVisible(BotDetectorPanel.WarningLabel.NAME_ERROR, false));
				}
			}
			return;
		}
		// Check for and ignore fake duplicate of the localplayer held in top level view during sailing
		// In other words, if a player object shares the same ID as the localplayer, but isn't localplayer, drop it
		else if (player.getId() == client.getLocalPlayer().getId())
		{
			return;
		}

		// Block processing AFTER local player check
		if (isCurrentWorldBlocked || invalidName)
		{
			return;
		}

		String playerName = normalizePlayerName(rawName);
		CaseInsensitiveString wrappedName = wrap(playerName);

		// Maybe using clientThread will help with whatever is going on with instance regions sneaking through?
		// Theory is on some machines, maybe isInInstance() returns false, but player gets changed before getWorldLocation() runs?
		// IDK man I can't ever seem to be able to repro this...
		clientThread.invoke(() ->
			{
				WorldView wv = player.getWorldView();
				boolean instanced = wv != null && wv.isInstance();
				boolean isBoat = wv != null && wv.getId() != WorldView.TOPLEVEL && client != null && client.getTopLevelWorldView() != null;

				WorldPoint wp = player.getWorldLocation();
				if (isBoat)
				{
					// Appears to give us the center of the boat, good enough for now
					WorldEntity we = client.getTopLevelWorldView().worldEntities().byIndex(wv.getId());
					wp = WorldPoint.fromLocalInstance(client, we.getLocalLocation());
				}
				else if (instanced)
				{
					wp = WorldPoint.fromLocalInstance(client, player.getLocalLocation());
				}

				if (wp.getRegionID() > MAX_ALLOWED_REGION_ID)
				{
					log.warn(String.format("Player sighting with invalid region ID. (name:'%s' x:%d y:%d z:%d r:%d)",
						playerName, wp.getX(), wp.getY(), wp.getPlane(), wp.getRegionID()));
					return;
				}

				// Get player's equipment item ids (botanicvelious/Equipment-Inspector)
				Map<KitType, Integer> equipment = new HashMap<>();
				long geValue = 0;
				for (KitType kitType : KitType.values())
				{
					int itemId = player.getPlayerComposition().getEquipmentId(kitType);
					if (itemId >= 0)
					{
						equipment.put(kitType, itemId);
						// Use GE price, not Wiki price
						geValue += itemManager.getItemPriceWithSource(itemId, false);
					}
				}

				PlayerSighting p = PlayerSighting.builder()
					.playerName(playerName)
					.regionID(wp.getRegionID())
					.worldX(wp.getX())
					.worldY(wp.getY())
					// If coordinate comes from a boat, add 64 to the plane (z) coordinate
					// We'll handle it on the server later
					.plane(wp.getPlane() + (isBoat ? 64 : 0))
					.equipment(equipment)
					.equipmentGEValue(geValue)
					.timestamp(Instant.now())
					.worldNumber(currentWorldNumber)
					.inMembersWorld(isCurrentWorldMembers)
					.inPVPWorld(isCurrentWorldPVP)
					.build();

				synchronized (sightingTable)
				{
					sightingTable.put(wrappedName, p.getRegionID(), p);
				}
				persistentSightings.put(wrappedName, p);
			}
		);
	}

	@Subscribe
	private void onCommandExecuted(CommandExecuted event)
	{
		Consumer<String[]> consumer = commandConsumerMap.get(wrap(event.getCommand()));
		if (consumer != null)
		{
			consumer.accept(event.getArguments());
		}
	}

	@Subscribe
	private void onClientShutdown(ClientShutdown event)
	{
		if (config.uploadOnShutdown())
		{
			CompletableFuture<Boolean> future = flushPlayersToClient(false);
			if (future != null)
			{
				event.waitFor(future);
			}
		}
	}

	/**
	 * Parses the Author and Code from the given message arguments and sends them over to
	 * {@link BotDetectorClient#verifyDiscord(String, String, String)} for verification.
	 * Requires that {@link #authToken} has the {@link AuthTokenPermission#VERIFY_DISCORD} permission.
	 * @param chatMessage The ChatMessage event object.
	 * @param message The actual chat message.
	 */
	private void verifyDiscord(ChatMessage chatMessage, String message)
	{
		if (!authToken.getTokenType().getPermissions().contains(AuthTokenPermission.VERIFY_DISCORD))
		{
			return;
		}

		if (message.length() <= VERIFY_DISCORD_COMMAND.length())
		{
			return;
		}

		String author;
		if (chatMessage.getType().equals(ChatMessageType.PRIVATECHATOUT))
		{
			author = loggedPlayerName;
		}
		else
		{
			author = Text.sanitize(chatMessage.getName());
		}

		String code = message.substring(VERIFY_DISCORD_COMMAND.length() + 1).trim();

		if (!VERIFY_DISCORD_CODE_PATTERN.matcher(code).matches())
		{
			return;
		}

		detectorClient.verifyDiscord(authToken.getToken(), author,
			StringUtils.leftPad(code, VERIFY_DISCORD_CODE_SIZE, '0'))
			.whenComplete((b, ex) ->
			{
				if (ex == null && b)
				{
					sendChatStatusMessage("Discord verified for '" + author + "'!", true);
				}
				else if (ex instanceof UnauthorizedTokenException)
				{
					sendChatStatusMessage("Invalid token for Discord verification, cannot verify '" + author + "'.", true);
				}
				else if (config.showDiscordVerificationErrors())
				{
					sendChatStatusMessage("Could not verify Discord for '" + author + "'" + (ex != null ? ": " + ex.getMessage() : "."), true);
				}
			});
	}

	/**
	 * Displays the Bot Detector statistics for the message's author
	 * @param chatMessage The ChatMessage event object.
	 * @param message The actual chat message.
	 */
	private void statsChatCommand(ChatMessage chatMessage, String message)
	{
		if (message.length() != STATS_CHAT_COMMAND.length())
		{
			return;
		}

		final StatsCommandDetailLevel detailLevel = config.statsChatCommandDetailLevel();
		if (detailLevel == StatsCommandDetailLevel.OFF)
		{
			return;
		}

		final String author;
		if (chatMessage.getType().equals(ChatMessageType.PRIVATECHATOUT))
		{
			author = loggedPlayerName;
		}
		else
		{
			author = Text.sanitize(chatMessage.getName());
		}

		detectorClient.requestPlayerStats(author)
			.whenComplete((map, ex) ->
			{
				if (ex == null && map != null)
				{
					PlayerStats totalStats = map.get(PlayerStatsType.TOTAL);

					ChatMessageBuilder response = new ChatMessageBuilder()
						.append(ChatColorType.HIGHLIGHT)
						.append("Bot Detector stats -");

					if (totalStats == null || totalStats.getNamesUploaded() <= 0)
					{
						response.append(ChatColorType.NORMAL)
							.append(" No plugin stats for this player");
					}
					else
					{
						if (detailLevel == StatsCommandDetailLevel.DETAILED)
						{
							response.append(ChatColorType.NORMAL)
								.append(" Total Uploads:")
								.append(ChatColorType.HIGHLIGHT)
								.append(String.format(" %,d", totalStats.getNamesUploaded()))
								.append(ChatColorType.NORMAL)
								.append(" Feedback Sent:")
								.append(ChatColorType.HIGHLIGHT)
								.append(String.format(" %,d", totalStats.getFeedbackSent()))
								.append(ChatColorType.NORMAL)
								.append(" Possible Bans:")
								.append(ChatColorType.HIGHLIGHT)
								.append(String.format(" %,d", totalStats.getPossibleBans()));
						}

						response.append(ChatColorType.NORMAL)
							.append(" Confirmed Bans:")
							.append(ChatColorType.HIGHLIGHT)
							.append(String.format(" %,d", totalStats.getConfirmedBans()));

						PlayerStats manualStats = map.get(PlayerStatsType.MANUAL);
						if (manualStats != null && manualStats.getNamesUploaded() > 0)
						{
							if (detailLevel == StatsCommandDetailLevel.DETAILED)
							{
								response.append(ChatColorType.NORMAL)
									.append(" Manual Flags:")
									.append(ChatColorType.HIGHLIGHT)
									.append(String.format(" %,d", manualStats.getNamesUploaded()))
									.append(ChatColorType.NORMAL)
									.append(" Manual Possible Bans:")
									.append(ChatColorType.HIGHLIGHT)
									.append(String.format(" %,d", manualStats.getPossibleBans()));
							}

							response.append(ChatColorType.NORMAL)
								.append(" Manual Confirmed Bans:")
								.append(ChatColorType.HIGHLIGHT)
								.append(String.format(" %,d", manualStats.getConfirmedBans()));

							response.append(ChatColorType.NORMAL)
								.append(" Manual Flag Accuracy:")
								.append(ChatColorType.HIGHLIGHT)
								.append(new DecimalFormat(" 0.00%").format(manualStats.getAccuracy()));
						}
					}

					final String builtResponse = response.build();
					final MessageNode messageNode = chatMessage.getMessageNode();

					clientThread.invokeLater(() ->
					{
						messageNode.setRuneLiteFormatMessage(builtResponse);
						client.refreshChat();
					});
				}
			});
	}

	@Subscribe
	private void onMenuEntryAdded(MenuEntryAdded event)
	{
		if (!config.addPredictMenuOption())
		{
			return;
		}

		if (event.getType() != MenuAction.CC_OP.getId() && event.getType() != MenuAction.CC_OP_LOW_PRIORITY.getId())
		{
			return;
		}

		final int componentId = event.getActionParam1();
		final int groupId = WidgetUtil.componentToInterface(componentId);
		final String option = event.getOption();

		if (groupId == InterfaceID.FRIENDS && option.equals("Delete")
			|| groupId == InterfaceID.CHATCHANNEL_CURRENT && (option.equals("Add ignore") || option.equals("Remove friend"))
			|| groupId == InterfaceID.CHATBOX && (option.equals("Add ignore") || option.equals("Message"))
			|| groupId == InterfaceID.IGNORE && option.equals("Delete")
			|| (componentId == InterfaceID.ClansSidepanel.PLAYERLIST || componentId == InterfaceID.ClansGuestSidepanel.PLAYERLIST) && (option.equals("Add ignore") || option.equals("Remove friend"))
			|| groupId == InterfaceID.PM_CHAT && (option.equals("Add ignore") || option.equals("Message"))
			|| groupId == InterfaceID.GIM_SIDEPANEL && (option.equals("Add friend") || option.equals("Remove friend") || option.equals("Remove ignore")))
		{
			// TODO: Properly use the new menu entry callbacks
			client.getMenu().createMenuEntry(-1)
				.setOption(getPredictOption(event.getTarget()))
				.setTarget(event.getTarget())
				.setType(MenuAction.RUNELITE)
				.setParam0(event.getActionParam0())
				.setParam1(event.getActionParam1())
				.setIdentifier(event.getIdentifier());
		}
	}

	@Subscribe
	private void onMenuOpened(MenuOpened event)
	{
		// If neither color changing options are set, this is unnecessary
		if (config.predictOptionDefaultColor() == null && config.predictOptionFlaggedColor() == null)
		{
			return;
		}

		boolean changeReportOption = config.applyPredictColorsOnReportOption();
		// Do this once when the menu opens
		// Avoids having to loop the menu entries on every 'added' event
		MenuEntry[] menuEntries = event.getMenuEntries();
		for (MenuEntry entry : menuEntries)
		{
			int type = entry.getType().getId();
			if (type >= MenuAction.MENU_ACTION_DEPRIORITIZE_OFFSET)
			{
				type -= MenuAction.MENU_ACTION_DEPRIORITIZE_OFFSET;
			}

			if (type == MenuAction.RUNELITE_PLAYER.getId()
				&& entry.getOption().equals(PREDICT_OPTION))
			{
				Player player = entry.getPlayer();
				if (player != null)
				{
					entry.setOption(getPredictOption(player.getName()));
				}
			}

			// Check for Report option
			if (changeReportOption && entry.getOption().equals(REPORT_OPTION)
				&& (PLAYER_MENU_ACTIONS.contains(entry.getType()) || entry.getType() == MenuAction.CC_OP_LOW_PRIORITY))
			{
				Player player = entry.getPlayer();
				if (player != null)
				{
					entry.setOption(getReportOption(player.getName()));
				}
			}
		}
	}

	@Subscribe
	private void onMenuOptionClicked(MenuOptionClicked event)
	{
		String optionText = Text.removeTags(event.getMenuOption());
		if (((event.getMenuAction() == MenuAction.RUNELITE || event.getMenuAction() == MenuAction.RUNELITE_PLAYER)
				&& optionText.equals(PREDICT_OPTION))
			|| (config.predictOnReport() && (PLAYER_MENU_ACTIONS.contains(event.getMenuAction()) || event.getMenuAction() == MenuAction.CC_OP_LOW_PRIORITY)
				&& optionText.equals(REPORT_OPTION)))
		{
			String name;
			if (event.getMenuAction() == MenuAction.RUNELITE_PLAYER
				|| PLAYER_MENU_ACTIONS.contains(event.getMenuAction()))
			{
				Player player = event.getMenuEntry().getPlayer();
				if (player == null)
				{
					return;
				}
				name = player.getName();
			}
			else
			{
				name = event.getMenuTarget();
			}

			if (name != null)
			{
				String toPredict = Text.removeTags(name);
				if (config.predictOptionCopyName())
				{
					Toolkit.getDefaultToolkit().getSystemClipboard().setContents(new StringSelection(toPredict), null);
				}
				predictPlayer(toPredict);
			}
		}
	}

	@Subscribe
	private void onWorldChanged(WorldChanged event)
	{
		processCurrentWorld();
	}

	/**
	 * Opens the plugin panel and sends over {@code playerName} to {@link BotDetectorPanel#predictPlayer(String)} for prediction.
	 * @param playerName The player name to predict.
	 */
	public void predictPlayer(String playerName)
	{
		SwingUtilities.invokeLater(() ->
		{
			clientToolbar.openPanel(navButton);
			panel.predictPlayer(playerName);
		});
	}

	/**
	 * Sends a message to the in-game chatbox if {@link BotDetectorConfig#enableChatStatusMessages()} is {@code true}.
	 * @param msg The message to send.
	 */
	public void sendChatStatusMessage(String msg)
	{
		sendChatStatusMessage(msg, false);
	}

	/**
	 * Sends a message to the in-game chatbox.
	 * @param msg The message to send.
	 * @param forceShow If {@code true}, bypasses {@link BotDetectorConfig#enableChatStatusMessages()}.
	 */
	public void sendChatStatusMessage(String msg, boolean forceShow)
	{
		if ((forceShow || config.enableChatStatusMessages()) && loggedPlayerName != null)
		{
			final String message = new ChatMessageBuilder()
				.append(ChatColorType.HIGHLIGHT)
				.append(CHAT_MESSAGE_HEADER + msg)
				.build();

			chatMessageManager.queue(
				QueuedMessage.builder()
					.type(ChatMessageType.CONSOLE)
					.runeLiteFormattedMessage(message)
					.build());
		}
	}

	/**
	 * Sets various class variables and panel warnings according to what {@link Client#getWorld()} returns.
	 */
	private void processCurrentWorld()
	{
		currentWorldNumber = client.getWorld();
		EnumSet<WorldType> types = client.getWorldType();
		isCurrentWorldMembers = types.contains(WorldType.MEMBERS);
		isCurrentWorldPVP = types.contains(WorldType.PVP);
		isCurrentWorldBlocked = !ALLOWED_PROFILE_TYPES.contains(RuneScapeProfileType.getCurrent(client));
		SwingUtilities.invokeLater(() ->
			panel.setWarningVisible(BotDetectorPanel.WarningLabel.BLOCKED_WORLD, isCurrentWorldBlocked));
	}

	/**
	 * Gets the name that should be used when an uploader name is required,
	 * according to {@link BotDetectorConfig#enableAnonymousUploading()}.
	 * @return {@link #loggedPlayerName} or {@link #ANONYMOUS_USER_NAME}. Returns {@code null} if logged out.
	 */
	public String getUploaderName()
	{
		return getUploaderName(false);
	}

	/**
	 * Gets the name that should be used when an uploader name is required,
	 * according to {@link BotDetectorConfig#enableAnonymousUploading()}.
	 * @param useAnonymousUUIDFormat Whether or not to use the UUID anonymous username format.
	 * @return {@link #loggedPlayerName} if not anonymous. When anonymous, returns
	 * {@link #ANONYMOUS_USER_NAME_UUID_FORMAT} with {@link #anonymousUUID}
	 * or simply {@link #ANONYMOUS_USER_NAME} depending on {@code useAnonymousUUIDFormat}.
	 * Returns {@code null} if logged out.
	 */
	public String getUploaderName(boolean useAnonymousUUIDFormat)
	{
		if (loggedPlayerName == null)
		{
			return null;
		}

		if (config.enableAnonymousUploading())
		{
			return useAnonymousUUIDFormat ?
				String.format(ANONYMOUS_USER_NAME_UUID_FORMAT, anonymousUUID)
				: ANONYMOUS_USER_NAME;
		}

		return loggedPlayerName;
	}

	/**
	 * Gets the correct variant of {@link #PREDICT_OPTION} to show for the given {@code player}.
	 * @param playerName The player to get the menu option string for.
	 * @return A variant of {@link #PREDICT_OPTION} prepended or not with some color.
	 */
	private String getPredictOption(String playerName)
	{
		return getMenuOption(playerName, PREDICT_OPTION);
	}

	/**
	 * Gets the correct variant of {@link #REPORT_OPTION} to show for the given {@code player}.
	 * @param playerName The player to get the menu option string for.
	 * @return A variant of {@link #REPORT_OPTION} prepended or not with some color.
	 */
	private String getReportOption(String playerName)
	{
		return getMenuOption(playerName, REPORT_OPTION);
	}

	/**
	 * Gets the correct variant of the given option string to show for the given {@code player}.
	 * @param playerName The player to get the menu option string for.
	 * @return A variant of the option string prepended or not with some color.
	 */
	private String getMenuOption(String playerName, String option)
	{
		CaseInsensitiveString name = normalizeAndWrapPlayerName(playerName);
		Color prepend = (feedbackedPlayers.containsKey(name) || flaggedPlayers.containsKey(name)) ?
			config.predictOptionFlaggedColor() : config.predictOptionDefaultColor();

		return prepend != null ? ColorUtil.prependColorTag(option, prepend) : option;
	}

	private Set<Player> getAllPlayers()
	{
		WorldView top = client.getTopLevelWorldView();
		if (top == null)
		{
			return null;
		}

		HashSet<Player> pSet = new HashSet<>();
		getAllPlayersRecurse(top, pSet);

		return pSet;
	}

	private void getAllPlayersRecurse(WorldView wv, HashSet<Player> pSet)
	{
		if (wv == null)
		{
			return;
		}
		wv.players().stream().forEach(pSet::add);
		for (WorldView sub : wv.worldViews())
		{
			getAllPlayersRecurse(sub, pSet);
		}
	}

	/**
	 * Normalizes the given {@code playerName} by sanitizing the player name string,
	 * removing any Jagex tags and replacing any {@code _} or {@code -} with spaces.
	 * @param playerName The player name to normalize.
	 * @return The normalized {@code playerName}.
	 */
	public static String normalizePlayerName(String playerName)
	{
		if (playerName == null)
		{
			return null;
		}

		return Text.removeTags(Text.toJagexName(playerName));
	}

	/**
	 * Normalizes the given {@code playerName} using {@link #normalizePlayerName(String)},
	 * then wraps the resulting {@link String} with {@link CaseInsensitiveString#wrap(String)}.
	 * @param playerName The player name to normalize and wrap.
	 * @return A {@link CaseInsensitiveString} containing the normalized {@code playerName}.
	 */
	public static CaseInsensitiveString normalizeAndWrapPlayerName(String playerName)
	{
		return wrap(normalizePlayerName(playerName));
	}

	//region Commands

	/**
	 * Manually executes {@link #flushPlayersToClient(boolean, boolean)},
	 * first checking that {@link #lastFlush} did not occur within {@link #MANUAL_FLUSH_COOLDOWN_SECONDS}.
	 */
	private void manualFlushCommand()
	{
		Instant canFlush = lastFlush.plusSeconds(MANUAL_FLUSH_COOLDOWN_SECONDS);
		Instant now = Instant.now();
		if (now.isAfter(canFlush))
		{
			if (flushPlayersToClient(true, true) == null)
			{
				sendChatStatusMessage("No player sightings to flush!", true);
			}
		}
		else
		{
			long secs = (Duration.between(now, canFlush).toMillis() / 1000) + 1;
			sendChatStatusMessage("Please wait " + secs + " seconds before manually flushing players.", true);
		}
	}

	/**
	 * Manually force a full rescan of all players in {@link WorldView#players()} using {@link #processPlayer(Player)}.
	 */
	private void manualSightCommand()
	{
		if (isCurrentWorldBlocked)
		{
			sendChatStatusMessage("Cannot refresh player sightings on a blocked world.", true);
		}
		else if (client.getGameState() != GameState.LOGGED_IN)
		{
			// Just in case!
			sendChatStatusMessage("Current game state must be 'LOGGED_IN'!", true);
		}
		else
		{
			Set<Player> allPlayers = getAllPlayers();
			if (allPlayers != null)
			{
				allPlayers.forEach(this::processPlayer);
				sendChatStatusMessage("Player sightings refreshed.", true);
			}
			else
			{
				sendChatStatusMessage("Could not refresh player sightings for an unknown reason.", true);
			}
		}
	}

	/**
	 * Manually force executes {@link #refreshPlayerStats(boolean)}.
	 */
	private void manualRefreshStatsCommand()
	{
		refreshPlayerStats(true);
		sendChatStatusMessage("Refreshing player stats...", true);
	}

	/**
	 * Shows or hides the player ID field in the plugin panel using {@link BotDetectorPanel#setPlayerIdVisible(boolean)}.
	 * @param args String arguments from {@link CommandExecuted#getArguments()}, requires 1 argument being either "0" or "1".
	 */
	private void showHideIdCommand(String[] args)
	{
		String arg = args.length > 0 ? args[0] : "";
		switch (arg)
		{
			case "1":
				SwingUtilities.invokeLater(() -> panel.setPlayerIdVisible(true));
				sendChatStatusMessage("Player ID field added to panel.", true);
				break;
			case "0":
				SwingUtilities.invokeLater(() -> panel.setPlayerIdVisible(false));
				sendChatStatusMessage("Player ID field hidden.", true);
				break;
			default:
				sendChatStatusMessage("Argument must be 0 or 1.", true);
				break;
		}
	}

	/**
	 * Gets the currently loaded {@link AuthToken} and copies it into the user's system clipboard.
	 */
	private void putAuthTokenIntoClipboardCommand()
	{
		if (authToken.getTokenType() == AuthTokenType.NONE)
		{
			sendChatStatusMessage("No auth token currently set.", true);
		}
		else
		{
			Toolkit.getDefaultToolkit().getSystemClipboard().setContents(
				new StringSelection(authToken.toFullToken()), null);
			sendChatStatusMessage(authToken.getTokenType() + " auth token copied to clipboard.", true);
		}
	}

	/**
	 * Sets the {@link AuthToken} saved in {@link BotDetectorConfig#authFullToken()} to the contents of the clipboard,
	 * assuming the contents respect the defined token format in {@link AuthToken#AUTH_TOKEN_PATTERN}.
	 */
	private void setAuthTokenFromClipboardCommand()
	{
		final String clipboardText;
		try
		{
			clipboardText = Toolkit.getDefaultToolkit()
				.getSystemClipboard()
				.getData(DataFlavor.stringFlavor)
				.toString().trim();
		}
		catch (IOException | UnsupportedFlavorException ex)
		{
			sendChatStatusMessage("Unable to read system clipboard for dev token.", true);
			log.warn("Error reading clipboard", ex);
			return;
		}

		AuthToken token = AuthToken.fromFullToken(clipboardText);

		if (token.getTokenType() == AuthTokenType.NONE)
		{
			sendChatStatusMessage(AuthToken.AUTH_TOKEN_DESCRIPTION_MESSAGE, true);
		}
		else
		{
			authToken = token;
			config.setAuthFullToken(token.toFullToken());
			sendChatStatusMessage(token.getTokenType() + " auth token successfully set from clipboard.", true);
		}
	}

	/**
	 * Clears the current {@link AuthToken} saved in {@link BotDetectorConfig#authFullToken()}.
	 */
	private void clearAuthTokenCommand()
	{
		authToken = AuthToken.EMPTY_TOKEN;
		config.setAuthFullToken(null);
		sendChatStatusMessage("Auth token cleared.", true);
	}

	/**
	 * Toggles the config value in {@link BotDetectorConfig#showDiscordVerificationErrors()} and notifies the user of the change.
	 */
	private void toggleShowDiscordVerificationErrors()
	{
		boolean newVal = !config.showDiscordVerificationErrors();
		config.setShowDiscordVerificationErrors(newVal);
		if (newVal)
		{
			sendChatStatusMessage("Discord verification errors will now be shown in the chat", true);
		}
		else
		{
			sendChatStatusMessage("Discord verification errors will no longer be shown in the chat", true);
		}
	}

	//endregion


	/**
	 * Displays an error message about being unable to parse a plugin version and links to the Bot Detector Discord.
	 */
	private void displayPluginVersionError()
	{
		JEditorPane ep = new JEditorPane("text/html",
			"<html><body>Could not parse the plugin version from the properties file!"
			+ "<br>This should never happen! Please contact us on our <a href="
			+ BotDetectorPanel.WebLink.DISCORD.getLink() + ">Discord</a>.</body></html>");
		ep.addHyperlinkListener(e ->
		{
			if (e.getEventType().equals(HyperlinkEvent.EventType.ACTIVATED))
			{
				LinkBrowser.browse(e.getURL().toString());
			}
		});
		ep.setEditable(false);
		JOptionPane.showOptionDialog(null, ep,
			"Error starting Bot Detector!", JOptionPane.DEFAULT_OPTION, JOptionPane.ERROR_MESSAGE,
			null, new String[]{"Ok"}, "Ok");
	}
}

/*
 * Copyright (c) 2021, Ferrariic, Seltzer Bro, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.botdetector.events;

/**
 * Event for when the {@link com.botdetector.ui.BotDetectorPanel} is activated.
 */
public class BotDetectorPanelActivated
{
}

/*
 * Copyright (c) 2021, Ferrariic, Seltzer Bro, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.botdetector.http;

import com.botdetector.BotDetectorPlugin;
import com.botdetector.model.FeedbackPredictionLabel;
import com.botdetector.model.PlayerSighting;
import com.botdetector.model.PlayerStats;
import com.botdetector.model.PlayerStatsType;
import com.botdetector.model.Prediction;
import com.google.common.base.Strings;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.gson.Gson;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonSyntaxException;
import com.google.gson.annotations.SerializedName;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.io.IOException;
import java.lang.reflect.Type;
import java.time.Duration;
import java.time.Instant;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.kit.KitType;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.HttpUrl;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;

/**
 * Class containing various methods to interact with the Bot Detector API.
 */
@Slf4j
@Singleton
public class BotDetectorClient
{
	private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");
	private static final String API_VERSION_FALLBACK_WORD = "latest";
	private static final HttpUrl BASE_HTTP_URL = HttpUrl.parse(
		System.getProperty("BotDetectorAPIPath", "https://api.prd.osrsbotdetector.com"));
	private static final Supplier<String> CURRENT_EPOCH_SUPPLIER = () -> String.valueOf(Instant.now().getEpochSecond());

	private static final long LABELS_CACHE_SECONDS = 60 * 60; // One hour

	@Getter
	@AllArgsConstructor
	private enum ApiPath
	{
		DETECTION("v2/report"),
		PLAYER_STATS_REPORTS("v2/player/report/score"),
		PLAYER_STATS_FEEDBACK("v2/player/feedback/score"),
		PREDICTION("v2/player/prediction"),
		FEEDBACK("v2/feedback"),
		LABELS("v2/labels"),
		VERIFY_DISCORD("site/discord_user")
		;

		final String path;
	}

	public OkHttpClient okHttpClient;

	@Inject
	private Gson gson;

	@Getter
	@Setter
	private String pluginVersion;

	private final Supplier<String> pluginVersionSupplier = () ->
		(pluginVersion != null && !pluginVersion.isEmpty()) ? pluginVersion : API_VERSION_FALLBACK_WORD;

	private Collection<LabelAPIItem> cachedLabels = null;
	private Instant lastTimeCachedLabels = Instant.MIN;

	/**
	 * Constructs a base URL for the given {@code path}.
	 * @param path The path to get the base URL for.
	 * @param addVersion Whether to add a version prefix.
	 * @return The base URL for the given {@code path}.
	 */
	private HttpUrl getUrl(ApiPath path, boolean addVersion)
	{
		HttpUrl.Builder builder = BASE_HTTP_URL.newBuilder();

		if (addVersion)
		{
			builder.addPathSegment(pluginVersionSupplier.get());
		}

		return builder.addPathSegments(path.getPath()).build();
	}

	/**
	 * Constructs a base URL for the given {@code path} with no version prefix.
	 * @param path The path to get the base URL for
	 * @return The base URL for the given {@code path}.
	 */
	private HttpUrl getUrl(ApiPath path)
	{
		return getUrl(path, false);
	}

	@Inject
	public BotDetectorClient(OkHttpClient rlClient)
	{
		okHttpClient = rlClient.newBuilder()
			.pingInterval(0, TimeUnit.SECONDS)
			.connectTimeout(30, TimeUnit.SECONDS)
			.readTimeout(30, TimeUnit.SECONDS)
			.addNetworkInterceptor(chain ->
			{
				Request headerRequest = chain.request()
					.newBuilder()
					.header("Request-Epoch", CURRENT_EPOCH_SUPPLIER.get())
					.header("Plugin-Version", pluginVersionSupplier.get())
					.build();
				return chain.proceed(headerRequest);
			})
			.build();
	}

	/**
	 * Sends a single {@link PlayerSighting} to the API to be persisted in the Bot Detector database.
	 * @param sighting The sighting to send.
	 * @param uploaderName The user's player name (See {@link BotDetectorPlugin#getUploaderName()}).
	 * @param manual Whether or not the given sighting is to be manually flagged as a bot by the user.
	 * @return A future that will eventually return a boolean indicating success.
	 */
	public CompletableFuture<Boolean> sendSighting(PlayerSighting sighting, String uploaderName, boolean manual)
	{
		return sendSightings(ImmutableList.of(sighting), uploaderName, manual);
	}

	/**
	 * Sends a collection of {@link PlayerSighting}s to the API to be persisted in the Bot Detector database.
	 * @param sightings The collection of sightings to send.
	 * @param uploaderName The user's player name (See {@link BotDetectorPlugin#getUploaderName()}).
	 * @param manual Whether or not the given sightings are to be manually flagged as bots by the user.
	 * @return A future that will eventually return a boolean indicating success.
	 */
	public CompletableFuture<Boolean> sendSightings(Collection<PlayerSighting> sightings, String uploaderName, boolean manual)
	{
		List<PlayerSightingWrapper> wrappedList = sightings.stream()
			.map(p -> new PlayerSightingWrapper(uploaderName, manual, p)).collect(Collectors.toList());

		Gson bdGson = gson.newBuilder().enableComplexMapKeySerialization()
			.registerTypeAdapter(PlayerSightingWrapper.class, new PlayerSightingWrapperSerializer())
			.registerTypeAdapter(KitType.class, new KitTypeSerializer())
			.registerTypeAdapter(Boolean.class, new BooleanToZeroOneConverter())
			.registerTypeAdapter(Instant.class, new InstantSecondsConverter())
			.create();

		Request request = new Request.Builder()
			.url(getUrl(ApiPath.DETECTION).newBuilder()
				.build())
			.post(RequestBody.create(JSON, bdGson.toJson(wrappedList)))
			.build();

		CompletableFuture<Boolean> future = new CompletableFuture<>();
		okHttpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				log.warn("Error sending player sighting data", e);
				future.completeExceptionally(e);
			}

			@Override
			public void onResponse(Call call, Response response)
			{
				try
				{
					if (!response.isSuccessful())
					{
						throw getIOException(response);
					}

					future.complete(true);
				}
				catch (IOException e)
				{
					log.warn("Error sending player sighting data", e);
					future.completeExceptionally(e);
				}
				finally
				{
					response.close();
				}
			}
		});

		return future;
	}

	/**
	 * Tokenized API route to verify the given player name and code pair for Discord linking.
	 * @param token The auth token to use.
	 * @param nameToVerify The player name up for verification.
	 * @param code The code given by the player.
	 * @return A future that will eventually return a boolean indicating success.
	 */
	public CompletableFuture<Boolean> verifyDiscord(String token, String nameToVerify, String code)
	{
		Request request = new Request.Builder()
			.url(getUrl(ApiPath.VERIFY_DISCORD, true).newBuilder()
				.addPathSegment(token)
				.build())
			.post(RequestBody.create(JSON, gson.toJson(new DiscordVerification(nameToVerify, code))))
			.build();

		CompletableFuture<Boolean> future = new CompletableFuture<>();
		okHttpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				log.warn("Error verifying discord user", e);
				future.completeExceptionally(e);
			}

			@Override
			public void onResponse(Call call, Response response)
			{
				try
				{
					// TODO: Differenciate between bad token and failed auth (return false)
					if (!response.isSuccessful())
					{
						if (response.code() == 401)
						{
							throw new UnauthorizedTokenException("Invalid or unauthorized token for operation");
						}
						else
						{
							throw getIOException(response);
						}
					}

					future.complete(true);
				}
				catch (UnauthorizedTokenException | IOException e)
				{
					log.warn("Error verifying discord user", e);
					future.completeExceptionally(e);
				}
				finally
				{
					response.close();
				}
			}
		});

		return future;
	}

	/**
	 * Sends a feedback to the API for the given prediction. If a feedback is duplicated, the future will return false.
	 * @param pred The prediction object to give a feedback for.
	 * @param uploaderName The user's player name (See {@link BotDetectorPlugin#getUploaderName()}).
	 * @param proposedLabel The user's proposed label and feedback.
	 * @param feedbackText The user's feedback text to include with the feedback.
	 * @return A future that will eventually return a boolean indicating success.
	 */
	public CompletableFuture<Boolean> sendFeedback(Prediction pred, String uploaderName, FeedbackPredictionLabel proposedLabel, String feedbackText)
	{
		Request request = new Request.Builder()
			.url(getUrl(ApiPath.FEEDBACK))
			.post(RequestBody.create(JSON, gson.toJson(new PredictionFeedback(
				uploaderName,
				proposedLabel.getFeedbackValue().getApiValue(),
				pred.getPredictionLabel(),
				Optional.ofNullable(pred.getConfidence()).orElse(0.0),
				pred.getPlayerId(),
				proposedLabel.getLabel(),
				proposedLabel.getLabelConfidence(),
				feedbackText
			)))).build();

		CompletableFuture<Boolean> future = new CompletableFuture<>();
		okHttpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				log.warn("Error sending prediction feedback", e);
				future.completeExceptionally(e);
			}

			@Override
			public void onResponse(Call call, Response response)
			{
				try
				{
					boolean duplicated = false;

					if (!response.isSuccessful())
					{
						IOException ioe = getIOException(response);
						// If the error is because of being a duplicate record, do not throw
						// Instead return false and let the caller handle it
						if (!ioe.getMessage().contains("duplicate_record"))
						{
							throw ioe;
						}
						duplicated = true;
					}

					future.complete(!duplicated);
				}
				catch (IOException e)
				{
					log.warn("Error sending prediction feedback", e);
					future.completeExceptionally(e);
				}
				finally
				{
					response.close();
				}
			}
		});

		return future;
	}

	/**
	 * Requests a bot prediction for the given {@code playerName}.
	 * Breakdown will be provided by default in special cases (see {@link BotDetectorClient#requestPrediction(String, boolean)}).
	 * @param playerName The player name to predict.
	 * @return A future that will eventually return the player's bot prediction.
	 */
	public CompletableFuture<Prediction> requestPrediction(String playerName)
	{
		return requestPrediction(playerName, true);
	}

	/**
	 * Requests a bot prediction for the given {@code playerName}.
	 * @param playerName The player name to predict.
	 * @param receiveBreakdownOnSpecialCases Whether to receive a prediction breakdown in special cases, such as "Player Stats Too Low".
	 * @return A future that will eventually return the player's bot prediction.
	 */
	public CompletableFuture<Prediction> requestPrediction(String playerName, boolean receiveBreakdownOnSpecialCases)
	{
		Request request_pred = new Request.Builder()
			.url(getUrl(ApiPath.PREDICTION).newBuilder()
				.addQueryParameter("name", playerName)
				.addQueryParameter("breakdown", Boolean.toString(receiveBreakdownOnSpecialCases))
				.build())
			.build();

		CompletableFuture<Prediction> predFuture = new CompletableFuture<>();
		okHttpClient.newCall(request_pred).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				log.warn("Error obtaining player prediction data", e);
				predFuture.completeExceptionally(e);
			}

			@Override
			public void onResponse(Call call, Response response)
			{
				try
				{
					Collection<Prediction> preds = processResponse(gson, response, new TypeToken<Collection<Prediction>>()
					{
					}.getType());
					if (preds != null)
					{
						predFuture.complete(preds.stream().findFirst().orElse(null));
						return;
					}
					predFuture.complete(null);
				}
				catch (IOException e)
				{
					log.warn("Error obtaining player prediction data", e);
					predFuture.completeExceptionally(e);
				}
				finally
				{
					response.close();
				}
			}
		});

		CompletableFuture<Collection<LabelAPIItem>> labelsFuture = new CompletableFuture<>();

		Instant now = Instant.now();
		if (Duration.between(lastTimeCachedLabels, now).getSeconds() <= LABELS_CACHE_SECONDS)
		{
			labelsFuture.complete(cachedLabels);
		}
		else
		{
			Request request_labels = new Request.Builder()
				.url(getUrl(ApiPath.LABELS).newBuilder()
					.build())
				.build();

			okHttpClient.newCall(request_labels).enqueue(new Callback()
			{
				@Override
				public void onFailure(Call call, IOException e)
				{
					log.warn("Error obtaining labels data", e);
					labelsFuture.completeExceptionally(e);
				}

				@Override
				public void onResponse(Call call, Response response)
				{
					try
					{
						Collection<LabelAPIItem> labels = processResponse(gson, response, new TypeToken<Collection<LabelAPIItem>>()
						{
						}.getType());
						if (labels != null)
						{
							cachedLabels = labels;
							lastTimeCachedLabels = now;
						}
						labelsFuture.complete(labels);
					}
					catch (IOException e)
					{
						log.warn("Error obtaining player labels data", e);
						labelsFuture.completeExceptionally(e);
					}
					finally
					{
						response.close();
					}
				}
			});
		}

		CompletableFuture<Prediction> finalFuture = new CompletableFuture<>();

		// Doing this so we log only the first future failing, not all 2 within the callback.
		CompletableFuture.allOf(predFuture, labelsFuture).whenComplete((v, e) ->
		{
			if (e != null)
			{
				// allOf will send a CompletionException when one of the futures fail, just get the cause.
				log.warn("Error obtaining player prediction data", e.getCause());
				finalFuture.completeExceptionally(e.getCause());
				return;
			}

			Prediction pred = predFuture.join();
			if (pred == null)
			{
				finalFuture.complete(null);
				return;
			}

			Collection<LabelAPIItem> labels = labelsFuture.join();

			// Re-add predictions as lowercase
			Map<String, Double> newBreakdown = new HashMap<>();
			if (pred.getPredictionBreakdown() != null)
			{
				for (Map.Entry<String, Double> entry : pred.getPredictionBreakdown().entrySet())
				{
					newBreakdown.put(entry.getKey().toLowerCase(), entry.getValue());
				}
			}

			// Add labels that may not be in the breakdown
			if (labels != null)
			{
				for (LabelAPIItem label : labels)
				{
					newBreakdown.putIfAbsent(label.getLabel().toLowerCase(), 0.0);
				}
			}

			// Build a new copy of the prediction object with normalized labels
			finalFuture.complete(
				Prediction.builder()
					.playerName(pred.getPlayerName())
					.playerId(pred.getPlayerId())
					.confidence(pred.getConfidence())
					.predictionBreakdown(newBreakdown)
					.predictionLabel(pred.getPredictionLabel().toLowerCase())
					.build()
			);
		});

		return finalFuture;
	}

	/**
	 * Requests the uploading contributions for the given {@code playerName}.
	 * @param playerName The name to request the uploading contributions.
	 * @return A future that will eventually return the player's statistics.
	 */
	public CompletableFuture<Map<PlayerStatsType, PlayerStats>> requestPlayerStats(String playerName)
	{
		Request requestR = new Request.Builder()
			.url(getUrl(ApiPath.PLAYER_STATS_REPORTS).newBuilder()
				.addQueryParameter("name", playerName)
				.build())
			.build();

		Request requestF = new Request.Builder()
			.url(getUrl(ApiPath.PLAYER_STATS_FEEDBACK).newBuilder()
				.addQueryParameter("name", playerName)
				.build())
			.build();

		CompletableFuture<Collection<PlayerStatsAPIItem>> reportsFuture = new CompletableFuture<>();
		CompletableFuture<Collection<PlayerStatsAPIItem>> feedbackFuture = new CompletableFuture<>();

		okHttpClient.newCall(requestR).enqueue(new PlayerStatsCallback(reportsFuture, gson));
		okHttpClient.newCall(requestF).enqueue(new PlayerStatsCallback(feedbackFuture, gson));

		CompletableFuture<Map<PlayerStatsType, PlayerStats>> finalFuture = new CompletableFuture<>();

		// Doing this so we log only the first future failing, not all 2 within the callback.
		CompletableFuture.allOf(reportsFuture, feedbackFuture).whenComplete((v, e) ->
		{
			if (e != null)
			{
				// allOf will send a CompletionException when one of the futures fail, just get the cause.
				log.warn("Error obtaining player stats data", e.getCause());
				finalFuture.completeExceptionally(e.getCause());
			}
			else
			{
				finalFuture.complete(processPlayerStats(reportsFuture.join(), feedbackFuture.join()));
			}
		});

		return finalFuture;
	}

	/**
	 * Utility class intended for {@link BotDetectorClient#requestPlayerStats(String)}.
	 */
	private class PlayerStatsCallback implements Callback
	{
		private final CompletableFuture<Collection<PlayerStatsAPIItem>> future;
		private final Gson gson;

		public PlayerStatsCallback(CompletableFuture<Collection<PlayerStatsAPIItem>> future, Gson gson)
		{
			this.future = future;
			this.gson = gson;
		}

		@Override
		public void onFailure(Call call, IOException e)
		{
			future.completeExceptionally(e);
		}

		@Override
		public void onResponse(Call call, Response response) throws IOException
		{
			try
			{
				future.complete(processResponse(gson, response,
					new TypeToken<Collection<PlayerStatsAPIItem>>()
					{
					}.getType()));
			}
			catch (IOException e)
			{
				future.completeExceptionally(e);
			}
			finally
			{
				response.close();
			}
		}
	}

	/**
	 * Processes the body of the given response and parses out the contained JSON object.
	 * @param gson The {@link Gson} instance to use for parsing the JSON object in the {@code response}.
	 * @param response The response containing the object to parse in {@link Response#body()}.
	 * @param type The type of the JSON object to parse.
	 * @param <T> The type of the JSON object to parse, inferred from {@code type}.
	 * @return The parsed object, or {@code null} if the API returned a 404.
	 * @throws IOException If the response is unsuccessful or the {@link Response#body()} contains malformed data.
	 */
	private <T> T processResponse(Gson gson, Response response, Type type) throws IOException
	{
		if (!response.isSuccessful())
		{
			if (response.code() == 404)
			{
				return null;
			}

			throw getIOException(response);
		}

		try
		{
			return gson.fromJson(response.body().string(), type);
		}
		catch (IOException | IllegalStateException | JsonSyntaxException ex)
		{
			throw new IOException("Error parsing API response body", ex);
		}
	}

	/**
	 * Gets the {@link IOException} to return for when {@link Response#isSuccessful()} returns false.
	 * @param response The response object to get the {@link IOException} for.
	 * @return The {@link IOException} with the appropriate message for the given {@code response}.
	 */
	private IOException getIOException(Response response)
	{
		int code = response.code();
		if (code >= 400 && code < 500)
		{
			try
			{
				String body = response.body().string();
				try
				{
					Map<String, String> map = gson.fromJson(body,
						new TypeToken<Map<String, String>>()
						{
						}.getType());

					// "error" has priority if it exists, else use "detail" (FastAPI)
					String error = map.get("error");
					if (Strings.isNullOrEmpty(error))
					{
						error = map.getOrDefault("detail", "Unknown " + code + " error from API");
					}
					return new IOException(error);
				}
				catch (JsonSyntaxException ex)
				{
					// If can't parse, just log the response body
					// TODO: Parse actual error info received from FastAPI (details -> loc, msg, ctx, etc.) especially for 422 errors
					log.warn("Received HTTP error code " + code + " from API with the following response body:\n" + body);
					return new IOException("Error " + code + ", see log for more info");
				}
			}
			catch (IOException ex)
			{
				return new IOException("Error " + code + " with no error info", ex);
			}
		}

		return new IOException("Error " + code + " from API");
	}

	/**
	 * Collects the given {@link PlayerStatsAPIItem} into a combined map that the plugin expects.
	 * @param reports The reports usage stats from the API.
	 * @param feedback The feedback stats from the API.
	 * @return The combined processed map expected by the plugin.
	 */
	private Map<PlayerStatsType, PlayerStats> processPlayerStats(Collection<PlayerStatsAPIItem> reports, Collection<PlayerStatsAPIItem> feedback)
	{
		if (reports == null || feedback == null)
		{
			return null;
		}

		PlayerStats passiveStats = countStats(reports.stream().filter(
			r -> r.getManual() != null && !r.getManual()).collect(Collectors.toList()), false);
		PlayerStats manualStats = countStats(reports.stream().filter(
			r -> r.getManual() != null && r.getManual()).collect(Collectors.toList()), true);
		PlayerStats feedbackStats = countStats(feedback, false);

		PlayerStats totalStats = PlayerStats.builder()
			.namesUploaded(passiveStats.getNamesUploaded() + manualStats.getNamesUploaded())
			.confirmedBans(passiveStats.getConfirmedBans() + manualStats.getConfirmedBans())
			.possibleBans(passiveStats.getPossibleBans() + manualStats.getPossibleBans())
			.feedbackSent(feedbackStats.getNamesUploaded()) // Might change the total/passive/manual thing in the future.
			.build();

		return ImmutableMap.of(
			PlayerStatsType.TOTAL, totalStats,
			PlayerStatsType.PASSIVE, passiveStats,
			PlayerStatsType.MANUAL, manualStats
		);
	}

	/**
	 * Utility function for {@link BotDetectorClient#processPlayerStats(Collection, Collection)}.
	 * Compile each element from the API into a {@link PlayerStats} object.
	 * @param fromAPI The returned collections of player stats from the API to accumulate.
	 * @param countIncorrect Intended for manual flagging stats. If true, count confirmed players into {@link PlayerStats#getIncorrectFlags()}.
	 * @return The stats object with accumulated counts from the API.
	 */
	private PlayerStats countStats(Collection<PlayerStatsAPIItem> fromAPI, boolean countIncorrect)
	{
		long total = 0, confirmedBans = 0, possibleBans = 0, incorrectFlags = 0;
		for (PlayerStatsAPIItem item : fromAPI)
		{
			if (item.isBanned())
			{
				confirmedBans += item.getCount();
			}
			else
			{
				if (item.isPossibleBanned())
				{
					possibleBans += item.getCount();
				}

				if (countIncorrect && item.isPlayer())
				{
					incorrectFlags += item.getCount();
				}
			}

			total += item.getCount();
		}

		return PlayerStats.builder()
			.namesUploaded(total)
			.confirmedBans(confirmedBans)
			.possibleBans(possibleBans)
			.incorrectFlags(incorrectFlags)
			.build();
	}

	/**
	 * For use with {@link PlayerSightingWrapperSerializer}.
	 */
	@Value
	private static class PlayerSightingWrapper
	{
		String uploaderName;
		boolean manualDetect;
		PlayerSighting sightingData;
	}

	@Value
	private static class DiscordVerification
	{
		@SerializedName("player_name")
		String nameToVerify;
		String code;
	}

	@Value
	private static class PredictionFeedback
	{
		@SerializedName("player_name")
		String playerName;
		int vote;
		@SerializedName("prediction")
		String predictionLabel;
		// Important: API requires this to be non-null!
		@SerializedName("confidence")
		double predictionConfidence;
		@SerializedName("subject_id")
		long targetId;
		@SerializedName("proposed_label")
		String proposedLabel;
		@SerializedName("proposed_label_confidence")
		Double proposedLabelConfidence;
		@SerializedName("feedback_text")
		String feedbackText;
	}

	@Value
	private static class PlayerStatsAPIItem
	{
		@SerializedName("possible_ban")
		boolean possibleBanned;
		@SerializedName("confirmed_ban")
		boolean banned;
		@SerializedName("confirmed_player")
		boolean player;
		/**
		 * Will be Null for feedbacks
		 */
		@SerializedName("manual_detect")
		Boolean manual;
		long count;
		/**
		 * Will be Null for report counts
		 */
		Long vote;
	}

	@Value
	private static class LabelAPIItem
	{
		int id;
		String label;
	}

	/**
	 * Wrapper around the {@link PlayerSighting}'s json serializer.
	 * Adds the reporter name as an element on the same level as the {@link PlayerSighting}'s fields.
	 */
	private static class PlayerSightingWrapperSerializer implements JsonSerializer<PlayerSightingWrapper>
	{
		@Override
		public JsonElement serialize(PlayerSightingWrapper src, Type typeOfSrc, JsonSerializationContext context)
		{
			JsonElement json = context.serialize(src.getSightingData());
			JsonObject jo = json.getAsJsonObject();
			jo.addProperty("reporter", src.getUploaderName());
			jo.add("manual_detect", context.serialize(src.isManualDetect()));
			return json;
		}
	}

	/**
	 * Serializes a {@link KitType} for the API.
	 */
	private static class KitTypeSerializer implements JsonSerializer<KitType>
	{
		@Override
		public JsonElement serialize(KitType kitType, Type typeOfSrc, JsonSerializationContext context)
		{
			return context.serialize("equip_" + kitType.name().toLowerCase() + "_id");
		}
	}

	/**
	 * Serializes/Deserializes a {@link Boolean} as the integers {@code 0} or {@code 1}.
	 */
	private static class BooleanToZeroOneConverter implements JsonSerializer<Boolean>, JsonDeserializer<Boolean>
	{
		@Override
		public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context)
		{
			return context.serialize(src ? 1 : 0);
		}

		@Override
		public Boolean deserialize(JsonElement json, Type type, JsonDeserializationContext context)
			throws JsonParseException
		{
			return json.getAsInt() != 0;
		}
	}

	/**
	 * Serializes/Unserializes {@link Instant} using {@link Instant#getEpochSecond()}/{@link Instant#ofEpochSecond(long)}
	 */
	private static class InstantSecondsConverter implements JsonSerializer<Instant>, JsonDeserializer<Instant>
	{
		@Override
		public JsonElement serialize(Instant src, Type srcType, JsonSerializationContext context)
		{
			return new JsonPrimitive(src.getEpochSecond());
		}

		@Override
		public Instant deserialize(JsonElement json, Type type, JsonDeserializationContext context)
			throws JsonParseException
		{
			return Instant.ofEpochSecond(json.getAsLong());
		}
	}
}

/*
 * Copyright (c) 2021, Ferrariic, Seltzer Bro, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.botdetector.http;

/**
 * Exception for when a tokenized route in {@link BotDetectorClient} fails due to using a bad or unauthorized token.
 */
public class UnauthorizedTokenException extends Exception
{
	public UnauthorizedTokenException(String message)
	{
		super(message);
	}
}

/*
 * Copyright (c) 2021, Ferrariic, Seltzer Bro, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.botdetector.http;

import java.io.IOException;

/**
 * Exception for when a route in {@link BotDetectorClient} fails due to HTTP Error 422.
 */
public class ValidationException extends IOException
{
	public ValidationException(String message)
	{
		super(message);
	}
}

/*
 * Copyright (c) 2021, Ferrariic, Seltzer Bro, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.botdetector.model;

import java.util.regex.Matcher;
import java.util.regex.Pattern;
import lombok.Value;

/**
 * Wrapper class for a {@link AuthTokenType} and {@link String} (token) pair.
 */
@Value
public class AuthToken
{
	AuthTokenType tokenType;
	String token;

	/**
	 * The default token when no valid token is present.
	 * Contains {@link AuthTokenType#NONE} along with an empty token {@link String}.
	 */
	public static final AuthToken EMPTY_TOKEN = new AuthToken(AuthTokenType.NONE, "");
	/** The separator between the prefix (token type) and suffix (token) part of a full token **/
	public static final String AUTH_TOKEN_SEPARATOR = "|";
	public static final Pattern AUTH_TOKEN_PATTERN = Pattern.compile("^([a-zA-Z_]+)"
		+ Pattern.quote(AUTH_TOKEN_SEPARATOR)
		+ "([\\w\\-]{12,32})$");

	/** Should describe {@link #AUTH_TOKEN_PATTERN} in a human readable form. **/
	public static final String AUTH_TOKEN_DESCRIPTION_MESSAGE =
		"Auth token in clipboard must be of format 'prefix|Suffix_Alpha-numeric'" +
			" with a valid prefix and a suffix between 12 and 32 characters long.";

	/**
	 * Parses out an {@link AuthToken} from the given {@code fullToken}. Also see {@link #toFullToken()}.
	 * @param fullToken The full token to parse.
	 * @return The parsed {@link AuthToken}, or {@link AuthToken#EMPTY_TOKEN} if {@code fullToken} was invalid.
	 */
	public static AuthToken fromFullToken(String fullToken)
	{
		if (fullToken == null)
		{
			return EMPTY_TOKEN;
		}

		Matcher m = AUTH_TOKEN_PATTERN.matcher(fullToken);
		if (m.matches())
		{
			return new AuthToken(AuthTokenType.fromPrefix(m.group(1)), m.group(2));
		}
		else
		{
			return EMPTY_TOKEN;
		}
	}

	/**
	 * Converts this {@link AuthToken} back into a pure {@link String} form parsable with {@link #fromFullToken(String)}.
	 * @return The full token {@link String} form for this {@link AuthToken}.
	 */
	public String toFullToken()
	{
		return tokenType.name() + AUTH_TOKEN_SEPARATOR + token;
	}
}

/*
 * Copyright (c) 2021, Ferrariic, Seltzer Bro, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.botdetector.model;

/**
 * Represents the operations that a given {@link AuthTokenType} should allow.
 */
public enum AuthTokenPermission
{
	/** Allows verification of RSN/Discord pairs in-game **/
	VERIFY_DISCORD
}

/*
 * Copyright (c) 2021, Ferrariic, Seltzer Bro, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.botdetector.model;

import com.google.common.collect.ImmutableSet;
import java.util.Arrays;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import static com.botdetector.model.AuthTokenPermission.*;

@Getter
@RequiredArgsConstructor
public enum AuthTokenType
{
	/**
	 * No permissions
	 */
	NONE(ImmutableSet.of()),

	/**
	 * All permissions
	 */
	DEV(Arrays.stream(AuthTokenPermission.values()).collect(ImmutableSet.toImmutableSet())),

	/**
	 * Can perform discord verification
	 */
	MOD(ImmutableSet.of(VERIFY_DISCORD))
	;

	private final ImmutableSet<AuthTokenPermission> permissions;

	/**
	 * Parses the token type from the given {@code prefix}.
	 * @param prefix The prefix to parse.
	 * @return The token type if parsed successfully, {@link #NONE} otherwise.
	 */
	public static AuthTokenType fromPrefix(String prefix)
	{
		if (prefix == null)
		{
			return AuthTokenType.NONE;
		}

		try
		{
			return AuthTokenType.valueOf(prefix.toUpperCase());
		}
		catch (IllegalArgumentException e)
		{
			return AuthTokenType.NONE;
		}
	}
}

/*
 * Copyright (c) 2016 under CC BY 3.0, CrypticCabub <https://stackoverflow.com/q/39026195>
 * Copyright (c) 2021 under BSD 2, Ferrariic, Seltzer Bro, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.botdetector.model;

import lombok.Value;

/**
 * A string wrapper that makes .equals a caseInsensitive match
 * <p>
 *     a collection that wraps a String mapping in CaseInsensitiveStrings will still accept a String but will now
 *     return a caseInsensitive match rather than a caseSensitive one
 * </p>
 */
@Value
public class CaseInsensitiveString
{
	String str;

	public static CaseInsensitiveString wrap(String str)
	{
		return new CaseInsensitiveString(str);
	}

	@Override
	public boolean equals(Object o)
	{
		if (this == o)
		{
			return true;
		}

		if (o == null)
		{
			return false;
		}

		if (o.getClass() == getClass())
		{
			// Is another CaseInsensitiveString
			CaseInsensitiveString that = (CaseInsensitiveString) o;
			return (str != null) ? str.equalsIgnoreCase(that.str) : that.str == null;
		}

		if (o.getClass() == String.class)
		{
			// Is just a regular String
			String that = (String) o;
			return that.equalsIgnoreCase(str);
		}

		return false;
	}

	@Override
	public int hashCode()
	{
		return (str != null) ? str.toUpperCase().hashCode() : 0;
	}

	@Override
	public String toString()
	{
		return str;
	}
}

/*
 * Copyright (c) 2021, Ferrariic, Seltzer Bro, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.botdetector.model;

import java.util.Objects;
import lombok.Value;
import org.apache.commons.text.WordUtils;

@Value
public class FeedbackPredictionLabel
{
	String label;
	String normalizedLabel;
	FeedbackValue feedbackValue;
	Double labelConfidence;

	public FeedbackPredictionLabel(String label, Double labelConfidence, FeedbackValue feedbackValue)
	{
		this.label = label;
		this.normalizedLabel = normalizeLabel(label);
		this.labelConfidence = labelConfidence;
		this.feedbackValue = feedbackValue;
	}

	@Override
	public boolean equals(Object o)
	{
		if (this == o)
		{
			return true;
		}

		if (o instanceof FeedbackPredictionLabel)
		{
			FeedbackPredictionLabel that = (FeedbackPredictionLabel) o;
			return Objects.equals(label, that.label)
				&& Objects.equals(labelConfidence, that.labelConfidence)
				&& Objects.equals(feedbackValue, that.feedbackValue);
		}

		return false;
	}

	@Override
	public int hashCode()
	{
		return (label != null ? label.hashCode() : 0)
			+ (labelConfidence != null ? labelConfidence.hashCode() : 0)
			+ (feedbackValue != null ? feedbackValue.hashCode() : 0);
	}

	@Override
	public String toString()
	{
		return normalizedLabel;
	}

	/**
	 * Normalizes the given prediction label by separating word
	 * with spaces and making each word capitalized.
	 * @param label The label to normalize.
	 * @return The normalized label.
	 */
	public static String normalizeLabel(String label)
	{
		if (label == null)
		{
			return null;
		}

		return WordUtils.capitalize(label.replace('_', ' ').trim(), ' ');
	}
}

/*
 * Copyright (c) 2021, Ferrariic, Seltzer Bro, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.botdetector.model;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum FeedbackValue
{
	POSITIVE(1),
	NEGATIVE(-1),
	NEUTRAL(0)
	;

	private final int apiValue;
}

/*
 * Copyright (c) 2021, Ferrariic, Seltzer Bro, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.botdetector.model;

import com.google.gson.annotations.SerializedName;
import java.time.Instant;
import java.util.Map;
import lombok.Builder;
import lombok.Value;
import net.runelite.api.kit.KitType;

@Value
@Builder
public class PlayerSighting
{
	@SerializedName("reported")
	String playerName;

	@SerializedName("region_id")
	int regionID;

	@SerializedName("x_coord")
	int worldX;

	@SerializedName("y_coord")
	int worldY;

	@SerializedName("z_coord")
	int plane;

	@SerializedName("equipment")
	Map<KitType, Integer> equipment;

	@SerializedName("equipment_ge_value")
	long equipmentGEValue;

	@SerializedName("world_number")
	int worldNumber;

	@SerializedName("on_members_world")
	boolean inMembersWorld;

	@SerializedName("on_pvp_world")
	boolean inPVPWorld;

	@SerializedName("ts")
	Instant timestamp;
}

/*
 * Copyright (c) 2021, Ferrariic, Seltzer Bro, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.botdetector.model;

import lombok.Builder;
import lombok.Value;

@Value
@Builder
public class PlayerStats
{
	long namesUploaded;
	long confirmedBans;
	long possibleBans;
	long incorrectFlags;
	long feedbackSent;

	/**
	 * The accuracy represents {@link #confirmedBans} divided by
	 * the sum of {@link #confirmedBans} and {@link #incorrectFlags}.
	 */
	public double getAccuracy()
	{
		long divisor = incorrectFlags + confirmedBans;
		return divisor > 0 ? confirmedBans / (double)divisor : 0;
	}
}

package com.botdetector.model;

import com.google.gson.annotations.SerializedName;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.experimental.Accessors;

@Getter
@RequiredArgsConstructor
public enum PlayerStatsType
{
	@SerializedName("manual")
	MANUAL("Manual", "Manual uploading statistics, uploads from manually flagging a player as a bot.", true),
	@SerializedName("passive")
	PASSIVE("Auto", "Passive uploading statistics, uploads from simply seeing other players in-game.", false),
	@SerializedName("total")
	TOTAL("Total", "Total uploading statistics, both passive and manual.", false)
	;

	private final String shorthand;
	private final String description;
	@Accessors(fluent = true)
	private final boolean canDisplayAccuracy;

	@Override
	public String toString()
	{
		return shorthand;
	}
}

/*
 * Copyright (c) 2021, Ferrariic, Seltzer Bro, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.botdetector.model;

import com.google.gson.annotations.SerializedName;
import java.util.Map;
import lombok.Value;
import lombok.Builder;

@Value
@Builder
public class Prediction
{
	@SerializedName("player_id")
	long playerId;
	@SerializedName("player_name")
	String playerName;
	@SerializedName("prediction_label")
	String predictionLabel;
	@SerializedName("prediction_confidence")
	Double confidence;
	@SerializedName("predictions_breakdown")
	Map<String, Double> predictionBreakdown;
}

/*
 * Copyright (c) 2021, Ferrariic, Seltzer Bro, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.botdetector.model;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum StatsCommandDetailLevel
{
	OFF("Disabled"),
	CONFIRMED_ONLY("Confirmed Bans"),
	DETAILED("Detailed Stats")
	;

	private final String name;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2021, Ferrariic, Seltzer Bro, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.botdetector.ui;

import com.botdetector.BotDetectorConfig;
import com.botdetector.BotDetectorPlugin;
import static com.botdetector.BotDetectorPlugin.normalizeAndWrapPlayerName;
import com.botdetector.events.BotDetectorPanelActivated;
import com.botdetector.http.BotDetectorClient;
import com.botdetector.model.CaseInsensitiveString;
import com.botdetector.model.FeedbackValue;
import com.botdetector.model.FeedbackPredictionLabel;
import static com.botdetector.model.FeedbackPredictionLabel.normalizeLabel;
import com.botdetector.model.PlayerSighting;
import com.botdetector.model.PlayerStats;
import com.botdetector.model.PlayerStatsType;
import com.botdetector.model.Prediction;
import com.botdetector.ui.components.ComboBoxSelfTextTooltipListRenderer;
import com.botdetector.ui.components.JLimitedTextArea;
import com.formdev.flatlaf.FlatClientProperties;
import com.google.common.primitives.Doubles;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.event.ItemEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.text.DecimalFormat;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;
import javax.inject.Inject;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.SwingUtilities;
import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.QuantityFormatter;
import org.apache.commons.text.StringEscapeUtils;

public class BotDetectorPanel extends PluginPanel
{
	@Getter
	@AllArgsConstructor
	public enum WebLink
	{
		WEBSITE(Icons.WEB_ICON, "Our website", "https://www.osrsbotdetector.com/"),
		TWITTER(Icons.TWITTER_ICON, "Follow us on X!", "https://www.twitter.com/OSRSBotDetector"),
		DISCORD(Icons.DISCORD_ICON, "Join our Discord!", "https://discord.com/invite/JCAGpcjbfP"),
		GITHUB(Icons.GITHUB_ICON, "Check out the project's source code", "https://github.com/Bot-detector"),
		PATREON(Icons.PATREON_ICON, "Help keep us going!", "https://www.patreon.com/Ferrariic")
		;

		private final ImageIcon image;
		private final String tooltip;
		private final String link;
	}

	@Getter
	@AllArgsConstructor
	public enum WarningLabel
	{
		ANONYMOUS(Icons.WARNING_ICON, " Anonymous Uploading Active",
			"<html>Your name will not be included with your uploads and your tallies will not increase."
				+ "<br>Manual bot flagging is also disabled.</html>"),
		BLOCKED_WORLD(Icons.WARNING_ICON, " No Uploading For Current World",
			"<html>You are currently logged into a world where player sightings are not being collected."
				+ "<br>Your tallies will not increase from seeing players in this world.</html>"),
		PLAYER_STATS_ERROR(Icons.ERROR_ICON, " Could Not Retrieve Statistics",
			"<html>Your player statistics could not be retrieved at this time."
				+ "<br>Either the server could not assign you an ID or the server is down at the moment.</html>"),
		NAME_ERROR(Icons.ERROR_ICON, " Invalid Player Name",
			"<html>Your player name could not be loaded correctly."
				+ "<br>Most likely you spawned on Tutorial Island or your name was forcibly reset by Jagex."
				+ "<br>Try relogging after setting a name.</html>"),
		HARASSMENT_WARNING(Icons.STRONG_WARNING_ICON, " Please Don't Harass Players",
			"<html>We have received reports of legitimate players being harassed by users of this plugin." +
				"<br>You may remove this message by acknowledging and reading more about it in the plugin's config.</html>")
		;

		private final Icon image;
		private final String message;
		private final String tooltip;
	}

	private static final int MAX_RSN_LENGTH = 12;
	private static final Pattern VALID_RSN_PATTERN = Pattern.compile("^[ _\\-]*[a-zA-Z0-9][\\w\\- ]*$");
	private static final Font BOLD_FONT = FontManager.getRunescapeBoldFont();
	private static final Font NORMAL_FONT = FontManager.getRunescapeFont();
	private static final Font SMALL_FONT = FontManager.getRunescapeSmallFont();

	private static final Color BACKGROUND_COLOR = ColorScheme.DARK_GRAY_COLOR;
	private static final Color SUB_BACKGROUND_COLOR = ColorScheme.DARKER_GRAY_COLOR;
	private static final Color LINK_HEADER_COLOR = ColorScheme.LIGHT_GRAY_COLOR;
	private static final Color HEADER_COLOR = Color.WHITE;
	private static final Color TEXT_COLOR = ColorScheme.LIGHT_GRAY_COLOR;
	private static final Color VALUE_COLOR = Color.WHITE;
	private static final Color ERROR_COLOR = ColorScheme.PROGRESS_ERROR_COLOR;
	private static final Color POSITIVE_BUTTON_COLOR = ColorScheme.PROGRESS_COMPLETE_COLOR.darker().darker().darker();
	private static final Color NEUTRAL_BUTTON_COLOR = ColorScheme.PROGRESS_INPROGRESS_COLOR.darker().darker().darker();
	private static final Color NEGATIVE_BUTTON_COLOR = ColorScheme.PROGRESS_ERROR_COLOR.darker().darker().darker();

	private static final String EMPTY_LABEL = "---";

	private static final int HEADER_PAD = 3;
	private static final int WARNING_PAD = 5;
	private static final int VALUE_PAD = 2;
	private static final int SUB_PANEL_SEPARATION_HEIGHT = 10;
	private static final Border SUB_PANEL_BORDER = new EmptyBorder(5, 10, 10, 10);
	private static final Dimension HEADER_PREFERRED_SIZE = new Dimension(0, 25);

	private static final int MAX_FEEDBACK_TEXT_CHARS = 250;
	private static final Dimension FEEDBACK_TEXTBOX_PREFERRED_SIZE = new Dimension(0, 75);

	private static final FeedbackPredictionLabel UNSURE_PREDICTION_LABEL = new FeedbackPredictionLabel("unsure", null, FeedbackValue.NEUTRAL);
	private static final FeedbackPredictionLabel SOMETHING_ELSE_PREDICTION_LABEL = new FeedbackPredictionLabel("something_else", null, FeedbackValue.NEGATIVE);
	private static final FeedbackPredictionLabel CORRECT_FALLBACK_PREDICTION_LABEL = new FeedbackPredictionLabel("correct", null, FeedbackValue.POSITIVE);

	private static final PlayerStatsType[] PLAYER_STAT_TYPES = {
		PlayerStatsType.TOTAL, PlayerStatsType.PASSIVE, PlayerStatsType.MANUAL
	};

	private final IconTextField searchBar;
	private final JPanel linksPanel;
	private final JPanel playerStatsPanel;
	private final JPanel primaryPredictionPanel;
	private final JPanel predictionFeedbackPanel;
	private final JPanel predictionFlaggingPanel;
	private final JPanel predictionBreakdownPanel;

	private final BotDetectorPlugin plugin;
	private final BotDetectorClient detectorClient;
	private final BotDetectorConfig config;
	private final NameAutocompleter nameAutocompleter;
	private final EventBus eventBus;

	/** Components that can have their font switched on the fly. See {@link #setFontType(PanelFontType)}. **/
	private final Set<JComponent> switchableFontComponents = new HashSet<>();

	private boolean statsLoading;
	private boolean searchBarLoading;

	// Player Stats
	private JLabel playerStatsHeaderLabel;
	private JLabel playerStatsPluginVersionLabel;
	private JLabel playerStatsUploadedNamesLabel;
	private JLabel playerStatsTotalUploadsLabel;
	private JLabel playerStatsFeedbackSentLabel;
	private JLabel playerStatsPossibleBansLabel;
	private JLabel playerStatsConfirmedBansLabel;
	private JLabel playerStatsIncorrectFlagsLabel;
	private JLabel playerStatsFlagAccuracyLabel;
	private final Map<WarningLabel, JLabel> warningLabels = new HashMap<>();
	private Map<PlayerStatsType, PlayerStats> playerStatsMap;
	private int playerCurrentManualUploads;
	private int playerCurrentPassiveUploads;
	private final MaterialTabGroup playerStatsTabGroup;
	private PlayerStatsType currentPlayerStatsType;

	// Primary Prediction
	private JLabel predictionPlayerIdTextLabel;
	private JLabel predictionPlayerIdLabel;
	private JLabel predictionPlayerNameLabel;
	private JLabel predictionTypeLabel;
	private JLabel predictionConfidenceLabel;

	// Prediction Breakdown
	private JLabel predictionBreakdownLabel;

	// For feedback/flag
	private JLabel feedbackHeaderLabel;
	private JComboBox<FeedbackPredictionLabel> feedbackLabelComboBox;
	private JButton feedbackSendButton;
	private JScrollPane feedbackTextScrollPane;
	private JLimitedTextArea feedbackTextbox;
	private JLabel flaggingHeaderLabel;
	private JButton flaggingYesButton;
	private JButton flaggingNoButton;
	private Prediction lastPrediction;
	private PlayerSighting lastPredictionPlayerSighting;
	private String lastPredictionUploaderName;

	@Getter
	private boolean isActive;

	@Inject
	public BotDetectorPanel(
		BotDetectorPlugin plugin,
		BotDetectorClient detectorClient,
		BotDetectorConfig config,
		NameAutocompleter nameAutocompleter,
		EventBus eventBus)
	{
		this.plugin = plugin;
		this.detectorClient = detectorClient;
		this.config = config;
		this.nameAutocompleter = nameAutocompleter;
		this.eventBus = eventBus;

		setBorder(new EmptyBorder(10, 10, 10, 10));
		setBackground(BACKGROUND_COLOR);
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

		currentPlayerStatsType = config.panelDefaultStatsType();

		searchBar = playerSearchBar();
		linksPanel = linksPanel();
		// Used in the next panel, define now!
		playerStatsTabGroup = playerStatsTabGroup();
		playerStatsPanel = playerStatsPanel();
		primaryPredictionPanel = primaryPredictionPanel();
		predictionFeedbackPanel = putInBoxPanelWithVerticalSeparator(predictionFeedbackPanel());
		predictionFeedbackPanel.setVisible(false);
		predictionFlaggingPanel = putInBoxPanelWithVerticalSeparator(predictionFlaggingPanel());
		predictionFlaggingPanel.setVisible(false);
		predictionBreakdownPanel = putInBoxPanelWithVerticalSeparator(predictionBreakdownPanel());
		predictionBreakdownPanel.setVisible(false);

		add(linksPanel);

		add(Box.createVerticalStrut(SUB_PANEL_SEPARATION_HEIGHT));
		add(playerStatsPanel);

		add(Box.createVerticalStrut(SUB_PANEL_SEPARATION_HEIGHT));
		add(searchBar);

		add(Box.createVerticalStrut(SUB_PANEL_SEPARATION_HEIGHT));
		add(primaryPredictionPanel);

		add(predictionBreakdownPanel);

		add(predictionFeedbackPanel);

		add(predictionFlaggingPanel);

		setPlayerIdVisible(false);
		setPrediction(null);
		setPlayerStatsMap(null);
		setFontType(config.panelFontType());

		addInputKeyListener(nameAutocompleter);
	}

	public void shutdown()
	{
		removeInputKeyListener(nameAutocompleter);
	}

	@Override
	public void onActivate()
	{
		eventBus.post(new BotDetectorPanelActivated());
		isActive = true;
	}

	@Override
	public void onDeactivate()
	{
		isActive = false;
	}

	/**
	 * Puts the panel in a box layout panel with a vertical pad above ({@link #SUB_PANEL_SEPARATION_HEIGHT}).
	 * @param panel The panel.
	 * @return A panel containing the previous panel with a vertical padding element above.
	 */
	private static JPanel putInBoxPanelWithVerticalSeparator(JPanel panel)
	{
		JPanel newPanel = new JPanel();
		newPanel.setBorder(new EmptyBorder(0, 0, 0, 0));
		newPanel.setLayout(new BoxLayout(newPanel, BoxLayout.Y_AXIS));
		newPanel.add(Box.createVerticalStrut(SUB_PANEL_SEPARATION_HEIGHT));
		newPanel.add(panel);
		return newPanel;
	}

	/**
	 * Generates and sets variables related to the links panel.
	 * @return The panel containing all the related elements.
	 */
	private JPanel linksPanel()
	{
		JPanel linksPanel = new JPanel();
		linksPanel.setBorder(new EmptyBorder(0, 0, 0, 0));
		linksPanel.setBackground(SUB_BACKGROUND_COLOR);

		JLabel title = new JLabel("Connect With Us: ");
		title.setForeground(LINK_HEADER_COLOR);
		title.setFont(NORMAL_FONT);

		linksPanel.add(title);

		for (WebLink w : WebLink.values())
		{
			JLabel link = new JLabel(w.getImage());
			link.setToolTipText(w.getTooltip());
			link.addMouseListener(new MouseAdapter()
			{
				@Override
				public void mousePressed(MouseEvent e)
				{
					LinkBrowser.browse(w.getLink());
				}
			});

			linksPanel.add(link);
		}

		return linksPanel;
	}

	/**
	 * Generates a tab group object to be used in {@link #playerStatsPanel()},
	 * allowing splitting stats by {@link #currentPlayerStatsType}.
	 * @return The tab group object.
	 */
	private MaterialTabGroup playerStatsTabGroup()
	{
		MaterialTabGroup tabGroup = new MaterialTabGroup();
		tabGroup.setLayout(new GridLayout(1, PLAYER_STAT_TYPES.length, 7, 7));
		tabGroup.setBorder(new EmptyBorder(VALUE_PAD, 0, VALUE_PAD, 0));

		for (PlayerStatsType pst : PLAYER_STAT_TYPES)
		{
			MaterialTab tab = new MaterialTab(pst.getShorthand(), tabGroup, null);
			tab.setToolTipText(pst.getDescription());
			tab.setFont(SMALL_FONT);
			tab.setHorizontalAlignment(JLabel.CENTER);

			tab.setOnSelectEvent(() ->
			{
				currentPlayerStatsType = pst;
				return true;
			});

			tab.addMouseListener(new MouseAdapter()
			{
				@Override
				public void mousePressed(MouseEvent mouseEvent)
				{
					updatePlayerStatsLabels();
				}
			});

			tabGroup.addTab(tab);
			if (currentPlayerStatsType == pst)
			{
				tabGroup.select(tab);
			}
		}

		return tabGroup;
	}

	/**
	 * Generates and sets variables related to the player contributions panel.
	 * @return The panel containing all the related elements.
	 */
	private JPanel playerStatsPanel()
	{
		JLabel label;

		JPanel uploadingStatsPanel = new JPanel();
		uploadingStatsPanel.setBackground(SUB_BACKGROUND_COLOR);
		uploadingStatsPanel.setBorder(SUB_PANEL_BORDER);

		uploadingStatsPanel.setLayout(new GridBagLayout());
		GridBagConstraints c = new GridBagConstraints();
		c.fill = GridBagConstraints.HORIZONTAL;

		playerStatsHeaderLabel = new JLabel("Player Statistics");
		playerStatsHeaderLabel.setHorizontalTextPosition(JLabel.LEFT);
		playerStatsHeaderLabel.setFont(BOLD_FONT);
		playerStatsHeaderLabel.setForeground(HEADER_COLOR);
		playerStatsHeaderLabel.setPreferredSize(HEADER_PREFERRED_SIZE);
		playerStatsHeaderLabel.setMinimumSize(HEADER_PREFERRED_SIZE);

		c.gridx = 0;
		c.gridy = 0;
		c.ipady = HEADER_PAD;
		c.gridwidth = 2;
		c.weightx = 1;
		c.anchor = GridBagConstraints.NORTH;
		uploadingStatsPanel.add(playerStatsHeaderLabel, c);

		label = new JLabel("Plugin Version: ");
		label.setToolTipText("The Bot Detector plugin version you're running.");
		label.setForeground(TEXT_COLOR);

		c.gridy = 1;
		c.gridy++;
		c.ipady = VALUE_PAD;
		c.gridwidth = 1;
		c.weightx = 0;
		uploadingStatsPanel.add(label, c);
		switchableFontComponents.add(label);

		playerStatsPluginVersionLabel = new JLabel();
		playerStatsPluginVersionLabel.setForeground(VALUE_COLOR);
		c.gridx = 1;
		c.weightx = 1;
		uploadingStatsPanel.add(playerStatsPluginVersionLabel, c);
		switchableFontComponents.add(playerStatsPluginVersionLabel);

		label = new JLabel("Current Uploads: ");
		label.setToolTipText("How many names uploaded during the current Runelite session.");
		label.setForeground(TEXT_COLOR);

		c.gridy++;
		c.gridx = 0;
		c.weightx = 0;
		uploadingStatsPanel.add(label, c);
		switchableFontComponents.add(label);

		playerStatsUploadedNamesLabel = new JLabel();
		playerStatsUploadedNamesLabel.setForeground(VALUE_COLOR);
		c.gridx = 1;
		c.weightx = 1;
		uploadingStatsPanel.add(playerStatsUploadedNamesLabel, c);
		switchableFontComponents.add(playerStatsUploadedNamesLabel);

		label = new JLabel("Total Uploads: ");
		label.setToolTipText("How many unique names sent to us that were attributed to you.");
		label.setForeground(TEXT_COLOR);
		c.gridy++;
		c.gridx = 0;
		c.weightx = 0;
		uploadingStatsPanel.add(label, c);
		switchableFontComponents.add(label);

		playerStatsTotalUploadsLabel = new JLabel();
		playerStatsTotalUploadsLabel.setForeground(VALUE_COLOR);
		c.gridx = 1;
		c.weightx = 1;
		uploadingStatsPanel.add(playerStatsTotalUploadsLabel, c);
		switchableFontComponents.add(playerStatsTotalUploadsLabel);

		label = new JLabel("Feedback Sent: ");
		label.setToolTipText("How many prediction feedbacks you've sent us.");
		label.setForeground(TEXT_COLOR);
		c.gridy++;
		c.gridx = 0;
		c.weightx = 0;
		uploadingStatsPanel.add(label, c);
		switchableFontComponents.add(label);

		playerStatsFeedbackSentLabel = new JLabel();
		playerStatsFeedbackSentLabel.setForeground(VALUE_COLOR);
		c.gridx = 1;
		c.weightx = 1;
		uploadingStatsPanel.add(playerStatsFeedbackSentLabel, c);
		switchableFontComponents.add(playerStatsFeedbackSentLabel);

		label = new JLabel("Possible Bans: ");
		label.setToolTipText(
			"<html>How many of your uploaded names may have been banned." +
			"<br>For example: Names that no longer appear on the Hiscores.</html>");
		label.setForeground(TEXT_COLOR);
		c.gridy++;
		c.gridx = 0;
		c.weightx = 0;
		uploadingStatsPanel.add(label, c);
		switchableFontComponents.add(label);

		playerStatsPossibleBansLabel = new JLabel();
		playerStatsPossibleBansLabel.setForeground(VALUE_COLOR);
		c.gridx = 1;
		c.weightx = 1;
		uploadingStatsPanel.add(playerStatsPossibleBansLabel, c);
		switchableFontComponents.add(playerStatsPossibleBansLabel);

		label = new JLabel("Confirmed Bans: ");
		label.setToolTipText("How many of your uploaded names were confirmed to have been banned by Jagex.");
		label.setForeground(TEXT_COLOR);
		c.gridy++;
		c.gridx = 0;
		c.weightx = 0;
		uploadingStatsPanel.add(label, c);
		switchableFontComponents.add(label);

		playerStatsConfirmedBansLabel = new JLabel();
		playerStatsConfirmedBansLabel.setForeground(VALUE_COLOR);
		c.gridx = 1;
		c.weightx = 1;
		uploadingStatsPanel.add(playerStatsConfirmedBansLabel, c);
		switchableFontComponents.add(playerStatsConfirmedBansLabel);

		label = new JLabel("Incorrect Flags: ");
		label.setToolTipText("How many of your flagged names were confirmed to have been real players by Jagex.");
		label.setForeground(TEXT_COLOR);
		c.gridy++;
		c.gridx = 0;
		c.weightx = 0;
		uploadingStatsPanel.add(label, c);
		switchableFontComponents.add(label);

		playerStatsIncorrectFlagsLabel = new JLabel();
		playerStatsIncorrectFlagsLabel.setForeground(VALUE_COLOR);
		c.gridx = 1;
		c.weightx = 1;
		uploadingStatsPanel.add(playerStatsIncorrectFlagsLabel, c);
		switchableFontComponents.add(playerStatsIncorrectFlagsLabel);

		label = new JLabel("Flag Accuracy: ");
		label.setToolTipText("How accurate your flagging has been.");
		label.setForeground(TEXT_COLOR);
		c.gridy++;
		c.gridx = 0;
		c.weightx = 0;
		uploadingStatsPanel.add(label, c);
		switchableFontComponents.add(label);

		playerStatsFlagAccuracyLabel = new JLabel();
		playerStatsFlagAccuracyLabel.setForeground(VALUE_COLOR);
		c.gridx = 1;
		c.weightx = 1;
		uploadingStatsPanel.add(playerStatsFlagAccuracyLabel, c);
		switchableFontComponents.add(playerStatsFlagAccuracyLabel);

		c.gridy++;
		c.gridx = 0;
		c.weightx = 1;
		c.gridwidth = 2;
		c.ipady = 0;
		uploadingStatsPanel.add(playerStatsTabGroup, c);

		c.ipady = WARNING_PAD;
		for (WarningLabel wl : WarningLabel.values())
		{
			c.gridy++;
			label = new JLabel(wl.getMessage());
			label.setToolTipText(wl.getTooltip());
			label.setIcon(wl.getImage());
			label.setFont(NORMAL_FONT);
			label.setForeground(HEADER_COLOR);
			label.setVisible(false);
			uploadingStatsPanel.add(label, c);
			warningLabels.put(wl, label);
		}

		return uploadingStatsPanel;
	}

	/**
	 * Generates a search bar object to be placed in the plugin panel.
	 * @return The seach bar object.
	 */
	private IconTextField playerSearchBar()
	{
		IconTextField searchBar = new IconTextField();
		searchBar.setIcon(IconTextField.Icon.SEARCH);
		searchBar.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 30));
		searchBar.setBackground(SUB_BACKGROUND_COLOR);
		searchBar.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
		searchBar.setMinimumSize(new Dimension(0, 30));
		searchBar.addActionListener(e -> predictPlayer());
		searchBar.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				if (e.getClickCount() != 2)
				{
					return;
				}

				String name = plugin.getLoggedPlayerName();
				if (name != null)
				{
					predictPlayer(name);
				}
			}
		});
		searchBar.addClearListener(() ->
		{
			searchBar.setIcon(IconTextField.Icon.SEARCH);
			searchBar.setEditable(true);
			searchBarLoading = false;
		});

		return searchBar;
	}

	/**
	 * Generates and sets variables related to the main prediction panel.
	 * @return The panel containing all the related elements.
	 */
	private JPanel primaryPredictionPanel()
	{
		JLabel label;

		JPanel primaryPredictionPanel = new JPanel();
		primaryPredictionPanel.setBackground(SUB_BACKGROUND_COLOR);
		primaryPredictionPanel.setLayout(new GridBagLayout());
		primaryPredictionPanel.setBorder(SUB_PANEL_BORDER);

		GridBagConstraints c = new GridBagConstraints();
		c.fill = GridBagConstraints.HORIZONTAL;

		label = new JLabel("Primary Prediction");
		label.setFont(BOLD_FONT);
		label.setForeground(HEADER_COLOR);
		label.setPreferredSize(HEADER_PREFERRED_SIZE);
		label.setMinimumSize(HEADER_PREFERRED_SIZE);
		c.gridx = 0;
		c.gridy = 0;
		c.ipady = HEADER_PAD;
		c.gridwidth = 2;
		c.weightx = 1;
		primaryPredictionPanel.add(label, c);

		predictionPlayerIdTextLabel = new JLabel("Player ID: ");
		predictionPlayerIdTextLabel.setForeground(TEXT_COLOR);
		c.gridy = 1;
		c.gridy++;
		c.ipady = VALUE_PAD;
		c.gridwidth = 1;
		c.weightx = 0;
		c.anchor = GridBagConstraints.NORTH;
		primaryPredictionPanel.add(predictionPlayerIdTextLabel, c);
		switchableFontComponents.add(predictionPlayerIdTextLabel);

		predictionPlayerIdLabel = new JLabel();
		c.gridx = 1;
		c.weightx = 1;
		primaryPredictionPanel.add(predictionPlayerIdLabel, c);
		switchableFontComponents.add(predictionPlayerIdLabel);

		label = new JLabel("Player Name: ");
		label.setForeground(TEXT_COLOR);
		c.gridx = 0;
		c.weightx = 0;
		c.gridy++;
		primaryPredictionPanel.add(label, c);
		switchableFontComponents.add(label);

		predictionPlayerNameLabel = new JLabel();
		c.gridx = 1;
		c.weightx = 1;
		primaryPredictionPanel.add(predictionPlayerNameLabel, c);
		switchableFontComponents.add(predictionPlayerNameLabel);

		label = new JLabel("Prediction: ");
		label.setForeground(TEXT_COLOR);
		c.gridx = 0;
		c.weightx = 0;
		c.gridy++;
		primaryPredictionPanel.add(label, c);
		switchableFontComponents.add(label);

		predictionTypeLabel = new JLabel();
		c.gridx = 1;
		c.weightx = 1;
		primaryPredictionPanel.add(predictionTypeLabel, c);
		switchableFontComponents.add(predictionTypeLabel);

		label = new JLabel("Confidence: ");
		label.setForeground(TEXT_COLOR);
		c.gridx = 0;
		c.weightx = 0;
		c.gridy++;
		primaryPredictionPanel.add(label, c);
		switchableFontComponents.add(label);

		predictionConfidenceLabel = new JLabel();
		c.gridx = 1;
		c.weightx = 1;
		primaryPredictionPanel.add(predictionConfidenceLabel, c);
		switchableFontComponents.add(predictionConfidenceLabel);

		return primaryPredictionPanel;
	}

	/**
	 * Generates and sets variables related to the prediction feedback panel.
	 * @return The panel containing all the related elements.
	 */
	private JPanel predictionFeedbackPanel()
	{
		JPanel panel = new JPanel();
		panel.setBackground(SUB_BACKGROUND_COLOR);
		panel.setLayout(new GridBagLayout());
		panel.setBorder(SUB_PANEL_BORDER);

		GridBagConstraints c = new GridBagConstraints();
		c.fill = GridBagConstraints.HORIZONTAL;

		feedbackHeaderLabel = new JLabel("Send a prediction feedback?");
		feedbackHeaderLabel.setHorizontalTextPosition(JLabel.LEFT);
		feedbackHeaderLabel.setFont(NORMAL_FONT);
		feedbackHeaderLabel.setForeground(HEADER_COLOR);
		feedbackHeaderLabel.setPreferredSize(HEADER_PREFERRED_SIZE);
		feedbackHeaderLabel.setMinimumSize(HEADER_PREFERRED_SIZE);
		c.gridx = 0;
		c.gridy = 0;
		c.ipady = HEADER_PAD;
		c.gridwidth = 3;
		c.weightx = 1;
		panel.add(feedbackHeaderLabel, c);

		feedbackTextbox = new JLimitedTextArea(MAX_FEEDBACK_TEXT_CHARS);
		feedbackTextbox.setToolTipText("Please explain your feedback (max " + MAX_FEEDBACK_TEXT_CHARS + " characters).");
		feedbackTextbox.setForeground(HEADER_COLOR);
		feedbackTextbox.setBackground(BACKGROUND_COLOR);
		feedbackTextbox.setFont(SMALL_FONT);
		feedbackTextbox.setWrapStyleWord(true);
		feedbackTextbox.setLineWrap(true);
		feedbackTextbox.setTabSize(2);
		feedbackTextbox.setBorder(new EmptyBorder(2, 2, 2, 2));
		feedbackTextScrollPane = new JScrollPane(feedbackTextbox);
		feedbackTextScrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
		feedbackTextScrollPane.setPreferredSize(FEEDBACK_TEXTBOX_PREFERRED_SIZE);
		feedbackTextScrollPane.setMinimumSize(FEEDBACK_TEXTBOX_PREFERRED_SIZE);
		feedbackTextScrollPane.setBorder(new EmptyBorder(0, 0, 10, 0));
		feedbackTextScrollPane.setOpaque(false);
		c.gridy++;
		panel.add(feedbackTextScrollPane, c);

		JLabel label = new JLabel("Please select the correct label:");
		label.setHorizontalTextPosition(JLabel.LEFT);
		label.setForeground(HEADER_COLOR);
		label.setFont(NORMAL_FONT);
		c.gridy++;
		panel.add(label, c);

		feedbackLabelComboBox = new JComboBox<>();
		feedbackLabelComboBox.addItemListener(e ->
		{
			if (e.getStateChange() == ItemEvent.SELECTED)
			{
				Object o = feedbackLabelComboBox.getSelectedItem();
				feedbackLabelComboBox.setToolTipText(o != null ? o.toString() : null);
			}
		});
		feedbackLabelComboBox.setRenderer(new ComboBoxSelfTextTooltipListRenderer<>());
		c.gridy++;
		c.gridx = 0;
		c.weightx = 1;
		c.gridwidth = 2;
		panel.add(feedbackLabelComboBox, c);

		feedbackSendButton = new JButton("Send");
		feedbackSendButton.setToolTipText("<html>Tell us the correct label for <b>primary prediction</b>! Doing so will help us improve our model." +
			"<br><span style='color:red'>Please</span>, do not vote against a prediction simply because the percentage is not high enough.</html>");
		feedbackSendButton.setForeground(HEADER_COLOR);
		feedbackSendButton.addActionListener(l -> sendFeedbackToClient((FeedbackPredictionLabel)feedbackLabelComboBox.getSelectedItem()));
		feedbackSendButton.setFocusable(false);
		c.gridx = 2;
		c.weightx = 0;
		c.gridwidth = 1;
		panel.add(feedbackSendButton, c);

		return panel;
	}

	/**
	 * Generates and sets variables related to the prediction flagging panel.
	 * @return The panel containing all the related elements.
	 */
	private JPanel predictionFlaggingPanel()
	{
		JPanel panel = new JPanel();
		panel.setBackground(SUB_BACKGROUND_COLOR);
		panel.setLayout(new GridBagLayout());
		panel.setBorder(SUB_PANEL_BORDER);

		GridBagConstraints c = new GridBagConstraints();
		c.fill = GridBagConstraints.HORIZONTAL;

		flaggingHeaderLabel = new JLabel("Flag this player as a bot?");
		flaggingHeaderLabel.setHorizontalTextPosition(JLabel.LEFT);
		flaggingHeaderLabel.setFont(NORMAL_FONT);
		flaggingHeaderLabel.setForeground(HEADER_COLOR);
		flaggingHeaderLabel.setPreferredSize(HEADER_PREFERRED_SIZE);
		flaggingHeaderLabel.setMinimumSize(HEADER_PREFERRED_SIZE);
		c.gridx = 0;
		c.gridy = 0;
		c.ipady = HEADER_PAD;
		c.gridwidth = 2;
		c.weightx = 1;
		panel.add(flaggingHeaderLabel, c);

		flaggingYesButton = new JButton("Yes");
		flaggingYesButton.setToolTipText(
			"<html>This is <span style='color:red'>NOT</span> the same as reporting the player in-game!" +
			"<br>Flagging a player as a bot tells us to pay more attention to them when training our model.</html>");
		flaggingYesButton.setForeground(HEADER_COLOR);
		flaggingYesButton.addActionListener(l -> sendFlagToClient(true));
		flaggingYesButton.setFocusable(false);
		c.gridy++;
		c.weightx = 0.5;
		c.gridwidth = 1;
		panel.add(flaggingYesButton, c);

		flaggingNoButton = new JButton("No");
		flaggingNoButton.setForeground(HEADER_COLOR);
		flaggingNoButton.addActionListener(l -> sendFlagToClient(false));
		flaggingNoButton.setFocusable(false);
		c.gridx++;
		panel.add(flaggingNoButton, c);

		return panel;
	}

	/**
	 * Generates and sets variables related to the prediction breakdown panel.
	 * @return The panel containing all the related elements.
	 */
	private JPanel predictionBreakdownPanel()
	{
		JPanel predictionBreakdownPanel = new JPanel();
		predictionBreakdownPanel.setBackground(SUB_BACKGROUND_COLOR);
		predictionBreakdownPanel.setBorder(SUB_PANEL_BORDER);
		predictionBreakdownPanel.setLayout(new GridBagLayout());

		GridBagConstraints c = new GridBagConstraints();
		c.fill = GridBagConstraints.HORIZONTAL;

		JLabel label = new JLabel("Prediction Breakdown");
		label.setFont(BOLD_FONT);
		label.setForeground(HEADER_COLOR);
		label.setPreferredSize(HEADER_PREFERRED_SIZE);
		label.setMinimumSize(HEADER_PREFERRED_SIZE);
		c.gridx = 0;
		c.gridy = 0;
		c.weightx = 1.0;
		c.ipady = HEADER_PAD;
		predictionBreakdownPanel.add(label, c);

		predictionBreakdownLabel = new JLabel();
		predictionBreakdownLabel.setForeground(TEXT_COLOR);
		c.anchor = GridBagConstraints.PAGE_END;
		c.gridy++;
		predictionBreakdownPanel.add(predictionBreakdownLabel, c);
		switchableFontComponents.add(predictionBreakdownLabel);

		return predictionBreakdownPanel;
	}

	/**
	 * Sets the displayed plugin version string in the panel.
	 * @param pluginVersion The plugin version to display.
	 */
	public void setPluginVersion(String pluginVersion)
	{
		playerStatsPluginVersionLabel.setText(pluginVersion);
	}

	/**
	 * Sets the number of passive/manual uploads, then updates the label (see {@link #updateCurrentUploadsLabel()}).
	 * @param num The number of uploads to display.
	 * @param manual Whether {@code num} is for passive or manual uploads.
	 */
	public void setNamesUploaded(int num, boolean manual)
	{
		if (manual)
		{
			playerCurrentManualUploads = num;
		}
		else
		{
			playerCurrentPassiveUploads = num;
		}
		updateCurrentUploadsLabel();
	}

	/**
	 * Sets the current {@link #playerStatsMap}, then calls {@link #updatePlayerStatsLabels()}.
	 * @param psm The player stats map to set.
	 */
	public void setPlayerStatsMap(Map<PlayerStatsType, PlayerStats> psm)
	{
		playerStatsMap = psm;
		updatePlayerStatsLabels();
	}

	/**
	 * Updates all the fields in the player contributions panel according to
	 * {@link #playerStatsMap} and {@link #currentPlayerStatsType}.
	 * If the map is null or there is no {@link PlayerStats} for the currently displayed type, the fields are cleared.
	 */
	private void updatePlayerStatsLabels()
	{
		PlayerStats ps = playerStatsMap != null ? playerStatsMap.get(currentPlayerStatsType) : null;
		if (ps != null)
		{
			playerStatsTotalUploadsLabel.setText(QuantityFormatter.formatNumber(ps.getNamesUploaded()));
			playerStatsConfirmedBansLabel.setText(QuantityFormatter.formatNumber(ps.getConfirmedBans()));
			playerStatsPossibleBansLabel.setText(QuantityFormatter.formatNumber(ps.getPossibleBans()));
			if (currentPlayerStatsType.canDisplayAccuracy())
			{
				playerStatsIncorrectFlagsLabel.setText(QuantityFormatter.formatNumber(ps.getIncorrectFlags()));
				playerStatsFlagAccuracyLabel.setText(wrapHTML(toColoredPercentSpan(ps.getAccuracy()), false));
			}
			else
			{
				playerStatsIncorrectFlagsLabel.setText(EMPTY_LABEL);
				playerStatsFlagAccuracyLabel.setText(EMPTY_LABEL);
			}
		}
		else
		{
			playerStatsTotalUploadsLabel.setText(EMPTY_LABEL);
			playerStatsConfirmedBansLabel.setText(EMPTY_LABEL);
			playerStatsPossibleBansLabel.setText(EMPTY_LABEL);
			playerStatsIncorrectFlagsLabel.setText(EMPTY_LABEL);
			playerStatsFlagAccuracyLabel.setText(EMPTY_LABEL);
		}

		// Process Feedback sent field separately, it's only available in "Total".
		PlayerStats totalStats = playerStatsMap != null ? playerStatsMap.get(PlayerStatsType.TOTAL) : null;
		if (totalStats != null)
		{
			playerStatsFeedbackSentLabel.setText(QuantityFormatter.formatNumber(totalStats.getFeedbackSent()));
		}
		else
		{
			playerStatsFeedbackSentLabel.setText(EMPTY_LABEL);
		}

		updateCurrentUploadsLabel();
	}

	/**
	 * Updates the value in {@link #playerStatsUploadedNamesLabel} according to
	 * {@link #currentPlayerStatsType}, {@link #playerCurrentManualUploads} and {@link #playerCurrentPassiveUploads}.
	 */
	private void updateCurrentUploadsLabel()
	{
		int val;
		switch (currentPlayerStatsType)
		{
			case MANUAL:
				val = playerCurrentManualUploads;
				break;
			case PASSIVE:
				val = playerCurrentPassiveUploads;
				break;
			default:
				val = playerCurrentManualUploads + playerCurrentPassiveUploads;
				break;
		}
		playerStatsUploadedNamesLabel.setText(QuantityFormatter.formatNumber(val));
	}

	/**
	 * Gets the current visibility of the given warning label.
	 * @param wl The warning label to get the visibility for.
	 * @return True if the warning label is currently visible, false otherwise.
	 */
	public boolean getWarningVisible(WarningLabel wl)
	{
		JLabel label = warningLabels.get(wl);
		return label != null && label.isVisible();
	}

	/**
	 * Sets the visibility of the given warning in the player contributions panel.
	 * @param wl The warning label to set visibility.
	 * @param visible The visibility to set on the warning label.
	 */
	public void setWarningVisible(WarningLabel wl, boolean visible)
	{
		JLabel label = warningLabels.get(wl);
		if (label != null)
		{
			label.setVisible(visible);
		}
	}

	/**
	 * Sets the player contributions panel to be in 'loading' mode.
	 * @param loading Whether or not the player contributions panel is loading.
	 */
	public void setPlayerStatsLoading(boolean loading)
	{
		statsLoading = loading;
		playerStatsHeaderLabel.setIcon(loading ? Icons.LOADING_SPINNER : null);
	}

	/**
	 * Sets the visibility of the player ID field in the main prediction panel.
	 * @param visible The visibility to apply on the player ID field.
	 */
	public void setPlayerIdVisible(boolean visible)
	{
		predictionPlayerIdTextLabel.setVisible(visible);
		predictionPlayerIdLabel.setVisible(visible);
	}

	/**
	 * Sets the visibility of the text box in the feedback panel.
	 * @param visible The visibility to apply on the feedback text box.
	 */
	public void setFeedbackTextboxVisible(boolean visible)
	{
		feedbackTextScrollPane.setVisible(visible);
	}

	/**
	 * Forcibly hides the feedback panel.
	 */
	public void forceHideFeedbackPanel()
	{
		predictionFeedbackPanel.setVisible(false);
	}

	/**
	 * Forcibly hides the flagging panel.
	 */
	public void forceHideFlaggingPanel()
	{
		predictionFlaggingPanel.setVisible(false);
	}

	/**
	 * Sets the given color on all value labels in the main prediction panel.
	 * @param color The color to set on all value labels in the main prediction panel.
	 */
	private void setPredictionLabelsColor(Color color)
	{
		predictionPlayerIdLabel.setForeground(color);
		predictionPlayerNameLabel.setForeground(color);
		predictionTypeLabel.setForeground(color);
		predictionConfidenceLabel.setForeground(color);
	}

	/**
	 * Sets up the prediction and feedback panels according to the given prediction.
	 * @param pred The prediction to display. If {@code null}, clears and resets all panels.
	 */
	public void setPrediction(Prediction pred)
	{
		setPrediction(pred, null);
	}

	/**
	 * Sets up the prediction, feedback and flagging panels according to the given parameters.
	 * @param pred The prediction to display. If {@code null}, clears and resets all panels.
	 * @param sighting The player sighting to associate with the prediction for the flagging panel.
	 */
	public void setPrediction(Prediction pred, PlayerSighting sighting)
	{
		setPredictionLabelsColor(VALUE_COLOR);

		feedbackLabelComboBox.removeAllItems();

		if (pred != null)
		{
			final boolean isNullConfidence = pred.getConfidence() == null;

			nameAutocompleter.addToSearchHistory(pred.getPlayerName().toLowerCase());
			lastPrediction = pred;
			lastPredictionPlayerSighting = sighting;
			lastPredictionUploaderName = plugin.getUploaderName(true);
			predictionPlayerIdLabel.setText(String.valueOf(pred.getPlayerId()));
			predictionPlayerNameLabel.setText(wrapHTML(pred.getPlayerName()));
			predictionTypeLabel.setText(wrapHTML(normalizeLabel(pred.getPredictionLabel())));
			predictionConfidenceLabel.setText(isNullConfidence ? EMPTY_LABEL : wrapHTML(toColoredPercentSpan(pred.getConfidence()), false));

			feedbackLabelComboBox.addItem(UNSURE_PREDICTION_LABEL);
			feedbackLabelComboBox.setSelectedItem(UNSURE_PREDICTION_LABEL);
			feedbackLabelComboBox.addItem(SOMETHING_ELSE_PREDICTION_LABEL);

			if (pred.getPredictionBreakdown() == null || pred.getPredictionBreakdown().size() == 0)
			{
				predictionBreakdownLabel.setText(EMPTY_LABEL);
				predictionBreakdownPanel.setVisible(false);

				feedbackLabelComboBox.addItem(CORRECT_FALLBACK_PREDICTION_LABEL);
			}
			else
			{
				if (isNullConfidence && !config.showBreakdownOnNullConfidence())
				{
					predictionBreakdownLabel.setText(EMPTY_LABEL);
					predictionBreakdownPanel.setVisible(false);
				}
				else
				{
					predictionBreakdownLabel.setText(toPredictionBreakdownString(pred.getPredictionBreakdown()));
					predictionBreakdownPanel.setVisible(true);
				}

				final String primaryLabel = pred.getPredictionLabel();

				pred.getPredictionBreakdown().entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(
					entry ->
					{
						FeedbackPredictionLabel pLabel = new FeedbackPredictionLabel(entry.getKey(), entry.getValue(),
							entry.getKey().equals(primaryLabel) ? FeedbackValue.POSITIVE : FeedbackValue.NEGATIVE);
						feedbackLabelComboBox.addItem(pLabel);
						if (pLabel.getFeedbackValue() == FeedbackValue.POSITIVE)
						{
							feedbackLabelComboBox.setSelectedItem(pLabel);
						}
					});
			}

			// Must be logged in
			if (lastPredictionUploaderName != null)
			{
				resetFeedbackPanel(true);
				CaseInsensitiveString name = normalizeAndWrapPlayerName(pred.getPlayerName());
				if (pred.getPlayerId() <= 0)
				{
					predictionFeedbackPanel.setVisible(false);
				}
				else
				{
					// If the player has already been feedbacked, ensure the panels reflect this
					FeedbackPredictionLabel feedbacked = plugin.getFeedbackedPlayers().get(name);

					if (feedbacked != null)
					{
						disableAndSetComboBoxOnFeedbackPanel(feedbacked, true);
					}

					// If there was some feedback text from a previous send, either successful or failed
					String feedbackText = plugin.getFeedbackedPlayersText().get(name);
					if (feedbackText != null)
					{
						feedbackTextbox.setText(feedbackText);
					}

					predictionFeedbackPanel.setVisible(true);
				}

				resetFlaggingPanel();
				if (sighting == null || !shouldAllowFlagging())
				{
					predictionFlaggingPanel.setVisible(false);
				}
				else
				{
					// If the player has already been flagged, ensure the panels reflect this
					Boolean flagged = plugin.getFlaggedPlayers().get(name);
					if (flagged != null)
					{
						disableAndSetColorOnFlaggingPanel(flagged);
					}
					predictionFlaggingPanel.setVisible(true);
				}
			}
			else
			{
				predictionFeedbackPanel.setVisible(false);
				predictionFlaggingPanel.setVisible(false);
			}
		}
		else
		{
			lastPrediction = null;
			lastPredictionPlayerSighting = null;
			lastPredictionUploaderName = null;
			predictionPlayerIdLabel.setText(EMPTY_LABEL);
			predictionPlayerNameLabel.setText(EMPTY_LABEL);
			predictionTypeLabel.setText(EMPTY_LABEL);
			predictionConfidenceLabel.setText(EMPTY_LABEL);
			predictionBreakdownLabel.setText(EMPTY_LABEL);

			predictionBreakdownPanel.setVisible(false);
			predictionFeedbackPanel.setVisible(false);
			predictionFlaggingPanel.setVisible(false);
		}
	}

	/**
	 * Sets up the prediction panel to display the given error message without including a detailed error.
	 * @param playerName The player's name.
	 * @param error The short, main error descriptor.
	 */
	public void setPredictionError(String playerName, String error)
	{
		setPredictionError(playerName, error, EMPTY_LABEL);
	}

	/**
	 * Sets up the prediction panel to display the given error message.
	 * @param playerName The player's name.
	 * @param error The short, main error descriptor.
	 * @param details The detailed error explanation.
	 */
	public void setPredictionError(String playerName, String error, String details)
	{
		setPrediction(null);
		setPredictionLabelsColor(ERROR_COLOR);

		predictionPlayerNameLabel.setText(wrapHTML(playerName));
		predictionTypeLabel.setText(wrapHTML(error));
		predictionConfidenceLabel.setText(wrapHTML(details));
	}

	/**
	 * Sets the given {@code playerName} in the panel's {@link #searchBar}, then calls {@link #predictPlayer()}.
	 * @param playerName The player to predict.
	 */
	public void predictPlayer(String playerName)
	{
		searchBar.setText(playerName);
		predictPlayer();
	}

	/**
	 * Hits up the API and retrieves the bot prediction for the player name in the panel's {@link #searchBar}.
	 */
	private void predictPlayer()
	{
		String target = sanitize(searchBar.getText());

		if (target.length() <= 0)
		{
			return;
		}

		if (target.length() > MAX_RSN_LENGTH)
		{
			searchBar.setIcon(IconTextField.Icon.ERROR);
			searchBarLoading = false;
			setPredictionError(target.substring(0, MAX_RSN_LENGTH) + "...",
				"Name Input Error",
				"Name cannot be longer than " + MAX_RSN_LENGTH + " characters");
			return;
		}
		else if (!isValidPlayerName(target))
		{
			searchBar.setIcon(IconTextField.Icon.ERROR);
			searchBarLoading = false;
			setPredictionError(target,
				"Name Input Error",
				"Entered name is not a valid Runescape name");
			return;
		}

		searchBar.setIcon(IconTextField.Icon.LOADING_DARKER);
		searchBar.setEditable(false);
		searchBarLoading = true;

		setPrediction(null);

		detectorClient.requestPrediction(target).whenCompleteAsync((pred, ex) ->
			SwingUtilities.invokeLater(() ->
			{
				if (!sanitize(searchBar.getText()).equals(target))
				{
					// Target has changed in the meantime
					return;
				}

				searchBar.setEditable(true);
				searchBarLoading = false;

				if (ex != null)
				{
					searchBar.setIcon(IconTextField.Icon.ERROR);
					setPredictionError(target, "Server Error", ex.getMessage());
					return;
				}

				searchBar.setIcon(IconTextField.Icon.SEARCH);

				// Build a dummy prediction if player not found in API
				Prediction p = pred;
				if (p == null)
				{
					p = Prediction.builder()
						.playerName(target)
						.playerId(-1) // Prevents feedback panel from appearing
						.confidence(null)
						.predictionBreakdown(null)
						.predictionLabel("Player not found")
						.build();
				}

				setPrediction(p, plugin.getPersistentSightings().get(normalizeAndWrapPlayerName(target)));
			}));
	}

	/**
	 * Processes the user input from the prediction feedback panel.
	 * @param proposedLabel The intended label from the user for {@link #lastPrediction} to be sent to the API.
	 */
	private void sendFeedbackToClient(FeedbackPredictionLabel proposedLabel)
	{
		if (lastPrediction == null
			|| lastPredictionUploaderName == null
			|| proposedLabel == null
			|| proposedLabel.getLabel() == null)
		{
			return;
		}

		disableAndSetComboBoxOnFeedbackPanel(proposedLabel, false);

		CaseInsensitiveString wrappedName = normalizeAndWrapPlayerName(lastPrediction.getPlayerName());
		Map<CaseInsensitiveString, FeedbackPredictionLabel> feedbackMap = plugin.getFeedbackedPlayers();
		feedbackMap.put(wrappedName, proposedLabel);

		String feedbackText = feedbackTextbox.getText().trim();
		if (feedbackText.isEmpty())
		{
			feedbackText = null;
		}
		else
		{
			// Will not get reset upon send failure, so don't need to keep reference
			plugin.getFeedbackedPlayersText().put(wrappedName, feedbackText);
		}

		feedbackHeaderLabel.setIcon(Icons.LOADING_SPINNER);
		feedbackHeaderLabel.setToolTipText(null);
		detectorClient.sendFeedback(lastPrediction, lastPredictionUploaderName, proposedLabel, feedbackText)
			.whenComplete((successful, ex) ->
			{
				boolean stillSame = lastPrediction != null &&
					wrappedName.equals(normalizeAndWrapPlayerName(lastPrediction.getPlayerName()));

				String message;
				if (ex == null)
				{
					if (successful)
					{
						message = "Thank you for your prediction feedback for '%s'!";
						if (stillSame)
						{
							feedbackHeaderLabel.setIcon(null);
							feedbackHeaderLabel.setToolTipText(null);
						}
					}
					// Failure is due to duplicate record on server side
					else
					{
						message = "Sorry, but your feedback for '%s' was rejected as it already exists on the server.";
						if (stillSame)
						{
							feedbackHeaderLabel.setIcon(Icons.WARNING_ICON);
							feedbackHeaderLabel.setToolTipText("The server rejected your feedback as it already exists for this player");
						}
					}
				}
				else
				{
					message = "Error sending your prediction feedback for '%s'.";
					// Didn't work so remove from feedback map
					feedbackMap.remove(wrappedName);
					if (stillSame)
					{
						resetFeedbackPanel(false);
						feedbackHeaderLabel.setIcon(Icons.ERROR_ICON);
						feedbackHeaderLabel.setToolTipText(ex.getMessage());
					}
				}

				plugin.sendChatStatusMessage(String.format(message, wrappedName));
			});
	}

	/**
	 * Processes the user input from the flagging panel.
	 * @param doFlag Whether or not the user intends to flag {@link #lastPredictionPlayerSighting} to the API.
	 */
	private void sendFlagToClient(boolean doFlag)
	{
		if (lastPredictionPlayerSighting == null
			|| !shouldAllowFlagging())
		{
			return;
		}

		disableAndSetColorOnFlaggingPanel(doFlag);

		CaseInsensitiveString wrappedName = normalizeAndWrapPlayerName(lastPredictionPlayerSighting.getPlayerName());
		Map<CaseInsensitiveString, Boolean> flagMap = plugin.getFlaggedPlayers();
		flagMap.put(wrappedName, doFlag);

		// Didn't want to flag? Work is done!
		if (!doFlag)
		{
			return;
		}

		flaggingHeaderLabel.setIcon(Icons.LOADING_SPINNER);
		flaggingHeaderLabel.setToolTipText(null);
		detectorClient.sendSighting(lastPredictionPlayerSighting, lastPredictionUploaderName, true)
			.whenComplete((b, ex) ->
			{
				boolean stillSame = lastPredictionPlayerSighting != null &&
					wrappedName.equals(normalizeAndWrapPlayerName(lastPredictionPlayerSighting.getPlayerName()));

				String message;
				if (ex == null && b)
				{
					message = "Thank you for flagging '%s' as a bot to us!";
					setNamesUploaded(playerCurrentManualUploads + 1, true);
					if (stillSame)
					{
						flaggingHeaderLabel.setIcon(null);
						flaggingHeaderLabel.setToolTipText(null);
					}
				}
				else
				{
					message = "Error sending your bot flag for '%s'.";
					// Didn't work so remove from flagged map
					flagMap.remove(wrappedName);
					if (stillSame)
					{
						resetFlaggingPanel();
						flaggingHeaderLabel.setIcon(Icons.ERROR_ICON);
						flaggingHeaderLabel.setToolTipText(ex != null ? ex.getMessage() : "Unknown error");
					}
				}

				plugin.sendChatStatusMessage(String.format(message, wrappedName));
			});
	}

	/**
	 * Checks if flagging should be allowed.
	 * @return True if {@link BotDetectorPlugin#getUploaderName()} indicates a logged user that isn't in anonymous mode.
	 */
	private boolean shouldAllowFlagging()
	{
		return lastPredictionUploaderName != null
			&& !lastPredictionUploaderName.startsWith(BotDetectorPlugin.ANONYMOUS_USER_NAME);
	}

	/**
	 * Clears and re-enables the components in the feedback panel.
	 */
	private void resetFeedbackPanel(boolean clearText)
	{
		feedbackHeaderLabel.setIcon(null);
		feedbackHeaderLabel.setToolTipText(null);
		setBackgroundFlatLaf(feedbackSendButton, null);
		feedbackSendButton.setEnabled(true);
		feedbackTextbox.setEnabled(true);
		feedbackLabelComboBox.setEnabled(true);
		if (clearText)
		{
			feedbackTextbox.setText("");
		}
	}

	/**
	 * Disables the feedback panel and sets the label combobox according to the parameter.
	 * @param label The label to display in the combobox.
	 * @param clearAndForceSetComboBoxLabel Set to true if the {@code label} is not expected to exist exactly in the combo box.
	 */
	private void disableAndSetComboBoxOnFeedbackPanel(FeedbackPredictionLabel label, boolean clearAndForceSetComboBoxLabel)
	{
		feedbackSendButton.setEnabled(false);
		feedbackTextbox.setEnabled(false);
		feedbackLabelComboBox.setEnabled(false);

		if (clearAndForceSetComboBoxLabel)
		{
			feedbackLabelComboBox.removeAllItems();
			feedbackLabelComboBox.addItem(label);
		}

		feedbackLabelComboBox.setSelectedItem(label);

		switch (label.getFeedbackValue())
		{
			case POSITIVE:
				setBackgroundFlatLaf(feedbackSendButton, POSITIVE_BUTTON_COLOR);
				break;
			case NEUTRAL:
				setBackgroundFlatLaf(feedbackSendButton, NEUTRAL_BUTTON_COLOR);
				break;
			case NEGATIVE:
				setBackgroundFlatLaf(feedbackSendButton, NEGATIVE_BUTTON_COLOR);
				break;
		}
	}

	/**
	 * Clears and re-enables the components in the flagging panel.
	 */
	private void resetFlaggingPanel()
	{
		flaggingHeaderLabel.setIcon(null);
		flaggingHeaderLabel.setToolTipText(null);
		setBackgroundFlatLaf(flaggingYesButton, null);
		flaggingYesButton.setEnabled(true);
		setBackgroundFlatLaf(flaggingNoButton, null);
		flaggingNoButton.setEnabled(true);
	}

	/**
	 * Disables the flagging panel and sets a color on either the 'Yes' or 'No' button according to the parameter.
	 * @param flagged If true, highlight the 'Yes' button, otherwise highlight the 'No' button.
	 */
	private void disableAndSetColorOnFlaggingPanel(boolean flagged)
	{
		flaggingYesButton.setEnabled(false);
		flaggingNoButton.setEnabled(false);
		if (flagged)
		{
			setBackgroundFlatLaf(flaggingYesButton, POSITIVE_BUTTON_COLOR);
		}
		else
		{
			setBackgroundFlatLaf(flaggingNoButton, NEGATIVE_BUTTON_COLOR);
		}
	}

	/**
	 * Sets the appropriate font for every components in {@link #switchableFontComponents}.
	 * @param fontType The font type to apply.
	 */
	public void setFontType(PanelFontType fontType)
	{
		Font f;

		switch (fontType)
		{
			case SMALL:
				f = SMALL_FONT;
				break;
			case BOLD:
				f = BOLD_FONT;
				break;
			default:
				f = NORMAL_FONT;
				break;
		}

		switchableFontComponents.forEach(c -> c.setFont(f));
	}

	/**
	 * Wraps the given string in HTML tags. The input string is escaped for HTML.
	 * Use this in {@link JLabel#setText(String)} to make text wrapping work.
	 * @param str The string to wrap with HTML tags.
	 * @return The wrapped string.
	 */
	private static String wrapHTML(String str)
	{
		return wrapHTML(str, true);
	}

	/**
	 * Wraps the given string in HTML tags.
	 * @param str The string to wrap with HTML tags.
	 * @param escape Whether or not to escape the input string for HTML.
	 * @return The wrapped string.
	 */
	private static String wrapHTML(String str, boolean escape)
	{
		return "<html>"
			+ (escape ? StringEscapeUtils.escapeHtml4(str) : str)
			+ "</html>";
	}

	/**
	 * Replaces {@code NBSP}s in the given string with spaces.
	 * @param lookup The string to sanitize.
	 * @return The sanitized string.
	 */
	private static String sanitize(String lookup)
	{
		return lookup.replace('\u00A0', ' ');
	}

	/**
	 * Checks if the given player name is a valid Jagex name.
	 * @param playerName The player name to check.
	 * @return True if the name is valid, false otherwise.
	 */
	private static boolean isValidPlayerName(String playerName)
	{
		if (playerName == null || playerName.length() > MAX_RSN_LENGTH)
		{
			return false;
		}

		return VALID_RSN_PATTERN.matcher(playerName).matches();
	}

	/**
	 * Gets the {@link Color} to use for the given double value.
	 * @param percent A double representing a percent value from {@code 0.0} to {@code 1.0}.
	 * @return The recommended {@link Color}.
	 */
	private static Color getPercentColor(double percent)
	{
		percent = Doubles.constrainToRange(percent, 0, 1);
		return percent < 0.5 ?
			ColorUtil.colorLerp(Color.RED, Color.YELLOW, percent * 2)
			: ColorUtil.colorLerp(Color.YELLOW, Color.GREEN, (percent - 0.5) * 2);
	}

	/**
	 * Formats the given double into a percent string with two decimal points (ex.: {@code 0.57458 -> 57.46%}).
	 * @param percent The double percent value to format.
	 * @return The formatted percent value.
	 */
	private static String toPercentString(double percent)
	{
		return new DecimalFormat("0.00%").format(percent);
	}

	/**
	 * Wraps the given percent double in a HTML span tag, with color and text format
	 * from {@link #getPercentColor(double)} and {@link #toPercentString(double)} respectively.
	 * @param percent The double percent value to wrap and format.
	 * @return The formatted percent value wrapped in a HTML span tag.
	 */
	private static String toColoredPercentSpan(double percent)
	{
		return String.format("<span style='color:%s'>%s</span>",
			ColorUtil.toHexColor(getPercentColor(percent)),
			toPercentString(percent));
	}

	/**
	 * Creates a HTML table string for the given prediction breakdown map.
	 * @param predictionMap The prediction breakdown map to process.
	 * @return A HTML table string containing the data from the given prediction breakdown map.
	 */
	private static String toPredictionBreakdownString(Map<String, Double> predictionMap)
	{
		if (predictionMap == null || predictionMap.size() == 0)
		{
			return null;
		}

		String openingTags = "<html><body style='margin:0;padding:0;color:"
			+ ColorUtil.toHexColor(TEXT_COLOR) + "'>"
			+ "<table border='0' cellspacing='0' cellpadding='0'>";
		String closingTags = "</table></body></html>";

		StringBuilder sb = new StringBuilder();
		sb.append(openingTags);

		String rowString = "<tr><td>%s:</td><td style='padding-left:5;text-align:right;color:%s'>%s</td></tr>";
		predictionMap.entrySet().stream().filter(e -> e.getValue() > 0)
			.sorted(Map.Entry.<String, Double>comparingByValue().reversed().thenComparing(Map.Entry.comparingByKey()))
			.forEach(e -> sb.append(String.format(rowString,
				normalizeLabel(e.getKey()),
				ColorUtil.toHexColor(getPercentColor(e.getValue())),
				toPercentString(e.getValue()))));

		return sb.append(closingTags).toString();
	}

	/**
	 * Set background and disabledBackground values, the latter such that FlatLaf can catch it.
	 * @param component The component to set the background colors.
	 * @param color The color to set.
	 */
	private static void setBackgroundFlatLaf(JComponent component, Color color)
	{
		component.setBackground(color);
		component.putClientProperty(FlatClientProperties.STYLE,
			color == null ? null : "disabledBackground: " + ColorUtil.toHexColor(color));
	}

	void addInputKeyListener(KeyListener l)
	{
		this.searchBar.addKeyListener(l);
	}

	void removeInputKeyListener(KeyListener l)
	{
		this.searchBar.removeKeyListener(l);
	}
}

/*
 * Copyright (c) 2021, Ferrariic, Seltzer Bro, Cyborger1
 * Copyright (c) 2017, Psikoi <https://github.com/psikoi>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.botdetector.ui.components;

import java.awt.Color;
import java.awt.Component;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.ListCellRenderer;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.ColorScheme;

public final class ComboBoxSelfTextTooltipListRenderer<T> extends JLabel implements ListCellRenderer<T>
{
	@Override
	public Component getListCellRendererComponent(JList<? extends T> list, T o, int index, boolean isSelected, boolean cellHasFocus)
	{
		if (isSelected)
		{
			setBackground(ColorScheme.DARK_GRAY_COLOR);
			setForeground(Color.WHITE);
		}
		else
		{
			setBackground(list.getBackground());
			setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		}

		setBorder(new EmptyBorder(0, 0, 0, 0));

		setText(o.toString());
		setToolTipText(o.toString());

		return this;
	}
}

/*
 * Copyright (c) 2016 under CC BY 3.0, Francisco J. Gemes Sevilla <https://stackoverflow.com/a/14849680>
 * Copyright (c) 2021 under BSD 2, Ferrariic, Seltzer Bro, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.botdetector.ui.components;

import javax.swing.JTextArea;
import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.PlainDocument;

/**
 * An extension of {@link JTextArea} that automatically implements
 * a default {@link Document} model that limits the number of characters
 * that can be entered to the given {@code limit} in {@link #JLimitedTextArea(int)}.
 */
public class JLimitedTextArea extends JTextArea
{
	private final int limit;

	/**
	 * Instanciates a {@link JTextArea} implementing a default {@link Document} model
	 * that limits the number of characters that can be entered.
	 * @param limit The maximum number of characters that can be entered in the underlying {@link JTextArea}.
	 */
	public JLimitedTextArea(int limit)
	{
		super();
		this.limit = limit;
	}

	@Override
	protected Document createDefaultModel()
	{
		return new LimitDocument();
	}

	private class LimitDocument extends PlainDocument
	{
		@Override
		public void insertString( int offset, String  str, AttributeSet attr ) throws BadLocationException
		{
			if (str == null) return;

			if ((getLength() + str.length()) <= limit)
			{
				super.insertString(offset, str, attr);
			}
		}
	}
}

/*
 * Copyright (c) 2021, Ferrariic, Seltzer Bro, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.botdetector.ui;

import java.util.Objects;
import javax.swing.ImageIcon;
import net.runelite.client.util.ImageUtil;

public class Icons
{
	private static final Class<?> PLUGIN_CLASS = BotDetectorPanel.class;

	public static final ImageIcon GITHUB_ICON = new ImageIcon(ImageUtil.loadImageResource(PLUGIN_CLASS, "github.png"));
	public static final ImageIcon DISCORD_ICON = new ImageIcon(ImageUtil.loadImageResource(PLUGIN_CLASS, "discord.png"));
	public static final ImageIcon PATREON_ICON = new ImageIcon(ImageUtil.loadImageResource(PLUGIN_CLASS, "patreon.png"));
	public static final ImageIcon WEB_ICON = new ImageIcon(ImageUtil.loadImageResource(PLUGIN_CLASS, "web.png"));
	public static final ImageIcon TWITTER_ICON = new ImageIcon(ImageUtil.loadImageResource(PLUGIN_CLASS, "twitter.png"));
	public static final ImageIcon WARNING_ICON = new ImageIcon(ImageUtil.loadImageResource(PLUGIN_CLASS, "warning.png"));
	public static final ImageIcon STRONG_WARNING_ICON = new ImageIcon(ImageUtil.loadImageResource(PLUGIN_CLASS, "strong_warning.png"));
	public static final ImageIcon ERROR_ICON = new ImageIcon(ImageUtil.loadImageResource(PLUGIN_CLASS, "error.png"));

	// Must not be ImageUtil.loadImageResource as it produces a static image
	public static final ImageIcon LOADING_SPINNER = new ImageIcon(Objects.requireNonNull(PLUGIN_CLASS.getResource("loading_spinner_darker.gif")));
}

/*
 * Copyright (c) 2018, John Pettenger
 * Copyright (c) 2021, Ferrariic, Seltzer Bro, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.botdetector.ui;

import com.botdetector.BotDetectorConfig;
import com.google.common.collect.EvictingQueue;
import com.google.inject.Inject;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.Arrays;
import java.util.Objects;
import java.util.Optional;
import java.util.regex.Pattern;
import javax.annotation.Nullable;
import javax.inject.Singleton;
import javax.swing.SwingUtilities;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.JTextComponent;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.FriendsChatManager;
import net.runelite.api.Client;
import net.runelite.api.Friend;
import net.runelite.api.Nameable;
import net.runelite.api.NameableContainer;
import net.runelite.api.Player;
import net.runelite.api.WorldView;

@Slf4j
@Singleton
public class NameAutocompleter implements KeyListener
{
	/**
	 * Non-breaking space character.
	 */
	private static final String NBSP = Character.toString((char) 160);

	/**
	 * Character class for characters that cannot be in an RSN.
	 */
	private static final Pattern INVALID_CHARS = Pattern.compile("[^a-zA-Z0-9_ -]");

	private static final int MAX_SEARCH_HISTORY = 25;

	private final Client client;
	private final BotDetectorConfig botDetectorConfig;

	private final EvictingQueue<String> searchHistory = EvictingQueue.create(MAX_SEARCH_HISTORY);

	/**
	 * The name currently being autocompleted.
	 */
	private String autocompleteName;

	/**
	 * Pattern for the name currently being autocompleted.
	 */
	private Pattern autocompleteNamePattern;

	@Inject
	private NameAutocompleter(@Nullable Client client, BotDetectorConfig botDetectorConfig)
	{
		this.client = client;
		this.botDetectorConfig = botDetectorConfig;
	}

	@Override
	public void keyPressed(KeyEvent e)
	{

	}

	@Override
	public void keyReleased(KeyEvent e)
	{

	}

	@Override
	public void keyTyped(KeyEvent e)
	{
		if (!botDetectorConfig.panelAutocomplete())
		{
			return;
		}

		final JTextComponent input = (JTextComponent) e.getSource();
		final String inputText = input.getText();

		// Only autocomplete if the selection end is at the end of the text.
		if (input.getSelectionEnd() != inputText.length())
		{
			return;
		}

		// Character to be inserted at the selection start.
		final String charToInsert = Character.toString(e.getKeyChar());

		// Don't attempt to autocomplete if the name is invalid.
		// This condition is also true when the user presses a key like backspace.
		if (INVALID_CHARS.matcher(charToInsert).find()
			|| INVALID_CHARS.matcher(inputText).find())
		{
			return;
		}

		// Check if we are already autocompleting.
		if (autocompleteName != null && autocompleteNamePattern.matcher(inputText).matches())
		{
			if (isExpectedNext(input, charToInsert))
			{
				try
				{
					// Insert the character and move the selection.
					final int insertIndex = input.getSelectionStart();
					Document doc = input.getDocument();
					doc.remove(insertIndex, 1);
					doc.insertString(insertIndex, charToInsert, null);
					input.select(insertIndex + 1, input.getSelectionEnd());
				}
				catch (BadLocationException ex)
				{
					log.warn("Could not insert character.", ex);
				}

				// Prevent default behavior.
				e.consume();
			}
			else // Character to insert does not match current autocompletion. Look for another name.
			{
				newAutocomplete(e);
			}
		}
		else // Search for a name to autocomplete
		{
			newAutocomplete(e);
		}
	}

	private void newAutocomplete(KeyEvent e)
	{
		final JTextComponent input = (JTextComponent) e.getSource();
		final String inputText = input.getText();
		final String nameStart = inputText.substring(0, input.getSelectionStart()) + e.getKeyChar();

		if (findAutocompleteName(nameStart))
		{
			// Assert this.autocompleteName != null
			final String name = this.autocompleteName;
			SwingUtilities.invokeLater(() ->
			{
				try
				{
					input.getDocument().insertString(
						nameStart.length(),
						name.substring(nameStart.length()),
						null);
					input.select(nameStart.length(), name.length());
				}
				catch (BadLocationException ex)
				{
					log.warn("Could not autocomplete name.", ex);
				}
			});
		}
	}

	private boolean findAutocompleteName(String nameStart)
	{
		final Pattern pattern;
		Optional<String> autocompleteName;

		// Pattern to match names that start with nameStart.
		// Allows spaces to be represented as common whitespaces, underscores,
		// hyphens, or non-breaking spaces.
		// Matching non-breaking spaces is necessary because the API
		// returns non-breaking spaces when a name has whitespace.
		pattern = Pattern.compile(
			"(?i)^" + nameStart.replaceAll("[ _-]", "[ _" + NBSP + "-]") + ".+?");

		if (client == null)
		{
			return false;
		}

		// Search all previous successful queries
		autocompleteName = searchHistory.stream()
			.filter(n -> pattern.matcher(n).matches())
			.findFirst();

		// Search friends if previous searches weren't matched
		if (!autocompleteName.isPresent())
		{
			NameableContainer<Friend> friendContainer = client.getFriendContainer();
			if (friendContainer != null)
			{
				autocompleteName = Arrays.stream(friendContainer.getMembers())
					.map(Nameable::getName)
					.filter(n -> pattern.matcher(n).matches())
					.findFirst();
			}
		}

		// Search friends chat if a friend wasn't found
		if (!autocompleteName.isPresent())
		{
			final FriendsChatManager friendsChatManager = client.getFriendsChatManager();
			if (friendsChatManager != null)
			{
				autocompleteName = Arrays.stream(friendsChatManager.getMembers())
					.map(Nameable::getName)
					.filter(n -> pattern.matcher(n).matches())
					.findFirst();
			}
		}

		// Search cached players if a friend wasn't found
		if (!autocompleteName.isPresent())
		{
			final WorldView wv = client.getTopLevelWorldView();
			if (wv != null)
			{
				autocompleteName = wv.players().stream()
					.filter(Objects::nonNull)
					.map(Player::getName)
					.filter(Objects::nonNull)
					.filter(n -> pattern.matcher(n).matches())
					.findFirst();
			}
		}

		if (autocompleteName.isPresent())
		{
			this.autocompleteName = autocompleteName.get().replace(NBSP, " ");
			this.autocompleteNamePattern = Pattern.compile(
				"(?i)^" + this.autocompleteName.replaceAll("[ _-]", "[ _-]") + "$");
		}
		else
		{
			this.autocompleteName = null;
			this.autocompleteNamePattern = null;
		}

		return autocompleteName.isPresent();
	}

	void addToSearchHistory(@NonNull String name)
	{
		if (!searchHistory.contains(name))
		{
			searchHistory.offer(name);
		}
	}

	private boolean isExpectedNext(JTextComponent input, String nextChar)
	{
		String expected;
		if (input.getSelectionStart() < input.getSelectionEnd())
		{
			try
			{
				expected = input.getText(input.getSelectionStart(), 1);
			}
			catch (BadLocationException ex)
			{
				log.warn("Could not get first character from input selection.", ex);
				return false;
			}
		}
		else
		{
			expected = "";
		}
		return nextChar.equalsIgnoreCase(expected);
	}
}

/*
 * Copyright (c) 2021, Ferrariic, Seltzer Bro, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.botdetector.ui;

public enum PanelFontType
{
	SMALL,
	NORMAL,
	BOLD
}

package com.botdetector;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class BotDetectorPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(BotDetectorPlugin.class);
		RuneLite.main(args);
	}
}

